- en: scipy.signal.place_poles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.place_poles.html#scipy.signal.place_poles](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.place_poles.html#scipy.signal.place_poles)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute K such that eigenvalues (A - dot(B, K))=poles.
  prefs: []
  type: TYPE_NORMAL
- en: K is the gain matrix such as the plant described by the linear system `AX+BU`
    will have its closed-loop poles, i.e the eigenvalues `A - B*K`, as close as possible
    to those asked for in poles.
  prefs: []
  type: TYPE_NORMAL
- en: SISO, MISO and MIMO systems are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A, B**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: State-space representation of linear system `AX + BU`.
  prefs: []
  type: TYPE_NORMAL
- en: '**poles**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Desired real poles and/or complex conjugates poles. Complex poles are only supported
    with `method="YT"` (default).
  prefs: []
  type: TYPE_NORMAL
- en: '**method: {‘YT’, ‘KNV0’}, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which method to choose to find the gain matrix K. One of:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘YT’: Yang Tits'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘KNV0’: Kautsky, Nichols, Van Dooren update method 0'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: See References and Notes for details on the algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol: float, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: After each iteration the determinant of the eigenvectors of `A - B*K` is compared
    to its previous value, when the relative error between these two values becomes
    lower than *rtol* the algorithm stops. Default is 1e-3.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter: int, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations to compute the gain matrix. Default is 30.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**full_state_feedback**Bunch object'
  prefs: []
  type: TYPE_NORMAL
- en: 'full_state_feedback is composed of:'
  prefs: []
  type: TYPE_NORMAL
- en: gain_matrix1-D ndarray
  prefs: []
  type: TYPE_NORMAL
- en: The closed loop matrix K such as the eigenvalues of `A-BK` are as close as possible
    to the requested poles.
  prefs: []
  type: TYPE_NORMAL
- en: computed_poles1-D ndarray
  prefs: []
  type: TYPE_NORMAL
- en: The poles corresponding to `A-BK` sorted as first the real poles in increasing
    order, then the complex congugates in lexicographic order.
  prefs: []
  type: TYPE_NORMAL
- en: requested_poles1-D ndarray
  prefs: []
  type: TYPE_NORMAL
- en: The poles the algorithm was asked to place sorted as above, they may differ
    from what was achieved.
  prefs: []
  type: TYPE_NORMAL
- en: X2-D ndarray
  prefs: []
  type: TYPE_NORMAL
- en: The transfer matrix such as `X * diag(poles) = (A - B*K)*X` (see Notes)
  prefs: []
  type: TYPE_NORMAL
- en: rtolfloat
  prefs: []
  type: TYPE_NORMAL
- en: The relative tolerance achieved on `det(X)` (see Notes). *rtol* will be NaN
    if it is possible to solve the system `diag(poles) = (A - B*K)`, or 0 when the
    optimization algorithms can’t do anything i.e when `B.shape[1] == 1`.
  prefs: []
  type: TYPE_NORMAL
- en: nb_iterint
  prefs: []
  type: TYPE_NORMAL
- en: The number of iterations performed before converging. *nb_iter* will be NaN
    if it is possible to solve the system `diag(poles) = (A - B*K)`, or 0 when the
    optimization algorithms can’t do anything i.e when `B.shape[1] == 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The Tits and Yang (YT), [[2]](#r05297b315da4-2) paper is an update of the original
    Kautsky et al. (KNV) paper [[1]](#r05297b315da4-1). KNV relies on rank-1 updates
    to find the transfer matrix X such that `X * diag(poles) = (A - B*K)*X`, whereas
    YT uses rank-2 updates. This yields on average more robust solutions (see [[2]](#r05297b315da4-2)
    pp 21-22), furthermore the YT algorithm supports complex poles whereas KNV does
    not in its original version. Only update method 0 proposed by KNV has been implemented
    here, hence the name `'KNV0'`.
  prefs: []
  type: TYPE_NORMAL
- en: KNV extended to complex poles is used in Matlab’s `place` function, YT is distributed
    under a non-free licence by Slicot under the name `robpole`. It is unclear and
    undocumented how KNV0 has been extended to complex poles (Tits and Yang claim
    on page 14 of their paper that their method can not be used to extend KNV to complex
    poles), therefore only YT supports them in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As the solution to the problem of pole placement is not unique for MIMO systems,
    both methods start with a tentative transfer matrix which is altered in various
    way to increase its determinant. Both methods have been proven to converge to
    a stable solution, however depending on the way the initial transfer matrix is
    chosen they will converge to different solutions and therefore there is absolutely
    no guarantee that using `'KNV0'` will yield results similar to Matlab’s or any
    other implementation of these algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Using the default method `'YT'` should be fine in most cases; `'KNV0'` is only
    provided because it is needed by `'YT'` in some specific cases. Furthermore `'YT'`
    gives on average more robust results than `'KNV0'` when `abs(det(X))` is used
    as a robustness indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2]](#r05297b315da4-2) is available as a technical report on the following
    URL: [https://hdl.handle.net/1903/5598](https://hdl.handle.net/1903/5598)'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id2),[2](#id7))'
  prefs: []
  type: TYPE_NORMAL
- en: J. Kautsky, N.K. Nichols and P. van Dooren, “Robust pole assignment in linear
    state feedback”, International Journal of Control, Vol. 41 pp. 1129-1155, 1985.
  prefs: []
  type: TYPE_NORMAL
- en: '[2] ([1](#id1),[2](#id3),[3](#id4))'
  prefs: []
  type: TYPE_NORMAL
- en: A.L. Tits and Y. Yang, “Globally convergent algorithms for robust pole assignment
    by state feedback”, IEEE Transactions on Automatic Control, Vol. 41, pp. 1432-1452,
    1996.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example demonstrating real pole placement using both KNV and YT algorithms.
    This is example number 1 from section 4 of the reference KNV publication ([[1]](#r05297b315da4-1)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now compute K with KNV method 0, with the default YT method and with the YT
    method while forcing 100 iterations of the algorithm and print some results after
    each call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The absolute value of the determinant of X is a good indicator to check the
    robustness of the results, both `''KNV0''` and `''YT''` aim at maximizing it.
    Below a comparison of the robustness of the results above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now a simple example for complex poles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can plot the desired and computed poles in the complex plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-place_poles-1.png](../Images/4599dc18bdabf3130cc397c8be1b365e.png)'
  prefs: []
  type: TYPE_IMG
