- en: 'numpy.i: a SWIG Interface File for NumPy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: numpy.i：NumPy的SWIG接口文件
- en: 原文：[https://numpy.org/doc/1.26/reference/swig.interface-file.html](https://numpy.org/doc/1.26/reference/swig.interface-file.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/swig.interface-file.html](https://numpy.org/doc/1.26/reference/swig.interface-file.html)
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: 'The Simple Wrapper and Interface Generator (or [SWIG](http://www.swig.org))
    is a powerful tool for generating wrapper code for interfacing to a wide variety
    of scripting languages. [SWIG](http://www.swig.org) can parse header files, and
    using only the code prototypes, create an interface to the target language. But
    [SWIG](http://www.swig.org) is not omnipotent. For example, it cannot know from
    the prototype:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成适用于各种脚本语言的包装器代码的强大工具——简单包装器和接口生成器（或[SWIG](http://www.swig.org)）。[SWIG](http://www.swig.org)可以解析头文件，并仅使用代码原型，为目标语言创建接口。但[SWIG](http://www.swig.org)并非无所不能。例如，它无法通过原型了解到：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: what exactly `seq` is. Is it a single value to be altered in-place? Is it an
    array, and if so what is its length? Is it input-only? Output-only? Input-output?
    [SWIG](http://www.swig.org) cannot determine these details, and does not attempt
    to do so.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq`到底是什么。它是一个要原地更改的单个值吗？它是一个数组，如果是的话，它的长度是多少？它只能输入吗？只能输出？输入输出？[SWIG](http://www.swig.org)无法确定这些细节，并且也不试图这样做。'
- en: If we designed `rms`, we probably made it a routine that takes an input-only
    array of length `n` of `double` values called `seq` and returns the root mean
    square. The default behavior of [SWIG](http://www.swig.org), however, will be
    to create a wrapper function that compiles, but is nearly impossible to use from
    the scripting language in the way the C routine was intended.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计了`rms`，那么我们可能使其成为一个仅接受名为`seq`的`double`值长度为`n`的输入数组的例程，并返回均方根。然而，[SWIG](http://www.swig.org)的默认行为将是创建一个可编译但几乎无法像C例程预期的那样从脚本语言使用的包装器函数。
- en: 'For Python, the preferred way of handling contiguous (or technically, *strided*)
    blocks of homogeneous data is with NumPy, which provides full object-oriented
    access to multidimensial arrays of data. Therefore, the most logical Python interface
    for the `rms` function would be (including doc string):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python，处理连续（或技术上的*跨度*）块的同质数据的首选方式是使用NumPy，它提供对数据的多维数组的完整面向对象访问。因此，`rms`函数的最合理Python接口应该是（包括文档字符串）：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where `seq` would be a NumPy array of `double` values, and its length `n` would
    be extracted from `seq` internally before being passed to the C routine. Even
    better, since NumPy supports construction of arrays from arbitrary Python sequences,
    `seq` itself could be a nearly arbitrary sequence (so long as each element can
    be converted to a `double`) and the wrapper code would internally convert it to
    a NumPy array before extracting its data and length.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`seq`将是`double`值的NumPy数组，并且它的长度`n`将在传递给C例程之前从内部`seq`中提取。更好的是，由于NumPy支持从任意Python序列构建数组，`seq`本身可以是几乎任意序列（只要每个元素都可以转换为`double`），包装器代码会在提取数据和长度之前将其内部转换为NumPy数组。
- en: '[SWIG](http://www.swig.org) allows these types of conversions to be defined
    via a mechanism called *typemaps*. This document provides information on how to
    use `numpy.i`, a [SWIG](http://www.swig.org) interface file that defines a series
    of typemaps intended to make the type of array-related conversions described above
    relatively simple to implement. For example, suppose that the `rms` function prototype
    defined above was in a header file named `rms.h`. To obtain the Python interface
    discussed above, your [SWIG](http://www.swig.org) interface file would need the
    following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org)允许通过一种称为*typemaps*的机制定义这些类型的转换。本文为您提供了如何使用`numpy.i`，一个[SWIG](http://www.swig.org)接口文件的信息，该文件定义了一系列typemaps，旨在使上面描述的与数组相关的转换类型相对简单地实现。例如，假设上面定义的`rms`函数原型位于名为`rms.h`的头文件中。要获得上述讨论的Python接口，您的[SWIG](http://www.swig.org)接口文件将需要以下内容：'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Typemaps are keyed off a list of one or more function arguments, either by type
    or by type and name. We will refer to such lists as *signatures*. One of the many
    typemaps defined by `numpy.i` is used above and has the signature `(double* IN_ARRAY1,
    int DIM1)`. The argument names are intended to suggest that the `double*` argument
    is an input array of one dimension and that the `int` represents the size of that
    dimension. This is precisely the pattern in the `rms` prototype.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Typemaps是基于一个或多个函数参数列表进行关键化，可以是类型或类型和名称。我们将这些列表称为*签名*。`numpy.i`定义的众多typemap之一被上述使用，具有签名`(double*
    IN_ARRAY1, int DIM1)`。参数名意在表明`double*`参数是一个一维输入数组，`int`代表该维度的大小。这正是`rms`原型中的模式。
- en: Most likely, no actual prototypes to be wrapped will have the argument names
    `IN_ARRAY1` and `DIM1`. We use the [SWIG](http://www.swig.org) `%apply` directive
    to apply the typemap for one-dimensional input arrays of type `double` to the
    actual prototype used by `rms`. Using `numpy.i` effectively, therefore, requires
    knowing what typemaps are available and what they do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，将要包装的实际原型不会有参数名为`IN_ARRAY1`和`DIM1`。我们使用[SWIG](http://www.swig.org)的`%apply`指令将一维`double`类型的输入数组的typemap应用到`rms`实际原型上。因此，有效地使用`numpy.i`需要知道可用的typemap以及它们的作用。
- en: 'A [SWIG](http://www.swig.org) interface file that includes the [SWIG](http://www.swig.org)
    directives given above will produce wrapper code that looks something like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含上述[SWIG](http://www.swig.org)指令的[SWIG](http://www.swig.org)接口文件将生成类似如下的包装器代码：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The typemaps from `numpy.i` are responsible for the following lines of code:
    12–20, 25 and 30\. Line 10 parses the input to the `rms` function. From the format
    string `"O:rms"`, we can see that the argument list is expected to be a single
    Python object (specified by the `O` before the colon) and whose pointer is stored
    in `obj0`. A number of functions, supplied by `numpy.i`, are called to make and
    check the (possible) conversion from a generic Python object to a NumPy array.
    These functions are explained in the section [Helper Functions](#helper-functions),
    but hopefully their names are self-explanatory. At line 12 we use `obj0` to construct
    a NumPy array. At line 17, we check the validity of the result: that it is non-null
    and that it has a single dimension of arbitrary length. Once these states are
    verified, we extract the data buffer and length in lines 19 and 20 so that we
    can call the underlying C function at line 22\. Line 25 performs memory management
    for the case where we have created a new array that is no longer needed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i`中的typemaps负责以下代码行：12–20，25和30。第10行解析了传递给`rms`函数的输入。从格式字符串`"O:rms"`，我们可以看到参数列表预期是一个单一的Python对象（由冒号前的`O`指定），它的指针存储在`obj0`中。许多由`numpy.i`提供的函数被调用以完成并验证从通用Python对象到NumPy数组的（可能的）转换。这些函数在[Helper
    Functions](#helper-functions)部分中有解释，但希望它们的名称是不言自明的。在第12行，我们使用`obj0`构造一个NumPy数组。在第17行，我们检查结果的有效性：非空且具有任意长度的单一维度。一旦这些状态验证通过，我们在第19和20行提取数据缓冲区和长度，以便在第22行调用底层C函数。第25行处理了在创建一个不再需要的新数组时的内存管理。'
- en: This code has a significant amount of error handling. Note the `SWIG_fail` is
    a macro for `goto fail`, referring to the label at line 28\. If the user provides
    the wrong number of arguments, this will be caught at line 10\. If construction
    of the NumPy array fails or produces an array with the wrong number of dimensions,
    these errors are caught at line 17\. And finally, if an error is detected, memory
    is still managed correctly at line 30.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含大量的错误处理。请注意，`SWIG_fail`是一个宏，用于引用第28行处的标签`goto fail`。如果用户提供了错误数量的参数，它会在第10行捕捉到。如果构建NumPy数组失败或生成具有错误维度数量的数组，则在第17行捕捉到这些错误。最后，如果检测到错误，则在第30行仍管理内存。
- en: 'Note that if the C function signature was in a different order:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果C函数签名的顺序不同：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'that [SWIG](http://www.swig.org) would not match the typemap signature given
    above with the argument list for `rms`. Fortunately, `numpy.i` has a set of typemaps
    with the data pointer given last:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么[SWIG](http://www.swig.org)将无法与给定`rms`参数列表匹配上述typemap签名。幸运的是，`numpy.i`有一组typemap，其中数据指针在最后：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This simply has the effect of switching the definitions of `arg1` and `arg2`
    in lines 3 and 4 of the generated code above, and their assignments in lines 19
    and 20.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是将生成代码中第3和第4行中的`arg1`和`arg2`的定义位置互换的效果，并且将它们在第19和20行的赋值位置也互换。
- en: Using numpy.i
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用numpy.i
- en: The `numpy.i` file is currently located in the `tools/swig` sub-directory under
    the `numpy` installation directory. Typically, you will want to copy it to the
    directory where you are developing your wrappers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`numpy.i` 文件位于 `numpy` 安装目录下的 `tools/swig` 子目录中。通常，您会希望将其复制到您开发包装器的目录中。
- en: 'A simple module that only uses a single [SWIG](http://www.swig.org) interface
    file should include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只使用单个 [SWIG](http://www.swig.org) 接口文件的简单模块应包括以下内容：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within a compiled Python module, `import_array()` should only get called once.
    This could be in a C/C++ file that you have written and is linked to the module.
    If this is the case, then none of your interface files should `#define SWIG_FILE_WITH_INIT`
    or call `import_array()`. Or, this initialization call could be in a wrapper file
    generated by [SWIG](http://www.swig.org) from an interface file that has the `%init`
    block as above. If this is the case, and you have more than one [SWIG](http://www.swig.org)
    interface file, then only one interface file should `#define SWIG_FILE_WITH_INIT`
    and call `import_array()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译的 Python 模块中，`import_array()` 只应调用一次。这可能在你编写并链接到该模块的 C/C++ 文件中。如果是这种情况，那么你的任何接口文件都不应该
    `#define SWIG_FILE_WITH_INIT` 或调用 `import_array()`。或者，这个初始化调用可能在由 [SWIG](http://www.swig.org)
    从具有上述 `%init` 块的接口文件生成的包装文件中。如果是这种情况，并且你有多个 [SWIG](http://www.swig.org) 接口文件，则只有一个接口文件应该
    `#define SWIG_FILE_WITH_INIT` 并调用 `import_array()`。
- en: Available Typemaps
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的类型映射
- en: 'The typemap directives provided by `numpy.i` for arrays of different data types,
    say `double` and `int`, and dimensions of different types, say `int` or `long`,
    are identical to one another except for the C and NumPy type specifications. The
    typemaps are therefore implemented (typically behind the scenes) via a macro:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `numpy.i` 提供的针对不同数据类型（如 `双精度浮点型` 和 `整型`）和维度不同类型（如 `整型` 或 `长整型`）的数组���类型映射指令，除了
    C 和 NumPy 类型规格外，是相同的。因此，这些类型映射是通过宏实现的（通常是在幕后）：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'that can be invoked for appropriate `(DATA_TYPE, DATA_TYPECODE, DIM_TYPE)`
    triplets. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为适当的 `(数据类型, 数据类型代码, DIM_TYPE)` 组合调用。例如：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `numpy.i` interface file uses the `%numpy_typemaps` macro to implement
    typemaps for the following C data types and `int` dimension types:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 接口文件使用 `%numpy_typemaps` 宏来为以下 C 数据类型和 `int` 维度类型实现类型映射：'
- en: '`signed char`'
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`有符号字符`'
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned char`'
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号字符`'
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`short`'
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`短整型`'
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned short`'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号短整型`'
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int`'
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`整型`'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned int`'
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号整型`'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long`'
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`长整型`'
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long`'
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号长整型`'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long long`'
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`长长整型`'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long long`'
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无符号长长整型`'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`float`'
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`单精度浮点型`'
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`double`'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`双精度浮点型`'
- en: In the following descriptions, we reference a generic `DATA_TYPE`, which could
    be any of the C data types listed above, and `DIM_TYPE` which should be one of
    the many types of integers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下描述中，我们引用了一个通用的 `数据类型`，它可以是上面列出的任何 C 数据类型之一，以及 `DIM_TYPE`，应该是多种类型中的其中一种。
- en: The typemap signatures are largely differentiated on the name given to the buffer
    pointer. Names with `FARRAY` are for Fortran-ordered arrays, and names with `ARRAY`
    are for C-ordered (or 1D arrays).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型映射签名在缓冲指针的名称上有很大的不同。带有 `FARRAY` 的名称用于 Fortran 排序数组，而带有 `ARRAY` 的名称用于 C 排序（或
    1D 数组）。
- en: Input Arrays
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数组
- en: Input arrays are defined as arrays of data that are passed into a routine but
    are not altered in-place or returned to the user. The Python input array is therefore
    allowed to be almost any Python sequence (such as a list) that can be converted
    to the requested type of array. The input array signatures are
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组被定义为传入例程但不在原地更改或返回给用户的数据数组。因此，Python 输入数组几乎可以是任何可以转换为请求类型的数组的 Python 序列（如列表）。输入数组签名为
- en: '1D:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE IN_ARRAY1[ANY] )`'
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 IN_ARRAY1[任意] )`'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY1, int DIM1 )`'
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* IN_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* IN_ARRAY1 )`'
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, 数据类型* IN_ARRAY1 )`'
- en: '2D:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE IN_ARRAY2[ANY][ANY] )`'
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 IN_ARRAY2[任意][任意] )`'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* IN_ARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_ARRAY2 )`'
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, 数据类型* IN_ARRAY2 )`'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* IN_FARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_FARRAY2 )`'
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, 数据类型* IN_FARRAY2 )`'
- en: '3D:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE IN_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 IN_ARRAY3[任意][任意][任意] )`'
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_ARRAY3 )`'
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, 数据类型* IN_ARRAY3 )`'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_FARRAY3 )`'
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, 数据类型* IN_FARRAY3 )`'
- en: '4D:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型 IN_ARRAY4[任意][任意][任意][任意])`'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型* IN_ARRAY4, 维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4)`'
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    IN_ARRAY4)`'
  id: totrans-115
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(维度类型 维度1, 维度类型 维度2, 维度类型 维度3, , 维度类型 维���4, 数据类型* IN_ARRAY4)`'
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型* IN_FARRAY4, 维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4)`'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)`'
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4, 数据类型* IN_FARRAY4)`'
- en: The first signature listed, `( DATA_TYPE IN_ARRAY[ANY] )` is for one-dimensional
    arrays with hard-coded dimensions. Likewise, `( DATA_TYPE IN_ARRAY2[ANY][ANY]
    )` is for two-dimensional arrays with hard-coded dimensions, and similarly for
    three-dimensional.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所列的第一个签名 `( 数据类型 IN_ARRAY[任意] )` 是用于具有硬编码维度的一维数组。同样，`( 数据类型 IN_ARRAY2[任意][任意]
    )` 用于具有硬编码维度的二维数组，以此类推和三维数组。
- en: In-Place Arrays
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 就地数组
- en: In-place arrays are defined as arrays that are modified in-place. The input
    values may or may not be used, but the values at the time the function returns
    are significant. The provided Python argument must therefore be a NumPy array
    of the required type. The in-place signatures are
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就地数组被定义为原地修改的数组。输入值可能会被使用，也可能不会被使用，但函数返回时的值是重要的。因此，提供的Python参数必须是所需类型的NumPy数组。就地签名为
- en: '1D:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE INPLACE_ARRAY1[ANY] )`'
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 INPLACE_ARRAY1[任意] )`'
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY1, int DIM1 )`'
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* INPLACE_ARRAY1, int 维度1 )`'
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* INPLACE_ARRAY1 )`'
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int 维度1, 数据类型* INPLACE_ARRAY1 )`'
- en: '2D:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE INPLACE_ARRAY2[ANY][ANY] )`'
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 INPLACE_ARRAY2[任意][任意] )`'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* INPLACE_ARRAY2, int 维度1, int 维度2 )`'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_ARRAY2 )`'
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int 维度1, int 维度2, 数据类型* INPLACE_ARRAY2 )`'
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* INPLACE_FARRAY2, int 维度1, int 维度2 )`'
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_FARRAY2 )`'
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int 维度1, int 维度2, 数据类型* INPLACE_FARRAY2 )`'
- en: '3D:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型 INPLACE_ARRAY3[任意][任意][任意] )`'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* INPLACE_ARRAY3, int 维度1, int 维度2, int 维度3 )`'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_ARRAY3 )`'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int 维度1, int 维度2, int 维度3, 数据类型* INPLACE_ARRAY3 )`'
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( 数据类型* INPLACE_FARRAY3, int 维度1, int 维度2, int 维度3 )`'
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_FARRAY3 )`'
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int 维度1, int 维度2, int 维度3, 数据类型* INPLACE_FARRAY3 )`'
- en: '4D:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型 INPLACE_ARRAY4[任意][任意][任意][任意])`'
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型* INPLACE_ARRAY4, 维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4)`'
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    INPLACE_ARRAY4)`'
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(维度类型 维度1, 维度类型 维度2, 维度类型 维度3, , 维度类型 维度4, 数据类型* INPLACE_ARRAY4)`'
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3,
    DIM_TYPE DIM4)`'
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型* INPLACE_FARRAY4, 维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4)`'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)`'
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(维度类型 维度1, 维度类型 维度2, 维度类型 维度3, 维度类型 维度4, 数据类型* INPLACE_FARRAY4)`'
- en: These typemaps now check to make sure that the `INPLACE_ARRAY` arguments use
    native byte ordering. If not, an exception is raised.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型映射现在会检查`INPLACE_ARRAY`参数是否使用本机字节顺序。如果不是，则会引发异常。
- en: There is also a “flat” in-place array for situations in which you would like
    to modify or process each element, regardless of the number of dimensions. One
    example is a “quantization” function that quantizes each element of an array in-place,
    be it 1D, 2D or whatever. This form checks for continuity but allows either C
    or Fortran ordering.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种“flat”就地数组，适用于无论维度如何都想修改或处理每个元素的情况。一个例子是“量化”函数，在此函数中，对数组的每个元素进行原地量化处理，无论是
    1D、2D 还是其他。此形式会检查连续性，但允许C或Fortran排序。
- en: 'ND:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'ND:'
- en: '`(DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)`'
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型* INPLACE_ARRAY_FLAT, 维度类型 维度FLAT)`'
- en: Argout Arrays
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数组
- en: Argout arrays are arrays that appear in the input arguments in C, but are in
    fact output arrays. This pattern occurs often when there is more than one output
    variable and the single return argument is therefore not sufficient. In Python,
    the conventional way to return multiple arguments is to pack them into a sequence
    (tuple, list, etc.) and return the sequence. This is what the argout typemaps
    do. If a wrapped function that uses these argout typemaps has more than one return
    argument, they are packed into a tuple or list, depending on the version of Python.
    The Python user does not pass these arrays in, they simply get returned. For the
    case where a dimension is specified, the python user must provide that dimension
    as an argument. The argout signatures are
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Argout 数组是在 C 中作为输入参数出现的数组，但实际上是输出数组。这种模式经常在存在多个输出变量且单个返回参数因此不足够时发生。在 Python
    中，返回多个参数的常规方法是将它们打包到一个序列（元组、列表等）中并返回该序列。这就是 argout 类型映射的作用。如果使用这些 argout 类型映射的包装函数具有多个返回参数，则它们将被打包到一个元组或列表中，具体取决于
    Python 的版本。Python 用户不需要传入这些数组，它们只会被返回。对于指定维度的情况，Python 用户必须将该维度作为参数提供。argout 签名为
- en: '1D:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 1D：
- en: '`( DATA_TYPE ARGOUT_ARRAY1[ANY] )`'
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE ARGOUT_ARRAY1[ANY])`'
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* ARGOUT_ARRAY1, int DIM1 )`'
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* ARGOUT_ARRAY1，int DIM1)`'
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* ARGOUT_ARRAY1 )`'
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int DIM1，DATA_TYPE* ARGOUT_ARRAY1)`'
- en: '2D:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 2D：
- en: '`( DATA_TYPE ARGOUT_ARRAY2[ANY][ANY] )`'
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE ARGOUT_ARRAY2[ANY][ANY])`'
- en: '3D:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 3D：
- en: '`( DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY])`'
- en: '4D:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 4D：
- en: '`( DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY] )`'
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY])`'
- en: These are typically used in situations where in C/C++, you would allocate a(n)
    array(s) on the heap, and call the function to fill the array(s) values. In Python,
    the arrays are allocated for you and returned as new array objects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常用于在 C/C++ 中分配堆上的数组，并调用函数来填充数组的值的情况。在 Python 中，这些数组会为您分配并作为新数组对象返回。
- en: Note that we support `DATA_TYPE*` argout typemaps in 1D, but not 2D or 3D. This
    is because of a quirk with the [SWIG](http://www.swig.org) typemap syntax and
    cannot be avoided. Note that for these types of 1D typemaps, the Python function
    will take a single argument representing `DIM1`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们支持 1D 中的 `DATA_TYPE*` argout 类型映射，但不支持 2D 或 3D。这是由于 [SWIG](http://www.swig.org)
    类型映射语法的一个怪癖，无法避免。请注意，对于这些类型的 1D 类型映射，Python 函数将接受表示 `DIM1` 的单个参数。
- en: Argout View Arrays
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Argout 视图数组
- en: Argoutview arrays are for when your C code provides you with a view of its internal
    data and does not require any memory to be allocated by the user. This can be
    dangerous. There is almost no way to guarantee that the internal data from the
    C code will remain in existence for the entire lifetime of the NumPy array that
    encapsulates it. If the user destroys the object that provides the view of the
    data before destroying the NumPy array, then using that array may result in bad
    memory references or segmentation faults. Nevertheless, there are situations,
    working with large data sets, where you simply have no other choice.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Argoutview 数组用于在 C 代码中提供内部数据视图而不需要用户分配任何内存的情况。这可能是危险的。几乎没有办法保证 C 代码的内部数据在封装它的
    NumPy 数组的整个生命周期内都保持存在。如果用户在销毁提供数据视图的对象之前销毁了 NumPy 数组，那么使用该数组可能导致错误的内存引用或分段错误。尽管如此，在处理大型数据集的情况下，有时您别无选择。
- en: 'The C code to be wrapped for argoutview arrays are characterized by pointers:
    pointers to the dimensions and double pointers to the data, so that these values
    can be passed back to the user. The argoutview typemap signatures are therefore'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要包装 Argoutview 数组的 C 代码的特征是指针：指向维度和指向数据的双指针，以便这些值可以回传给用户。因此，argoutview 类型映射的签名为
- en: '1D:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 1D：
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY1, DIM_TYPE* DIM1 )`'
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(数据类型** ARGOUTVIEW_ARRAY1，DIM_TYPE* DIM1)`'
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEW_ARRAY1 )`'
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1，DATA_TYPE** ARGOUTVIEW_ARRAY1)`'
- en: '2D:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 2D：
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_ARRAY2，DIM_TYPE* DIM1，DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_ARRAY2 )`'
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1，DIM_TYPE* DIM2，DATA_TYPE** ARGOUTVIEW_ARRAY2)`'
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_FARRAY2，DIM_TYPE* DIM1，DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_FARRAY2 )`'
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1，DIM_TYPE* DIM2，DATA_TYPE** ARGOUTVIEW_FARRAY2)`'
- en: '3D:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 3D：
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_ARRAY3，DIM_TYPE* DIM1，DIM_TYPE* DIM2，DIM_TYPE* DIM3)`'
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_ARRAY3)`'
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1，DIM_TYPE* DIM2，DIM_TYPE* DIM3，DATA_TYPE** ARGOUTVIEW_ARRAY3)`'
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)`'
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)`'
- en: '4D:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_ARRAY4)`'
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_ARRAY4)`'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_FARRAY4)`'
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_FARRAY4)`'
- en: Note that arrays with hard-coded dimensions are not supported. These cannot
    follow the double pointer signatures of these typemaps.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持具有硬编码维度的数组。这些无法遵循这些类型映射的双指针签名。
- en: Memory Managed Argout View Arrays
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理 Argout 视图数组
- en: A recent addition to `numpy.i` are typemaps that permit argout arrays with views
    into memory that is managed. See the discussion [here](http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 的最新补充是允许 argout 数组使用受管理内存视图的类型映射。请参见[此处](http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory)的讨论。'
- en: '1D:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)`'
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)`'
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)`'
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)`'
- en: '2D:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)`'
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)`'
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)`'
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)`'
- en: '3D:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)`'
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)`'
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)`'
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)`'
- en: '4D:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_ARRAY4)`'
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_ARRAY4)`'
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_FARRAY4)`'
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_FARRAY4)`'
- en: Output Arrays
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数组
- en: 'The `numpy.i` interface file does not support typemaps for output arrays, for
    several reasons. First, C/C++ return arguments are limited to a single value.
    This prevents obtaining dimension information in a general way. Second, arrays
    with hard-coded lengths are not permitted as return arguments. In other words:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 接口文件不支持输出数组的类型映射,原因有几个。首先,C/C++ 返回参数限制为单个值。这阻碍了以通用方式获取维度信息。其次,不允许作为返回参数使用硬编码长度的数组。换句话说:'
- en: '[PRE9]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'is not legal C/C++ syntax. Therefore, we cannot provide typemaps of the form:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '这不是合法的 C/C++ 语法。因此,我们无法提供以下形式的类型映射:'
- en: '[PRE10]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you run into a situation where a function or method is returning a pointer
    to an array, your best bet is to write your own version of the function to be
    wrapped, either with `%extend` for the case of class methods or `%ignore` and
    `%rename` for the case of functions.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到一个函数或方法返回指向数组的指针的情况,您最好的选择是编写自己的版本的函数来包装,可以是使用 `%extend` 对于类方法的情况,或使用 `%ignore`
    和 `%rename` 对于函数的情况。
- en: 'Other Common Types: bool'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '其他常见类型: bool'
- en: 'Note that C++ type `bool` is not supported in the list in the [Available Typemaps](#available-typemaps)
    section. NumPy bools are a single byte, while the C++ `bool` is four bytes (at
    least on my system). Therefore:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意,C++ 类型 `bool` 在[可用类型映射](#available-typemaps)部分的列表中不受支持。NumPy 布尔值是单个字节,而
    C++ `bool` 是四个字节(至少在我的系统上是这样)。因此:'
- en: '[PRE11]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'will result in typemaps that will produce code that reference improper data
    lengths. You can implement the following macro expansion:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致产生引用不正确数据长度的代码的 typemaps。你可以实现以下的宏展开：
- en: '[PRE12]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to fix the data length problem, and [Input Arrays](#input-arrays) will work
    fine, but [In-Place Arrays](#in-place-arrays) might fail type-checking.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决数据长度的问题，[输入数组](#input-arrays)会很好地运作，但是[原地数组](#in-place-arrays)可能会失败类型检查。
- en: 'Other Common Types: complex'
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见类型：复杂
- en: 'Typemap conversions for complex floating-point types is also not supported
    automatically. This is because Python and NumPy are written in C, which does not
    have native complex types. Both Python and NumPy implement their own (essentially
    equivalent) `struct` definitions for complex variables:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂浮点类型的 typemap 转换也不会自动支持。这是因为 Python 和 NumPy 是用 C 编写的，而 C 没有原生的复杂类型。Python
    和 NumPy 都实现了它们自己的（本质上等效的）`struct` 定义用于复杂变量：
- en: '[PRE13]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could have implemented:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以实现的是：
- en: '[PRE14]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: which would have provided automatic type conversions for arrays of type `Py_complex`,
    `npy_cfloat` and `npy_cdouble`. However, it seemed unlikely that there would be
    any independent (non-Python, non-NumPy) application code that people would be
    using [SWIG](http://www.swig.org) to generate a Python interface to, that also
    used these definitions for complex types. More likely, these application codes
    will define their own complex types, or in the case of C++, use `std::complex`.
    Assuming these data structures are compatible with Python and NumPy complex types,
    `%numpy_typemap` expansions as above (with the user’s complex type substituted
    for the first argument) should work.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 它本可以提供自动转换为 `Py_complex`、`npy_cfloat` 和 `npy_cdouble` 类型数组的 typemap。然而，不太可能会有任何独立（非
    Python，非 NumPy）应用代码，人们会使用[SWIG](http://www.swig.org) 生成一个 Python 接口，该接口还使用这些复杂类型的定义。更可能的是，这些应用代码将定义自己的复杂类型，或者在
    C++ 中使用 `std::complex`。假设这些数据结构与 Python 和 NumPy 复杂类型兼容，像上面的 `%numpy_typemap` 展开（将用户的复杂类型替换为第一个参数）应该可以工作。
- en: NumPy Array Scalars and SWIG
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组标量和 SWIG
- en: '[SWIG](http://www.swig.org) has sophisticated type checking for numerical types.
    For example, if your C/C++ routine expects an integer as input, the code generated
    by [SWIG](http://www.swig.org) will check for both Python integers and Python
    long integers, and raise an overflow error if the provided Python integer is too
    big to cast down to a C integer. With the introduction of NumPy scalar arrays
    into your Python code, you might conceivably extract an integer from a NumPy array
    and attempt to pass this to a [SWIG](http://www.swig.org)-wrapped C/C++ function
    that expects an `int`, but the [SWIG](http://www.swig.org) type checking will
    not recognize the NumPy array scalar as an integer. (Often, this does in fact
    work – it depends on whether NumPy recognizes the integer type you are using as
    inheriting from the Python integer type on the platform you are using. Sometimes,
    this means that code that works on a 32-bit machine will fail on a 64-bit machine.)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org) 对于数字类型有复杂的类型检查。例如，如果你的 C/C++ 程序期望一个整数作为输入，[SWIG](http://www.swig.org)
    生成的代码将同时检查 Python 整数和 Python 长整数，并且如果提供的 Python 整数太大而无法缩小成 C 整数时将引发溢出错误。通过在你的
    Python 代码中引入 NumPy 标量数组，你可能会从 NumPy 数组中提取一个整数并尝试将其传递给一个期望 `int` 的[SWIG](http://www.swig.org)
    封装的 C/C++ 函数，但是[SWIG](http://www.swig.org) 的类型检查不会将 NumPy 数组标量识别为整数。（通常，这确实可行
    - 这取决于 NumPy 是否在使用平台上将你正在使用的整数类型识别为继承自 Python 整数类型。有时候，这意味着在 32 位机器上运行的代码在 64
    位机器上会失败。）'
- en: 'If you get a Python error that looks like the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个看起来像下面这样的 Python 错误：
- en: '[PRE15]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'and the argument you are passing is an integer extracted from a NumPy array,
    then you have stumbled upon this problem. The solution is to modify the [SWIG](http://www.swig.org)
    type conversion system to accept NumPy array scalars in addition to the standard
    integer types. Fortunately, this capability has been provided for you. Simply
    copy the file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递的参数是从 NumPy 数组中提取的整数，并且你遇到了这个问题。解决方法是修改[SWIG](http://www.swig.org) 类型转换系统，以接受
    NumPy 数组标量，除了标准整数类型之外。幸运的是，这个功能已经为你提供。只需要复制文件：
- en: '[PRE16]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: to the working build directory for you project, and this problem will be fixed.
    It is suggested that you do this anyway, as it only increases the capabilities
    of your Python interface.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 到项目的工作构建目录中，这个问题将会被解决。建议无论如何都这样做，因为这只会增加你的 Python 接口的功能。
- en: Why is There a Second File?
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么会有第二个文件？
- en: The [SWIG](http://www.swig.org) type checking and conversion system is a complicated
    combination of C macros, [SWIG](http://www.swig.org) macros, [SWIG](http://www.swig.org)
    typemaps and [SWIG](http://www.swig.org) fragments. Fragments are a way to conditionally
    insert code into your wrapper file if it is needed, and not insert it if not needed.
    If multiple typemaps require the same fragment, the fragment only gets inserted
    into your wrapper code once.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org)的类型检查和转换系统是C宏、[SWIG](http://www.swig.org)宏、[SWIG](http://www.swig.org)类型映射和[SWIG](http://www.swig.org)片段的复杂组合。片段是一种在需要时有条件地将代码插入包装文件中的方法，并且如果不需要则不插入。如果多个类型映射需要相同的片段，则该片段只会在包装代码中插入一次。'
- en: There is a fragment for converting a Python integer to a C `long`. There is
    a different fragment that converts a Python integer to a C `int`, that calls the
    routine defined in the `long` fragment. We can make the changes we want here by
    changing the definition for the `long` fragment. [SWIG](http://www.swig.org) determines
    the active definition for a fragment using a “first come, first served” system.
    That is, we need to define the fragment for `long` conversions prior to [SWIG](http://www.swig.org)
    doing it internally. [SWIG](http://www.swig.org) allows us to do this by putting
    our fragment definitions in the file `pyfragments.swg`. If we were to put the
    new fragment definitions in `numpy.i`, they would be ignored.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用于将Python整数转换为C `long`的片段。还有一个将Python整数转换为C `int`的不同片段，并调用`long`片段中定义的例程。我们可以通过更改`long`片段的定义来实现所需的更改。[SWIG](http://www.swig.org)使用“先到先得”系统确定片段的活动定义。也就是说，我们需要在[SWIG](http://www.swig.org)内部执行之前定义`long`转换的片段。通过将我们的片段定义放入文件`pyfragments.swg`中，[SWIG](http://www.swig.org)允许我们这样做。如果我们将新的片段定义放入`numpy.i`中，它们将被忽略。
- en: Helper Functions
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'The `numpy.i` file contains several macros and routines that it uses internally
    to build its typemaps. However, these functions may be useful elsewhere in your
    interface file. These macros and routines are implemented as fragments, which
    are described briefly in the previous section. If you try to use one or more of
    the following macros or functions, but your compiler complains that it does not
    recognize the symbol, then you need to force these fragments to appear in your
    code using:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i`文件包含几个宏和例程，它在内部使用这些内容来构建其类型映射。但是，这些功能在接口文件的其他地方也可能会有用。这些宏和例程被实现为片段，在上一节中简要描述。如果您尝试使用以下一个或多个宏或函数，但是您的编译器抱怨找不到该符号，则您需要使用以下方式强制使这些片段出现在代码中：'
- en: '[PRE17]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: in your [SWIG](http://www.swig.org) interface file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的[SWIG](http://www.swig.org)接口文件中。
- en: Macros
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: '**is_array(a)**'
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**is_array(a)**'
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is non-`NULL` and can be cast to a `PyArrayObject*`.
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`非`NULL`且可以被转换为`PyArrayObject*`，则为真。
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_type(a)**'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_type(a)**'
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer data type code of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a`的整数数据类型代码的值，假设`a`可以被转换为`PyArrayObject*`。'
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_numdims(a)**'
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_numdims(a)**'
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer number of dimensions of `a`, assuming `a` can be cast
    to a `PyArrayObject*`.
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a`的维度数目的整数值，假设`a`可以被转换为`PyArrayObject*`。'
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_dimensions(a)**'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_dimensions(a)**'
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the lengths of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评估为类型为`npy_intp`且长度为`array_numdims(a)`的数组，给出`a`的所有维度的长度，假设`a`可以被转换为`PyArrayObject*`。
- en: ''
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_size(a,i)**'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_size(a,i)**'
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th dimension size of `a`, assuming `a` can be cast to a
    `PyArrayObject*`.
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a`的`i`维度大小的值，假设`a`可以被转换为`PyArrayObject*`。'
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_strides(a)**'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_strides(a)**'
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the stridess of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
    A stride is the distance in bytes between an element and its immediate neighbor
    along the same axis.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评估为类型为`npy_intp`且长度为`array_numdims(a)`的数组，给出`a`的所有维度的步长，假设`a`可以被转换为`PyArrayObject*`。步长是元素与沿着相同轴的相邻元素之间的字节距离。
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_stride(a,i)**'
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_stride(a,i)**'
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th stride of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a`的第`i`个步长的值，假设`a`可以被转换为`PyArrayObject*`。'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_data(a)**'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_data(a)**'
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to a pointer of type `void*` that points to the data buffer of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 评估为指向`a`的数据缓冲区的`void*`类型的指针，假设`a`可以被转换为`PyArrayObject*`。
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_descr(a)**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_descr(a)**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns a borrowed reference to the dtype property (`PyArray_Descr*`) of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回对`a`的dtype属性（`PyArray_Descr*`）的借用引用，假定`a`可转换为`PyArrayObject*`。
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_flags(a)**'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_flags(a)**'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns an integer representing the flags of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回表示`a`的标志的整数，假定`a`可以转换为`PyArrayObject*`。
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_enableflags(a,f)**'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_enableflags(a,f)**'
- en: ''
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sets the flag represented by `f` of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置`a`的标志（`f`表示）的标志，假设`a`可以转换为`PyArrayObject*`。
- en: ''
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_contiguous(a)**'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_is_contiguous(a)**'
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is a contiguous array. Equivalent to `(PyArray_ISCONTIGUOUS(a))`.
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`是一个连续的数组，则评估为true。等效于`（PyArray_ISCONTIGUOUS(a))`。
- en: ''
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_native(a)**'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_is_native(a)**'
- en: ''
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if the data buffer of `a` uses native byte order. Equivalent
    to `(PyArray_ISNOTSWAPPED(a))`.
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`的数据缓冲区使用本机字节顺序，则评估为true。等效于`（PyArray_ISNOTSWAPPED(a))`。
- en: ''
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_fortran(a)**'
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_is_fortran(a)**'
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is FORTRAN ordered.
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`是FORTRAN排序，则评估为true。
- en: Routines
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例程
- en: '**pytype_string()**'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**pytype_string()**'
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`const char*`
- en: ''
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* py_obj`, a general Python object.'
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* py_obj`，一个一般的Python对象。'
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type of `py_obj`.
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个描述`py_obj`类型的字符串。
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**typecode_string()**'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**typecode_string()**'
- en: ''
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`const char*`
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int typecode`, a NumPy integer typecode.'
  id: totrans-386
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，一个NumPy整数类型代码。'
- en: ''
  id: totrans-387
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-388
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-389
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type corresponding to the NumPy `typecode`.
  id: totrans-390
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个描述与NumPy`typecode`对应的类型的字符串。
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**type_match()**'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**type_match()**'
- en: ''
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-394
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-396
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-397
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int actual_type`, the NumPy typecode of a NumPy array.'
  id: totrans-398
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int actual_type`，NumPy数组的NumPy类型代码。'
- en: ''
  id: totrans-399
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-400
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int desired_type`, the desired NumPy typecode.'
  id: totrans-401
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int desired_type`，期望的NumPy类型代码。'
- en: ''
  id: totrans-402
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure that `actual_type` is compatible with `desired_type`. For example,
    this allows character and byte types, or int and long types, to match. This is
    now equivalent to `PyArray_EquivTypenums()`.
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保`actual_type`与`desired_type`兼容。例如，这允许字符和字节类型，或整数和长整数类型相匹配。现在等同于`PyArray_EquivTypenums()`。
- en: ''
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_no_conversion()**'
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_no_conversion()**'
- en: ''
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-409
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-410
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-411
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-413
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个一般的Python对象。'
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode.'
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，期望的NumPy类型代码。'
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cast `input` to a `PyArrayObject*` if legal, and ensure that it is of type `typecode`.
    If `input` cannot be cast, or the `typecode` is wrong, set a Python error and
    return `NULL`.
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果合法，将`input`转换为`PyArrayObject*`，并确保其为`typecode`类型。如果无法转换`input`，或者`typecode`错误，则设置Python错误并返回`NULL`。
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_allow_conversion()**'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_allow_conversion()**'
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个一般的Python对象。'
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-431
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，结果数组的期望NumPy类型代码。'
- en: ''
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有执行转换，则返回值为0，否则为1。'
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a NumPy array with the given `typecode`. On success, return
    a valid `PyArrayObject*` with the correct type. On failure, the Python error string
    will be set and the routine returns `NULL`.
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将`input`转换为具有给定`typecode`的NumPy数组。成功时，返回一个具有正确类型的有效`PyArrayObject*`。失败时，将设置Python错误字符串，并返回`NULL`。
- en: ''
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_contiguous()**'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**make_contiguous()**'
- en: ''
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-442
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-443
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-444
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-445
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-446
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-448
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-449
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有执行转换，则返回值为0，否则为1。'
- en: ''
  id: totrans-450
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-451
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int min_dims`, minimum allowable dimensions.'
  id: totrans-452
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int min_dims`，最小允许的维度。'
- en: ''
  id: totrans-453
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-454
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int max_dims`, maximum allowable dimensions.'
  id: totrans-455
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int max_dims`，最大允许的维度。'
- en: ''
  id: totrans-456
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-457
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is contiguous. If so, return the input pointer and flag
    it as not a new object. If it is not contiguous, create a new `PyArrayObject*`
    using the original data, flag it as a new object and return the pointer.
  id: totrans-459
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查`ary`是否是连续的。如果是，返回输入指针并标记为不是新对象。如果不是连续的，使用原始数据创建一个新的`PyArrayObject*`，将其标记为新对象并返回指针。
- en: ''
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_fortran()**'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**make_fortran()**'
- en: ''
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-463
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arguments
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-470
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有执行转换，则返回值为0，否则为1。'
- en: ''
  id: totrans-471
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is Fortran contiguous. If so, return the input pointer
    and flag it as not a new object. If it is not Fortran contiguous, create a new
    `PyArrayObject*` using the original data, flag it as a new object and return the
    pointer.
  id: totrans-474
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查`ary`是否是Fortran连续的。如果是，则返回输入指针，并将其标记为非新对象。如果它不是Fortran连续的，则使用原始数据创建一个新的`PyArrayObject*`，将其标记为新对象，并返回指针。
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_contiguous_allow_conversion()**'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_contiguous_allow_conversion()**'
- en: ''
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-478
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-481
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-482
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的Python对象。'
- en: ''
  id: totrans-483
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-484
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-485
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所得数组的所需NumPy类型代码。'
- en: ''
  id: totrans-486
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-487
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-488
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行任何转换，则返回0，否则返回1。'
- en: ''
  id: totrans-489
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-490
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a contiguous `PyArrayObject*` of the specified type. If the
    input object is not a contiguous `PyArrayObject*`, a new one will be created and
    the new object flag will be set.
  id: totrans-492
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将`input`转换为所需类型的连续`PyArrayObject*`。如果输入对象不是连续的`PyArrayObject*`，则将创建一个新的对象并设置新对象标志。
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_fortran_allow_conversion()**'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_fortran_allow_conversion()**'
- en: ''
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-496
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-497
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-498
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-500
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的Python对象。'
- en: ''
  id: totrans-501
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-502
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-503
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所得数组的所需NumPy类型代码。'
- en: ''
  id: totrans-504
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-505
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-506
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行任何转换，则返回0，否则返回1。'
- en: ''
  id: totrans-507
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-508
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-509
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a Fortran contiguous `PyArrayObject*` of the specified type.
    If the input object is not a Fortran contiguous `PyArrayObject*`, a new one will
    be created and the new object flag will be set.
  id: totrans-510
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将`input`转换为所需类型的Fortran连续`PyArrayObject*`。如果输入对象不是Fortran连续的`PyArrayObject*`，则将创建一个新的对象并设置新对象标志。
- en: ''
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_contiguous()**'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_contiguous()**'
- en: ''
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-514
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-515
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-516
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-517
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-518
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-519
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-521
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test whether `ary` is contiguous. If so, return 1\. Otherwise, set a Python
    error and return 0.
  id: totrans-522
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查`ary`是否是连续的。如果是，则返回1。否则，设置Python错误并返回0。
- en: ''
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_native()**'
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_native()**'
- en: ''
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-526
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-527
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-528
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArray_Object* ary`, a NumPy array.'
  id: totrans-530
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArray_Object* ary`，一个NumPy数组。'
- en: ''
  id: totrans-531
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-532
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-533
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require that `ary` is not byte-swapped. If the array is not byte-swapped, return
    1\. Otherwise, set a Python error and return 0.
  id: totrans-534
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要求`ary`不是字节交换的。如果数组没有字节交换，则返回1。否则，设置Python错误并返回0。
- en: ''
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions()**'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_dimensions()**'
- en: ''
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-538
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-539
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-540
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-541
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-542
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-543
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-544
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int exact_dimensions`, the desired number of dimensions.'
  id: totrans-545
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int exact_dimensions`，所需的维度数。'
- en: ''
  id: totrans-546
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-547
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-548
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified number of dimensions. If the array has the
    specified number of dimensions, return 1. Otherwise, set a Python error and return
    0.
  id: totrans-549
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要求`ary`有指定的维数。如果数组具有指定的维数，则返回1。否则，设置Python错误并返回0。
- en: ''
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions_n()**'
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_dimensions_n()**'
- en: ''
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-553
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-554
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-555
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-556
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-557
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-558
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-559
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* exact_dimensions`, an array of integers representing acceptable numbers
    of dimensions.'
  id: totrans-560
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* exact_dimensions`，表示可接受维度数量的整数数组。'
- en: ''
  id: totrans-561
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `exact_dimensions`.'
  id: totrans-563
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int n`，`exact_dimensions`的长度。'
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-565
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have one of a list of specified number of dimensions. If the
    array has one of the specified number of dimensions, return 1\. Otherwise, set
    the Python error string and return 0.
  id: totrans-567
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要求`ary`具有指定数量的维度之一。如果数组具有指定数量的维度之一，则返回1。否则，设置Python错误字符串并返回0。
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_size()**'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_size()**'
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-571
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-572
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-575
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-576
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-577
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npy_int* size`, an array representing the desired lengths of each dimension.'
  id: totrans-578
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npy_int* size`，表示每个维度的所需长度的数组。'
- en: ''
  id: totrans-579
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-580
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `size`.'
  id: totrans-581
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int n`，`size`的长度。'
- en: ''
  id: totrans-582
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-583
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-584
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified shape. If the array has the specified shape,
    return 1\. Otherwise, set the Python error string and return 0.
  id: totrans-585
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要求`ary`具有指定的形状。如果数组具有指定的形状，则返回1。否则，设置Python错误字符串并返回0。
- en: ''
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_fortran()**'
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**require_fortran()**'
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-591
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-593
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个NumPy数组。'
- en: ''
  id: totrans-594
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-595
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-596
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require the given `PyArrayObject` to be Fortran ordered. If the `PyArrayObject`
    is already Fortran ordered, do nothing. Else, set the Fortran ordering flag and
    recompute the strides.
  id: totrans-597
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要求给定的`PyArrayObject`是Fortran有序的。如果`PyArrayObject`已经是Fortran有序的，则不做任何处理。否则，设置Fortran排序标志并重新计算步进。
- en: Beyond the Provided Typemaps
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供的类型映射之外的内容
- en: There are many C or C++ array/NumPy array situations not covered by a simple
    `%include "numpy.i"` and subsequent `%apply` directives.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多C或C++数组/NumPy数组的情况没有通过简单的`%include "numpy.i"`和后续的`%apply`指令进行覆盖。
- en: A Common Example
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个常见的例子
- en: 'Consider a reasonable prototype for a dot product function:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个合理的点积函数原型：
- en: '[PRE18]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Python interface that we want is:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的Python接口是：
- en: '[PRE19]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The problem here is that there is one dimension argument and two array arguments,
    and our typemaps are set up for dimensions that apply to a single array (in fact,
    [SWIG](http://www.swig.org) does not provide a mechanism for associating `len`
    with `vec2` that takes two Python input arguments). The recommended solution is
    the following:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是只有一个维度参数和两个数组参数，而且我们的类型映射是针对应用于单个数组的维度的（实际上，[SWIG](http://www.swig.org)不提供一种将`len`与接受两个Python输入参数的`vec2`关联的机制）。推荐的解决方案如下：
- en: '[PRE20]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the header file that contains the prototype for `double dot()` also contains
    other prototypes that you want to wrap, so that you need to `%include` this header
    file, then you will also need a `%ignore dot;` directive, placed after the `%rename`
    and before the `%include` directives. Or, if the function in question is a class
    method, you will want to use `%extend` rather than `%inline` in addition to `%ignore`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含`double dot()`原型的头文件还包含其他你想要包装的原型，以便你需要`%include`这个头文件，那么你还需要一个`%ignore
    dot;`指令，放在`%rename`之后和`%include`之前。或者，如果涉及的函数是一个类方法，除了`%inline`之外，你还需要使用`%extend`，而不是`%ignore`。
- en: '**A note on error handling:** Note that `my_dot` returns a `double` but that
    it can also raise a Python error. The resulting wrapper function will return a
    Python float representation of 0.0 when the vector lengths do not match. Since
    this is not `NULL`, the Python interpreter will not know to check for an error.
    For this reason, we add the `%exception` directive above for `my_dot` to get the
    behavior we want (note that `$action` is a macro that gets expanded to a valid
    call to `my_dot`). In general, you will probably want to write a [SWIG](http://www.swig.org)
    macro to perform this task.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于错误处理的注解：** 注意，`my_dot`返回一个`double`但它也可以引发Python错误。当向量长度不匹配时，得到的包装器函数将返回Python浮点表示为0.0。由于这不是`NULL`，Python解释器将不知道如何检查错误。因此，我们在申请`my_dot`之前添加`%exception`指令以获得我们想要的行为（注意`$action`是一个宏，用于扩展为对`my_dot`的有效调用）。一般来说，你可能希望编写一个[SWIG](http://www.swig.org)宏来执行此任务。'
- en: Other Situations
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他情况
- en: There are other wrapping situations in which `numpy.i` may be helpful when you
    encounter them.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在遇到其他包装情况时，当你遇到它们时，`numpy.i`可能会有所帮助。
- en: 'In some situations, it is possible that you could use the `%numpy_typemaps`
    macro to implement typemaps for your own types. See the [Other Common Types: bool](#other-common-types-bool)
    or [Other Common Types: complex](#other-common-types-complex) sections for examples.
    Another situation is if your dimensions are of a type other than `int` (say `long`
    for example):'
  id: totrans-611
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以使用`%numpy_typemaps`宏为自己的类型实现类型映射。查看[其他常见类型：bool](#other-common-types-bool)或[其他常见类型：complex](#other-common-types-complex)部分以获取示例。另一种情况是，如果你的维度不是`int`类型（例如，是`long`类型）：
- en: ''
  id: totrans-612
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-613
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-614
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-615
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ''
  id: totrans-616
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-617
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the code in `numpy.i` to write your own typemaps. For example, if
    you had a five-dimensional array as a function argument, you could cut-and-paste
    the appropriate four-dimensional typemaps into your interface file. The modifications
    for the fourth dimension would be trivial.
  id: totrans-618
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`numpy.i`中的代码编写自己的类型映射。例如，如果函数参数是一个五维数组，你可以将适当的四维类型映射复制粘贴到你的接口文件中。对于第四维的修改将是微不足道的。
- en: ''
  id: totrans-619
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-620
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, the best approach is to use the `%extend` directive to define new
    methods for your classes (or overload existing ones) that take a `PyObject*` (that
    either is or can be converted to a `PyArrayObject*`) instead of a pointer to a
    buffer. In this case, the helper routines in `numpy.i` can be very useful.
  id: totrans-621
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，最佳方法是使用`%extend`指令为你的类定义新方法（或者重载现有方法），这些方法接受一个`PyObject*`（可以转换为`PyArrayObject*`）而不是指向缓冲区的指针。在这种情况下，`numpy.i`中的辅助工具程序可能非常有用。
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-623
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing typemaps can be a bit nonintuitive. If you have specific questions about
    writing [SWIG](http://www.swig.org) typemaps for NumPy, the developers of `numpy.i`
    do monitor the [Numpy-discussion](/cdn-cgi/l/email-protection#753b0018050c58111c06160006061c1a1b535646424e535640474e5356414d4e050c011d1a1b535641434e1a0712)
    and [Swig-user](/cdn-cgi/l/email-protection#aaf9ddc3cd87dfd9cfd88c89999d918c899f98918c899e9291c6c3d9ded98c899e9c91d9c5dfd8c9cfccc5d8cdcf8c899e9c91c4cfde)
    mail lists.
  id: totrans-624
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写类型映射可能有点不直观。如果您对为 NumPy 编写 [SWIG](http://www.swig.org) 类型映射有具体问题，`numpy.i`
    的开发人员会监视 [Numpy-discussion](/cdn-cgi/l/email-protection#753b0018050c58111c06160006061c1a1b535646424e535640474e5356414d4e050c011d1a1b535641434e1a0712)
    和 [Swig-user](/cdn-cgi/l/email-protection#aaf9ddc3cd87dfd9cfd88c89999d918c899f98918c899e9291c6c3d9ded98c899e9c91d9c5dfd8c9cfccc5d8cdcf8c899e9c91c4cfde)
    邮件列表。
- en: A Final Note
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后说明
- en: 'When you use the `%apply` directive, as is usually necessary to use `numpy.i`,
    it will remain in effect until you tell [SWIG](http://www.swig.org) that it shouldn’t
    be. If the arguments to the functions or methods that you are wrapping have common
    names, such as `length` or `vector`, these typemaps may get applied in situations
    you do not expect or want. Therefore, it is always a good idea to add a `%clear`
    directive after you are done with a specific typemap:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `%apply` 指令时，通常需要使用 `numpy.i`，它会一直有效，直到告诉 [SWIG](http://www.swig.org) 不再需要。如果您要封装的函数或方法的参数具有常见名称，例如
    `length` 或 `vector`，这些类型映射可能会应用于您意料之外或不希望的情况。因此，在完成特定类型映射后，始终最好添加 `%clear` 指令：
- en: '[PRE22]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In general, you should target these typemap signatures specifically where you
    want them, and then clear them after you are done.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应针对特定地方使用这些类型映射签名，然后在使用完成后清除它们。
- en: Summary
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Out of the box, `numpy.i` provides typemaps that support conversion between
    NumPy arrays and C arrays:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`numpy.i` 提供了支持在 NumPy 数组和 C 数组之间进行转换的类型映射：
- en: 'That can be one of 12 different scalar types: `signed char`, `unsigned char`,
    `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `long
    long`, `unsigned long long`, `float` and `double`.'
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以是 12 种不同的标量类型之一：`signed char`、`unsigned char`、`short`、`unsigned short`、`int`、`unsigned
    int`、`long`、`unsigned long`、`long long`、`unsigned long long`、`float` 和 `double`。
- en: ''
  id: totrans-632
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-633
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That support 74 different argument signatures for each data type, including:'
  id: totrans-634
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持每种数据类型的 74 种不同参数签名，包括：
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-636
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.
  id: totrans-637
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一维、二维、三维和四维数组。
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.
  id: totrans-640
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅输入、原地、输出参数、输出参数视图和内存管理的输出参数视图行为。
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer
    specification.
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬编码的维度、数据缓冲区-维度规范和维度-数据缓冲区规范。
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Both C-ordering (“last dimension fastest”) or Fortran-ordering (“first dimension
    fastest”) support for 2D, 3D and 4D arrays.
  id: totrans-646
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 C 排序（“最后一个维度最快”）或 Fortran 排序（“第一个维度最快”）的 2D、3D 和 4D 数组。
- en: 'The `numpy.i` interface file also provides additional tools for wrapper developers,
    including:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 接口文件还为包装开发者提供了额外的工具，包括：'
- en: A [SWIG](http://www.swig.org) macro (`%numpy_typemaps`) with three arguments
    for implementing the 74 argument signatures for the user’s choice of (1) C data
    type, (2) NumPy data type (assuming they match), and (3) dimension type.
  id: totrans-648
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 [SWIG](http://www.swig.org) 宏 (`%numpy_typemaps`)，具有三个参数，用于为用户选择的 (1) C 数据类型、(2)
    NumPy 数据类型（假设它们匹配）和 (3) 维度类型 实现 74 个参数签名。
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-650
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fourteen C macros and fifteen C functions that can be used to write specialized
    typemaps, extensions, or inlined functions that handle cases not covered by the
    provided typemaps. Note that the macros and functions are coded specifically to
    work with the NumPy C/API regardless of NumPy version number, both before and
    after the deprecation of some aspects of the API after version 1.6.
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十四个 C 宏和十五个 C 函数，可用于编写专门的类型映射、扩展或处理提供的类型映射未涵盖的情况的内联函数。请注意，这些宏和函数是专门设计用于与 NumPy
    C/API 一起使用，不管 NumPy 版本号如何，无论 1.6 版本之前和之后的一些 API 弃用后的情况如何。
- en: Introduction
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: 'The Simple Wrapper and Interface Generator (or [SWIG](http://www.swig.org))
    is a powerful tool for generating wrapper code for interfacing to a wide variety
    of scripting languages. [SWIG](http://www.swig.org) can parse header files, and
    using only the code prototypes, create an interface to the target language. But
    [SWIG](http://www.swig.org) is not omnipotent. For example, it cannot know from
    the prototype:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 简单包装器和接口生成器（或 [SWIG](http://www.swig.org)）是一个强大的工具，用于为各种脚本语言生成包装器代码。[SWIG](http://www.swig.org)可以解析头文件，并仅使用代码原型，为目标语言创建接口。但
    [SWIG](http://www.swig.org) 也不是无所不能的。例如，它无法从原型中知道：
- en: '[PRE23]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: what exactly `seq` is. Is it a single value to be altered in-place? Is it an
    array, and if so what is its length? Is it input-only? Output-only? Input-output?
    [SWIG](http://www.swig.org) cannot determine these details, and does not attempt
    to do so.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq`到底是什么。它是一个要就地更改的单个值吗？它是一个数组，如果是的话，它的长度是多少？它只能作为输入吗？输出？输入输出？[SWIG](http://www.swig.org)
    无法确定这些细节，也不会尝试这样做。'
- en: If we designed `rms`, we probably made it a routine that takes an input-only
    array of length `n` of `double` values called `seq` and returns the root mean
    square. The default behavior of [SWIG](http://www.swig.org), however, will be
    to create a wrapper function that compiles, but is nearly impossible to use from
    the scripting language in the way the C routine was intended.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计了`rms`，我们可能会将其设计成一个接受长度为`n`的`double`值数组（称为`seq`）作为输入并返回均方根的常规函数。然而，[SWIG](http://www.swig.org)的默认行为将是创建一个包装函数，可以编译，但几乎无法按照C例程预期的方式从脚本语言中使用。
- en: 'For Python, the preferred way of handling contiguous (or technically, *strided*)
    blocks of homogeneous data is with NumPy, which provides full object-oriented
    access to multidimensial arrays of data. Therefore, the most logical Python interface
    for the `rms` function would be (including doc string):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python，处理连续（或技术上的*跨距*）的同质数据块的首选方式是使用 NumPy，它提供了对数据的多维数组的完全面向对象的访问。因此，`rms`
    函数的最合理的 Python 接口应该是（包括文档字符串）：
- en: '[PRE24]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where `seq` would be a NumPy array of `double` values, and its length `n` would
    be extracted from `seq` internally before being passed to the C routine. Even
    better, since NumPy supports construction of arrays from arbitrary Python sequences,
    `seq` itself could be a nearly arbitrary sequence (so long as each element can
    be converted to a `double`) and the wrapper code would internally convert it to
    a NumPy array before extracting its data and length.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq`将是一个由`double`值组成的NumPy数组，其长度`n`将在传递给C例程之前从`seq`内部提取。更好的是，由于NumPy支持从任意Python序列构建数组，`seq`本身可以是一个几乎任意的序列（只要每个元素都可以转换为`double`），而包装代码将在提取其数据和长度之前在内部将其转换为NumPy数组。'
- en: '[SWIG](http://www.swig.org) allows these types of conversions to be defined
    via a mechanism called *typemaps*. This document provides information on how to
    use `numpy.i`, a [SWIG](http://www.swig.org) interface file that defines a series
    of typemaps intended to make the type of array-related conversions described above
    relatively simple to implement. For example, suppose that the `rms` function prototype
    defined above was in a header file named `rms.h`. To obtain the Python interface
    discussed above, your [SWIG](http://www.swig.org) interface file would need the
    following:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org)允许通过一种称为*typemaps*的机制来定义这些类型的转换。本文档提供了如何使用 `numpy.i`
    的信息，这是一个定义了一系列旨在使上面描述的数组相关转换相对简单实现的 [SWIG](http://www.swig.org) 接口文件。例如，假设上面定义的
    `rms` 函数原型在名为 `rms.h` 的头文件中。要获得上面讨论的 Python 接口，你的 [SWIG](http://www.swig.org)
    接口文件需要包含以下内容：'
- en: '[PRE25]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Typemaps are keyed off a list of one or more function arguments, either by type
    or by type and name. We will refer to such lists as *signatures*. One of the many
    typemaps defined by `numpy.i` is used above and has the signature `(double* IN_ARRAY1,
    int DIM1)`. The argument names are intended to suggest that the `double*` argument
    is an input array of one dimension and that the `int` represents the size of that
    dimension. This is precisely the pattern in the `rms` prototype.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: Typemaps 是根据一个或多个函数参数的列表（按类型或类型和名称）进行匹配的。我们将这样的列表称为*签名*。`numpy.i` 定义的众多 typemap
    之一在上面的代码中使用，其签名为`(double* IN_ARRAY1, int DIM1)`。参数名称旨在建议 `double*` 参数是一个一维输入数组，而
    `int` 表示该维度的大小。这恰好是 `rms` 原型中的模式。
- en: Most likely, no actual prototypes to be wrapped will have the argument names
    `IN_ARRAY1` and `DIM1`. We use the [SWIG](http://www.swig.org) `%apply` directive
    to apply the typemap for one-dimensional input arrays of type `double` to the
    actual prototype used by `rms`. Using `numpy.i` effectively, therefore, requires
    knowing what typemaps are available and what they do.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，没有实际的要包装的原型会具有参数名称 `IN_ARRAY1` 和 `DIM1`。 我们使用 [SWIG](http://www.swig.org)
    `%apply` 指令将一个维度为 `double` 的一维输入数组的类型映射应用到 `rms` 实际使用的原型上。 因此，有效地使用 `numpy.i`
    需要知道可用的类型映射及其作用。
- en: 'A [SWIG](http://www.swig.org) interface file that includes the [SWIG](http://www.swig.org)
    directives given above will produce wrapper code that looks something like:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 包括上述 [SWIG](http://www.swig.org) 指令的 [SWIG](http://www.swig.org) 接口文件将生成类似于以下内容的包装器代码：
- en: '[PRE26]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The typemaps from `numpy.i` are responsible for the following lines of code:
    12–20, 25 and 30\. Line 10 parses the input to the `rms` function. From the format
    string `"O:rms"`, we can see that the argument list is expected to be a single
    Python object (specified by the `O` before the colon) and whose pointer is stored
    in `obj0`. A number of functions, supplied by `numpy.i`, are called to make and
    check the (possible) conversion from a generic Python object to a NumPy array.
    These functions are explained in the section [Helper Functions](#helper-functions),
    but hopefully their names are self-explanatory. At line 12 we use `obj0` to construct
    a NumPy array. At line 17, we check the validity of the result: that it is non-null
    and that it has a single dimension of arbitrary length. Once these states are
    verified, we extract the data buffer and length in lines 19 and 20 so that we
    can call the underlying C function at line 22\. Line 25 performs memory management
    for the case where we have created a new array that is no longer needed.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `numpy.i` 的类型映射负责以下代码行：12–20，25 和 30。 第10行解析输入到 `rms` 函数。从格式字符串`"O:rms"`，我们可以看到参数列表预期是单个
    Python 对象（由冒号前的 `O` 指定），其指针存储在 `obj0` 中。 通过调用由 `numpy.i` 提供的一些函数，可以进行从通用 Python
    对象到 NumPy 数组的转换（可能的）进行检查。 这些函数在 [辅助函数](#helper-functions) 部分中有所解释，但希望它们的名称是不言自明的。
    第12行我们使用 `obj0` 构造一个 NumPy 数组。 在第17行，我们检查结果的有效性：它不为空，并且具有任意长度的单个维度。 一旦验证了这些状态，我们提取数据缓冲区和长度，以便我们可以在第22行调用底层
    C 函数。 第25行对于我们创建了一个不再需要的新数组进行内存管理。
- en: This code has a significant amount of error handling. Note the `SWIG_fail` is
    a macro for `goto fail`, referring to the label at line 28\. If the user provides
    the wrong number of arguments, this will be caught at line 10\. If construction
    of the NumPy array fails or produces an array with the wrong number of dimensions,
    these errors are caught at line 17\. And finally, if an error is detected, memory
    is still managed correctly at line 30.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码有大量的错误处理。 请注意，`SWIG_fail` 是一个指向第28行标签的 `goto fail` 的宏。 如果用户提供了错误数量的参数，这将在第10行被捕获。
    如果构造 NumPy 数组失败或产生了维度错误的数组，这些错误将在第17行被捕获。 最后，如果检测到错误，内存在第30行仍然被正确地管理。
- en: 'Note that if the C function signature was in a different order:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 C 函数签名的顺序不同：
- en: '[PRE27]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'that [SWIG](http://www.swig.org) would not match the typemap signature given
    above with the argument list for `rms`. Fortunately, `numpy.i` has a set of typemaps
    with the data pointer given last:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org) 不会将上述类型映射签名与 `rms` 的参数列表匹配。 幸运的是，`numpy.i` 具有一套具有数据指针的类型映射：最后
    given last：'
- en: '[PRE28]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simply has the effect of switching the definitions of `arg1` and `arg2`
    in lines 3 and 4 of the generated code above, and their assignments in lines 19
    and 20.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单地将上面生成的代码中第3和第4行的 `arg1` 和 `arg2` 的定义进行了交换，以及在第19和第20行的赋值。
- en: Using numpy.i
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 numpy.i
- en: The `numpy.i` file is currently located in the `tools/swig` sub-directory under
    the `numpy` installation directory. Typically, you will want to copy it to the
    directory where you are developing your wrappers.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 文件当前位于 `numpy` 安装目录下的 `tools/swig` 子目录中。通常，您会希望将其复制到您正在开发包装器的目录中。'
- en: 'A simple module that only uses a single [SWIG](http://www.swig.org) interface
    file should include the following:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用单个 [SWIG](http://www.swig.org) 接口文件的简单模块应该包括以下内容：
- en: '[PRE29]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Within a compiled Python module, `import_array()` should only get called once.
    This could be in a C/C++ file that you have written and is linked to the module.
    If this is the case, then none of your interface files should `#define SWIG_FILE_WITH_INIT`
    or call `import_array()`. Or, this initialization call could be in a wrapper file
    generated by [SWIG](http://www.swig.org) from an interface file that has the `%init`
    block as above. If this is the case, and you have more than one [SWIG](http://www.swig.org)
    interface file, then only one interface file should `#define SWIG_FILE_WITH_INIT`
    and call `import_array()`.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译的 Python 模块中，`import_array()` 应该只被调用一次。这可以在一个你编写的并与模块链接的 C/C++ 文件中实现。如果是这种情况，则你的接口文件中不应该存在
    `#define SWIG_FILE_WITH_INIT` 或调用 `import_array()`。或者，这个初始化调用可以在通过[SWIG](http://www.swig.org)从具有上述
    `%init` 块的接口文件生成的包装文件中实现。如果是这种情况，并且你有多个[SWIG](http://www.swig.org)接口文件，则只有一个接口文件应该
    `#define SWIG_FILE_WITH_INIT` 并调用 `import_array()`。
- en: Available Typemaps
  id: totrans-678
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的类型映射
- en: 'The typemap directives provided by `numpy.i` for arrays of different data types,
    say `double` and `int`, and dimensions of different types, say `int` or `long`,
    are identical to one another except for the C and NumPy type specifications. The
    typemaps are therefore implemented (typically behind the scenes) via a macro:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 提供了不同数据类型（如 `double` 和 `int`）和不同维度类型（如 `int` 或 `long`）的数组的类型映射指令。这些类型映射指令是相同的，只有
    C 和 NumPy 类型的规定不同。这些类型映射指令通常通过宏来实现（通常在幕后实现）：'
- en: '[PRE30]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'that can be invoked for appropriate `(DATA_TYPE, DATA_TYPECODE, DIM_TYPE)`
    triplets. For example:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据适当的 `(DATA_TYPE, DATA_TYPECODE, DIM_TYPE)` 三元组调用它。例如：
- en: '[PRE31]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `numpy.i` interface file uses the `%numpy_typemaps` macro to implement
    typemaps for the following C data types and `int` dimension types:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 接口文件使用 `%numpy_typemaps` 宏为以下 C 数据类型和 `int` 维度类型实现类型映射：'
- en: '`signed char`'
  id: totrans-684
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signed char`'
- en: ''
  id: totrans-685
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-686
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned char`'
  id: totrans-687
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned char`'
- en: ''
  id: totrans-688
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-689
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`short`'
  id: totrans-690
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: ''
  id: totrans-691
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-692
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned short`'
  id: totrans-693
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned short`'
- en: ''
  id: totrans-694
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-695
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int`'
  id: totrans-696
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: ''
  id: totrans-697
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-698
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned int`'
  id: totrans-699
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int`'
- en: ''
  id: totrans-700
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-701
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long`'
  id: totrans-702
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: ''
  id: totrans-703
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-704
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long`'
  id: totrans-705
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long`'
- en: ''
  id: totrans-706
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-707
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long long`'
  id: totrans-708
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long long`'
- en: ''
  id: totrans-709
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-710
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long long`'
  id: totrans-711
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long long`'
- en: ''
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`float`'
  id: totrans-714
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: ''
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`double`'
  id: totrans-717
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: In the following descriptions, we reference a generic `DATA_TYPE`, which could
    be any of the C data types listed above, and `DIM_TYPE` which should be one of
    the many types of integers.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的描述中，我们引用一个通用的 `DATA_TYPE`，它可以是上述 C 数据类型之一，以及 `DIM_TYPE`，它应该是许多类型的整数之一。
- en: The typemap signatures are largely differentiated on the name given to the buffer
    pointer. Names with `FARRAY` are for Fortran-ordered arrays, and names with `ARRAY`
    are for C-ordered (or 1D arrays).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 类型映射的签名在于缓冲区指针的命名方式。`FARRAY` 命名方式适用于 Fortran 排序的数组，`ARRAY` 命名方式适用于 C 排序（或 1D
    数组）。
- en: Input Arrays
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数组
- en: Input arrays are defined as arrays of data that are passed into a routine but
    are not altered in-place or returned to the user. The Python input array is therefore
    allowed to be almost any Python sequence (such as a list) that can be converted
    to the requested type of array. The input array signatures are
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组被定义为传递给例程但不进行原地修改或返回给用户的数据的数组。因此，Python 输入数组可以是几乎任何可以转换为请求类型数组的 Python 序列（如列表）。输入数组的签名为
- en: '1D:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 1D：
- en: '`( DATA_TYPE IN_ARRAY1[ANY] )`'
  id: totrans-723
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY1[ANY] )`'
- en: ''
  id: totrans-724
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-725
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY1, int DIM1 )`'
  id: totrans-726
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-727
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-728
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* IN_ARRAY1 )`'
  id: totrans-729
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, DATA_TYPE* IN_ARRAY1 )`'
- en: '2D:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 2D：
- en: '`( DATA_TYPE IN_ARRAY2[ANY][ANY] )`'
  id: totrans-731
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY2[ANY][ANY] )`'
- en: ''
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-733
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-734
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-735
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-736
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_ARRAY2 )`'
  id: totrans-737
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* IN_ARRAY2 )`'
- en: ''
  id: totrans-738
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-739
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-740
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_FARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_FARRAY2 )`'
  id: totrans-743
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* IN_FARRAY2 )`'
- en: '3D:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 3D：
- en: '`( DATA_TYPE IN_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-745
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY3[ANY][ANY][ANY] )`'
- en: ''
  id: totrans-746
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-747
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-748
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-749
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-750
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_ARRAY3 )`'
  id: totrans-751
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_ARRAY3 )`'
- en: ''
  id: totrans-752
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-753
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-754
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_FARRAY3 )`'
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_FARRAY3 )`'
- en: '4D:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 4D：
- en: '`(DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-759
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])`'
- en: ''
  id: totrans-760
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-761
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-762
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-764
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    IN_ARRAY4)`'
  id: totrans-765
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    IN_ARRAY4)`'
- en: ''
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-767
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-768
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-770
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)`'
  id: totrans-771
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)`'
- en: The first signature listed, `( DATA_TYPE IN_ARRAY[ANY] )` is for one-dimensional
    arrays with hard-coded dimensions. Likewise, `( DATA_TYPE IN_ARRAY2[ANY][ANY]
    )` is for two-dimensional arrays with hard-coded dimensions, and similarly for
    three-dimensional.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第一个签名，`( DATA_TYPE IN_ARRAY[ANY] )`是用于具有硬编码维度的一维数组。同样，`( DATA_TYPE IN_ARRAY2[ANY][ANY]
    )`用于具有硬编码维度的二维数组，三维数组类似。
- en: In-Place Arrays
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原位数组
- en: In-place arrays are defined as arrays that are modified in-place. The input
    values may or may not be used, but the values at the time the function returns
    are significant. The provided Python argument must therefore be a NumPy array
    of the required type. The in-place signatures are
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 原位数组定义为在原地修改的数组。输入值可能会被使用，也可能不会被使用，但在函数返回时的值是重要的。因此，提供的Python参数必须是所需类型的NumPy数组。原地签名为
- en: '1D:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE INPLACE_ARRAY1[ANY] )`'
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY1[ANY] )`'
- en: ''
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-778
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY1, int DIM1 )`'
  id: totrans-779
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-780
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-781
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* INPLACE_ARRAY1 )`'
  id: totrans-782
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, DATA_TYPE* INPLACE_ARRAY1 )`'
- en: '2D:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE INPLACE_ARRAY2[ANY][ANY] )`'
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY2[ANY][ANY] )`'
- en: ''
  id: totrans-785
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-787
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-789
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_ARRAY2 )`'
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_ARRAY2 )`'
- en: ''
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-792
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-793
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_FARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-794
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-795
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_FARRAY2 )`'
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_FARRAY2 )`'
- en: '3D:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY] )`'
- en: ''
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_ARRAY3 )`'
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_ARRAY3 )`'
- en: ''
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-806
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-809
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_FARRAY3 )`'
  id: totrans-810
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_FARRAY3 )`'
- en: '4D:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-812
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])`'
- en: ''
  id: totrans-813
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-816
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    INPLACE_ARRAY4)`'
  id: totrans-818
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    INPLACE_ARRAY4)`'
- en: ''
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3,
    DIM_TYPE DIM4)`'
  id: totrans-821
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3,
    DIM_TYPE DIM4)`'
- en: ''
  id: totrans-822
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-823
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)`'
  id: totrans-824
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)`'
- en: These typemaps now check to make sure that the `INPLACE_ARRAY` arguments use
    native byte ordering. If not, an exception is raised.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 这些typemap现在检查以确保`INPLACE_ARRAY`参数使用本机字节顺序。如果不是，则会引发异常。
- en: There is also a “flat” in-place array for situations in which you would like
    to modify or process each element, regardless of the number of dimensions. One
    example is a “quantization” function that quantizes each element of an array in-place,
    be it 1D, 2D or whatever. This form checks for continuity but allows either C
    or Fortran ordering.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种“平坦”的原地数组，用于您希望修改或处理每个元素的情况，无论维度的数量如何。一个例子是一个在原地量化数组的“量化”函数，无论是1D、2D还是其他维度，都可以对每个元素进行量化。这种形式检查连续性，但允许C或Fortran排序。
- en: 'ND:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 'ND:'
- en: '`(DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)`'
  id: totrans-828
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)`'
- en: Argout Arrays
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Argout数组
- en: Argout arrays are arrays that appear in the input arguments in C, but are in
    fact output arrays. This pattern occurs often when there is more than one output
    variable and the single return argument is therefore not sufficient. In Python,
    the conventional way to return multiple arguments is to pack them into a sequence
    (tuple, list, etc.) and return the sequence. This is what the argout typemaps
    do. If a wrapped function that uses these argout typemaps has more than one return
    argument, they are packed into a tuple or list, depending on the version of Python.
    The Python user does not pass these arrays in, they simply get returned. For the
    case where a dimension is specified, the python user must provide that dimension
    as an argument. The argout signatures are
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '1D:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE ARGOUT_ARRAY1[ANY] )`'
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* ARGOUT_ARRAY1, int DIM1 )`'
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* ARGOUT_ARRAY1 )`'
  id: totrans-838
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '2D:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE ARGOUT_ARRAY2[ANY][ANY] )`'
  id: totrans-840
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '3D:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-842
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '4D:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY] )`'
  id: totrans-844
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: These are typically used in situations where in C/C++, you would allocate a(n)
    array(s) on the heap, and call the function to fill the array(s) values. In Python,
    the arrays are allocated for you and returned as new array objects.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: Note that we support `DATA_TYPE*` argout typemaps in 1D, but not 2D or 3D. This
    is because of a quirk with the [SWIG](http://www.swig.org) typemap syntax and
    cannot be avoided. Note that for these types of 1D typemaps, the Python function
    will take a single argument representing `DIM1`.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: Argout View Arrays
  id: totrans-847
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Argoutview arrays are for when your C code provides you with a view of its internal
    data and does not require any memory to be allocated by the user. This can be
    dangerous. There is almost no way to guarantee that the internal data from the
    C code will remain in existence for the entire lifetime of the NumPy array that
    encapsulates it. If the user destroys the object that provides the view of the
    data before destroying the NumPy array, then using that array may result in bad
    memory references or segmentation faults. Nevertheless, there are situations,
    working with large data sets, where you simply have no other choice.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'The C code to be wrapped for argoutview arrays are characterized by pointers:
    pointers to the dimensions and double pointers to the data, so that these values
    can be passed back to the user. The argoutview typemap signatures are therefore'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '1D:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY1, DIM_TYPE* DIM1 )`'
  id: totrans-851
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-853
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEW_ARRAY1 )`'
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '2D:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-856
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-857
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-858
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_ARRAY2 )`'
  id: totrans-859
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_FARRAY2 )`'
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '3D:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-869
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_ARRAY3)`'
  id: totrans-870
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-871
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-872
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-873
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-874
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-875
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)`'
  id: totrans-876
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '4D:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-880
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_ARRAY4)`'
  id: totrans-881
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-882
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-883
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-884
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_FARRAY4)`'
  id: totrans-887
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that arrays with hard-coded dimensions are not supported. These cannot
    follow the double pointer signatures of these typemaps.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: Memory Managed Argout View Arrays
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A recent addition to `numpy.i` are typemaps that permit argout arrays with views
    into memory that is managed. See the discussion [here](http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory).
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '1D:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)`'
  id: totrans-892
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)`'
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '2D:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-898
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)`'
  id: totrans-900
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-901
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-902
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-903
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-905
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)`'
  id: totrans-906
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '3D:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-908
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-909
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)`'
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-914
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-915
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-916
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)`'
  id: totrans-917
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '4D:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-919
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-920
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_ARRAY4)`'
  id: totrans-922
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-924
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_FARRAY4)`'
  id: totrans-928
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Output Arrays
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `numpy.i` interface file does not support typemaps for output arrays, for
    several reasons. First, C/C++ return arguments are limited to a single value.
    This prevents obtaining dimension information in a general way. Second, arrays
    with hard-coded lengths are not permitted as return arguments. In other words:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'is not legal C/C++ syntax. Therefore, we cannot provide typemaps of the form:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you run into a situation where a function or method is returning a pointer
    to an array, your best bet is to write your own version of the function to be
    wrapped, either with `%extend` for the case of class methods or `%ignore` and
    `%rename` for the case of functions.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: 'Other Common Types: bool'
  id: totrans-935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that C++ type `bool` is not supported in the list in the [Available Typemaps](#available-typemaps)
    section. NumPy bools are a single byte, while the C++ `bool` is four bytes (at
    least on my system). Therefore:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'will result in typemaps that will produce code that reference improper data
    lengths. You can implement the following macro expansion:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致Typemaps产生引用不正确数据长度的代码。您可以实现以下宏扩展：
- en: '[PRE35]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: to fix the data length problem, and [Input Arrays](#input-arrays) will work
    fine, but [In-Place Arrays](#in-place-arrays) might fail type-checking.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 来解决数据长度问题，[输入数组](#input-arrays) 可能有效，但[原位数组](#in-place-arrays) 可能无法通过类型检查。
- en: 'Other Common Types: complex'
  id: totrans-941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见类型：复数
- en: 'Typemap conversions for complex floating-point types is also not supported
    automatically. This is because Python and NumPy are written in C, which does not
    have native complex types. Both Python and NumPy implement their own (essentially
    equivalent) `struct` definitions for complex variables:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂浮点类型的Typemap转换也不能自动支持。这是因为Python和NumPy是用C编写的，它们没有本地复杂类型。Python和NumPy都实现了它们自己的（本质上等效的）`struct`定义，用于复杂变量：
- en: '[PRE36]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We could have implemented:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以实现：
- en: '[PRE37]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: which would have provided automatic type conversions for arrays of type `Py_complex`,
    `npy_cfloat` and `npy_cdouble`. However, it seemed unlikely that there would be
    any independent (non-Python, non-NumPy) application code that people would be
    using [SWIG](http://www.swig.org) to generate a Python interface to, that also
    used these definitions for complex types. More likely, these application codes
    will define their own complex types, or in the case of C++, use `std::complex`.
    Assuming these data structures are compatible with Python and NumPy complex types,
    `%numpy_typemap` expansions as above (with the user’s complex type substituted
    for the first argument) should work.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`Py_complex`、`npy_cfloat`和`npy_cdouble`类型的数组提供自动类型转换。然而，似乎不太可能有任何独立的（非Python、非NumPy）应用代码会使用
    [SWIG](http://www.swig.org) 生成Python接口，并且还使用这些定义的复杂类型。更有可能的是，这些应用代码将定义它们自己的复杂类型，或者在C++的情况下使用`std::complex`。假设这些数据结构与Python和NumPy的复杂类型兼容，那么以上的`%numpy_typemap`扩展（用用户的复杂类型替换第一个参数）应该有效。
- en: Input Arrays
  id: totrans-947
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入数组
- en: Input arrays are defined as arrays of data that are passed into a routine but
    are not altered in-place or returned to the user. The Python input array is therefore
    allowed to be almost any Python sequence (such as a list) that can be converted
    to the requested type of array. The input array signatures are
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数组被定义为传入程序但不会被直接更改或返回给用户的数据数组。因此，Python输入数组几乎可以是任何可转换为所请求数组类型的Python序列（如列表）。输入数组签名为
- en: '1D:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE IN_ARRAY1[ANY] )`'
  id: totrans-950
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY1[ANY] )`'
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-952
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY1, int DIM1 )`'
  id: totrans-953
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* IN_ARRAY1 )`'
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, DATA_TYPE* IN_ARRAY1 )`'
- en: '2D:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE IN_ARRAY2[ANY][ANY] )`'
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY2[ANY][ANY] )`'
- en: ''
  id: totrans-959
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-960
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-961
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-962
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_ARRAY2 )`'
  id: totrans-964
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* IN_ARRAY2 )`'
- en: ''
  id: totrans-965
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-966
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_FARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* IN_FARRAY2 )`'
  id: totrans-970
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* IN_FARRAY2 )`'
- en: '3D:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE IN_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-972
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE IN_ARRAY3[ANY][ANY][ANY] )`'
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-977
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_ARRAY3 )`'
  id: totrans-978
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_ARRAY3 )`'
- en: ''
  id: totrans-979
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-980
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-981
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* IN_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-983
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_FARRAY3 )`'
  id: totrans-984
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* IN_FARRAY3 )`'
- en: '4D:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-986
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE IN_ARRAY4[ANY][ANY][ANY][ANY])`'
- en: ''
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-988
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-989
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* IN_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-990
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-991
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    IN_ARRAY4)`'
  id: totrans-992
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    IN_ARRAY4)`'
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-994
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* IN_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-997
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)`'
  id: totrans-998
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* IN_FARRAY4)`'
- en: The first signature listed, `( DATA_TYPE IN_ARRAY[ANY] )` is for one-dimensional
    arrays with hard-coded dimensions. Likewise, `( DATA_TYPE IN_ARRAY2[ANY][ANY]
    )` is for two-dimensional arrays with hard-coded dimensions, and similarly for
    three-dimensional.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的第一个签名，`( DATA_TYPE IN_ARRAY[ANY] )`，是给定固定维度的一维数组。同样，`( DATA_TYPE IN_ARRAY2[ANY][ANY]
    )`是给定固定维度的二维数组，类似地适用于三维数组。
- en: In-Place Arrays
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原位数组
- en: In-place arrays are defined as arrays that are modified in-place. The input
    values may or may not be used, but the values at the time the function returns
    are significant. The provided Python argument must therefore be a NumPy array
    of the required type. The in-place signatures are
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: In-place arrays are defined as arrays that are modified in-place. The input
    values may or may not be used, but the values at the time the function returns
    are significant. The provided Python argument must therefore be a NumPy array
    of the required type. The in-place signatures are
- en: '1D:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE INPLACE_ARRAY1[ANY] )`'
  id: totrans-1003
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY1[ANY] )`'
- en: ''
  id: totrans-1004
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1005
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY1, int DIM1 )`'
  id: totrans-1006
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* INPLACE_ARRAY1 )`'
  id: totrans-1009
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, DATA_TYPE* INPLACE_ARRAY1 )`'
- en: '2D:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE INPLACE_ARRAY2[ANY][ANY] )`'
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY2[ANY][ANY] )`'
- en: ''
  id: totrans-1012
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1013
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY2, int DIM1, int DIM2 )`'
  id: totrans-1014
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-1015
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1016
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_ARRAY2 )`'
  id: totrans-1017
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_ARRAY2 )`'
- en: ''
  id: totrans-1018
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY2, int DIM1, int DIM2 )`'
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_FARRAY2, int DIM1, int DIM2 )`'
- en: ''
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_FARRAY2 )`'
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, DATA_TYPE* INPLACE_FARRAY2 )`'
- en: '3D:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE INPLACE_ARRAY3[ANY][ANY][ANY] )`'
- en: ''
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_ARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_ARRAY3 )`'
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_ARRAY3 )`'
- en: ''
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
  id: totrans-1034
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* INPLACE_FARRAY3, int DIM1, int DIM2, int DIM3 )`'
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_FARRAY3 )`'
  id: totrans-1037
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, int DIM2, int DIM3, DATA_TYPE* INPLACE_FARRAY3 )`'
- en: '4D:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])`'
  id: totrans-1039
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE INPLACE_ARRAY4[ANY][ANY][ANY][ANY])`'
- en: ''
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_ARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE
    DIM4)`'
- en: ''
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    INPLACE_ARRAY4)`'
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, , DIM_TYPE DIM4, DATA_TYPE*
    INPLACE_ARRAY4)`'
- en: ''
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3,
    DIM_TYPE DIM4)`'
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_FARRAY4, DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3,
    DIM_TYPE DIM4)`'
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)`'
  id: totrans-1051
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE DIM1, DIM_TYPE DIM2, DIM_TYPE DIM3, DIM_TYPE DIM4, DATA_TYPE* INPLACE_FARRAY4)`'
- en: These typemaps now check to make sure that the `INPLACE_ARRAY` arguments use
    native byte ordering. If not, an exception is raised.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: These typemaps now check to make sure that the `INPLACE_ARRAY` arguments use
    native byte ordering. If not, an exception is raised.
- en: There is also a “flat” in-place array for situations in which you would like
    to modify or process each element, regardless of the number of dimensions. One
    example is a “quantization” function that quantizes each element of an array in-place,
    be it 1D, 2D or whatever. This form checks for continuity but allows either C
    or Fortran ordering.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: There is also a “flat” in-place array for situations in which you would like
    to modify or process each element, regardless of the number of dimensions. One
    example is a “quantization” function that quantizes each element of an array in-place,
    be it 1D, 2D or whatever. This form checks for continuity but allows either C
    or Fortran ordering.
- en: 'ND:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 'ND:'
- en: '`(DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)`'
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE* INPLACE_ARRAY_FLAT, DIM_TYPE DIM_FLAT)`'
- en: Argout Arrays
  id: totrans-1056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Argout Arrays
- en: Argout arrays are arrays that appear in the input arguments in C, but are in
    fact output arrays. This pattern occurs often when there is more than one output
    variable and the single return argument is therefore not sufficient. In Python,
    the conventional way to return multiple arguments is to pack them into a sequence
    (tuple, list, etc.) and return the sequence. This is what the argout typemaps
    do. If a wrapped function that uses these argout typemaps has more than one return
    argument, they are packed into a tuple or list, depending on the version of Python.
    The Python user does not pass these arrays in, they simply get returned. For the
    case where a dimension is specified, the python user must provide that dimension
    as an argument. The argout signatures are
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: Argout arrays are arrays that appear in the input arguments in C, but are in
    fact output arrays. This pattern occurs often when there is more than one output
    variable and the single return argument is therefore not sufficient. In Python,
    the conventional way to return multiple arguments is to pack them into a sequence
    (tuple, list, etc.) and return the sequence. This is what the argout typemaps
    do. If a wrapped function that uses these argout typemaps has more than one return
    argument, they are packed into a tuple or list, depending on the version of Python.
    The Python user does not pass these arrays in, they simply get returned. For the
    case where a dimension is specified, the python user must provide that dimension
    as an argument. The argout signatures are
- en: '1D:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE ARGOUT_ARRAY1[ANY] )`'
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE ARGOUT_ARRAY1[ANY] )`'
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1061
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE* ARGOUT_ARRAY1, int DIM1 )`'
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE* ARGOUT_ARRAY1, int DIM1 )`'
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( int DIM1, DATA_TYPE* ARGOUT_ARRAY1 )`'
  id: totrans-1065
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( int DIM1, DATA_TYPE* ARGOUT_ARRAY1 )`'
- en: '2D:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE ARGOUT_ARRAY2[ANY][ANY] )`'
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE ARGOUT_ARRAY2[ANY][ANY] )`'
- en: '3D:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY] )`'
  id: totrans-1069
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE ARGOUT_ARRAY3[ANY][ANY][ANY] )`'
- en: '4D:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`( DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY] )`'
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE ARGOUT_ARRAY4[ANY][ANY][ANY][ANY] )`'
- en: These are typically used in situations where in C/C++, you would allocate a(n)
    array(s) on the heap, and call the function to fill the array(s) values. In Python,
    the arrays are allocated for you and returned as new array objects.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常用于在C/C++中，您会在堆上分配一个或多个数组，并调用函数填充数组的值的情况。 在Python中，数组将为您分配并返回为新的数组对象。
- en: Note that we support `DATA_TYPE*` argout typemaps in 1D, but not 2D or 3D. This
    is because of a quirk with the [SWIG](http://www.swig.org) typemap syntax and
    cannot be avoided. Note that for these types of 1D typemaps, the Python function
    will take a single argument representing `DIM1`.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们支持`DATA_TYPE*` argout typemaps在1D中，但不支持2D或3D。 这是由于[SWIG](http://www.swig.org)
    typemap语法的一个怪癖，无法避免。 请注意，对于这些类型的1D typemaps，Python函数将采用一个表示`DIM1`的单个参数。
- en: Argout View Arrays
  id: totrans-1074
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出视图数组
- en: Argoutview arrays are for when your C code provides you with a view of its internal
    data and does not require any memory to be allocated by the user. This can be
    dangerous. There is almost no way to guarantee that the internal data from the
    C code will remain in existence for the entire lifetime of the NumPy array that
    encapsulates it. If the user destroys the object that provides the view of the
    data before destroying the NumPy array, then using that array may result in bad
    memory references or segmentation faults. Nevertheless, there are situations,
    working with large data sets, where you simply have no other choice.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: Argoutview数组用于当您的C代码向您提供其内部数据的视图且不需要用户分配任何内存时。 这可能很危险。 几乎没有办法保证来自C代码的内部数据将在封装它的NumPy数组的整个生命周期中保持存在。
    如果用户在销毁提供数据视图的对象之前销毁了封装该数组的NumPy数组，那么使用该数组可能会导致不良的内存引用或段错误。 尽管如此，在处理大型数据集的情况下，有时只有这一个选择。
- en: 'The C code to be wrapped for argoutview arrays are characterized by pointers:
    pointers to the dimensions and double pointers to the data, so that these values
    can be passed back to the user. The argoutview typemap signatures are therefore'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 要为argoutview数组包装的C代码以指针为特征：指向尺寸和指向数据的双指针，以便将这些值传递回用户。 因此，argoutview typemap签名为
- en: '1D:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY1, DIM_TYPE* DIM1 )`'
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE** ARGOUTVIEW_ARRAY1, DIM_TYPE* DIM1 )`'
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEW_ARRAY1 )`'
  id: totrans-1081
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEW_ARRAY1 )`'
- en: '2D:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '2D:'
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-1083
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE** ARGOUTVIEW_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1085
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_ARRAY2 )`'
  id: totrans-1086
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_ARRAY2 )`'
- en: ''
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2 )`'
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_FARRAY2 )`'
  id: totrans-1092
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEW_FARRAY2 )`'
- en: '3D:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: '3D:'
- en: '`( DATA_TYPE** ARGOUTVIEW_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-1094
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE** ARGOUTVIEW_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1096
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_ARRAY3)`'
  id: totrans-1097
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_ARRAY3)`'
- en: ''
  id: totrans-1098
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1099
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DATA_TYPE** ARGOUTVIEW_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)`'
  id: totrans-1103
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEW_FARRAY3)`'
- en: '4D:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '4D:'
- en: '`(DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-1105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_ARRAY4)`'
  id: totrans-1108
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_ARRAY4)`'
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-1111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEW_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_FARRAY4)`'
  id: totrans-1114
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEW_FARRAY4)`'
- en: Note that arrays with hard-coded dimensions are not supported. These cannot
    follow the double pointer signatures of these typemaps.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持具有硬编码尺寸的数组。 这些无法遵循这些typemaps的双指针签名。
- en: Memory Managed Argout View Arrays
  id: totrans-1116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理的Argout视图数组
- en: A recent addition to `numpy.i` are typemaps that permit argout arrays with views
    into memory that is managed. See the discussion [here](http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory).
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i`最近新增了允许管理视图的argout数组的typemaps。请查看[这里](http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory)的讨论。'
- en: '1D:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '1D:'
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)`'
  id: totrans-1119
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY1, DIM_TYPE* DIM1)`'
- en: ''
  id: totrans-1120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)`'
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DATA_TYPE** ARGOUTVIEWM_ARRAY1)`'
- en: '2D:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 2D：
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)`'
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_ARRAY2)`'
- en: ''
  id: totrans-1128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
  id: totrans-1130
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY2, DIM_TYPE* DIM1, DIM_TYPE* DIM2)`'
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1132
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)`'
  id: totrans-1133
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DATA_TYPE** ARGOUTVIEWM_FARRAY2)`'
- en: '3D:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 3D：
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-1135
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-1136
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1137
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)`'
  id: totrans-1138
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_ARRAY3)`'
- en: ''
  id: totrans-1139
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1140
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
  id: totrans-1141
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY3, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3)`'
- en: ''
  id: totrans-1142
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1143
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)`'
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DATA_TYPE** ARGOUTVIEWM_FARRAY3)`'
- en: '4D:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 4D：
- en: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_ARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-1147
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1148
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_ARRAY4)`'
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_ARRAY4)`'
- en: ''
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DATA_TYPE** ARGOUTVIEWM_FARRAY4, DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE*
    DIM3, DIM_TYPE* DIM4)`'
- en: ''
  id: totrans-1153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1154
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_FARRAY4)`'
  id: totrans-1155
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(DIM_TYPE* DIM1, DIM_TYPE* DIM2, DIM_TYPE* DIM3, DIM_TYPE* DIM4, DATA_TYPE**
    ARGOUTVIEWM_FARRAY4)`'
- en: Output Arrays
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出数组
- en: 'The `numpy.i` interface file does not support typemaps for output arrays, for
    several reasons. First, C/C++ return arguments are limited to a single value.
    This prevents obtaining dimension information in a general way. Second, arrays
    with hard-coded lengths are not permitted as return arguments. In other words:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.i` 接口文件不支持用于输出数组的 typemaps，原因有几点。首先，C/C++ 返回参数限制为单个值。这阻止了以一般方式获取维度信息。其次，不允许作为返回参数的硬编码长度的数组。换句话说：'
- en: '[PRE38]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'is not legal C/C++ syntax. Therefore, we cannot provide typemaps of the form:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 不是合法的 C/C++ 语法。因此，我们不能提供以下形式的 typemaps：
- en: '[PRE39]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If you run into a situation where a function or method is returning a pointer
    to an array, your best bet is to write your own version of the function to be
    wrapped, either with `%extend` for the case of class methods or `%ignore` and
    `%rename` for the case of functions.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到函数或方法返回指向数组的指针的情况，最好编写要包装的函数的自定义版本，对于类方法的情况，可以使用`%extend`，对于函数的情况，可以使用`%ignore`和`%rename`。
- en: 'Other Common Types: bool'
  id: totrans-1162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见类型：布尔值
- en: 'Note that C++ type `bool` is not supported in the list in the [Available Typemaps](#available-typemaps)
    section. NumPy bools are a single byte, while the C++ `bool` is four bytes (at
    least on my system). Therefore:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：C++ 类型`bool`在[可用类型映射](#available-typemaps)部分不受支持。 NumPy 的布尔值占用一个字节，而 C++
    的`bool`占用四个字节（至少在我的系统上是这样）。因此：
- en: '[PRE40]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'will result in typemaps that will produce code that reference improper data
    lengths. You can implement the following macro expansion:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生引用错误数据长度的 typemaps。您可以实现以下宏扩展：
- en: '[PRE41]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: to fix the data length problem, and [Input Arrays](#input-arrays) will work
    fine, but [In-Place Arrays](#in-place-arrays) might fail type-checking.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决数据长度问题，[输入数组](#input-arrays)将正常工作，但[原位数组](#in-place-arrays)可能会失败类型检查。
- en: 'Other Common Types: complex'
  id: totrans-1168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见类型：复数
- en: 'Typemap conversions for complex floating-point types is also not supported
    automatically. This is because Python and NumPy are written in C, which does not
    have native complex types. Both Python and NumPy implement their own (essentially
    equivalent) `struct` definitions for complex variables:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂浮点类型的 typemap 转换也不会自动支持。这是因为 Python 和 NumPy 是用 C 编写的，没有本地复杂类型。 Python 和
    NumPy 都实现了自己的（本质上等效的）`struct`定义以用于复数变量：
- en: '[PRE42]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We could have implemented:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本来可以实现：
- en: '[PRE43]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: which would have provided automatic type conversions for arrays of type `Py_complex`,
    `npy_cfloat` and `npy_cdouble`. However, it seemed unlikely that there would be
    any independent (non-Python, non-NumPy) application code that people would be
    using [SWIG](http://www.swig.org) to generate a Python interface to, that also
    used these definitions for complex types. More likely, these application codes
    will define their own complex types, or in the case of C++, use `std::complex`.
    Assuming these data structures are compatible with Python and NumPy complex types,
    `%numpy_typemap` expansions as above (with the user’s complex type substituted
    for the first argument) should work.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`Py_complex`、`npy_cfloat`和`npy_cdouble`类型的数组提供自动类型转换。但是，这些定义对于复数类型的独立（非 Python，非
    NumPy）应用代码的使用似乎不太可能使用 [SWIG](http://www.swig.org) 生成 Python 接口，并且使用这些定义处理复数类型。更可能的是，这些应用代码将定义它们自己的复数类型，或者在
    C++ 的情况下，使用`std::complex`。假设这些数据结构与 Python 和 NumPy 的复数类型兼容，那么以上（用用户的复数类型代替第一个参数）的`%numpy_typemap`扩展应该起作用。
- en: NumPy Array Scalars and SWIG
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy 数组标量和 SWIG
- en: '[SWIG](http://www.swig.org) has sophisticated type checking for numerical types.
    For example, if your C/C++ routine expects an integer as input, the code generated
    by [SWIG](http://www.swig.org) will check for both Python integers and Python
    long integers, and raise an overflow error if the provided Python integer is too
    big to cast down to a C integer. With the introduction of NumPy scalar arrays
    into your Python code, you might conceivably extract an integer from a NumPy array
    and attempt to pass this to a [SWIG](http://www.swig.org)-wrapped C/C++ function
    that expects an `int`, but the [SWIG](http://www.swig.org) type checking will
    not recognize the NumPy array scalar as an integer. (Often, this does in fact
    work – it depends on whether NumPy recognizes the integer type you are using as
    inheriting from the Python integer type on the platform you are using. Sometimes,
    this means that code that works on a 32-bit machine will fail on a 64-bit machine.)'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org) 对数值类型有复杂的类型检查。例如，如果你的 C/C++ 程序期望整数作为输入，那么由 [SWIG](http://www.swig.org)
    生成的代码将同时检查 Python 整数和 Python 长整数，并且如果提供的 Python 整数太大而无法转换为 C 整数，则会引发溢出错误。引入 NumPy
    标量数组到你的 Python 代码中，你可能会从 NumPy 数组中提取整数，并尝试将其传递给一个期望`int`的 [SWIG](http://www.swig.org)
    包装的 C/C++ 函数，但是 [SWIG](http://www.swig.org) 的类型检查不会将 NumPy 数组标量识别为整数。（通常情况下，这实际上是有效的-这取决于
    NumPy 是否识别你所用的整数类型作为继承于你所用平台上的 Python 整数类型。有时，这意味着在 32 位机器上工作的代码在 64 位机器上会失败。）'
- en: 'If you get a Python error that looks like the following:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个看起来像下面的 Python 错误：
- en: '[PRE44]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'and the argument you are passing is an integer extracted from a NumPy array,
    then you have stumbled upon this problem. The solution is to modify the [SWIG](http://www.swig.org)
    type conversion system to accept NumPy array scalars in addition to the standard
    integer types. Fortunately, this capability has been provided for you. Simply
    copy the file:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你传递的参数是从 NumPy 数组中提取的整数，那么你就遇到了这个问题。解决方法是修改 [SWIG](http://www.swig.org) 的类型转换系统以接受
    NumPy 数组标量，除了标准整数类型之外。幸运的是，这个功能已经为你提供了。只需复制文件：
- en: '[PRE45]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: to the working build directory for you project, and this problem will be fixed.
    It is suggested that you do this anyway, as it only increases the capabilities
    of your Python interface.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 到你的项目工作构建目录，并且这个问题就会被解决。建议你无论如何都这样做，因为它只会增加你的 Python 接口的功能。
- en: Why is There a Second File?
  id: totrans-1181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么还有第二个文件？
- en: The [SWIG](http://www.swig.org) type checking and conversion system is a complicated
    combination of C macros, [SWIG](http://www.swig.org) macros, [SWIG](http://www.swig.org)
    typemaps and [SWIG](http://www.swig.org) fragments. Fragments are a way to conditionally
    insert code into your wrapper file if it is needed, and not insert it if not needed.
    If multiple typemaps require the same fragment, the fragment only gets inserted
    into your wrapper code once.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org)的类型检查和转换系统是复杂的 C 宏、[SWIG](http://www.swig.org) 宏、[SWIG](http://www.swig.org)
    类型映射和 [SWIG](http://www.swig.org) 片段的复杂组合。片段是一种在需要时有条件地将代码插入到包装文件中的方法，如果不需要，则不插入。如果多个类型映射需要同一个片段，那么片段只会被插入你的包装代码一次。'
- en: There is a fragment for converting a Python integer to a C `long`. There is
    a different fragment that converts a Python integer to a C `int`, that calls the
    routine defined in the `long` fragment. We can make the changes we want here by
    changing the definition for the `long` fragment. [SWIG](http://www.swig.org) determines
    the active definition for a fragment using a “first come, first served” system.
    That is, we need to define the fragment for `long` conversions prior to [SWIG](http://www.swig.org)
    doing it internally. [SWIG](http://www.swig.org) allows us to do this by putting
    our fragment definitions in the file `pyfragments.swg`. If we were to put the
    new fragment definitions in `numpy.i`, they would be ignored.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个片段用于将 Python 整数转换为 C 的`long`。有另一个片段将 Python 整数转换为 C 的`int`，并调用在`long`片段中定义的例程。我们可以通过更改`long`片段的定义在这里做我们想要的更改。[SWIG](http://www.swig.org)使用“先到先服务”系统来确定片段的活动定义。也就是说，我们需要在[SWIG](http://www.swig.org)内部执行之前为`long`转换定义片段。[SWIG](http://www.swig.org)允许我们通过将我们的片段定义放在文件`pyfragments.swg`中来实现这一点。如果我们将新的片段定义放在`numpy.i`中，它们将被忽略。
- en: Why is There a Second File?
  id: totrans-1184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么有第二个文件？
- en: The [SWIG](http://www.swig.org) type checking and conversion system is a complicated
    combination of C macros, [SWIG](http://www.swig.org) macros, [SWIG](http://www.swig.org)
    typemaps and [SWIG](http://www.swig.org) fragments. Fragments are a way to conditionally
    insert code into your wrapper file if it is needed, and not insert it if not needed.
    If multiple typemaps require the same fragment, the fragment only gets inserted
    into your wrapper code once.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '[SWIG](http://www.swig.org)类型检查和转换系统是C宏、[SWIG](http://www.swig.org)宏、[SWIG](http://www.swig.org)类型映射和[SWIG](http://www.swig.org)片段的复杂组合。片段是一种在需要时有条件地将代码插入到您的包装文件中的方法，在不需要时不插入。如果多个类型映射需要相同的片段，则该片段只会被插入到您的包装代码中一次。'
- en: There is a fragment for converting a Python integer to a C `long`. There is
    a different fragment that converts a Python integer to a C `int`, that calls the
    routine defined in the `long` fragment. We can make the changes we want here by
    changing the definition for the `long` fragment. [SWIG](http://www.swig.org) determines
    the active definition for a fragment using a “first come, first served” system.
    That is, we need to define the fragment for `long` conversions prior to [SWIG](http://www.swig.org)
    doing it internally. [SWIG](http://www.swig.org) allows us to do this by putting
    our fragment definitions in the file `pyfragments.swg`. If we were to put the
    new fragment definitions in `numpy.i`, they would be ignored.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个片段用于将 Python 整数转换为 C 的`long`。还有一个不同的片段将 Python 整数转换为 C 的`int`，它调用`long`片段中定义的例程。我们可以通过更改`long`片段的定义在这里做我们想要的更改。[SWIG](http://www.swig.org)使用“先到先服务”系统来确定片段的活动定义。也就是说，我们需要在[SWIG](http://www.swig.org)内部执行之前为`long`转换定义片段。[SWIG](http://www.swig.org)允许我们通过将我们的片段定义放在文件`pyfragments.swg`中来实现这一点。如果我们将新的片段定义放在`numpy.i`中，它们将被忽略。
- en: Helper Functions
  id: totrans-1187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'The `numpy.i` file contains several macros and routines that it uses internally
    to build its typemaps. However, these functions may be useful elsewhere in your
    interface file. These macros and routines are implemented as fragments, which
    are described briefly in the previous section. If you try to use one or more of
    the following macros or functions, but your compiler complains that it does not
    recognize the symbol, then you need to force these fragments to appear in your
    code using:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`numpy.i`包含许多宏和例程，它们在内部用于构建其类型映射。但是，这些函数可能在接口文件中其他地方也有用。这些宏和例程被实现为片段，在前一节中简要描述了这些片段。如果您尝试使用以下一个或多个宏或函数，但是您的编译器抱怨它不能识别该符号，那么您需要使用以下方法强制这些片段出现在您的代码中：
- en: '[PRE46]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: in your [SWIG](http://www.swig.org) interface file.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的[SWIG](http://www.swig.org)接口文件中。
- en: Macros
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: '**is_array(a)**'
  id: totrans-1192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**is_array(a)**'
- en: ''
  id: totrans-1193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is non-`NULL` and can be cast to a `PyArrayObject*`.
  id: totrans-1194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`是非`NULL`并且可以转换为`PyArrayObject*`，则求值为真。
- en: ''
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_type(a)**'
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_type(a)**'
- en: ''
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer data type code of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对 `a` 的整数数据类型代码求值，假设`a`可以转换为`PyArrayObject*`。
- en: ''
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_numdims(a)**'
  id: totrans-1200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_numdims(a)**'
- en: ''
  id: totrans-1201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer number of dimensions of `a`, assuming `a` can be cast
    to a `PyArrayObject*`.
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对`a`的维数求值，假设`a`可以转换为`PyArrayObject*`。
- en: ''
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_dimensions(a)**'
  id: totrans-1204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**array_dimensions(a)**'
- en: ''
  id: totrans-1205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the lengths of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_size(a,i)**'
  id: totrans-1208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th dimension size of `a`, assuming `a` can be cast to a
    `PyArrayObject*`.
  id: totrans-1210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_strides(a)**'
  id: totrans-1212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the stridess of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
    A stride is the distance in bytes between an element and its immediate neighbor
    along the same axis.
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_stride(a,i)**'
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th stride of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_data(a)**'
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to a pointer of type `void*` that points to the data buffer of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_descr(a)**'
  id: totrans-1224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns a borrowed reference to the dtype property (`PyArray_Descr*`) of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_flags(a)**'
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns an integer representing the flags of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_enableflags(a,f)**'
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sets the flag represented by `f` of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_contiguous(a)**'
  id: totrans-1236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is a contiguous array. Equivalent to `(PyArray_ISCONTIGUOUS(a))`.
  id: totrans-1238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_native(a)**'
  id: totrans-1240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if the data buffer of `a` uses native byte order. Equivalent
    to `(PyArray_ISNOTSWAPPED(a))`.
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_fortran(a)**'
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is FORTRAN ordered.
  id: totrans-1246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Routines
  id: totrans-1247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**pytype_string()**'
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-1250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1251
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1253
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* py_obj`, a general Python object.'
  id: totrans-1254
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1255
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1256
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1257
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type of `py_obj`.
  id: totrans-1258
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**typecode_string()**'
  id: totrans-1260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-1262
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1263
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1264
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1265
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int typecode`, a NumPy integer typecode.'
  id: totrans-1266
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1267
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1268
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1269
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type corresponding to the NumPy `typecode`.
  id: totrans-1270
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**type_match()**'
  id: totrans-1272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1277
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int actual_type`, the NumPy typecode of a NumPy array.'
  id: totrans-1278
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1279
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1280
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int desired_type`, the desired NumPy typecode.'
  id: totrans-1281
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1282
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1283
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1284
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure that `actual_type` is compatible with `desired_type`. For example,
    this allows character and byte types, or int and long types, to match. This is
    now equivalent to `PyArray_EquivTypenums()`.
  id: totrans-1285
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_no_conversion()**'
  id: totrans-1287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1289
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1290
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1292
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1293
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1294
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1295
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode.'
  id: totrans-1296
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1297
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1298
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1299
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cast `input` to a `PyArrayObject*` if legal, and ensure that it is of type `typecode`.
    If `input` cannot be cast, or the `typecode` is wrong, set a Python error and
    return `NULL`.
  id: totrans-1300
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_allow_conversion()**'
  id: totrans-1302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1304
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1305
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1306
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1307
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1308
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1309
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1310
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1311
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1312
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1313
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1314
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1315
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1316
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1317
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a NumPy array with the given `typecode`. On success, return
    a valid `PyArrayObject*` with the correct type. On failure, the Python error string
    will be set and the routine returns `NULL`.
  id: totrans-1318
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_contiguous()**'
  id: totrans-1320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1322
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1323
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1324
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1326
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1327
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1328
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1329
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1330
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1331
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int min_dims`, minimum allowable dimensions.'
  id: totrans-1332
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1333
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1334
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int max_dims`, maximum allowable dimensions.'
  id: totrans-1335
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1336
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1337
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1338
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is contiguous. If so, return the input pointer and flag
    it as not a new object. If it is not contiguous, create a new `PyArrayObject*`
    using the original data, flag it as a new object and return the pointer.
  id: totrans-1339
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_fortran()**'
  id: totrans-1341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1343
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arguments
  id: totrans-1345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1346
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1347
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1348
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1349
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1350
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1351
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1352
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1353
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is Fortran contiguous. If so, return the input pointer
    and flag it as not a new object. If it is not Fortran contiguous, create a new
    `PyArrayObject*` using the original data, flag it as a new object and return the
    pointer.
  id: totrans-1354
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_contiguous_allow_conversion()**'
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1358
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1359
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1360
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1361
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1362
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1363
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1364
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1365
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1366
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1367
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1368
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1369
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1370
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1371
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a contiguous `PyArrayObject*` of the specified type. If the
    input object is not a contiguous `PyArrayObject*`, a new one will be created and
    the new object flag will be set.
  id: totrans-1372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_fortran_allow_conversion()**'
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1376
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1379
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1380
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1381
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1382
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1383
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1384
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1385
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1386
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1387
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1388
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1389
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a Fortran contiguous `PyArrayObject*` of the specified type.
    If the input object is not a Fortran contiguous `PyArrayObject*`, a new one will
    be created and the new object flag will be set.
  id: totrans-1390
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_contiguous()**'
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1394
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1396
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1397
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1398
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1399
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1400
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1401
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test whether `ary` is contiguous. If so, return 1\. Otherwise, set a Python
    error and return 0.
  id: totrans-1402
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_native()**'
  id: totrans-1404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1406
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1407
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1408
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1409
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArray_Object* ary`, a NumPy array.'
  id: totrans-1410
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1411
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1412
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1413
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require that `ary` is not byte-swapped. If the array is not byte-swapped, return
    1\. Otherwise, set a Python error and return 0.
  id: totrans-1414
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions()**'
  id: totrans-1416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1418
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1419
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1420
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1421
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1422
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1423
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1424
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int exact_dimensions`, the desired number of dimensions.'
  id: totrans-1425
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1426
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1427
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1428
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified number of dimensions. If the array has the
    specified number of dimensions, return 1. Otherwise, set a Python error and return
    0.
  id: totrans-1429
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions_n()**'
  id: totrans-1431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1433
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1434
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1435
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1436
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1437
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1438
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1439
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* exact_dimensions`, an array of integers representing acceptable numbers
    of dimensions.'
  id: totrans-1440
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1441
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1442
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `exact_dimensions`.'
  id: totrans-1443
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1444
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1445
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1446
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have one of a list of specified number of dimensions. If the
    array has one of the specified number of dimensions, return 1\. Otherwise, set
    the Python error string and return 0.
  id: totrans-1447
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_size()**'
  id: totrans-1449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1451
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1452
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1453
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1454
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1455
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1456
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1457
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npy_int* size`, an array representing the desired lengths of each dimension.'
  id: totrans-1458
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1459
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1460
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `size`.'
  id: totrans-1461
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1462
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1463
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified shape. If the array has the specified shape,
    return 1\. Otherwise, set the Python error string and return 0.
  id: totrans-1465
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_fortran()**'
  id: totrans-1467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1469
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1470
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1471
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1472
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1473
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1474
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1475
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1476
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require the given `PyArrayObject` to be Fortran ordered. If the `PyArrayObject`
    is already Fortran ordered, do nothing. Else, set the Fortran ordering flag and
    recompute the strides.
  id: totrans-1477
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Macros
  id: totrans-1478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**is_array(a)**'
  id: totrans-1479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is non-`NULL` and can be cast to a `PyArrayObject*`.
  id: totrans-1481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_type(a)**'
  id: totrans-1483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer data type code of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-1485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_numdims(a)**'
  id: totrans-1487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the integer number of dimensions of `a`, assuming `a` can be cast
    to a `PyArrayObject*`.
  id: totrans-1489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_dimensions(a)**'
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the lengths of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_size(a,i)**'
  id: totrans-1495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th dimension size of `a`, assuming `a` can be cast to a
    `PyArrayObject*`.
  id: totrans-1497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_strides(a)**'
  id: totrans-1499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to an array of type `npy_intp` and length `array_numdims(a)`, giving
    the stridess of all of the dimensions of `a`, assuming `a` can be cast to a `PyArrayObject*`.
    A stride is the distance in bytes between an element and its immediate neighbor
    along the same axis.
  id: totrans-1501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_stride(a,i)**'
  id: totrans-1503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to the `i`-th stride of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_data(a)**'
  id: totrans-1507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates to a pointer of type `void*` that points to the data buffer of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_descr(a)**'
  id: totrans-1511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns a borrowed reference to the dtype property (`PyArray_Descr*`) of `a`,
    assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_flags(a)**'
  id: totrans-1515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns an integer representing the flags of `a`, assuming `a` can be cast to
    a `PyArrayObject*`.
  id: totrans-1517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_enableflags(a,f)**'
  id: totrans-1519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sets the flag represented by `f` of `a`, assuming `a` can be cast to a `PyArrayObject*`.
  id: totrans-1521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_contiguous(a)**'
  id: totrans-1523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is a contiguous array. Equivalent to `(PyArray_ISCONTIGUOUS(a))`.
  id: totrans-1525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_native(a)**'
  id: totrans-1527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if the data buffer of `a` uses native byte order. Equivalent
    to `(PyArray_ISNOTSWAPPED(a))`.
  id: totrans-1529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**array_is_fortran(a)**'
  id: totrans-1531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Evaluates as true if `a` is FORTRAN ordered.
  id: totrans-1533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Routines
  id: totrans-1534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**pytype_string()**'
  id: totrans-1535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-1537
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1538
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1539
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1540
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* py_obj`, a general Python object.'
  id: totrans-1541
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1542
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1543
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1544
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type of `py_obj`.
  id: totrans-1545
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**typecode_string()**'
  id: totrans-1547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `const char*`'
  id: totrans-1549
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1550
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1551
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1552
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int typecode`, a NumPy integer typecode.'
  id: totrans-1553
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，一个 NumPy 整数类型码。'
- en: ''
  id: totrans-1554
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1555
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1556
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return a string describing the type corresponding to the NumPy `typecode`.
  id: totrans-1557
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个描述与 NumPy `typecode` 对应的类型的字符串。
- en: ''
  id: totrans-1558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**type_match()**'
  id: totrans-1559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**type_match()**'
- en: ''
  id: totrans-1560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1561
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`int`
- en: ''
  id: totrans-1562
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1563
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1564
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`int actual_type`, the NumPy typecode of a NumPy array.'
  id: totrans-1565
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int actual_type`，一个 NumPy 数组的 NumPy 类型码。'
- en: ''
  id: totrans-1566
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1567
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int desired_type`, the desired NumPy typecode.'
  id: totrans-1568
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int desired_type`，所需的 NumPy 类型码。'
- en: ''
  id: totrans-1569
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1570
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1571
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure that `actual_type` is compatible with `desired_type`. For example,
    this allows character and byte types, or int and long types, to match. This is
    now equivalent to `PyArray_EquivTypenums()`.
  id: totrans-1572
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保 `actual_type` 与 `desired_type` 兼容。例如，这允许字符和字节类型，或整数和长整数类型匹配。这现在等同于 `PyArray_EquivTypenums()`。
- en: ''
  id: totrans-1573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_no_conversion()**'
  id: totrans-1574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_no_conversion()**'
- en: ''
  id: totrans-1575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1576
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1577
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1578
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1579
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1580
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的 Python 对象。'
- en: ''
  id: totrans-1581
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1582
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode.'
  id: totrans-1583
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所需的 NumPy 类型码。'
- en: ''
  id: totrans-1584
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1585
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1586
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cast `input` to a `PyArrayObject*` if legal, and ensure that it is of type `typecode`.
    If `input` cannot be cast, or the `typecode` is wrong, set a Python error and
    return `NULL`.
  id: totrans-1587
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果合法，将 `input` 强制转换为 `PyArrayObject*`，并确保其为 `typecode` 类型。如果无法强制转换 `input`，或者
    `typecode` 错误，则设置 Python 错误并返回 `NULL`。
- en: ''
  id: totrans-1588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_allow_conversion()**'
  id: totrans-1589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_allow_conversion()**'
- en: ''
  id: totrans-1590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1591
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1592
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1593
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1594
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1595
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的 Python 对象。'
- en: ''
  id: totrans-1596
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1597
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1598
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所需的 NumPy 类型码。'
- en: ''
  id: totrans-1599
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1600
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1601
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行转换，则返回0，否则返回1。'
- en: ''
  id: totrans-1602
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1603
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1604
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a NumPy array with the given `typecode`. On success, return
    a valid `PyArrayObject*` with the correct type. On failure, the Python error string
    will be set and the routine returns `NULL`.
  id: totrans-1605
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 `input` 转换成具有给定 `typecode` 的 NumPy 数组。成功时，返回具有正确类型的有效 `PyArrayObject*`。失败时，将设置
    Python 错误字符串，并返回 `NULL`。
- en: ''
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_contiguous()**'
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**make_contiguous()**'
- en: ''
  id: totrans-1608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1609
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1610
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1611
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1612
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1613
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个 NumPy 数组。'
- en: ''
  id: totrans-1614
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1615
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1616
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行转换，则返回0，否则返回1。'
- en: ''
  id: totrans-1617
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1618
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int min_dims`, minimum allowable dimensions.'
  id: totrans-1619
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int min_dims`，最小可允许的维数。'
- en: ''
  id: totrans-1620
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1621
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int max_dims`, maximum allowable dimensions.'
  id: totrans-1622
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int max_dims`，最大可允许的维数。'
- en: ''
  id: totrans-1623
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1624
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1625
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is contiguous. If so, return the input pointer and flag
    it as not a new object. If it is not contiguous, create a new `PyArrayObject*`
    using the original data, flag it as a new object and return the pointer.
  id: totrans-1626
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查 `ary` 是否是连续的。如果是，则返回输入指针，并标记为非新对象。如果它不是连续的，使用原始数据创建一个新的 `PyArrayObject*`，并将其标记为新对象，然后返回指针。
- en: ''
  id: totrans-1627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**make_fortran()**'
  id: totrans-1628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**make_fortran()**'
- en: ''
  id: totrans-1629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1630
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1631
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arguments
  id: totrans-1632
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1633
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1634
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyArrayObject* ary`，一个 NumPy 数组。'
- en: ''
  id: totrans-1635
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1636
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1637
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行转换，则返回0，否则返回1。'
- en: ''
  id: totrans-1638
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1639
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1640
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check to see if `ary` is Fortran contiguous. If so, return the input pointer
    and flag it as not a new object. If it is not Fortran contiguous, create a new
    `PyArrayObject*` using the original data, flag it as a new object and return the
    pointer.
  id: totrans-1641
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查 `ary` 是否是 Fortran 连续的。如果是，则返回输入指针，并标记为非新对象。如果它不是 Fortran 连续的，使用原始数据创建一个新的
    `PyArrayObject*`，并将其标记为新对象，然后返回指针。
- en: ''
  id: totrans-1642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_contiguous_allow_conversion()**'
  id: totrans-1643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_contiguous_allow_conversion()**'
- en: ''
  id: totrans-1644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1645
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1646
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1647
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1648
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1649
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的 Python 对象。'
- en: ''
  id: totrans-1650
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1651
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1652
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所需的 NumPy 类型码。'
- en: ''
  id: totrans-1653
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1654
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1655
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行转换，则返回0，否则返回1。'
- en: ''
  id: totrans-1656
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1657
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1658
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a contiguous `PyArrayObject*` of the specified type. If the
    input object is not a contiguous `PyArrayObject*`, a new one will be created and
    the new object flag will be set.
  id: totrans-1659
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 `input` 转换成指定类型的连续的 `PyArrayObject*`。如果输入对象不是连续的 `PyArrayObject*`，则会创建一个新对象，并设置新对象标志。
- en: ''
  id: totrans-1660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**obj_to_array_fortran_allow_conversion()**'
  id: totrans-1661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**obj_to_array_fortran_allow_conversion()**'
- en: ''
  id: totrans-1662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `PyArrayObject*`'
  id: totrans-1663
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回类型：`PyArrayObject*`
- en: ''
  id: totrans-1664
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1665
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数：
- en: ''
  id: totrans-1666
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyObject* input`, a general Python object.'
  id: totrans-1667
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyObject* input`，一个通用的 Python 对象。'
- en: ''
  id: totrans-1668
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1669
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int typecode`, the desired NumPy typecode of the resulting array.'
  id: totrans-1670
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int typecode`，所需的 NumPy 类型码。'
- en: ''
  id: totrans-1671
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1672
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* is_new_object`, returns a value of 0 if no conversion performed, else
    1.'
  id: totrans-1673
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int* is_new_object`，如果没有进行转换，则返回0，否则返回1。'
- en: ''
  id: totrans-1674
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1675
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1676
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert `input` to a Fortran contiguous `PyArrayObject*` of the specified type.
    If the input object is not a Fortran contiguous `PyArrayObject*`, a new one will
    be created and the new object flag will be set.
  id: totrans-1677
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_contiguous()**'
  id: totrans-1679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1681
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1682
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1683
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1684
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1685
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1686
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1687
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1688
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test whether `ary` is contiguous. If so, return 1\. Otherwise, set a Python
    error and return 0.
  id: totrans-1689
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_native()**'
  id: totrans-1691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1693
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1694
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1695
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1696
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArray_Object* ary`, a NumPy array.'
  id: totrans-1697
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1698
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1699
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1700
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require that `ary` is not byte-swapped. If the array is not byte-swapped, return
    1\. Otherwise, set a Python error and return 0.
  id: totrans-1701
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions()**'
  id: totrans-1703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1705
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1706
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1707
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1708
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1709
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1710
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1711
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int exact_dimensions`, the desired number of dimensions.'
  id: totrans-1712
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1713
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1714
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1715
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified number of dimensions. If the array has the
    specified number of dimensions, return 1. Otherwise, set a Python error and return
    0.
  id: totrans-1716
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_dimensions_n()**'
  id: totrans-1718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1720
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1721
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1722
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1723
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1724
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1725
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1726
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int* exact_dimensions`, an array of integers representing acceptable numbers
    of dimensions.'
  id: totrans-1727
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1728
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1729
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `exact_dimensions`.'
  id: totrans-1730
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1731
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1732
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1733
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have one of a list of specified number of dimensions. If the
    array has one of the specified number of dimensions, return 1\. Otherwise, set
    the Python error string and return 0.
  id: totrans-1734
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_size()**'
  id: totrans-1736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1738
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1739
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1740
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1741
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1742
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1743
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1744
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`npy_int* size`, an array representing the desired lengths of each dimension.'
  id: totrans-1745
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1746
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1747
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int n`, the length of `size`.'
  id: totrans-1748
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1749
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1750
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1751
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require `ary` to have a specified shape. If the array has the specified shape,
    return 1\. Otherwise, set the Python error string and return 0.
  id: totrans-1752
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**require_fortran()**'
  id: totrans-1754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Return type: `int`'
  id: totrans-1756
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1757
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Arguments:'
  id: totrans-1758
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-1759
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`PyArrayObject* ary`, a NumPy array.'
  id: totrans-1760
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1761
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1762
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1763
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Require the given `PyArrayObject` to be Fortran ordered. If the `PyArrayObject`
    is already Fortran ordered, do nothing. Else, set the Fortran ordering flag and
    recompute the strides.
  id: totrans-1764
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Beyond the Provided Typemaps
  id: totrans-1765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many C or C++ array/NumPy array situations not covered by a simple
    `%include "numpy.i"` and subsequent `%apply` directives.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: A Common Example
  id: totrans-1767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a reasonable prototype for a dot product function:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The Python interface that we want is:'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The problem here is that there is one dimension argument and two array arguments,
    and our typemaps are set up for dimensions that apply to a single array (in fact,
    [SWIG](http://www.swig.org) does not provide a mechanism for associating `len`
    with `vec2` that takes two Python input arguments). The recommended solution is
    the following:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the header file that contains the prototype for `double dot()` also contains
    other prototypes that you want to wrap, so that you need to `%include` this header
    file, then you will also need a `%ignore dot;` directive, placed after the `%rename`
    and before the `%include` directives. Or, if the function in question is a class
    method, you will want to use `%extend` rather than `%inline` in addition to `%ignore`.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: '**A note on error handling:** Note that `my_dot` returns a `double` but that
    it can also raise a Python error. The resulting wrapper function will return a
    Python float representation of 0.0 when the vector lengths do not match. Since
    this is not `NULL`, the Python interpreter will not know to check for an error.
    For this reason, we add the `%exception` directive above for `my_dot` to get the
    behavior we want (note that `$action` is a macro that gets expanded to a valid
    call to `my_dot`). In general, you will probably want to write a [SWIG](http://www.swig.org)
    macro to perform this task.'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: Other Situations
  id: totrans-1776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other wrapping situations in which `numpy.i` may be helpful when you
    encounter them.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, it is possible that you could use the `%numpy_typemaps`
    macro to implement typemaps for your own types. See the [Other Common Types: bool](#other-common-types-bool)
    or [Other Common Types: complex](#other-common-types-complex) sections for examples.
    Another situation is if your dimensions are of a type other than `int` (say `long`
    for example):'
  id: totrans-1778
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1779
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1780
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1781
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1782
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-1783
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1784
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the code in `numpy.i` to write your own typemaps. For example, if
    you had a five-dimensional array as a function argument, you could cut-and-paste
    the appropriate four-dimensional typemaps into your interface file. The modifications
    for the fourth dimension would be trivial.
  id: totrans-1785
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1786
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1787
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, the best approach is to use the `%extend` directive to define new
    methods for your classes (or overload existing ones) that take a `PyObject*` (that
    either is or can be converted to a `PyArrayObject*`) instead of a pointer to a
    buffer. In this case, the helper routines in `numpy.i` can be very useful.
  id: totrans-1788
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1789
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1790
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing typemaps can be a bit nonintuitive. If you have specific questions about
    writing [SWIG](http://www.swig.org) typemaps for NumPy, the developers of `numpy.i`
    do monitor the [Numpy-discussion](/cdn-cgi/l/email-protection#753b0018050c58111c06160006061c1a1b535646424e535640474e5356414d4e050c011d1a1b535641434e1a0712)
    and [Swig-user](/cdn-cgi/l/email-protection#aaf9ddc3cd87dfd9cfd88c89999d918c899f98918c899e9291c6c3d9ded98c899e9c91d9c5dfd8c9cfccc5d8cdcf8c899e9c91c4cfde)
    mail lists.
  id: totrans-1791
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: A Final Note
  id: totrans-1792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use the `%apply` directive, as is usually necessary to use `numpy.i`,
    it will remain in effect until you tell [SWIG](http://www.swig.org) that it shouldn’t
    be. If the arguments to the functions or methods that you are wrapping have common
    names, such as `length` or `vector`, these typemaps may get applied in situations
    you do not expect or want. Therefore, it is always a good idea to add a `%clear`
    directive after you are done with a specific typemap:'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In general, you should target these typemap signatures specifically where you
    want them, and then clear them after you are done.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: A Common Example
  id: totrans-1796
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a reasonable prototype for a dot product function:'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The Python interface that we want is:'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The problem here is that there is one dimension argument and two array arguments,
    and our typemaps are set up for dimensions that apply to a single array (in fact,
    [SWIG](http://www.swig.org) does not provide a mechanism for associating `len`
    with `vec2` that takes two Python input arguments). The recommended solution is
    the following:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the header file that contains the prototype for `double dot()` also contains
    other prototypes that you want to wrap, so that you need to `%include` this header
    file, then you will also need a `%ignore dot;` directive, placed after the `%rename`
    and before the `%include` directives. Or, if the function in question is a class
    method, you will want to use `%extend` rather than `%inline` in addition to `%ignore`.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: '**A note on error handling:** Note that `my_dot` returns a `double` but that
    it can also raise a Python error. The resulting wrapper function will return a
    Python float representation of 0.0 when the vector lengths do not match. Since
    this is not `NULL`, the Python interpreter will not know to check for an error.
    For this reason, we add the `%exception` directive above for `my_dot` to get the
    behavior we want (note that `$action` is a macro that gets expanded to a valid
    call to `my_dot`). In general, you will probably want to write a [SWIG](http://www.swig.org)
    macro to perform this task.'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: Other Situations
  id: totrans-1805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other wrapping situations in which `numpy.i` may be helpful when you
    encounter them.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, it is possible that you could use the `%numpy_typemaps`
    macro to implement typemaps for your own types. See the [Other Common Types: bool](#other-common-types-bool)
    or [Other Common Types: complex](#other-common-types-complex) sections for examples.
    Another situation is if your dimensions are of a type other than `int` (say `long`
    for example):'
  id: totrans-1807
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1808
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1809
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1810
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1811
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-1812
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1813
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: You can use the code in `numpy.i` to write your own typemaps. For example, if
    you had a five-dimensional array as a function argument, you could cut-and-paste
    the appropriate four-dimensional typemaps into your interface file. The modifications
    for the fourth dimension would be trivial.
  id: totrans-1814
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1815
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1816
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Sometimes, the best approach is to use the `%extend` directive to define new
    methods for your classes (or overload existing ones) that take a `PyObject*` (that
    either is or can be converted to a `PyArrayObject*`) instead of a pointer to a
    buffer. In this case, the helper routines in `numpy.i` can be very useful.
  id: totrans-1817
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1818
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1819
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Writing typemaps can be a bit nonintuitive. If you have specific questions about
    writing [SWIG](http://www.swig.org) typemaps for NumPy, the developers of `numpy.i`
    do monitor the [Numpy-discussion](/cdn-cgi/l/email-protection#753b0018050c58111c06160006061c1a1b535646424e535640474e5356414d4e050c011d1a1b535641434e1a0712)
    and [Swig-user](/cdn-cgi/l/email-protection#aaf9ddc3cd87dfd9cfd88c89999d918c899f98918c899e9291c6c3d9ded98c899e9c91d9c5dfd8c9cfccc5d8cdcf8c899e9c91c4cfde)
    mail lists.
  id: totrans-1820
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: A Final Note
  id: totrans-1821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use the `%apply` directive, as is usually necessary to use `numpy.i`,
    it will remain in effect until you tell [SWIG](http://www.swig.org) that it shouldn’t
    be. If the arguments to the functions or methods that you are wrapping have common
    names, such as `length` or `vector`, these typemaps may get applied in situations
    you do not expect or want. Therefore, it is always a good idea to add a `%clear`
    directive after you are done with a specific typemap:'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In general, you should target these typemap signatures specifically where you
    want them, and then clear them after you are done.
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Out of the box, `numpy.i` provides typemaps that support conversion between
    NumPy arrays and C arrays:'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: 'That can be one of 12 different scalar types: `signed char`, `unsigned char`,
    `short`, `unsigned short`, `int`, `unsigned int`, `long`, `unsigned long`, `long
    long`, `unsigned long long`, `float` and `double`.'
  id: totrans-1827
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1828
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1829
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That support 74 different argument signatures for each data type, including:'
  id: totrans-1830
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1831
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1832
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.
  id: totrans-1833
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1834
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1835
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.
  id: totrans-1836
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1837
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1838
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer
    specification.
  id: totrans-1839
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1840
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1841
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Both C-ordering (“last dimension fastest”) or Fortran-ordering (“first dimension
    fastest”) support for 2D, 3D and 4D arrays.
  id: totrans-1842
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `numpy.i` interface file also provides additional tools for wrapper developers,
    including:'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: A [SWIG](http://www.swig.org) macro (`%numpy_typemaps`) with three arguments
    for implementing the 74 argument signatures for the user’s choice of (1) C data
    type, (2) NumPy data type (assuming they match), and (3) dimension type.
  id: totrans-1844
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1845
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1846
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Fourteen C macros and fifteen C functions that can be used to write specialized
    typemaps, extensions, or inlined functions that handle cases not covered by the
    provided typemaps. Note that the macros and functions are coded specifically to
    work with the NumPy C/API regardless of NumPy version number, both before and
    after the deprecation of some aspects of the API after version 1.6.
  id: totrans-1847
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
