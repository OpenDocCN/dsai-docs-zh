- en: MultiIndex / advanced indexing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultiIndex / 高级索引
- en: 原文：[https://pandas.pydata.org/docs/user_guide/advanced.html](https://pandas.pydata.org/docs/user_guide/advanced.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pandas.pydata.org/docs/user_guide/advanced.html](https://pandas.pydata.org/docs/user_guide/advanced.html)
- en: This section covers [indexing with a MultiIndex](#advanced-hierarchical) and
    [other advanced indexing features](#advanced-index-types).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了[使用MultiIndex进行索引](#advanced-hierarchical)和[其他高级索引功能](#advanced-index-types)。
- en: See the [Indexing and Selecting Data](indexing.html#indexing) for general indexing
    documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[数据索引和选择](indexing.html#indexing)以获取一般索引文档。
- en: Warning
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Whether a copy or a reference is returned for a setting operation may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](indexing.html#indexing-view-versus-copy).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置操作中返回副本还是引用可能取决于上下文。有时这被称为`chained assignment`，应该避免。请参阅[返回视图与副本](indexing.html#indexing-view-versus-copy)。
- en: See the [cookbook](cookbook.html#cookbook-selection) for some advanced strategies.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[食谱](cookbook.html#cookbook-selection)以获取一些��级策略。
- en: '## Hierarchical indexing (MultiIndex)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 层次化索引（MultiIndex）'
- en: Hierarchical / Multi-level indexing is very exciting as it opens the door to
    some quite sophisticated data analysis and manipulation, especially for working
    with higher dimensional data. In essence, it enables you to store and manipulate
    data with an arbitrary number of dimensions in lower dimensional data structures
    like `Series` (1d) and `DataFrame` (2d).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化/多级索引非常令人兴奋，因为它为一些相当复杂的数据分析和操作打开了大门，特别是用于处理更高维数据。本质上，它使您能够在较低维数据结构（如`Series`（1d）和`DataFrame`（2d））中存储和操作具有任意数量维度的数据。
- en: In this section, we will show what exactly we mean by “hierarchical” indexing
    and how it integrates with all of the pandas indexing functionality described
    above and in prior sections. Later, when discussing [group by](groupby.html#groupby)
    and [pivoting and reshaping data](reshaping.html#reshaping), we’ll show non-trivial
    applications to illustrate how it aids in structuring data for analysis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示“层次化”索引的确切含义以及它如何与上述和之前章节中描述的所有pandas索引功能集成。稍后，在讨论[分组](groupby.html#groupby)和[数据透视和重塑](reshaping.html#reshaping)时，我们将展示非平凡的应用程序，以说明它如何帮助构建数据进行分析。
- en: See the [cookbook](cookbook.html#cookbook-multi-index) for some advanced strategies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[食谱](cookbook.html#cookbook-multi-index)以获取一些高级策略。
- en: Creating a MultiIndex (hierarchical index) object
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个MultiIndex（层次化索引）对象
- en: The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") object is the hierarchical analogue of the standard [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") object which typically stores the axis labels in pandas objects.
    You can think of `MultiIndex` as an array of tuples where each tuple is unique.
    A `MultiIndex` can be created from a list of arrays (using [`MultiIndex.from_arrays()`](../reference/api/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays
    "pandas.MultiIndex.from_arrays")), an array of tuples (using [`MultiIndex.from_tuples()`](../reference/api/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples
    "pandas.MultiIndex.from_tuples")), a crossed set of iterables (using [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product")), or a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (using [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame")). The `Index` constructor will attempt to return
    a `MultiIndex` when it is passed a list of tuples. The following examples demonstrate
    different ways to initialize MultiIndexes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")对象是标准[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")对象的分层类比，通常在pandas对象中存储轴标签。您可以将`MultiIndex`视为元组数组，其中每个元组都是唯一的。可以从数组列表（使用[`MultiIndex.from_arrays()`](../reference/api/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays
    "pandas.MultiIndex.from_arrays")）、元组数组（使用[`MultiIndex.from_tuples()`](../reference/api/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples
    "pandas.MultiIndex.from_tuples")）、可迭代的交叉集（使用[`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product")）或[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")（使用[`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame")）创建`MultiIndex`。当传递元组列表给`Index`构造函数时，它将尝试返回`MultiIndex`。以下示例演示了初始化MultiIndexes的不同方法。'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you want every pairing of the elements in two iterables, it can be easier
    to use the [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product") method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要两个可迭代元素的每个配对时，可以更容易地使用[`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product")方法：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also construct a `MultiIndex` from a `DataFrame` directly, using the
    method [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame"). This is a complementary method to [`MultiIndex.to_frame()`](../reference/api/pandas.MultiIndex.to_frame.html#pandas.MultiIndex.to_frame
    "pandas.MultiIndex.to_frame").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以直接从`DataFrame`构建`MultiIndex`，使用方法[`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame")。这是与[`MultiIndex.to_frame()`](../reference/api/pandas.MultiIndex.to_frame.html#pandas.MultiIndex.to_frame
    "pandas.MultiIndex.to_frame")互补的方法。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a convenience, you can pass a list of arrays directly into `Series` or `DataFrame`
    to construct a `MultiIndex` automatically:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种便利，你可以直接将数组列表传递给`Series`或`DataFrame`以自动构建`MultiIndex`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All of the `MultiIndex` constructors accept a `names` argument which stores
    string names for the levels themselves. If no names are provided, `None` will
    be assigned:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`MultiIndex`构造函数都接受一个`names`参数，用于存储级别本身的字符串名称。如果没有提供名称，将分配`None`：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This index can back any axis of a pandas object, and the number of **levels**
    of the index is up to you:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个索引可以支持 pandas 对象的任何轴，并且索引的**级别**数量由你决定：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ve “sparsified” the higher levels of the indexes to make the console output
    a bit easier on the eyes. Note that how the index is displayed can be controlled
    using the `multi_sparse` option in `pandas.set_options()`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们“稀疏化”了索引的较高级别，以使控制台输出更加舒适。请注意，可以使用`pandas.set_options()`中的`multi_sparse`选项来控制索引的显示方式：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s worth keeping in mind that there’s nothing preventing you from using tuples
    as atomic labels on an axis:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，没有什么可以阻止你在轴上使用元组作为原子标签：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The reason that the `MultiIndex` matters is that it can allow you to do grouping,
    selection, and reshaping operations as we will describe below and in subsequent
    areas of the documentation. As you will see in later sections, you can find yourself
    working with hierarchically-indexed data without creating a `MultiIndex` explicitly
    yourself. However, when loading data from a file, you may wish to generate your
    own `MultiIndex` when preparing the data set.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiIndex`的重要性在于它可以让你执行分组、选择和重塑操作，如下文和文档的后续部分所述。正如你将在后面的章节中看到的，你可能会发现自己在处理具有分层索引数据时，而不需要显式地创建`MultiIndex`。然而，在从文件加载数据时，你可能希望在准备数据集时自己生成`MultiIndex`。'
- en: '### Reconstructing the level labels'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '### 重建级别标签'
- en: 'The method [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") will return a vector of the labels for each
    location at a particular level:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values")将返回特定级别上每个位置的标签向量：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basic indexing on axis with MultiIndex
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`MultiIndex`在轴上进行基本索引
- en: 'One of the important features of hierarchical indexing is that you can select
    data by a “partial” label identifying a subgroup in the data. **Partial** selection
    “drops” levels of the hierarchical index in the result in a completely analogous
    way to selecting a column in a regular DataFrame:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 分层索引的一个重要特点是，你可以通过标识数据中的子组的“部分”标签来选择数据。**部分**选择会在结果中以与在常规DataFrame中选择列完全类似的方式“删除”分层索引的级别：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See [Cross-section with hierarchical index](#advanced-xs) for how to select
    on a deeper level.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[使用分层索引进行交叉选择](#advanced-xs)以了解如何在更深层次上进行选择。
- en: '### Defined levels'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '### 定义级别'
- en: 'The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") keeps all the defined levels of an index, even if they are
    not actually used. When slicing an index, you may notice this. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")保留索引的所有定义级别，即使它们实际上没有被使用。在对索引进行切片时，你可能会注意到这一点。例如：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is done to avoid a recomputation of the levels in order to make slicing
    highly performant. If you want to see only the used levels, you can use the [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To reconstruct the `MultiIndex` with only the used levels, the [`remove_unused_levels()`](../reference/api/pandas.MultiIndex.remove_unused_levels.html#pandas.MultiIndex.remove_unused_levels
    "pandas.MultiIndex.remove_unused_levels") method may be used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Data alignment and using `reindex`
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Operations between differently-indexed objects having `MultiIndex` on the axes
    will work as you expect; data alignment will work the same as an Index of tuples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") method of `Series`/`DataFrames` can be called with
    another `MultiIndex`, or even a list or array of tuples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]  ## Advanced indexing with hierarchical index'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically integrating `MultiIndex` in advanced indexing with `.loc` is
    a bit challenging, but we’ve made every effort to do so. In general, MultiIndex
    keys take the form of tuples. For example, the following works as you would expect:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that `df.loc['bar', 'two']` would also work in this example, but this shorthand
    notation can lead to ambiguity in general.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'If you also want to index a specific column with `.loc`, you must use a tuple
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You don’t have to specify all levels of the `MultiIndex` by passing only the
    first elements of the tuple. For example, you can use “partial” indexing to get
    all elements with `bar` in the first level as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a shortcut for the slightly more verbose notation `df.loc[('bar',),]`
    (equivalent to `df.loc['bar',]` in this example).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: “Partial” slicing also works quite nicely.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can slice with a ‘range’ of values, by providing a slice of tuples.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Passing a list of labels or tuples works similar to reindexing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that tuples and lists are not treated identically in
    pandas when it comes to indexing. Whereas a tuple is interpreted as one multi-level
    key, a list is used to specify several keys. Or in other words, tuples go horizontally
    (traversing levels), lists go vertically (scanning levels).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Importantly, a list of tuples indexes several complete `MultiIndex` keys, whereas
    a tuple of lists refer to several values within a level:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '### Using slicers'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: You can slice a `MultiIndex` by providing multiple indexers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: You can provide any of the selectors as if you are indexing by label, see [Selection
    by Label](indexing.html#indexing-label), including slices, lists of labels, labels,
    and boolean indexers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: You can use `slice(None)` to select all the contents of *that* level. You do
    not need to specify all the *deeper* levels, they will be implied as `slice(None)`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: As usual, **both sides** of the slicers are included as this is label indexing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: You should specify all axes in the `.loc` specifier, meaning the indexer for
    the **index** and for the **columns**. There are some ambiguous cases where the
    passed indexer could be misinterpreted as indexing *both* axes, rather than into
    say the `MultiIndex` for the rows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'You should do this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should **not** do this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Basic MultiIndex slicing using slices, lists, and labels.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can use [`pandas.IndexSlice`](../reference/api/pandas.IndexSlice.html#pandas.IndexSlice
    "pandas.IndexSlice") to facilitate a more natural syntax using `:`, rather than
    using `slice(None)`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is possible to perform quite complicated selections using this method on
    multiple axes at the same time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a boolean indexer you can provide selection related to the *values*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can also specify the `axis` argument to `.loc` to interpret the passed slicers
    on a single axis.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Furthermore, you can *set* the values using the following methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can use a right-hand-side of an alignable object as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]  ### Cross-section'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The [`xs()`](../reference/api/pandas.DataFrame.xs.html#pandas.DataFrame.xs "pandas.DataFrame.xs")
    method of `DataFrame` additionally takes a level argument to make selecting data
    at a particular level of a `MultiIndex` easier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can also select on the columns with `xs`, by providing the axis argument.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`xs` also allows selection with multiple keys.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can pass `drop_level=False` to `xs` to retain the level that was selected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compare the above with the result using `drop_level=True` (the default value).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]  ### Advanced reindexing and alignment'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the parameter `level` in the [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") and [`align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align") methods of pandas objects is useful to broadcast values
    across a level. For instance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Swapping levels with `swaplevel`
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`swaplevel()`](../reference/api/pandas.MultiIndex.swaplevel.html#pandas.MultiIndex.swaplevel
    "pandas.MultiIndex.swaplevel") method can switch the order of two levels:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '### Reordering levels with `reorder_levels`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`reorder_levels()`](../reference/api/pandas.MultiIndex.reorder_levels.html#pandas.MultiIndex.reorder_levels
    "pandas.MultiIndex.reorder_levels") method generalizes the `swaplevel` method,
    allowing you to permute the hierarchical index levels in one step:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]  ### Renaming names of an `Index` or `MultiIndex`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method is used to rename the labels of a `MultiIndex`,
    and is typically used to rename the columns of a `DataFrame`. The `columns` argument
    of `rename` allows a dictionary to be specified that includes only the columns
    you wish to rename.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This method can also be used to rename specific labels of the main index of
    the `DataFrame`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The [`rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") method is used to rename the name of a `Index`
    or `MultiIndex`. In particular, the names of the levels of a `MultiIndex` can
    be specified, which is useful if `reset_index()` is later used to move the values
    from the `MultiIndex` to a column.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") 方法用于重命名 `Index` 或 `MultiIndex` 的名称。特别是，可以指定 `MultiIndex`
    级别的名称，如果稍后使用 `reset_index()` 将值从 `MultiIndex` 移动到列中，则这很有用。'
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the columns of a `DataFrame` are an index, so that using `rename_axis`
    with the `columns` argument will change the name of that index.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`DataFrame` 的列是一个索引，因此使用 `rename_axis` 与 `columns` 参数将更改该索引的名称。
- en: '[PRE46]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Both `rename` and `rename_axis` support specifying a dictionary, `Series` or
    a mapping function to map labels/names to new values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename` 和 `rename_axis` 都支持指定字典、`Series` 或映射函数，将标签/名称映射到新值。'
- en: When working with an `Index` object directly, rather than via a `DataFrame`,
    [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") can be used to change the names.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接使用 `Index` 对象而不是通过 `DataFrame` 进行操作时，可以使用 [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") 来更改名称。
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You cannot set the names of the MultiIndex via a level.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无法通过级别设置 MultiIndex 的名称。
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Use [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") 替代。
- en: Sorting a `MultiIndex`
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 `MultiIndex` 进行排序
- en: For [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex")-ed objects to be indexed and sliced effectively, they need
    to be sorted. As with any index, you can use [`sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地对 [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") 对象进行索引和切片，它们需要被排序。与任何索引一样，您可以使用 [`sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index")。
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You may also pass a level name to `sort_index` if the `MultiIndex` levels are
    named.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `MultiIndex` 的级别已命名，还可以向 `sort_index` 传递级别名称。
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On higher dimensional objects, you can sort any of the other axes by level
    if they have a `MultiIndex`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高维度的对象上，如果它们具有 `MultiIndex`，则可以按级别对任何其他轴进行排序：
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Indexing will work even if the data are not sorted, but will be rather inefficient
    (and show a `PerformanceWarning`). It will also return a copy of the data rather
    than a view:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据未排序，索引也会起作用，但效率会相当低（并显示 `PerformanceWarning`）。它还将返回数据的副本而不是视��：
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Furthermore, if you try to index something that is not fully lexsorted, this
    can raise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果尝试对未完全按字典顺序排序的内容进行索引，可能会引发：
- en: '[PRE53]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `is_monotonic_increasing()` method on a `MultiIndex` shows if the index
    is sorted:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_monotonic_increasing()` 方法在 `MultiIndex` 上显示索引是否已排序：'
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And now selection works as expected.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择功能按预期工作。
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Take methods
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取方法
- en: Similar to NumPy ndarrays, pandas `Index`, `Series`, and `DataFrame` also provides
    the [`take()`](../reference/api/pandas.DataFrame.take.html#pandas.DataFrame.take
    "pandas.DataFrame.take") method that retrieves elements along a given axis at
    the given indices. The given indices must be either a list or an ndarray of integer
    index positions. `take` will also accept negative integers as relative positions
    to the end of the object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NumPy ndarrays 类似，pandas 的 `Index`、`Series` 和 `DataFrame` 也提供了 [`take()`](../reference/api/pandas.DataFrame.take.html#pandas.DataFrame.take
    "pandas.DataFrame.take") 方法，该方法检索给定索引处给定轴上的元素。给定的索引必须是整数索引位置的列表或 ndarray。`take`
    还将接受负整数作为相对于对象末尾的位置。
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For DataFrames, the given indices should be a 1d list or ndarray that specifies
    row or column positions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DataFrames，给定的索引应该是指定行或列位置的 1d 列表或 ndarray。
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It is important to note that the `take` method on pandas objects are not intended
    to work on boolean indices and may return unexpected results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，pandas 对象上的 `take` 方法不适用于布尔索引，并且可能返回意外结果。
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, as a small note on performance, because the `take` method handles a
    narrower range of inputs, it can offer performance that is a good deal faster
    than fancy indexing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于性能的一点小提示，因为 `take` 方法处理范围较窄的输入，它可以提供比花式索引快得多的性能。
- en: '[PRE60]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '## Index types'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '## 索引类型'
- en: We have discussed `MultiIndex` in the previous sections pretty extensively.
    Documentation about `DatetimeIndex` and `PeriodIndex` are shown [here](timeseries.html#timeseries-overview),
    and documentation about `TimedeltaIndex` is found [here](timedeltas.html#timedeltas-index).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中已经广泛讨论了`MultiIndex`。关于`DatetimeIndex`和`PeriodIndex`的文档在这里显示[timeseries.html#timeseries-overview](timeseries.html#timeseries-overview)，关于`TimedeltaIndex`的文档在这里找到[timedeltas.html#timedeltas-index](timedeltas.html#timedeltas-index)。
- en: In the following sub-sections we will highlight some other index types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，我们将重点介绍一些其他索引类型。
- en: '### CategoricalIndex'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '### CategoricalIndex'
- en: '[`CategoricalIndex`](../reference/api/pandas.CategoricalIndex.html#pandas.CategoricalIndex
    "pandas.CategoricalIndex") is a type of index that is useful for supporting indexing
    with duplicates. This is a container around a [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") and allows efficient indexing and storage of an index with
    a large number of duplicated elements.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CategoricalIndex`](../reference/api/pandas.CategoricalIndex.html#pandas.CategoricalIndex
    "pandas.CategoricalIndex")是一种支持具有重复索引的索引类型。这是围绕[`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical")的容器，允许高效地索引和存储具有大量重复元素的索引。'
- en: '[PRE62]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Setting the index will create a `CategoricalIndex`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 设置索引将创建一个`CategoricalIndex`。
- en: '[PRE63]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Indexing with `__getitem__/.iloc/.loc` works similarly to an `Index` with duplicates.
    The indexers **must** be in the category or the operation will raise a `KeyError`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__getitem__/.iloc/.loc`进行索引类似于具有重复项的`Index`。索引器**必须**在类别中，否则操作将引发`KeyError`。
- en: '[PRE64]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `CategoricalIndex` is **preserved** after indexing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引后，`CategoricalIndex`是**保留**的：
- en: '[PRE65]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Sorting the index will sort by the order of the categories (recall that we created
    the index with `CategoricalDtype(list('cab'))`, so the sorted order is `cab`).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对索引进行排序将按照类别的顺序排序（回想我们使用`CategoricalDtype(list('cab'))`创建了索引，所以排序顺序是`cab`）。
- en: '[PRE66]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Groupby operations on the index will preserve the index nature as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对索引进行分组操作将保留索引的性质。
- en: '[PRE67]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Reindexing operations will return a resulting index based on the type of the
    passed indexer. Passing a list will return a plain-old `Index`; indexing with
    a `Categorical` will return a `CategoricalIndex`, indexed according to the categories
    of the **passed** `Categorical` dtype. This allows one to arbitrarily index these
    even with values **not** in the categories, similarly to how you can reindex **any**
    pandas index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重新索引操作将根据传递的索引器的类型返回一个结果索引。传递列表将返回一个普通的`Index`；使用`Categorical`进行索引将返回一个`CategoricalIndex`，根据**传递的**`Categorical`
    dtype的类别进行索引。这允许任意索引这些，即使值**不在**类别中，类似于如何重新索引**任何**pandas索引。
- en: '[PRE68]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Warning
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Reshaping and Comparison operations on a `CategoricalIndex` must have the same
    categories or a `TypeError` will be raised.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对`CategoricalIndex`进行重塑和比较操作必须具有相同的类别，否则将引发`TypeError`。
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]  ### RangeIndex'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE71]  ### RangeIndex'
- en: '[`RangeIndex`](../reference/api/pandas.RangeIndex.html#pandas.RangeIndex "pandas.RangeIndex")
    is a sub-class of [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    that provides the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. `RangeIndex` is an optimized version of `Index` that
    can represent a monotonic ordered set. These are analogous to Python [range types](https://docs.python.org/3/library/stdtypes.html#typesseq-range).
    A `RangeIndex` will always have an `int64` dtype.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[`RangeIndex`](../reference/api/pandas.RangeIndex.html#pandas.RangeIndex "pandas.RangeIndex")是[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")和[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")对象的默认索引的子类。`RangeIndex`是`Index`的优化版本，可以表示一个单调有序集合。这类似于Python的[range类型](https://docs.python.org/3/library/stdtypes.html#typesseq-range)。`RangeIndex`将始终具有`int64`
    dtype。'
- en: '[PRE72]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`RangeIndex` is the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`RangeIndex`是所有[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")和[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")对象的默认索引：'
- en: '[PRE73]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'A `RangeIndex` will behave similarly to a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") with an `int64` dtype and operations on a `RangeIndex`, whose
    result cannot be represented by a `RangeIndex`, but should have an integer dtype,
    will be converted to an `Index` with `int64`. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]  ### IntervalIndex'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[`IntervalIndex`](../reference/api/pandas.IntervalIndex.html#pandas.IntervalIndex
    "pandas.IntervalIndex") together with its own dtype, `IntervalDtype` as well as
    the [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval "pandas.Interval")
    scalar type, allow first-class support in pandas for interval notation.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The `IntervalIndex` allows some unique indexing and is also used as a return
    type for the categories in [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut").
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with an `IntervalIndex`
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `IntervalIndex` can be used in `Series` and in `DataFrame` as the index.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Label based indexing via `.loc` along the edges of an interval works as you
    would expect, selecting that particular interval.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you select a label *contained* within an interval, this will also select
    the interval.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Selecting using an `Interval` will only return exact matches.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Trying to select an `Interval` that is not exactly contained in the `IntervalIndex`
    will raise a `KeyError`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Selecting all `Intervals` that overlap a given `Interval` can be performed using
    the [`overlaps()`](../reference/api/pandas.IntervalIndex.overlaps.html#pandas.IntervalIndex.overlaps
    "pandas.IntervalIndex.overlaps") method to create a boolean indexer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Binning data with `cut` and `qcut`
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") both return a `Categorical` object, and the bins they create are
    stored as an `IntervalIndex` in its `.categories` attribute.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") also accepts
    an `IntervalIndex` for its `bins` argument, which enables a useful pandas idiom.
    First, We call [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut")
    with some data and `bins` set to a fixed number, to generate the bins. Then, we
    pass the values of `.categories` as the `bins` argument in subsequent calls to
    [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut"), supplying
    new data which will be binned into the same bins.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Any value which falls outside all bins will be assigned a `NaN` value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Generating ranges of intervals
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we need intervals on a regular frequency, we can use the [`interval_range()`](../reference/api/pandas.interval_range.html#pandas.interval_range
    "pandas.interval_range") function to create an `IntervalIndex` using various combinations
    of `start`, `end`, and `periods`. The default frequency for `interval_range` is
    a 1 for numeric intervals, and calendar day for datetime-like intervals:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `freq` parameter can used to specify non-default frequencies, and can utilize
    a variety of [frequency aliases](timeseries.html#timeseries-offset-aliases) with
    datetime-like intervals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`freq`参数可用于指定非默认频率，并且可以利用各种[频率别名](timeseries.html#timeseries-offset-aliases)与类似于日期时间的间隔：'
- en: '[PRE84]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Additionally, the `closed` parameter can be used to specify which side(s) the
    intervals are closed on. Intervals are closed on the right side by default.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`closed`参数可用于指定区间的哪一侧是闭合的。默认情况下，区间在右侧是闭合的。
- en: '[PRE85]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    intervals from `start` to `end` inclusively, with `periods` number of elements
    in the resulting `IntervalIndex`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`start`、`end`和`periods`将生成从`start`到`end`的一系列均匀间隔的区间，包括`IntervalIndex`中的`periods`个元素：
- en: '[PRE86]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Miscellaneous indexing FAQ
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项索引常见问题解答
- en: Integer indexing
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数索引
- en: 'Label-based indexing with integer axis labels is a thorny topic. It has been
    discussed heavily on mailing lists and among various members of the scientific
    Python community. In pandas, our general viewpoint is that labels matter more
    than integer locations. Therefore, with an integer axis index *only* label-based
    indexing is possible with the standard tools like `.loc`. The following code will
    generate exceptions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数轴标签进行基于标签的索引是一个棘手的问题。在邮件列表和科学Python社区的各个成员中已经广泛讨论过这个问题。在pandas中，我们的一般观点是标签比整数位置更重要。因此，只有使用整数轴索引时，才能使用标签为基础的索引，例如`.loc`等标准工具。以下代码将生成异常：
- en: '[PRE87]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This deliberate decision was made to prevent ambiguities and subtle bugs (many
    users reported finding bugs when the API change was made to stop “falling back”
    on position-based indexing).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故意的决定是为了防止歧义和微妙的错误（许多用户报告在API更改为停止“回退”到基于位置的索引时发现错误）。
- en: Non-monotonic indexes require exact matches
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非单调索引需要精确匹配
- en: If the index of a `Series` or `DataFrame` is monotonically increasing or decreasing,
    then the bounds of a label-based slice can be outside the range of the index,
    much like slice indexing a normal Python `list`. Monotonicity of an index can
    be tested with the [`is_monotonic_increasing()`](../reference/api/pandas.Index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing
    "pandas.Index.is_monotonic_increasing") and [`is_monotonic_decreasing()`](../reference/api/pandas.Index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing
    "pandas.Index.is_monotonic_decreasing") attributes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Series`或`DataFrame`的索引是单调递增或递减的，那么基于标签的切片的边界可以超出索引范围，就像切片索引普通的Python `list`一样。可以使用[`is_monotonic_increasing()`](../reference/api/pandas.Index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing
    "pandas.Index.is_monotonic_increasing")和[`is_monotonic_decreasing()`](../reference/api/pandas.Index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing
    "pandas.Index.is_monotonic_decreasing")属性测试索引的单调性。
- en: '[PRE88]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: On the other hand, if the index is not monotonic, then both slice bounds must
    be *unique* members of the index.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果索引不是单调的，那么切片的两个边界必须是索引的*唯一*成员。
- en: '[PRE89]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`Index.is_monotonic_increasing` and `Index.is_monotonic_decreasing` only check
    that an index is weakly monotonic. To check for strict monotonicity, you can combine
    one of those with the [`is_unique()`](../reference/api/pandas.Index.is_unique.html#pandas.Index.is_unique
    "pandas.Index.is_unique") attribute.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index.is_monotonic_increasing`和`Index.is_monotonic_decreasing`只检查索引是否弱单调。要检查严格单调性，可以将其中一个与[`is_unique()`](../reference/api/pandas.Index.is_unique.html#pandas.Index.is_unique
    "pandas.Index.is_unique")属性结合使用。'
- en: '[PRE91]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '### Endpoints are inclusive'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '### 端点是包含的'
- en: 'Compared with standard Python sequence slicing in which the slice endpoint
    is not inclusive, label-based slicing in pandas **is inclusive**. The primary
    reason for this is that it is often not possible to easily determine the “successor”
    or next element after a particular label in an index. For example, consider the
    following `Series`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的Python序列切片相比，其中切片的端点不包含在内，pandas中基于标签的切片**是包含的**。这样做的主要原因是往往不容易确定索引中特定标签后的“后继”或下一个元素。例如，考虑以下`Series`：
- en: '[PRE92]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Suppose we wished to slice from `c` to `e`, using integers this would be accomplished
    as such:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望从`c`到`e`进行切片，使用整数可以这样实现：
- en: '[PRE93]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'However, if you only had `c` and `e`, determining the next element in the index
    can be somewhat complicated. For example, the following does not work:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你只有`c`和`e`，确定索引中的下一个元素可能会有些复杂。例如，以下情况不起作用：
- en: '[PRE94]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'A very common use case is to limit a time series to start and end at two specific
    dates. To enable this, we made the design choice to make label-based slicing include
    both endpoints:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This is most definitely a “practicality beats purity” sort of thing, but it
    is something to watch out for if you expect label-based slicing to behave exactly
    in the way that standard Python integer slicing works.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Indexing potentially changes underlying Series dtype
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The different indexing operation can potentially change the dtype of a `Series`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is because the (re)indexing operations above silently inserts `NaNs` and
    the `dtype` changes accordingly. This can cause some issues when using `numpy`
    `ufuncs` such as `numpy.logical_and`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: See the [GH 2388](https://github.com/pandas-dev/pandas/issues/2388) for a more
    detailed discussion.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '## Hierarchical indexing (MultiIndex)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical / Multi-level indexing is very exciting as it opens the door to
    some quite sophisticated data analysis and manipulation, especially for working
    with higher dimensional data. In essence, it enables you to store and manipulate
    data with an arbitrary number of dimensions in lower dimensional data structures
    like `Series` (1d) and `DataFrame` (2d).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show what exactly we mean by “hierarchical” indexing
    and how it integrates with all of the pandas indexing functionality described
    above and in prior sections. Later, when discussing [group by](groupby.html#groupby)
    and [pivoting and reshaping data](reshaping.html#reshaping), we’ll show non-trivial
    applications to illustrate how it aids in structuring data for analysis.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: See the [cookbook](cookbook.html#cookbook-multi-index) for some advanced strategies.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MultiIndex (hierarchical index) object
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") object is the hierarchical analogue of the standard [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") object which typically stores the axis labels in pandas objects.
    You can think of `MultiIndex` as an array of tuples where each tuple is unique.
    A `MultiIndex` can be created from a list of arrays (using [`MultiIndex.from_arrays()`](../reference/api/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays
    "pandas.MultiIndex.from_arrays")), an array of tuples (using [`MultiIndex.from_tuples()`](../reference/api/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples
    "pandas.MultiIndex.from_tuples")), a crossed set of iterables (using [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product")), or a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (using [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame")). The `Index` constructor will attempt to return
    a `MultiIndex` when it is passed a list of tuples. The following examples demonstrate
    different ways to initialize MultiIndexes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When you want every pairing of the elements in two iterables, it can be easier
    to use the [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product") method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: You can also construct a `MultiIndex` from a `DataFrame` directly, using the
    method [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame"). This is a complementary method to [`MultiIndex.to_frame()`](../reference/api/pandas.MultiIndex.to_frame.html#pandas.MultiIndex.to_frame
    "pandas.MultiIndex.to_frame").
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As a convenience, you can pass a list of arrays directly into `Series` or `DataFrame`
    to construct a `MultiIndex` automatically:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'All of the `MultiIndex` constructors accept a `names` argument which stores
    string names for the levels themselves. If no names are provided, `None` will
    be assigned:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This index can back any axis of a pandas object, and the number of **levels**
    of the index is up to you:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We’ve “sparsified” the higher levels of the indexes to make the console output
    a bit easier on the eyes. Note that how the index is displayed can be controlled
    using the `multi_sparse` option in `pandas.set_options()`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'It’s worth keeping in mind that there’s nothing preventing you from using tuples
    as atomic labels on an axis:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The reason that the `MultiIndex` matters is that it can allow you to do grouping,
    selection, and reshaping operations as we will describe below and in subsequent
    areas of the documentation. As you will see in later sections, you can find yourself
    working with hierarchically-indexed data without creating a `MultiIndex` explicitly
    yourself. However, when loading data from a file, you may wish to generate your
    own `MultiIndex` when preparing the data set.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '### Reconstructing the level labels'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The method [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") will return a vector of the labels for each
    location at a particular level:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Basic indexing on axis with MultiIndex
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the important features of hierarchical indexing is that you can select
    data by a “partial” label identifying a subgroup in the data. **Partial** selection
    “drops” levels of the hierarchical index in the result in a completely analogous
    way to selecting a column in a regular DataFrame:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: See [Cross-section with hierarchical index](#advanced-xs) for how to select
    on a deeper level.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '### Defined levels'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") keeps all the defined levels of an index, even if they are
    not actually used. When slicing an index, you may notice this. For example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This is done to avoid a recomputation of the levels in order to make slicing
    highly performant. If you want to see only the used levels, you can use the [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: To reconstruct the `MultiIndex` with only the used levels, the [`remove_unused_levels()`](../reference/api/pandas.MultiIndex.remove_unused_levels.html#pandas.MultiIndex.remove_unused_levels
    "pandas.MultiIndex.remove_unused_levels") method may be used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Data alignment and using `reindex`
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Operations between differently-indexed objects having `MultiIndex` on the axes
    will work as you expect; data alignment will work the same as an Index of tuples:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") method of `Series`/`DataFrames` can be called with
    another `MultiIndex`, or even a list or array of tuples:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Creating a MultiIndex (hierarchical index) object
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") object is the hierarchical analogue of the standard [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") object which typically stores the axis labels in pandas objects.
    You can think of `MultiIndex` as an array of tuples where each tuple is unique.
    A `MultiIndex` can be created from a list of arrays (using [`MultiIndex.from_arrays()`](../reference/api/pandas.MultiIndex.from_arrays.html#pandas.MultiIndex.from_arrays
    "pandas.MultiIndex.from_arrays")), an array of tuples (using [`MultiIndex.from_tuples()`](../reference/api/pandas.MultiIndex.from_tuples.html#pandas.MultiIndex.from_tuples
    "pandas.MultiIndex.from_tuples")), a crossed set of iterables (using [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product")), or a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (using [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame")). The `Index` constructor will attempt to return
    a `MultiIndex` when it is passed a list of tuples. The following examples demonstrate
    different ways to initialize MultiIndexes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When you want every pairing of the elements in two iterables, it can be easier
    to use the [`MultiIndex.from_product()`](../reference/api/pandas.MultiIndex.from_product.html#pandas.MultiIndex.from_product
    "pandas.MultiIndex.from_product") method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You can also construct a `MultiIndex` from a `DataFrame` directly, using the
    method [`MultiIndex.from_frame()`](../reference/api/pandas.MultiIndex.from_frame.html#pandas.MultiIndex.from_frame
    "pandas.MultiIndex.from_frame"). This is a complementary method to [`MultiIndex.to_frame()`](../reference/api/pandas.MultiIndex.to_frame.html#pandas.MultiIndex.to_frame
    "pandas.MultiIndex.to_frame").
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'As a convenience, you can pass a list of arrays directly into `Series` or `DataFrame`
    to construct a `MultiIndex` automatically:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'All of the `MultiIndex` constructors accept a `names` argument which stores
    string names for the levels themselves. If no names are provided, `None` will
    be assigned:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This index can back any axis of a pandas object, and the number of **levels**
    of the index is up to you:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We’ve “sparsified” the higher levels of the indexes to make the console output
    a bit easier on the eyes. Note that how the index is displayed can be controlled
    using the `multi_sparse` option in `pandas.set_options()`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'It’s worth keeping in mind that there’s nothing preventing you from using tuples
    as atomic labels on an axis:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The reason that the `MultiIndex` matters is that it can allow you to do grouping,
    selection, and reshaping operations as we will describe below and in subsequent
    areas of the documentation. As you will see in later sections, you can find yourself
    working with hierarchically-indexed data without creating a `MultiIndex` explicitly
    yourself. However, when loading data from a file, you may wish to generate your
    own `MultiIndex` when preparing the data set.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '### Reconstructing the level labels'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The method [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") will return a vector of the labels for each
    location at a particular level:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Basic indexing on axis with MultiIndex
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the important features of hierarchical indexing is that you can select
    data by a “partial” label identifying a subgroup in the data. **Partial** selection
    “drops” levels of the hierarchical index in the result in a completely analogous
    way to selecting a column in a regular DataFrame:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: See [Cross-section with hierarchical index](#advanced-xs) for how to select
    on a deeper level.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '### Defined levels'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") keeps all the defined levels of an index, even if they are
    not actually used. When slicing an index, you may notice this. For example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This is done to avoid a recomputation of the levels in order to make slicing
    highly performant. If you want to see only the used levels, you can use the [`get_level_values()`](../reference/api/pandas.MultiIndex.get_level_values.html#pandas.MultiIndex.get_level_values
    "pandas.MultiIndex.get_level_values") method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: To reconstruct the `MultiIndex` with only the used levels, the [`remove_unused_levels()`](../reference/api/pandas.MultiIndex.remove_unused_levels.html#pandas.MultiIndex.remove_unused_levels
    "pandas.MultiIndex.remove_unused_levels") method may be used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Data alignment and using `reindex`
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Operations between differently-indexed objects having `MultiIndex` on the axes
    will work as you expect; data alignment will work the same as an Index of tuples:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") method of `Series`/`DataFrames` can be called with
    another `MultiIndex`, or even a list or array of tuples:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '## Advanced indexing with hierarchical index'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically integrating `MultiIndex` in advanced indexing with `.loc` is
    a bit challenging, but we’ve made every effort to do so. In general, MultiIndex
    keys take the form of tuples. For example, the following works as you would expect:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Note that `df.loc['bar', 'two']` would also work in this example, but this shorthand
    notation can lead to ambiguity in general.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'If you also want to index a specific column with `.loc`, you must use a tuple
    like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You don’t have to specify all levels of the `MultiIndex` by passing only the
    first elements of the tuple. For example, you can use “partial” indexing to get
    all elements with `bar` in the first level as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This is a shortcut for the slightly more verbose notation `df.loc[('bar',),]`
    (equivalent to `df.loc['bar',]` in this example).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: “Partial” slicing also works quite nicely.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: You can slice with a ‘range’ of values, by providing a slice of tuples.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Passing a list of labels or tuples works similar to reindexing:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that tuples and lists are not treated identically in
    pandas when it comes to indexing. Whereas a tuple is interpreted as one multi-level
    key, a list is used to specify several keys. Or in other words, tuples go horizontally
    (traversing levels), lists go vertically (scanning levels).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Importantly, a list of tuples indexes several complete `MultiIndex` keys, whereas
    a tuple of lists refer to several values within a level:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '### Using slicers'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You can slice a `MultiIndex` by providing multiple indexers.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: You can provide any of the selectors as if you are indexing by label, see [Selection
    by Label](indexing.html#indexing-label), including slices, lists of labels, labels,
    and boolean indexers.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: You can use `slice(None)` to select all the contents of *that* level. You do
    not need to specify all the *deeper* levels, they will be implied as `slice(None)`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: As usual, **both sides** of the slicers are included as this is label indexing.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: You should specify all axes in the `.loc` specifier, meaning the indexer for
    the **index** and for the **columns**. There are some ambiguous cases where the
    passed indexer could be misinterpreted as indexing *both* axes, rather than into
    say the `MultiIndex` for the rows.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'You should do this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'You should **not** do this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Basic MultiIndex slicing using slices, lists, and labels.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You can use [`pandas.IndexSlice`](../reference/api/pandas.IndexSlice.html#pandas.IndexSlice
    "pandas.IndexSlice") to facilitate a more natural syntax using `:`, rather than
    using `slice(None)`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: It is possible to perform quite complicated selections using this method on
    multiple axes at the same time.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Using a boolean indexer you can provide selection related to the *values*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: You can also specify the `axis` argument to `.loc` to interpret the passed slicers
    on a single axis.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Furthermore, you can *set* the values using the following methods.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You can use a right-hand-side of an alignable object as well.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]  ### Cross-section'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: The [`xs()`](../reference/api/pandas.DataFrame.xs.html#pandas.DataFrame.xs "pandas.DataFrame.xs")
    method of `DataFrame` additionally takes a level argument to make selecting data
    at a particular level of a `MultiIndex` easier.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: You can also select on the columns with `xs`, by providing the axis argument.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '`xs` also allows selection with multiple keys.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: You can pass `drop_level=False` to `xs` to retain the level that was selected.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Compare the above with the result using `drop_level=True` (the default value).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]  ### Advanced reindexing and alignment'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the parameter `level` in the [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") and [`align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align") methods of pandas objects is useful to broadcast values
    across a level. For instance:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Swapping levels with `swaplevel`
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`swaplevel()`](../reference/api/pandas.MultiIndex.swaplevel.html#pandas.MultiIndex.swaplevel
    "pandas.MultiIndex.swaplevel") method can switch the order of two levels:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '### Reordering levels with `reorder_levels`'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`reorder_levels()`](../reference/api/pandas.MultiIndex.reorder_levels.html#pandas.MultiIndex.reorder_levels
    "pandas.MultiIndex.reorder_levels") method generalizes the `swaplevel` method,
    allowing you to permute the hierarchical index levels in one step:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]  ### Renaming names of an `Index` or `MultiIndex`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method is used to rename the labels of a `MultiIndex`,
    and is typically used to rename the columns of a `DataFrame`. The `columns` argument
    of `rename` allows a dictionary to be specified that includes only the columns
    you wish to rename.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This method can also be used to rename specific labels of the main index of
    the `DataFrame`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The [`rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") method is used to rename the name of a `Index`
    or `MultiIndex`. In particular, the names of the levels of a `MultiIndex` can
    be specified, which is useful if `reset_index()` is later used to move the values
    from the `MultiIndex` to a column.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note that the columns of a `DataFrame` are an index, so that using `rename_axis`
    with the `columns` argument will change the name of that index.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Both `rename` and `rename_axis` support specifying a dictionary, `Series` or
    a mapping function to map labels/names to new values.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: When working with an `Index` object directly, rather than via a `DataFrame`,
    [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") can be used to change the names.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: You cannot set the names of the MultiIndex via a level.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Use [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") instead.  ### Using slicers'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: You can slice a `MultiIndex` by providing multiple indexers.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: You can provide any of the selectors as if you are indexing by label, see [Selection
    by Label](indexing.html#indexing-label), including slices, lists of labels, labels,
    and boolean indexers.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: You can use `slice(None)` to select all the contents of *that* level. You do
    not need to specify all the *deeper* levels, they will be implied as `slice(None)`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: As usual, **both sides** of the slicers are included as this is label indexing.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: You should specify all axes in the `.loc` specifier, meaning the indexer for
    the **index** and for the **columns**. There are some ambiguous cases where the
    passed indexer could be misinterpreted as indexing *both* axes, rather than into
    say the `MultiIndex` for the rows.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'You should do this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You should **not** do this:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Basic MultiIndex slicing using slices, lists, and labels.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: You can use [`pandas.IndexSlice`](../reference/api/pandas.IndexSlice.html#pandas.IndexSlice
    "pandas.IndexSlice") to facilitate a more natural syntax using `:`, rather than
    using `slice(None)`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: It is possible to perform quite complicated selections using this method on
    multiple axes at the same time.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Using a boolean indexer you can provide selection related to the *values*.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: You can also specify the `axis` argument to `.loc` to interpret the passed slicers
    on a single axis.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Furthermore, you can *set* the values using the following methods.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: You can use a right-hand-side of an alignable object as well.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '### Cross-section'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The [`xs()`](../reference/api/pandas.DataFrame.xs.html#pandas.DataFrame.xs "pandas.DataFrame.xs")
    method of `DataFrame` additionally takes a level argument to make selecting data
    at a particular level of a `MultiIndex` easier.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: You can also select on the columns with `xs`, by providing the axis argument.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '`xs` also allows selection with multiple keys.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: You can pass `drop_level=False` to `xs` to retain the level that was selected.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Compare the above with the result using `drop_level=True` (the default value).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '### Advanced reindexing and alignment'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the parameter `level` in the [`reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") and [`align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align") methods of pandas objects is useful to broadcast values
    across a level. For instance:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Swapping levels with `swaplevel`
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`swaplevel()`](../reference/api/pandas.MultiIndex.swaplevel.html#pandas.MultiIndex.swaplevel
    "pandas.MultiIndex.swaplevel") method can switch the order of two levels:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '### Reordering levels with `reorder_levels`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`reorder_levels()`](../reference/api/pandas.MultiIndex.reorder_levels.html#pandas.MultiIndex.reorder_levels
    "pandas.MultiIndex.reorder_levels") method generalizes the `swaplevel` method,
    allowing you to permute the hierarchical index levels in one step:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '### Renaming names of an `Index` or `MultiIndex`'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method is used to rename the labels of a `MultiIndex`,
    and is typically used to rename the columns of a `DataFrame`. The `columns` argument
    of `rename` allows a dictionary to be specified that includes only the columns
    you wish to rename.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: This method can also be used to rename specific labels of the main index of
    the `DataFrame`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: The [`rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") method is used to rename the name of a `Index`
    or `MultiIndex`. In particular, the names of the levels of a `MultiIndex` can
    be specified, which is useful if `reset_index()` is later used to move the values
    from the `MultiIndex` to a column.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Note that the columns of a `DataFrame` are an index, so that using `rename_axis`
    with the `columns` argument will change the name of that index.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Both `rename` and `rename_axis` support specifying a dictionary, `Series` or
    a mapping function to map labels/names to new values.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: When working with an `Index` object directly, rather than via a `DataFrame`,
    [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") can be used to change the names.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You cannot set the names of the MultiIndex via a level.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Use [`Index.set_names()`](../reference/api/pandas.Index.set_names.html#pandas.Index.set_names
    "pandas.Index.set_names") instead.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a `MultiIndex`
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex")-ed objects to be indexed and sliced effectively, they need
    to be sorted. As with any index, you can use [`sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index").
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: You may also pass a level name to `sort_index` if the `MultiIndex` levels are
    named.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'On higher dimensional objects, you can sort any of the other axes by level
    if they have a `MultiIndex`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Indexing will work even if the data are not sorted, but will be rather inefficient
    (and show a `PerformanceWarning`). It will also return a copy of the data rather
    than a view:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Furthermore, if you try to index something that is not fully lexsorted, this
    can raise:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The `is_monotonic_increasing()` method on a `MultiIndex` shows if the index
    is sorted:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: And now selection works as expected.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Take methods
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to NumPy ndarrays, pandas `Index`, `Series`, and `DataFrame` also provides
    the [`take()`](../reference/api/pandas.DataFrame.take.html#pandas.DataFrame.take
    "pandas.DataFrame.take") method that retrieves elements along a given axis at
    the given indices. The given indices must be either a list or an ndarray of integer
    index positions. `take` will also accept negative integers as relative positions
    to the end of the object.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: For DataFrames, the given indices should be a 1d list or ndarray that specifies
    row or column positions.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: It is important to note that the `take` method on pandas objects are not intended
    to work on boolean indices and may return unexpected results.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Finally, as a small note on performance, because the `take` method handles a
    narrower range of inputs, it can offer performance that is a good deal faster
    than fancy indexing.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '## Index types'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed `MultiIndex` in the previous sections pretty extensively.
    Documentation about `DatetimeIndex` and `PeriodIndex` are shown [here](timeseries.html#timeseries-overview),
    and documentation about `TimedeltaIndex` is found [here](timedeltas.html#timedeltas-index).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: In the following sub-sections we will highlight some other index types.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '### CategoricalIndex'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[`CategoricalIndex`](../reference/api/pandas.CategoricalIndex.html#pandas.CategoricalIndex
    "pandas.CategoricalIndex") is a type of index that is useful for supporting indexing
    with duplicates. This is a container around a [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") and allows efficient indexing and storage of an index with
    a large number of duplicated elements.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Setting the index will create a `CategoricalIndex`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Indexing with `__getitem__/.iloc/.loc` works similarly to an `Index` with duplicates.
    The indexers **must** be in the category or the operation will raise a `KeyError`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The `CategoricalIndex` is **preserved** after indexing:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Sorting the index will sort by the order of the categories (recall that we created
    the index with `CategoricalDtype(list('cab'))`, so the sorted order is `cab`).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Groupby operations on the index will preserve the index nature as well.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Reindexing operations will return a resulting index based on the type of the
    passed indexer. Passing a list will return a plain-old `Index`; indexing with
    a `Categorical` will return a `CategoricalIndex`, indexed according to the categories
    of the **passed** `Categorical` dtype. This allows one to arbitrarily index these
    even with values **not** in the categories, similarly to how you can reindex **any**
    pandas index.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Warning
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping and Comparison operations on a `CategoricalIndex` must have the same
    categories or a `TypeError` will be raised.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]  ### RangeIndex'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[`RangeIndex`](../reference/api/pandas.RangeIndex.html#pandas.RangeIndex "pandas.RangeIndex")
    is a sub-class of [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    that provides the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. `RangeIndex` is an optimized version of `Index` that
    can represent a monotonic ordered set. These are analogous to Python [range types](https://docs.python.org/3/library/stdtypes.html#typesseq-range).
    A `RangeIndex` will always have an `int64` dtype.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '`RangeIndex` is the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'A `RangeIndex` will behave similarly to a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") with an `int64` dtype and operations on a `RangeIndex`, whose
    result cannot be represented by a `RangeIndex`, but should have an integer dtype,
    will be converted to an `Index` with `int64`. For example:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]  ### IntervalIndex'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[`IntervalIndex`](../reference/api/pandas.IntervalIndex.html#pandas.IntervalIndex
    "pandas.IntervalIndex") together with its own dtype, `IntervalDtype` as well as
    the [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval "pandas.Interval")
    scalar type, allow first-class support in pandas for interval notation.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: The `IntervalIndex` allows some unique indexing and is also used as a return
    type for the categories in [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut").
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with an `IntervalIndex`
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `IntervalIndex` can be used in `Series` and in `DataFrame` as the index.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Label based indexing via `.loc` along the edges of an interval works as you
    would expect, selecting that particular interval.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: If you select a label *contained* within an interval, this will also select
    the interval.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Selecting using an `Interval` will only return exact matches.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Trying to select an `Interval` that is not exactly contained in the `IntervalIndex`
    will raise a `KeyError`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Selecting all `Intervals` that overlap a given `Interval` can be performed using
    the [`overlaps()`](../reference/api/pandas.IntervalIndex.overlaps.html#pandas.IntervalIndex.overlaps
    "pandas.IntervalIndex.overlaps") method to create a boolean indexer.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Binning data with `cut` and `qcut`
  id: totrans-532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") both return a `Categorical` object, and the bins they create are
    stored as an `IntervalIndex` in its `.categories` attribute.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") also accepts
    an `IntervalIndex` for its `bins` argument, which enables a useful pandas idiom.
    First, We call [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut")
    with some data and `bins` set to a fixed number, to generate the bins. Then, we
    pass the values of `.categories` as the `bins` argument in subsequent calls to
    [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut"), supplying
    new data which will be binned into the same bins.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Any value which falls outside all bins will be assigned a `NaN` value.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Generating ranges of intervals
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we need intervals on a regular frequency, we can use the [`interval_range()`](../reference/api/pandas.interval_range.html#pandas.interval_range
    "pandas.interval_range") function to create an `IntervalIndex` using various combinations
    of `start`, `end`, and `periods`. The default frequency for `interval_range` is
    a 1 for numeric intervals, and calendar day for datetime-like intervals:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'The `freq` parameter can used to specify non-default frequencies, and can utilize
    a variety of [frequency aliases](timeseries.html#timeseries-offset-aliases) with
    datetime-like intervals:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Additionally, the `closed` parameter can be used to specify which side(s) the
    intervals are closed on. Intervals are closed on the right side by default.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    intervals from `start` to `end` inclusively, with `periods` number of elements
    in the resulting `IntervalIndex`:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]  ### CategoricalIndex'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[`CategoricalIndex`](../reference/api/pandas.CategoricalIndex.html#pandas.CategoricalIndex
    "pandas.CategoricalIndex") is a type of index that is useful for supporting indexing
    with duplicates. This is a container around a [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") and allows efficient indexing and storage of an index with
    a large number of duplicated elements.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Setting the index will create a `CategoricalIndex`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Indexing with `__getitem__/.iloc/.loc` works similarly to an `Index` with duplicates.
    The indexers **must** be in the category or the operation will raise a `KeyError`.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'The `CategoricalIndex` is **preserved** after indexing:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Sorting the index will sort by the order of the categories (recall that we created
    the index with `CategoricalDtype(list('cab'))`, so the sorted order is `cab`).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Groupby operations on the index will preserve the index nature as well.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Reindexing operations will return a resulting index based on the type of the
    passed indexer. Passing a list will return a plain-old `Index`; indexing with
    a `Categorical` will return a `CategoricalIndex`, indexed according to the categories
    of the **passed** `Categorical` dtype. This allows one to arbitrarily index these
    even with values **not** in the categories, similarly to how you can reindex **any**
    pandas index.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Warning
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping and Comparison operations on a `CategoricalIndex` must have the same
    categories or a `TypeError` will be raised.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '### RangeIndex'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[`RangeIndex`](../reference/api/pandas.RangeIndex.html#pandas.RangeIndex "pandas.RangeIndex")
    is a sub-class of [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    that provides the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. `RangeIndex` is an optimized version of `Index` that
    can represent a monotonic ordered set. These are analogous to Python [range types](https://docs.python.org/3/library/stdtypes.html#typesseq-range).
    A `RangeIndex` will always have an `int64` dtype.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '`RangeIndex` is the default index for all [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'A `RangeIndex` will behave similarly to a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") with an `int64` dtype and operations on a `RangeIndex`, whose
    result cannot be represented by a `RangeIndex`, but should have an integer dtype,
    will be converted to an `Index` with `int64`. For example:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '### IntervalIndex'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[`IntervalIndex`](../reference/api/pandas.IntervalIndex.html#pandas.IntervalIndex
    "pandas.IntervalIndex") together with its own dtype, `IntervalDtype` as well as
    the [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval "pandas.Interval")
    scalar type, allow first-class support in pandas for interval notation.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The `IntervalIndex` allows some unique indexing and is also used as a return
    type for the categories in [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut").
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with an `IntervalIndex`
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `IntervalIndex` can be used in `Series` and in `DataFrame` as the index.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Label based indexing via `.loc` along the edges of an interval works as you
    would expect, selecting that particular interval.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: If you select a label *contained* within an interval, this will also select
    the interval.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Selecting using an `Interval` will only return exact matches.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Trying to select an `Interval` that is not exactly contained in the `IntervalIndex`
    will raise a `KeyError`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Selecting all `Intervals` that overlap a given `Interval` can be performed using
    the [`overlaps()`](../reference/api/pandas.IntervalIndex.overlaps.html#pandas.IntervalIndex.overlaps
    "pandas.IntervalIndex.overlaps") method to create a boolean indexer.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Binning data with `cut` and `qcut`
  id: totrans-589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") both return a `Categorical` object, and the bins they create are
    stored as an `IntervalIndex` in its `.categories` attribute.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") also accepts
    an `IntervalIndex` for its `bins` argument, which enables a useful pandas idiom.
    First, We call [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut")
    with some data and `bins` set to a fixed number, to generate the bins. Then, we
    pass the values of `.categories` as the `bins` argument in subsequent calls to
    [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut"), supplying
    new data which will be binned into the same bins.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Any value which falls outside all bins will be assigned a `NaN` value.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Generating ranges of intervals
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we need intervals on a regular frequency, we can use the [`interval_range()`](../reference/api/pandas.interval_range.html#pandas.interval_range
    "pandas.interval_range") function to create an `IntervalIndex` using various combinations
    of `start`, `end`, and `periods`. The default frequency for `interval_range` is
    a 1 for numeric intervals, and calendar day for datetime-like intervals:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'The `freq` parameter can used to specify non-default frequencies, and can utilize
    a variety of [frequency aliases](timeseries.html#timeseries-offset-aliases) with
    datetime-like intervals:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Additionally, the `closed` parameter can be used to specify which side(s) the
    intervals are closed on. Intervals are closed on the right side by default.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    intervals from `start` to `end` inclusively, with `periods` number of elements
    in the resulting `IntervalIndex`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Indexing with an `IntervalIndex`
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An `IntervalIndex` can be used in `Series` and in `DataFrame` as the index.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Label based indexing via `.loc` along the edges of an interval works as you
    would expect, selecting that particular interval.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: If you select a label *contained* within an interval, this will also select
    the interval.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Selecting using an `Interval` will only return exact matches.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Trying to select an `Interval` that is not exactly contained in the `IntervalIndex`
    will raise a `KeyError`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Selecting all `Intervals` that overlap a given `Interval` can be performed using
    the [`overlaps()`](../reference/api/pandas.IntervalIndex.overlaps.html#pandas.IntervalIndex.overlaps
    "pandas.IntervalIndex.overlaps") method to create a boolean indexer.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Binning data with `cut` and `qcut`
  id: totrans-617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") both return a `Categorical` object, and the bins they create are
    stored as an `IntervalIndex` in its `.categories` attribute.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut") also accepts
    an `IntervalIndex` for its `bins` argument, which enables a useful pandas idiom.
    First, We call [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut")
    with some data and `bins` set to a fixed number, to generate the bins. Then, we
    pass the values of `.categories` as the `bins` argument in subsequent calls to
    [`cut()`](../reference/api/pandas.cut.html#pandas.cut "pandas.cut"), supplying
    new data which will be binned into the same bins.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Any value which falls outside all bins will be assigned a `NaN` value.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Generating ranges of intervals
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we need intervals on a regular frequency, we can use the [`interval_range()`](../reference/api/pandas.interval_range.html#pandas.interval_range
    "pandas.interval_range") function to create an `IntervalIndex` using various combinations
    of `start`, `end`, and `periods`. The default frequency for `interval_range` is
    a 1 for numeric intervals, and calendar day for datetime-like intervals:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'The `freq` parameter can used to specify non-default frequencies, and can utilize
    a variety of [frequency aliases](timeseries.html#timeseries-offset-aliases) with
    datetime-like intervals:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Additionally, the `closed` parameter can be used to specify which side(s) the
    intervals are closed on. Intervals are closed on the right side by default.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    intervals from `start` to `end` inclusively, with `periods` number of elements
    in the resulting `IntervalIndex`:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Miscellaneous indexing FAQ
  id: totrans-632
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integer indexing
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Label-based indexing with integer axis labels is a thorny topic. It has been
    discussed heavily on mailing lists and among various members of the scientific
    Python community. In pandas, our general viewpoint is that labels matter more
    than integer locations. Therefore, with an integer axis index *only* label-based
    indexing is possible with the standard tools like `.loc`. The following code will
    generate exceptions:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: This deliberate decision was made to prevent ambiguities and subtle bugs (many
    users reported finding bugs when the API change was made to stop “falling back”
    on position-based indexing).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Non-monotonic indexes require exact matches
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the index of a `Series` or `DataFrame` is monotonically increasing or decreasing,
    then the bounds of a label-based slice can be outside the range of the index,
    much like slice indexing a normal Python `list`. Monotonicity of an index can
    be tested with the [`is_monotonic_increasing()`](../reference/api/pandas.Index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing
    "pandas.Index.is_monotonic_increasing") and [`is_monotonic_decreasing()`](../reference/api/pandas.Index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing
    "pandas.Index.is_monotonic_decreasing") attributes.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: On the other hand, if the index is not monotonic, then both slice bounds must
    be *unique* members of the index.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '`Index.is_monotonic_increasing` and `Index.is_monotonic_decreasing` only check
    that an index is weakly monotonic. To check for strict monotonicity, you can combine
    one of those with the [`is_unique()`](../reference/api/pandas.Index.is_unique.html#pandas.Index.is_unique
    "pandas.Index.is_unique") attribute.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '### Endpoints are inclusive'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared with standard Python sequence slicing in which the slice endpoint
    is not inclusive, label-based slicing in pandas **is inclusive**. The primary
    reason for this is that it is often not possible to easily determine the “successor”
    or next element after a particular label in an index. For example, consider the
    following `Series`:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Suppose we wished to slice from `c` to `e`, using integers this would be accomplished
    as such:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'However, if you only had `c` and `e`, determining the next element in the index
    can be somewhat complicated. For example, the following does not work:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'A very common use case is to limit a time series to start and end at two specific
    dates. To enable this, we made the design choice to make label-based slicing include
    both endpoints:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: This is most definitely a “practicality beats purity” sort of thing, but it
    is something to watch out for if you expect label-based slicing to behave exactly
    in the way that standard Python integer slicing works.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Indexing potentially changes underlying Series dtype
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The different indexing operation can potentially change the dtype of a `Series`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: This is because the (re)indexing operations above silently inserts `NaNs` and
    the `dtype` changes accordingly. This can cause some issues when using `numpy`
    `ufuncs` such as `numpy.logical_and`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: See the [GH 2388](https://github.com/pandas-dev/pandas/issues/2388) for a more
    detailed discussion.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Integer indexing
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Label-based indexing with integer axis labels is a thorny topic. It has been
    discussed heavily on mailing lists and among various members of the scientific
    Python community. In pandas, our general viewpoint is that labels matter more
    than integer locations. Therefore, with an integer axis index *only* label-based
    indexing is possible with the standard tools like `.loc`. The following code will
    generate exceptions:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: This deliberate decision was made to prevent ambiguities and subtle bugs (many
    users reported finding bugs when the API change was made to stop “falling back”
    on position-based indexing).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Non-monotonic indexes require exact matches
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the index of a `Series` or `DataFrame` is monotonically increasing or decreasing,
    then the bounds of a label-based slice can be outside the range of the index,
    much like slice indexing a normal Python `list`. Monotonicity of an index can
    be tested with the [`is_monotonic_increasing()`](../reference/api/pandas.Index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing
    "pandas.Index.is_monotonic_increasing") and [`is_monotonic_decreasing()`](../reference/api/pandas.Index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing
    "pandas.Index.is_monotonic_decreasing") attributes.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: On the other hand, if the index is not monotonic, then both slice bounds must
    be *unique* members of the index.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '`Index.is_monotonic_increasing` and `Index.is_monotonic_decreasing` only check
    that an index is weakly monotonic. To check for strict monotonicity, you can combine
    one of those with the [`is_unique()`](../reference/api/pandas.Index.is_unique.html#pandas.Index.is_unique
    "pandas.Index.is_unique") attribute.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '### Endpoints are inclusive'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared with standard Python sequence slicing in which the slice endpoint
    is not inclusive, label-based slicing in pandas **is inclusive**. The primary
    reason for this is that it is often not possible to easily determine the “successor”
    or next element after a particular label in an index. For example, consider the
    following `Series`:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Suppose we wished to slice from `c` to `e`, using integers this would be accomplished
    as such:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'However, if you only had `c` and `e`, determining the next element in the index
    can be somewhat complicated. For example, the following does not work:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'A very common use case is to limit a time series to start and end at two specific
    dates. To enable this, we made the design choice to make label-based slicing include
    both endpoints:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: This is most definitely a “practicality beats purity” sort of thing, but it
    is something to watch out for if you expect label-based slicing to behave exactly
    in the way that standard Python integer slicing works.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Indexing potentially changes underlying Series dtype
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The different indexing operation can potentially change the dtype of a `Series`.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: This is because the (re)indexing operations above silently inserts `NaNs` and
    the `dtype` changes accordingly. This can cause some issues when using `numpy`
    `ufuncs` such as `numpy.logical_and`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: See the [GH 2388](https://github.com/pandas-dev/pandas/issues/2388) for a more
    detailed discussion.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
