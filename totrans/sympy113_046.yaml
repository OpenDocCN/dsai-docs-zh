- en: Glossary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/explanation/glossary.html](https://docs.sympy.org/latest/explanation/glossary.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This page is a glossary for various terms used throughout the SymPy documentation.
    This glossary is primarily for terms that are specific to SymPy. For more general
    Python terms, refer to the [Python glossary](https://docs.python.org/3/glossary.html).
    Mathematical terms are only included here if they have a specific meaning in SymPy.
    For general mathematical definitions, refer to other sources such as [Wikipedia](https://www.wikipedia.org/)
    or [MathWorld](https://mathworld.wolfram.com/), as well as the references in the
    documentation for the specific SymPy functions.
  prefs: []
  type: TYPE_NORMAL
- en: Antiderivative
  prefs: []
  type: TYPE_NORMAL
- en: An *antiderivative* of a function \(f(x)\) with respect to \(x\) is a function
    \(F(x)\) such that \(\frac{d}{dx}F(x) = f(x).\) It is also sometimes called an
    “indefinite integral” of \(f(x)\), and written as \(\int f(x)\,dx.\) Antiderivatives
    in SymPy can be computed with [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate"). Note some sources call this the “primitive”
    of \(f(x)\), but this terminology is not used in SymPy because it is not as universally
    used as “antiderivative”, and because “primitive” has other meanings in mathematics
    and in [`SymPy`](../modules/polys/reference.html#sympy.polys.polytools.primitive
    "sympy.polys.polytools.primitive").
  prefs: []
  type: TYPE_NORMAL
- en: '`args`'
  prefs: []
  type: TYPE_NORMAL
- en: The *`args`* property of a SymPy [expression](#term-Expression) is a tuple of
    the top-level [subexpressions](#term-Subexpression) used to create it. They are
    the arguments to the class used to create the expression. The args of any expression
    can be obtained by the `.args` attribute. For example, `(1 + x*y).args` is `(1,
    x*y)`, because it equals `Add(1, x*y)`. The `args` together with [func](#term-func)
    completely define an expression. It is always possible to walk the [expression
    tree](#term-Expression-Tree) and extract any subexpression of a SymPy expression
    by repeated use of `.args`. Every SymPy expression can be rebuilt exactly with
    `func` and `args`, that is, `expr.func(*expr.args) == expr` will always be true
    of any SymPy expression `expr`. The args of an expression may be the empty tuple
    `()`, meaning the expression is an [atom](#term-Atom).
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions
  prefs: []
  type: TYPE_NORMAL
- en: '*Assumptions* are a set of predicates on a [symbol](#term-Symbol) or [expression](#term-Expression)
    that define the set of possible values it can take. Some examples of assumptions
    are `positive`, `real`, and `integer`. Assumptions are related to one another
    logically, for example, an assumption of `integer` automatically implies `real`.
    Assumptions use a [three-valued logic](#term-Three-valued-logic) system where
    predicates are either `True`, `False`, or `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions are either *assumed* or *queried*. For example, a symbol `x` might
    be *assumed* to be positive by defining it as `x = symbols('x', positive=True)`.
    Then an assumption might be *queried* on the expression containing this symbol,
    like `(x + 1).is_real`, which in this case would return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: If no assumptions are assumed on a symbol, then by default symbols are assumed
    to be general complex numbers. Setting assumptions is important because certain
    simplifications are only mathematically true in a restricted domain, for example,
    \(\sqrt{x^2} = x\) is not true for general complex \(x\) but it is true when \(x\)
    is positive. SymPy functions will never perform an operation on an expression
    unless it is true for all values allowed by its assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: SymPy has two separate assumptions systems, which are closely related to one
    another. In the first, which is sometimes called the “old assumptions” because
    it is older, assumptions are assumed on [Symbol](#term-Symbol) objects and queried
    with [is_*](#term-is_) attributes. In the second, which is sometimes called the
    “new assumptions”, assumptions are assumed using separate predicate objects like
    `Q.positive` and queried using the [`ask()`](../modules/assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask") function. The newer assumptions system is able to
    support more complex queries, but is also not as well developed as the older one.
    Most users of SymPy should prefer the older assumptions system at this time.
  prefs: []
  type: TYPE_NORMAL
- en: See the [assumptions guide](../guides/assumptions.html#assumptions-guide) for
    more details on assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Atom
  prefs: []
  type: TYPE_NORMAL
- en: An *atom* is an expression whose [args](#term-args) is the empty tuple `()`.
    Atoms are the leaves of the [expression tree](#term-Expression-Tree). For example,
    if a function uses recursion to walk an expression tree using `args`, the atomic
    expressions will be the base case of the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the class [`Atom`](../modules/core.html#sympy.core.basic.Atom "sympy.core.basic.Atom")
    is sometimes used as the base class of atomic expressions, but it is not a requirement
    for atomic expressions to subclass this class. The only requirement for an expression
    to be atomic is for its [args](#term-args) to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Simplification
  prefs: []
  type: TYPE_NORMAL
- en: '*Automatic Simplification* refers to any simplification that happens automatically
    inside of a class constructor. For example, `x + x` is automatically simplified
    to `2*x` in the [`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add")
    constructor. Unlike manual [simplification](#term-Simplification), automatic simplification
    can only be disabled by setting `evaluate=False` (see [Unevaluated](#term-Unevaluated)).
    Automatic simplification is often done so that expressions become [canonicalized](#term-Canonicalize).
    Excessive automatic simplification is discouraged, as it makes it impossible to
    represent the non-simplified form of the expression without using tricks like
    `evaluate=False`, and it can often be an expensive thing to do in a class constructor.
    Instead, manual [simplification](#term-Simplification)/[canonicalization](#term-Canonicalize)
    is generally preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")*
    is the superclass of all SymPy expressions. It defines the basic methods required
    for a SymPy expression, such as [args](#term-args), [func](#term-func), [equality](#term-Structural-Equality),
    [immutability](#term-Immutable), and some useful expression manipulation functions
    such as [substitution](#term-Substitution). Most SymPy classes will subclass a
    more specific `Basic` subclass such as [Boolean](#term-Boolean), [Expr](#term-Expr),
    [Function](#term-Function-class), or [Matrix](#term-Matrix). An object that is
    not a `Basic` instance typically cannot be used in SymPy functions, unless it
    can be turned into one via [sympify()](#term-sympify).'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")*
    is the base class for the classes in the [`logic`](../modules/logic.html#module-sympy.logic
    "sympy.logic") module. `Boolean` instances represent logical predicates that are
    elements of a [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra)
    and can be thought of as having a “true” or “false” value (note that `Boolean`
    objects do not use the [three-valued logic](#term-Three-valued-logic) used by
    the [assumptions](#term-Assumptions)).'
  prefs: []
  type: TYPE_NORMAL
- en: Bound symbols
  prefs: []
  type: TYPE_NORMAL
- en: A [symbol](#term-Symbol) in an expression is *bound* if it is not [free](#term-Free-symbols).
    A bound symbol can be replaced everywhere with new symbol and the resulting expression
    will still be mathematically equivalent. Examples of bound symbols are integration
    variables in definite integrals and substituted variables in a [`Subs`](../modules/core.html#sympy.core.function.Subs
    "sympy.core.function.Subs"). Bound symbols are sometimes represented by [dummy](#term-Dummy)
    symbols, but the are not always [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy") objects, and [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy") objects are not always bound symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Canonical Form
  prefs: []
  type: TYPE_NORMAL
- en: Canonicalize
  prefs: []
  type: TYPE_NORMAL
- en: Often expressions can be written in multiple, mathematically equivalent ways.
    A *canonical form* is a single way of writing an expression, which all equivalent
    expressions can be transformed to. An expression that is put into a canonical
    form is said to be *canonicalized*. Often canonical forms are unique and have
    properties that make them easier to work with. For example, a common canonical
    form used for rational functions is \(\frac{p}{q}\), where \(p\) and \(q\) are
    expanded polynomials with no common factors.
  prefs: []
  type: TYPE_NORMAL
- en: Code Generation
  prefs: []
  type: TYPE_NORMAL
- en: '*Code generation* refers to the process of taking a SymPy expression and converting
    it into code for a language or library so that it can be evaluated numerically.
    SymPy supports code generation for [dozens of languages](../reference/public/codegeneration/index.html#codegen-module)
    and libraries including C, C++, Fortran, and NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: The [*core*](../modules/core.html#core-module) is the submodule that contains
    the important functionality used by all SymPy objects. This includes the [Basic](#term-Basic)
    and [Expr](#term-Expr) base classes, classes like [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add"), [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    and [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow"),
    and the [assumptions](#term-Assumptions).
  prefs: []
  type: TYPE_NORMAL
- en: Dummy
  prefs: []
  type: TYPE_NORMAL
- en: A *dummy* [symbol](#term-Symbol) is a symbol that is automatically unequal to
    any other dummy symbol other than itself, even if it has the same name. Dummy
    symbols are used when a function needs to return an expression with a new symbol,
    so that it cannot accidentally clash with a [symbol](#term-Symbol) of the same
    name. Dummy symbols can be created with [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy").
  prefs: []
  type: TYPE_NORMAL
- en: Equation
  prefs: []
  type: TYPE_NORMAL
- en: An *equation* is an [expression](#term-Expression) that has an equals sign \(=\).
    Equations in SymPy are represented using the [`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") class. Equations are **not** created using the
    `==` operator. The `==` operator does a [structural equality](#term-Structural-Equality)
    check between two expressions, and always returns `True` or `False`. To contrast,
    a symbolic equation may be [unevaluated](#term-Unevaluated). Equations are considered
    [booleans](#term-Boolean) since they mathematically represent a predicate value
    that is either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '`_eval_*`'
  prefs: []
  type: TYPE_NORMAL
- en: Various methods on [Basic](#term-Basic) and [Expr](#term-Expr) can be defined
    on subclasses using special *`_eval_*`* methods. For example, an object can define
    how it will be processed by the [`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff") function by defining a `_eval_derivative` method.
    `_eval_*` methods used are instead of overriding the method itself so that the
    method defined on the base class can do pre-processing before dispatching to the
    `_eval_*` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`evalf`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*`evalf`*](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")
    is the method present on every [Expr](#term-Expr) object that evaluates it to
    a floating-point numerical value, or converts the constant parts of the expression
    to a numerical value if it contains [symbols](#term-Symbol). The [`.n()`](../modules/core.html#sympy.core.evalf.EvalfMixin.n
    "sympy.core.evalf.EvalfMixin.n") method and [`N()`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N") function are both shorthands for `evalf`. “evalf” stands
    for “evaluate floating-point”. `evalf` uses [mpmath](#term-mpmath) under the hood
    to evaluate expressions to arbitrary precision.'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate
  prefs: []
  type: TYPE_NORMAL
- en: '*Evaluate* can refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: The process of converting an [expression](#term-Expression) into a numerical
    value (see [evalf](#term-evalf)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of [automatic simplification](#term-Automatic-Simplification) that
    occurs when creating an expression (see [Unevaluated](#term-Unevaluated)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of replacing one or more [symbols](#term-Symbol) in an expression
    with numeric values or with other expressions using [substitution](#term-Substitution).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")*
    is the superclass of all algebraic SymPy expressions. It is itself a subclass
    of [Basic](#term-Basic). SymPy expressions that can be in an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add"), [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    or [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow") should
    be `Expr` subclasses. Not all SymPy classes are subclasses of `Expr`, for example,
    [Boolean](#term-Boolean) objects are [Basic](#term-Basic) but not `Expr`, because
    boolean expressions do not make mathematical sense in classes like [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") or [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul").'
  prefs: []
  type: TYPE_NORMAL
- en: Expression
  prefs: []
  type: TYPE_NORMAL
- en: Any SymPy object, that is, any instance of [Basic](#term-Basic), may be called
    an *expression*. Sometimes, the term “expression” is reserved for [Expr](#term-Expr)
    objects, which are algebraic expressions. Expressions are not to be confused with
    [equations](#term-Equation), which are a specific types of expressions that represents
    mathematical equalities.
  prefs: []
  type: TYPE_NORMAL
- en: Expression Tree
  prefs: []
  type: TYPE_NORMAL
- en: An *expression tree* is a [tree](https://en.wikipedia.org/wiki/Tree_(data_structure))
    of [expressions](#term-Expression). Every expression is built up from smaller
    expressions as a tree. The nodes of an expression tree are expressions and the
    children of each node are the direct [subexpressions](#term-Subexpression) that
    constitute that expression. Alternatively, one can view an expression tree as
    a tree where the non-leaf nodes are [funcs](#term-func) and the leaf nodes are
    [atoms](#term-Atom). An example expression tree is shown in the [tutorial](../tutorials/intro-tutorial/manipulation.html#tutorial-expression-trees).
    The expression tree of any SymPy expression can be obtained by recursing through
    [args](#term-args). Note that because SymPy expressions are [immutable](#term-Immutable)
    and are treated equal strictly by [structural equality](#term-Structural-Equality),
    one may also think of an expression tree as being a [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph),
    where identical subexpressions are only represented in the graph once.
  prefs: []
  type: TYPE_NORMAL
- en: Free symbols
  prefs: []
  type: TYPE_NORMAL
- en: A [symbol](#term-Symbol) in an expression is *free* if the expression mathematically
    depends on the value of that symbol. That is, if the symbol were replaced with
    a new symbol, the result would be a different expression. Symbols that are not
    free are [bound](#term-Bound-symbols). The free symbols of an expression can be
    accessed with the [`free_symbols`](../modules/core.html#sympy.core.basic.Basic.free_symbols
    "sympy.core.basic.Basic.free_symbols") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`func`'
  prefs: []
  type: TYPE_NORMAL
- en: The *`func`* property is the function of an [expression](#term-Expression),
    which can be obtained by `expr.func`. This is usually the same as `type(expr)`,
    but may differ in some cases, so it should be preferred to use `expr.func` instead
    of `type(expr)` when rebuilding expressions with [args](#term-args). Every SymPy
    expression can be rebuilt exactly with `func` and `args`, that is, `expr.func(*expr.args)
    == expr` will always be true of any SymPy expression `expr`.
  prefs: []
  type: TYPE_NORMAL
- en: Function
  prefs: []
  type: TYPE_NORMAL
- en: '*Function* may refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: A mathematical function, that is, something which maps values from a domain
    to a range. Sometimes an [expression](#term-Expression) containing a [symbol](#term-Symbol)
    is colloquially called a “function” because the symbol can be replaced with a
    value using [substitution](#term-Substitution), [evaluating](#term-Evaluate) the
    expression. This usage is colloquial because one must use the [`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs") method to do this rather than the typical Python
    function calling syntax, and because it is not specific about what variable(s)
    the expression is a function of, so generally the term “expression” should be
    preferred unless something is an actual function. An expression can be converted
    into a function object that can be called using the Python `f(x)` syntax using
    [`Lambda`](../modules/core.html#sympy.core.function.Lambda "sympy.core.function.Lambda").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the SymPy [Function](#term-Function-class) class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python function, i.e., a function defined using the `def` keyword. Python
    functions are not [symbolic](#term-Symbolic), since they must always return a
    value and thus cannot be [unevaluated](#term-Unevaluated).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")
    (class)'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")*
    is the base class of symbolic functions in SymPy. This includes common functions
    like [`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin") and [`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp"), special functions like [`zeta()`](../modules/functions/special.html#sympy.functions.special.zeta_functions.zeta
    "sympy.functions.special.zeta_functions.zeta") and [`hyper()`](../modules/functions/special.html#sympy.functions.special.hyper.hyper
    "sympy.functions.special.hyper.hyper"), and integral functions like [`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi") and [`divisor_sigma()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma"). Function classes are always
    [symbolic](#term-Symbolic), meaning that they typically remain [unevaluated](#term-Unevaluated)
    when passed a [symbol](#term-Symbol), like `f(x)`. Not every symbolic [expression](#term-Expression)
    class is a `Function` subclass, for example, [core](#term-Core) classes like `Add`
    and `Mul` are not `Function` subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Function` may also be used to create an [undefined function](#term-Undefined-Function)
    by passing it a string name for the function, like `Function(''f'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Not every function in SymPy is a symbolic `Function` class; some are just Python
    functions which always return a value. For example, most simplification functions
    like [simplify()](#term-Simplification) cannot be represented symbolically.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable
  prefs: []
  type: TYPE_NORMAL
- en: In Python, objects are *immutable* if they can not be modified in-place. In
    order to change an immutable object, a new object must be created. In SymPy, all
    [Basic](#term-Basic) objects are immutable. This means that all functions that
    operate on [expressions](#term-Expression) will return a new expression and leave
    the original unchanged. Performing an operation on an expression will never change
    other objects or expressions that reference that expression. This also means that
    any two objects that are [equal](#term-Structural-Equality) are completely interchangeable
    and may be thought of as being the same object, even if they happen to be two
    different objects in memory. Immutability makes it easier to maintain a mental
    model of code, because there is no hidden state. SymPy objects being immutable
    also means that they are hashable, which allows them to be used as dictionary
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive
  prefs: []
  type: TYPE_NORMAL
- en: '*Interactive* usage refers to using SymPy in an interactive REPL environment
    such as the Python prompt, [isympy](#term-isympy), [IPython](https://ipython.org/),
    or the [Jupyter notebook](https://jupyter.org/). When using SymPy interactively,
    all commands are typed in real time by the user and all intermediate results are
    shown. *Interactive* use is in contrast with *programmatic* use, which is where
    the code is written in a file which is either executed as a script or is part
    of a larger Python library. Some SymPy idioms are only recommended for interactive
    use and are considered anti-patterns when used programmatically. For example,
    running `from sympy import *` is convenient when using SymPy interactively, but
    is generally frowned upon for programmatic usage, where importing names explicitly
    just using `import sympy` is preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes in SymPy that start with *`is_`* and use a *lowercase* name query
    the given [assumption](#term-Assumptions) on that object (note: there are a few
    properties that are an exception to this because they do not use the assumptions
    system, see [the assumptions guide](../guides/assumptions.html#assumptions-guide-other-is-properties)).
    For example, `x.is_integer` will query the `integer` assumption on `x`. `is_*`
    attributes that use a *Capitalized* name test if an object is an instance of the
    given class. Sometimes the same name will exist for both the lowercase and Capitalized
    property, but they are different things. For example, `x.is_Integer` is only `True`
    if `x` is an instance of [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), whereas `x.is_integer` is `True` if `x` is `integer`
    in the assumptions system, such as `x = symbols(''x'', integer=True)`. In general,
    it is recommended to not use `is_Capitalized` properties. They exist for historical
    purposes, but they are unneeded because the same thing can be achieved with `isinstance()`.
    See also [Number](#term-Number).'
  prefs: []
  type: TYPE_NORMAL
- en: '`isympy`'
  prefs: []
  type: TYPE_NORMAL
- en: '*`isympy`* is a command that ships with SymPy that starts an [interactive](#term-Interactive)
    session on the command line with all SymPy names imported and [printing](#term-Printing)
    enabled. It uses [IPython](https://ipython.org/) by default when it is installed.'
  prefs: []
  type: TYPE_NORMAL
- en: Kind
  prefs: []
  type: TYPE_NORMAL
- en: The *kind* of a SymPy object represents what sort of mathematical object it
    represents. The kind of an object can be accessed with the `kind` attribute. Example
    kinds are [`NumberKind`](../modules/core.html#sympy.core.kind.NumberKind "sympy.core.kind.NumberKind"),
    which represents complex numbers, [`MatrixKind`](../modules/matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind"), which represents matrices of some other kind,
    and [`BooleanKind`](../modules/core.html#sympy.core.kind.BooleanKind "sympy.core.kind.BooleanKind"),
    which represents boolean predicates. The kind of a SymPy object is distinct from
    its Python type, since sometimes a single Python type may represent many different
    kinds of objects. For example, `Matrix` could be a matrix of complex numbers or
    a matrix of objects from some other ring of values. See [the classification of
    SymPy objects](special_topics/classification.html#kind-classification) page for
    more details about kinds in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: lamda
  prefs: []
  type: TYPE_NORMAL
- en: “*Lamda*” is just an alternate spelling of the Greek letter “lambda”. It is
    used sometimes in SymPy because `lambda` is a reserved keyword in Python, so a
    symbol representing λ must be named something else.
  prefs: []
  type: TYPE_NORMAL
- en: '[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")* is a function that converts a SymPy expression
    into a Python function that can be evaluated numerically, typically making use
    of a [numeric](#term-Numeric) library such as NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix
  prefs: []
  type: TYPE_NORMAL
- en: '*Matrix* refers to the set of classes used by SymPy to represent matrices.
    SymPy has several internal classes to represent matrices, depending on whether
    the matrix is symbolic ([`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr")) or explicit, mutable or immutable, dense
    or sparse, and what type the underlying elements are, but these are often all
    just called “Matrix”.'
  prefs: []
  type: TYPE_NORMAL
- en: mpmath
  prefs: []
  type: TYPE_NORMAL
- en: '[*mpmath*](https://mpmath.org/) is a pure Python library for arbitrary precision
    numerics. It is a [hard dependency](../contributing/dependencies.html#dependencies-mpmath)
    of SymPy. mpmath is capable of computing [numerical](#term-Numeric) functions
    to any given number of digits. mpmath is used under the hood whenever SymPy evaluates
    an expression numerically, such as when using [evalf](#term-evalf).'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs: []
  type: TYPE_NORMAL
- en: A *numeric* representation or algorithm is one that operates directly on numeric
    inputs. It is in contrast with a *[symbolic](#term-Symbolic)* representation or
    algorithm, which can work with objects in an unevaluated form. Often a numerical
    algorithm is quite different from a symbolic one. For example, numerically solving
    an ODE typically means evaluating the ODE using an algorithm like [Runge–Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods)
    to find a set of numeric points given an initial condition, whereas symbolically
    solving an ODE (such as with SymPy’s [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")) means mathematically manipulating the ODE to produce
    a [symbolic](#term-Symbolic) [equation](#term-Equation) that represents the solution.
    A symbolic ODE solution may including symbolic constants which can represent any
    numerical value. Numeric algorithms are typically designed around issues caused
    by floating-point numbers such as loss of precision and numerical stability, whereas
    symbolic algorithms are not concerned with these things because they compute things
    exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Most scientific libraries other than SymPy, such as NumPy or SciPy, are strictly
    numerical, meaning the functions in those libraries can only operate on specific
    numeric inputs. They will not work with SymPy expressions, because their algorithms
    are not designed to work with symbolic inputs. SymPy focuses on symbolic functions,
    leaving purely numerical code to other tools like NumPy. However, SymPy does interface
    with numerical libraries via tools like [code generation](#term-Code-Generation)
    and [lambdify()](#term-lambdify).
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs: []
  type: TYPE_NORMAL
- en: '*Number* can refer to two things in SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: The class [`Number`](../modules/core.html#sympy.core.numbers.Number "sympy.core.numbers.Number"),
    which is the base class for explicit numbers ([`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational"), and [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float")). Symbolic numeric constants like [`pi`](../modules/core.html#sympy.core.numbers.Pi
    "sympy.core.numbers.Pi") are not instances of `Number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase “*number*”, as in the `is_number` property, refers to any [expression](#term-Expression)
    that can be [evalfed](#term-evalf) into an explicit `Number`. This includes symbolic
    constants like [`pi`](../modules/core.html#sympy.core.numbers.Pi "sympy.core.numbers.Pi").
    Note that `is_number` is not part of the [assumptions](#term-Assumptions) system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This distinction is important for the `is_Number` and `is_number` properties.
    `x.is_Number` will check if `x` is an instance of the class [`Number`](../modules/core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number").
  prefs: []
  type: TYPE_NORMAL
- en: '[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")*
    is the SymPy object representing positive infinity. It is spelled this way, as
    two lower case letter Os, because it resembles the symbol \(\infty\) and is easy
    to type. See also [zoo](#term-zoo).'
  prefs: []
  type: TYPE_NORMAL
- en: Polys
  prefs: []
  type: TYPE_NORMAL
- en: The *polys* refers to the [`sympy.polys`](../modules/polys/reference.html#module-sympy.polys
    "sympy.polys") submodule, which implements the basic data structures and algorithms
    for polynomial manipulation. The polys are a key part of SymPy (though not typically
    considered part of the [core](#term-Core)), because many basic symbolic manipulations
    can be represented as manipulations on polynomials. Many algorithms in SymPy make
    use of the polys under the hood. For example, [`factor()`](../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") is a wrapper around the polynomial factorization
    algorithms that are implemented in the polys. The classes in the polys are implemented
    using efficient data structures, and are not subclasses of [Basic](#term-Basic)
    like the other classes in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Printing
  prefs: []
  type: TYPE_NORMAL
- en: '*Printing* refers to the act of taking an [expression](#term-Expression) and
    converting it into a form that can be viewed on screen. Printing is also often
    used to refer to [code generation](#term-Code-Generation). SymPy has several printers
    which represent expressions using different formats. Some of the more common printers
    are the string printer (`str()`), the pretty printer ([`pprint()`](../modules/printing.html#sympy.printing.pretty.pretty.pretty_print
    "sympy.printing.pretty.pretty.pretty_print")) the LaTeX printer ([`latex()`](../modules/printing.html#sympy.printing.latex.latex
    "sympy.printing.latex.latex")), and code printers.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational
  prefs: []
  type: TYPE_NORMAL
- en: A *relational* is an [expression](#term-Expression) that is a [symbolic](#term-Symbolic)
    [equality](#term-Equation) (like \(a=b\)), or a symbolic inequality like “less
    than” (\(a<b\)). Equality (\(=\)) and non-equality (\(\neq\)) relationals are
    created with [`Eq`](../modules/core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    and [`Ne`](../modules/core.html#sympy.core.relational.Unequality "sympy.core.relational.Unequality"),
    respectively. For example, `Eq(x, 0)` represents \(x=0\). These should be used
    instead of `==` or `!=`, as these are used for [structural](#term-Structural-Equality)
    rather than symbolic equality. Inequality relationals can be created directly
    using `<`, `<=`, `>`, and `>=`, like `x < 0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")*
    object in SymPy has two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It holds all singleton classes as attributes. Some special classes in SymPy
    are singletonized, meaning that there is always exactly one instance of them.
    This is an optimization that allows saving memory. For instance, there is only
    ever one instance of `Integer(0)`, which is available as `S.Zero`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It serves as a shorthand for [sympify()](#term-sympify), that is `S(a)` is the
    same as `sympify(a)`. This is useful for converting integers to SymPy Integers
    in expressions to avoid dividing Python ints (see [the gotchas section of the
    tutorial](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplification
  prefs: []
  type: TYPE_NORMAL
- en: '*Simplification* (not to be confused with [sympify](#term-sympify)) refers
    to the process of taking an [expression](#term-Expression) and transforming it
    into another expression that is mathematically equivalent but which is somehow
    “simpler”. The adjective “simple” is actually not very well-defined. What counts
    as simpler depends on the specific use-case and personal aesthetics.'
  prefs: []
  type: TYPE_NORMAL
- en: The SymPy function [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") heuristically tries various simplification
    algorithms to try to find a “simpler” form of an expression. If you aren’t particular
    about what you want from “simplify”, it may be a good fit. But if you have an
    idea about what sort of simplification you want to apply, it is generally better
    to use one or more of targeted [simplification functions](../modules/simplify/simplify.html#simplify-docs)
    which apply very specific mathematical manipulations to an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Solve
  prefs: []
  type: TYPE_NORMAL
- en: Solvers
  prefs: []
  type: TYPE_NORMAL
- en: To *solve* an [equation](#term-Equation) or system of equations means to find
    a set of [expressions](#term-Expression) that make the equation(s) true when the
    given [symbol(s)](#term-Symbol) are [substituted](#term-Substitution) with them.
    For example, the solution to the equation \(x^2 = 1\) with respect to \(x\) would
    be the set \(\{-1, 1\}\). Different types of equations can be solved by SymPy
    using different [*solvers*](../guides/solving/index.html#solving-guide) functions.
    For instance, algebraic equations can be solved with [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"), differential equations can be solved with [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: SymPy generally uses the word “solve” and “solvers” to mean equation solving
    in this sense. It is not used in the sense of “solving a problem”. For instance,
    one would generally prefer to say “compute an integral” or “evaluate an integral”
    rather than “solve an integral” to refer to symbolic integration using the function
    [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate").
  prefs: []
  type: TYPE_NORMAL
- en: Structural Equality
  prefs: []
  type: TYPE_NORMAL
- en: Two SymPy objects are *structurally equal* if they are equal as [expressions](#term-Expression),
    that is, they have the same [expression trees](#term-Expression-Tree). Two structurally
    equal expressions are considered to be identical by SymPy, since all SymPy expressions
    are [immutable](#term-Immutable). Structural equality can be checked with the
    `==` operator, which always returns `True` or `False`. Symbolic [equality](#term-Equation)
    can be represented using [`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality").
  prefs: []
  type: TYPE_NORMAL
- en: Typically, two expressions are structurally equal if they are the same class
    and (recursively) have the same [args](#term-args). Two expressions may be mathematically
    identical but not structurally equal. For example, `(x + 1)**2` and `x**2 + 2*x
    + 1` are mathematically equal, but they are not structurally equal, because the
    first is a [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow")
    whose [args](#term-args) consist of an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") and an [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), and the second is an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") whose [args](#term-args) consist of a [`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow"), a [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    and an [`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer").
  prefs: []
  type: TYPE_NORMAL
- en: Two apparently different expressions may be structurally equal if they are [canonicalized](#term-Canonicalize)
    to the same thing by [automatic simplification](#term-Automatic-Simplification).
    For example, `x + y` and `y + x` are structurally equal because the [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") constructor automatically sorts its arguments, making them
    both the same.
  prefs: []
  type: TYPE_NORMAL
- en: Subexpression
  prefs: []
  type: TYPE_NORMAL
- en: A *subexpression* is an [expression](#term-Expression) that is contained within
    a larger expression. A subexpression appears somewhere in the [expression tree](#term-Expression-Tree).
    For `Add` and `Mul` terms, commutative and associative laws may be taken into
    account when determining what is a subexpression. For instance, `x + y` may sometimes
    be considered a subexpression of `x + y + z`, even though the expression tree
    for `Add(x, y)` is not a direct child of the expression tree for `Add(x, y, z)`.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution
  prefs: []
  type: TYPE_NORMAL
- en: '*Substitution* refers to the act of replacing a [symbol](#term-Symbol) or [subexpression](#term-Subexpression)
    inside of an [expression](#term-Expression) with another expression. There are
    different methods in SymPy for performing substitution, including [`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs"), [`replace`](../modules/core.html#sympy.core.basic.Basic.replace
    "sympy.core.basic.Basic.replace"), and [`xreplace`](../modules/core.html#sympy.core.basic.Basic.xreplace
    "sympy.core.basic.Basic.xreplace"). The methods may differ depending on whether
    they perform substitution using only strict [structural equality](#term-Structural-Equality)
    or by making use of mathematical knowledge when determining where a subexpression
    appears in an expression. Substitution is the standard way to treat an expression
    as a mathematical [function](#term-Function) and evaluate it at a point.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic
  prefs: []
  type: TYPE_NORMAL
- en: A *symbolic* representation of a mathematical object is a representation that
    is partially or completely unevaluated at runtime. It may include named [symbolic
    constants](#term-Symbol) in place of explicit numeric values. A symbolic representation
    is often contrasted with a [numeric](#term-Numeric) one. Symbolic representations
    are mathematically exact, to contrast with numeric representations which are typically
    rounded so they can fit within a floating-point value. Symbolic [expressions](#term-Expression)
    representing mathematical objects may be aware of mathematical properties of these
    objects and be able to [simplify](#term-Simplification) to equivalent symbolic
    expressions using those properties. The goal of SymPy is to represent and manipulate
    symbolic expressions representing various mathematical objects.
  prefs: []
  type: TYPE_NORMAL
- en: Some sources use the phrases “analytic solution” or “closed-form” to refer to
    the concept of “symbolic”, but this terminology is not used in SymPy. If used
    in SymPy, “analytic” would refer to the property of being [an analytic function](https://en.wikipedia.org/wiki/Analytic_function),
    and in SymPy [solve](#term-Solve) refers only to a certain type of symbolic operation.
    “Closed-form” in SymPy would typically refer to the mathematical sense of the
    term, whereas “symbolic” would generally refer to the implementation detail of
    how a mathematical concept is implemented, and be in contrast with a [numeric](#term-Numeric)
    implementation of the same mathematical concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")*
    is the class for symbol objects. A symbol represents a single mathematical variable
    in an expression. The [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") class is a subclass of [Expr](#term-Expr) and is [atomic](#term-Atom).
    A `Symbol` contains a name, which is any string, and [assumptions](#term-Assumptions).
    Symbols are typically defined with the `Symbol` constructor or the [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols") function. Two Symbols with the same name and assumptions
    are considered [equal](#term-Structural-Equality). Symbols are implicitly assumed
    to be independent or constant with respect to one another. Constants, variables,
    and parameters are all represented by Symbols. The distinction is generally made
    in the way the Symbols are used in a given SymPy function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")*
    (not to be confused with *[simplify()](#term-Simplification)*) is a function that
    converts non-SymPy objects into SymPy objects. The result of `sympify()` will
    be an instance of [Basic](#term-Basic). Objects that can be *sympified* include
    native Python numeric types such as `int` and `float`, strings that are parsable
    as SymPy [expressions](#term-Expression), and iterables containing *sympifiable*
    objects (see the documentation for [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") for more information).'
  prefs: []
  type: TYPE_NORMAL
- en: Since all SymPy [expressions](#term-Expression) must be instances of [Basic](#term-Basic),
    all SymPy functions and operations will implicitly call `sympify()` on their inputs.
    For example, `x + 1` implicitly calls `sympify(1)` to convert the `1` that is
    a Python `int` into a SymPy [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"). Functions that accept SymPy expressions should
    typically call `sympify()` on their arguments so that they work even when the
    input is not a SymPy type.
  prefs: []
  type: TYPE_NORMAL
- en: Three-valued logic
  prefs: []
  type: TYPE_NORMAL
- en: '*Three-valued logic* is a logic with three values, `True`, `False`, and `None`.
    It is also sometimes called *fuzzy logic*, although this term also has different
    meanings in the mathematical literature, so “three-valued logic” is preferred.
    `True` and `False` work the same as in the usual two-valued predicate logic. `None`
    is an additional term that represents “unknown”, “noncomputable”, or “could be
    either True or False” (philosophically these are distinct concepts, but logically
    they all function identically). The semantics of `None` are that it absorbs other
    terms in logical operations whenever the result would differ if it were replaced
    with `True` or `False`. For example, `None OR False` is `None`, but `None OR True`
    is `True` because the predicate is `True` whether the `None` “really” represents
    a value of `True` or `False`. One must be careful when using the usual Python
    logical operators like `and`, `or` and `not` on three-valued logic, since `None`
    is false. See [the guide for symbolic and fuzzy booleans](../guides/booleans.html#booleans-guide)
    for more details on how to code with three-valued logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Three-valued logic is used by the [assumptions](#term-Assumptions) system to
    represent assumptions that are not known. For instance, `x.is_positive` might
    be `None` if `x` could be positive or negative under its given assumptions. Note
    that the predicate logic defined by [Boolean](#term-Boolean) subclasses represents
    a standard two-valued logic, not three-valued logic.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined Function
  prefs: []
  type: TYPE_NORMAL
- en: An *undefined function* is a [Function](#term-Function-class) that has no mathematical
    properties defined on it. It always remains [unevaluated](#term-Unevaluated),
    like `f(x)`. An undefined function can be created by passing a string name of
    the function to `Function`, like `f = Function('f')`. Undefined functions are
    commonly used when working with [ODEs](../modules/solvers/ode.html#ode-docs).
    Undefined functions are also the easiest way to make [symbols](#term-Symbol) that
    mathematically depend on other symbols. For example, if `f = Function('f')` and
    `x = Symbol('x')`, then SymPy will know that `f(x)` depends on `x`, meaning, for
    instance, that the derivative `diff(f(x), x)` will not be evaluated to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Unevaluated
  prefs: []
  type: TYPE_NORMAL
- en: An expression is *unevaluated* if the [automatic simplification](#term-Automatic-Simplification)
    that typically occurs when the expression is created is disabled. This is typically
    done by setting `evaluate=False`, using `with evaluate(False)`, or using [`UnevaluatedExpr`](../modules/core.html#sympy.core.expr.UnevaluatedExpr
    "sympy.core.expr.UnevaluatedExpr"). While unevaluated expressions are supported,
    they can sometimes lead to surprising behavior because the expressions are not
    properly [canonicalized](#term-Canonicalize).
  prefs: []
  type: TYPE_NORMAL
- en: The term *unevaluated* is also sometimes used to denote the fact that an expression
    does not [evaluate](#term-Evaluate) to a specific value when its arguments are
    [symbolic](#term-Symbolic).
  prefs: []
  type: TYPE_NORMAL
- en: '[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")'
  prefs: []
  type: TYPE_NORMAL
- en: '*[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")*
    represents [complex infinity](https://mathworld.wolfram.com/ComplexInfinity.html),
    i.e., the north pole of the [Riemann sphere](https://en.wikipedia.org/wiki/Riemann_sphere).
    The reason it is spelled this way is that it is “z-oo”, where “z” is the symbol
    commonly used for complex variables, and [oo](#term-oo) is the symbol SymPy uses
    for real positive infinity.'
  prefs: []
  type: TYPE_NORMAL
