# 积分

> 译文：[`docs.sympy.org/latest/modules/integrals/integrals.html`](https://docs.sympy.org/latest/modules/integrals/integrals.html)

SymPy 中的 `integrals` 模块实现了计算表达式的定积分和不定积分的方法。

此模块中的主要方法是 `integrate()`

> +   `integrate(f, x)` 返回不定积分 \(\int f\,dx\)
> +   
> +   `integrate(f, (x, a, b))` 返回确定积分 \(\int_{a}^{b} f\,dx\)

## 示例

SymPy 可以积分各种函数。它可以积分多项式函数：

```py
>>> from sympy import *
>>> init_printing(use_unicode=False)
>>> x = Symbol('x')
>>> integrate(x**2 + x + 1, x)
 3    2
x    x
-- + -- + x
3    2 
```

有理函数：

```py
>>> integrate(x/(x**2+2*x+1), x)
 1
log(x + 1) + -----
 x + 1 
```

指数多项式函数。这些多项式与函数 `exp`、`cos` 和 `sin` 的乘积组合可以通过重复分部积分手工积分，这是一个极其繁琐的过程。幸运的是，SymPy 将处理这些积分。

```py
>>> integrate(x**2 * exp(x) * cos(x), x)
 2  x           2  x                         x           x
x *e *sin(x)   x *e *cos(x)      x          e *sin(x)   e *cos(x)
------------ + ------------ - x*e *sin(x) + --------- - ---------
 2              2                           2           2 
```

即使有一些非初等积分（特别是一些涉及误差函数的积分）也可以计算：

```py
>>> integrate(exp(-x**2)*erf(x), x)
 ____    2
\/ pi *erf (x)
--------------
 4 
```

## 积分变换

SymPy 对确定积分和积分变换有特殊支持。

```py
sympy.integrals.transforms.mellin_transform(f, x, s, **hints)
```

计算 \(f(x)\) 的 Mellin 变换 \(F(s)\)，

\[F(s) = \int_0^\infty x^{s-1} f(x) \mathrm{d}x.\]

对于所有“合理”的函数，这在一个条带内绝对收敛。

\(a < \operatorname{Re}(s) < b\).

解释

Mellin 变换通过变量变换与 Fourier 变换相关联，并且与（双边）拉普拉斯变换也相关。

此函数返回 `(F, (a, b), cond)`，其中 `F` 是 `f` 的 Mellin 变换，`(a, b)` 是基本条（如上所述），而 `cond` 是辅助收敛条件。

如果积分无法以闭合形式计算，则此函数返回一个未评估的 `MellinTransform` 对象。

有关可能提示的描述，请参阅 `sympy.integrals.transforms.IntegralTransform.doit()` 的文档字符串。如果 `noconds=False`，则仅返回 \(F\)（即不返回 `cond`，也不返回条带 `(a, b)`）。

示例

```py
>>> from sympy import mellin_transform, exp
>>> from sympy.abc import x, s
>>> mellin_transform(exp(-x), x, s)
(gamma(s), (0, oo), True) 
```

另请参阅

`inverse_mellin_transform`, `laplace_transform`, `fourier_transform`, `hankel_transform`, `inverse_hankel_transform`

```py
class sympy.integrals.transforms.MellinTransform(*args)
```

表示未评估的 Mellin 变换的类。

如何使用这个类，请参阅`IntegralTransform`文档字符串。

如何计算 Mellin 变换，请参阅`mellin_transform()`文档字符串。

```py
sympy.integrals.transforms.inverse_mellin_transform(F, s, x, strip, **hints)
```

计算给定由`strip=(a, b)`确定的基本带上\(F(s)\)的逆 Mellin 变换。

解释

这可以定义为

\[f(x) = \frac{1}{2\pi i} \int_{c - i\infty}^{c + i\infty} x^{-s} F(s) \mathrm{d}s,\]

对于任意在基本带中的\(c\)。在\(F\)和/或\(f\)的某些正则条件下，这可以从其 Mellin 变换\(F\)（及反之）恢复\(f\)，对于正实数\(x\)。

\(a\)或\(b\)中的一个可以传递为`None`；适当的\(c\)将被推断。

如果无法闭合计算积分，则此函数返回一个未评估的`InverseMellinTransform`对象。

请注意，此函数将假定 x 为正实数，不考虑 SymPy 的假设！

有关可能提示的描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`文档字符串。

示例

```py
>>> from sympy import inverse_mellin_transform, oo, gamma
>>> from sympy.abc import x, s
>>> inverse_mellin_transform(gamma(s), s, x, (0, oo))
exp(-x) 
```

基本带很重要：

```py
>>> f = 1/(s**2 - 1)
>>> inverse_mellin_transform(f, s, x, (-oo, -1))
x*(1 - 1/x**2)*Heaviside(x - 1)/2
>>> inverse_mellin_transform(f, s, x, (-1, 1))
-x*Heaviside(1 - x)/2 - Heaviside(x - 1)/(2*x)
>>> inverse_mellin_transform(f, s, x, (1, oo))
(1/2 - x**2/2)*Heaviside(1 - x)/x 
```

参见

`mellin_transform`, `hankel_transform`, `inverse_hankel_transform`

```py
class sympy.integrals.transforms.InverseMellinTransform(*args)
```

表示未评估逆 Mellin 变换的类。

如何使用这个类，请参阅`IntegralTransform`文档字符串。

如何计算逆 Mellin 变换，请参阅`inverse_mellin_transform()`文档字符串。

```py
sympy.integrals.transforms.laplace_transform(f, t, s, legacy_matrix=True, **hints)
```

计算拉普拉斯变换 \(F(s)\) 的 \(f(t)\)，

\[F(s) = \int_{0^{-}}^\infty e^{-st} f(t) \mathrm{d}t.\]

解释

对于所有合理的函数，这在半平面绝对收敛

\[a < \operatorname{Re}(s)\]

此函数返回`(F, a, cond)`，其中`F`是`f`的 Laplace 变换，\(a\)是收敛的半平面，\(cond\)是辅助收敛条件。

实现是基于规则的，如果您对应用了哪些规则感兴趣，以及是否尝试了集成，可以通过设置`sympy.SYMPY_DEBUG=True`来打开调试信息。调试信息中的规则编号（及代码）参考 Bateman 的积分变换表[1]。

下限为 \( 0^- \)，意味着应该从下侧接近此下限。仅当涉及分布时才需要这样做。目前仅在 \( f(t) \) 包含 `DiracDelta` 时才执行此操作，此时 Laplace 变换将隐式计算为

\[F(s) = \lim_{\tau\to 0^{-}} \int_{\tau}^\infty e^{-st} f(t) \mathrm{d}t\]

通过应用规则。

如果 Laplace 变换无法以封闭形式完全计算，则此函数将返回包含未评估的 `LaplaceTransform` 对象的表达式。

要获取可能的提示描述，请参阅 `sympy.integrals.transforms.IntegralTransform.doit()` 的文档字符串。如果 `noconds=True`，只返回 \( F \)（即不包括 `cond`，也不包括平面 `a`）。

自版本 1.9 起弃用：对于 `laplace_transform` 使用 `noconds=False`（默认），返回一个元素为元组的矩阵的旧行为。SymPy 未来版本中，`laplace_transform` 在矩阵的行为将发生变化，以返回转换后的矩阵及其整体收敛条件的元组。使用 `legacy_matrix=False` 可启用新行为。

示例

```py
>>> from sympy import DiracDelta, exp, laplace_transform
>>> from sympy.abc import t, s, a
>>> laplace_transform(t**4, t, s)
(24/s**5, 0, True)
>>> laplace_transform(t**a, t, s)
(gamma(a + 1)/(s*s**a), 0, re(a) > -1)
>>> laplace_transform(DiracDelta(t)-a*exp(-a*t), t, s, simplify=True)
(s/(a + s), -re(a), True) 
```

还有一些辅助函数可通过 Laplace 变换轻松解决微分方程。例如，要解决

\[m x''(t) + d x'(t) + k x(t) = 0\]

初始值为 \( 0 \)，初始导数为 \( v \)：

```py
>>> from sympy import Function, laplace_correspondence, diff, solve
>>> from sympy import laplace_initial_conds, inverse_laplace_transform
>>> from sympy.abc import d, k, m, v
>>> x = Function('x')
>>> X = Function('X')
>>> f = m*diff(x(t), t, 2) + d*diff(x(t), t) + k*x(t)
>>> F = laplace_transform(f, t, s, noconds=True)
>>> F = laplace_correspondence(F, {x: X})
>>> F = laplace_initial_conds(F, t, {x: [0, v]})
>>> F
d*s*X(s) + k*X(s) + m*(s**2*X(s) - v)
>>> Xs = solve(F, X(s))[0]
>>> Xs
m*v/(d*s + k + m*s**2)
>>> inverse_laplace_transform(Xs, s, t)
2*v*exp(-d*t/(2*m))*sin(t*sqrt((-d**2 + 4*k*m)/m**2)/2)*Heaviside(t)/sqrt((-d**2 + 4*k*m)/m**2) 
```

也见

`inverse_laplace_transform`，`mellin_transform`，`fourier_transform`，`hankel_transform`，`inverse_hankel_transform`

参考资料

[R567]

埃尔德艾伊，A.（编），积分变换表，第 1 卷，贝特曼手稿项目，麦克格劳-希尔（1954），可用：[`resolver.caltech.edu/CaltechAUTHORS:20140123-101456353`](https://resolver.caltech.edu/CaltechAUTHORS:20140123-101456353)

```py
sympy.integrals.transforms.laplace_correspondence(f, fdict, /)
```

此辅助函数接受一个函数 \( f \)，该函数是 `laplace_transform` 或 `inverse_laplace_transform` 的结果。它将所有未评估的 `LaplaceTransform(y(t), t, s)` 替换为任何 \( s \) 的 \( Y(s) \)，并将所有 `InverseLaplaceTransform(Y(s), s, t)` 替换为任何 \( t \) 的 \( y(t) \)，如果 `fdict` 包含对应关系 `{y: Y}`。

参数：

**f**：SymPy 表达式

> 包含未评估的 `LaplaceTransform` 或 `LaplaceTransform` 对象的表达式。

**fdict**：字典

> 包含一个或多个函数对应关系的字典，例如`{x: X, y: Y}`，意味着`X`和`Y`分别是`x`和`y`的拉普拉斯变换。

示例

```py
>>> from sympy import laplace_transform, diff, Function
>>> from sympy import laplace_correspondence, inverse_laplace_transform
>>> from sympy.abc import t, s
>>> y = Function("y")
>>> Y = Function("Y")
>>> z = Function("z")
>>> Z = Function("Z")
>>> f = laplace_transform(diff(y(t), t, 1) + z(t), t, s, noconds=True)
>>> laplace_correspondence(f, {y: Y, z: Z})
s*Y(s) + Z(s) - y(0)
>>> f = inverse_laplace_transform(Y(s), s, t)
>>> laplace_correspondence(f, {y: Y})
y(t) 
```

```py
sympy.integrals.transforms.laplace_initial_conds(f, t, fdict, /)
```

此辅助函数接受一个`laplace_transform`结果的函数\(f\)。它接受一个形如`{y: [1, 4, 2]}`的 fdict，其中列表中的值是函数\(y(t)\)的初始值、初始斜率、初始二阶导数等，用以替换所有未评估的初始条件。

参数：

**f**：sympy 表达式

> 包含未评估函数的初始条件的表达式。

**t**：sympy 表达式

> 初始条件要应用的变量。

**fdict**：字典

> 包含每个函数初始条件列表的字典，例如`{y: [0, 1, 2], x: [3, 4, 5]}`。导数顺序升序，因此\(0\)、\(1\)、\(2\)分别是\(y(0)\)、\(y'(0)\)和\(y''(0)\)。

示例

```py
>>> from sympy import laplace_transform, diff, Function
>>> from sympy import laplace_correspondence, laplace_initial_conds
>>> from sympy.abc import t, s
>>> y = Function("y")
>>> Y = Function("Y")
>>> f = laplace_transform(diff(y(t), t, 3), t, s, noconds=True)
>>> g = laplace_correspondence(f, {y: Y})
>>> laplace_initial_conds(g, t, {y: [2, 4, 8, 16, 32]})
s**3*Y(s) - 2*s**2 - 4*s - 8 
```

```py
class sympy.integrals.transforms.LaplaceTransform(*args)
```

表示未评估拉普拉斯变换的类。

有关此类用法，请参阅`IntegralTransform`的文档字符串。

如何计算拉普拉斯变换，请参阅`laplace_transform()`的文档字符串。

如果使用`.doit()`调用它，它将作为表达式返回拉普拉斯变换。如果使用`.doit(noconds=False)`调用它，则返回包含相同表达式、收敛平面和条件的元组。

```py
doit(**hints)
```

尝试以闭合形式评估变换。

解释

标准提示如下：- `noconds`：如果为 True，则不返回收敛条件。默认设置为\(True\)。- `simplify`：如果为 True，则简化最终结果。默认设置为\(False\)。

```py
sympy.integrals.transforms.inverse_laplace_transform(F, s, t, plane=None, **hints)
```

计算\(F(s)\)的逆拉普拉斯变换，定义为

\[f(t) = \frac{1}{2\pi i} \int_{c-i\infty}^{c+i\infty} e^{st} F(s) \mathrm{d}s,\]

对于\(c\)足够大，以至于\(F(s)\)在半平面\(\operatorname{Re}(s) > c-\epsilon\)内无奇点。

解释

可以通过参数`plane`指定平面，但如果作为 None 传递，则会推断。

在某些正则条件下，这从其拉普拉斯变换\(F(s)\)中恢复\(f(t)\)，对于非负的\(t\)，反之亦然。

如果无法计算闭合形式的积分，则此函数返回一个未评估的`InverseLaplaceTransform`对象。

请注意，此函数始终假定\(t\)为实数，而不考虑\(t\)的 SymPy 假设。

有关可能提示的描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。

示例

```py
>>> from sympy import inverse_laplace_transform, exp, Symbol
>>> from sympy.abc import s, t
>>> a = Symbol('a', positive=True)
>>> inverse_laplace_transform(exp(-a*s)/s, s, t)
Heaviside(-a + t) 
```

另请参阅

`laplace_transform`, `hankel_transform`, `inverse_hankel_transform`

```py
class sympy.integrals.transforms.InverseLaplaceTransform(*args)
```

表示未评估的逆拉普拉斯变换的类。

要使用此类，请参阅`IntegralTransform`的文档字符串。

如何计算逆拉普拉斯变换，请参阅`inverse_laplace_transform()`的文档字符串。

```py
doit(**hints)
```

尝试以闭合形式评估变换。

解释

标准提示如下：- `noconds`：如果为 True，则不返回收敛条件。默认设置为\(True\)。- `simplify`：如果为 True，则简化最终结果。默认设置为\(False\)。

```py
sympy.integrals.transforms.fourier_transform(f, x, k, **hints)
```

计算`f`的单位、普通频率傅里叶变换，定义为

\[F(k) = \int_{-\infty}^\infty f(x) e^{-2\pi i x k} \mathrm{d} x.\]

解释

如果无法以闭合形式计算变换，则此函数返回一个未评估的`FourierTransform`对象。

对于其他傅里叶变换约定，请参阅函数`sympy.integrals.transforms._fourier_transform()`。

要了解可能的提示说明，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。请注意，默认情况下，对于此变换，`noconds=True`。

示例

```py
>>> from sympy import fourier_transform, exp
>>> from sympy.abc import x, k
>>> fourier_transform(exp(-x**2), x, k)
sqrt(pi)*exp(-pi**2*k**2)
>>> fourier_transform(exp(-x**2), x, k, noconds=False)
(sqrt(pi)*exp(-pi**2*k**2), True) 
```

另请参阅

`inverse_fourier_transform`, `sine_transform`, `inverse_sine_transform`, `cosine_transform`, `inverse_cosine_transform`, `hankel_transform`, `inverse_hankel_transform`, `mellin_transform`, `laplace_transform`

```py
sympy.integrals.transforms._fourier_transform(f, x, k, a, b, name, simplify=True)
```

计算一般的傅里叶类型变换

\[F(k) = a \int_{-\infty}^{\infty} e^{bixk} f(x)\, dx.\]

对于适当选择的*a*和*b*，这将简化为标准的傅里叶和逆傅里叶变换。

```py
class sympy.integrals.transforms.FourierTransform(*args)
```

表示未评估的傅里叶变换的类。

对于此类的使用，请参见`IntegralTransform`的文档字符串。

如何计算傅里叶变换，请参见`fourier_transform()`文档字符串。

```py
sympy.integrals.transforms.inverse_fourier_transform(F, k, x, **hints)
```

计算单位、普通频率的逆傅里叶变换，定义为

\[f(x) = \int_{-\infty}^\infty F(k) e^{2\pi i x k} \mathrm{d} k.\]

解释

如果不能以封闭形式计算变换，则此函数返回一个未评估的`InverseFourierTransform`对象。

对于其他傅里叶变换约定，请参见函数`sympy.integrals.transforms._fourier_transform()`。

获取可能提示的说明，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。请注意，默认情况下，对于此变换，`noconds=True`。

示例

```py
>>> from sympy import inverse_fourier_transform, exp, sqrt, pi
>>> from sympy.abc import x, k
>>> inverse_fourier_transform(sqrt(pi)*exp(-(pi*k)**2), k, x)
exp(-x**2)
>>> inverse_fourier_transform(sqrt(pi)*exp(-(pi*k)**2), k, x, noconds=False)
(exp(-x**2), True) 
```

另请参阅

`fourier_transform`，`sine_transform`，`inverse_sine_transform`，`cosine_transform`，`inverse_cosine_transform`，`hankel_transform`，`inverse_hankel_transform`，`mellin_transform`，`laplace_transform`

```py
class sympy.integrals.transforms.InverseFourierTransform(*args)
```

表示未求值逆傅里叶变换的类。

关于此类使用，请参阅`IntegralTransform`文档字符串。

对于如何计算逆傅里叶变换，请参阅`inverse_fourier_transform()`文档字符串。

```py
sympy.integrals.transforms.sine_transform(f, x, k, **hints)
```

计算定义为\(f\)的单位、普通频率正弦变换，如下所示：

\[F(k) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty f(x) \sin(2\pi x k) \mathrm{d} x.\]

解释

如果不能以封闭形式计算变换，则此函数返回一个未求值的`SineTransform`对象。

关于可能的提示描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`文档字符串。注意，默认情况下对于此变换，`noconds=True`。

示例

```py
>>> from sympy import sine_transform, exp
>>> from sympy.abc import x, k, a
>>> sine_transform(x*exp(-a*x**2), x, k)
sqrt(2)*k*exp(-k**2/(4*a))/(4*a**(3/2))
>>> sine_transform(x**(-a), x, k)
2**(1/2 - a)*k**(a - 1)*gamma(1 - a/2)/gamma(a/2 + 1/2) 
```

另请参见

`fourier_transform`, `inverse_fourier_transform`, `inverse_sine_transform`, `cosine_transform`, `inverse_cosine_transform`, `hankel_transform`, `inverse_hankel_transform`, `mellin_transform`, `laplace_transform`

```py
class sympy.integrals.transforms.SineTransform(*args)
```

表示未计算正弦变换的类。

对于此类的使用方法，请参阅`IntegralTransform`的文档字符串。

如何计算正弦变换，请参阅`sine_transform()`文档字符串。

```py
sympy.integrals.transforms.inverse_sine_transform(F, k, x, **hints)
```

计算\(F\)的单位、普通频率逆正弦变换，定义为

\[f(x) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty F(k) \sin(2\pi x k) \mathrm{d} k.\]

解释

如果无法以封闭形式计算变换，则此函数返回一个未计算的`InverseSineTransform`对象。

有关可能的提示说明，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。请注意，对于此变换，默认情况下`noconds=True`。

示例

```py
>>> from sympy import inverse_sine_transform, exp, sqrt, gamma
>>> from sympy.abc import x, k, a
>>> inverse_sine_transform(2**((1-2*a)/2)*k**(a - 1)*
...     gamma(-a/2 + 1)/gamma((a+1)/2), k, x)
x**(-a)
>>> inverse_sine_transform(sqrt(2)*k*exp(-k**2/(4*a))/(4*sqrt(a)**3), k, x)
x*exp(-a*x**2) 
```

另请参阅

`fourier_transform`, `inverse_fourier_transform`, `sine_transform`, `cosine_transform`, `inverse_cosine_transform`, `hankel_transform`, `inverse_hankel_transform`, `mellin_transform`, `laplace_transform`

```py
class sympy.integrals.transforms.InverseSineTransform(*args)
```

表示未评估的反正弦变换的类。

要使用此类，请参阅`IntegralTransform`的文档字符串。

要了解如何计算反正弦变换，请参阅`inverse_sine_transform()`的文档字符串。

```py
sympy.integrals.transforms.cosine_transform(f, x, k, **hints)
```

计算\(f\)的单位，普通频率余弦变换定义为

\[F(k) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty f(x) \cos(2\pi x k) \mathrm{d} x.\]

解释

如果无法以封闭形式计算变换，则此函数返回未评估的`CosineTransform`对象。

获取可能的提示描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。注意，默认情况下，此变换使用`noconds=True`。

示例

```py
>>> from sympy import cosine_transform, exp, sqrt, cos
>>> from sympy.abc import x, k, a
>>> cosine_transform(exp(-a*x), x, k)
sqrt(2)*a/(sqrt(pi)*(a**2 + k**2))
>>> cosine_transform(exp(-a*sqrt(x))*cos(a*sqrt(x)), x, k)
a*exp(-a**2/(2*k))/(2*k**(3/2)) 
```

另请参阅

`fourier_transform`, `inverse_fourier_transform`, `sine_transform`, `inverse_sine_transform`, `inverse_cosine_transform`, `hankel_transform`, `inverse_hankel_transform`, `mellin_transform`, `laplace_transform`

```py
class sympy.integrals.transforms.CosineTransform(*args)
```

表示未求值余弦变换的类。

若要使用此类，请参阅`IntegralTransform`的文档字符串。

如需计算余弦变换，请参阅`cosine_transform()`文档字符串。

```py
sympy.integrals.transforms.inverse_cosine_transform(F, k, x, **hints)
```

计算\(F\)的单位、普通频率的反余弦变换，定义为

\[f(x) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty F(k) \cos(2\pi x k) \mathrm{d} k.\]

解释

如果无法计算该变换的闭合形式，则此函数返回一个未求值的`InverseCosineTransform`对象。

如需可能的提示说明，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。请注意，默认情况下，对于此变换，`noconds=True`。

示例

```py
>>> from sympy import inverse_cosine_transform, sqrt, pi
>>> from sympy.abc import x, k, a
>>> inverse_cosine_transform(sqrt(2)*a/(sqrt(pi)*(a**2 + k**2)), k, x)
exp(-a*x)
>>> inverse_cosine_transform(1/sqrt(k), k, x)
1/sqrt(x) 
```

另请参阅

`fourier_transform`, `inverse_fourier_transform`, `sine_transform`, `inverse_sine_transform`, `cosine_transform`, `hankel_transform`, `inverse_hankel_transform`, `mellin_transform`, `laplace_transform`

```py
class sympy.integrals.transforms.InverseCosineTransform(*args)
```

表示未评估的反余弦变换的类。

有关此类的用法，请参阅`IntegralTransform`文档字符串。

有关如何计算反余弦变换，请参阅`inverse_cosine_transform()`的文档字符串。

```py
sympy.integrals.transforms.hankel_transform(f, r, k, nu, **hints)
```

计算定义为\[f\]的 Hankel 变换

\[F_\nu(k) = \int_{0}^\infty f(r) J_\nu(k r) r \mathrm{d} r.\]

解释

如果无法以闭合形式计算变换，则此函数返回一个未评估的`HankelTransform`对象。

有关可能提示的描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`的文档字符串。请注意，默认情况下对于此变换，`noconds=True`。

示例

```py
>>> from sympy import hankel_transform, inverse_hankel_transform
>>> from sympy import exp
>>> from sympy.abc import r, k, m, nu, a 
```

```py
>>> ht = hankel_transform(1/r**m, r, k, nu)
>>> ht
2*k**(m - 2)*gamma(-m/2 + nu/2 + 1)/(2**m*gamma(m/2 + nu/2)) 
```

```py
>>> inverse_hankel_transform(ht, k, r, nu)
r**(-m) 
```

```py
>>> ht = hankel_transform(exp(-a*r), r, k, 0)
>>> ht
a/(k**3*(a**2/k**2 + 1)**(3/2)) 
```

```py
>>> inverse_hankel_transform(ht, k, r, 0)
exp(-a*r) 
```

另见

`fourier_transform`，`inverse_fourier_transform`，`sine_transform`，`inverse_sine_transform`，`cosine_transform`，`inverse_cosine_transform`，`inverse_hankel_transform`，`mellin_transform`，`laplace_transform`

```py
class sympy.integrals.transforms.HankelTransform(*args)
```

表示未计算的汉克尔变换的类。

关于该类的使用，请参阅`IntegralTransform`文档字符串。

如何计算汉克尔变换，请参阅`hankel_transform()`文档字符串。

```py
sympy.integrals.transforms.inverse_hankel_transform(F, k, r, nu, **hints)
```

计算定义为\(F\)的逆汉克尔变换，如下所示：

\[f(r) = \int_{0}^\infty F_\nu(k) J_\nu(k r) k \mathrm{d} k.\]

说明

如果无法以封闭形式计算变换，则此函数返回一个未计算的`InverseHankelTransform`对象。

有关可能提示的描述，请参阅`sympy.integrals.transforms.IntegralTransform.doit()`文档字符串。请注意，默认情况下，对于此变换，`noconds=True`。

示例

```py
>>> from sympy import hankel_transform, inverse_hankel_transform
>>> from sympy import exp
>>> from sympy.abc import r, k, m, nu, a 
```

```py
>>> ht = hankel_transform(1/r**m, r, k, nu)
>>> ht
2*k**(m - 2)*gamma(-m/2 + nu/2 + 1)/(2**m*gamma(m/2 + nu/2)) 
```

```py
>>> inverse_hankel_transform(ht, k, r, nu)
r**(-m) 
```

```py
>>> ht = hankel_transform(exp(-a*r), r, k, 0)
>>> ht
a/(k**3*(a**2/k**2 + 1)**(3/2)) 
```

```py
>>> inverse_hankel_transform(ht, k, r, 0)
exp(-a*r) 
```

另请参阅

`傅里叶变换`，`逆傅里叶变换`，`正弦变换`，`逆正弦变换`，`余弦变换`，`逆余弦变换`，`汉克尔变换`，`梅林变换`，`拉普拉斯变换`

```py
class sympy.integrals.transforms.InverseHankelTransform(*args)
```

表示未计算逆汉克尔变换的类。

如何使用此类，请参见 `IntegralTransform` 的文档字符串。

如何计算逆汉克尔变换，请参见 `inverse_hankel_transform()` 的文档字符串。

```py
class sympy.integrals.transforms.IntegralTransform(*args)
```

积分变换的基类。

解释

此类表示未计算的变换。

要实现具体的变换，从这个类派生并实现 `_compute_transform(f, x, s, **hints)` 和 `_as_integral(f, x, s)` 函数。如果无法计算变换，则抛出 `IntegralTransformError`。

还要设置 `cls._name`。例如，

```py
>>> from sympy import LaplaceTransform
>>> LaplaceTransform._name
'Laplace' 
```

如果您的函数返回的不仅仅是一个数，可能还有一个收敛条件，则实现 `self._collapse_extra`。

```py
doit(**hints)
```

尝试以封闭形式评估变换。

解释

此通用函数处理线性性，但除此之外几乎所有事情都留给 `_compute_transform`。

标准提示如下：

+   `simplify`: 是否简化结果

+   `noconds`: 如果为 True，则不返回收敛条件

+   `needeval`: 如果为 True，则抛出 IntegralTransformError 而不是

    返回 IntegralTransform 对象

这些提示的默认值取决于具体的变换，默认情况下是 `(simplify, noconds, needeval) = (True, False, False)`。

```py
property function
```

要进行变换的函数。

```py
property function_variable
```

要进行变换的函数的依赖变量。

```py
property transform_variable
```

变换的独立变量。

```py
exception sympy.integrals.transforms.IntegralTransformError(transform, function, msg)
```

与计算变换相关的异常。

解释

此类主要用于内部使用；如果无法计算积分，则通常返回表示未计算的变换对象。

提示 `needeval=True` 可用于禁用返回变换对象，并在无法计算积分时引发异常。

## 内部

SymPy 使用多种算法来计算积分。按顺序尝试这些算法，直到一个产生答案。大多数算法可以通过各种标志手动启用或禁用，使用 `integrate()` 或 `doit()`。

SymPy 首先应用几个启发式算法，因为它们是最快的：

1.  如果函数是一个有理函数，有一个完整的算法用于集成有理函数，称为 Lazard-Rioboo-Trager 和 Horowitz-Ostrogradsky 算法。它们在 `ratint()` 中实现。

    ```py
    sympy.integrals.rationaltools.ratint(f, x, **flags)
    ```

    执行有理函数的不定积分。

    解释

    给定域 \(K\) 和有理函数 \(f = p/q\)，其中 \(p\) 和 \(q\) 是 \(K[x]\) 中的多项式，返回一个函数 \(g\)，使得 \(f = g'\)。

    例子

    ```py
    >>> from sympy.integrals.rationaltools import ratint
    >>> from sympy.abc import x 
    ```

    ```py
    >>> ratint(36/(x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2), x)
    (12*x + 6)/(x**2 - 1) + 4*log(x - 2) - 4*log(x + 1) 
    ```

    另见

    `sympy.integrals.integrals.Integral.doit`，`sympy.integrals.rationaltools.ratint_logpart`，`sympy.integrals.rationaltools.ratint_ratpart`

    参考文献

    [R568]

    M. Bronstein, Symbolic Integration I: Transcendental Functions, Second Edition, Springer-Verlag, 2005, pp. 35-70

    ```py
    sympy.integrals.rationaltools.ratint_ratpart(f, g, x)
    ```

    Horowitz-Ostrogradsky 算法。

    解释

    给定域 K 和 K[x] 中的多项式 f 和 g，使得 f 和 g 互素且 deg(f) < deg(g)，返回 K(x) 中的分数 A 和 B，使得 f/g = A’ + B，且 B 具有无平方分母。

    例子

    ```py
    >>> from sympy.integrals.rationaltools import ratint_ratpart
    >>> from sympy.abc import x, y
    >>> from sympy import Poly
    >>> ratint_ratpart(Poly(1, x, domain='ZZ'),
    ... Poly(x + 1, x, domain='ZZ'), x)
    (0, 1/(x + 1))
    >>> ratint_ratpart(Poly(1, x, domain='EX'),
    ... Poly(x**2 + y**2, x, domain='EX'), x)
    (0, 1/(x**2 + y**2))
    >>> ratint_ratpart(Poly(36, x, domain='ZZ'),
    ... Poly(x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2, x, domain='ZZ'), x)
    ((12*x + 6)/(x**2 - 1), 12/(x**2 - x - 2)) 
    ```

    另见

    `ratint`，`ratint_logpart`

    ```py
    sympy.integrals.rationaltools.ratint_logpart(f, g, x, t=None)
    ```

    Lazard-Rioboo-Trager 算法。

    解释

    给定域 K 和 K[x] 中的多项式 f 和 g，使得 f 和 g 互素，deg(f) < deg(g) 且 g 是无平方的，返回多项式的元组 (s_i, q_i)，其中 i = 1..n，使得 s_i 在 K[t, x] 中，q_i 在 K[t] 中，并且：

    ```py
     ___    ___
    d  f   d  \  `   \  `
    -- - = --  )      )   a log(s_i(a, x))
    dx g   dx /__,   /__,
             i=1..n a | q_i(a) = 0 
    ```

    例子

    ```py
    >>> from sympy.integrals.rationaltools import ratint_logpart
    >>> from sympy.abc import x
    >>> from sympy import Poly
    >>> ratint_logpart(Poly(1, x, domain='ZZ'),
    ... Poly(x**2 + x + 1, x, domain='ZZ'), x)
    [(Poly(x + 3*_t/2 + 1/2, x, domain='QQ[_t]'),
    ...Poly(3*_t**2 + 1, _t, domain='ZZ'))]
    >>> ratint_logpart(Poly(12, x, domain='ZZ'),
    ... Poly(x**2 - x - 2, x, domain='ZZ'), x)
    [(Poly(x - 3*_t/8 - 1/2, x, domain='QQ[_t]'),
    ...Poly(-_t**2 + 16, _t, domain='ZZ'))] 
    ```

    另见

    `ratint`，`ratint_ratpart`

1.  `trigintegrate()` 使用模式匹配解决三角函数的积分

    ```py
    sympy.integrals.trigonometry.trigintegrate(f, x, conds='piecewise')
    ```

    对于 x，集成 f = Mul(trig)。

    例子

    ```py
    >>> from sympy import sin, cos, tan, sec
    >>> from sympy.integrals.trigonometry import trigintegrate
    >>> from sympy.abc import x 
    ```

    ```py
    >>> trigintegrate(sin(x)*cos(x), x)
    sin(x)**2/2 
    ```

    ```py
    >>> trigintegrate(sin(x)**2, x)
    x/2 - sin(x)*cos(x)/2 
    ```

    ```py
    >>> trigintegrate(tan(x)*sec(x), x)
    1/cos(x) 
    ```

    ```py
    >>> trigintegrate(sin(x)*tan(x), x)
    -log(sin(x) - 1)/2 + log(sin(x) + 1)/2 - sin(x) 
    ```

    另见

    `sympy.integrals.integrals.Integral.doit`，`sympy.integrals.integrals.Integral`

    参考文献

    [R569]

    [`en.wikibooks.org/wiki/Calculus/Integration_techniques`](https://en.wikibooks.org/wiki/Calculus/Integration_techniques)

1.  `deltaintegrate()` 解决带有`DiracDelta`对象的积分问题。

    ```py
    sympy.integrals.deltafunctions.deltaintegrate(f, x)
    ```

    解释

    积分的思路如下：

    +   如果我们正在处理 DiracDelta 表达式，即 DiracDelta(g(x))，我们尝试简化它。

        如果我们能简化它，那么我们就积分得到的表达式。我们已经知道我们可以积分一个简化的表达式，因为只涉及简单的 DiracDelta 表达式。

        如果我们无法简化它，有两种情况：

        1.  表达式是一个简单的表达式：我们返回积分结果，注意我们是否在处理导数或适当的 DiracDelta。

        1.  表达式不简单（例如 DiracDelta(cos(x))）：我们根本无法处理。

    +   如果节点是一个包含 DiracDelta 项的乘法节点：

        首先我们将其展开。

        如果展开成功，我们就尝试积分这个展开式。

        如果不行，我们尝试提取一个简单的 DiracDelta 项，然后有两种情况：

        1.  我们有一个简单的 DiracDelta 项，所以我们返回积分结果。

        1.  我们没有一个简单的项，但是我们有一个包含简化的 DiracDelta 项的表达式，所以我们积分这个表达式。

    示例

    ```py
    >>> from sympy.abc import x, y, z
    >>> from sympy.integrals.deltafunctions import deltaintegrate
    >>> from sympy import sin, cos, DiracDelta
    >>> deltaintegrate(x*sin(x)*cos(x)*DiracDelta(x - 1), x)
    sin(1)*cos(1)*Heaviside(x - 1)
    >>> deltaintegrate(y**2*DiracDelta(x - z)*DiracDelta(y - z), y)
    z**2*DiracDelta(x - z)*Heaviside(y - z) 
    ```

    参见

    `sympy.functions.special.delta_functions.DiracDelta`，`sympy.integrals.integrals.Integral`

1.  `singularityintegrate()` 适用于函数包含`SingularityFunction`实例时。

    ```py
    sympy.integrals.singularityfunctions.singularityintegrate(f, x)
    ```

    此函数处理 Singularity 函数的不定积分。每当 SingularityFunction 的实例作为参数传递时，`integrate`函数内部都会调用此函数。

    解释

    积分的思路如下：

    +   如果我们正在处理 SingularityFunction 表达式，即`SingularityFunction(x, a, n)`，如果`n >= 0`，我们只需返回`SingularityFunction(x, a, n + 1)/(n + 1)`，如果`n < 0`，则返回`SingularityFunction(x, a, n + 1)`。

    +   如果节点是具有 SingularityFunction 项的乘法或幂节点，我们将整个表达式重写为 Heaviside 和 DiracDelta 的术语，然后积分输出。最后，我们将积分输出重新写成 SingularityFunction 的术语。

    +   如果上述情况都不符合，我们返回 None。

    示例

    ```py
    >>> from sympy.integrals.singularityfunctions import singularityintegrate
    >>> from sympy import SingularityFunction, symbols, Function
    >>> x, a, n, y = symbols('x a n y')
    >>> f = Function('f')
    >>> singularityintegrate(SingularityFunction(x, a, 3), x)
    SingularityFunction(x, a, 4)/4
    >>> singularityintegrate(5*SingularityFunction(x, 5, -2), x)
    5*SingularityFunction(x, 5, -1)
    >>> singularityintegrate(6*SingularityFunction(x, 5, -1), x)
    6*SingularityFunction(x, 5, 0)
    >>> singularityintegrate(x*SingularityFunction(x, 0, -1), x)
    0
    >>> singularityintegrate(SingularityFunction(x, 1, -1) * f(x), x)
    f(1)*SingularityFunction(x, 1, 0) 
    ```

1.  如果启发式算法无法应用，接下来会尝试 `risch_integrate()`。*Risch 算法* 是一种计算初等函数的反导数的通用方法。Risch 算法是一个决策过程，可以确定是否存在初等解，并在这种情况下计算它。它可以扩展到处理许多非初等函数，除了初等函数。但是，在 SymPy 中实现的版本仅支持完整算法的一小部分，特别是仅实现了对指数和对数的超越算法的部分。`risch_integrate()` 相比其他方法的一个优势是，如果返回 `NonElementaryIntegral` 的一个实例，算法证明该积分为非初等的，这意味着积分不能用指数、对数、三角函数、幂函数、有理函数、代数函数和函数组合的组合表示。

    ```py
    sympy.integrals.risch.risch_integrate(f, x, extension=None, handle_first='log', separate_integral=False, rewrite_complex=None, conds='piecewise')
    ```

    Risch 积分算法。

    解释

    仅支持超越函数。目前仅支持指数和对数，但支持三角函数即将推出。

    如果此函数在结果中返回一个未评估的积分，意味着它已证明该积分为非初等的。任何错误将导致抛出 NotImplementedError。未评估的积分将是 NonElementaryIntegral 的一个实例，是 Integral 的一个子类。

    `handle_first` 可以是 'exp' 或者 'log'。这会改变扩展的顺序，并可能导致不同（但等效）的解决方案（例如，参见问题 5109）。也有可能只能用其中一种计算积分，因为并未完全实现所有情况。默认为 'log'，这样外部扩展在可能时是指数的，因为更多的指数情况已经实现。

    如果 `separate_integral` 为 `True`，则结果作为元组 (ans, i) 返回，其中积分为 ans + i，ans 是初等的，i 是 NonElementaryIntegral 或 0。如果希望使用其他算法进一步积分 NonElementaryIntegral 部分以可能获得特殊函数的解，则此选项很有用。默认为 False。

    示例

    ```py
    >>> from sympy.integrals.risch import risch_integrate
    >>> from sympy import exp, log, pprint
    >>> from sympy.abc import x 
    ```

    首先，我们尝试积分 exp(-x**2)。除了 sqrt(pi) 的常数因子为 2，这是著名的误差函数。

    ```py
    >>> pprint(risch_integrate(exp(-x**2), x))
     /
     |
     |    2
     |  -x
     | e    dx
     |
    / 
    ```

    结果中的未求值积分意味着 risch_integrate() 已经证明了 exp(-x**2) 没有基本的反导数。

    在许多情况下，risch_integrate() 可以将非基本反导数部分分离出来。例如，

    ```py
    >>> pprint(risch_integrate((2*log(x)**2 - log(x) - x**2)/(log(x)**3 -
    ... x**2*log(x)), x))
     /
     |
     log(-x + log(x))   log(x + log(x))    |   1
    - ---------------- + --------------- +  | ------ dx
     2                  2           | log(x)
     |
     / 
    ```

    这意味着它已经证明了 1/log(x) 的积分是非基本的。这个函数也被称为对数积分，通常表示为 Li(x)。

    risch_integrate() 目前只接受纯超越函数，包括指数和对数，尽管请注意，这可能包括嵌套的指数和对数，以及底数不为 E 的指数。

    ```py
    >>> pprint(risch_integrate(exp(x)*exp(exp(x)), x))
     / x\
     \e /
    e
    >>> pprint(risch_integrate(exp(exp(x)), x))
     /
     |
     |  / x\
     |  \e /
     | e     dx
     |
    / 
    ```

    ```py
    >>> pprint(risch_integrate(x*x**x*log(x) + x**x + x*x**x, x))
     x
    x*x
    >>> pprint(risch_integrate(x**x, x))
     /
     |
     |  x
     | x  dx
     |
    / 
    ```

    ```py
    >>> pprint(risch_integrate(-1/(x*log(x)*log(log(x))**2), x))
     1
    -----------
    log(log(x)) 
    ```

    ```py
    class sympy.integrals.risch.NonElementaryIntegral(function, *symbols, **assumptions)
    ```

    表示一个非基本积分。

    解释

    如果 integrate() 的结果是这个类的实例，则保证是非基本的。请注意，默认情况下，integrate() 将尝试找到任何闭合形式的解，即使是在可能本身不是基本的特殊函数中。为了使 integrate() 只提供基本解，或者在可以证明积分是非基本的情况下，返回这个类的实例，请使用 integrate(risch=True)。在这种情况下，如果无法做出这样的判断，integrate() 可能会引发 NotImplementedError。

    integrate() 使用确定性 Risch 算法来对基本函数进行积分或证明它们没有基本积分。在某些情况下，该算法可以将积分分解为基本和非基本部分，因此 integrate 的结果将是基本表达式和非基本积分的和。

    示例

    ```py
    >>> from sympy import integrate, exp, log, Integral
    >>> from sympy.abc import x 
    ```

    ```py
    >>> a = integrate(exp(-x**2), x, risch=True)
    >>> print(a)
    Integral(exp(-x**2), x)
    >>> type(a)
    <class 'sympy.integrals.risch.NonElementaryIntegral'> 
    ```

    ```py
    >>> expr = (2*log(x)**2 - log(x) - x**2)/(log(x)**3 - x**2*log(x))
    >>> b = integrate(expr, x, risch=True)
    >>> print(b)
    -log(-x + log(x))/2 + log(x + log(x))/2 + Integral(1/log(x), x)
    >>> type(b.atoms(Integral).pop())
    <class 'sympy.integrals.risch.NonElementaryIntegral'> 
    ```

1.  对于非基本定积分，SymPy 使用所谓的 Meijer G 函数。详细信息请参见 使用 Meijer G 函数计算积分。

1.  到目前为止提到的所有算法都是基于模式匹配的启发式算法，或者使用与大多数人在微积分课程中所学的方式大不相同的算法来求解积分。SymPy 还实现了一种可以像在微积分中一样求解积分的方法。这种方法的优势在于可以提取出积分步骤，以便可以看到如何手工计算积分。这由 [SymPy Gamma](https://sympygamma.com) 使用。这在 `manualintegrate()` 函数中实现。可以通过 `integral_steps()` 函数查看积分步骤。

    ```py
    sympy.integrals.manualintegrate.manualintegrate(f, var)
    ```

    解释

    使用类似学生手工操作的算法计算单变量的不定积分。

    与 `integrate()` 不同，var 只能是单个符号。

    示例

    ```py
    >>> from sympy import sin, cos, tan, exp, log, integrate
    >>> from sympy.integrals.manualintegrate import manualintegrate
    >>> from sympy.abc import x
    >>> manualintegrate(1 / x, x)
    log(x)
    >>> integrate(1/x)
    log(x)
    >>> manualintegrate(log(x), x)
    x*log(x) - x
    >>> integrate(log(x))
    x*log(x) - x
    >>> manualintegrate(exp(x) / (1 + exp(2 * x)), x)
    atan(exp(x))
    >>> integrate(exp(x) / (1 + exp(2 * x)))
    RootSum(4*_z**2 + 1, Lambda(_i, _i*log(2*_i + exp(x))))
    >>> manualintegrate(cos(x)**4 * sin(x), x)
    -cos(x)**5/5
    >>> integrate(cos(x)**4 * sin(x), x)
    -cos(x)**5/5
    >>> manualintegrate(cos(x)**4 * sin(x)**3, x)
    cos(x)**7/7 - cos(x)**5/5
    >>> integrate(cos(x)**4 * sin(x)**3, x)
    cos(x)**7/7 - cos(x)**5/5
    >>> manualintegrate(tan(x), x)
    -log(cos(x))
    >>> integrate(tan(x), x)
    -log(cos(x)) 
    ```

    另请参阅

    `sympy.integrals.integrals.integrate`, `sympy.integrals.integrals.Integral.doit`, `sympy.integrals.integrals.Integral`

    ```py
    sympy.integrals.manualintegrate.integral_steps(integrand, symbol, **options)
    ```

    返回计算积分所需的步骤。

    返回：

    **规则**：规则

    > 第一步；大多数规则还有必须考虑的子步骤。这些子步骤可以使用`manualintegrate`来评估以获得结果。

    解释

    此函数尝试尽可能地模仿学生手工操作。

    SymPy Gamma 使用此方法提供积分的逐步解释。它用于格式化该函数结果的代码可以在[`github.com/sympy/sympy_gamma/blob/master/app/logic/intsteps.py`](https://github.com/sympy/sympy_gamma/blob/master/app/logic/intsteps.py)找到。

    例子

    ```py
    >>> from sympy import exp, sin
    >>> from sympy.integrals.manualintegrate import integral_steps
    >>> from sympy.abc import x
    >>> print(repr(integral_steps(exp(x) / (1 + exp(2 * x)), x)))     
    URule(integrand=exp(x)/(exp(2*x) + 1), variable=x, u_var=_u, u_func=exp(x),
    substep=ArctanRule(integrand=1/(_u**2 + 1), variable=_u, a=1, b=1, c=1))
    >>> print(repr(integral_steps(sin(x), x)))     
    SinRule(integrand=sin(x), variable=x)
    >>> print(repr(integral_steps((x**2 + 3)**2, x)))     
    RewriteRule(integrand=(x**2 + 3)**2, variable=x, rewritten=x**4 + 6*x**2 + 9,
    substep=AddRule(integrand=x**4 + 6*x**2 + 9, variable=x,
    substeps=[PowerRule(integrand=x**4, variable=x, base=x, exp=4),
    ConstantTimesRule(integrand=6*x**2, variable=x, constant=6, other=x**2,
    substep=PowerRule(integrand=x**2, variable=x, base=x, exp=2)),
    ConstantRule(integrand=9, variable=x)])) 
    ```

1.  最后，如果上述所有方法都失败了，SymPy 还使用了 Risch-Norman 算法的简化版本。这个算法通常是计算速度最慢的，因此被最后尝试。它在`heurisch()`中实现：

    ```py
    sympy.integrals.heurisch.heurisch(f, x, rewrite=False, hints=None, mappings=None, retries=3, degree_offset=0, unnecessary_permutations=None, _try_heurisch=None)
    ```

    使用启发式 Risch 算法计算不定积分。

    解释

    这是一种启发式方法，使用扩展的启发式（并行）Risch 算法在有限项中进行不定积分，基于 Manuel Bronstein 的“穷人积分器”。

    该算法支持各类函数，包括超越元素或特殊函数，如 Airy，Bessel，Whittaker 和 Lambert。

    注意，该算法不是一个决策过程。如果它无法计算给定函数的反导数，那么这并不证明这样的函数不存在。在这种情况下应使用递归的 Risch 算法。这个算法是否可以成为一个完全的决策过程尚未解决。

    这是一个内部积分器过程。在大多数情况下，您应该使用顶层的‘integrate’函数，因为此过程需要一些预处理步骤，否则可能失败。

    规格

    heurisch(f, x, rewrite=False, hints=None)

    > 其中
    > 
    > f：表达式 x：符号
    > 
    > 重写 -> 强制使用‘tan’和‘tanh’重写‘f’提示 -> 可能出现在反导数中的函数列表
    > 
    > > +   hints = None –> 没有建议
    > > +   
    > > +   hints = [ ] –> 尝试解析
    > > +   
    > > +   hints = [f1, …, fn] –> 我们更了解

    例子

    ```py
    >>> from sympy import tan
    >>> from sympy.integrals.heurisch import heurisch
    >>> from sympy.abc import x, y 
    ```

    ```py
    >>> heurisch(y*tan(x), x)
    y*log(tan(x)**2 + 1)/2 
    ```

    参见 Manuel Bronstein 的“穷人积分器”：

    参见

    `sympy.integrals.integrals.Integral.doit`, `sympy.integrals.integrals.Integral`, `sympy.integrals.heurisch.components`

    参考

    [R570]

    [`www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html`](https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html)

    有关已实现算法的更多信息，请参阅：

    [R571]

    K. Geddes, L. Stefanus, On the Risch-Norman Integration Method and its Implementation in Maple, Proceedings of ISSAC’89, ACM Press, 212-217.

    [R572]

    J. H. Davenport, On the Parallel Risch Algorithm (I), Proceedings of EUROCAM’82, LNCS 144, Springer, 144-157.

    [R573]

    J. H. Davenport, On the Parallel Risch Algorithm (III): Use of Tangents, SIGSAM Bulletin 16 (1982), 3-6.

    [R574]

    J. H. Davenport, B. M. Trager, On the Parallel Risch Algorithm (II), ACM Transactions on Mathematical Software 11 (1985), 356-362.

    ```py
    sympy.integrals.heurisch.components(f, x)
    ```

    返回给定表达式的所有功能组件，包括符号、函数应用和组合，以及非整数幂。分数幂以最小的正指数收集。

    示例

    ```py
    >>> from sympy import cos, sin
    >>> from sympy.abc import x
    >>> from sympy.integrals.heurisch import components 
    ```

    ```py
    >>> components(sin(x)*cos(x)**2, x)
    {x, sin(x), cos(x)} 
    ```

    另请参阅

    `heurisch`

## API 参考

```py
sympy.integrals.integrals.integrate(f, var, ...)
```

自 1.6 版起已弃用：使用 `Poly` 的 `integrate()` 已弃用。请改用 `Poly.integrate()`。参见 使用 Poly 进行积分。

解释

使用 Risch-Norman 算法和表查找计算一个或多个变量的定积分或不定积分。此过程能处理基本代数和超越函数，以及包括 Airy、Bessel、Whittaker 和 Lambert 在内的大量特殊函数。

变量 var 可以是：

+   一个符号 – 不定积分

+   一个元组 (symbol, a) – 不定积分并返回结果

    用 `a` 替换 `symbol` 给出的

+   一个元组 (symbol, a, b) – 定积分

可指定多个变量，此时结果为多重积分。（如果省略 var 并且被积函数是一元的，则将在该变量上进行不定积分。）

不定积分返回时，与积分变量无关的项将被省略。（见示例）

定积分不恰当时常需精确的收敛条件。分别传递 conds=’piecewise’、‘separate’ 或 ‘none’ 以得到以下返回：作为 Piecewise 函数、作为单独结果（即结果将是一个元组），或者不返回（默认为 ‘piecewise’）。

**策略**

SymPy 使用多种方法进行定积分。一种方法是找到被积函数的反导函数，然后应用基本定理。实现了多项式、有理函数、三角函数以及包含 DiracDelta 项的积分函数。

SymPy 还实现了 Risch 算法的部分，这是一个用于积分基本函数的决策过程，即，算法可以找到一个基本反导数，或者证明不存在这样的反导数。还有一个（非常成功但有些慢）启发式 Risch 算法的通用实现。随着更多完整的 Risch 算法的实现，这种算法最终将被淘汰。有关使用代数方法计算反导数的更多详细信息，请参阅 Integral._eval_integral() 的文档字符串。

可以通过选项 risch=True 来仅使用（完整的）Risch 算法。如果要知道一个基本函数是否有基本反导数，这是很有用的。如果这个函数返回的不定积分是 NonElementaryIntegral 的实例，那么 Risch 算法已经证明该积分是非基本的。请注意，默认情况下，对这些积分尝试了其他方法（如下面概述的 Meijer G 方法），因为它们可能可以用特殊函数表达，因此如果只关心基本答案，请使用 risch=True。还请注意，即使使用 risch=True，由这个函数返回的未计算积分也不一定是 NonElementaryIntegral，因为这可能只是表示该函数的积分所需的 Risch 算法的特定部分尚未实现。

另一族策略来自将被积函数重写为所谓的 Meijer G-函数。单个 G-函数的不定积分总是可以计算的，并且两个 G-函数乘积的定积分可以从零到无穷计算。实施了各种策略来将被积函数重写为 G-函数，并使用此信息来计算积分（请参阅 `meijerint` 模块）。

可以通过选项 manual=True 来仅使用尝试模仿手工积分的算法。这种算法处理的积分因子较少，但可能以更熟悉的形式返回结果。`manualintegrate` 模块具有返回使用的步骤的函数（更多信息请参阅模块文档字符串）。

一般来说，代数方法最适合计算（可能复杂的）基本函数组合的反导数。G-函数方法最适合计算从零到无穷的中度复杂的特殊函数组合的定积分，或者非常简单的特殊函数组合的不定积分。

积分代码使用的策略如下：

+   如果计算一个定积分，并且两个限制值都是实数，并且至少一个限制值是 +- oo，请首先尝试 G-函数方法进行定积分。

+   尝试找到一个反导数，使用所有可用的方法，按性能排序（即首先尝试最快的方法，最后尝试最慢的方法；特别是首先尝试多项式积分，其次尝试 Meijer G-函数，最后尝试启发式 Risch 算法）。

+   如果仍然不成功，请尝试 G 函数，无论限制如何。

选项 meijerg=True, False, None 可分别用于：始终使用 G 函数方法且不使用其他方法，永不使用 G 函数方法，或使用所有可用方法（如上述顺序）。默认为 None。

示例

```py
>>> from sympy import integrate, log, exp, oo
>>> from sympy.abc import a, x, y 
```

```py
>>> integrate(x*y, x)
x**2*y/2 
```

```py
>>> integrate(log(x), x)
x*log(x) - x 
```

```py
>>> integrate(log(x), (x, 1, a))
a*log(a) - a + 1 
```

```py
>>> integrate(x)
x**2/2 
```

与 x 无关的项被不定积分舍弃：

```py
>>> from sympy import sqrt
>>> integrate(sqrt(1 + x), (x, 0, x))
2*(x + 1)**(3/2)/3 - 2/3
>>> integrate(sqrt(1 + x), x)
2*(x + 1)**(3/2)/3 
```

```py
>>> integrate(x*y)
Traceback (most recent call last):
...
ValueError: specify integration variables to integrate x*y 
```

注意，`integrate(x)`语法仅用于交互式会话的方便，应在库代码中避免使用。

```py
>>> integrate(x**a*exp(-x), (x, 0, oo)) # same as conds='piecewise'
Piecewise((gamma(a + 1), re(a) > -1),
 (Integral(x**a*exp(-x), (x, 0, oo)), True)) 
```

```py
>>> integrate(x**a*exp(-x), (x, 0, oo), conds='none')
gamma(a + 1) 
```

```py
>>> integrate(x**a*exp(-x), (x, 0, oo), conds='separate')
(gamma(a + 1), re(a) > -1) 
```

参见

`Integral`, `Integral.doit`

```py
sympy.integrals.integrals.line_integrate(field, Curve, variables)
```

计算线积分。

示例

```py
>>> from sympy import Curve, line_integrate, E, ln
>>> from sympy.abc import x, y, t
>>> C = Curve([E**t + 1, E**t - 1], (t, 0, ln(2)))
>>> line_integrate(x + y, C, [x, y])
3*sqrt(2) 
```

参见

`sympy.integrals.integrals.integrate`, `Integral`

类`Integral`表示未评估的积分，并具有一些有助于表达式积分的方法。

```py
class sympy.integrals.integrals.Integral(function, *symbols, **assumptions)
```

表示未评估的积分。

```py
is_commutative
```

返回积分中所有自由符号是否可交换。

```py
as_sum(n=None, method='midpoint', evaluate=True)
```

通过求和近似确定积分。

参数：

**n :**

> 使用的子区间数，可选。

**method :**

> 其中之一：'left', 'right', 'midpoint', 'trapezoid'。

**evaluate** : bool

> 如果为 False，则返回一个未评估的求和表达式。默认为 True，评估求和。

注意事项

这些近似积分方法在[1]中描述。

示例

```py
>>> from sympy import Integral, sin, sqrt
>>> from sympy.abc import x, n
>>> e = Integral(sin(x), (x, 3, 7))
>>> e
Integral(sin(x), (x, 3, 7)) 
```

出于演示目的，此间隔仅将分为两个区域，由[3, 5]和[5, 7]界定。

左手法则使用每个区间左侧的函数评估：

```py
>>> e.as_sum(2, 'left')
2*sin(5) + 2*sin(3) 
```

中点法则使用每个区间的中心进行评估：

```py
>>> e.as_sum(2, 'midpoint')
2*sin(4) + 2*sin(6) 
```

右手法则使用每个区间右侧的函数评估：

```py
>>> e.as_sum(2, 'right')
2*sin(5) + 2*sin(7) 
```

梯形法则使用区间两侧的函数评估。这相当于取左手法和右手法结果的平均值：

```py
>>> s = e.as_sum(2, 'trapezoid')
>>> s
2*sin(5) + sin(3) + sin(7)
>>> (e.as_sum(2, 'left') + e.as_sum(2, 'right'))/2 == s
True 
```

在这里，通过使用中点或右手法可以避免在 x = 0 处的不连续：

```py
>>> e = Integral(1/sqrt(x), (x, 0, 1))
>>> e.as_sum(5).n(4)
1.730
>>> e.as_sum(10).n(4)
1.809
>>> e.doit().n(4)  # the actual value is 2
2.000 
```

左手法或梯形法将遇到不连续并返回无穷大：

```py
>>> e.as_sum(5, 'left')
zoo 
```

区间数可以是符号的。如果省略，将使用一个虚拟符号。

```py
>>> e = Integral(x**2, (x, 0, 2))
>>> e.as_sum(n, 'right').expand()
8/3 + 4/n + 4/(3*n**2) 
```

这表明中点法则更精确，因为其误差项按 n 的平方衰减：

```py
>>> e.as_sum(method='midpoint').expand()
8/3 - 2/(3*_n**2) 
```

当 evaluate=False 时返回一个符号求和：

```py
>>> e.as_sum(n, 'midpoint', evaluate=False)
2*Sum((2*_k/n - 1/n)**2, (_k, 1, n))/n 
```

参见

`Integral.doit`

使用任何给定的提示执行积分

参考文献

[R575]

[`en.wikipedia.org/wiki/Riemann_sum#Riemann_summation_methods`](https://en.wikipedia.org/wiki/Riemann_sum#Riemann_summation_methods)

```py
doit(**hints)
```

使用任何给定的提示执行积分。

示例

```py
>>> from sympy import Piecewise, S
>>> from sympy.abc import x, t
>>> p = x**2 + Piecewise((0, x/t < 0), (1, True))
>>> p.integrate((t, S(4)/5, 1), (x, -1, 1))
1/3 
```

参见

`sympy.integrals.trigonometry.trigintegrate`, `sympy.integrals.heurisch.heurisch`, `sympy.integrals.rationaltools.ratint`

`as_sum`

通过求和来近似积分

```py
property free_symbols
```

如果要确定积分是否依赖于某个符号，则此方法返回积分计算时存在的符号。这在试图确定积分是否依赖于某个符号时非常有用。

示例

```py
>>> from sympy import Integral
>>> from sympy.abc import x, y
>>> Integral(x, (x, y, 1)).free_symbols
{y} 
```

另见

`sympy.concrete.expr_with_limits.ExprWithLimits.function`, `sympy.concrete.expr_with_limits.ExprWithLimits.limits`, `sympy.concrete.expr_with_limits.ExprWithLimits.variables`

```py
principal_value(**kwargs)
```

计算给定实轴上给定区间内实函数的柯西主值。

解释

在数学中，柯西主值是一种方法，用于为某些原本未定义的不定积分赋值。

示例

```py
>>> from sympy import Integral, oo
>>> from sympy.abc import x
>>> Integral(x+1, (x, -oo, oo)).principal_value()
oo
>>> f = 1 / (x**3)
>>> Integral(f, (x, -oo, oo)).principal_value()
0
>>> Integral(f, (x, -10, 10)).principal_value()
0
>>> Integral(f, (x, -10, oo)).principal_value() + Integral(f, (x, -oo, 10)).principal_value()
0 
```

参考文献

[R576]

[`en.wikipedia.org/wiki/Cauchy_principal_value`](https://en.wikipedia.org/wiki/Cauchy_principal_value)

[R577]

[`mathworld.wolfram.com/CauchyPrincipalValue.html`](https://mathworld.wolfram.com/CauchyPrincipalValue.html)

```py
transform(x, u)
```

执行从 \(x\) 到 \(u\) 的变量变换，使用由 \(x\) 和 \(u\) 之间的关系给出的关系，定义变换 \(f\) 和 \(F\)（它们是互为逆函数）如下：

1.  如果 \(x\) 是一个符号（即积分的变量），那么 \(u\) 将被解释为某个函数 \(f(u)\)，其逆为 \(F(u)\)。这实际上只是将 \(x\) 替换为 \(f(x)\)。

1.  如果 \(u\) 是一个符号，那么 \(x\) 将被解释为某个函数 \(F(x)\)，其逆为 \(f(u)\)。这通常被称为 u-替换。

一旦识别出 \(f\) 和 \(F\)，变换如下进行：

\[\int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x) \frac{\mathrm{d}}{\mathrm{d}x}\]

其中 \(F(x)\) 是 \(f(x)\) 的逆函数，积分的限制和被积函数已经校正，以保证积分后的值保持不变。

注记

映射函数 \(F(x)\) 或 \(f(u)\) 必须导致唯一的积分结果。线性或有理线性表达式，如 `2*x`，`1/x` 和 `sqrt(x)`，始终有效；二次表达式如 `x**2 - 1` 也是可接受的，只要积分被积函数不依赖解的符号（见示例）。

如果`x`不是积分变量，则积分将保持不变。

`x`必须是（或包含）积分变量之一。如果`u`有多个自由符号，则应作为元组(`u`, `uvar`)发送，其中`uvar`标识替换积分变量的变量。XXX 它可以包含另一个积分变量吗？

示例

```py
>>> from sympy.abc import a, x, u
>>> from sympy import Integral, cos, sqrt 
```

```py
>>> i = Integral(x*cos(x**2 - 1), (x, 0, 1)) 
```

变换可以改变积分变量

```py
>>> i.transform(x, u)
Integral(u*cos(u**2 - 1), (u, 0, 1)) 
```

变换可以执行 u-替换，只要获得唯一的被积函数：

```py
>>> ui = i.transform(x**2 - 1, u)
>>> ui
Integral(cos(u)/2, (u, -1, 0)) 
```

此尝试失败，因为 x = +/-sqrt(u + 1)，符号未从被积函数中取消：

```py
>>> Integral(cos(x**2 - 1), (x, 0, 1)).transform(x**2 - 1, u)
Traceback (most recent call last):
...
ValueError:
The mapping between F(x) and f(u) did not give a unique integrand. 
```

变换可以进行替换。在这里，使用“u-替换”将先前的结果转换回原始表达式：

```py
>>> ui.transform(sqrt(u + 1), x) == i
True 
```

我们可以通过常规替换来完成相同的操作：

```py
>>> ui.transform(u, x**2 - 1) == i
True 
```

如果\(x\)不包含积分符号，则积分将保持不变。积分\(i\)没有积分变量\(a\)，因此没有变化：

```py
>>> i.transform(a, x) == i
True 
```

当\(u\)有多个自由符号时，替换\(x\)的符号必须通过传递\(u\)作为元组来标识：

```py
>>> Integral(x, (x, 0, 1)).transform(x, (u + a, u))
Integral(a + u, (u, -a, 1 - a))
>>> Integral(x, (x, 0, 1)).transform(x, (u + a, a))
Integral(a + u, (a, -u, 1 - u)) 
```

参见

`sympy.concrete.expr_with_limits.ExprWithLimits.variables`

列出积分变量

`as_dummy`

用虚拟变量替换积分变量

`Integral` 继承自 `ExprWithLimits`，这是 `Integral` 和 `Sum` 的常见超类。

```py
class sympy.concrete.expr_with_limits.ExprWithLimits(function, *symbols, **assumptions)
```

```py
property bound_symbols
```

只返回虚拟变量。

示例

```py
>>> from sympy import Integral
>>> from sympy.abc import x, i, j, k
>>> Integral(x**i, (i, 1, 3), (j, 2), k).bound_symbols
[i, j] 
```

参见

`function`，`limits`，`free_symbols`

`as_dummy`

重命名虚拟变量

`sympy.integrals.integrals.Integral.transform`

对虚拟变量执行映射

```py
property free_symbols
```

此方法返回对象中的符号，不包括那些取特定值的符号（即虚拟符号）。

示例

```py
>>> from sympy import Sum
>>> from sympy.abc import x, y
>>> Sum(x, (x, y, 1)).free_symbols
{y} 
```

```py
property function
```

返回应用于限制的函数。

示例

```py
>>> from sympy import Integral
>>> from sympy.abc import x
>>> Integral(x**2, (x,)).function
x**2 
```

参见

`limits`, `variables`, `free_symbols`

```py
property has_finite_limits
```

如果极限已知为有限，则返回 True，可以通过显式边界、边界假设或变量假设来确定。如果根据边界已知为无限，则返回 False。如果没有足够的信息来确定，则返回 None。

示例

```py
>>> from sympy import Sum, Integral, Product, oo, Symbol
>>> x = Symbol('x')
>>> Sum(x, (x, 1, 8)).has_finite_limits
True 
```

```py
>>> Integral(x, (x, 1, oo)).has_finite_limits
False 
```

```py
>>> M = Symbol('M')
>>> Sum(x, (x, 1, M)).has_finite_limits 
```

```py
>>> N = Symbol('N', integer=True)
>>> Product(x, (x, 1, N)).has_finite_limits
True 
```

另请参阅

`has_reversed_limits`

```py
property has_reversed_limits
```

如果极限已知为反向顺序，则返回 True，可以通过显式边界、边界假设或变量假设来确定。如果根据边界已知为正常顺序，则返回 False。如果没有足够的信息来确定，则返回 None。

示例

```py
>>> from sympy import Sum, Integral, Product, oo, Symbol
>>> x = Symbol('x')
>>> Sum(x, (x, 8, 1)).has_reversed_limits
True 
```

```py
>>> Sum(x, (x, 1, oo)).has_reversed_limits
False 
```

```py
>>> M = Symbol('M')
>>> Integral(x, (x, 1, M)).has_reversed_limits 
```

```py
>>> N = Symbol('N', integer=True, positive=True)
>>> Sum(x, (x, 1, N)).has_reversed_limits
False 
```

```py
>>> Product(x, (x, 2, N)).has_reversed_limits 
```

```py
>>> Product(x, (x, 2, N)).subs(N, N + 2).has_reversed_limits
False 
```

另请参阅

`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence`

```py
property is_number
```

如果 Sum 没有自由符号，则返回 True，否则返回 False。

```py
property limits
```

返回表达式的极限。

示例

```py
>>> from sympy import Integral
>>> from sympy.abc import x, i
>>> Integral(x**i, (i, 1, 3)).limits
((i, 1, 3),) 
```

另请参阅

`function`, `variables`, `free_symbols`

```py
property variables
```

返回极限变量的列表。

```py
>>> from sympy import Sum
>>> from sympy.abc import x, i
>>> Sum(x**i, (i, 1, 3)).variables
[i] 
```

另请参阅

`function`, `limits`, `free_symbols`

`as_dummy`

重命名虚拟变量

`sympy.integrals.integrals.Integral.transform`

对虚拟变量执行映射

## 待办事项和错误

SymPy 仍然有许多函数不知道如何进行积分。有关此模块的错误，请参见[`github.com/sympy/sympy/issues?q=is%3Aissue+is%3Aopen+label%3Aintegrals`](https://github.com/sympy/sympy/issues?q=is%3Aissue+is%3Aopen+label%3Aintegrals)

## 数值积分

SymPy 有函数来计算任何阶数和任何精度的高斯积分的点和权重：

```py
sympy.integrals.quadrature.gauss_legendre(n, n_digits)
```

计算高斯-勒让德积分[[R578]](#r578)的点和权重。

参数：

**n：**

> 积分的秩序。

**n_digits：**

> 返回要返回的点和权重的有效数字。

返回：

**(x, w)**：`x`和`w`是点和权重的浮点数列表。

> 点\(x_i\)和权重\(w_i\)作为`(x, w)`列表的元组返回。

解释

高斯-勒让德积分逼近积分：

\[\int_{-1}¹ f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

一个秩为\(n\)的积分规则的节点\(x_i\)是\(P_n\)的根，权重\(w_i\)由以下给出：

\[w_i = \frac{2}{\left(1-x_i²\right) \left(P'_n(x_i)\right)²}\]

例子

```py
>>> from sympy.integrals.quadrature import gauss_legendre
>>> x, w = gauss_legendre(3, 5)
>>> x
[-0.7746, 0, 0.7746]
>>> w
[0.55556, 0.88889, 0.55556]
>>> x, w = gauss_legendre(4, 5)
>>> x
[-0.86114, -0.33998, 0.33998, 0.86114]
>>> w
[0.34785, 0.65215, 0.65215, 0.34785] 
```

另见

`gauss_laguerre`, `gauss_gen_laguerre`, `gauss_hermite`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R578] (1,2)

[`en.wikipedia.org/wiki/Gaussian_quadrature`](https://en.wikipedia.org/wiki/Gaussian_quadrature)

[R579]

[`people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html)

```py
sympy.integrals.quadrature.gauss_laguerre(n, n_digits)
```

计算高斯-拉盖尔积分[[R580]](#r580)的点和权重。

参数：

**n：**

> 积分的秩序。

**n_digits：**

> 返回要返回的点和权重的有效数字。

返回：

**(x, w)**：`x`和`w`是点和权重的浮点数列表。

> 点\(x_i\)和权重\(w_i\)作为`(x, w)`列表的元组返回。

解释

高斯-拉盖尔积分逼近积分：

\[\int_0^{\infty} e^{-x} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

一个秩为\(n\)的积分规则的节点\(x_i\)是\(L_n\)的根，权重\(w_i\)由以下给出：

\[w_i = \frac{x_i}{(n+1)² \left(L_{n+1}(x_i)\right)²}\]

例子

```py
>>> from sympy.integrals.quadrature import gauss_laguerre
>>> x, w = gauss_laguerre(3, 5)
>>> x
[0.41577, 2.2943, 6.2899]
>>> w
[0.71109, 0.27852, 0.010389]
>>> x, w = gauss_laguerre(6, 5)
>>> x
[0.22285, 1.1889, 2.9927, 5.7751, 9.8375, 15.983]
>>> w
[0.45896, 0.417, 0.11337, 0.010399, 0.00026102, 8.9855e-7] 
```

另见

`gauss_legendre`, `gauss_gen_laguerre`, `gauss_hermite`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R580] (1,2)

[`en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature`](https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature)

[R581]

[`people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html)

```py
sympy.integrals.quadrature.gauss_hermite(n, n_digits)
```

计算 Gauss-Hermite 积分 [[R582]](#r582) 的节点和权重。

参数：

**n：**

> 积分的顺序。

**n_digits：**

> 返回的节点和权重的有效数字位数。

返回：

**(x, w)**：`x` 和 `w` 是浮点数列表。

> 节点 \(x_i\) 和权重 \(w_i\) 返回为 `(x, w)` 列表的元组。

解释

Gauss-Hermite 积分近似于积分：

\[\int_{-\infty}^{\infty} e^{-x²} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

秩为 \(n\) 的积分规则的节点 \(x_i\) 是 \(H_n\) 的根，权重 \(w_i\) 如下所示：

\[w_i = \frac{2^{n-1} n! \sqrt{\pi}}{n² \left(H_{n-1}(x_i)\right)²}\]

示例

```py
>>> from sympy.integrals.quadrature import gauss_hermite
>>> x, w = gauss_hermite(3, 5)
>>> x
[-1.2247, 0, 1.2247]
>>> w
[0.29541, 1.1816, 0.29541] 
```

```py
>>> x, w = gauss_hermite(6, 5)
>>> x
[-2.3506, -1.3358, -0.43608, 0.43608, 1.3358, 2.3506]
>>> w
[0.00453, 0.15707, 0.72463, 0.72463, 0.15707, 0.00453] 
```

参见

`gauss_legendre`, `gauss_laguerre`, `gauss_gen_laguerre`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R582] (1,2)

[`en.wikipedia.org/wiki/Gauss-Hermite_Quadrature`](https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature)

[R583]

[`people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html)

[R584]

[`people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html)

```py
sympy.integrals.quadrature.gauss_gen_laguerre(n, alpha, n_digits)
```

计算广义 Gauss-Laguerre 积分 [[R585]](#r585) 的点和权重。

参数：

**n :**

> 积分的顺序。

**alpha :**

> 奇异性的指数，\(\alpha > -1\)。

**n_digits :**

> 要返回点和权重的显著数字的数量。

返回：

**(x, w)** : `x` 和 `w` 是点和权重的列表，类型为 Float。

> 点 \(x_i\) 和权重 \(w_i\) 以 `(x, w)` 的列表形式返回。

解释

广义 Gauss-Laguerre 积分近似于：

\[\int_{0}^\infty x^{\alpha} e^{-x} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

秩为 \(n\) 的积分规则的节点 \(x_i\) 是 \(L^{\alpha}_n\) 的根，权重 \(w_i\) 由以下给出：

\[w_i = \frac{\Gamma(\alpha+n)} {n \Gamma(n) L^{\alpha}_{n-1}(x_i) L^{\alpha+1}_{n-1}(x_i)}\]

示例

```py
>>> from sympy import S
>>> from sympy.integrals.quadrature import gauss_gen_laguerre
>>> x, w = gauss_gen_laguerre(3, -S.Half, 5)
>>> x
[0.19016, 1.7845, 5.5253]
>>> w
[1.4493, 0.31413, 0.00906] 
```

```py
>>> x, w = gauss_gen_laguerre(4, 3*S.Half, 5)
>>> x
[0.97851, 2.9904, 6.3193, 11.712]
>>> w
[0.53087, 0.67721, 0.11895, 0.0023152] 
```

见也

`gauss_legendre`, `gauss_laguerre`, `gauss_hermite`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R585] (1,2)

[`en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature`](https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature)

[R586]

[`people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html)

```py
sympy.integrals.quadrature.gauss_chebyshev_t(n, n_digits)
```

计算第一类 Gauss-Chebyshev 积分 [[R587]](#r587) 的点和权重。

参数：

**n :**

> 积分的顺序。

**n_digits :**

> 要返回点和权重的显著数字的数量。

返回：

**(x, w)** : `x` 和 `w` 是点和权重的列表，类型为 Float。

> 点 \(x_i\) 和权重 \(w_i\) 以 `(x, w)` 的列表形式返回。

解释

第一类 Gauss-Chebyshev 积分近似于：

\[\int_{-1}^{1} \frac{1}{\sqrt{1-x²}} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

秩为 \(n\) 的积分规则的节点 \(x_i\) 是 \(T_n\) 的根，权重 \(w_i\) 由以下给出：

\[w_i = \frac{\pi}{n}\]

示例

```py
>>> from sympy.integrals.quadrature import gauss_chebyshev_t
>>> x, w = gauss_chebyshev_t(3, 5)
>>> x
[0.86602, 0, -0.86602]
>>> w
[1.0472, 1.0472, 1.0472] 
```

```py
>>> x, w = gauss_chebyshev_t(6, 5)
>>> x
[0.96593, 0.70711, 0.25882, -0.25882, -0.70711, -0.96593]
>>> w
[0.5236, 0.5236, 0.5236, 0.5236, 0.5236, 0.5236] 
```

见也

`gauss_legendre`, `gauss_laguerre`, `gauss_hermite`, `gauss_gen_laguerre`, `gauss_chebyshev_u`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R587] (1,2]

[`zh.wikipedia.org/wiki/切比雪夫－高斯求积`](https://zh.wikipedia.org/wiki/切比雪夫－高斯求积)

[R588]

[`people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html)

```py
sympy.integrals.quadrature.gauss_chebyshev_u(n, n_digits)
```

计算第二类 Gauss-Chebyshev 求积 [[R589]](#r589) 的点和权重。

参数：

**n** : 求积的阶数

**n_digits** : 点和权重的有效数字位数

返回：

**(x, w)** : `x` 和 `w` 分别是浮点数列表。

> 返回 `(x, w)` 的元组，包含点 `x_i` 和权重 `w_i` 的列表。

解释

第二类 Gauss-Chebyshev 求积近似于积分：

\[\int_{-1}^{1} \sqrt{1-x²} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

一个阶数为 \(n\) 的求积规则的节点 \(x_i\) 是 \(U_n\) 的根，权重 \(w_i\) 由以下给出：

\[w_i = \frac{\pi}{n+1} \sin² \left(\frac{i}{n+1}\pi\right)\]

示例

```py
>>> from sympy.integrals.quadrature import gauss_chebyshev_u
>>> x, w = gauss_chebyshev_u(3, 5)
>>> x
[0.70711, 0, -0.70711]
>>> w
[0.3927, 0.7854, 0.3927] 
```

```py
>>> x, w = gauss_chebyshev_u(6, 5)
>>> x
[0.90097, 0.62349, 0.22252, -0.22252, -0.62349, -0.90097]
>>> w
[0.084489, 0.27433, 0.42658, 0.42658, 0.27433, 0.084489] 
```

另请参阅

`gauss_legendre`, `gauss_laguerre`, `gauss_hermite`, `gauss_gen_laguerre`, `gauss_chebyshev_t`, `gauss_jacobi`, `gauss_lobatto`

参考文献

[R589] (1,2)

[`zh.wikipedia.org/wiki/切比雪夫－高斯求积`](https://zh.wikipedia.org/wiki/切比雪夫－高斯求积)

[R590]

[`people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html)

```py
sympy.integrals.quadrature.gauss_jacobi(n, alpha, beta, n_digits)
```

计算高斯-雅各比数值积分 [[R591]](#r591) 的点和权重。

参数：

**n** : 数值积分的阶数

**alpha** : Jacobian 多项式的第一个参数，\(\alpha > -1\)

**beta** : Jacobian 多项式的第二个参数，\(\beta > -1\)

**n_digits** : 返回的点和权重的有效数字数

返回：

**(x, w)** : `x` 和 `w` 分别为点和权重的浮点数列表。

> 返回为 `(x, w)` 列表元组的点 \(x_i\) 和权重 \(w_i\)。

解释

第一类高斯-雅各比数值积分近似计算积分：

\[\int_{-1}¹ (1-x)^\alpha (1+x)^\beta f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

节点 \(x_i\) 是一个阶 \(n\) 的数值积分规则的多项式 \(P^{(\alpha,\beta)}_n\) 的根，权重 \(w_i\) 给定为：

\[w_i = -\frac{2n+\alpha+\beta+2}{n+\alpha+\beta+1} \frac{\Gamma(n+\alpha+1)\Gamma(n+\beta+1)} {\Gamma(n+\alpha+\beta+1)(n+1)!} \frac{2^{\alpha+\beta}}{P'_n(x_i) P^{(\alpha,\beta)}_{n+1}(x_i)}\]

示例

```py
>>> from sympy import S
>>> from sympy.integrals.quadrature import gauss_jacobi
>>> x, w = gauss_jacobi(3, S.Half, -S.Half, 5)
>>> x
[-0.90097, -0.22252, 0.62349]
>>> w
[1.7063, 1.0973, 0.33795] 
```

```py
>>> x, w = gauss_jacobi(6, 1, 1, 5)
>>> x
[-0.87174, -0.5917, -0.2093, 0.2093, 0.5917, 0.87174]
>>> w
[0.050584, 0.22169, 0.39439, 0.39439, 0.22169, 0.050584] 
```

另见

`gauss_legendre`, `gauss_laguerre`, `gauss_hermite`, `gauss_gen_laguerre`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_lobatto`

参考文献

[R591] (1,2)

[`en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature`](https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature)

[R592]

[`people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html)

[R593]

[`people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html`](https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html)

```py
sympy.integrals.quadrature.gauss_lobatto(n, n_digits)
```

计算高斯-洛巴托数值积分 [[R594]](#r594) 的点和权重。

参数：

**n** : 数值积分的阶数

**n_digits** : 返回的点和权重的有效数字数

返回：

**(x, w)** : `x` 和 `w` 分别为点和权重的浮点数列表。

> 返回为 `(x, w)` 列表元组的点 \(x_i\) 和权重 \(w_i\)。

解释

高斯-洛巴托数值积分近似计算积分：

\[\int_{-1}¹ f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]

节点 \(x_i\) 是一个阶 \(n\) 的数值积分规则的多项式 \(P'_(n-1)\) 的根，权重 \(w_i\) 给定为：

\[\begin{split}&w_i = \frac{2}{n(n-1) \left[P_{n-1}(x_i)\right]²},\quad x\neq\pm 1\\ &w_i = \frac{2}{n(n-1)},\quad x=\pm 1\end{split}\]

示例

```py
>>> from sympy.integrals.quadrature import gauss_lobatto
>>> x, w = gauss_lobatto(3, 5)
>>> x
[-1, 0, 1]
>>> w
[0.33333, 1.3333, 0.33333]
>>> x, w = gauss_lobatto(4, 5)
>>> x
[-1, -0.44721, 0.44721, 1]
>>> w
[0.16667, 0.83333, 0.83333, 0.16667] 
```

参见

`gauss_legendre`, `gauss_laguerre`, `gauss_gen_laguerre`, `gauss_hermite`, `gauss_chebyshev_t`, `gauss_chebyshev_u`, `gauss_jacobi`

参考文献

[R594] (1,2)

[`zh.wikipedia.org/wiki/高斯求积#高斯－洛巴托规则`](https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules)

[R595]

[`web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm`](https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm)

### 多面体积分

SymPy 中的`intpoly`模块实现了计算多面体上多项式积分的方法。使用了 Chin 等人（2015 年）[1] 中描述的评估技术。

二维多边形或多边形的输入使用了 SymPy 中已有的 `Polygon` 数据结构。参见 `sympy.geometry.polygon` 如何创建多边形。

对于三维多面体或多胞形，最经济的表示方法是指定顶点列表，并将每个组成面（多边形）表示为顶点索引列表。

例如，考虑单位立方体。其表示方法如下。

`unit_cube = [[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0),(1, 0, 1), (1, 1, 0), (1, 1, 1)],`

`[3, 7, 6, 2], [1, 5, 7, 3], [5, 4, 6, 7], [0, 4, 5, 1], [2, 0, 1, 3], [2, 6, 4, 0]]`

这里，第一个子列表是顶点列表。其他小列表如`[3, 7, 6, 2]`表示多面体的二维面，其顶点在第一个子列表中的索引为`3, 7, 6, 2`（按顺序）。

本模块中的主要方法是 `polytope_integrate()`

> +   `polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x)` 返回三角形（顶点为 (0, 0), (0, 1), (1, 0)）上 \(x\) 的积分。
> +   
> +   `polytope_integrate(unit_cube, x + y + z)` 返回单位立方体上 \(x + y + z\) 的积分。

## 参考文献

[1]：Chin, Eric B., Jean B. Lasserre 和 N. Sukumar。《计算力学》56.6（2015）：967-981。

PDF 链接：[`dilbert.engr.ucdavis.edu/~suku/quadrature/cls-integration.pdf`](http://dilbert.engr.ucdavis.edu/~suku/quadrature/cls-integration.pdf)

## 示例

## 对于 2D 多边形

单一多项式：

```py
>>> from sympy.integrals.intpoly import *
>>> init_printing(use_unicode=False)
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x)
1/6
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x + x*y + y**2)
7/24 
```

指定多项式列表：

```py
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [3, x*y + y**2, x**4], max_degree=4)
 4               2
{3: 3/2, x : 1/30, x*y + y : 1/8}
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [1.125, x, x**2, 6.89*x**3, x*y + y**2, x**4], max_degree=4)
 2              3  689    4               2
{1.125: 9/16, x: 1/6, x : 1/12, 6.89*x : ----, x : 1/30, x*y + y : 1/8}
 2000 
```

计算所有单项式，直至最大次数：

```py
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)),max_degree=3)
 2         3                 2         3                      2         2
{0: 0, 1: 1/2, x: 1/6, x : 1/12, x : 1/20, y: 1/6, y : 1/12, y : 1/20, x*y: 1/24, x*y : 1/60, x *y: 1/60} 
```

## 对于 3-多胞体/多面体

单一多项式：

```py
>>> from sympy.integrals.intpoly import *
>>> cube = [[(0, 0, 0), (0, 0, 5), (0, 5, 0), (0, 5, 5), (5, 0, 0), (5, 0, 5), (5, 5, 0), (5, 5, 5)], [2, 6, 7, 3], [3, 7, 5, 1], [7, 6, 4, 5], [1, 5, 4, 0], [3, 1, 0, 2], [0, 4, 6, 2]]
>>> polytope_integrate(cube, x**2 + y**2 + z**2 + x*y + y*z + x*z)
-21875/4
>>> octahedron = [[(S(-1) / sqrt(2), 0, 0), (0, S(1) / sqrt(2), 0), (0, 0, S(-1) / sqrt(2)), (0, 0, S(1) / sqrt(2)), (0, S(-1) / sqrt(2), 0), (S(1) / sqrt(2), 0, 0)], [3, 4, 5], [3, 5, 1], [3, 1, 0], [3, 0, 4], [4, 0, 2], [4, 2, 5], [2, 0, 1], [5, 2, 1]]
>>> polytope_integrate(octahedron, x**2 + y**2 + z**2 + x*y + y*z + x*z)
 ___
\/ 2
-----
 20 
```

指定多项式列表：

```py
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [3, x*y + y**2, x**4], max_degree=4)
 4               2
{3: 3/2, x : 1/30, x*y + y : 1/8}
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), [1.125, x, x**2, 6.89*x**3, x*y + y**2, x**4], max_degree=4)
 2              3  689    4               2
{1.125: 9/16, x: 1/6, x : 1/12, 6.89*x : ----, x : 1/30, x*y + y : 1/8}
 2000 
```

计算所有单项式，直至最大次数：

```py
>>> polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)),max_degree=3)
 2         3                 2         3                      2         2
{0: 0, 1: 1/2, x: 1/6, x : 1/12, x : 1/20, y: 1/6, y : 1/12, y : 1/20, x*y: 1/24, x*y : 1/60, x *y: 1/60} 
```

## API 参考

```py
sympy.integrals.intpoly.polytope_integrate(poly, expr=None, *, clockwise=False, max_degree=None)
```

在 2/3-多胞体上进行多项式积分。

参数：

**poly**：输入的多边形。

**expr**：输入的多项式。

**clockwise**：对 2-多面体输入点按顺时针排序的二进制值（可选）。

**max_degree**：输入多项式的任何单项式的最大次数（可选）。

解释

此函数接受`poly`中的多胞体和`expr`中的函数（实现了单/双/三变量多项式），并返回`expr`在`poly`上的精确积分。

示例

```py
>>> from sympy.abc import x, y
>>> from sympy import Point, Polygon
>>> from sympy.integrals.intpoly import polytope_integrate
>>> polygon = Polygon(Point(0, 0), Point(0, 1), Point(1, 1), Point(1, 0))
>>> polys = [1, x, y, x*y, x**2*y, x*y**2]
>>> expr = x*y
>>> polytope_integrate(polygon, expr)
1/4
>>> polytope_integrate(polygon, polys, max_degree=3)
{1: 1, x: 1/2, y: 1/2, x*y: 1/4, x*y**2: 1/6, x**2*y: 1/6} 
```
