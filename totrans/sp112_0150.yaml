- en: scipy.integrate.OdeSolver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.OdeSolver.html#scipy.integrate.OdeSolver](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.OdeSolver.html#scipy.integrate.OdeSolver)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Base class for ODE solvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement a new solver you need to follow the guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor must accept parameters presented in the base class (listed below)
    along with any other parameters specific to a solver.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A constructor must accept arbitrary extraneous arguments `**extraneous`, but
    warn that these arguments are irrelevant using *common.warn_extraneous* function.
    Do not pass these arguments to the base class.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A solver must implement a private method *_step_impl(self)* which propagates
    a solver one step further. It must return tuple `(success, message)`, where `success`
    is a boolean indicating whether a step was successful, and `message` is a string
    containing description of a failure if a step failed or None otherwise.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A solver must implement a private method *_dense_output_impl(self)*, which returns
    a [`DenseOutput`](scipy.integrate.DenseOutput.html#scipy.integrate.DenseOutput
    "scipy.integrate.DenseOutput") object covering the last successful step.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A solver must have attributes listed below in Attributes section. Note that
    `t_old` and `step_size` are updated automatically.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Use *fun(self, t, y)* method for the system rhs evaluation, this way the number
    of function evaluations (*nfev*) will be tracked automatically.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For convenience, a base class provides *fun_single(self, t, y)* and *fun_vectorized(self,
    t, y)* for evaluating the rhs in non-vectorized and vectorized fashions respectively
    (regardless of how *fun* from the constructor is implemented). These calls don’t
    increment *nfev*.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If a solver uses a Jacobian matrix and LU decompositions, it should track the
    number of Jacobian evaluations (*njev*) and the number of LU decompositions (*nlu*).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: By convention, the function evaluations used to compute a finite difference
    approximation of the Jacobian should not be counted in *nfev*, thus use *fun_single(self,
    t, y)* or *fun_vectorized(self, t, y)* when computing a finite difference approximation
    of the Jacobian.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-hand side of the system: the time derivative of the state `y` at time
    `t`. The calling signature is `fun(t, y)`, where `t` is a scalar and `y` is an
    ndarray with `len(y) = len(y0)`. `fun` must return an array of the same shape
    as `y`. See *vectorized* for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**t0**float'
  prefs: []
  type: TYPE_NORMAL
- en: Initial time.
  prefs: []
  type: TYPE_NORMAL
- en: '**y0**array_like, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '**t_bound**float'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary time — the integration won’t continue beyond it. It also determines
    the direction of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: '**vectorized**bool'
  prefs: []
  type: TYPE_NORMAL
- en: Whether *fun* can be called in a vectorized fashion. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: If `vectorized` is False, *fun* will always be called with `y` of shape `(n,)`,
    where `n = len(y0)`.
  prefs: []
  type: TYPE_NORMAL
- en: If `vectorized` is True, *fun* may be called with `y` of shape `(n, k)`, where
    `k` is an integer. In this case, *fun* must behave such that `fun(t, y)[:, i]
    == fun(t, y[:, i])` (i.e. each column of the returned array is the time derivative
    of the state corresponding with a column of `y`).
  prefs: []
  type: TYPE_NORMAL
- en: Setting `vectorized=True` allows for faster finite difference approximation
    of the Jacobian by methods ‘Radau’ and ‘BDF’, but will result in slower execution
    for other methods. It can also result in slower overall execution for ‘Radau’
    and ‘BDF’ in some circumstances (e.g. small `len(y0)`).
  prefs: []
  type: TYPE_NORMAL
- en: '**support_complex**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether integration in a complex domain should be supported. Generally determined
    by a derived solver class capabilities. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of equations.
  prefs: []
  type: TYPE_NORMAL
- en: '**status**string'
  prefs: []
  type: TYPE_NORMAL
- en: 'Current status of the solver: ‘running’, ‘finished’ or ‘failed’.'
  prefs: []
  type: TYPE_NORMAL
- en: '**t_bound**float'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary time.
  prefs: []
  type: TYPE_NORMAL
- en: '**direction**float'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration direction: +1 or -1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**float'
  prefs: []
  type: TYPE_NORMAL
- en: Current time.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Current state.
  prefs: []
  type: TYPE_NORMAL
- en: '**t_old**float'
  prefs: []
  type: TYPE_NORMAL
- en: Previous time. None if no steps were made yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**step_size**float'
  prefs: []
  type: TYPE_NORMAL
- en: Size of the last successful step. None if no steps were made yet.
  prefs: []
  type: TYPE_NORMAL
- en: '**nfev**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of the system’s rhs evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '**njev**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of the Jacobian evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '**nlu**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of LU decompositions.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| [`dense_output`](scipy.integrate.OdeSolver.dense_output.html#scipy.integrate.OdeSolver.dense_output
    "scipy.integrate.OdeSolver.dense_output")() | Compute a local interpolant over
    the last successful step. |'
  prefs: []
  type: TYPE_TB
- en: '| [`step`](scipy.integrate.OdeSolver.step.html#scipy.integrate.OdeSolver.step
    "scipy.integrate.OdeSolver.step")() | Perform one integration step. |'
  prefs: []
  type: TYPE_TB
