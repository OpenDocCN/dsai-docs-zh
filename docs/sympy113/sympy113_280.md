# 模块的基本功能

> 原文链接：[https://docs.sympy.org/latest/modules/polys/basics.html](https://docs.sympy.org/latest/modules/polys/basics.html)

## 介绍

本教程试图概述SymPy中关于多项式的功能。所有代码示例假设：

```py
>>> from sympy import *
>>> x, y, z = symbols('x,y,z')
>>> init_printing(use_unicode=False) 
```

## 基本概念

### 多项式

给定一个符号族\((x_i)\)，或其他适当的对象，包括数字，由它们通过重复加法、减法和乘法导出的表达式称为*生成器中的多项式表达式*\(x_i\)。

根据分配律，在加法和减法之前进行乘法是可能的。因此获得的生成器的乘积称为*单项式*。它们通常以形式\(x_1^{\nu_1}x_2^{\nu_2}\cdots x_n^{\nu_n}\)书写，其中指数\(\nu_i\)为非负整数。通常便于简写为\(x^\nu\)，其中\(x = (x_1, x_2, \ldots, x_n)\)表示生成器的族，\(\nu = (\nu_1, \nu_2, \ldots, \nu_n)\)表示指数的族。

当合并所有具有相同指数的单项式时，多项式表达式变为乘积的和\(c_\nu x^\nu\)，称为多项式的*项*，其中*系数*\(c_\nu\)为整数。如果某些\(x_i\)是明确的数字，则它们被合并到系数中，而不视为生成器。这些系数通常是有理数、实数或复数。一些符号数，例如`pi`，可以是系数或生成器。

由不同单项式之和构成的多项式表达式可以唯一由其系数族\((c_\nu)\)确定。这样的表达式通常被称为*多项式*，尽管更准确地说，该名称是指一旦生成器给定后的系数族。SymPy默认将多项式实现为以单项式为键、系数为值的字典。另一种实现方式是系数的嵌套列表。

在生成器\(x_i\)中所有整数系数的多项式集合是一个*环*，即其元素的和、差和积再次是相同生成器的多项式。这个环记作\(\mathbb{Z}[x_1, x_2, \ldots, x_n]\)，或\(\mathbb{Z}[(x_i)]\)，并称为*具有整数系数的生成器*\(x_i\)的多项式环。

更一般地，多项式的系数可以是任何可交换环\(A\)的元素，相应的多项式环通常记作\(A[x_1, x_2, \dots, x_n]\)。环\(A\)也可以是一个多项式环。在SymPy中，系数环称为多项式环的`domain`，可以作为关键字参数给出。默认情况下，它由多项式参数的系数确定。

多项式表达式可以通过方法[`sympy.core.expr.Expr.as_poly`](../core.html#sympy.core.expr.Expr.as_poly "sympy.core.expr.Expr.as_poly")转换为多项式：

```py
>>> e = (x + y)*(y - 2*z)
>>> e.as_poly()
Poly(x*y - 2*x*z + y**2 - 2*y*z, x, y, z, domain='ZZ') 
```

如果多项式表达式包含非整数的数，则它们被视为系数，并相应地扩展系数环。特别是，除以整数导致有理系数：

```py
>>> e = (3*x/2 + y)*(z - 1)
>>> e.as_poly()
Poly(3/2*x*z - 3/2*x + y*z - y, x, y, z, domain='QQ') 
```

符号数被认为是生成器，除非明确排除，否则它们被附加到系数环中：

```py
>>> e = (x + 2*pi)*y
>>> e.as_poly()
Poly(x*y + 2*y*pi, x, y, pi, domain='ZZ')
>>> e.as_poly(x, y)
Poly(x*y + 2*pi*y, x, y, domain='ZZ[pi]') 
```

或者，可以通过关键字参数指定系数域：

```py
>>> e = (x + 2*pi)*y
>>> e.as_poly(domain=ZZ[pi])
Poly(x*y + 2*pi*y, x, y, domain='ZZ[pi]') 
```

注意，环 \(\mathbb{Z}[\pi][x, y]\)，即以 \(\mathbb{Z}[\pi]\) 为系数的 \(x\) 和 \(y\) 的多项式环，在数学上等同于 \(\mathbb{Z}[\pi, x, y]\)，只是它们的实现有所不同。

如果表达式中包含生成器的函数，除了它们的正整数幂之外，这些函数被解释为新的生成器：

```py
>>> e = x*sin(y) - y
>>> e.as_poly()
Poly(x*(sin(y)) - y, x, y, sin(y), domain='ZZ') 
```

由于 \(y\) 和 \(\sin(y)\) 在代数上是独立的，它们可以作为多项式中的生成器出现。然而，*多项式表达式不得包含生成器的负幂*：

```py
>>> e = x - 1/x
>>> e.as_poly()
Poly(x - (1/x), x, 1/x, domain='ZZ') 
```

重要的是要意识到生成器 \(x\) 和 \(1/x = x^{-1}\) 被视为代数独立的变量。特别地，它们的乘积不等于 1。因此*应避免分母中的生成器，即使它们在当前实现中没有错误*。这种行为是不希望的，可能在将来会改变。类似的问题也会出现在生成器的有理幂中。例如，\(x\) 和 \(\sqrt x = x^{1/2}\) 并不被识别为代数相关。

如果表达式中含有代数数，则可以通过设置关键字`extension`将它们附加到系数环中：

```py
>>> e = x + sqrt(2)
>>> e.as_poly()
Poly(x + (sqrt(2)), x, sqrt(2), domain='ZZ')
>>> e.as_poly(extension=True)
Poly(x + sqrt(2), x, domain='QQ<sqrt(2)>') 
```

使用默认设置`extension=False`，\(x\) 和 \(\sqrt 2\) 都被错误地视为代数独立的变量。在扩展域 \(\mathbb{Q}(\sqrt 2)\) 中，平方根正确地被视为代数数。尽管当前的实现没有强制要求，但涉及代数数时建议设置`extension=True`。

### 可除性

第四个有理运算，即除法或倒数乘法，通常在环中不可能。如果 \(a\) 和 \(b\) 是环 \(A\) 的两个元素，则可能存在第三个元素 \(q\) 使得 \(a = bq\)。事实上，可能存在几个这样的元素。

如果还有 \(a = bq'\)，其中 \(q'\) 在 \(A\) 中，则 \(b(q - q') = 0\)。因此要么 \(b\) 要么 \(q - q'\) 是零，或者它们都是*零因子*，乘积为零的非零元素。

#### 整环

没有零因子的交换环称为*整环*。大多数常见的环，如整数环、域以及整环上的多项式环，都是整环。

现在假设\(A\)是一个整环，并考虑其非零元素构成的集合\(P\)，它在乘法下封闭。如果\(a\)和\(b\)属于\(P\)，并且存在\(P\)中的元素\(q\)使得\(a = bq\)，那么\(q\)是唯一的，并称为\(a\)除以\(b\)的*商*，记为\(a/b\)。此外，有如下关系：

+   \(a\)是\(b\)的*倍数*，

+   \(b\)是\(a\)的*除数*。

+   \(a\)是\(b\)的*倍数*，

+   \(b\)是\(a\)的*因子*。

元素\(a\)属于\(P\)，如果且仅如果它在\(A\)中是*可逆*的，即存在逆元\(a^{-1} = 1/a\)。这样的元素称为*单位*。整数环的单位包括\(1\)和\(-1\)。在域上的多项式环中，可逆元素为非零常数多项式。

如果\(P\)中的两个元素\(a\)和\(b\)相互整除，则商\(a/b\)可逆，其逆元为\(b/a\)，或等价地，\(b = ua\)，其中\(u\)是单位。这样的元素称为*关联*或*同伴*。整数\(n\)的同伴是\(n\)和\(-n\)。在域上的多项式环中，多项式的同伴是它的常数倍数。

每个\(P\)中的元素都可被它的关联元素和单位整除。如果一个元素是*不可约*的，那么它没有其他除数且不是单位。整数环中的不可约元素包括素数\(p\)及其负数\(-p\)。在域中，每个非零元素都是可逆的，因此没有不可约元素。

#### 阶乘整环

在整数环中，每个非零元素都可以表示为不可约元素的乘积，可选地加上单位\(\pm 1\)。此外，任意两个这样的乘积具有相同数量的不可约因子，它们在适当顺序下相互关联。具有此特性的整环称为*阶乘*或*唯一分解整环*。除整数环外，所有域上的多项式环都是阶乘整环，更一般地说，所有阶乘整环上的多项式环也是阶乘整环。域因其只有单位而显然是阶乘的。阶乘整环中的不可约元素通常称为*素数*。

整数族仅有有限个公共因数，并且其中最大的因数可整除它们中的所有元素。更一般地，给定整环中的非零元素族\((a_i)\)，元素\(d\)称为该族的*最大公因数*（简称*gcd*），如果它是所有公因数的倍数。最大公因数一般并非唯一；所有它的同伴都具有相同的性质。如果没有歧义，用\(d = \gcd(a_1,\ldots,a_n)\)表示。一个族的*最小公倍数*（简称*lcm*）\(m\)定义为所有公倍数中的最小数，记为\(m = \operatorname{lcm}(a_1,\dots,a_n)\)。  

在因子环中，最大公约数总是存在的。至少在原理上，可以通过将每个成员因式分解为素数幂的乘积和可选单位，并对每个素数取出现在因式分解中的最小幂来找到它们。这些素数幂的乘积就是最大公约数。最小公倍数可以从相同的因式分解中获得，即为每个素数取最大幂的乘积。

#### 欧几里德整环

一个实用的计算最大公约数的算法可以在*欧几里德整环*中实现。它们是可以赋予域内每个非零元素一个非负整数的整环，并具有以下属性：

> 如果 \(a\) 和 \(b\) 非零，则存在 \(q\) 和 \(r\) 满足*除法标识*
> 
> > \(a = qb + r\)
> > 
> 这样要么 \(r = 0\) 要么 \(w(r) < w(b)\)。

整数环和所有域上的一元多项式环是具有 \(w(a) = |a|\) 或 \(w(a) = \deg(a)\) 的欧几里德整环。

整数的除法标识在Python中作为内置函数`divmod`实现，也可以应用于SymPy整数：

```py
>>> divmod(Integer(53), Integer(7))
(7, 4) 
```

对于多项式，SymPy中的除法标识由函数[`div()`](reference.html#sympy.polys.polytools.div "sympy.polys.polytools.div")给出：

```py
>>> f = 5*x**2 + 10*x + 3
>>> g = 2*x + 2

>>> q, r = div(f, g, domain='QQ')
>>> q
5*x   5
--- + -
 2    2
>>> r
-2
>>> (q*g + r).expand()
 2
5*x  + 10*x + 3 
```

可以使用除法标识来确定欧几里德整环中元素的可除性。如果在除法标识中 \(r = 0\)，则 \(a\) 可以被 \(b\) 整除。反之，如果 \(a = cb\) 对于某些元素 \(c\)，则 \((c - q)b = r\)。由此可知，如果 \(w\) 具有附加属性，则 \(c = q\) 并且 \(r = 0\)。

> 如果 \(a\) 和 \(b\) 非零，则 \(w(ab) \ge w(b)\)。

这些给定的函数满足这一点。（并且总是可以通过重新定义 \(w(a)\) 为 \(w(xa)\) 的值中的最小值来满足。）

除法标识的主要应用是通过[欧几里德算法](https://en.wikipedia.org/wiki/Euclidean_algorithm)高效地计算欧几里德整环中两个元素的最大公约数。它适用于多个元素的最大公约数可以通过迭代获得。

计算SymPy整数最大公约数的函数目前是[`igcd()`](../core.html#sympy.core.intfunc.igcd "sympy.core.intfunc.igcd")：

```py
>>> igcd(2, 4)
2
>>> igcd(5, 10, 15)
5 
```

对于域上的一元多项式，该函数通常被称为[`gcd()`](reference.html#sympy.polys.polytools.gcd "sympy.polys.polytools.gcd")，并且返回的多项式是首一的：

```py
>>> f = 4*x**2 - 1
>>> g = 8*x**3 + 1
>>> gcd(f, g, domain=QQ)
x + 1/2 
```

#### 多项式的可除性

一元多项式环 \(A = \mathbb{Z}[x]\) 不是欧几里德但仍然是因子的。要看到这一点，请考虑\(A\)中的可整除性。

设\(f\)和\(g\)是\(A\)中的两个非零多项式。如果\(f\)在\(A\)中被\(g\)整除，则在有理系数多项式环\(B = \mathbb{Q}[x]\)中也是如此。由于\(B\)是欧几里得环，这可以通过除法恒等式确定。

假设反过来，对于某些多项式\(h\)在\(B\)中，\(f = gh\)。那么\(f\)在\(A\)中被\(g\)整除当且仅当\(h\)的系数是整数。要确定这是否成立，需要考虑系数的可整除性。

对于\(A\)中的多项式\(f\)，设\(c\)是其系数的最大公因子。那么\(f\)在\(A\)中被常数多项式\(c\)整除，且商\(f/c = p\)是其系数是没有单位以外的整数的多项式。这样的多项式称为*原始*。有理系数的多项式也可以写为\(f = cp\)，其中\(c\)是有理数，\(p\)是原始多项式。常数\(c\)称为\(f\)的*内容*，\(p\)是其*原始部分*。这些组成部分可以通过方法[`sympy.core.expr.Expr.as_content_primitive`](../core.html#sympy.core.expr.Expr.as_content_primitive "sympy.core.expr.Expr.as_content_primitive")找到：

```py
>>> f = 6*x**2 - 3*x + 9
>>> c, p = f.as_content_primitive()
>>> c, p
 2
(3, 2*x  - x + 3)
>>> f = x**2/3 - x/2 + 1
>>> c, p = f.as_content_primitive()
>>> c, p
 2
(1/6, 2*x  - 3*x + 6) 
```

设\(f\)和\(f'\)是具有内容\(c\)和\(c'\)以及原始部分\(p\)和\(p'\)的多项式。那么\(ff' = (cc')(pp')\)，其中乘积\(pp'\)由[Gauss引理](https://en.wikipedia.org/wiki/Gauss%27s_lemma_(polynomial))是原始的。由此得出

> 多项式乘积的内容是它们内容的乘积，而乘积的原始部分是原始部分的乘积。

回到环\(\mathbb{Z}[x]\)中的整除性，假设\(f\)和\(g\)是具有整数系数的两个多项式，使得在\(\mathbb{Q}[x]\)中的除法恒等式产生多项式\(h\)的等式\(f = gh\)。则\(f\)的内容等于\(g\)的内容乘以\(h\)的内容。由于\(h\)具有整数系数当且仅当其内容是整数，我们得到以下判据：

> \(f\)在环\(\mathbb{Z}[x]\)中被\(g\)整除当且仅当
> 
> 1.  \(f\)在\(\mathbb{Q}[x]\)中被\(g\)整除，并且
> 1.  
> 1.  \(f\)的内容在\(\mathbb{Z}\)中能被\(g\)的内容整除。

如果\(f = cp\)在\(\mathbb{Z}[x]\)中是不可约的，则\(c\)或\(p\)必须是单位。如果\(p\)不是单位，则它在\(\mathbb{Q}[x]\)中也必须是不可约的。因为如果它是两个多项式的乘积，它也是它们的原始部分的乘积，其中一个必须是单位。因此在\(\mathbb{Z}[x]\)中有两种不可约元素：

1.  \(\mathbb{Z}\)的素数，以及

1.  在\(\mathbb{Q}[x]\)中是不可约的原始多项式。

由此可知，\(\mathbb{Z}[x]\) 中的每个多项式都是不可约元素的乘积。只需分别对其内容和原始部分进行因式分解即可。这些乘积基本上是唯一的；因此 \(\mathbb{Z}[x]\) 也是因子的。

另一个重要的结论是，在 \(\mathbb{Z}[x]\) 中两个多项式的最大公约数可以通过将它们的内容和原始部分分别应用于欧几里得域 \(\mathbb{Z}\) 和 \(\mathbb{Q}[x]\) 中的欧几里得算法来有效地找到。这也在 SymPy 中实现了：

```py
>>> f = 4*x**2 - 1
>>> g = 8*x**3 + 1
>>> gcd(f, g)
2*x + 1
>>> gcd(6*f, 3*g)
6*x + 3 
```

## 基本功能

这些函数提供了处理 SymPy 表达式形式的多项式的不同算法，如符号、求和等。

### 除法

函数 [`div()`](reference.html#sympy.polys.polytools.div "sympy.polys.polytools.div") 提供了带余除法。也就是说，对于多项式 `f` 和 `g`，它计算出 `q` 和 `r`，使得 \(f = g \cdot q + r\) 且 \(\deg(r) < \deg(q)\)。对于系数在一个域中（例如有理数）的一元多项式，这种方式唯一地定义了 `q` 和 `r`：

```py
>>> f = 5*x**2 + 10*x + 3
>>> g = 2*x + 2

>>> q, r = div(f, g, domain='QQ')
>>> q
5*x   5
--- + -
 2    2
>>> r
-2
>>> (q*g + r).expand()
 2
5*x  + 10*x + 3 
```

正如你所见，`q` 有一个非整数系数。如果你只想在整数系数的多项式环中进行除法，你可以指定一个额外的参数：

```py
>>> q, r = div(f, g, domain='ZZ')
>>> q
0
>>> r
 2
5*x  + 10*x + 3 
```

但要注意，这个环不再是欧几里得环，余数的次数不一定比 `f` 的次数小。因为 2 不能整除 5，所以 \(2 x\) 不能整除 \(5 x^2\)，即使次数较小。但：

```py
>>> g = 5*x + 1

>>> q, r = div(f, g, domain='ZZ')
>>> q
x
>>> r
9*x + 3
>>> (q*g + r).expand()
 2
5*x  + 10*x + 3 
```

这也适用于多变量多项式：

```py
>>> f = x*y + y*z
>>> g = 3*x + 3*z

>>> q, r = div(f, g, domain='QQ')
>>> q
y
-
3
>>> r
0 
```

在最后的示例中，所有三个变量 `x`、`y` 和 `z` 都被假定为多项式的变量。但如果你有一些无关的常数作为系数，你可以显式地指定这些变量：

```py
>>> a, b, c = symbols('a,b,c')
>>> f = a*x**2 + b*x + c
>>> g = 3*x + 2
>>> q, r = div(f, g, domain='QQ')
>>> q
a*x   2*a   b
--- - --- + -
 3     9    3

>>> r
4*a   2*b
--- - --- + c
 9     3 
```

### 最大公约数和最小公倍数

除法时，还涉及最大公约数和最小公倍数的计算。

当多项式具有整数系数时，考虑到内容的最大公约数：

```py
>>> f = (12*x + 12)*x
>>> g = 16*x**2
>>> gcd(f, g)
4*x 
```

但是如果多项式具有有理系数，则返回的多项式是首一的：

```py
>>> f = 3*x**2/2
>>> g = 9*x/4
>>> gcd(f, g)
x 
```

它也适用于多变量。在这种情况下，默认情况下，变量按字母顺序排序，这会影响到主导系数：

```py
>>> f = x*y/2 + y**2
>>> g = 3*x + 6*y

>>> gcd(f, g)
x + 2*y 
```

最小公倍数与最大公约数相关联，可以用其中一个来计算另一个：

```py
>>> f = x*y**2 + x**2*y
>>> g = x**2*y**2
>>> gcd(f, g)
x*y
>>> lcm(f, g)
 3  2    2  3
x *y  + x *y
>>> (f*g).expand()
 4  3    3  4
x *y  + x *y
>>> (gcd(f, g, x, y)*lcm(f, g, x, y)).expand()
 4  3    3  4
x *y  + x *y 
```

### 无平方因式分解

单变量多项式的无平方因式分解是所有一次、二次等因子的乘积（不一定是不可约的）：

```py
>>> f = 2*x**2 + 5*x**3 + 4*x**4 + x**5

>>> sqf_list(f)
 2
(1, [(x + 2, 1), (x  + x, 2)])

>>> sqf(f)
 2
 / 2    \
(x + 2)*\x  + x/ 
```

### 因式分解

这个函数提供了有理系数的一元和多元多项式的因式分解：

```py
>>> factor(x**4/2 + 5*x**3/12 - x**2/3)
 2
x *(2*x - 1)*(3*x + 4)
----------------------
 12

>>> factor(x**2 + 4*x*y + 4*y**2)
 2
(x + 2*y) 
```

### Groebner 基

Buchberger 算法已经实现，支持各种单项式排序：

```py
>>> groebner([x**2 + 1, y**4*x + x**3], x, y, order='lex')
 /[ 2       4    ]                            \
GroebnerBasis\[x  + 1, y  - 1], x, y, domain=ZZ, order=lex/

>>> groebner([x**2 + 1, y**4*x + x**3, x*y*z**3], x, y, z, order='grevlex')
 /[ 4       3   2    ]                                   \
GroebnerBasis\[y  - 1, z , x  + 1], x, y, z, domain=ZZ, order=grevlex/ 
```

### 解方程

我们有（不完整的）方法来找到多项式的复数甚至符号根，并解一些多项式方程组：

```py
>>> from sympy import roots, solve_poly_system

>>> solve(x**3 + 2*x + 3, x)
 ____          ____
 1   \/ 11 *I  1   \/ 11 *I
[-1, - - --------, - + --------]
 2      2      2      2

>>> p = Symbol('p')
>>> q = Symbol('q')

>>> solve(x**2 + p*x + q, x)
 __________           __________
 /  2                 /  2
 p   \/  p  - 4*q     p   \/  p  - 4*q
[- - - -------------, - - + -------------]
 2         2          2         2

>>> solve_poly_system([y - x, x - 5], x, y)
[(5, 5)]

>>> solve_poly_system([y**2 - x**3 + 1, y*x], x, y)
 ___                 ___
 1   \/ 3 *I         1   \/ 3 *I
[(0, -I), (0, I), (1, 0), (- - - -------, 0), (- - + -------, 0)]
 2      2            2      2 
```
