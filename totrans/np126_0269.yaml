- en: Universal functions (ufunc)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/ufuncs.html](https://numpy.org/doc/1.26/reference/ufuncs.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Universal functions (ufunc) basics](../user/basics.ufuncs.html#ufuncs-basics)'
  prefs: []
  type: TYPE_NORMAL
- en: A universal function (or [ufunc](../glossary.html#term-ufunc) for short) is
    a function that operates on [`ndarrays`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") in an element-by-element fashion, supporting [array broadcasting](../user/basics.ufuncs.html#ufuncs-broadcasting),
    [type casting](../user/basics.ufuncs.html#ufuncs-casting), and several other standard
    features. That is, a ufunc is a “[vectorized](../glossary.html#term-vectorization)”
    wrapper for a function that takes a fixed number of specific inputs and produces
    a fixed number of specific outputs. For detailed information on universal functions,
    see [Universal functions (ufunc) basics](../user/basics.ufuncs.html#ufuncs-basics).
  prefs: []
  type: TYPE_NORMAL
- en: '[`ufunc`](generated/numpy.ufunc.html#numpy.ufunc "numpy.ufunc")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`numpy.ufunc`](generated/numpy.ufunc.html#numpy.ufunc "numpy.ufunc")() |
    Functions that operate element by element on whole arrays. |'
  prefs: []
  type: TYPE_TB
- en: '### Optional keyword arguments'
  prefs: []
  type: TYPE_NORMAL
- en: All ufuncs take optional keyword arguments. Most of these represent advanced
    usage and will not typically be used.
  prefs: []
  type: TYPE_NORMAL
- en: '*out*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: The first output can be provided as either a positional or a keyword parameter.
    Keyword ‘out’ arguments are incompatible with positional ones.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.
  prefs: []
  type: TYPE_NORMAL
- en: The ‘out’ keyword argument is expected to be a tuple with one entry per output
    (which can be None for arrays to be allocated by the ufunc). For ufuncs with a
    single output, passing a single array (instead of a tuple holding a single array)
    is also valid.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a single array in the ‘out’ keyword argument to a ufunc with multiple
    outputs is deprecated, and will raise a warning in numpy 1.10, and an error in
    a future release.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘out’ is None (the default), a uninitialized return array is created. The
    output array is then filled with the results of the ufunc in the places that the
    broadcast ‘where’ is True. If ‘where’ is the scalar True (the default), then this
    corresponds to the entire output being filled. Note that outputs not explicitly
    filled are left with their uninitialized values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap are defined
    to be the same as for equivalent operations where there is no memory overlap.
    Operations affected make temporary copies as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result in needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example, `np.add(a, b, out=a)` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: '*where*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a boolean array which is broadcast together with the operands. Values
    of True indicate to calculate the ufunc at that position, values of False indicate
    to leave the value in the output alone. This argument cannot be used for generalized
    ufuncs as those take non-scalar input.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if an uninitialized return array is created, values of False will
    leave those values **uninitialized**.
  prefs: []
  type: TYPE_NORMAL
- en: '*axes*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A list of tuples with indices of axes a generalized ufunc should operate on.
    For instance, for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. For simplicity, for generalized ufuncs that
    operate on 1-dimensional arrays (vectors), a single integer is accepted instead
    of a single-element tuple, and for generalized ufuncs for which all outputs are
    scalars, the output tuples can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '*axis*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A single axis over which a generalized ufunc should operate. This is a short-cut
    for ufuncs that operate over a single, shared core dimension, equivalent to passing
    in `axes` with entries of `(axis,)` for each single-core-dimension argument and
    `()` for all others. For instance, for a signature `(i),(i)->()`, it is equivalent
    to passing in `axes=[(axis,), (axis,), ()]`.
  prefs: []
  type: TYPE_NORMAL
- en: '*keepdims*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: If this is set to *True*, axes which are reduced over will be left in the result
    as a dimension with size one, so that the result will broadcast correctly against
    the inputs. This option can only be used for generalized ufuncs that operate on
    inputs that all have the same number of core dimensions and with outputs that
    have no core dimensions, i.e., with signatures like `(i),(i)->()` or `(m,m)->()`.
    If used, the location of the dimensions in the output can be controlled with `axes`
    and `axis`.
  prefs: []
  type: TYPE_NORMAL
- en: '*casting*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: May be ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, or ‘unsafe’. See [`can_cast`](generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") for explanations of the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Provides a policy for what kind of casting is permitted. For compatibility with
    previous versions of NumPy, this defaults to ‘unsafe’ for numpy < 1.7. In numpy
    1.7 a transition to ‘same_kind’ was begun where ufuncs produce a DeprecationWarning
    for calls which are allowed under the ‘unsafe’ rules, but not under the ‘same_kind’
    rules. From numpy 1.10 and onwards, the default is ‘same_kind’.
  prefs: []
  type: TYPE_NORMAL
- en: '*order*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the calculation iteration order/memory layout of the output array.
    Defaults to ‘K’. ‘C’ means the output should be C-contiguous, ‘F’ means F-contiguous,
    ‘A’ means F-contiguous if the inputs are F-contiguous and not also not C-contiguous,
    C-contiguous otherwise, and ‘K’ means to match the element ordering of the inputs
    as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*dtype*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Overrides the DType of the output arrays the same way as the *signature*. This
    should ensure a matching precision of the calculation. The exact calculation DTypes
    chosen may depend on the ufunc and the inputs may be cast to this DType to perform
    the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '*subok*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to true. If set to false, the output will always be a strict array,
    not a subtype.
  prefs: []
  type: TYPE_NORMAL
- en: '*signature*'
  prefs: []
  type: TYPE_NORMAL
- en: Either a Dtype, a tuple of DTypes, or a special signature string indicating
    the input and output types of a ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: This argument allows the user to specify exact DTypes to be used for the calculation.
    Casting will be used as necessary. The actual DType of the input arrays is not
    considered unless `signature` is `None` for that array.
  prefs: []
  type: TYPE_NORMAL
- en: When all DTypes are fixed, a specific loop is chosen or an error raised if no
    matching loop exists. If some DTypes are not specified and left `None`, the behaviour
    may depend on the ufunc. At this time, a list of available signatures is provided
    by the **types** attribute of the ufunc. (This list may be missing DTypes not
    defined by NumPy.)
  prefs: []
  type: TYPE_NORMAL
- en: The `signature` only specifies the DType class/type. For example, it can specify
    that the operation should be `datetime64` or `float64` operation. It does not
    specify the `datetime64` time-unit or the `float64` byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: For backwards compatibility this argument can also be provided as *sig*, although
    the long form is preferred. Note that this should not be confused with the generalized
    ufunc [signature](c-api/generalized-ufuncs.html#details-of-signature) that is
    stored in the **signature** attribute of the of the ufunc object.
  prefs: []
  type: TYPE_NORMAL
- en: '*extobj*'
  prefs: []
  type: TYPE_NORMAL
- en: A list of length 3 specifying the ufunc buffer-size, the error mode integer,
    and the error call-back function. Normally, these values are looked up in a thread-specific
    dictionary. Passing them here circumvents that look up and uses the low-level
    specification provided for the error mode. This may be useful, for example, as
    an optimization for calculations requiring many ufunc calls on small arrays in
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some informational attributes that universal functions possess. None
    of the attributes can be set.
  prefs: []
  type: TYPE_NORMAL
- en: '| **__doc__** | A docstring for each ufunc. The first part of the docstring
    is dynamically generated from the number of outputs, the name, and the number
    of inputs. The second part of the docstring is provided at creation time and stored
    with the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| **__name__** | The name of the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nin`](generated/numpy.ufunc.nin.html#numpy.ufunc.nin "numpy.ufunc.nin")
    | The number of inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nout`](generated/numpy.ufunc.nout.html#numpy.ufunc.nout "numpy.ufunc.nout")
    | The number of outputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nargs`](generated/numpy.ufunc.nargs.html#numpy.ufunc.nargs "numpy.ufunc.nargs")
    | The number of arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.ntypes`](generated/numpy.ufunc.ntypes.html#numpy.ufunc.ntypes "numpy.ufunc.ntypes")
    | The number of types. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.types`](generated/numpy.ufunc.types.html#numpy.ufunc.types "numpy.ufunc.types")
    | Returns a list with types grouped input->output. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.identity`](generated/numpy.ufunc.identity.html#numpy.ufunc.identity
    "numpy.ufunc.identity") | The identity value. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.signature`](generated/numpy.ufunc.signature.html#numpy.ufunc.signature
    "numpy.ufunc.signature") | Definition of the core elements a generalized ufunc
    operates on. |'
  prefs: []
  type: TYPE_TB
- en: '### Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`ufunc.reduce`](generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce "numpy.ufunc.reduce")(array[, axis, dtype, out, ...])
    | Reduces [`array`](generated/numpy.array.html#numpy.array "numpy.array")''s dimension
    by one, by applying ufunc along one axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.accumulate`](generated/numpy.ufunc.accumulate.html#numpy.ufunc.accumulate
    "numpy.ufunc.accumulate")(array[, axis, dtype, out]) | Accumulate the result of
    applying the operator to all elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.reduceat`](generated/numpy.ufunc.reduceat.html#numpy.ufunc.reduceat
    "numpy.ufunc.reduceat")(array, indices[, axis, ...]) | Performs a (local) reduce
    with specified slices over a single axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.outer`](generated/numpy.ufunc.outer.html#numpy.ufunc.outer "numpy.ufunc.outer")(A, B, /, **kwargs)
    | Apply the ufunc *op* to all pairs (a, b) with a in *A* and b in *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.at`](generated/numpy.ufunc.at.html#numpy.ufunc.at "numpy.ufunc.at")(a, indices[, b])
    | Performs unbuffered in place operation on operand ''a'' for elements specified
    by ''indices''. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: A reduce-like operation on an array with a data-type that has a range “too small”
    to handle the result will silently wrap. One should use [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") to increase the size of the data-type over which reduction takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Available ufuncs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are currently more than 60 universal functions defined in [`numpy`](index.html#module-numpy
    "numpy") on one or more types, covering a wide variety of operations. Some of
    these ufuncs are called automatically on arrays when the relevant infix notation
    is used (*e.g.*, [`add(a, b)`](generated/numpy.add.html#numpy.add "numpy.add")
    is called internally when `a + b` is written and *a* or *b* is an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")). Nevertheless, you may still want to use the ufunc call in order
    to use the optional output argument(s) to place the output(s) in an object (or
    objects) of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each ufunc operates element-by-element. Therefore, each scalar ufunc
    will be described as if acting on a set of scalar inputs to return a set of scalar
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The ufunc still returns its output(s) even if you use the optional output argument(s).
  prefs: []
  type: TYPE_NORMAL
- en: Math operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`add`](generated/numpy.add.html#numpy.add "numpy.add")(x1, x2, /[, out, where, casting, order, ...])
    | Add arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`subtract`](generated/numpy.subtract.html#numpy.subtract "numpy.subtract")(x1, x2, /[, out, where, casting, ...])
    | Subtract arguments, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`multiply`](generated/numpy.multiply.html#numpy.multiply "numpy.multiply")(x1, x2, /[, out, where, casting, ...])
    | Multiply arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul")(x1, x2, /[, out, casting, order, ...])
    | Matrix product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divide`](generated/numpy.divide.html#numpy.divide "numpy.divide")(x1, x2, /[, out, where, casting, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp`](generated/numpy.logaddexp.html#numpy.logaddexp "numpy.logaddexp")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp2`](generated/numpy.logaddexp2.html#numpy.logaddexp2 "numpy.logaddexp2")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs in base-2. |'
  prefs: []
  type: TYPE_TB
- en: '| [`true_divide`](generated/numpy.true_divide.html#numpy.true_divide "numpy.true_divide")(x1, x2, /[, out, where, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor_divide`](generated/numpy.floor_divide.html#numpy.floor_divide "numpy.floor_divide")(x1, x2, /[, out, where, ...])
    | Return the largest integer smaller or equal to the division of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`negative`](generated/numpy.negative.html#numpy.negative "numpy.negative")(x, /[, out, where, casting, order, ...])
    | Numerical negative, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`positive`](generated/numpy.positive.html#numpy.positive "numpy.positive")(x, /[, out, where, casting, order, ...])
    | Numerical positive, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`power`](generated/numpy.power.html#numpy.power "numpy.power")(x1, x2, /[, out, where, casting, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`float_power`](generated/numpy.float_power.html#numpy.float_power "numpy.float_power")(x1, x2, /[, out, where, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`remainder`](generated/numpy.remainder.html#numpy.remainder "numpy.remainder")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`mod`](generated/numpy.mod.html#numpy.mod "numpy.mod")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divmod`](generated/numpy.divmod.html#numpy.divmod "numpy.divmod")(x1, x2[, out1, out2], / [[, out, ...])
    | Return element-wise quotient and remainder simultaneously. |'
  prefs: []
  type: TYPE_TB
- en: '| [`absolute`](generated/numpy.absolute.html#numpy.absolute "numpy.absolute")(x, /[, out, where, casting, order, ...])
    | Calculate the absolute value element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rint`](generated/numpy.rint.html#numpy.rint "numpy.rint")(x, /[, out, where, casting, order, ...])
    | Round elements of the array to the nearest integer. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sign`](generated/numpy.sign.html#numpy.sign "numpy.sign")(x, /[, out, where, casting, order, ...])
    | Returns an element-wise indication of the sign of a number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`heaviside`](generated/numpy.heaviside.html#numpy.heaviside "numpy.heaviside")(x1, x2, /[, out, where, casting, ...])
    | Compute the Heaviside step function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conj`](generated/numpy.conj.html#numpy.conj "numpy.conj")(x, /[, out, where, casting, order, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conjugate`](generated/numpy.conjugate.html#numpy.conjugate "numpy.conjugate")(x, /[, out, where, casting, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp`](generated/numpy.exp.html#numpy.exp "numpy.exp")(x, /[, out, where, casting, order, ...])
    | Calculate the exponential of all elements in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp2`](generated/numpy.exp2.html#numpy.exp2 "numpy.exp2")(x, /[, out, where, casting, order, ...])
    | Calculate *2**p* for all *p* in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log`](generated/numpy.log.html#numpy.log "numpy.log")(x, /[, out, where, casting, order, ...])
    | Natural logarithm, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log2`](generated/numpy.log2.html#numpy.log2 "numpy.log2")(x, /[, out, where, casting, order, ...])
    | Base-2 logarithm of *x*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log10`](generated/numpy.log10.html#numpy.log10 "numpy.log10")(x, /[, out, where, casting, order, ...])
    | Return the base 10 logarithm of the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`expm1`](generated/numpy.expm1.html#numpy.expm1 "numpy.expm1")(x, /[, out, where, casting, order, ...])
    | Calculate `exp(x) - 1` for all elements in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log1p`](generated/numpy.log1p.html#numpy.log1p "numpy.log1p")(x, /[, out, where, casting, order, ...])
    | Return the natural logarithm of one plus the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sqrt`](generated/numpy.sqrt.html#numpy.sqrt "numpy.sqrt")(x, /[, out, where, casting, order, ...])
    | Return the non-negative square-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`square`](generated/numpy.square.html#numpy.square "numpy.square")(x, /[, out, where, casting, order, ...])
    | Return the element-wise square of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cbrt`](generated/numpy.cbrt.html#numpy.cbrt "numpy.cbrt")(x, /[, out, where, casting, order, ...])
    | Return the cube-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`reciprocal`](generated/numpy.reciprocal.html#numpy.reciprocal "numpy.reciprocal")(x, /[, out, where, casting, ...])
    | Return the reciprocal of the argument, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`gcd`](generated/numpy.gcd.html#numpy.gcd "numpy.gcd")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the greatest common divisor of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`lcm`](generated/numpy.lcm.html#numpy.lcm "numpy.lcm")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the lowest common multiple of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The optional output arguments can be used to help you save memory for large
    calculations. If your arrays are large, complicated expressions can take longer
    than absolutely necessary due to the creation and (later) destruction of temporary
    calculation spaces. For example, the expression `G = A * B + C` is equivalent
    to `T1 = A * B; G = T1 + C; del T1`. It will be more quickly executed as `G =
    A * B; add(G, C, G)` which is the same as `G = A * B; G += C`.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All trigonometric functions use radians when an angle is called for. The ratio
    of degrees to radians is \(180^{\circ}/\pi.\)
  prefs: []
  type: TYPE_NORMAL
- en: '| [`sin`](generated/numpy.sin.html#numpy.sin "numpy.sin")(x, /[, out, where, casting, order, ...])
    | Trigonometric sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cos`](generated/numpy.cos.html#numpy.cos "numpy.cos")(x, /[, out, where, casting, order, ...])
    | Cosine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tan`](generated/numpy.tan.html#numpy.tan "numpy.tan")(x, /[, out, where, casting, order, ...])
    | Compute tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsin`](generated/numpy.arcsin.html#numpy.arcsin "numpy.arcsin")(x, /[, out, where, casting, order, ...])
    | Inverse sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccos`](generated/numpy.arccos.html#numpy.arccos "numpy.arccos")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan`](generated/numpy.arctan.html#numpy.arctan "numpy.arctan")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse tangent, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan2`](generated/numpy.arctan2.html#numpy.arctan2 "numpy.arctan2")(x1, x2, /[, out, where, casting, ...])
    | Element-wise arc tangent of `x1/x2` choosing the quadrant correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| [`hypot`](generated/numpy.hypot.html#numpy.hypot "numpy.hypot")(x1, x2, /[, out, where, casting, ...])
    | Given the "legs" of a right triangle, return its hypotenuse. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sinh`](generated/numpy.sinh.html#numpy.sinh "numpy.sinh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cosh`](generated/numpy.cosh.html#numpy.cosh "numpy.cosh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tanh`](generated/numpy.tanh.html#numpy.tanh "numpy.tanh")(x, /[, out, where, casting, order, ...])
    | Compute hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsinh`](generated/numpy.arcsinh.html#numpy.arcsinh "numpy.arcsinh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic sine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccosh`](generated/numpy.arccosh.html#numpy.arccosh "numpy.arccosh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctanh`](generated/numpy.arctanh.html#numpy.arctanh "numpy.arctanh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`degrees`](generated/numpy.degrees.html#numpy.degrees "numpy.degrees")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: '| [`radians`](generated/numpy.radians.html#numpy.radians "numpy.radians")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`deg2rad`](generated/numpy.deg2rad.html#numpy.deg2rad "numpy.deg2rad")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rad2deg`](generated/numpy.rad2deg.html#numpy.rad2deg "numpy.rad2deg")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: Bit-twiddling functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These function all require integer arguments and they manipulate the bit-pattern
    of those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`bitwise_and`](generated/numpy.bitwise_and.html#numpy.bitwise_and "numpy.bitwise_and")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise AND of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_or`](generated/numpy.bitwise_or.html#numpy.bitwise_or "numpy.bitwise_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the bit-wise OR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_xor`](generated/numpy.bitwise_xor.html#numpy.bitwise_xor "numpy.bitwise_xor")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise XOR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`invert`](generated/numpy.invert.html#numpy.invert "numpy.invert")(x, /[, out, where, casting, order, ...])
    | Compute bit-wise inversion, or bit-wise NOT, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`left_shift`](generated/numpy.left_shift.html#numpy.left_shift "numpy.left_shift")(x1, x2, /[, out, where, casting, ...])
    | Shift the bits of an integer to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| [`right_shift`](generated/numpy.right_shift.html#numpy.right_shift "numpy.right_shift")(x1, x2, /[, out, where, ...])
    | Shift the bits of an integer to the right. |'
  prefs: []
  type: TYPE_TB
- en: Comparison functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`greater`](generated/numpy.greater.html#numpy.greater "numpy.greater")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 > x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`greater_equal`](generated/numpy.greater_equal.html#numpy.greater_equal
    "numpy.greater_equal")(x1, x2, /[, out, where, ...]) | Return the truth value
    of (x1 >= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less`](generated/numpy.less.html#numpy.less "numpy.less")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 < x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less_equal`](generated/numpy.less_equal.html#numpy.less_equal "numpy.less_equal")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 <= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`not_equal`](generated/numpy.not_equal.html#numpy.not_equal "numpy.not_equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 != x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`equal`](generated/numpy.equal.html#numpy.equal "numpy.equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 == x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the Python keywords `and` and `or` to combine logical array expressions.
    These keywords will test the truth value of the entire array (not element-by-element
    as you might expect). Use the bitwise operators & and | instead.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`logical_and`](generated/numpy.logical_and.html#numpy.logical_and "numpy.logical_and")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 AND x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_or`](generated/numpy.logical_or.html#numpy.logical_or "numpy.logical_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the truth value of x1 OR x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_xor`](generated/numpy.logical_xor.html#numpy.logical_xor "numpy.logical_xor")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 XOR x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_not`](generated/numpy.logical_not.html#numpy.logical_not "numpy.logical_not")(x, /[, out, where, casting, ...])
    | Compute the truth value of NOT x element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The bit-wise operators & and | are the proper way to perform element-by-element
    array comparisons. Be sure you understand the operator precedence: `(a > 2) &
    (a < 5)` is the proper syntax because `a > 2 & a < 5` will result in an error
    due to the fact that `2 & a` is evaluated first.'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`maximum`](generated/numpy.maximum.html#numpy.maximum "numpy.maximum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The Python function `max()` will find the maximum over a one-dimensional array,
    but it will do so using a slower sequence interface. The reduce method of the
    maximum ufunc is much faster. Also, the `max()` method will not give answers you
    might expect for arrays with greater than one dimension. The reduce method of
    minimum also allows you to compute a total minimum over an array.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`minimum`](generated/numpy.minimum.html#numpy.minimum "numpy.minimum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: the behavior of `maximum(a, b)` is different than that of `max(a, b)`. As a
    ufunc, `maximum(a, b)` performs an element-by-element comparison of *a* and *b*
    and chooses each element of the result according to which element in the two arrays
    is larger. In contrast, `max(a, b)` treats the objects *a* and *b* as a whole,
    looks at the (total) truth value of `a > b` and uses it to return either *a* or
    *b* (as a whole). A similar difference exists between `minimum(a, b)` and `min(a,
    b)`.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fmax`](generated/numpy.fmax.html#numpy.fmax "numpy.fmax")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin`](generated/numpy.fmin.html#numpy.fmin "numpy.fmin")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Floating functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that all of these functions work element-by-element over an array, returning
    an array output. The description details only a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`isfinite`](generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")(x, /[, out, where, casting, order, ...])
    | Test element-wise for finiteness (not infinity and not Not a Number). |'
  prefs: []
  type: TYPE_TB
- en: '| [`isinf`](generated/numpy.isinf.html#numpy.isinf "numpy.isinf")(x, /[, out, where, casting, order, ...])
    | Test element-wise for positive or negative infinity. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnan`](generated/numpy.isnan.html#numpy.isnan "numpy.isnan")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaN and return result as a boolean array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnat`](generated/numpy.isnat.html#numpy.isnat "numpy.isnat")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaT (not a time) and return result as a boolean array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`signbit`](generated/numpy.signbit.html#numpy.signbit "numpy.signbit")(x, /[, out, where, casting, order, ...])
    | Returns element-wise True where signbit is set (less than zero). |'
  prefs: []
  type: TYPE_TB
- en: '| [`copysign`](generated/numpy.copysign.html#numpy.copysign "numpy.copysign")(x1, x2, /[, out, where, casting, ...])
    | Change the sign of x1 to that of x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`nextafter`](generated/numpy.nextafter.html#numpy.nextafter "numpy.nextafter")(x1, x2, /[, out, where, casting, ...])
    | Return the next floating-point value after x1 towards x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`spacing`](generated/numpy.spacing.html#numpy.spacing "numpy.spacing")(x, /[, out, where, casting, order, ...])
    | Return the distance between x and the nearest adjacent number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`modf`](generated/numpy.modf.html#numpy.modf "numpy.modf")(x[, out1, out2], / [[, out, where, ...])
    | Return the fractional and integral parts of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ldexp`](generated/numpy.ldexp.html#numpy.ldexp "numpy.ldexp")(x1, x2, /[, out, where, casting, ...])
    | Returns x1 * 2**x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`frexp`](generated/numpy.frexp.html#numpy.frexp "numpy.frexp")(x[, out1, out2], / [[, out, where, ...])
    | Decompose the elements of x into mantissa and twos exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor`](generated/numpy.floor.html#numpy.floor "numpy.floor")(x, /[, out, where, casting, order, ...])
    | Return the floor of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ceil`](generated/numpy.ceil.html#numpy.ceil "numpy.ceil")(x, /[, out, where, casting, order, ...])
    | Return the ceiling of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`trunc`](generated/numpy.trunc.html#numpy.trunc "numpy.trunc")(x, /[, out, where, casting, order, ...])
    | Return the truncated value of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '[`ufunc`](generated/numpy.ufunc.html#numpy.ufunc "numpy.ufunc")'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`numpy.ufunc`](generated/numpy.ufunc.html#numpy.ufunc "numpy.ufunc")() |
    Functions that operate element by element on whole arrays. |'
  prefs: []
  type: TYPE_TB
- en: '### Optional keyword arguments'
  prefs: []
  type: TYPE_NORMAL
- en: All ufuncs take optional keyword arguments. Most of these represent advanced
    usage and will not typically be used.
  prefs: []
  type: TYPE_NORMAL
- en: '*out*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: The first output can be provided as either a positional or a keyword parameter.
    Keyword ‘out’ arguments are incompatible with positional ones.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.
  prefs: []
  type: TYPE_NORMAL
- en: The ‘out’ keyword argument is expected to be a tuple with one entry per output
    (which can be None for arrays to be allocated by the ufunc). For ufuncs with a
    single output, passing a single array (instead of a tuple holding a single array)
    is also valid.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a single array in the ‘out’ keyword argument to a ufunc with multiple
    outputs is deprecated, and will raise a warning in numpy 1.10, and an error in
    a future release.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘out’ is None (the default), a uninitialized return array is created. The
    output array is then filled with the results of the ufunc in the places that the
    broadcast ‘where’ is True. If ‘where’ is the scalar True (the default), then this
    corresponds to the entire output being filled. Note that outputs not explicitly
    filled are left with their uninitialized values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap are defined
    to be the same as for equivalent operations where there is no memory overlap.
    Operations affected make temporary copies as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result in needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example, `np.add(a, b, out=a)` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: '*where*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a boolean array which is broadcast together with the operands. Values
    of True indicate to calculate the ufunc at that position, values of False indicate
    to leave the value in the output alone. This argument cannot be used for generalized
    ufuncs as those take non-scalar input.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if an uninitialized return array is created, values of False will
    leave those values **uninitialized**.
  prefs: []
  type: TYPE_NORMAL
- en: '*axes*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A list of tuples with indices of axes a generalized ufunc should operate on.
    For instance, for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. For simplicity, for generalized ufuncs that
    operate on 1-dimensional arrays (vectors), a single integer is accepted instead
    of a single-element tuple, and for generalized ufuncs for which all outputs are
    scalars, the output tuples can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '*axis*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A single axis over which a generalized ufunc should operate. This is a short-cut
    for ufuncs that operate over a single, shared core dimension, equivalent to passing
    in `axes` with entries of `(axis,)` for each single-core-dimension argument and
    `()` for all others. For instance, for a signature `(i),(i)->()`, it is equivalent
    to passing in `axes=[(axis,), (axis,), ()]`.
  prefs: []
  type: TYPE_NORMAL
- en: '*keepdims*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: If this is set to *True*, axes which are reduced over will be left in the result
    as a dimension with size one, so that the result will broadcast correctly against
    the inputs. This option can only be used for generalized ufuncs that operate on
    inputs that all have the same number of core dimensions and with outputs that
    have no core dimensions, i.e., with signatures like `(i),(i)->()` or `(m,m)->()`.
    If used, the location of the dimensions in the output can be controlled with `axes`
    and `axis`.
  prefs: []
  type: TYPE_NORMAL
- en: '*casting*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: May be ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, or ‘unsafe’. See [`can_cast`](generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") for explanations of the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Provides a policy for what kind of casting is permitted. For compatibility with
    previous versions of NumPy, this defaults to ‘unsafe’ for numpy < 1.7. In numpy
    1.7 a transition to ‘same_kind’ was begun where ufuncs produce a DeprecationWarning
    for calls which are allowed under the ‘unsafe’ rules, but not under the ‘same_kind’
    rules. From numpy 1.10 and onwards, the default is ‘same_kind’.
  prefs: []
  type: TYPE_NORMAL
- en: '*order*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the calculation iteration order/memory layout of the output array.
    Defaults to ‘K’. ‘C’ means the output should be C-contiguous, ‘F’ means F-contiguous,
    ‘A’ means F-contiguous if the inputs are F-contiguous and not also not C-contiguous,
    C-contiguous otherwise, and ‘K’ means to match the element ordering of the inputs
    as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*dtype*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Overrides the DType of the output arrays the same way as the *signature*. This
    should ensure a matching precision of the calculation. The exact calculation DTypes
    chosen may depend on the ufunc and the inputs may be cast to this DType to perform
    the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '*subok*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to true. If set to false, the output will always be a strict array,
    not a subtype.
  prefs: []
  type: TYPE_NORMAL
- en: '*signature*'
  prefs: []
  type: TYPE_NORMAL
- en: Either a Dtype, a tuple of DTypes, or a special signature string indicating
    the input and output types of a ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: This argument allows the user to specify exact DTypes to be used for the calculation.
    Casting will be used as necessary. The actual DType of the input arrays is not
    considered unless `signature` is `None` for that array.
  prefs: []
  type: TYPE_NORMAL
- en: When all DTypes are fixed, a specific loop is chosen or an error raised if no
    matching loop exists. If some DTypes are not specified and left `None`, the behaviour
    may depend on the ufunc. At this time, a list of available signatures is provided
    by the **types** attribute of the ufunc. (This list may be missing DTypes not
    defined by NumPy.)
  prefs: []
  type: TYPE_NORMAL
- en: The `signature` only specifies the DType class/type. For example, it can specify
    that the operation should be `datetime64` or `float64` operation. It does not
    specify the `datetime64` time-unit or the `float64` byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: For backwards compatibility this argument can also be provided as *sig*, although
    the long form is preferred. Note that this should not be confused with the generalized
    ufunc [signature](c-api/generalized-ufuncs.html#details-of-signature) that is
    stored in the **signature** attribute of the of the ufunc object.
  prefs: []
  type: TYPE_NORMAL
- en: '*extobj*'
  prefs: []
  type: TYPE_NORMAL
- en: A list of length 3 specifying the ufunc buffer-size, the error mode integer,
    and the error call-back function. Normally, these values are looked up in a thread-specific
    dictionary. Passing them here circumvents that look up and uses the low-level
    specification provided for the error mode. This may be useful, for example, as
    an optimization for calculations requiring many ufunc calls on small arrays in
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some informational attributes that universal functions possess. None
    of the attributes can be set.
  prefs: []
  type: TYPE_NORMAL
- en: '| **__doc__** | A docstring for each ufunc. The first part of the docstring
    is dynamically generated from the number of outputs, the name, and the number
    of inputs. The second part of the docstring is provided at creation time and stored
    with the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| **__name__** | The name of the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nin`](generated/numpy.ufunc.nin.html#numpy.ufunc.nin "numpy.ufunc.nin")
    | The number of inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nout`](generated/numpy.ufunc.nout.html#numpy.ufunc.nout "numpy.ufunc.nout")
    | The number of outputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nargs`](generated/numpy.ufunc.nargs.html#numpy.ufunc.nargs "numpy.ufunc.nargs")
    | The number of arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.ntypes`](generated/numpy.ufunc.ntypes.html#numpy.ufunc.ntypes "numpy.ufunc.ntypes")
    | The number of types. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.types`](generated/numpy.ufunc.types.html#numpy.ufunc.types "numpy.ufunc.types")
    | Returns a list with types grouped input->output. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.identity`](generated/numpy.ufunc.identity.html#numpy.ufunc.identity
    "numpy.ufunc.identity") | The identity value. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.signature`](generated/numpy.ufunc.signature.html#numpy.ufunc.signature
    "numpy.ufunc.signature") | Definition of the core elements a generalized ufunc
    operates on. |'
  prefs: []
  type: TYPE_TB
- en: '### Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`ufunc.reduce`](generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce "numpy.ufunc.reduce")(array[, axis, dtype, out, ...])
    | Reduces [`array`](generated/numpy.array.html#numpy.array "numpy.array")''s dimension
    by one, by applying ufunc along one axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.accumulate`](generated/numpy.ufunc.accumulate.html#numpy.ufunc.accumulate
    "numpy.ufunc.accumulate")(array[, axis, dtype, out]) | Accumulate the result of
    applying the operator to all elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.reduceat`](generated/numpy.ufunc.reduceat.html#numpy.ufunc.reduceat
    "numpy.ufunc.reduceat")(array, indices[, axis, ...]) | Performs a (local) reduce
    with specified slices over a single axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.outer`](generated/numpy.ufunc.outer.html#numpy.ufunc.outer "numpy.ufunc.outer")(A, B, /, **kwargs)
    | Apply the ufunc *op* to all pairs (a, b) with a in *A* and b in *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.at`](generated/numpy.ufunc.at.html#numpy.ufunc.at "numpy.ufunc.at")(a, indices[, b])
    | Performs unbuffered in place operation on operand ''a'' for elements specified
    by ''indices''. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'A reduce-like operation on an array with a data-type that has a range “too
    small” to handle the result will silently wrap. One should use [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") to increase the size of the data-type over which reduction takes
    place.  ### Optional keyword arguments'
  prefs: []
  type: TYPE_NORMAL
- en: All ufuncs take optional keyword arguments. Most of these represent advanced
    usage and will not typically be used.
  prefs: []
  type: TYPE_NORMAL
- en: '*out*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: The first output can be provided as either a positional or a keyword parameter.
    Keyword ‘out’ arguments are incompatible with positional ones.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.
  prefs: []
  type: TYPE_NORMAL
- en: The ‘out’ keyword argument is expected to be a tuple with one entry per output
    (which can be None for arrays to be allocated by the ufunc). For ufuncs with a
    single output, passing a single array (instead of a tuple holding a single array)
    is also valid.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a single array in the ‘out’ keyword argument to a ufunc with multiple
    outputs is deprecated, and will raise a warning in numpy 1.10, and an error in
    a future release.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘out’ is None (the default), a uninitialized return array is created. The
    output array is then filled with the results of the ufunc in the places that the
    broadcast ‘where’ is True. If ‘where’ is the scalar True (the default), then this
    corresponds to the entire output being filled. Note that outputs not explicitly
    filled are left with their uninitialized values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap are defined
    to be the same as for equivalent operations where there is no memory overlap.
    Operations affected make temporary copies as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result in needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example, `np.add(a, b, out=a)` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: '*where*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a boolean array which is broadcast together with the operands. Values
    of True indicate to calculate the ufunc at that position, values of False indicate
    to leave the value in the output alone. This argument cannot be used for generalized
    ufuncs as those take non-scalar input.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if an uninitialized return array is created, values of False will
    leave those values **uninitialized**.
  prefs: []
  type: TYPE_NORMAL
- en: '*axes*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A list of tuples with indices of axes a generalized ufunc should operate on.
    For instance, for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. For simplicity, for generalized ufuncs that
    operate on 1-dimensional arrays (vectors), a single integer is accepted instead
    of a single-element tuple, and for generalized ufuncs for which all outputs are
    scalars, the output tuples can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '*axis*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: A single axis over which a generalized ufunc should operate. This is a short-cut
    for ufuncs that operate over a single, shared core dimension, equivalent to passing
    in `axes` with entries of `(axis,)` for each single-core-dimension argument and
    `()` for all others. For instance, for a signature `(i),(i)->()`, it is equivalent
    to passing in `axes=[(axis,), (axis,), ()]`.
  prefs: []
  type: TYPE_NORMAL
- en: '*keepdims*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: If this is set to *True*, axes which are reduced over will be left in the result
    as a dimension with size one, so that the result will broadcast correctly against
    the inputs. This option can only be used for generalized ufuncs that operate on
    inputs that all have the same number of core dimensions and with outputs that
    have no core dimensions, i.e., with signatures like `(i),(i)->()` or `(m,m)->()`.
    If used, the location of the dimensions in the output can be controlled with `axes`
    and `axis`.
  prefs: []
  type: TYPE_NORMAL
- en: '*casting*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: May be ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, or ‘unsafe’. See [`can_cast`](generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") for explanations of the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Provides a policy for what kind of casting is permitted. For compatibility with
    previous versions of NumPy, this defaults to ‘unsafe’ for numpy < 1.7. In numpy
    1.7 a transition to ‘same_kind’ was begun where ufuncs produce a DeprecationWarning
    for calls which are allowed under the ‘unsafe’ rules, but not under the ‘same_kind’
    rules. From numpy 1.10 and onwards, the default is ‘same_kind’.
  prefs: []
  type: TYPE_NORMAL
- en: '*order*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the calculation iteration order/memory layout of the output array.
    Defaults to ‘K’. ‘C’ means the output should be C-contiguous, ‘F’ means F-contiguous,
    ‘A’ means F-contiguous if the inputs are F-contiguous and not also not C-contiguous,
    C-contiguous otherwise, and ‘K’ means to match the element ordering of the inputs
    as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*dtype*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Overrides the DType of the output arrays the same way as the *signature*. This
    should ensure a matching precision of the calculation. The exact calculation DTypes
    chosen may depend on the ufunc and the inputs may be cast to this DType to perform
    the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '*subok*'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to true. If set to false, the output will always be a strict array,
    not a subtype.
  prefs: []
  type: TYPE_NORMAL
- en: '*signature*'
  prefs: []
  type: TYPE_NORMAL
- en: Either a Dtype, a tuple of DTypes, or a special signature string indicating
    the input and output types of a ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: This argument allows the user to specify exact DTypes to be used for the calculation.
    Casting will be used as necessary. The actual DType of the input arrays is not
    considered unless `signature` is `None` for that array.
  prefs: []
  type: TYPE_NORMAL
- en: When all DTypes are fixed, a specific loop is chosen or an error raised if no
    matching loop exists. If some DTypes are not specified and left `None`, the behaviour
    may depend on the ufunc. At this time, a list of available signatures is provided
    by the **types** attribute of the ufunc. (This list may be missing DTypes not
    defined by NumPy.)
  prefs: []
  type: TYPE_NORMAL
- en: The `signature` only specifies the DType class/type. For example, it can specify
    that the operation should be `datetime64` or `float64` operation. It does not
    specify the `datetime64` time-unit or the `float64` byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: For backwards compatibility this argument can also be provided as *sig*, although
    the long form is preferred. Note that this should not be confused with the generalized
    ufunc [signature](c-api/generalized-ufuncs.html#details-of-signature) that is
    stored in the **signature** attribute of the of the ufunc object.
  prefs: []
  type: TYPE_NORMAL
- en: '*extobj*'
  prefs: []
  type: TYPE_NORMAL
- en: A list of length 3 specifying the ufunc buffer-size, the error mode integer,
    and the error call-back function. Normally, these values are looked up in a thread-specific
    dictionary. Passing them here circumvents that look up and uses the low-level
    specification provided for the error mode. This may be useful, for example, as
    an optimization for calculations requiring many ufunc calls on small arrays in
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some informational attributes that universal functions possess. None
    of the attributes can be set.
  prefs: []
  type: TYPE_NORMAL
- en: '| **__doc__** | A docstring for each ufunc. The first part of the docstring
    is dynamically generated from the number of outputs, the name, and the number
    of inputs. The second part of the docstring is provided at creation time and stored
    with the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| **__name__** | The name of the ufunc. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nin`](generated/numpy.ufunc.nin.html#numpy.ufunc.nin "numpy.ufunc.nin")
    | The number of inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nout`](generated/numpy.ufunc.nout.html#numpy.ufunc.nout "numpy.ufunc.nout")
    | The number of outputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.nargs`](generated/numpy.ufunc.nargs.html#numpy.ufunc.nargs "numpy.ufunc.nargs")
    | The number of arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.ntypes`](generated/numpy.ufunc.ntypes.html#numpy.ufunc.ntypes "numpy.ufunc.ntypes")
    | The number of types. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.types`](generated/numpy.ufunc.types.html#numpy.ufunc.types "numpy.ufunc.types")
    | Returns a list with types grouped input->output. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.identity`](generated/numpy.ufunc.identity.html#numpy.ufunc.identity
    "numpy.ufunc.identity") | The identity value. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.signature`](generated/numpy.ufunc.signature.html#numpy.ufunc.signature
    "numpy.ufunc.signature") | Definition of the core elements a generalized ufunc
    operates on. |'
  prefs: []
  type: TYPE_TB
- en: '### Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`ufunc.reduce`](generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce "numpy.ufunc.reduce")(array[, axis, dtype, out, ...])
    | Reduces [`array`](generated/numpy.array.html#numpy.array "numpy.array")''s dimension
    by one, by applying ufunc along one axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.accumulate`](generated/numpy.ufunc.accumulate.html#numpy.ufunc.accumulate
    "numpy.ufunc.accumulate")(array[, axis, dtype, out]) | Accumulate the result of
    applying the operator to all elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.reduceat`](generated/numpy.ufunc.reduceat.html#numpy.ufunc.reduceat
    "numpy.ufunc.reduceat")(array, indices[, axis, ...]) | Performs a (local) reduce
    with specified slices over a single axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.outer`](generated/numpy.ufunc.outer.html#numpy.ufunc.outer "numpy.ufunc.outer")(A, B, /, **kwargs)
    | Apply the ufunc *op* to all pairs (a, b) with a in *A* and b in *B*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ufunc.at`](generated/numpy.ufunc.at.html#numpy.ufunc.at "numpy.ufunc.at")(a, indices[, b])
    | Performs unbuffered in place operation on operand ''a'' for elements specified
    by ''indices''. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: A reduce-like operation on an array with a data-type that has a range “too small”
    to handle the result will silently wrap. One should use [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") to increase the size of the data-type over which reduction takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Available ufuncs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are currently more than 60 universal functions defined in [`numpy`](index.html#module-numpy
    "numpy") on one or more types, covering a wide variety of operations. Some of
    these ufuncs are called automatically on arrays when the relevant infix notation
    is used (*e.g.*, [`add(a, b)`](generated/numpy.add.html#numpy.add "numpy.add")
    is called internally when `a + b` is written and *a* or *b* is an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")). Nevertheless, you may still want to use the ufunc call in order
    to use the optional output argument(s) to place the output(s) in an object (or
    objects) of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each ufunc operates element-by-element. Therefore, each scalar ufunc
    will be described as if acting on a set of scalar inputs to return a set of scalar
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The ufunc still returns its output(s) even if you use the optional output argument(s).
  prefs: []
  type: TYPE_NORMAL
- en: Math operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`add`](generated/numpy.add.html#numpy.add "numpy.add")(x1, x2, /[, out, where, casting, order, ...])
    | Add arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`subtract`](generated/numpy.subtract.html#numpy.subtract "numpy.subtract")(x1, x2, /[, out, where, casting, ...])
    | Subtract arguments, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`multiply`](generated/numpy.multiply.html#numpy.multiply "numpy.multiply")(x1, x2, /[, out, where, casting, ...])
    | Multiply arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul")(x1, x2, /[, out, casting, order, ...])
    | Matrix product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divide`](generated/numpy.divide.html#numpy.divide "numpy.divide")(x1, x2, /[, out, where, casting, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp`](generated/numpy.logaddexp.html#numpy.logaddexp "numpy.logaddexp")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp2`](generated/numpy.logaddexp2.html#numpy.logaddexp2 "numpy.logaddexp2")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs in base-2. |'
  prefs: []
  type: TYPE_TB
- en: '| [`true_divide`](generated/numpy.true_divide.html#numpy.true_divide "numpy.true_divide")(x1, x2, /[, out, where, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor_divide`](generated/numpy.floor_divide.html#numpy.floor_divide "numpy.floor_divide")(x1, x2, /[, out, where, ...])
    | Return the largest integer smaller or equal to the division of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`negative`](generated/numpy.negative.html#numpy.negative "numpy.negative")(x, /[, out, where, casting, order, ...])
    | Numerical negative, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`positive`](generated/numpy.positive.html#numpy.positive "numpy.positive")(x, /[, out, where, casting, order, ...])
    | Numerical positive, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`power`](generated/numpy.power.html#numpy.power "numpy.power")(x1, x2, /[, out, where, casting, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`float_power`](generated/numpy.float_power.html#numpy.float_power "numpy.float_power")(x1, x2, /[, out, where, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`remainder`](generated/numpy.remainder.html#numpy.remainder "numpy.remainder")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`mod`](generated/numpy.mod.html#numpy.mod "numpy.mod")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divmod`](generated/numpy.divmod.html#numpy.divmod "numpy.divmod")(x1, x2[, out1, out2], / [[, out, ...])
    | Return element-wise quotient and remainder simultaneously. |'
  prefs: []
  type: TYPE_TB
- en: '| [`absolute`](generated/numpy.absolute.html#numpy.absolute "numpy.absolute")(x, /[, out, where, casting, order, ...])
    | Calculate the absolute value element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rint`](generated/numpy.rint.html#numpy.rint "numpy.rint")(x, /[, out, where, casting, order, ...])
    | Round elements of the array to the nearest integer. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sign`](generated/numpy.sign.html#numpy.sign "numpy.sign")(x, /[, out, where, casting, order, ...])
    | Returns an element-wise indication of the sign of a number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`heaviside`](generated/numpy.heaviside.html#numpy.heaviside "numpy.heaviside")(x1, x2, /[, out, where, casting, ...])
    | Compute the Heaviside step function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conj`](generated/numpy.conj.html#numpy.conj "numpy.conj")(x, /[, out, where, casting, order, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conjugate`](generated/numpy.conjugate.html#numpy.conjugate "numpy.conjugate")(x, /[, out, where, casting, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp`](generated/numpy.exp.html#numpy.exp "numpy.exp")(x, /[, out, where, casting, order, ...])
    | Calculate the exponential of all elements in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp2`](generated/numpy.exp2.html#numpy.exp2 "numpy.exp2")(x, /[, out, where, casting, order, ...])
    | Calculate *2**p* for all *p* in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log`](generated/numpy.log.html#numpy.log "numpy.log")(x, /[, out, where, casting, order, ...])
    | Natural logarithm, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log2`](generated/numpy.log2.html#numpy.log2 "numpy.log2")(x, /[, out, where, casting, order, ...])
    | Base-2 logarithm of *x*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log10`](generated/numpy.log10.html#numpy.log10 "numpy.log10")(x, /[, out, where, casting, order, ...])
    | Return the base 10 logarithm of the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`expm1`](generated/numpy.expm1.html#numpy.expm1 "numpy.expm1")(x, /[, out, where, casting, order, ...])
    | Calculate `exp(x) - 1` for all elements in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log1p`](generated/numpy.log1p.html#numpy.log1p "numpy.log1p")(x, /[, out, where, casting, order, ...])
    | Return the natural logarithm of one plus the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sqrt`](generated/numpy.sqrt.html#numpy.sqrt "numpy.sqrt")(x, /[, out, where, casting, order, ...])
    | Return the non-negative square-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`square`](generated/numpy.square.html#numpy.square "numpy.square")(x, /[, out, where, casting, order, ...])
    | Return the element-wise square of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cbrt`](generated/numpy.cbrt.html#numpy.cbrt "numpy.cbrt")(x, /[, out, where, casting, order, ...])
    | Return the cube-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`reciprocal`](generated/numpy.reciprocal.html#numpy.reciprocal "numpy.reciprocal")(x, /[, out, where, casting, ...])
    | Return the reciprocal of the argument, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`gcd`](generated/numpy.gcd.html#numpy.gcd "numpy.gcd")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the greatest common divisor of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`lcm`](generated/numpy.lcm.html#numpy.lcm "numpy.lcm")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the lowest common multiple of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The optional output arguments can be used to help you save memory for large
    calculations. If your arrays are large, complicated expressions can take longer
    than absolutely necessary due to the creation and (later) destruction of temporary
    calculation spaces. For example, the expression `G = A * B + C` is equivalent
    to `T1 = A * B; G = T1 + C; del T1`. It will be more quickly executed as `G =
    A * B; add(G, C, G)` which is the same as `G = A * B; G += C`.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All trigonometric functions use radians when an angle is called for. The ratio
    of degrees to radians is \(180^{\circ}/\pi.\)
  prefs: []
  type: TYPE_NORMAL
- en: '| [`sin`](generated/numpy.sin.html#numpy.sin "numpy.sin")(x, /[, out, where, casting, order, ...])
    | Trigonometric sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cos`](generated/numpy.cos.html#numpy.cos "numpy.cos")(x, /[, out, where, casting, order, ...])
    | Cosine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tan`](generated/numpy.tan.html#numpy.tan "numpy.tan")(x, /[, out, where, casting, order, ...])
    | Compute tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsin`](generated/numpy.arcsin.html#numpy.arcsin "numpy.arcsin")(x, /[, out, where, casting, order, ...])
    | Inverse sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccos`](generated/numpy.arccos.html#numpy.arccos "numpy.arccos")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan`](generated/numpy.arctan.html#numpy.arctan "numpy.arctan")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse tangent, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan2`](generated/numpy.arctan2.html#numpy.arctan2 "numpy.arctan2")(x1, x2, /[, out, where, casting, ...])
    | Element-wise arc tangent of `x1/x2` choosing the quadrant correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| [`hypot`](generated/numpy.hypot.html#numpy.hypot "numpy.hypot")(x1, x2, /[, out, where, casting, ...])
    | Given the "legs" of a right triangle, return its hypotenuse. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sinh`](generated/numpy.sinh.html#numpy.sinh "numpy.sinh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cosh`](generated/numpy.cosh.html#numpy.cosh "numpy.cosh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tanh`](generated/numpy.tanh.html#numpy.tanh "numpy.tanh")(x, /[, out, where, casting, order, ...])
    | Compute hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsinh`](generated/numpy.arcsinh.html#numpy.arcsinh "numpy.arcsinh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic sine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccosh`](generated/numpy.arccosh.html#numpy.arccosh "numpy.arccosh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctanh`](generated/numpy.arctanh.html#numpy.arctanh "numpy.arctanh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`degrees`](generated/numpy.degrees.html#numpy.degrees "numpy.degrees")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: '| [`radians`](generated/numpy.radians.html#numpy.radians "numpy.radians")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`deg2rad`](generated/numpy.deg2rad.html#numpy.deg2rad "numpy.deg2rad")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rad2deg`](generated/numpy.rad2deg.html#numpy.rad2deg "numpy.rad2deg")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: Bit-twiddling functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These function all require integer arguments and they manipulate the bit-pattern
    of those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`bitwise_and`](generated/numpy.bitwise_and.html#numpy.bitwise_and "numpy.bitwise_and")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise AND of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_or`](generated/numpy.bitwise_or.html#numpy.bitwise_or "numpy.bitwise_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the bit-wise OR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_xor`](generated/numpy.bitwise_xor.html#numpy.bitwise_xor "numpy.bitwise_xor")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise XOR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`invert`](generated/numpy.invert.html#numpy.invert "numpy.invert")(x, /[, out, where, casting, order, ...])
    | Compute bit-wise inversion, or bit-wise NOT, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`left_shift`](generated/numpy.left_shift.html#numpy.left_shift "numpy.left_shift")(x1, x2, /[, out, where, casting, ...])
    | Shift the bits of an integer to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| [`right_shift`](generated/numpy.right_shift.html#numpy.right_shift "numpy.right_shift")(x1, x2, /[, out, where, ...])
    | Shift the bits of an integer to the right. |'
  prefs: []
  type: TYPE_TB
- en: Comparison functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`greater`](generated/numpy.greater.html#numpy.greater "numpy.greater")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 > x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`greater_equal`](generated/numpy.greater_equal.html#numpy.greater_equal
    "numpy.greater_equal")(x1, x2, /[, out, where, ...]) | Return the truth value
    of (x1 >= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less`](generated/numpy.less.html#numpy.less "numpy.less")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 < x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less_equal`](generated/numpy.less_equal.html#numpy.less_equal "numpy.less_equal")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 <= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`not_equal`](generated/numpy.not_equal.html#numpy.not_equal "numpy.not_equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 != x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`equal`](generated/numpy.equal.html#numpy.equal "numpy.equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 == x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the Python keywords `and` and `or` to combine logical array expressions.
    These keywords will test the truth value of the entire array (not element-by-element
    as you might expect). Use the bitwise operators & and | instead.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`logical_and`](generated/numpy.logical_and.html#numpy.logical_and "numpy.logical_and")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 AND x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_or`](generated/numpy.logical_or.html#numpy.logical_or "numpy.logical_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the truth value of x1 OR x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_xor`](generated/numpy.logical_xor.html#numpy.logical_xor "numpy.logical_xor")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 XOR x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_not`](generated/numpy.logical_not.html#numpy.logical_not "numpy.logical_not")(x, /[, out, where, casting, ...])
    | Compute the truth value of NOT x element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The bit-wise operators & and | are the proper way to perform element-by-element
    array comparisons. Be sure you understand the operator precedence: `(a > 2) &
    (a < 5)` is the proper syntax because `a > 2 & a < 5` will result in an error
    due to the fact that `2 & a` is evaluated first.'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`maximum`](generated/numpy.maximum.html#numpy.maximum "numpy.maximum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The Python function `max()` will find the maximum over a one-dimensional array,
    but it will do so using a slower sequence interface. The reduce method of the
    maximum ufunc is much faster. Also, the `max()` method will not give answers you
    might expect for arrays with greater than one dimension. The reduce method of
    minimum also allows you to compute a total minimum over an array.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`minimum`](generated/numpy.minimum.html#numpy.minimum "numpy.minimum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: the behavior of `maximum(a, b)` is different than that of `max(a, b)`. As a
    ufunc, `maximum(a, b)` performs an element-by-element comparison of *a* and *b*
    and chooses each element of the result according to which element in the two arrays
    is larger. In contrast, `max(a, b)` treats the objects *a* and *b* as a whole,
    looks at the (total) truth value of `a > b` and uses it to return either *a* or
    *b* (as a whole). A similar difference exists between `minimum(a, b)` and `min(a,
    b)`.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fmax`](generated/numpy.fmax.html#numpy.fmax "numpy.fmax")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin`](generated/numpy.fmin.html#numpy.fmin "numpy.fmin")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Floating functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that all of these functions work element-by-element over an array, returning
    an array output. The description details only a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`isfinite`](generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")(x, /[, out, where, casting, order, ...])
    | Test element-wise for finiteness (not infinity and not Not a Number). |'
  prefs: []
  type: TYPE_TB
- en: '| [`isinf`](generated/numpy.isinf.html#numpy.isinf "numpy.isinf")(x, /[, out, where, casting, order, ...])
    | Test element-wise for positive or negative infinity. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnan`](generated/numpy.isnan.html#numpy.isnan "numpy.isnan")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaN and return result as a boolean array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnat`](generated/numpy.isnat.html#numpy.isnat "numpy.isnat")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaT (not a time) and return result as a boolean array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`signbit`](generated/numpy.signbit.html#numpy.signbit "numpy.signbit")(x, /[, out, where, casting, order, ...])
    | Returns element-wise True where signbit is set (less than zero). |'
  prefs: []
  type: TYPE_TB
- en: '| [`copysign`](generated/numpy.copysign.html#numpy.copysign "numpy.copysign")(x1, x2, /[, out, where, casting, ...])
    | Change the sign of x1 to that of x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`nextafter`](generated/numpy.nextafter.html#numpy.nextafter "numpy.nextafter")(x1, x2, /[, out, where, casting, ...])
    | Return the next floating-point value after x1 towards x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`spacing`](generated/numpy.spacing.html#numpy.spacing "numpy.spacing")(x, /[, out, where, casting, order, ...])
    | Return the distance between x and the nearest adjacent number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`modf`](generated/numpy.modf.html#numpy.modf "numpy.modf")(x[, out1, out2], / [[, out, where, ...])
    | Return the fractional and integral parts of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ldexp`](generated/numpy.ldexp.html#numpy.ldexp "numpy.ldexp")(x1, x2, /[, out, where, casting, ...])
    | Returns x1 * 2**x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`frexp`](generated/numpy.frexp.html#numpy.frexp "numpy.frexp")(x[, out1, out2], / [[, out, where, ...])
    | Decompose the elements of x into mantissa and twos exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor`](generated/numpy.floor.html#numpy.floor "numpy.floor")(x, /[, out, where, casting, order, ...])
    | Return the floor of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ceil`](generated/numpy.ceil.html#numpy.ceil "numpy.ceil")(x, /[, out, where, casting, order, ...])
    | Return the ceiling of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`trunc`](generated/numpy.trunc.html#numpy.trunc "numpy.trunc")(x, /[, out, where, casting, order, ...])
    | Return the truncated value of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Math operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`add`](generated/numpy.add.html#numpy.add "numpy.add")(x1, x2, /[, out, where, casting, order, ...])
    | Add arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`subtract`](generated/numpy.subtract.html#numpy.subtract "numpy.subtract")(x1, x2, /[, out, where, casting, ...])
    | Subtract arguments, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`multiply`](generated/numpy.multiply.html#numpy.multiply "numpy.multiply")(x1, x2, /[, out, where, casting, ...])
    | Multiply arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul")(x1, x2, /[, out, casting, order, ...])
    | Matrix product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divide`](generated/numpy.divide.html#numpy.divide "numpy.divide")(x1, x2, /[, out, where, casting, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp`](generated/numpy.logaddexp.html#numpy.logaddexp "numpy.logaddexp")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logaddexp2`](generated/numpy.logaddexp2.html#numpy.logaddexp2 "numpy.logaddexp2")(x1, x2, /[, out, where, casting, ...])
    | Logarithm of the sum of exponentiations of the inputs in base-2. |'
  prefs: []
  type: TYPE_TB
- en: '| [`true_divide`](generated/numpy.true_divide.html#numpy.true_divide "numpy.true_divide")(x1, x2, /[, out, where, ...])
    | Divide arguments element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor_divide`](generated/numpy.floor_divide.html#numpy.floor_divide "numpy.floor_divide")(x1, x2, /[, out, where, ...])
    | Return the largest integer smaller or equal to the division of the inputs. |'
  prefs: []
  type: TYPE_TB
- en: '| [`negative`](generated/numpy.negative.html#numpy.negative "numpy.negative")(x, /[, out, where, casting, order, ...])
    | Numerical negative, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`positive`](generated/numpy.positive.html#numpy.positive "numpy.positive")(x, /[, out, where, casting, order, ...])
    | Numerical positive, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`power`](generated/numpy.power.html#numpy.power "numpy.power")(x1, x2, /[, out, where, casting, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`float_power`](generated/numpy.float_power.html#numpy.float_power "numpy.float_power")(x1, x2, /[, out, where, ...])
    | First array elements raised to powers from second array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`remainder`](generated/numpy.remainder.html#numpy.remainder "numpy.remainder")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`mod`](generated/numpy.mod.html#numpy.mod "numpy.mod")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`divmod`](generated/numpy.divmod.html#numpy.divmod "numpy.divmod")(x1, x2[, out1, out2], / [[, out, ...])
    | Return element-wise quotient and remainder simultaneously. |'
  prefs: []
  type: TYPE_TB
- en: '| [`absolute`](generated/numpy.absolute.html#numpy.absolute "numpy.absolute")(x, /[, out, where, casting, order, ...])
    | Calculate the absolute value element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rint`](generated/numpy.rint.html#numpy.rint "numpy.rint")(x, /[, out, where, casting, order, ...])
    | Round elements of the array to the nearest integer. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sign`](generated/numpy.sign.html#numpy.sign "numpy.sign")(x, /[, out, where, casting, order, ...])
    | Returns an element-wise indication of the sign of a number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`heaviside`](generated/numpy.heaviside.html#numpy.heaviside "numpy.heaviside")(x1, x2, /[, out, where, casting, ...])
    | Compute the Heaviside step function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conj`](generated/numpy.conj.html#numpy.conj "numpy.conj")(x, /[, out, where, casting, order, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`conjugate`](generated/numpy.conjugate.html#numpy.conjugate "numpy.conjugate")(x, /[, out, where, casting, ...])
    | Return the complex conjugate, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp`](generated/numpy.exp.html#numpy.exp "numpy.exp")(x, /[, out, where, casting, order, ...])
    | Calculate the exponential of all elements in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`exp2`](generated/numpy.exp2.html#numpy.exp2 "numpy.exp2")(x, /[, out, where, casting, order, ...])
    | Calculate *2**p* for all *p* in the input array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log`](generated/numpy.log.html#numpy.log "numpy.log")(x, /[, out, where, casting, order, ...])
    | Natural logarithm, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log2`](generated/numpy.log2.html#numpy.log2 "numpy.log2")(x, /[, out, where, casting, order, ...])
    | Base-2 logarithm of *x*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log10`](generated/numpy.log10.html#numpy.log10 "numpy.log10")(x, /[, out, where, casting, order, ...])
    | Return the base 10 logarithm of the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`expm1`](generated/numpy.expm1.html#numpy.expm1 "numpy.expm1")(x, /[, out, where, casting, order, ...])
    | Calculate `exp(x) - 1` for all elements in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`log1p`](generated/numpy.log1p.html#numpy.log1p "numpy.log1p")(x, /[, out, where, casting, order, ...])
    | Return the natural logarithm of one plus the input array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sqrt`](generated/numpy.sqrt.html#numpy.sqrt "numpy.sqrt")(x, /[, out, where, casting, order, ...])
    | Return the non-negative square-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`square`](generated/numpy.square.html#numpy.square "numpy.square")(x, /[, out, where, casting, order, ...])
    | Return the element-wise square of the input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cbrt`](generated/numpy.cbrt.html#numpy.cbrt "numpy.cbrt")(x, /[, out, where, casting, order, ...])
    | Return the cube-root of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`reciprocal`](generated/numpy.reciprocal.html#numpy.reciprocal "numpy.reciprocal")(x, /[, out, where, casting, ...])
    | Return the reciprocal of the argument, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`gcd`](generated/numpy.gcd.html#numpy.gcd "numpy.gcd")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the greatest common divisor of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`lcm`](generated/numpy.lcm.html#numpy.lcm "numpy.lcm")(x1, x2, /[, out, where, casting, order, ...])
    | Returns the lowest common multiple of `&#124;x1&#124;` and `&#124;x2&#124;`
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The optional output arguments can be used to help you save memory for large
    calculations. If your arrays are large, complicated expressions can take longer
    than absolutely necessary due to the creation and (later) destruction of temporary
    calculation spaces. For example, the expression `G = A * B + C` is equivalent
    to `T1 = A * B; G = T1 + C; del T1`. It will be more quickly executed as `G =
    A * B; add(G, C, G)` which is the same as `G = A * B; G += C`.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All trigonometric functions use radians when an angle is called for. The ratio
    of degrees to radians is \(180^{\circ}/\pi.\)
  prefs: []
  type: TYPE_NORMAL
- en: '| [`sin`](generated/numpy.sin.html#numpy.sin "numpy.sin")(x, /[, out, where, casting, order, ...])
    | Trigonometric sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cos`](generated/numpy.cos.html#numpy.cos "numpy.cos")(x, /[, out, where, casting, order, ...])
    | Cosine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tan`](generated/numpy.tan.html#numpy.tan "numpy.tan")(x, /[, out, where, casting, order, ...])
    | Compute tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsin`](generated/numpy.arcsin.html#numpy.arcsin "numpy.arcsin")(x, /[, out, where, casting, order, ...])
    | Inverse sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccos`](generated/numpy.arccos.html#numpy.arccos "numpy.arccos")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan`](generated/numpy.arctan.html#numpy.arctan "numpy.arctan")(x, /[, out, where, casting, order, ...])
    | Trigonometric inverse tangent, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctan2`](generated/numpy.arctan2.html#numpy.arctan2 "numpy.arctan2")(x1, x2, /[, out, where, casting, ...])
    | Element-wise arc tangent of `x1/x2` choosing the quadrant correctly. |'
  prefs: []
  type: TYPE_TB
- en: '| [`hypot`](generated/numpy.hypot.html#numpy.hypot "numpy.hypot")(x1, x2, /[, out, where, casting, ...])
    | Given the "legs" of a right triangle, return its hypotenuse. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sinh`](generated/numpy.sinh.html#numpy.sinh "numpy.sinh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic sine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cosh`](generated/numpy.cosh.html#numpy.cosh "numpy.cosh")(x, /[, out, where, casting, order, ...])
    | Hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tanh`](generated/numpy.tanh.html#numpy.tanh "numpy.tanh")(x, /[, out, where, casting, order, ...])
    | Compute hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arcsinh`](generated/numpy.arcsinh.html#numpy.arcsinh "numpy.arcsinh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic sine element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arccosh`](generated/numpy.arccosh.html#numpy.arccosh "numpy.arccosh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic cosine, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`arctanh`](generated/numpy.arctanh.html#numpy.arctanh "numpy.arctanh")(x, /[, out, where, casting, order, ...])
    | Inverse hyperbolic tangent element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`degrees`](generated/numpy.degrees.html#numpy.degrees "numpy.degrees")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: '| [`radians`](generated/numpy.radians.html#numpy.radians "numpy.radians")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`deg2rad`](generated/numpy.deg2rad.html#numpy.deg2rad "numpy.deg2rad")(x, /[, out, where, casting, order, ...])
    | Convert angles from degrees to radians. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rad2deg`](generated/numpy.rad2deg.html#numpy.rad2deg "numpy.rad2deg")(x, /[, out, where, casting, order, ...])
    | Convert angles from radians to degrees. |'
  prefs: []
  type: TYPE_TB
- en: Bit-twiddling functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These function all require integer arguments and they manipulate the bit-pattern
    of those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`bitwise_and`](generated/numpy.bitwise_and.html#numpy.bitwise_and "numpy.bitwise_and")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise AND of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_or`](generated/numpy.bitwise_or.html#numpy.bitwise_or "numpy.bitwise_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the bit-wise OR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bitwise_xor`](generated/numpy.bitwise_xor.html#numpy.bitwise_xor "numpy.bitwise_xor")(x1, x2, /[, out, where, ...])
    | Compute the bit-wise XOR of two arrays element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`invert`](generated/numpy.invert.html#numpy.invert "numpy.invert")(x, /[, out, where, casting, order, ...])
    | Compute bit-wise inversion, or bit-wise NOT, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`left_shift`](generated/numpy.left_shift.html#numpy.left_shift "numpy.left_shift")(x1, x2, /[, out, where, casting, ...])
    | Shift the bits of an integer to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| [`right_shift`](generated/numpy.right_shift.html#numpy.right_shift "numpy.right_shift")(x1, x2, /[, out, where, ...])
    | Shift the bits of an integer to the right. |'
  prefs: []
  type: TYPE_TB
- en: Comparison functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`greater`](generated/numpy.greater.html#numpy.greater "numpy.greater")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 > x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`greater_equal`](generated/numpy.greater_equal.html#numpy.greater_equal
    "numpy.greater_equal")(x1, x2, /[, out, where, ...]) | Return the truth value
    of (x1 >= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less`](generated/numpy.less.html#numpy.less "numpy.less")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 < x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`less_equal`](generated/numpy.less_equal.html#numpy.less_equal "numpy.less_equal")(x1, x2, /[, out, where, casting, ...])
    | Return the truth value of (x1 <= x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`not_equal`](generated/numpy.not_equal.html#numpy.not_equal "numpy.not_equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 != x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`equal`](generated/numpy.equal.html#numpy.equal "numpy.equal")(x1, x2, /[, out, where, casting, ...])
    | Return (x1 == x2) element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the Python keywords `and` and `or` to combine logical array expressions.
    These keywords will test the truth value of the entire array (not element-by-element
    as you might expect). Use the bitwise operators & and | instead.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`logical_and`](generated/numpy.logical_and.html#numpy.logical_and "numpy.logical_and")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 AND x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_or`](generated/numpy.logical_or.html#numpy.logical_or "numpy.logical_or")(x1, x2, /[, out, where, casting, ...])
    | Compute the truth value of x1 OR x2 element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_xor`](generated/numpy.logical_xor.html#numpy.logical_xor "numpy.logical_xor")(x1, x2, /[, out, where, ...])
    | Compute the truth value of x1 XOR x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`logical_not`](generated/numpy.logical_not.html#numpy.logical_not "numpy.logical_not")(x, /[, out, where, casting, ...])
    | Compute the truth value of NOT x element-wise. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The bit-wise operators & and | are the proper way to perform element-by-element
    array comparisons. Be sure you understand the operator precedence: `(a > 2) &
    (a < 5)` is the proper syntax because `a > 2 & a < 5` will result in an error
    due to the fact that `2 & a` is evaluated first.'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`maximum`](generated/numpy.maximum.html#numpy.maximum "numpy.maximum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The Python function `max()` will find the maximum over a one-dimensional array,
    but it will do so using a slower sequence interface. The reduce method of the
    maximum ufunc is much faster. Also, the `max()` method will not give answers you
    might expect for arrays with greater than one dimension. The reduce method of
    minimum also allows you to compute a total minimum over an array.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`minimum`](generated/numpy.minimum.html#numpy.minimum "numpy.minimum")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: the behavior of `maximum(a, b)` is different than that of `max(a, b)`. As a
    ufunc, `maximum(a, b)` performs an element-by-element comparison of *a* and *b*
    and chooses each element of the result according to which element in the two arrays
    is larger. In contrast, `max(a, b)` treats the objects *a* and *b* as a whole,
    looks at the (total) truth value of `a > b` and uses it to return either *a* or
    *b* (as a whole). A similar difference exists between `minimum(a, b)` and `min(a,
    b)`.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fmax`](generated/numpy.fmax.html#numpy.fmax "numpy.fmax")(x1, x2, /[, out, where, casting, ...])
    | Element-wise maximum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin`](generated/numpy.fmin.html#numpy.fmin "numpy.fmin")(x1, x2, /[, out, where, casting, ...])
    | Element-wise minimum of array elements. |'
  prefs: []
  type: TYPE_TB
- en: Floating functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that all of these functions work element-by-element over an array, returning
    an array output. The description details only a single operation.
  prefs: []
  type: TYPE_NORMAL
- en: '| [`isfinite`](generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")(x, /[, out, where, casting, order, ...])
    | Test element-wise for finiteness (not infinity and not Not a Number). |'
  prefs: []
  type: TYPE_TB
- en: '| [`isinf`](generated/numpy.isinf.html#numpy.isinf "numpy.isinf")(x, /[, out, where, casting, order, ...])
    | Test element-wise for positive or negative infinity. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnan`](generated/numpy.isnan.html#numpy.isnan "numpy.isnan")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaN and return result as a boolean array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isnat`](generated/numpy.isnat.html#numpy.isnat "numpy.isnat")(x, /[, out, where, casting, order, ...])
    | Test element-wise for NaT (not a time) and return result as a boolean array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`fabs`](generated/numpy.fabs.html#numpy.fabs "numpy.fabs")(x, /[, out, where, casting, order, ...])
    | Compute the absolute values element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`signbit`](generated/numpy.signbit.html#numpy.signbit "numpy.signbit")(x, /[, out, where, casting, order, ...])
    | Returns element-wise True where signbit is set (less than zero). |'
  prefs: []
  type: TYPE_TB
- en: '| [`copysign`](generated/numpy.copysign.html#numpy.copysign "numpy.copysign")(x1, x2, /[, out, where, casting, ...])
    | Change the sign of x1 to that of x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`nextafter`](generated/numpy.nextafter.html#numpy.nextafter "numpy.nextafter")(x1, x2, /[, out, where, casting, ...])
    | Return the next floating-point value after x1 towards x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`spacing`](generated/numpy.spacing.html#numpy.spacing "numpy.spacing")(x, /[, out, where, casting, order, ...])
    | Return the distance between x and the nearest adjacent number. |'
  prefs: []
  type: TYPE_TB
- en: '| [`modf`](generated/numpy.modf.html#numpy.modf "numpy.modf")(x[, out1, out2], / [[, out, where, ...])
    | Return the fractional and integral parts of an array, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ldexp`](generated/numpy.ldexp.html#numpy.ldexp "numpy.ldexp")(x1, x2, /[, out, where, casting, ...])
    | Returns x1 * 2**x2, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`frexp`](generated/numpy.frexp.html#numpy.frexp "numpy.frexp")(x[, out1, out2], / [[, out, where, ...])
    | Decompose the elements of x into mantissa and twos exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmod`](generated/numpy.fmod.html#numpy.fmod "numpy.fmod")(x1, x2, /[, out, where, casting, ...])
    | Returns the element-wise remainder of division. |'
  prefs: []
  type: TYPE_TB
- en: '| [`floor`](generated/numpy.floor.html#numpy.floor "numpy.floor")(x, /[, out, where, casting, order, ...])
    | Return the floor of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ceil`](generated/numpy.ceil.html#numpy.ceil "numpy.ceil")(x, /[, out, where, casting, order, ...])
    | Return the ceiling of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
- en: '| [`trunc`](generated/numpy.trunc.html#numpy.trunc "numpy.trunc")(x, /[, out, where, casting, order, ...])
    | Return the truncated value of the input, element-wise. |'
  prefs: []
  type: TYPE_TB
