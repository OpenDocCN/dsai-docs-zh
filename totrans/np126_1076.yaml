- en: NumPy core libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/coremath.html](https://numpy.org/doc/1.26/reference/c-api/coremath.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Starting from numpy 1.3.0, we are working on separating the pure C, “computational”
    code from the python dependent code. The goal is twofolds: making the code cleaner,
    and enabling code reuse by other extensions outside numpy (scipy, etc…).'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy core math library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The numpy core math library (‘npymath’) is a first step in this direction. This
    library contains most math-related C99 functionality, which can be used on platforms
    where C99 is not well supported. The core math functions have the same API as
    the C99 ones, except for the `npy_*` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The available functions are defined in `<numpy/npy_math.h>` - please refer to
    this header when in doubt.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An effort is underway to make `npymath` smaller (since C99 compatibility of
    compilers has improved over time) and more easily vendorable or usable as a header-only
    dependency. That will avoid problems with shipping a static library built with
    a compiler which may not match the compiler used by a downstream package or end
    user. See [gh-20880](https://github.com/numpy/numpy/issues/20880) for details.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point classification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN (Not a Number), and is guaranteed to have the
    signbit unset (‘positive’ NaN). The corresponding single and extension precision
    macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a positive inf. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero (that is with the sign bit set). The
    corresponding single and extension precision macro are available with the suffix
    F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isnan: works for single, double and extended precision,
    and return a non 0 value if x is a NaN.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isfinite: works for single, double and extended precision,
    and return a non 0 value if x is neither a NaN nor an infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isinf: works for single, double and extended precision,
    and return a non 0 value if x is infinite (positive and negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 signbit: works for single, double and extended precision,
    and return a non 0 value if x has the signbit set (that is the number is negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 copysign: return x with the same sign as y. Works
    for any value, including inf and nan. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: Useful math constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following math constants are available in `npy_math.h`. Single and extended
    precision are also available by adding the `f` and `l` suffixes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Base of natural logarithm (\(e\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 2 of the Euler constant (\(\frac{\ln(e)}{\ln(2)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 10 of the Euler constant (\(\frac{\ln(e)}{\ln(10)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 2 (\(\ln(2)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 10 (\(\ln(10)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Pi (\(\pi\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 2 (\(\frac{\pi}{2}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 4 (\(\frac{\pi}{4}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Reciprocal of pi (\(\frac{1}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Two times the reciprocal of pi (\(\frac{2}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Euler constant
  prefs: []
  type: TYPE_NORMAL
- en: \(\lim_{n\rightarrow\infty}({\sum_{k=1}^n{\frac{1}{k}}-\ln n})\)
  prefs: []
  type: TYPE_NORMAL
- en: Low-level floating point manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those can be useful for precise floating point comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias to C99 nextafter: return next representable floating point
    value from x in the direction of y. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a function equivalent to Fortran intrinsic. Return distance between
    x and next representable floating point value from x, e.g. spacing(1) == eps.
    spacing of nan and +/- inf return nan. Single and extended precisions are available
    with suffix f and l.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Set the divide by zero floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Set the overflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Set the underflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Set the invalid floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Get floating point status. Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that [`npy_get_floatstatus_barrier`](#c.npy_get_floatstatus_barrier "npy_get_floatstatus_barrier")
    is preferable as it prevents aggressive compiler optimizations reordering the
    call relative to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Get floating point status. A pointer to a local variable is passed in to prevent
    aggressive compiler optimizations from reordering this function call relative
    to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`npy_clear_floatstatus_barrier`](#c.npy_clear_floatstatus_barrier
    "npy_clear_floatstatus_barrier") is preferable as it prevents aggressive compiler
    optimizations reordering the call relative to the code setting the status, which
    could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. A pointer to a local variable is passed in
    to prevent aggressive compiler optimizations from reordering this function call.
    Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: Complex functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C99-like complex functions have been added. Those can be used if you wish to
    implement portable C extensions. Since we still support platforms without C99
    complex type (most importantly Windows, where MSVC doesn’t support C99 complex
    types as of Nov 2022), you need to restrict to C90-compatible syntax, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '### Linking against the core math library in an extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the core math library that NumPy ships as a static library in your own
    Python extension, you need to add the npymath compile and link options to your
    extension. The exact steps to take will depend on the build system you are using.
    The generic steps to take are:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the numpy include directory (= the value of `np.get_include()`) to your
    include directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `npymath` static library resides in the `lib` directory right next to numpy’s
    include directory (i.e., `pathlib.Path(np.get_include()) / '..' / 'lib'`). Add
    that to your library search directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link with `libnpymath` and `libm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when you are cross compiling, you must use the `numpy` for
    the platform you are building for, not the native one for the build machine. Otherwise
    you pick up a static library built for the wrong architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build with `numpy.distutils` (deprecated), then use this in your `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: In other words, the usage of `info` is exactly the same as when using `blas_info`
    and co.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are building with [Meson](https://mesonbuild.com), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The header file `<numpy/halffloat.h>` provides functions to work with IEEE 754-2008
    16-bit floating point values. While this format is not typically used for numerical
    computations, it is useful for storing values which require floating point but
    do not need much precision. It can also be used as an educational tool to understand
    the nature of floating point round-off error.
  prefs: []
  type: TYPE_NORMAL
- en: Like for other types, NumPy includes a typedef npy_half for the 16 bit float.
    Unlike for most of the other types, you cannot use this as a normal type in C,
    since it is a typedef for npy_uint16\. For example, 1.0 looks like 0x3c00 to C,
    and if you do an equality comparison between the different signed zeros, you will
    get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, NumPy provides an API to work with npy_half values accessible
    by including `<numpy/halffloat.h>` and linking to `npymath`. For functions that
    are not provided directly, such as the arithmetic operations, the preferred method
    is to convert to float or double and back again, as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'External Links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[754-2008 IEEE Standard for Floating-Point Arithmetic](https://ieeexplore.ieee.org/document/4610935/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Half-precision Float Wikipedia Article](https://en.wikipedia.org/wiki/Half-precision_floating-point_format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenGL Half Float Pixel Support](https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_half_float_pixel.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The OpenEXR image format](https://www.openexr.com/about.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to +inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN value, guaranteed to have its sign bit unset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a single-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a double-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Converts a single-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Converts a double-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 == h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 != h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 <= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 < h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 >= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 > h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 == h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 < h2). If
    a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 <= h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float has a value equal to zero. This may be
    slightly faster than calling npy_half_eq(h, NPY_ZERO).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is a NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is plus or minus Inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is finite (not NaN or Inf).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 is h is negative, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Returns the value of x with the sign bit copied from y. Works for any value,
    including Inf and NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_spacing and npy_spacingf described
    in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_nextafter and npy_nextafterf
    described in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 32-bit single-precision float, stored as
    a uint32, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 64-bit double-precision float, stored as
    a uint64, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 32-bit
    single-precision float, stored as a uint32.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 64-bit
    double-precision float, stored as a uint64.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy core math library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The numpy core math library (‘npymath’) is a first step in this direction. This
    library contains most math-related C99 functionality, which can be used on platforms
    where C99 is not well supported. The core math functions have the same API as
    the C99 ones, except for the `npy_*` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The available functions are defined in `<numpy/npy_math.h>` - please refer to
    this header when in doubt.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An effort is underway to make `npymath` smaller (since C99 compatibility of
    compilers has improved over time) and more easily vendorable or usable as a header-only
    dependency. That will avoid problems with shipping a static library built with
    a compiler which may not match the compiler used by a downstream package or end
    user. See [gh-20880](https://github.com/numpy/numpy/issues/20880) for details.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point classification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN (Not a Number), and is guaranteed to have the
    signbit unset (‘positive’ NaN). The corresponding single and extension precision
    macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a positive inf. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero (that is with the sign bit set). The
    corresponding single and extension precision macro are available with the suffix
    F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isnan: works for single, double and extended precision,
    and return a non 0 value if x is a NaN.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isfinite: works for single, double and extended precision,
    and return a non 0 value if x is neither a NaN nor an infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isinf: works for single, double and extended precision,
    and return a non 0 value if x is infinite (positive and negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 signbit: works for single, double and extended precision,
    and return a non 0 value if x has the signbit set (that is the number is negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 copysign: return x with the same sign as y. Works
    for any value, including inf and nan. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: Useful math constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following math constants are available in `npy_math.h`. Single and extended
    precision are also available by adding the `f` and `l` suffixes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Base of natural logarithm (\(e\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 2 of the Euler constant (\(\frac{\ln(e)}{\ln(2)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 10 of the Euler constant (\(\frac{\ln(e)}{\ln(10)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 2 (\(\ln(2)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 10 (\(\ln(10)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Pi (\(\pi\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 2 (\(\frac{\pi}{2}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 4 (\(\frac{\pi}{4}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Reciprocal of pi (\(\frac{1}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Two times the reciprocal of pi (\(\frac{2}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The Euler constant
  prefs: []
  type: TYPE_NORMAL
- en: \(\lim_{n\rightarrow\infty}({\sum_{k=1}^n{\frac{1}{k}}-\ln n})\)
  prefs: []
  type: TYPE_NORMAL
- en: Low-level floating point manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those can be useful for precise floating point comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias to C99 nextafter: return next representable floating point
    value from x in the direction of y. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This is a function equivalent to Fortran intrinsic. Return distance between
    x and next representable floating point value from x, e.g. spacing(1) == eps.
    spacing of nan and +/- inf return nan. Single and extended precisions are available
    with suffix f and l.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Set the divide by zero floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Set the overflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Set the underflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Set the invalid floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Get floating point status. Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that [`npy_get_floatstatus_barrier`](#c.npy_get_floatstatus_barrier "npy_get_floatstatus_barrier")
    is preferable as it prevents aggressive compiler optimizations reordering the
    call relative to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Get floating point status. A pointer to a local variable is passed in to prevent
    aggressive compiler optimizations from reordering this function call relative
    to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`npy_clear_floatstatus_barrier`](#c.npy_clear_floatstatus_barrier
    "npy_clear_floatstatus_barrier") is preferable as it prevents aggressive compiler
    optimizations reordering the call relative to the code setting the status, which
    could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. A pointer to a local variable is passed in
    to prevent aggressive compiler optimizations from reordering this function call.
    Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: Complex functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C99-like complex functions have been added. Those can be used if you wish to
    implement portable C extensions. Since we still support platforms without C99
    complex type (most importantly Windows, where MSVC doesn’t support C99 complex
    types as of Nov 2022), you need to restrict to C90-compatible syntax, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '### Linking against the core math library in an extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the core math library that NumPy ships as a static library in your own
    Python extension, you need to add the npymath compile and link options to your
    extension. The exact steps to take will depend on the build system you are using.
    The generic steps to take are:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the numpy include directory (= the value of `np.get_include()`) to your
    include directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `npymath` static library resides in the `lib` directory right next to numpy’s
    include directory (i.e., `pathlib.Path(np.get_include()) / '..' / 'lib'`). Add
    that to your library search directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link with `libnpymath` and `libm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when you are cross compiling, you must use the `numpy` for
    the platform you are building for, not the native one for the build machine. Otherwise
    you pick up a static library built for the wrong architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build with `numpy.distutils` (deprecated), then use this in your `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: In other words, the usage of `info` is exactly the same as when using `blas_info`
    and co.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are building with [Meson](https://mesonbuild.com), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The header file `<numpy/halffloat.h>` provides functions to work with IEEE 754-2008
    16-bit floating point values. While this format is not typically used for numerical
    computations, it is useful for storing values which require floating point but
    do not need much precision. It can also be used as an educational tool to understand
    the nature of floating point round-off error.
  prefs: []
  type: TYPE_NORMAL
- en: Like for other types, NumPy includes a typedef npy_half for the 16 bit float.
    Unlike for most of the other types, you cannot use this as a normal type in C,
    since it is a typedef for npy_uint16\. For example, 1.0 looks like 0x3c00 to C,
    and if you do an equality comparison between the different signed zeros, you will
    get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, NumPy provides an API to work with npy_half values accessible
    by including `<numpy/halffloat.h>` and linking to `npymath`. For functions that
    are not provided directly, such as the arithmetic operations, the preferred method
    is to convert to float or double and back again, as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'External Links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[754-2008 IEEE Standard for Floating-Point Arithmetic](https://ieeexplore.ieee.org/document/4610935/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Half-precision Float Wikipedia Article](https://en.wikipedia.org/wiki/Half-precision_floating-point_format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenGL Half Float Pixel Support](https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_half_float_pixel.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The OpenEXR image format](https://www.openexr.com/about.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to +inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN value, guaranteed to have its sign bit unset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a single-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a double-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Converts a single-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Converts a double-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 == h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 != h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 <= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 < h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 >= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 > h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 == h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 < h2). If
    a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 <= h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float has a value equal to zero. This may be
    slightly faster than calling npy_half_eq(h, NPY_ZERO).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is a NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is plus or minus Inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is finite (not NaN or Inf).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 is h is negative, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Returns the value of x with the sign bit copied from y. Works for any value,
    including Inf and NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_spacing and npy_spacingf described
    in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_nextafter and npy_nextafterf
    described in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 32-bit single-precision float, stored as
    a uint32, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 64-bit double-precision float, stored as
    a uint64, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 32-bit
    single-precision float, stored as a uint32.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 64-bit
    double-precision float, stored as a uint64.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point classification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN (Not a Number), and is guaranteed to have the
    signbit unset (‘positive’ NaN). The corresponding single and extension precision
    macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a positive inf. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero. The corresponding single and extension
    precision macro are available with the suffix F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero (that is with the sign bit set). The
    corresponding single and extension precision macro are available with the suffix
    F and L.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isnan: works for single, double and extended precision,
    and return a non 0 value if x is a NaN.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isfinite: works for single, double and extended precision,
    and return a non 0 value if x is neither a NaN nor an infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 isinf: works for single, double and extended precision,
    and return a non 0 value if x is infinite (positive and negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 signbit: works for single, double and extended precision,
    and return a non 0 value if x has the signbit set (that is the number is negative).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias for C99 copysign: return x with the same sign as y. Works
    for any value, including inf and nan. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: Useful math constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following math constants are available in `npy_math.h`. Single and extended
    precision are also available by adding the `f` and `l` suffixes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Base of natural logarithm (\(e\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 2 of the Euler constant (\(\frac{\ln(e)}{\ln(2)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Logarithm to base 10 of the Euler constant (\(\frac{\ln(e)}{\ln(10)}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 2 (\(\ln(2)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Natural logarithm of 10 (\(\ln(10)\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Pi (\(\pi\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 2 (\(\frac{\pi}{2}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Pi divided by 4 (\(\frac{\pi}{4}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Reciprocal of pi (\(\frac{1}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Two times the reciprocal of pi (\(\frac{2}{\pi}\))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The Euler constant
  prefs: []
  type: TYPE_NORMAL
- en: \(\lim_{n\rightarrow\infty}({\sum_{k=1}^n{\frac{1}{k}}-\ln n})\)
  prefs: []
  type: TYPE_NORMAL
- en: Low-level floating point manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those can be useful for precise floating point comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an alias to C99 nextafter: return next representable floating point
    value from x in the direction of y. Single and extended precisions are available
    with suffix f and l.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: This is a function equivalent to Fortran intrinsic. Return distance between
    x and next representable floating point value from x, e.g. spacing(1) == eps.
    spacing of nan and +/- inf return nan. Single and extended precisions are available
    with suffix f and l.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Set the divide by zero floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Set the overflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Set the underflow floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Set the invalid floating point exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Get floating point status. Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that [`npy_get_floatstatus_barrier`](#c.npy_get_floatstatus_barrier "npy_get_floatstatus_barrier")
    is preferable as it prevents aggressive compiler optimizations reordering the
    call relative to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Get floating point status. A pointer to a local variable is passed in to prevent
    aggressive compiler optimizations from reordering this function call relative
    to the code setting the status, which could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a bitmask with following possible flags:'
  prefs: []
  type: TYPE_NORMAL
- en: NPY_FPE_DIVIDEBYZERO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_OVERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_UNDERFLOW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPY_FPE_INVALID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [`npy_clear_floatstatus_barrier`](#c.npy_clear_floatstatus_barrier
    "npy_clear_floatstatus_barrier") is preferable as it prevents aggressive compiler
    optimizations reordering the call relative to the code setting the status, which
    could lead to incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Clears the floating point status. A pointer to a local variable is passed in
    to prevent aggressive compiler optimizations from reordering this function call.
    Returns the previous status mask.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: Complex functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C99-like complex functions have been added. Those can be used if you wish to
    implement portable C extensions. Since we still support platforms without C99
    complex type (most importantly Windows, where MSVC doesn’t support C99 complex
    types as of Nov 2022), you need to restrict to C90-compatible syntax, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '### Linking against the core math library in an extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the core math library that NumPy ships as a static library in your own
    Python extension, you need to add the npymath compile and link options to your
    extension. The exact steps to take will depend on the build system you are using.
    The generic steps to take are:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the numpy include directory (= the value of `np.get_include()`) to your
    include directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `npymath` static library resides in the `lib` directory right next to numpy’s
    include directory (i.e., `pathlib.Path(np.get_include()) / '..' / 'lib'`). Add
    that to your library search directories,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link with `libnpymath` and `libm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when you are cross compiling, you must use the `numpy` for
    the platform you are building for, not the native one for the build machine. Otherwise
    you pick up a static library built for the wrong architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you build with `numpy.distutils` (deprecated), then use this in your `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: In other words, the usage of `info` is exactly the same as when using `blas_info`
    and co.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are building with [Meson](https://mesonbuild.com), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The header file `<numpy/halffloat.h>` provides functions to work with IEEE 754-2008
    16-bit floating point values. While this format is not typically used for numerical
    computations, it is useful for storing values which require floating point but
    do not need much precision. It can also be used as an educational tool to understand
    the nature of floating point round-off error.
  prefs: []
  type: TYPE_NORMAL
- en: Like for other types, NumPy includes a typedef npy_half for the 16 bit float.
    Unlike for most of the other types, you cannot use this as a normal type in C,
    since it is a typedef for npy_uint16\. For example, 1.0 looks like 0x3c00 to C,
    and if you do an equality comparison between the different signed zeros, you will
    get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, NumPy provides an API to work with npy_half values accessible
    by including `<numpy/halffloat.h>` and linking to `npymath`. For functions that
    are not provided directly, such as the arithmetic operations, the preferred method
    is to convert to float or double and back again, as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'External Links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[754-2008 IEEE Standard for Floating-Point Arithmetic](https://ieeexplore.ieee.org/document/4610935/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Half-precision Float Wikipedia Article](https://en.wikipedia.org/wiki/Half-precision_floating-point_format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenGL Half Float Pixel Support](https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_half_float_pixel.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The OpenEXR image format](https://www.openexr.com/about.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to positive zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to negative zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to +inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to -inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: This macro is defined to a NaN value, guaranteed to have its sign bit unset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a single-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Converts a half-precision float to a double-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Converts a single-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Converts a double-precision float to a half-precision float. The value is rounded
    to the nearest representable half, with ties going to the nearest even. If the
    value is too small or too big, the system’s floating point underflow or overflow
    bit will be set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 == h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 != h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 <= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 < h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 >= h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats (h1 > h2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 == h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 < h2). If
    a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Compares two half-precision floats that are known to not be NaN (h1 <= h2).
    If a value is NaN, the result is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float has a value equal to zero. This may be
    slightly faster than calling npy_half_eq(h, NPY_ZERO).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is a NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is plus or minus Inf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the half-precision float is finite (not NaN or Inf).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 is h is negative, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Returns the value of x with the sign bit copied from y. Works for any value,
    including Inf and NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_spacing and npy_spacingf described
    in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: This is the same for half-precision float as npy_nextafter and npy_nextafterf
    described in the low-level floating point section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 32-bit single-precision float, stored as
    a uint32, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 64-bit double-precision float, stored as
    a uint64, into a 16-bit half-precision float.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 32-bit
    single-precision float, stored as a uint32.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Low-level function which converts a 16-bit half-precision float into a 64-bit
    double-precision float, stored as a uint64.
  prefs: []
  type: TYPE_NORMAL
