- en: Array API Standard Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/array_api.html](https://numpy.org/doc/1.26/reference/array_api.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `numpy.array_api` module is still experimental. See [NEP 47](https://numpy.org/neps/nep-0047-array-api-standard.html).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy includes a reference implementation of the [array API standard](https://data-apis.org/array-api/latest/)
    in `numpy.array_api`. [NEP 47](https://numpy.org/neps/nep-0047-array-api-standard.html)
    describes the motivation and scope for implementing the array API standard in
    NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: The `numpy.array_api` module serves as a minimal, reference implementation of
    the array API standard. In being minimal, the module only implements those things
    that are explicitly required by the specification. Certain things are allowed
    by the specification but are explicitly disallowed in `numpy.array_api`. This
    is so that the module can serve as a reference implementation for users of the
    array API standard. Any consumer of the array API can test their code against
    `numpy.array_api` and be sure that they aren’t using any features that aren’t
    guaranteed by the spec, and which may not be present in other conforming libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The `numpy.array_api` module is not documented here. For a listing of the functions
    present in the array API specification, refer to the [array API standard](https://data-apis.org/array-api/latest/).
    The `numpy.array_api` implementation is functionally complete, so all functionality
    described in the standard is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '## Table of Differences between `numpy.array_api` and `numpy`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This table outlines the primary differences between `numpy.array_api` from
    the main `numpy` namespace. There are three types of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strictness**. Things that are only done so that `numpy.array_api` is a strict,
    minimal implementation. They aren’t actually required by the spec, and other conforming
    libraries may not follow them. In most cases, spec does not specify or require
    any behavior outside of the given domain. The main `numpy` namespace would not
    need to change in any way to be spec-compatible for these.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compatible**. Things that could be added to the main `numpy` namespace without
    breaking backwards compatibility.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Breaking**. Things that would break backwards compatibility if implemented
    in the main `numpy` namespace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many functions have been renamed in the spec from NumPy. These are otherwise
    identical in behavior, and are thus all **compatible** changes, unless otherwise
    noted.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Function Name Changes'
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are named differently in the array API
  prefs: []
  type: TYPE_NORMAL
- en: '| Array API name | NumPy namespace name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | `arccos` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | `arccosh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` | `arcsin` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` | `arcsinh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` | `arctan` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` | `arctan2` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` | `arctanh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` | `left_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | `invert` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` | `right_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool_` | This is **breaking** because `np.bool` is currently a
    deprecated alias for the built-in `bool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | `concatenate` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` and `vector_norm` | `norm` | `matrix_norm` and `vector_norm`
    each do a limited subset of what `np.norm` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `permute_dims` | `transpose` | Unlike `np.transpose`, the `axis` keyword-argument
    to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` | `power` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values` | `unique`
    | Each is equivalent to `np.unique` with certain flags set. |'
  prefs: []
  type: TYPE_TB
- en: Function instead of method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`astype` is a function in the array API, whereas it is a method on `ndarray`
    in `numpy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linalg` Namespace Differences'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These functions are in the `linalg` sub-namespace in the array API, but are
    only in the top-level namespace in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diagonal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matmul` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensordot` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(*): These functions are also in the top-level namespace in the array API.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Argument Renames
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following functions have keyword arguments that have been renamed. The functionality
    of the keyword argument is identical unless otherwise stated. Renamed keyword
    arguments with the same semantic definition may be considered either **compatible**
    or **breaking**, depending on how the change is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Note, this page does not list function keyword arguments that are in the main
    `numpy` namespace but not in the array API. Such keyword arguments are omitted
    from `numpy.array_api` for **strictness**, as the spec allows functions to include
    additional keyword arguments from those required.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Array API keyword name | NumPy keyword name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` | `stable` | `kind` | The definitions of `stable` and
    `kind` differ, as do the default values. The change of the default value makes
    this **breaking**. See [Set Functions Differences](#array-api-set-functions-differences).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | `rtol` | `tol` | The definitions of `rtol` and `tol` differ,
    as do the default values. The change of the default value makes this **breaking**.
    See [Linear Algebra Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | `rtol` | `rcond` | The definitions of `rtol` and `rcond` are the
    same, but their default values differ, making this **breaking**. See [Linear Algebra
    Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `std` and `var` | `correction` | `ddof` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` | `shape` | `newshape` | The argument may be passed as a positional
    or keyword argument for both NumPy and the array API. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Promotion Differences'
  prefs: []
  type: TYPE_NORMAL
- en: Type promotion is the biggest area where NumPy deviates from the spec. The most
    notable difference is that NumPy does value-based casting in many cases. The spec
    explicitly disallows value-based casting. In the array API, the result type of
    any operation is always determined entirely by the input types, independently
    of values or shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Limited set of dtypes. | **Strictness** | `numpy.array_api` only implements
    those [dtypes that are required by the spec](https://data-apis.org/array-api/latest/API_specification/data_types.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars only accept matching scalar types.
    | **Strictness** | For example, `<int32 array> + 1.0` is not allowed. See [the
    spec rules for mixing arrays and Python scalars](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars always return the same dtype as
    the array. | **Breaking** | For example, `numpy.array_api.asarray(0., dtype=float32)
    + 1e64` is a `float32` array. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the left-hand side would be promoted.
    | **Breaking** | Example: `a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`.
    The spec explicitly disallows this. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the right-hand side operand cannot
    broadcast to the shape of the left-hand side operand. | **Strictness** | This
    so-called “reverse broadcasting” should not be allowed. Example: `a = np.empty((2,
    3, 4)); a += np.empty((3, 4))` should error. See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` promotion for operators is only specified for integers within the bounds
    of the dtype. | **Strictness** | `numpy.array_api` fallsback to `np.ndarray` behavior
    (either cast or raise `OverflowError`). |'
  prefs: []
  type: TYPE_TB
- en: '| `__pow__` and `__rpow__` do not do value-based casting for 0-D arrays. |
    **Breaking** | For example, `np.array(0., dtype=float32)**np.array(0., dtype=float64)`
    is `float32`. Note that this is value-based casting on 0-D arrays, not scalars.
    |'
  prefs: []
  type: TYPE_TB
- en: '| No cross-kind casting. | **Strictness** | Namely, boolean, integer, and floating-point
    data types do not cast to each other, except explicitly with `astype` (this is
    separate from the behavior with Python scalars). |'
  prefs: []
  type: TYPE_TB
- en: '| No casting unsigned integer dtypes to floating dtypes (e.g., `int64 + uint64
    -> float64`. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `can_cast` and `result_type` are restricted. | **Strictness** | The `numpy.array_api`
    implementations disallow cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: Indexing Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The spec requires only a subset of indexing, but all indexing rules in the spec
    are compatible with NumPy’s more broad indexing rules.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No implicit ellipses (`...`). | **Strictness** | If an index does not include
    an ellipsis, all axes must be indexed. |'
  prefs: []
  type: TYPE_TB
- en: '| The start and stop of a slice may not be out of bounds. | **Strictness**
    | For a slice `i:j:k`, only the following are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` or `j` omitted (`None`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n <= i <= max(0, n - 1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k > 0` or `k` omitted (`None`), `-n <= j <= n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k < 0`, `-n - 1 <= j <= max(0, n - 1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Boolean array indices are only allowed as the sole index. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| Integer array indices are not allowed at all. | **Strictness** | With the
    exception of 0-D arrays, which are treated like integers. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Strictness'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in `numpy.array_api` restrict their inputs to only those dtypes that
    are explicitly required by the spec, even when the wrapped corresponding NumPy
    function would allow a broader set. Here, we list each function and the dtypes
    that are allowed in `numpy.array_api`. These are **strictness** differences because
    the spec does not require that other dtypes result in an error. The categories
    here are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point**: `float32` or `float64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer**: Any signed or unsigned integer dtype (`int8`, `int16`, `int32`,
    `int64`, `uint8`, `uint16`, `uint32`, or `uint64`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean**: `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer or boolean**: Any signed or unsigned integer dtype, or `bool`. For
    two-argument functions, both arguments must be integer or both must be `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numeric**: Any integer or floating-point dtype. For two-argument functions,
    both arguments must be integer or both must be floating-point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All**: Any of the above dtype categories. For two-argument functions, both
    arguments must be the same kind (integer, floating-point, or boolean).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, the return dtype is chosen according to [the rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html),
    and does not differ from NumPy’s return dtype for any of the allowed input dtypes,
    except in the cases mentioned specifically in the subsections below.
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_and` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_or` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_xor` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `cos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `expm1` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isfinite` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isinf` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logaddexp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log10` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log1p` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log2` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_and` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_not` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_or` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_xor` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `negative` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `positive` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` (*) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `remainder` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sin` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `square` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tanh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `trunc` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions have different names from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: Creation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `meshgrid` | Any (all input dtypes must be the same) |'
  prefs: []
  type: TYPE_TB
- en: Linear Algebra Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `det` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `eighvals` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `inv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matmul` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_power` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_transpose` (**) | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `qr` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `slogdet` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svd` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svdvals` (**) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tensordot` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vecdot` (**) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vector_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions are split from `norm` from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: (**) These functions are new in the array API and are not in the main `numpy`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Array Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the special `__operator__` methods on the array object behave identically
    to their corresponding functions (see [the spec](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)
    for a list of which methods correspond to which functions). The exception is that
    operators explicitly allow Python scalars according to the [rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)
    (see [Type Promotion Differences](#array-api-type-promotion-differences)).
  prefs: []
  type: TYPE_NORMAL
- en: Array Object Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No array scalars | **Strictness** | The spec does not have array scalars,
    only 0-D arrays. However, other than the promotion differences outlined in [Type
    Promotion Differences](#array-api-type-promotion-differences), scalars duck type
    as 0-D arrays for the purposes of the spec. The are immutable, but the spec [does
    not require mutability](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bool()`, `int()`, and `float()` only work on 0-D arrays. | **Strictness**
    | See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__imatmul__` | **Compatible** | `np.ndarray` does not currently implement
    `__imatmul`. Note that `a @= b` should only defined when it does not change the
    shape of `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `mT` attribute for matrix transpose. | **Compatible** | See [the spec
    definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html)
    for `mT`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `T` attribute should error if the input is not 2-dimensional. | **Breaking**
    | See [the note in the spec](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| New method `to_device` and attribute `device` | **Compatible** | The methods
    would effectively not do anything since NumPy is CPU only |'
  prefs: []
  type: TYPE_TB
- en: Creation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` keyword argument to `asarray` | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New `device` keyword argument to all array creation functions (`asarray`,
    `arange`, `empty`, `empty_like`, `eye`, `full`, `full_like`, `linspace`, `ones`,
    `ones_like`, `zeros`, and `zeros_like`). | **Compatible** | `device` would effectively
    do nothing, since NumPy is CPU only. |'
  prefs: []
  type: TYPE_TB
- en: Elementwise Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed. | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| Elementwise functions are only defined for given input type combinations.
    | **Strictness** | See [Type Strictness](#array-api-type-strictness). |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` and `bitwise_right_shift` are only defined for `x2`
    nonnegative. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil`, `floor`, and `trunc` return an integer with integer input. | **Breaking**
    | `np.ceil`, `np.floor`, and `np.trunc` return a floating-point dtype on integer
    dtype input. |'
  prefs: []
  type: TYPE_TB
- en: '### Linear Algebra Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` includes an `upper` keyword argument. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` does not allow size 2 vectors (only size 3). | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` operates on the last two axes. | **Breaking** | Strictly speaking
    this can be **compatible** because `diagonal` is moved to the `linalg` namespace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh`, `qr`, `slogdet` and `svd` return a named tuple. | **Compatible**
    | The corresponding `numpy` functions return a `tuple`, with the resulting arrays
    in the same order. |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `matrix_norm` and `vector_norm`. | **Compatible** | The `norm`
    function has been omitted from the array API and split into `matrix_norm` for
    matrix norms and `vector_norm` for vector norms. Note that `vector_norm` supports
    any number of axes, whereas `np.linalg.norm` only supports a single axis for vector
    norms. |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` has an `rtol` keyword argument instead of `tol`. | **Breaking**
    | In the array API, `rtol` filters singular values smaller than `rtol * largest_singular_value`.
    In `np.linalg.matrix_rank`, `tol` filters singular values smaller than `tol`.
    Furthermore, the default value for `rtol` is `max(M, N) * eps`, whereas the default
    value of `tol` in `np.linalg.matrix_rank` is `S.max() * max(M, N) * eps`, where
    `S` is the singular values of the input. The new flag name is compatible but the
    default change is breaking |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` does not support 1-dimensional arrays. | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New function `matrix_transpose`. | **Compatible** | Unlike `np.transpose`,
    `matrix_transpose` only transposes the last two axes. See [the spec definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` only supports 1-dimensional arrays. | **Breaking** | The spec currently
    only specifies behavior on 1-D arrays but future behavior will likely be to broadcast,
    rather than flatten, which is what `np.outer` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` has an `rtol` keyword argument instead of `rcond` | **Breaking** |
    The meaning of `rtol` and `rcond` is the same, but the default value for `rtol`
    is `max(M, N) * eps`, whereas the default value for `rcond` is `1e-15`. The new
    flag name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` only accepts `x2` as a vector when it is exactly 1-dimensional. |
    **Breaking** | The `np.linalg.solve` behavior is ambiguous. See [this numpy issue](https://github.com/numpy/numpy/issues/15349)
    and [this array API specification issue](https://github.com/data-apis/array-api/issues/285)
    for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `svdvals`. | **Compatible** | Equivalent to `np.linalg.svd(compute_uv=False)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| The `axis` keyword to `tensordot` must be a tuple. | **Compatible** | In
    `np.tensordot`, it can also be an array or array-like. |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` operates on the last two axes. | **Breaking** | `np.trace` operates
    on the first two axes by default. Note that the array API `trace` does not allow
    specifying which axes to operate on. |'
  prefs: []
  type: TYPE_TB
- en: Manipulation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` has different default casting rules from `np.concatenate` | **Strictness**
    | No cross-kind casting. No value-based casting on scalars (when axis=None). |'
  prefs: []
  type: TYPE_TB
- en: '| `stack` has different default casting rules from `np.stack` | **Strictness**
    | No cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `permute_dims`. | **Compatible** | Unlike `np.transpose`, the
    `axis` keyword argument to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` function has a `copy` keyword argument | **Compatible** | See [https://github.com/numpy/numpy/issues/9818](https://github.com/numpy/numpy/issues/9818).
    |'
  prefs: []
  type: TYPE_TB
- en: Set Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values`.
    | **Compatible** | See [Function Name Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| The four `unique_*` functions return a named tuple. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all` and `unique_indices` return indices with the same shape as `x`.
    | **Compatible** | See [https://github.com/numpy/numpy/issues/20638](https://github.com/numpy/numpy/issues/20638).
    |'
  prefs: []
  type: TYPE_TB
- en: '### Set Functions Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `stable` keyword argument instead of `kind`.
    | **Breaking** | `stable` is a boolean keyword argument, defaulting to `True`.
    `kind` takes a string, defaulting to `"quicksort"`. `stable=True` is equivalent
    to `kind="stable"` and `kind=False` is equivalent to `kind="quicksort"`, although
    any sorting algorithm is allowed by the spec when `stable=False`. The new flag
    name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `descending` keyword argument. | **Compatible**
    |  |'
  prefs: []
  type: TYPE_TB
- en: Statistical Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| The `std` and `var` functions have a `correction` keyword argument instead
    of `ddof`. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: Other Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dtypes can only be spelled as dtype objects. | **Strictness** | For example,
    `numpy.array_api.asarray([0], dtype=''int32'')` is not allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `asarray` is not implicitly called in any function. | **Strictness** | The
    exception is Python operators, which accept Python scalars in certain cases (see
    [Type Promotion Differences](#array-api-type-promotion-differences)). |'
  prefs: []
  type: TYPE_TB
- en: '| `tril` and `triu` require the input to be at least 2-D. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| finfo() return type uses `float` for the various attributes. | **Strictness**
    | The spec allows duck typing, so `finfo` returning dtype scalars is considered
    type compatible with `float`. |'
  prefs: []
  type: TYPE_TB
- en: '| Positional arguments in every function are positional-only. | **Breaking**
    | See the spec for the exact signature of each function. Note that NumPy ufuncs
    already use positional-only arguments, but non-ufuncs like `asarray` generally
    do not. |  ## Table of Differences between `numpy.array_api` and `numpy`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This table outlines the primary differences between `numpy.array_api` from
    the main `numpy` namespace. There are three types of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strictness**. Things that are only done so that `numpy.array_api` is a strict,
    minimal implementation. They aren’t actually required by the spec, and other conforming
    libraries may not follow them. In most cases, spec does not specify or require
    any behavior outside of the given domain. The main `numpy` namespace would not
    need to change in any way to be spec-compatible for these.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compatible**. Things that could be added to the main `numpy` namespace without
    breaking backwards compatibility.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Breaking**. Things that would break backwards compatibility if implemented
    in the main `numpy` namespace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many functions have been renamed in the spec from NumPy. These are otherwise
    identical in behavior, and are thus all **compatible** changes, unless otherwise
    noted.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Function Name Changes'
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are named differently in the array API
  prefs: []
  type: TYPE_NORMAL
- en: '| Array API name | NumPy namespace name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | `arccos` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | `arccosh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` | `arcsin` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` | `arcsinh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` | `arctan` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` | `arctan2` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` | `arctanh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` | `left_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | `invert` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` | `right_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool_` | This is **breaking** because `np.bool` is currently a
    deprecated alias for the built-in `bool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | `concatenate` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` and `vector_norm` | `norm` | `matrix_norm` and `vector_norm`
    each do a limited subset of what `np.norm` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `permute_dims` | `transpose` | Unlike `np.transpose`, the `axis` keyword-argument
    to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` | `power` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values` | `unique`
    | Each is equivalent to `np.unique` with certain flags set. |'
  prefs: []
  type: TYPE_TB
- en: Function instead of method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`astype` is a function in the array API, whereas it is a method on `ndarray`
    in `numpy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linalg` Namespace Differences'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These functions are in the `linalg` sub-namespace in the array API, but are
    only in the top-level namespace in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diagonal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matmul` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensordot` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(*): These functions are also in the top-level namespace in the array API.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Argument Renames
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following functions have keyword arguments that have been renamed. The functionality
    of the keyword argument is identical unless otherwise stated. Renamed keyword
    arguments with the same semantic definition may be considered either **compatible**
    or **breaking**, depending on how the change is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Note, this page does not list function keyword arguments that are in the main
    `numpy` namespace but not in the array API. Such keyword arguments are omitted
    from `numpy.array_api` for **strictness**, as the spec allows functions to include
    additional keyword arguments from those required.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Array API keyword name | NumPy keyword name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` | `stable` | `kind` | The definitions of `stable` and
    `kind` differ, as do the default values. The change of the default value makes
    this **breaking**. See [Set Functions Differences](#array-api-set-functions-differences).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | `rtol` | `tol` | The definitions of `rtol` and `tol` differ,
    as do the default values. The change of the default value makes this **breaking**.
    See [Linear Algebra Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | `rtol` | `rcond` | The definitions of `rtol` and `rcond` are the
    same, but their default values differ, making this **breaking**. See [Linear Algebra
    Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `std` and `var` | `correction` | `ddof` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` | `shape` | `newshape` | The argument may be passed as a positional
    or keyword argument for both NumPy and the array API. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Promotion Differences'
  prefs: []
  type: TYPE_NORMAL
- en: Type promotion is the biggest area where NumPy deviates from the spec. The most
    notable difference is that NumPy does value-based casting in many cases. The spec
    explicitly disallows value-based casting. In the array API, the result type of
    any operation is always determined entirely by the input types, independently
    of values or shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Limited set of dtypes. | **Strictness** | `numpy.array_api` only implements
    those [dtypes that are required by the spec](https://data-apis.org/array-api/latest/API_specification/data_types.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars only accept matching scalar types.
    | **Strictness** | For example, `<int32 array> + 1.0` is not allowed. See [the
    spec rules for mixing arrays and Python scalars](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars always return the same dtype as
    the array. | **Breaking** | For example, `numpy.array_api.asarray(0., dtype=float32)
    + 1e64` is a `float32` array. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the left-hand side would be promoted.
    | **Breaking** | Example: `a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`.
    The spec explicitly disallows this. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the right-hand side operand cannot
    broadcast to the shape of the left-hand side operand. | **Strictness** | This
    so-called “reverse broadcasting” should not be allowed. Example: `a = np.empty((2,
    3, 4)); a += np.empty((3, 4))` should error. See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` promotion for operators is only specified for integers within the bounds
    of the dtype. | **Strictness** | `numpy.array_api` fallsback to `np.ndarray` behavior
    (either cast or raise `OverflowError`). |'
  prefs: []
  type: TYPE_TB
- en: '| `__pow__` and `__rpow__` do not do value-based casting for 0-D arrays. |
    **Breaking** | For example, `np.array(0., dtype=float32)**np.array(0., dtype=float64)`
    is `float32`. Note that this is value-based casting on 0-D arrays, not scalars.
    |'
  prefs: []
  type: TYPE_TB
- en: '| No cross-kind casting. | **Strictness** | Namely, boolean, integer, and floating-point
    data types do not cast to each other, except explicitly with `astype` (this is
    separate from the behavior with Python scalars). |'
  prefs: []
  type: TYPE_TB
- en: '| No casting unsigned integer dtypes to floating dtypes (e.g., `int64 + uint64
    -> float64`. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `can_cast` and `result_type` are restricted. | **Strictness** | The `numpy.array_api`
    implementations disallow cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: Indexing Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The spec requires only a subset of indexing, but all indexing rules in the spec
    are compatible with NumPy’s more broad indexing rules.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No implicit ellipses (`...`). | **Strictness** | If an index does not include
    an ellipsis, all axes must be indexed. |'
  prefs: []
  type: TYPE_TB
- en: '| The start and stop of a slice may not be out of bounds. | **Strictness**
    | For a slice `i:j:k`, only the following are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` or `j` omitted (`None`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n <= i <= max(0, n - 1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k > 0` or `k` omitted (`None`), `-n <= j <= n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k < 0`, `-n - 1 <= j <= max(0, n - 1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Boolean array indices are only allowed as the sole index. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| Integer array indices are not allowed at all. | **Strictness** | With the
    exception of 0-D arrays, which are treated like integers. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Strictness'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in `numpy.array_api` restrict their inputs to only those dtypes that
    are explicitly required by the spec, even when the wrapped corresponding NumPy
    function would allow a broader set. Here, we list each function and the dtypes
    that are allowed in `numpy.array_api`. These are **strictness** differences because
    the spec does not require that other dtypes result in an error. The categories
    here are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point**: `float32` or `float64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer**: Any signed or unsigned integer dtype (`int8`, `int16`, `int32`,
    `int64`, `uint8`, `uint16`, `uint32`, or `uint64`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean**: `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer or boolean**: Any signed or unsigned integer dtype, or `bool`. For
    two-argument functions, both arguments must be integer or both must be `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numeric**: Any integer or floating-point dtype. For two-argument functions,
    both arguments must be integer or both must be floating-point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All**: Any of the above dtype categories. For two-argument functions, both
    arguments must be the same kind (integer, floating-point, or boolean).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, the return dtype is chosen according to [the rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html),
    and does not differ from NumPy’s return dtype for any of the allowed input dtypes,
    except in the cases mentioned specifically in the subsections below.
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_and` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_or` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_xor` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `cos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `expm1` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isfinite` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isinf` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logaddexp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log10` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log1p` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log2` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_and` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_not` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_or` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_xor` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `negative` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `positive` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` (*) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `remainder` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sin` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `square` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tanh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `trunc` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions have different names from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: Creation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `meshgrid` | Any (all input dtypes must be the same) |'
  prefs: []
  type: TYPE_TB
- en: Linear Algebra Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `det` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `eighvals` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `inv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matmul` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_power` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_transpose` (**) | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `qr` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `slogdet` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svd` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svdvals` (**) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tensordot` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vecdot` (**) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vector_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions are split from `norm` from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: (**) These functions are new in the array API and are not in the main `numpy`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Array Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the special `__operator__` methods on the array object behave identically
    to their corresponding functions (see [the spec](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)
    for a list of which methods correspond to which functions). The exception is that
    operators explicitly allow Python scalars according to the [rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)
    (see [Type Promotion Differences](#array-api-type-promotion-differences)).
  prefs: []
  type: TYPE_NORMAL
- en: Array Object Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No array scalars | **Strictness** | The spec does not have array scalars,
    only 0-D arrays. However, other than the promotion differences outlined in [Type
    Promotion Differences](#array-api-type-promotion-differences), scalars duck type
    as 0-D arrays for the purposes of the spec. The are immutable, but the spec [does
    not require mutability](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bool()`, `int()`, and `float()` only work on 0-D arrays. | **Strictness**
    | See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__imatmul__` | **Compatible** | `np.ndarray` does not currently implement
    `__imatmul`. Note that `a @= b` should only defined when it does not change the
    shape of `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `mT` attribute for matrix transpose. | **Compatible** | See [the spec
    definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html)
    for `mT`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `T` attribute should error if the input is not 2-dimensional. | **Breaking**
    | See [the note in the spec](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| New method `to_device` and attribute `device` | **Compatible** | The methods
    would effectively not do anything since NumPy is CPU only |'
  prefs: []
  type: TYPE_TB
- en: Creation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` keyword argument to `asarray` | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New `device` keyword argument to all array creation functions (`asarray`,
    `arange`, `empty`, `empty_like`, `eye`, `full`, `full_like`, `linspace`, `ones`,
    `ones_like`, `zeros`, and `zeros_like`). | **Compatible** | `device` would effectively
    do nothing, since NumPy is CPU only. |'
  prefs: []
  type: TYPE_TB
- en: Elementwise Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed. | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| Elementwise functions are only defined for given input type combinations.
    | **Strictness** | See [Type Strictness](#array-api-type-strictness). |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` and `bitwise_right_shift` are only defined for `x2`
    nonnegative. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil`, `floor`, and `trunc` return an integer with integer input. | **Breaking**
    | `np.ceil`, `np.floor`, and `np.trunc` return a floating-point dtype on integer
    dtype input. |'
  prefs: []
  type: TYPE_TB
- en: '### Linear Algebra Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` includes an `upper` keyword argument. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` does not allow size 2 vectors (only size 3). | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` operates on the last two axes. | **Breaking** | Strictly speaking
    this can be **compatible** because `diagonal` is moved to the `linalg` namespace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh`, `qr`, `slogdet` and `svd` return a named tuple. | **Compatible**
    | The corresponding `numpy` functions return a `tuple`, with the resulting arrays
    in the same order. |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `matrix_norm` and `vector_norm`. | **Compatible** | The `norm`
    function has been omitted from the array API and split into `matrix_norm` for
    matrix norms and `vector_norm` for vector norms. Note that `vector_norm` supports
    any number of axes, whereas `np.linalg.norm` only supports a single axis for vector
    norms. |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` has an `rtol` keyword argument instead of `tol`. | **Breaking**
    | In the array API, `rtol` filters singular values smaller than `rtol * largest_singular_value`.
    In `np.linalg.matrix_rank`, `tol` filters singular values smaller than `tol`.
    Furthermore, the default value for `rtol` is `max(M, N) * eps`, whereas the default
    value of `tol` in `np.linalg.matrix_rank` is `S.max() * max(M, N) * eps`, where
    `S` is the singular values of the input. The new flag name is compatible but the
    default change is breaking |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` does not support 1-dimensional arrays. | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New function `matrix_transpose`. | **Compatible** | Unlike `np.transpose`,
    `matrix_transpose` only transposes the last two axes. See [the spec definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` only supports 1-dimensional arrays. | **Breaking** | The spec currently
    only specifies behavior on 1-D arrays but future behavior will likely be to broadcast,
    rather than flatten, which is what `np.outer` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` has an `rtol` keyword argument instead of `rcond` | **Breaking** |
    The meaning of `rtol` and `rcond` is the same, but the default value for `rtol`
    is `max(M, N) * eps`, whereas the default value for `rcond` is `1e-15`. The new
    flag name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` only accepts `x2` as a vector when it is exactly 1-dimensional. |
    **Breaking** | The `np.linalg.solve` behavior is ambiguous. See [this numpy issue](https://github.com/numpy/numpy/issues/15349)
    and [this array API specification issue](https://github.com/data-apis/array-api/issues/285)
    for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `svdvals`. | **Compatible** | Equivalent to `np.linalg.svd(compute_uv=False)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| The `axis` keyword to `tensordot` must be a tuple. | **Compatible** | In
    `np.tensordot`, it can also be an array or array-like. |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` operates on the last two axes. | **Breaking** | `np.trace` operates
    on the first two axes by default. Note that the array API `trace` does not allow
    specifying which axes to operate on. |'
  prefs: []
  type: TYPE_TB
- en: Manipulation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` has different default casting rules from `np.concatenate` | **Strictness**
    | No cross-kind casting. No value-based casting on scalars (when axis=None). |'
  prefs: []
  type: TYPE_TB
- en: '| `stack` has different default casting rules from `np.stack` | **Strictness**
    | No cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `permute_dims`. | **Compatible** | Unlike `np.transpose`, the
    `axis` keyword argument to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` function has a `copy` keyword argument | **Compatible** | See [https://github.com/numpy/numpy/issues/9818](https://github.com/numpy/numpy/issues/9818).
    |'
  prefs: []
  type: TYPE_TB
- en: Set Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values`.
    | **Compatible** | See [Function Name Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| The four `unique_*` functions return a named tuple. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all` and `unique_indices` return indices with the same shape as `x`.
    | **Compatible** | See [https://github.com/numpy/numpy/issues/20638](https://github.com/numpy/numpy/issues/20638).
    |'
  prefs: []
  type: TYPE_TB
- en: '### Set Functions Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `stable` keyword argument instead of `kind`.
    | **Breaking** | `stable` is a boolean keyword argument, defaulting to `True`.
    `kind` takes a string, defaulting to `"quicksort"`. `stable=True` is equivalent
    to `kind="stable"` and `kind=False` is equivalent to `kind="quicksort"`, although
    any sorting algorithm is allowed by the spec when `stable=False`. The new flag
    name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `descending` keyword argument. | **Compatible**
    |  |'
  prefs: []
  type: TYPE_TB
- en: Statistical Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| The `std` and `var` functions have a `correction` keyword argument instead
    of `ddof`. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: Other Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dtypes can only be spelled as dtype objects. | **Strictness** | For example,
    `numpy.array_api.asarray([0], dtype=''int32'')` is not allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `asarray` is not implicitly called in any function. | **Strictness** | The
    exception is Python operators, which accept Python scalars in certain cases (see
    [Type Promotion Differences](#array-api-type-promotion-differences)). |'
  prefs: []
  type: TYPE_TB
- en: '| `tril` and `triu` require the input to be at least 2-D. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| finfo() return type uses `float` for the various attributes. | **Strictness**
    | The spec allows duck typing, so `finfo` returning dtype scalars is considered
    type compatible with `float`. |'
  prefs: []
  type: TYPE_TB
- en: '| Positional arguments in every function are positional-only. | **Breaking**
    | See the spec for the exact signature of each function. Note that NumPy ufuncs
    already use positional-only arguments, but non-ufuncs like `asarray` generally
    do not. |'
  prefs: []
  type: TYPE_TB
- en: Name Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many functions have been renamed in the spec from NumPy. These are otherwise
    identical in behavior, and are thus all **compatible** changes, unless otherwise
    noted.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Function Name Changes'
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are named differently in the array API
  prefs: []
  type: TYPE_NORMAL
- en: '| Array API name | NumPy namespace name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | `arccos` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | `arccosh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` | `arcsin` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` | `arcsinh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` | `arctan` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` | `arctan2` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` | `arctanh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` | `left_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | `invert` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` | `right_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool_` | This is **breaking** because `np.bool` is currently a
    deprecated alias for the built-in `bool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | `concatenate` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` and `vector_norm` | `norm` | `matrix_norm` and `vector_norm`
    each do a limited subset of what `np.norm` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `permute_dims` | `transpose` | Unlike `np.transpose`, the `axis` keyword-argument
    to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` | `power` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values` | `unique`
    | Each is equivalent to `np.unique` with certain flags set. |'
  prefs: []
  type: TYPE_TB
- en: Function instead of method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`astype` is a function in the array API, whereas it is a method on `ndarray`
    in `numpy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linalg` Namespace Differences'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These functions are in the `linalg` sub-namespace in the array API, but are
    only in the top-level namespace in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diagonal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matmul` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensordot` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(*): These functions are also in the top-level namespace in the array API.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Argument Renames
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following functions have keyword arguments that have been renamed. The functionality
    of the keyword argument is identical unless otherwise stated. Renamed keyword
    arguments with the same semantic definition may be considered either **compatible**
    or **breaking**, depending on how the change is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Note, this page does not list function keyword arguments that are in the main
    `numpy` namespace but not in the array API. Such keyword arguments are omitted
    from `numpy.array_api` for **strictness**, as the spec allows functions to include
    additional keyword arguments from those required.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Array API keyword name | NumPy keyword name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` | `stable` | `kind` | The definitions of `stable` and
    `kind` differ, as do the default values. The change of the default value makes
    this **breaking**. See [Set Functions Differences](#array-api-set-functions-differences).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | `rtol` | `tol` | The definitions of `rtol` and `tol` differ,
    as do the default values. The change of the default value makes this **breaking**.
    See [Linear Algebra Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | `rtol` | `rcond` | The definitions of `rtol` and `rcond` are the
    same, but their default values differ, making this **breaking**. See [Linear Algebra
    Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `std` and `var` | `correction` | `ddof` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` | `shape` | `newshape` | The argument may be passed as a positional
    or keyword argument for both NumPy and the array API. |'
  prefs: []
  type: TYPE_TB
- en: '#### Function Name Changes'
  prefs: []
  type: TYPE_NORMAL
- en: The following functions are named differently in the array API
  prefs: []
  type: TYPE_NORMAL
- en: '| Array API name | NumPy namespace name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | `arccos` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | `arccosh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` | `arcsin` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` | `arcsinh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` | `arctan` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` | `arctan2` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` | `arctanh` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` | `left_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | `invert` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` | `right_shift` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool_` | This is **breaking** because `np.bool` is currently a
    deprecated alias for the built-in `bool`. |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | `concatenate` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` and `vector_norm` | `norm` | `matrix_norm` and `vector_norm`
    each do a limited subset of what `np.norm` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `permute_dims` | `transpose` | Unlike `np.transpose`, the `axis` keyword-argument
    to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` | `power` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values` | `unique`
    | Each is equivalent to `np.unique` with certain flags set. |'
  prefs: []
  type: TYPE_TB
- en: Function instead of method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`astype` is a function in the array API, whereas it is a method on `ndarray`
    in `numpy`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linalg` Namespace Differences'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These functions are in the `linalg` sub-namespace in the array API, but are
    only in the top-level namespace in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cross`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`diagonal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matmul` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tensordot` (*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(*): These functions are also in the top-level namespace in the array API.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Argument Renames
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following functions have keyword arguments that have been renamed. The functionality
    of the keyword argument is identical unless otherwise stated. Renamed keyword
    arguments with the same semantic definition may be considered either **compatible**
    or **breaking**, depending on how the change is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Note, this page does not list function keyword arguments that are in the main
    `numpy` namespace but not in the array API. Such keyword arguments are omitted
    from `numpy.array_api` for **strictness**, as the spec allows functions to include
    additional keyword arguments from those required.
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Array API keyword name | NumPy keyword name | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` | `stable` | `kind` | The definitions of `stable` and
    `kind` differ, as do the default values. The change of the default value makes
    this **breaking**. See [Set Functions Differences](#array-api-set-functions-differences).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | `rtol` | `tol` | The definitions of `rtol` and `tol` differ,
    as do the default values. The change of the default value makes this **breaking**.
    See [Linear Algebra Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | `rtol` | `rcond` | The definitions of `rtol` and `rcond` are the
    same, but their default values differ, making this **breaking**. See [Linear Algebra
    Differences](#array-api-linear-algebra-differences). |'
  prefs: []
  type: TYPE_TB
- en: '| `std` and `var` | `correction` | `ddof` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` | `shape` | `newshape` | The argument may be passed as a positional
    or keyword argument for both NumPy and the array API. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Promotion Differences'
  prefs: []
  type: TYPE_NORMAL
- en: Type promotion is the biggest area where NumPy deviates from the spec. The most
    notable difference is that NumPy does value-based casting in many cases. The spec
    explicitly disallows value-based casting. In the array API, the result type of
    any operation is always determined entirely by the input types, independently
    of values or shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Limited set of dtypes. | **Strictness** | `numpy.array_api` only implements
    those [dtypes that are required by the spec](https://data-apis.org/array-api/latest/API_specification/data_types.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars only accept matching scalar types.
    | **Strictness** | For example, `<int32 array> + 1.0` is not allowed. See [the
    spec rules for mixing arrays and Python scalars](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Operators (like `+`) with Python scalars always return the same dtype as
    the array. | **Breaking** | For example, `numpy.array_api.asarray(0., dtype=float32)
    + 1e64` is a `float32` array. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the left-hand side would be promoted.
    | **Breaking** | Example: `a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`.
    The spec explicitly disallows this. |'
  prefs: []
  type: TYPE_TB
- en: '| In-place operators are disallowed when the right-hand side operand cannot
    broadcast to the shape of the left-hand side operand. | **Strictness** | This
    so-called “reverse broadcasting” should not be allowed. Example: `a = np.empty((2,
    3, 4)); a += np.empty((3, 4))` should error. See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` promotion for operators is only specified for integers within the bounds
    of the dtype. | **Strictness** | `numpy.array_api` fallsback to `np.ndarray` behavior
    (either cast or raise `OverflowError`). |'
  prefs: []
  type: TYPE_TB
- en: '| `__pow__` and `__rpow__` do not do value-based casting for 0-D arrays. |
    **Breaking** | For example, `np.array(0., dtype=float32)**np.array(0., dtype=float64)`
    is `float32`. Note that this is value-based casting on 0-D arrays, not scalars.
    |'
  prefs: []
  type: TYPE_TB
- en: '| No cross-kind casting. | **Strictness** | Namely, boolean, integer, and floating-point
    data types do not cast to each other, except explicitly with `astype` (this is
    separate from the behavior with Python scalars). |'
  prefs: []
  type: TYPE_TB
- en: '| No casting unsigned integer dtypes to floating dtypes (e.g., `int64 + uint64
    -> float64`. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `can_cast` and `result_type` are restricted. | **Strictness** | The `numpy.array_api`
    implementations disallow cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: Indexing Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The spec requires only a subset of indexing, but all indexing rules in the spec
    are compatible with NumPy’s more broad indexing rules.
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No implicit ellipses (`...`). | **Strictness** | If an index does not include
    an ellipsis, all axes must be indexed. |'
  prefs: []
  type: TYPE_TB
- en: '| The start and stop of a slice may not be out of bounds. | **Strictness**
    | For a slice `i:j:k`, only the following are allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` or `j` omitted (`None`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n <= i <= max(0, n - 1)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k > 0` or `k` omitted (`None`), `-n <= j <= n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `k < 0`, `-n - 1 <= j <= max(0, n - 1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Boolean array indices are only allowed as the sole index. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| Integer array indices are not allowed at all. | **Strictness** | With the
    exception of 0-D arrays, which are treated like integers. |'
  prefs: []
  type: TYPE_TB
- en: '### Type Strictness'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in `numpy.array_api` restrict their inputs to only those dtypes that
    are explicitly required by the spec, even when the wrapped corresponding NumPy
    function would allow a broader set. Here, we list each function and the dtypes
    that are allowed in `numpy.array_api`. These are **strictness** differences because
    the spec does not require that other dtypes result in an error. The categories
    here are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point**: `float32` or `float64`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer**: Any signed or unsigned integer dtype (`int8`, `int16`, `int32`,
    `int64`, `uint8`, `uint16`, `uint32`, or `uint64`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean**: `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integer or boolean**: Any signed or unsigned integer dtype, or `bool`. For
    two-argument functions, both arguments must be integer or both must be `bool`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numeric**: Any integer or floating-point dtype. For two-argument functions,
    both arguments must be integer or both must be floating-point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All**: Any of the above dtype categories. For two-argument functions, both
    arguments must be the same kind (integer, floating-point, or boolean).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases, the return dtype is chosen according to [the rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html),
    and does not differ from NumPy’s return dtype for any of the allowed input dtypes,
    except in the cases mentioned specifically in the subsections below.
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_and` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_or` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_xor` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `cos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `expm1` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isfinite` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isinf` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logaddexp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log10` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log1p` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log2` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_and` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_not` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_or` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_xor` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `negative` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `positive` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` (*) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `remainder` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sin` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `square` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tanh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `trunc` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions have different names from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: Creation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `meshgrid` | Any (all input dtypes must be the same) |'
  prefs: []
  type: TYPE_TB
- en: Linear Algebra Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `det` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `eighvals` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `inv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matmul` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_power` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_transpose` (**) | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `qr` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `slogdet` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svd` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svdvals` (**) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tensordot` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vecdot` (**) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vector_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions are split from `norm` from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: (**) These functions are new in the array API and are not in the main `numpy`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Array Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the special `__operator__` methods on the array object behave identically
    to their corresponding functions (see [the spec](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)
    for a list of which methods correspond to which functions). The exception is that
    operators explicitly allow Python scalars according to the [rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)
    (see [Type Promotion Differences](#array-api-type-promotion-differences)).
  prefs: []
  type: TYPE_NORMAL
- en: Elementwise Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `acos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `asin` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `asinh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atan2` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `atanh` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_and` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_invert` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_or` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_right_shift` (*) | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_xor` | Integer or boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `cos` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cosh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `divide` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `expm1` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `floor` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `floor_divide` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `greater_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isfinite` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isinf` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `isnan` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `less_equal` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `log` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logaddexp` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log10` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log1p` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `log2` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_and` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_not` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_or` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `logical_xor` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `negative` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `not_equal` | All |'
  prefs: []
  type: TYPE_TB
- en: '| `positive` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pow` (*) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `remainder` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sign` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `sin` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sinh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `square` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `subtract` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `tan` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tanh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `trunc` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions have different names from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: Creation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `meshgrid` | Any (all input dtypes must be the same) |'
  prefs: []
  type: TYPE_TB
- en: Linear Algebra Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Function Name | Dtypes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `det` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `eighvals` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `inv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matmul` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_power` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_transpose` (**) | Any |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `qr` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `slogdet` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svd` | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `svdvals` (**) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: '| `tensordot` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vecdot` (**) | Numeric |'
  prefs: []
  type: TYPE_TB
- en: '| `vector_norm` (*) | Floating-point |'
  prefs: []
  type: TYPE_TB
- en: (*) These functions are split from `norm` from the main `numpy` namespace. See
    [Function Name Changes](#array-api-name-changes).
  prefs: []
  type: TYPE_NORMAL
- en: (**) These functions are new in the array API and are not in the main `numpy`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Array Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All the special `__operator__` methods on the array object behave identically
    to their corresponding functions (see [the spec](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)
    for a list of which methods correspond to which functions). The exception is that
    operators explicitly allow Python scalars according to the [rules outlined in
    the spec](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)
    (see [Type Promotion Differences](#array-api-type-promotion-differences)).
  prefs: []
  type: TYPE_NORMAL
- en: Array Object Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No array scalars | **Strictness** | The spec does not have array scalars,
    only 0-D arrays. However, other than the promotion differences outlined in [Type
    Promotion Differences](#array-api-type-promotion-differences), scalars duck type
    as 0-D arrays for the purposes of the spec. The are immutable, but the spec [does
    not require mutability](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bool()`, `int()`, and `float()` only work on 0-D arrays. | **Strictness**
    | See [https://github.com/numpy/numpy/issues/10404](https://github.com/numpy/numpy/issues/10404).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `__imatmul__` | **Compatible** | `np.ndarray` does not currently implement
    `__imatmul`. Note that `a @= b` should only defined when it does not change the
    shape of `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `mT` attribute for matrix transpose. | **Compatible** | See [the spec
    definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html)
    for `mT`. |'
  prefs: []
  type: TYPE_TB
- en: '| The `T` attribute should error if the input is not 2-dimensional. | **Breaking**
    | See [the note in the spec](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html).
    |'
  prefs: []
  type: TYPE_TB
- en: '| New method `to_device` and attribute `device` | **Compatible** | The methods
    would effectively not do anything since NumPy is CPU only |'
  prefs: []
  type: TYPE_TB
- en: Creation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` keyword argument to `asarray` | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New `device` keyword argument to all array creation functions (`asarray`,
    `arange`, `empty`, `empty_like`, `eye`, `full`, `full_like`, `linspace`, `ones`,
    `ones_like`, `zeros`, and `zeros_like`). | **Compatible** | `device` would effectively
    do nothing, since NumPy is CPU only. |'
  prefs: []
  type: TYPE_TB
- en: Elementwise Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed. | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| Elementwise functions are only defined for given input type combinations.
    | **Strictness** | See [Type Strictness](#array-api-type-strictness). |'
  prefs: []
  type: TYPE_TB
- en: '| `bitwise_left_shift` and `bitwise_right_shift` are only defined for `x2`
    nonnegative. | **Strictness** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ceil`, `floor`, and `trunc` return an integer with integer input. | **Breaking**
    | `np.ceil`, `np.floor`, and `np.trunc` return a floating-point dtype on integer
    dtype input. |'
  prefs: []
  type: TYPE_TB
- en: '### Linear Algebra Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cholesky` includes an `upper` keyword argument. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cross` does not allow size 2 vectors (only size 3). | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal` operates on the last two axes. | **Breaking** | Strictly speaking
    this can be **compatible** because `diagonal` is moved to the `linalg` namespace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `eigh`, `qr`, `slogdet` and `svd` return a named tuple. | **Compatible**
    | The corresponding `numpy` functions return a `tuple`, with the resulting arrays
    in the same order. |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `matrix_norm` and `vector_norm`. | **Compatible** | The `norm`
    function has been omitted from the array API and split into `matrix_norm` for
    matrix norms and `vector_norm` for vector norms. Note that `vector_norm` supports
    any number of axes, whereas `np.linalg.norm` only supports a single axis for vector
    norms. |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` has an `rtol` keyword argument instead of `tol`. | **Breaking**
    | In the array API, `rtol` filters singular values smaller than `rtol * largest_singular_value`.
    In `np.linalg.matrix_rank`, `tol` filters singular values smaller than `tol`.
    Furthermore, the default value for `rtol` is `max(M, N) * eps`, whereas the default
    value of `tol` in `np.linalg.matrix_rank` is `S.max() * max(M, N) * eps`, where
    `S` is the singular values of the input. The new flag name is compatible but the
    default change is breaking |'
  prefs: []
  type: TYPE_TB
- en: '| `matrix_rank` does not support 1-dimensional arrays. | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| New function `matrix_transpose`. | **Compatible** | Unlike `np.transpose`,
    `matrix_transpose` only transposes the last two axes. See [the spec definition](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `outer` only supports 1-dimensional arrays. | **Breaking** | The spec currently
    only specifies behavior on 1-D arrays but future behavior will likely be to broadcast,
    rather than flatten, which is what `np.outer` does. |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv` has an `rtol` keyword argument instead of `rcond` | **Breaking** |
    The meaning of `rtol` and `rcond` is the same, but the default value for `rtol`
    is `max(M, N) * eps`, whereas the default value for `rcond` is `1e-15`. The new
    flag name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `solve` only accepts `x2` as a vector when it is exactly 1-dimensional. |
    **Breaking** | The `np.linalg.solve` behavior is ambiguous. See [this numpy issue](https://github.com/numpy/numpy/issues/15349)
    and [this array API specification issue](https://github.com/data-apis/array-api/issues/285)
    for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `svdvals`. | **Compatible** | Equivalent to `np.linalg.svd(compute_uv=False)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| The `axis` keyword to `tensordot` must be a tuple. | **Compatible** | In
    `np.tensordot`, it can also be an array or array-like. |'
  prefs: []
  type: TYPE_TB
- en: '| `trace` operates on the last two axes. | **Breaking** | `np.trace` operates
    on the first two axes by default. Note that the array API `trace` does not allow
    specifying which axes to operate on. |'
  prefs: []
  type: TYPE_TB
- en: Manipulation Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Various functions have been renamed | **Compatible** | See [Function Name
    Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` has different default casting rules from `np.concatenate` | **Strictness**
    | No cross-kind casting. No value-based casting on scalars (when axis=None). |'
  prefs: []
  type: TYPE_TB
- en: '| `stack` has different default casting rules from `np.stack` | **Strictness**
    | No cross-kind casting. |'
  prefs: []
  type: TYPE_TB
- en: '| New function `permute_dims`. | **Compatible** | Unlike `np.transpose`, the
    `axis` keyword argument to `permute_dims` is required. |'
  prefs: []
  type: TYPE_TB
- en: '| `reshape` function has a `copy` keyword argument | **Compatible** | See [https://github.com/numpy/numpy/issues/9818](https://github.com/numpy/numpy/issues/9818).
    |'
  prefs: []
  type: TYPE_TB
- en: Set Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| New functions `unique_all`, `unique_counts`, `unique_inverse`, and `unique_values`.
    | **Compatible** | See [Function Name Changes](#array-api-name-changes). |'
  prefs: []
  type: TYPE_TB
- en: '| The four `unique_*` functions return a named tuple. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `unique_all` and `unique_indices` return indices with the same shape as `x`.
    | **Compatible** | See [https://github.com/numpy/numpy/issues/20638](https://github.com/numpy/numpy/issues/20638).
    |'
  prefs: []
  type: TYPE_TB
- en: '### Set Functions Differences'
  prefs: []
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `stable` keyword argument instead of `kind`.
    | **Breaking** | `stable` is a boolean keyword argument, defaulting to `True`.
    `kind` takes a string, defaulting to `"quicksort"`. `stable=True` is equivalent
    to `kind="stable"` and `kind=False` is equivalent to `kind="quicksort"`, although
    any sorting algorithm is allowed by the spec when `stable=False`. The new flag
    name is compatible but the default change is breaking. |'
  prefs: []
  type: TYPE_TB
- en: '| `argsort` and `sort` have a `descending` keyword argument. | **Compatible**
    |  |'
  prefs: []
  type: TYPE_TB
- en: Statistical Functions Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` and `prod` always upcast `float32` to `float64` when `dtype=None`.
    | **Breaking** |  |'
  prefs: []
  type: TYPE_TB
- en: '| The `std` and `var` functions have a `correction` keyword argument instead
    of `ddof`. | **Compatible** |  |'
  prefs: []
  type: TYPE_TB
- en: Other Differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Feature | Type | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Dtypes can only be spelled as dtype objects. | **Strictness** | For example,
    `numpy.array_api.asarray([0], dtype=''int32'')` is not allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `asarray` is not implicitly called in any function. | **Strictness** | The
    exception is Python operators, which accept Python scalars in certain cases (see
    [Type Promotion Differences](#array-api-type-promotion-differences)). |'
  prefs: []
  type: TYPE_TB
- en: '| `tril` and `triu` require the input to be at least 2-D. | **Strictness**
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| finfo() return type uses `float` for the various attributes. | **Strictness**
    | The spec allows duck typing, so `finfo` returning dtype scalars is considered
    type compatible with `float`. |'
  prefs: []
  type: TYPE_TB
- en: '| Positional arguments in every function are positional-only. | **Breaking**
    | See the spec for the exact signature of each function. Note that NumPy ufuncs
    already use positional-only arguments, but non-ufuncs like `asarray` generally
    do not. |'
  prefs: []
  type: TYPE_TB
