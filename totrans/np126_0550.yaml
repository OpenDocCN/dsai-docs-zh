- en: Linear algebra (numpy.linalg)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/routines.linalg.html](https://numpy.org/doc/1.26/reference/routines.linalg.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient
    low level implementations of standard linear algebra algorithms. Those libraries
    may be provided by NumPy itself using C versions of a subset of their reference
    implementations but, when possible, highly optimized libraries that take advantage
    of specialized processor functionality are preferred. Examples of such libraries
    are [OpenBLAS](https://www.openblas.net/), MKL (TM), and ATLAS. Because those
    libraries are multithreaded and processor dependent, environmental variables and
    external packages such as [threadpoolctl](https://github.com/joblib/threadpoolctl)
    may be needed to control the number of threads or specify the processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The SciPy library also contains a [`linalg`](https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg
    "(in SciPy v1.11.2)") submodule, and there is overlap in the functionality provided
    by the SciPy and NumPy submodules. SciPy contains functions not found in [`numpy.linalg`](#module-numpy.linalg
    "numpy.linalg"), such as functions related to LU decomposition and the Schur decomposition,
    multiple ways of calculating the pseudoinverse, and matrix transcendentals such
    as the matrix logarithm. Some functions that exist in both have augmented functionality
    in [`scipy.linalg`](https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg
    "(in SciPy v1.11.2)"). For example, [`scipy.linalg.eig`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "(in SciPy v1.11.2)") can take a second matrix argument for solving generalized
    eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting
    options. For example, [`numpy.linalg.solve`](generated/numpy.linalg.solve.html#numpy.linalg.solve
    "numpy.linalg.solve") can handle “stacked” arrays, while [`scipy.linalg.solve`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve
    "(in SciPy v1.11.2)") accepts only a single square array as its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term *matrix* as it is used on this page indicates a 2d [`numpy.array`](generated/numpy.array.html#numpy.array
    "numpy.array") object, and *not* a [`numpy.matrix`](generated/numpy.matrix.html#numpy.matrix
    "numpy.matrix") object. The latter is no longer recommended, even for linear algebra.
    See [the matrix object documentation](arrays.classes.html#matrix-objects) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `@` operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in NumPy 1.10.0, the `@` operator is preferable to other methods
    when computing the matrix product between 2d arrays. The [`numpy.matmul`](generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") function implements the `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix and vector products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`dot`](generated/numpy.dot.html#numpy.dot "numpy.dot")(a, b[, out]) | Dot
    product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.multi_dot`](generated/numpy.linalg.multi_dot.html#numpy.linalg.multi_dot
    "numpy.linalg.multi_dot")(arrays, *[, out]) | Compute the dot product of two or
    more arrays in a single function call, while automatically selecting the fastest
    evaluation order. |'
  prefs: []
  type: TYPE_TB
- en: '| [`vdot`](generated/numpy.vdot.html#numpy.vdot "numpy.vdot")(a, b, /) | Return
    the dot product of two vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| [`inner`](generated/numpy.inner.html#numpy.inner "numpy.inner")(a, b, /)
    | Inner product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`outer`](generated/numpy.outer.html#numpy.outer "numpy.outer")(a, b[, out])
    | Compute the outer product of two vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul")(x1, x2, /[, out, casting, order, ...])
    | Matrix product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tensordot`](generated/numpy.tensordot.html#numpy.tensordot "numpy.tensordot")(a, b[, axes])
    | Compute tensor dot product along specified axes. |'
  prefs: []
  type: TYPE_TB
- en: '| [`einsum`](generated/numpy.einsum.html#numpy.einsum "numpy.einsum")(subscripts, *operands[, out, dtype, ...])
    | Evaluates the Einstein summation convention on the operands. |'
  prefs: []
  type: TYPE_TB
- en: '| [`einsum_path`](generated/numpy.einsum_path.html#numpy.einsum_path "numpy.einsum_path")(subscripts, *operands[, optimize])
    | Evaluates the lowest cost contraction order for an einsum expression by considering
    the creation of intermediate arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.matrix_power`](generated/numpy.linalg.matrix_power.html#numpy.linalg.matrix_power
    "numpy.linalg.matrix_power")(a, n) | Raise a square matrix to the (integer) power
    *n*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`kron`](generated/numpy.kron.html#numpy.kron "numpy.kron")(a, b) | Kronecker
    product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: Decompositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.cholesky`](generated/numpy.linalg.cholesky.html#numpy.linalg.cholesky
    "numpy.linalg.cholesky")(a) | Cholesky decomposition. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.qr`](generated/numpy.linalg.qr.html#numpy.linalg.qr "numpy.linalg.qr")(a[, mode])
    | Compute the qr factorization of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.svd`](generated/numpy.linalg.svd.html#numpy.linalg.svd "numpy.linalg.svd")(a[, full_matrices, compute_uv, ...])
    | Singular Value Decomposition. |'
  prefs: []
  type: TYPE_TB
- en: Matrix eigenvalues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.eig`](generated/numpy.linalg.eig.html#numpy.linalg.eig "numpy.linalg.eig")(a)
    | Compute the eigenvalues and right eigenvectors of a square array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigh`](generated/numpy.linalg.eigh.html#numpy.linalg.eigh "numpy.linalg.eigh")(a[, UPLO])
    | Return the eigenvalues and eigenvectors of a complex Hermitian (conjugate symmetric)
    or a real symmetric matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigvals`](generated/numpy.linalg.eigvals.html#numpy.linalg.eigvals
    "numpy.linalg.eigvals")(a) | Compute the eigenvalues of a general matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigvalsh`](generated/numpy.linalg.eigvalsh.html#numpy.linalg.eigvalsh
    "numpy.linalg.eigvalsh")(a[, UPLO]) | Compute the eigenvalues of a complex Hermitian
    or real symmetric matrix. |'
  prefs: []
  type: TYPE_TB
- en: Norms and other numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.norm`](generated/numpy.linalg.norm.html#numpy.linalg.norm "numpy.linalg.norm")(x[, ord, axis, keepdims])
    | Matrix or vector norm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.cond`](generated/numpy.linalg.cond.html#numpy.linalg.cond "numpy.linalg.cond")(x[, p])
    | Compute the condition number of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.det`](generated/numpy.linalg.det.html#numpy.linalg.det "numpy.linalg.det")(a)
    | Compute the determinant of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.matrix_rank`](generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank")(A[, tol, hermitian]) | Return matrix rank of array
    using SVD method |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.slogdet`](generated/numpy.linalg.slogdet.html#numpy.linalg.slogdet
    "numpy.linalg.slogdet")(a) | Compute the sign and (natural) logarithm of the determinant
    of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`trace`](generated/numpy.trace.html#numpy.trace "numpy.trace")(a[, offset, axis1, axis2, dtype, out])
    | Return the sum along diagonals of the array. |'
  prefs: []
  type: TYPE_TB
- en: Solving equations and inverting matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.solve`](generated/numpy.linalg.solve.html#numpy.linalg.solve "numpy.linalg.solve")(a, b)
    | Solve a linear matrix equation, or system of linear scalar equations. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.tensorsolve`](generated/numpy.linalg.tensorsolve.html#numpy.linalg.tensorsolve
    "numpy.linalg.tensorsolve")(a, b[, axes]) | Solve the tensor equation `a x = b`
    for x. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.lstsq`](generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq "numpy.linalg.lstsq")(a, b[, rcond])
    | Return the least-squares solution to a linear matrix equation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.inv`](generated/numpy.linalg.inv.html#numpy.linalg.inv "numpy.linalg.inv")(a)
    | Compute the (multiplicative) inverse of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.pinv`](generated/numpy.linalg.pinv.html#numpy.linalg.pinv "numpy.linalg.pinv")(a[, rcond, hermitian])
    | Compute the (Moore-Penrose) pseudo-inverse of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.tensorinv`](generated/numpy.linalg.tensorinv.html#numpy.linalg.tensorinv
    "numpy.linalg.tensorinv")(a[, ind]) | Compute the ''inverse'' of an N-dimensional
    array. |'
  prefs: []
  type: TYPE_TB
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.LinAlgError`](generated/numpy.linalg.LinAlgError.html#numpy.linalg.LinAlgError
    "numpy.linalg.LinAlgError") | Generic Python-exception-derived object raised by
    linalg functions. |'
  prefs: []
  type: TYPE_TB
- en: '## Linear algebra on several matrices at once'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the linear algebra routines listed above are able to compute results
    for several matrices at once, if they are stacked into the same array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is indicated in the documentation via input parameter specifications such
    as `a : (..., M, M) array_like`. This means that if for instance given an input
    array `a.shape == (N, M, M)`, it is interpreted as a “stack” of N matrices, each
    of size M-by-M. Similar specification applies to return values, for instance the
    determinant has `det : (...)` and will in this case return an array of shape `det(a).shape
    == (N,)`. This generalizes to linear algebra operations on higher-dimensional
    arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted
    as vectors or matrices, as appropriate for each operation.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@` operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced in NumPy 1.10.0, the `@` operator is preferable to other methods
    when computing the matrix product between 2d arrays. The [`numpy.matmul`](generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") function implements the `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix and vector products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`dot`](generated/numpy.dot.html#numpy.dot "numpy.dot")(a, b[, out]) | Dot
    product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.multi_dot`](generated/numpy.linalg.multi_dot.html#numpy.linalg.multi_dot
    "numpy.linalg.multi_dot")(arrays, *[, out]) | Compute the dot product of two or
    more arrays in a single function call, while automatically selecting the fastest
    evaluation order. |'
  prefs: []
  type: TYPE_TB
- en: '| [`vdot`](generated/numpy.vdot.html#numpy.vdot "numpy.vdot")(a, b, /) | Return
    the dot product of two vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| [`inner`](generated/numpy.inner.html#numpy.inner "numpy.inner")(a, b, /)
    | Inner product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`outer`](generated/numpy.outer.html#numpy.outer "numpy.outer")(a, b[, out])
    | Compute the outer product of two vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul")(x1, x2, /[, out, casting, order, ...])
    | Matrix product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tensordot`](generated/numpy.tensordot.html#numpy.tensordot "numpy.tensordot")(a, b[, axes])
    | Compute tensor dot product along specified axes. |'
  prefs: []
  type: TYPE_TB
- en: '| [`einsum`](generated/numpy.einsum.html#numpy.einsum "numpy.einsum")(subscripts, *operands[, out, dtype, ...])
    | Evaluates the Einstein summation convention on the operands. |'
  prefs: []
  type: TYPE_TB
- en: '| [`einsum_path`](generated/numpy.einsum_path.html#numpy.einsum_path "numpy.einsum_path")(subscripts, *operands[, optimize])
    | Evaluates the lowest cost contraction order for an einsum expression by considering
    the creation of intermediate arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.matrix_power`](generated/numpy.linalg.matrix_power.html#numpy.linalg.matrix_power
    "numpy.linalg.matrix_power")(a, n) | Raise a square matrix to the (integer) power
    *n*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`kron`](generated/numpy.kron.html#numpy.kron "numpy.kron")(a, b) | Kronecker
    product of two arrays. |'
  prefs: []
  type: TYPE_TB
- en: Decompositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.cholesky`](generated/numpy.linalg.cholesky.html#numpy.linalg.cholesky
    "numpy.linalg.cholesky")(a) | Cholesky decomposition. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.qr`](generated/numpy.linalg.qr.html#numpy.linalg.qr "numpy.linalg.qr")(a[, mode])
    | Compute the qr factorization of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.svd`](generated/numpy.linalg.svd.html#numpy.linalg.svd "numpy.linalg.svd")(a[, full_matrices, compute_uv, ...])
    | Singular Value Decomposition. |'
  prefs: []
  type: TYPE_TB
- en: Matrix eigenvalues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.eig`](generated/numpy.linalg.eig.html#numpy.linalg.eig "numpy.linalg.eig")(a)
    | Compute the eigenvalues and right eigenvectors of a square array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigh`](generated/numpy.linalg.eigh.html#numpy.linalg.eigh "numpy.linalg.eigh")(a[, UPLO])
    | Return the eigenvalues and eigenvectors of a complex Hermitian (conjugate symmetric)
    or a real symmetric matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigvals`](generated/numpy.linalg.eigvals.html#numpy.linalg.eigvals
    "numpy.linalg.eigvals")(a) | Compute the eigenvalues of a general matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.eigvalsh`](generated/numpy.linalg.eigvalsh.html#numpy.linalg.eigvalsh
    "numpy.linalg.eigvalsh")(a[, UPLO]) | Compute the eigenvalues of a complex Hermitian
    or real symmetric matrix. |'
  prefs: []
  type: TYPE_TB
- en: Norms and other numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.norm`](generated/numpy.linalg.norm.html#numpy.linalg.norm "numpy.linalg.norm")(x[, ord, axis, keepdims])
    | Matrix or vector norm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.cond`](generated/numpy.linalg.cond.html#numpy.linalg.cond "numpy.linalg.cond")(x[, p])
    | Compute the condition number of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.det`](generated/numpy.linalg.det.html#numpy.linalg.det "numpy.linalg.det")(a)
    | Compute the determinant of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.matrix_rank`](generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank")(A[, tol, hermitian]) | Return matrix rank of array
    using SVD method |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.slogdet`](generated/numpy.linalg.slogdet.html#numpy.linalg.slogdet
    "numpy.linalg.slogdet")(a) | Compute the sign and (natural) logarithm of the determinant
    of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`trace`](generated/numpy.trace.html#numpy.trace "numpy.trace")(a[, offset, axis1, axis2, dtype, out])
    | Return the sum along diagonals of the array. |'
  prefs: []
  type: TYPE_TB
- en: Solving equations and inverting matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.solve`](generated/numpy.linalg.solve.html#numpy.linalg.solve "numpy.linalg.solve")(a, b)
    | Solve a linear matrix equation, or system of linear scalar equations. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.tensorsolve`](generated/numpy.linalg.tensorsolve.html#numpy.linalg.tensorsolve
    "numpy.linalg.tensorsolve")(a, b[, axes]) | Solve the tensor equation `a x = b`
    for x. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.lstsq`](generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq "numpy.linalg.lstsq")(a, b[, rcond])
    | Return the least-squares solution to a linear matrix equation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.inv`](generated/numpy.linalg.inv.html#numpy.linalg.inv "numpy.linalg.inv")(a)
    | Compute the (multiplicative) inverse of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.pinv`](generated/numpy.linalg.pinv.html#numpy.linalg.pinv "numpy.linalg.pinv")(a[, rcond, hermitian])
    | Compute the (Moore-Penrose) pseudo-inverse of a matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linalg.tensorinv`](generated/numpy.linalg.tensorinv.html#numpy.linalg.tensorinv
    "numpy.linalg.tensorinv")(a[, ind]) | Compute the ''inverse'' of an N-dimensional
    array. |'
  prefs: []
  type: TYPE_TB
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linalg.LinAlgError`](generated/numpy.linalg.LinAlgError.html#numpy.linalg.LinAlgError
    "numpy.linalg.LinAlgError") | Generic Python-exception-derived object raised by
    linalg functions. |'
  prefs: []
  type: TYPE_TB
- en: '## Linear algebra on several matrices at once'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: Several of the linear algebra routines listed above are able to compute results
    for several matrices at once, if they are stacked into the same array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is indicated in the documentation via input parameter specifications such
    as `a : (..., M, M) array_like`. This means that if for instance given an input
    array `a.shape == (N, M, M)`, it is interpreted as a “stack” of N matrices, each
    of size M-by-M. Similar specification applies to return values, for instance the
    determinant has `det : (...)` and will in this case return an array of shape `det(a).shape
    == (N,)`. This generalizes to linear algebra operations on higher-dimensional
    arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted
    as vectors or matrices, as appropriate for each operation.'
  prefs: []
  type: TYPE_NORMAL
