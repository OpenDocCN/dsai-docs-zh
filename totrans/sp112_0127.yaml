- en: scipy.integrate.quad_vec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.quad_vec.html#scipy.integrate.quad_vec](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.quad_vec.html#scipy.integrate.quad_vec)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adaptive integration of a vector-valued function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f**callable'
  prefs: []
  type: TYPE_NORMAL
- en: Vector-valued function f(x) to integrate.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**float'
  prefs: []
  type: TYPE_NORMAL
- en: Initial point.
  prefs: []
  type: TYPE_NORMAL
- en: '**b**float'
  prefs: []
  type: TYPE_NORMAL
- en: Final point.
  prefs: []
  type: TYPE_NORMAL
- en: '**epsabs**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: '**epsrel**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: '**norm**{‘max’, ‘2’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Vector norm to use for error estimation.
  prefs: []
  type: TYPE_NORMAL
- en: '**cache_size**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of bytes to use for memoization.
  prefs: []
  type: TYPE_NORMAL
- en: '**limit**float or int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: An upper bound on the number of subintervals used in the adaptive algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '**workers**int or map-like callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *workers* is an integer, part of the computation is done in parallel subdivided
    to this many tasks (using [`multiprocessing.pool.Pool`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool
    "(in Python v3.12)")). Supply *-1* to use all cores available to the Process.
    Alternatively, supply a map-like callable, such as [`multiprocessing.pool.Pool.map`](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool.map
    "(in Python v3.12)") for evaluating the population in parallel. This evaluation
    is carried out as `workers(func, iterable)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**points**list, optional'
  prefs: []
  type: TYPE_NORMAL
- en: List of additional breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '**quadrature**{‘gk21’, ‘gk15’, ‘trapezoid’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quadrature rule to use on subintervals. Options: ‘gk21’ (Gauss-Kronrod 21-point
    rule), ‘gk15’ (Gauss-Kronrod 15-point rule), ‘trapezoid’ (composite trapezoid
    rule). Default: ‘gk21’ for finite intervals and ‘gk15’ for (semi-)infinite'
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Return an additional `info` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments to pass to function, if any.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**res**{float, array-like}'
  prefs: []
  type: TYPE_NORMAL
- en: Estimate for the result
  prefs: []
  type: TYPE_NORMAL
- en: '**err**float'
  prefs: []
  type: TYPE_NORMAL
- en: Error estimate for the result in the given norm
  prefs: []
  type: TYPE_NORMAL
- en: '**info**dict'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returned only when `full_output=True`. Info dictionary. Is an object with the
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: successbool
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether integration reached target precision.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: statusint
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indicator for convergence, success (0), failure (1), and failure due to rounding
    error (2).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: nevalint
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number of function evaluations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: intervalsndarray, shape (num_intervals, 2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Start and end points of subdivision intervals.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: integralsndarray, shape (num_intervals, …)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Integral for each interval. Note that at most `cache_size` values are recorded,
    and the array may contains *nan* for missing items.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: errorsndarray, shape (num_intervals,)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Estimated integration error for each interval.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm mainly follows the implementation of QUADPACK’s DQAG* algorithms,
    implementing global error control and adaptive subdivision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm here has some differences to the QUADPACK approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of subdividing one interval at a time, the algorithm subdivides N intervals
    with largest errors at once. This enables (partial) parallelization of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: The logic of subdividing “next largest” intervals first is then not implemented,
    and we rely on the above extension to avoid concentrating on “small” intervals
    only.
  prefs: []
  type: TYPE_NORMAL
- en: The Wynn epsilon table extrapolation is not used (QUADPACK uses it for infinite
    intervals). This is because the algorithm here is supposed to work on vector-valued
    functions, in an user-specified norm, and the extension of the epsilon algorithm
    to this case does not appear to be widely agreed. For max-norm, using elementwise
    Wynn epsilon could be possible, but we do not do this here with the hope that
    the epsilon extrapolation is mainly useful in special cases.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] R. Piessens, E. de Doncker, QUADPACK (1983).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compute integrations of a vector-valued function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-integrate-quad_vec-1.png](../Images/444b3d528ca49cc4ae06b62d453f4893.png)'
  prefs: []
  type: TYPE_IMG
