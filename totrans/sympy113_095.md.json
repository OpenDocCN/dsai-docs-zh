["```py\n>     >>> from sympy import ImageSet, S, Lambda\n> \n>     >>> from sympy.abc import x\n> \n>     >>> squares = ImageSet(Lambda(x, x**2), S.Naturals)  # {x**2 for x in N}\n> \n>     >>> 4 in squares\n> \n>     True \n>     ```", "```py\n>>> from sympy import FiniteSet\n>>> FiniteSet(1, 2, 3)   # Unordered\n{1, 2, 3}\n>>> FiniteSet((1, 2, 3))  # Ordered\n{(1, 2, 3)} \n```", "```py\n>>> from sympy import solveset, S\n>>> from sympy.abc import x\n>>> solveset(x**2 + 1, x) # domain=S.Complexes is default\n{-I, I}\n>>> solveset(x**2 + 1, x, domain=S.Reals)\nEmptySet \n```", "```py\n>     >>> from sympy import ImageSet, Lambda, pi, S, Dummy, pprint\n> \n>     >>> n = Dummy('n')\n> \n>     >>> pprint(ImageSet(Lambda(n, 2*pi*n), S.Integers), use_unicode=True)\n> \n>     {2⋅n⋅π │ n ∊ ℤ} \n>     ```", "```py\n>     >>> from sympy import ComplexRegion, FiniteSet, Interval, pi, pprint\n> \n>     >>> pprint(ComplexRegion(FiniteSet(1)*Interval(0, 2*pi), polar=True), use_unicode=True)\n> \n>     {r⋅(ⅈ⋅sin(θ) + cos(θ)) │ r, θ ∊ {1} × [0, 2⋅π)} \n>     ```", "```py\n>     >>> from sympy import ComplexRegion, Interval, pi, oo, pprint\n> \n>     >>> pprint(ComplexRegion(Interval(-oo, oo)*Interval(0, oo)), use_unicode=True)\n> \n>     {x + y⋅ⅈ │ x, y ∊ (-∞, ∞) × [0, ∞)} \n>     ```", "```py\n> >>> from sympy import symbols, S, pprint, solveset\n> \n> >>> x, n = symbols('x, n')\n> \n> >>> pprint(solveset(abs(x) - n, x, domain=S.Reals), use_unicode=True)\n> \n> {x │ x ∊ {-n, n} ∧ (n ∈ [0, ∞))} \n> ```", "```py\n> >>> from sympy import Symbol, FiniteSet, Interval, not_empty_in, sqrt, oo\n> \n> >>> from sympy.abc import x\n> \n> >>> not_empty_in(FiniteSet(x/2).intersect(Interval(0, 1)), x)\n> \n> Interval(0, 2)\n> \n> >>> not_empty_in(FiniteSet(x, x**2).intersect(Interval(1, 2)), x)\n> \n> Union(Interval(1, 2), Interval(-sqrt(2), -1)) \n> ```", "```py\n>>> from sympy import solveset\n>>> from sympy import Symbol, Eq\n>>> x = Symbol('x')\n>>> solveset(Eq(x**2, 1), x)\n{-1, 1} \n```", "```py\n>>> solveset(x**2 - 1, x)\n{-1, 1} \n```", "```py\nsympy.solvers.solveset.solveset(f, symbol=None, domain=Complexes)\n```", "```py\n>>> from sympy import exp, sin, Symbol, pprint, S, Eq\n>>> from sympy.solvers.solveset import solveset, solveset_real \n```", "```py\n>>> x = Symbol('x')\n>>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n{2*n*I*pi | n in Integers} \n```", "```py\n>>> x = Symbol('x', real=True)\n>>> pprint(solveset(exp(x) - 1, x), use_unicode=False)\n{2*n*I*pi | n in Integers} \n```", "```py\n>>> R = S.Reals\n>>> x = Symbol('x')\n>>> solveset(exp(x) - 1, x, R)\n{0}\n>>> solveset_real(exp(x) - 1, x)\n{0} \n```", "```py\n>>> p = Symbol('p', positive=True)\n>>> pprint(solveset(p**2 - 4))\n{-2, 2} \n```", "```py\n>>> i = Symbol('i', imaginary=True)\n>>> solveset(Eq(i**2 + i*sin(i), 1), i, domain=S.Reals)\nConditionSet(_R, Eq(_R**2 + _R*sin(_R) - 1, 0), Reals) \n```", "```py\n>>> solveset(exp(x) > 1, x, R)\nInterval.open(0, oo) \n```", "```py\nsympy.solvers.solveset.solveset_real(f, symbol)\n```", "```py\nsympy.solvers.solveset.solveset_complex(f, symbol)\n```", "```py\nsympy.solvers.solveset.invert_real(f_x, y, x)\n```", "```py\nsympy.solvers.solveset.invert_complex(f_x, y, x, domain=Complexes)\n```", "```py\n>>> from sympy.solvers.solveset import invert_complex, invert_real\n>>> from sympy.abc import x, y\n>>> from sympy import exp \n```", "```py\n>>> invert_complex(exp(x), y, x)\n(x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers))\n>>> invert_real(exp(x), y, x)\n(x, Intersection({log(y)}, Reals)) \n```", "```py\n>>> invert_complex(exp(x), 1, x)\n(x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))\n>>> invert_real(exp(x), 1, x)\n(x, {0}) \n```", "```py\nsympy.solvers.solveset.domain_check(f, symbol, p)\n```", "```py\n>>> from sympy import Mul, oo\n>>> from sympy.abc import x\n>>> from sympy.solvers.solveset import domain_check\n>>> g = 1/(1 + (1/(x + 1))**2)\n>>> domain_check(g, x, -1)\nFalse\n>>> domain_check(x**2, x, 0)\nTrue\n>>> domain_check(1/x, x, oo)\nFalse \n```", "```py\n>>> domain_check(x/x, x, 0) # x/x is automatically simplified to 1\nTrue \n```", "```py\n>>> domain_check(Mul(x, 1/x, evaluate=False), x, 0)\nFalse \n```", "```py\nsympy.solvers.solveset.solvify(f, symbol, domain)\n```", "```py\n>>> from sympy.solvers.solveset import solvify\n>>> from sympy.abc import x\n>>> from sympy import S, tan, sin, exp\n>>> solvify(x**2 - 9, x, S.Reals)\n[-3, 3]\n>>> solvify(sin(x) - 1, x, S.Reals)\n[pi/2]\n>>> solvify(tan(x), x, S.Reals)\n[0]\n>>> solvify(exp(x) - 1, x, S.Complexes) \n```", "```py\n>>> solvify(exp(x) - 1, x, S.Reals)\n[0] \n```", "```py\nsympy.solvers.solveset.linear_eq_to_matrix(equations, *symbols)\n```", "```py\n>>> from sympy import linear_eq_to_matrix, symbols\n>>> c, x, y, z = symbols('c, x, y, z') \n```", "```py\n>>> eqns = [c*x + z - 1 - c, y + z, x - y]\n>>> A, b = linear_eq_to_matrix(eqns, [x, y, z])\n>>> A\nMatrix([\n[c,  0, 1],\n[0,  1, 1],\n[1, -1, 0]])\n>>> b\nMatrix([\n[c + 1],\n[    0],\n[    0]]) \n```", "```py\n> >>> eqns = [\n> \n> ...     (x**2 - 3*x)/(x - 3) - 3,\n> \n> ...     y**2 - 3*y - y*(y - 4) + x - 4]\n> \n> >>> linear_eq_to_matrix(eqns, [x, y])\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> NonlinearError:\n> \n> symbol-dependent term can be ignored using `strict=False` \n> ```", "```py\n> >>> [e.simplify() for e in eqns]\n> \n> [x - 3, x + y - 4] \n> ```", "```py\nsympy.solvers.solveset.linsolve(system, *symbols)\n```", "```py\nsystem = Matrix([[3, 2, -1, 1], [2, -2, 4, -2], [2, -1, 2, 0]]) \n```", "```py\nsystem  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z] \n```", "```py\nA = Matrix([[3, 2, -1], [2, -2, 4], [2, -1, 2]])\nb = Matrix([[1], [-2], [0]])\nsystem = (A, b) \n```", "```py\n>>> from sympy import Matrix, linsolve, symbols\n>>> x, y, z = symbols(\"x, y, z\")\n>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])\n>>> b = Matrix([3, 6, 9])\n>>> A\nMatrix([\n[1, 2,  3],\n[4, 5,  6],\n[7, 8, 10]])\n>>> b\nMatrix([\n[3],\n[6],\n[9]])\n>>> linsolve((A, b), [x, y, z])\n{(-1, 2, 0)} \n```", "```py\n>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> b = Matrix([3, 6, 9])\n>>> linsolve((A, b), x, y, z)\n{(z - 1, 2 - 2*z, z)} \n```", "```py\n>>> linsolve((A, b))\n{(tau0 - 1, 2 - 2*tau0, tau0)} \n```", "```py\n>>> Eqns = [3*x + 2*y - z - 1, 2*x - 2*y + 4*z + 2, - x + y/2 - z]\n>>> linsolve(Eqns, x, y, z)\n{(1, -2, -2)} \n```", "```py\n>>> aug = Matrix([[2, 1, 3, 1], [2, 6, 8, 3], [6, 8, 18, 5]])\n>>> aug\nMatrix([\n[2, 1,  3, 1],\n[2, 6,  8, 3],\n[6, 8, 18, 5]])\n>>> linsolve(aug, x, y, z)\n{(3/10, 2/5, 0)} \n```", "```py\n>>> a, b, c, d, e, f = symbols('a, b, c, d, e, f')\n>>> eqns = [a*x + b*y - c, d*x + e*y - f]\n>>> linsolve(eqns, x, y)\n{((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))} \n```", "```py\n>>> system = Matrix(([0, 0, 0], [0, 0, 0], [0, 0, 0]))\n>>> linsolve(system, x, y)\n{(x, y)} \n```", "```py\n>>> linsolve([], x)\nEmptySet \n```", "```py\n>>> linsolve([x*(1/x - 1)], x)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear term: 1/x \n```", "```py\n>>> linsolve([x*(y + 1)], x, y)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear cross-term: x*(y + 1) \n```", "```py\n>>> linsolve([x**2 - 1], x)\nTraceback (most recent call last):\n...\nNonlinearError: nonlinear term: x**2 \n```", "```py\nsympy.solvers.solveset.nonlinsolve(system, *symbols)\n```", "```py\nsystem  = [x*y - 1, 4*x**2 + y**2 - 5]\nsymbols = [x, y] \n```", "```py\n>>> from sympy import symbols, nonlinsolve\n>>> x, y, z = symbols('x, y, z', real=True)\n>>> nonlinsolve([x*y - 1, 4*x**2 + y**2 - 5], [x, y])\n{(-1, -1), (-1/2, -2), (1/2, 2), (1, 1)} \n```", "```py\n>>> from sympy import pprint\n>>> from sympy.polys.polytools import is_zero_dimensional\n>>> a, b, c, d = symbols('a, b, c, d', extended_real=True)\n>>> eq1 =  a + b + c + d\n>>> eq2 = a*b + b*c + c*d + d*a\n>>> eq3 = a*b*c + b*c*d + c*d*a + d*a*b\n>>> eq4 = a*b*c*d - 1\n>>> system = [eq1, eq2, eq3, eq4]\n>>> is_zero_dimensional(system)\nFalse\n>>> pprint(nonlinsolve(system, [a, b, c, d]), use_unicode=False)\n -1       1               1      -1\n{(---, -d, -, {d} \\ {0}), (-, -d, ---, {d} \\ {0})}\n d       d               d       d\n>>> nonlinsolve([(x+y)**2 - 4, x + y - 2], [x, y])\n{(2 - y, y)} \n```", "```py\n>>> from sympy import exp, sin\n>>> nonlinsolve([exp(x) - sin(y), y**2 - 4], [x, y])\n{(ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2),\n (ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2)} \n```", "```py\n>>> from sympy import sqrt\n>>> nonlinsolve([x**2 - 2*y**2 -2, x*y - 2], [x, y])\n{(-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I)} \n```", "```py\n>>> nonlinsolve([x + 2*y -z - 3, x - y - 4*z + 9, y + z - 4], [x, y, z])\n{(3*z - 5, 4 - z, z)} \n```", "```py\n>>> e1 = sqrt(x**2 + y**2) - 10\n>>> e2 = sqrt(y**2 + (-x + 10)**2) - 3\n>>> nonlinsolve((e1, e2), (x, y))\n{(191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20)}\n>>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [x, y])\n{(1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5))}\n>>> nonlinsolve([x**2 + 2/y - 2, x + y - 3], [y, x])\n{(2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5))} \n```", "```py\nsympy.solvers.solveset._transolve(f, symbol, domain)\n```", "```py\n>>> from sympy.solvers.solveset import _transolve as transolve\n>>> from sympy.solvers.solvers import _tsolve as tsolve\n>>> from sympy import symbols, S, pprint\n>>> x = symbols('x', real=True) # assumption added\n>>> transolve(5**(x - 3) - 3**(2*x + 1), x, S.Reals)\n{-(log(3) + 3*log(5))/(-log(5) + 2*log(3))} \n```", "```py\n>>> f = 3**(2*x) - 2**(x + 3)\n>>> pprint(transolve(f, x, S.Reals), use_unicode=False)\n -3*log(2)\n{------------------}\n -2*log(3) + log(2)\n>>> pprint(tsolve(f, x), use_unicode=False)\n /   3     \\\n | --------|\n | log(2/9)|\n[-log\\2         /] \n```", "```py\n    def add_type(lhs, rhs, x):\n        ....\n        if _is_exponential(lhs, x):\n            new_eq = _solve_exponential(lhs, rhs, x)\n    ....\n    rhs, lhs = eq.as_independent(x)\n    if lhs.is_Add:\n        result = add_type(lhs, rhs, x) \n    ```", "```py\nsympy.solvers.solveset._is_exponential(f, symbol)\n```", "```py\n>>> from sympy import symbols, cos, exp\n>>> from sympy.solvers.solveset import _is_exponential as check\n>>> x, y = symbols('x y')\n>>> check(y, y)\nFalse\n>>> check(x**y - 1, y)\nTrue\n>>> check(x**y*2**y - 1, y)\nTrue\n>>> check(exp(x + 3) + 3**x, x)\nTrue\n>>> check(cos(2**x), x)\nFalse \n```", "```py\nsympy.solvers.solveset._solve_exponential(lhs, rhs, symbol, domain)\n```", "```py\n>>> from sympy.solvers.solveset import _solve_exponential as solve_expo\n>>> from sympy import symbols, S\n>>> x = symbols('x', real=True)\n>>> a, b = symbols('a b')\n>>> solve_expo(2**x + 3**x - 5**x, 0, x, S.Reals)  # not solvable\nConditionSet(x, Eq(2**x + 3**x - 5**x, 0), Reals)\n>>> solve_expo(a**x - b**x, 0, x, S.Reals)  # solvable but incorrect assumptions\nConditionSet(x, (a > 0) & (b > 0), {0})\n>>> solve_expo(3**(2*x) - 2**(x + 3), 0, x, S.Reals)\n{-3*log(2)/(-2*log(3) + log(2))}\n>>> solve_expo(2**x - 4**x, 0, x, S.Reals)\n{0} \n```", "```py\nsympy.solvers.solveset._solve_logarithm(lhs, rhs, symbol, domain)\n```", "```py\n>>> from sympy import symbols, log, S\n>>> from sympy.solvers.solveset import _solve_logarithm as solve_log\n>>> x = symbols('x')\n>>> f = log(x - 3) + log(x + 3)\n>>> solve_log(f, 0, x, S.Reals)\n{-sqrt(10), sqrt(10)} \n```", "```py\nsympy.solvers.solveset._is_logarithmic(f, symbol)\n```", "```py\n>>> from sympy import symbols, tan, log\n>>> from sympy.solvers.solveset import _is_logarithmic as check\n>>> x, y = symbols('x y')\n>>> check(log(x + 2) - log(x + 3), x)\nTrue\n>>> check(tan(log(2*x)), x)\nFalse\n>>> check(x*log(x), x)\nFalse\n>>> check(x + log(x), x)\nFalse\n>>> check(y + log(x), x)\nTrue \n```"]