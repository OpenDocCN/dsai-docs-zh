# 多项式域的参考文档

> 原文：[https://docs.sympy.org/latest/modules/polys/domainsref.html](https://docs.sympy.org/latest/modules/polys/domainsref.html)

此页面列出了 polys 模块中域的参考文档。推荐阅读[模块的基本功能](basics.html#polys-basics)以获得 polys 模块的一般介绍。建议阅读[介绍多项式模块中的域](domainsintro.html#polys-domainsintro)以了解域系统的基本功能和使用方法的介绍。此页面列出了[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")类及其子类（例如 `ZZ` 等具体域）的参考文档，以及表示域元素的类。

## 域

这里我们记录了各种已实现的基础域（详见[介绍多项式模块中的域](domainsintro.html#polys-domainsintro)）。有三种[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")子类：抽象域、具体域和“实现域”。抽象域不能（有用地）被实例化，并且仅仅汇集了许多其他域共享的功能。具体域意味着可以实例化并用于多项式操作算法中。在某些情况下，实现数据类型的方式有多种可能性。例如，依赖于系统上可用的库，整数可以使用 Python 内置整数或使用 gmpy 实现。请注意，根据可用的库会自动创建各种别名。因此，例如 `ZZ` 总是指向系统中最有效的整数环的实现。

## 抽象域

```py
class sympy.polys.domains.domain.Domain
```

polys 域系统中所有域的超类。

参见[介绍多项式模块中的域](domainsintro.html#polys-domainsintro)以了解域系统的介绍。

[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 类是所有具体域类型的抽象基类。有许多不同的[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")子类，每个子类都有一个关联的 `dtype`，它是表示域元素的类。[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") 的系数是域的元素，必须是 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 的子类。

示例

最常见的示例域是整数 [ZZ](#zz) 和有理数 [QQ](#qq)。

```py
>>> from sympy import Poly, symbols, Domain
>>> x, y = symbols('x, y')
>>> p = Poly(x**2 + y)
>>> p
Poly(x**2 + y, x, y, domain='ZZ')
>>> p.domain
ZZ
>>> isinstance(p.domain, Domain)
True
>>> Poly(x**2 + y/2)
Poly(x**2 + 1/2*y, x, y, domain='QQ') 
```

可以直接使用域对象（例如 ([ZZ](#zz) 或 [QQ](#qq)）作为 `dtype` 元素的构造函数。

```py
>>> from sympy import ZZ, QQ
>>> ZZ(2)
2
>>> ZZ.dtype  
<class 'int'>
>>> type(ZZ(2))  
<class 'int'>
>>> QQ(1, 2)
1/2
>>> type(QQ(1, 2))  
<class 'sympy.polys.domains.pythonrational.PythonRational'> 
```

相应的域元素可以用于算术运算 `+,-,*,**`，根据域的不同，可能还可以使用 `/,//,%` 的某些组合。例如，在 [ZZ](#zz) 中，`//`（地板除法）和 `%`（模除法）都可以使用，但 `/`（真除法）不能使用。由于 [QQ](#qq) 是一个 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field")，它的元素可以使用 `/`，但不应使用 `//` 和 `%`。一些域有 [`gcd()`](#sympy.polys.domains.domain.Domain.gcd "sympy.polys.domains.domain.Domain.gcd") 方法。

```py
>>> ZZ(2) + ZZ(3)
5
>>> ZZ(5) // ZZ(2)
2
>>> ZZ(5) % ZZ(2)
1
>>> QQ(1, 2) / QQ(2, 3)
3/4
>>> ZZ.gcd(ZZ(4), ZZ(2))
2
>>> QQ.gcd(QQ(2,7), QQ(5,3))
1/21
>>> ZZ.is_Field
False
>>> QQ.is_Field
True 
```

还有许多其他的域，包括：

> 1.  [GF(p)](#gf-p) 代表素数阶有限域。
> 1.  
> 1.  [RR](#rr) 代表实数（浮点数）。
> 1.  
> 1.  [CC](#cc) 代表复数（浮点数）。
> 1.  
> 1.  [QQ<a>](#qq-a) 代表代数数域。
> 1.  
> 1.  [K[x]](#k-x) 代表多项式环。
> 1.  
> 1.  [K(x)](#id11) 代表有理函数域。
> 1.  
> 1.  [EX](#ex) 代表任意表达式。

每个域都由一个域对象和一个元素域的实现类（`dtype`）表示。例如，[K[x]](#k-x) 域由一个域对象表示，该对象是 [`PolynomialRing`](#sympy.polys.domains.PolynomialRing "sympy.polys.domains.PolynomialRing") 的一个实例，其元素始终是 [`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement") 的实例。这个实现类以比 SymPy 表达式（类型为 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")）更高效的方式表示特定类型的数学表达式。域方法 [`from_sympy()`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy") 和 [`to_sympy()`](#sympy.polys.domains.domain.Domain.to_sympy "sympy.polys.domains.domain.Domain.to_sympy") 用于在 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") 和域元素之间进行转换。

```py
>>> from sympy import Symbol, ZZ, Expr
>>> x = Symbol('x')
>>> K = ZZ[x]           # polynomial ring domain
>>> K
ZZ[x]
>>> type(K)             # class of the domain
<class 'sympy.polys.domains.polynomialring.PolynomialRing'>
>>> K.dtype             # class of the elements
<class 'sympy.polys.rings.PolyElement'>
>>> p_expr = x**2 + 1   # Expr
>>> p_expr
x**2 + 1
>>> type(p_expr)
<class 'sympy.core.add.Add'>
>>> isinstance(p_expr, Expr)
True
>>> p_domain = K.from_sympy(p_expr)
>>> p_domain            # domain element
x**2 + 1
>>> type(p_domain)
<class 'sympy.polys.rings.PolyElement'>
>>> K.to_sympy(p_domain) == p_expr
True 
```

方法 [`convert_from()`](#sympy.polys.domains.domain.Domain.convert_from "sympy.polys.domains.domain.Domain.convert_from") 用于将域元素从一个域转换到另一个域。

```py
>>> from sympy import ZZ, QQ
>>> ez = ZZ(2)
>>> eq = QQ.convert_from(ez, ZZ)
>>> type(ez)  
<class 'int'>
>>> type(eq)  
<class 'sympy.polys.domains.pythonrational.PythonRational'> 
```

不同域的元素不应混合在算术或其他操作中：它们应首先转换为一个公共域。域方法 [`unify()`](#sympy.polys.domains.domain.Domain.unify "sympy.polys.domains.domain.Domain.unify") 用于找到一个可以表示两个给定域所有元素的域。

```py
>>> from sympy import ZZ, QQ, symbols
>>> x, y = symbols('x, y')
>>> ZZ.unify(QQ)
QQ
>>> ZZ[x].unify(QQ)
QQ[x]
>>> ZZ[x].unify(QQ[y])
QQ[x,y] 
```

如果一个域是 [`Ring`](#sympy.polys.domains.ring.Ring "sympy.polys.domains.ring.Ring")，那么可能有一个关联的 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field")，反之亦然。方法 [`get_field()`](#sympy.polys.domains.domain.Domain.get_field "sympy.polys.domains.domain.Domain.get_field") 和 [`get_ring()`](#sympy.polys.domains.domain.Domain.get_ring "sympy.polys.domains.domain.Domain.get_ring") 将找到或创建相关联的域。

```py
>>> from sympy import ZZ, QQ, Symbol
>>> x = Symbol('x')
>>> ZZ.has_assoc_Field
True
>>> ZZ.get_field()
QQ
>>> QQ.has_assoc_Ring
True
>>> QQ.get_ring()
ZZ
>>> K = QQ[x]
>>> K
QQ[x]
>>> K.get_field()
QQ(x) 
```

另见

[`DomainElement`](#sympy.polys.domains.domainelement.DomainElement "sympy.polys.domains.domainelement.DomainElement")

一些表达式的最小域的抽象基类

[`construct_domain`](reference.html#sympy.polys.constructor.construct_domain "sympy.polys.constructor.construct_domain")

构造一些表达式的最小域。

```py
abs(a)
```

`a` 的绝对值，意味着 `__abs__`。

```py
add(a, b)
```

`a` 和 `b` 的和，意味着 `__add__`。

```py
alg_field_from_poly(poly, alias=None, root_index=-1)
```

便捷方法，根据根索引在多项式的根上构造代数扩展。

参数：

**poly** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")

> 生成扩展的多项式。

**alias** : 字符串，可选（默认为None）

> 扩展的生成器的符号名称。例如“alpha”或“theta”。

**root_index** : 整数，可选（默认为-1）

> 指定所需的多项式根。排序方式由[`ComplexRootOf`](reference.html#sympy.polys.rootoftools.ComplexRootOf "sympy.polys.rootoftools.ComplexRootOf")类定义。在二次和旋转多边形场合的常见情况下，默认值为`-1`选择最自然的选择（正实轴或虚轴上的平方根，即 \(\mathrm{e}^{2\pi i/n}\)）。

示例

```py
>>> from sympy import QQ, Poly
>>> from sympy.abc import x
>>> f = Poly(x**2 - 2)
>>> K = QQ.alg_field_from_poly(f)
>>> K.ext.minpoly == f
True
>>> g = Poly(8*x**3 - 6*x - 1)
>>> L = QQ.alg_field_from_poly(g, "alpha")
>>> L.ext.minpoly == g
True
>>> L.to_sympy(L([1, 1, 1]))
alpha**2 + alpha + 1 
```

```py
algebraic_field(*extension, alias=None)
```

返回一个代数域，即 \(K(\alpha, \ldots)\)。

```py
almosteq(a, b, tolerance=None)
```

检查 `a` 和 `b` 是否几乎相等。

```py
characteristic()
```

返回此域的特征。

```py
cofactors(a, b)
```

返回 `a` 和 `b` 的最大公因数及其余子。

```py
convert(element, base=None)
```

将 `element` 转换为 `self.dtype`。

```py
convert_from(element, base)
```

根据基域给定的域元素将 `element` 转换为 `self.dtype`。

```py
cyclotomic_field(n, ss=False, alias='zeta', gen=None, root_index=-1)
```

便捷方法，构造旋转多边形场。

参数：

**n** : 整数

> 构造第`n`个旋转多边形场。

**ss** : 布尔值，可选（默认为False）

> 如果为真，在别名字符串上附加 *n* 作为下标。

**alias** : 字符串，可选（默认为“zeta”）

> 生成器的符号名称。

**gen** : [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")，可选（默认为None）

> 欲定义该领域的旋转多边形的变量。如果为 `None`，将使用虚拟变量。

**root_index** : 整数，可选（默认为-1）

> 指定所需的多项式根。排序方式由[`ComplexRootOf`](reference.html#sympy.polys.rootoftools.ComplexRootOf "sympy.polys.rootoftools.ComplexRootOf")类定义。默认值为`-1`选择根 \(\mathrm{e}^{2\pi i/n}\)。

示例

```py
>>> from sympy import QQ, latex
>>> K = QQ.cyclotomic_field(5)
>>> K.to_sympy(K([-1, 1]))
1 - zeta
>>> L = QQ.cyclotomic_field(7, True)
>>> a = L.to_sympy(L([-1, 1]))
>>> print(a)
1 - zeta7
>>> print(latex(a))
1 - \zeta_{7} 
```

```py
denom(a)
```

返回 `a` 的分母。

```py
div(a, b)
```

*a* 和 *b* 的商和余数。类似于 `divmod(a, b)`

参数：

**a：域元素**

> 被除数

**b：域元素**

> 除数

返回：

(q, r): 域元素的元组

> 商和余数

异常：

**当除数为零时，抛出ZeroDivisionError。**

说明

在一些 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field") 域上工作时，这与 `divmod(a, b)` 本质上相同，例如 [QQ](#qq)。在任意 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 上工作时，应使用 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 方法而不是 `divmod`。

关键不变性是，如果 `q, r = K.div(a, b)`，那么 `a == b*q + r`。

`K.div(a, b)` 的结果与元组 `(K.quo(a, b), K.rem(a, b))` 相同，只是如果需要商和余数，则使用 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 更有效率。

示例

我们可以使用 `K.div` 替代 `divmod` 进行地板除法和余数运算。

```py
>>> from sympy import ZZ, QQ
>>> ZZ.div(ZZ(5), ZZ(2))
(2, 1) 
```

如果 `K` 是一个 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field")，则除法总是精确的，并且余数为 [`zero`](#sympy.polys.domains.domain.Domain.zero "sympy.polys.domains.domain.Domain.zero")。

```py
>>> QQ.div(QQ(5), QQ(2))
(5/2, 0) 
```

注意事项

如果安装了 `gmpy`，则 [`dtype`](#sympy.polys.domains.domain.Domain.dtype "sympy.polys.domains.domain.Domain.dtype") 将使用 `gmpy.mpq` 类型作为 [QQ](#qq) 的类型。`gmpy.mpq` 类型定义了 `divmod`，但其行为不佳，因此应使用 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 而不是 `divmod`。

```py
>>> a = QQ(1)
>>> b = QQ(3, 2)
>>> a               
mpq(1,1)
>>> b               
mpq(3,2)
>>> divmod(a, b)    
(mpz(0), mpq(1,1))
>>> QQ.div(a, b)    
(mpq(2,3), mpq(0,1)) 
```

在 [QQ](#qq) 中使用 `//` 或 `%` 会导致不正确的结果，因此应使用 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div")。

参见

[`quo`](#sympy.polys.domains.domain.Domain.quo "sympy.polys.domains.domain.Domain.quo")

模拟 `a // b`

[`rem`](#sympy.polys.domains.domain.Domain.rem "sympy.polys.domains.domain.Domain.rem")

模拟 `a % b`

[`exquo`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")

模拟 `a / b`

```py
drop(*symbols)
```

从该域中删除生成器。

```py
dtype: type | None = None
```

此 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 中元素的类型（类）：

```py
>>> from sympy import ZZ, QQ, Symbol
>>> ZZ.dtype
<class 'int'>
>>> z = ZZ(2)
>>> z
2
>>> type(z)
<class 'int'>
>>> type(z) == ZZ.dtype
True 
```

每个域都有一个关联的 **dtype**（“数据类型”），即关联域元素的类。

参见

[`of_type`](#sympy.polys.domains.domain.Domain.of_type "sympy.polys.domains.domain.Domain.of_type")

```py
evalf(a, prec=None, **options)
```

返回 `a` 的数值近似。

```py
exquo(a, b)
```

*a* 和 *b* 的精确商。模拟 `a / b`。

参数：

**a: 域元素**

> 被除数

**b: 域元素**

> 除数

返回：

q: 域元素

> 精确商

引发：

**ExactQuotientFailed: 如果无法进行精确除法。**

**ZeroDivisionError: 当除数为零时。**

解释

这本质上与 `a / b` 相同，但如果除法不精确（即存在任何余数），则会引发错误，并且结果始终是域元素。在工作于不是 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field") 的 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 中时（例如 [ZZ](#zz) 或 [K[x]](#k-x)），应使用 `exquo` 而不是 `/`。

关键不变量是如果 `q = K.exquo(a, b)`（且 `exquo` 没有引发异常），则 `a == b*q`。

例子

我们可以使用 `K.exquo` 而不是 `/` 进行精确除法。

```py
>>> from sympy import ZZ
>>> ZZ.exquo(ZZ(4), ZZ(2))
2
>>> ZZ.exquo(ZZ(5), ZZ(2))
Traceback (most recent call last):
  ...
ExactQuotientFailed: 2 does not divide 5 in ZZ 
```

在像 [QQ](#qq) 这样的 [`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field") 上，除法（非零除数）总是精确的，因此在这种情况下可以使用 `/` 而不是 [`exquo()`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")。

```py
>>> from sympy import QQ
>>> QQ.exquo(QQ(5), QQ(2))
5/2
>>> QQ(5) / QQ(2)
5/2 
```

注意

由于默认的 [`dtype`](#sympy.polys.domains.domain.Domain.dtype "sympy.polys.domains.domain.Domain.dtype") 对于 [ZZ](#zz) 是 `int`（或 `mpz`），所以应避免使用 `a / b`，因为它会给出一个不是域元素的 `float`。

```py
>>> ZZ(4) / ZZ(2) 
2.0
>>> ZZ(5) / ZZ(2) 
2.5 
```

另一方面，使用 \(SYMPY_GROUND_TYPES=flint\) 在 [ZZ](#zz) 中的元素是 `flint.fmpz`，并且除法将引发异常：

```py
>>> ZZ(4) / ZZ(2) 
Traceback (most recent call last):
...
TypeError: unsupported operand type(s) for /: 'fmpz' and 'fmpz' 
```

在 [ZZ](#zz) 使用 `/` 将导致不正确的结果，因此应该使用 [`exquo()`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo") 而不是 `/`。

参见

[`quo`](#sympy.polys.domains.domain.Domain.quo "sympy.polys.domains.domain.Domain.quo")

`a // b` 的类似物

[`rem`](#sympy.polys.domains.domain.Domain.rem "sympy.polys.domains.domain.Domain.rem")

`a % b` 的类似物

[`div`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div")

`divmod(a, b)` 的类似物

```py
exsqrt(a)
```

如果 `a` 是平方的，域内 `a` 的主要平方根。

解释

此方法的实现应返回域内的元素 `b`，使得 `b * b == a`，如果没有这样的 `b` 则返回 `None`。对于不精确的域如 [RR](#rr) 和 [CC](#cc)，在这个相等性上可以容忍微小差异。在可能的情况下，应遵循一致的规则选择“主要”平方根。

参见

[`sqrt`](#sympy.polys.domains.domain.Domain.sqrt "sympy.polys.domains.domain.Domain.sqrt")，[`is_square`](#sympy.polys.domains.domain.Domain.is_square "sympy.polys.domains.domain.Domain.is_square")

```py
frac_field(*symbols, order=LexOrder())
```

返回一个分式域，即 \(K(X)\)。

```py
from_AlgebraicField(a, K0)
```

将代数数转换为 `dtype`。

```py
from_ComplexField(a, K0)
```

将复数元素转换为 `dtype`。

```py
from_ExpressionDomain(a, K0)
```

将 `EX` 对象转换为 `dtype`。

```py
from_ExpressionRawDomain(a, K0)
```

将 `EX` 对象转换为 `dtype`。

```py
from_FF(a, K0)
```

将 `ModularInteger(int)` 转换为 `dtype`。

```py
from_FF_gmpy(a, K0)
```

将 `ModularInteger(mpz)` 转换为 `dtype`。

```py
from_FF_python(a, K0)
```

将 `ModularInteger(int)` 转换为 `dtype`。

```py
from_FractionField(a, K0)
```

将有理函数转换为 `dtype`。

```py
from_GlobalPolynomialRing(a, K0)
```

将多项式转换为 `dtype`。

```py
from_MonogenicFiniteExtension(a, K0)
```

将 `ExtensionElement` 转换为 `dtype`。

```py
from_PolynomialRing(a, K0)
```

将多项式转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 `mpq` 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python 的 `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将实数元素对象转换为`dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 `mpz` 对象转换为 `dtype`。

```py
from_ZZ_python(a, K0)
```

将 Python 的 `int` 对象转换为 `dtype`。

```py
from_sympy(a)
```

将 SymPy 表达式转换为该域的元素。

参数：

**expr: Expr**

> 一个普通的 SymPy 表达式，类型为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。

返回：

a: 域元素

> 该[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")的一个元素。

说明

参见[`to_sympy()`](#sympy.polys.domains.domain.Domain.to_sympy "sympy.polys.domains.domain.Domain.to_sympy")以获取说明和示例。

另见

[`to_sympy`](#sympy.polys.domains.domain.Domain.to_sympy "sympy.polys.domains.domain.Domain.to_sympy"), [`convert_from`](#sympy.polys.domains.domain.Domain.convert_from "sympy.polys.domains.domain.Domain.convert_from")

```py
gcd(a, b)
```

返回`a`和`b`的最大公约数。

```py
gcdex(a, b)
```

`a`和`b`的扩展欧几里得算法。

```py
get_exact()
```

返回与`self`相关联的精确域。

```py
get_field()
```

返回与`self`相关联的域。

```py
get_ring()
```

返回与`self`相关联的环。

```py
half_gcdex(a, b)
```

`a`和`b`的半扩展欧几里得算法。

```py
has_assoc_Field = False
```

布尔标志，指示域是否具有关联的[`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field")。

```py
>>> from sympy import ZZ
>>> ZZ.has_assoc_Field
True
>>> ZZ.get_field()
QQ 
```

另见

[`is_Field`](#sympy.polys.domains.domain.Domain.is_Field "sympy.polys.domains.domain.Domain.is_Field"), [`get_field`](#sympy.polys.domains.domain.Domain.get_field "sympy.polys.domains.domain.Domain.get_field")

```py
has_assoc_Ring = False
```

布尔标志，指示域是否具有关联的[`Ring`](#sympy.polys.domains.ring.Ring "sympy.polys.domains.ring.Ring")。

```py
>>> from sympy import QQ
>>> QQ.has_assoc_Ring
True
>>> QQ.get_ring()
ZZ 
```

另见

[`is_Field`](#sympy.polys.domains.domain.Domain.is_Field "sympy.polys.domains.domain.Domain.is_Field"), [`get_ring`](#sympy.polys.domains.domain.Domain.get_ring "sympy.polys.domains.domain.Domain.get_ring")

```py
inject(*symbols)
```

将生成器注入到此域。

```py
invert(a, b)
```

返回`a mod b`的倒数，暗示某事。

```py
is_Field = False
```

布尔标志，指示域是否为[`Field`](#sympy.polys.domains.field.Field "sympy.polys.domains.field.Field")。

```py
>>> from sympy import ZZ, QQ
>>> ZZ.is_Field
False
>>> QQ.is_Field
True 
```

另见

[`is_PID`](#sympy.polys.domains.domain.Domain.is_PID "sympy.polys.domains.domain.Domain.is_PID"), [`is_Ring`](#sympy.polys.domains.domain.Domain.is_Ring "sympy.polys.domains.domain.Domain.is_Ring"), [`get_field`](#sympy.polys.domains.domain.Domain.get_field "sympy.polys.domains.domain.Domain.get_field"), [`has_assoc_Field`](#sympy.polys.domains.domain.Domain.has_assoc_Field "sympy.polys.domains.domain.Domain.has_assoc_Field")

```py
is_PID = False
```

布尔标志，指示域是否为[主理想域](https://en.wikipedia.org/wiki/Principal_ideal_domain)。

```py
>>> from sympy import ZZ
>>> ZZ.has_assoc_Field
True
>>> ZZ.get_field()
QQ 
```

另见

[`is_Field`](#sympy.polys.domains.domain.Domain.is_Field "sympy.polys.domains.domain.Domain.is_Field"), [`get_field`](#sympy.polys.domains.domain.Domain.get_field "sympy.polys.domains.domain.Domain.get_field")

```py
is_Ring = False
```

布尔标志，指示域是否为[`Ring`](#sympy.polys.domains.ring.Ring "sympy.polys.domains.ring.Ring")。

```py
>>> from sympy import ZZ
>>> ZZ.is_Ring
True 
```

基本上每个[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")都代表一个环，所以这个标志并不那么有用。

参见

[`is_PID`](#sympy.polys.domains.domain.Domain.is_PID "sympy.polys.domains.domain.Domain.is_PID"), [`is_Field`](#sympy.polys.domains.domain.Domain.is_Field "sympy.polys.domains.domain.Domain.is_Field"), [`get_ring`](#sympy.polys.domains.domain.Domain.get_ring "sympy.polys.domains.domain.Domain.get_ring"), [`has_assoc_Ring`](#sympy.polys.domains.domain.Domain.has_assoc_Ring "sympy.polys.domains.domain.Domain.has_assoc_Ring")

```py
is_negative(a)
```

如果 `a` 是负数则返回 True。

```py
is_nonnegative(a)
```

如果 `a` 是非负数则返回 True。

```py
is_nonpositive(a)
```

如果 `a` 是非正数则返回 True。

```py
is_one(a)
```

如果 `a` 是一则返回 True。

```py
is_positive(a)
```

如果 `a` 是正数则返回 True。

```py
is_square(a)
```

返回 `a` 在域中是否是平方数。

解释

如果在域中存在元素 `b` 使得 `b * b == a`，则返回 `True`，否则返回 `False`。对于像 [RR](#rr) 和 [CC](#cc) 这样的不精确域，可以容忍此等式的微小差异。

参见

[`exsqrt`](#sympy.polys.domains.domain.Domain.exsqrt "sympy.polys.domains.domain.Domain.exsqrt")

```py
is_zero(a)
```

如果 `a` 是零则返回 True。

```py
lcm(a, b)
```

返回 `a` 和 `b` 的最小公倍数。

```py
log(a, b)
```

返回 `a` 的以 `b` 为底的对数。

```py
map(seq)
```

递归地将 `self` 应用于 `seq` 的所有元素。

```py
mul(a, b)
```

`a` 和 `b` 的乘积，意味着 `__mul__`。

```py
n(a, prec=None, **options)
```

返回 `a` 的数值近似。

```py
neg(a)
```

返回 `a` 的相反数，意味着 `__neg__`。

```py
numer(a)
```

返回 `a` 的分子。

```py
of_type(element)
```

检查 `a` 是否是 `dtype` 类型。

```py
old_frac_field(*symbols, **kwargs)
```

返回一个分式域，即 \(K(X)\)。

```py
old_poly_ring(*symbols, **kwargs)
```

返回一个多项式环，即 \(K[X]\)。

```py
one: Any = None
```

[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 的唯一元素：

```py
>>> from sympy import QQ
>>> QQ.one
1
>>> QQ.of_type(QQ.one)
True 
```

参见

[`of_type`](#sympy.polys.domains.domain.Domain.of_type "sympy.polys.domains.domain.Domain.of_type"), [`zero`](#sympy.polys.domains.domain.Domain.zero "sympy.polys.domains.domain.Domain.zero")

```py
poly_ring(*symbols, order=LexOrder())
```

返回一个多项式环，即 \(K[X]\)。

```py
pos(a)
```

返回 `a` 的正数，意味着 `__pos__`。

```py
pow(a, b)
```

将 `a` 的 `b` 次幂返回，意味着 `__pow__`。

```py
quo(a, b)
```

*a* 和 *b* 的商。`a // b` 的类似物。

`K.quo(a, b)` 等同于 `K.div(a, b)[0]`。详见 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 以获取更多解释。

参见

[`rem`](#sympy.polys.domains.domain.Domain.rem "sympy.polys.domains.domain.Domain.rem")

`a % b` 的类似物

[`div`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div")

`divmod(a, b)` 的类似物

[`exquo`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")

`a / b` 的类似物

```py
rem(a, b)
```

*a* 和 *b* 的模除。`a % b` 的类似物。

`K.rem(a, b)` 等同于 `K.div(a, b)[1]`。详见 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 以获取更多解释。

参见

[`quo`](#sympy.polys.domains.domain.Domain.quo "sympy.polys.domains.domain.Domain.quo")

`a // b` 的类似物

[`div`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div")

`divmod(a, b)` 的类似物

[`exquo`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")

`a / b` 的类似物

```py
revert(a)
```

如果可能则返回 `a**(-1)`。

```py
sqrt(a)
```

返回`a`的（可能是不精确的）平方根。

解释

不同域中“不精确平方根”的普遍定义不存在。不建议为除[ZZ](#zz)外的其他域实现此方法。

另见

[`exsqrt`](#sympy.polys.domains.domain.Domain.exsqrt "sympy.polys.domains.domain.Domain.exsqrt")

```py
sub(a, b)
```

`a` 和 `b` 的差异，意味着 `__sub__`。

```py
to_sympy(a)
```

将域元素 *a* 转换为 SymPy 表达式（Expr）。

参数：

**a：域元素**

> 这个[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")的一个元素。

返回：

expr: Expr

> 一个类型为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")的普通SymPy表达式。

解释

将[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")元素*a*转换为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。大多数公共SymPy函数与[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")对象一起工作。[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")的元素具有不同的内部表示。不可能将域元素与[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")混合使用，因此每个域都有[`to_sympy()`](#sympy.polys.domains.domain.Domain.to_sympy "sympy.polys.domains.domain.Domain.to_sympy")和[`from_sympy()`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy")方法来将其域元素转换为和从[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。

示例

构造[QQ](#qq)领域的元素，然后将其转换为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。

```py
>>> from sympy import QQ, Expr
>>> q_domain = QQ(2)
>>> q_domain
2
>>> q_expr = QQ.to_sympy(q_domain)
>>> q_expr
2 
```

尽管打印形式看起来相似，但这些对象并非同一类型。

```py
>>> isinstance(q_domain, Expr)
False
>>> isinstance(q_expr, Expr)
True 
```

构造[K[x]](#k-x)领域的元素并转换为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。

```py
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> K = QQ[x]
>>> x_domain = K.gens[0]  # generator x as a domain element
>>> p_domain = x_domain**2/3 + 1
>>> p_domain
1/3*x**2 + 1
>>> p_expr = K.to_sympy(p_domain)
>>> p_expr
x**2/3 + 1 
```

[`from_sympy()`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy")方法用于从普通的SymPy表达式到域元素的相反转换。

```py
>>> p_domain == p_expr
False
>>> K.from_sympy(p_expr) == p_domain
True
>>> K.to_sympy(p_domain) == p_expr
True
>>> K.from_sympy(K.to_sympy(p_domain)) == p_domain
True
>>> K.to_sympy(K.from_sympy(p_expr)) == p_expr
True 
```

[`from_sympy()`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy")方法使得交互式构造域元素更加容易。

```py
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> K = QQ[x]
>>> K.from_sympy(x**2/3 + 1)
1/3*x**2 + 1 
```

另见

[`from_sympy`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy")，[`convert_from`](#sympy.polys.domains.domain.Domain.convert_from "sympy.polys.domains.domain.Domain.convert_from")

```py
property tp
```

[`dtype`](#sympy.polys.domains.domain.Domain.dtype "sympy.polys.domains.domain.Domain.dtype")的别名

```py
unify(K1, symbols=None)
```

构造包含`K0`和`K1`元素的最小域。

已知领域（从最小到最大）：

+   `GF(p)`

+   `ZZ`

+   `QQ`

+   `RR(prec, tol)`

+   `CC(prec, tol)`

+   `ALG(a, b, c)`

+   `K[x, y, z]`

+   `K(x, y, z)`

+   `EX`

```py
unify_composite(K1)
```

统一至少一个是复合的两个域。

```py
zero: Any = None
```

The zero element of the [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain"):

```py
>>> from sympy import QQ
>>> QQ.zero
0
>>> QQ.of_type(QQ.zero)
True 
```

See also

[`of_type`](#sympy.polys.domains.domain.Domain.of_type "sympy.polys.domains.domain.Domain.of_type"), [`one`](#sympy.polys.domains.domain.Domain.one "sympy.polys.domains.domain.Domain.one")

```py
class sympy.polys.domains.domainelement.DomainElement
```

Represents an element of a domain.

Mix in this trait into a class whose instances should be recognized as elements of a domain. Method `parent()` gives that domain.

```py
parent()
```

Get the domain associated with `self`

Examples

```py
>>> from sympy import ZZ, symbols
>>> x, y = symbols('x, y')
>>> K = ZZ[x,y]
>>> p = K(x)**2 + K(y)**2
>>> p
x**2 + y**2
>>> p.parent()
ZZ[x,y] 
```

Notes

This is used by [`convert()`](#sympy.polys.domains.domain.Domain.convert "sympy.polys.domains.domain.Domain.convert") to identify the domain associated with a domain element.

```py
class sympy.polys.domains.field.Field
```

Represents a field domain.

```py
div(a, b)
```

Division of `a` and `b`, implies `__truediv__`.

```py
exquo(a, b)
```

Exact quotient of `a` and `b`, implies `__truediv__`.

```py
gcd(a, b)
```

Returns GCD of `a` and `b`.

This definition of GCD over fields allows to clear denominators in \(primitive()\).

Examples

```py
>>> from sympy.polys.domains import QQ
>>> from sympy import S, gcd, primitive
>>> from sympy.abc import x 
```

```py
>>> QQ.gcd(QQ(2, 3), QQ(4, 9))
2/9
>>> gcd(S(2)/3, S(4)/9)
2/9
>>> primitive(2*x/3 + S(4)/9)
(2/9, 3*x + 2) 
```

```py
get_field()
```

Returns a field associated with `self`.

```py
get_ring()
```

Returns a ring associated with `self`.

```py
is_unit(a)
```

Return true if `a` is a invertible

```py
lcm(a, b)
```

Returns LCM of `a` and `b`.

```py
>>> from sympy.polys.domains import QQ
>>> from sympy import S, lcm 
```

```py
>>> QQ.lcm(QQ(2, 3), QQ(4, 9))
4/3
>>> lcm(S(2)/3, S(4)/9)
4/3 
```

```py
quo(a, b)
```

Quotient of `a` and `b`, implies `__truediv__`.

```py
rem(a, b)
```

Remainder of `a` and `b`, implies nothing.

```py
revert(a)
```

Returns `a**(-1)` if possible.

```py
class sympy.polys.domains.ring.Ring
```

Represents a ring domain.

```py
denom(a)
```

Returns denominator of \(a\).

```py
div(a, b)
```

Division of `a` and `b`, implies `__divmod__`.

```py
exquo(a, b)
```

Exact quotient of `a` and `b`, implies `__floordiv__`.

```py
free_module(rank)
```

Generate a free module of rank `rank` over self.

```py
>>> from sympy.abc import x
>>> from sympy import QQ
>>> QQ.old_poly_ring(x).free_module(2)
QQ[x]**2 
```

```py
get_ring()
```

Returns a ring associated with `self`.

```py
ideal(*gens)
```

Generate an ideal of `self`.

```py
>>> from sympy.abc import x
>>> from sympy import QQ
>>> QQ.old_poly_ring(x).ideal(x**2)
<x**2> 
```

```py
invert(a, b)
```

Returns inversion of `a mod b`.

```py
numer(a)
```

Returns numerator of `a`.

```py
quo(a, b)
```

Quotient of `a` and `b`, implies `__floordiv__`.

```py
quotient_ring(e)
```

Form a quotient ring of `self`.

Here `e` can be an ideal or an iterable.

```py
>>> from sympy.abc import x
>>> from sympy import QQ
>>> QQ.old_poly_ring(x).quotient_ring(QQ.old_poly_ring(x).ideal(x**2))
QQ[x]/<x**2>
>>> QQ.old_poly_ring(x).quotient_ring([x**2])
QQ[x]/<x**2> 
```

The division operator has been overloaded for this:

```py
>>> QQ.old_poly_ring(x)/[x**2]
QQ[x]/<x**2> 
```

```py
rem(a, b)
```

Remainder of `a` and `b`, implies `__mod__`.

```py
revert(a)
```

Returns `a**(-1)` if possible.

```py
class sympy.polys.domains.simpledomain.SimpleDomain
```

Base class for simple domains, e.g. ZZ, QQ.

```py
inject(*gens)
```

Inject generators into this domain.

```py
class sympy.polys.domains.compositedomain.CompositeDomain
```

Base class for composite domains, e.g. ZZ[x], ZZ(X).

```py
drop(*symbols)
```

Drop generators from this domain.

```py
get_exact()
```

Returns an exact version of this domain.

```py
inject(*symbols)
```

Inject generators into this domain.

```py
property is_Exact
```

Returns `True` if this domain is exact.

```py
set_domain(domain)
```

Set the ground domain of this domain.

## GF(p)

```py
class sympy.polys.domains.FiniteField(mod, symmetric=True)
```

Finite field of prime order [GF(p)](#gf-p)

A [GF(p)](#gf-p) domain represents a [finite field](https://en.wikipedia.org/wiki/Finite_field) \(\mathbb{F}_p\) of prime order as [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") in the domain system (see [Introducing the Domains of the poly module](domainsintro.html#polys-domainsintro)).

A [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") created from an expression with integer coefficients will have the domain [ZZ](#zz). However, if the `modulus=p` option is given then the domain will be a finite field instead.

```py
>>> from sympy import Poly, Symbol
>>> x = Symbol('x')
>>> p = Poly(x**2 + 1)
>>> p
Poly(x**2 + 1, x, domain='ZZ')
>>> p.domain
ZZ
>>> p2 = Poly(x**2 + 1, modulus=2)
>>> p2
Poly(x**2 + 1, x, modulus=2)
>>> p2.domain
GF(2) 
```

可以使用模参数来在 [GF(p)](#gf-p) 上因式分解多项式，也可以通过明确指定域来实现。域也可以以字符串形式给出。

```py
>>> from sympy import factor, GF
>>> factor(x**2 + 1)
x**2 + 1
>>> factor(x**2 + 1, modulus=2)
(x + 1)**2
>>> factor(x**2 + 1, domain=GF(2))
(x + 1)**2
>>> factor(x**2 + 1, domain='GF(2)')
(x + 1)**2 
```

也可以使用 [GF(p)](#gf-p) 与 [`cancel()`](reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel") 和 [`gcd()`](reference.html#sympy.polys.polytools.gcd "sympy.polys.polytools.gcd") 函数。

```py
>>> from sympy import cancel, gcd
>>> cancel((x**2 + 1)/(x + 1))
(x**2 + 1)/(x + 1)
>>> cancel((x**2 + 1)/(x + 1), domain=GF(2))
x + 1
>>> gcd(x**2 + 1, x + 1)
1
>>> gcd(x**2 + 1, x + 1, domain=GF(2))
x + 1 
```

直接使用域 [GF(p)](#gf-p) 可以用作构造函数来创建支持操作 `+,-,*,**,/` 的实例。

```py
>>> from sympy import GF
>>> K = GF(5)
>>> K
GF(5)
>>> x = K(3)
>>> y = K(2)
>>> x
3 mod 5
>>> y
2 mod 5
>>> x * y
1 mod 5
>>> x / y
4 mod 5 
```

注意

也可以创建一个 [GF(p)](#gf-p) 域，其阶数为**非素数**，但生成的环**不是**域：它只是模 `n` 的整数环。

```py
>>> K = GF(9)
>>> z = K(3)
>>> z
3 mod 9
>>> z**2
0 mod 9 
```

很好地实现素数幂域 (`GF(p**n)`) 将很有帮助，但这些在 SymPY 中尚未实现。

```py
characteristic()
```

返回此域的特征。

```py
exsqrt(a)
```

如果 `a` 是二次剩余，则返回模 p 的平方根。

解释

总是返回不大于 `p // 2` 的平方根。

```py
from_FF(a, K0=None)
```

将 `ModularInteger(int)` 转换为 `dtype`。

```py
from_FF_gmpy(a, K0=None)
```

将 `ModularInteger(mpz)` 转换为 `dtype`。

```py
from_FF_python(a, K0=None)
```

将 `ModularInteger(int)` 转换为 `dtype`。

```py
from_QQ(a, K0=None)
```

将 Python 的 `Fraction` 转换为 `dtype`。

```py
from_QQ_gmpy(a, K0=None)
```

将 GMPY 的 `mpq` 转换为 `dtype`。

```py
from_QQ_python(a, K0=None)
```

将 Python 的 `Fraction` 转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath 的 `mpf` 转换为 `dtype`。

```py
from_ZZ(a, K0=None)
```

将 Python 的 `int` 转换为 `dtype`。

```py
from_ZZ_gmpy(a, K0=None)
```

将 GMPY 的 `mpz` 转换为 `dtype`。

```py
from_ZZ_python(a, K0=None)
```

将 Python 的 `int` 转换为 `dtype`。

```py
from_sympy(a)
```

将 SymPy 的整数转换为 SymPy 的 `Integer`。

```py
get_field()
```

返回与 `self` 关联的字段。

```py
is_negative(a)
```

如果 `a` 是负数，则返回 True。

```py
is_nonnegative(a)
```

如果 `a` 是非负数，则返回 True。

```py
is_nonpositive(a)
```

如果 `a` 是非正数，则返回 True。

```py
is_positive(a)
```

如果 `a` 是正数，则返回 True。

```py
is_square(a)
```

如果 `a` 对模 p 是二次剩余，则返回 True。

```py
to_int(a)
```

将 `val` 转换为 Python 的 `int` 对象。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。

```py
class sympy.polys.domains.PythonFiniteField(mod, symmetric=True)
```

基于 Python 整数的有限域。

```py
class sympy.polys.domains.GMPYFiniteField(mod, symmetric=True)
```

基于 GMPY 整数的有限域。  ## ZZ

[ZZ](#zz) 域表示整数 [integers](https://en.wikipedia.org/wiki/Integer) \(\mathbb{Z}\) 作为 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 在域系统中（参见 [Introducing the Domains of the poly module](domainsintro.html#polys-domainsintro)）。

默认情况下，从具有整数系数的表达式创建的 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") 将具有域 [ZZ](#zz)。

```py
>>> from sympy import Poly, Symbol
>>> x = Symbol('x')
>>> p = Poly(x**2 + 1)
>>> p
Poly(x**2 + 1, x, domain='ZZ')
>>> p.domain
ZZ 
```

相应的 [分式域](https://en.wikipedia.org/wiki/Field_of_fractions) 是有理数 [QQ](#qq) 的域。反过来，[ZZ](#zz) 是 [QQ](#qq) 的 [整数环](https://en.wikipedia.org/wiki/Ring_of_integers)：

```py
>>> from sympy import ZZ, QQ
>>> ZZ.get_field()
QQ
>>> QQ.get_ring()
ZZ 
```

直接使用域 [ZZ](#zz) 可以用作构造函数来创建支持操作 `+,-,*,**,//,%` 的实例（真除法 `/` 不应与 [ZZ](#zz) 一起使用 - 参见 [`exquo()`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo") 域方法）：

```py
>>> x = ZZ(5)
>>> y = ZZ(2)
>>> x // y  # floor division
2
>>> x % y   # modulo division (remainder)
1 
```

[`gcd()`](#sympy.polys.domains.domain.Domain.gcd "sympy.polys.domains.domain.Domain.gcd") 方法可用于计算任意两个元素的 [gcd](https://en.wikipedia.org/wiki/Greatest_common_divisor)：

```py
>>> ZZ.gcd(ZZ(10), ZZ(2))
2 
```

SymPy 中有两种 [ZZ](#zz) 的实现。如果安装了 `gmpy` 或 `gmpy2`，则 [ZZ](#zz) 将由 [`GMPYIntegerRing`](#sympy.polys.domains.GMPYIntegerRing "sympy.polys.domains.GMPYIntegerRing") 实现，并且元素将是 `gmpy.mpz` 类型的实例。否则，如果未安装 `gmpy` 和 `gmpy2`，则 [ZZ](#zz) 将由 [`PythonIntegerRing`](#sympy.polys.domains.PythonIntegerRing "sympy.polys.domains.PythonIntegerRing") 实现，使用 Python 的标准内置 `int` 类型。对于更大的整数，使用 `gmpy` 可能更有效率，因此在可用时推荐使用。

```py
class sympy.polys.domains.IntegerRing
```

表示整数的域 `ZZ` 是 \(\mathbb{Z}\)。

[`IntegerRing`](#sympy.polys.domains.IntegerRing "sympy.polys.domains.IntegerRing") 类作为 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 在域系统中表示整数环。[`IntegerRing`](#sympy.polys.domains.IntegerRing "sympy.polys.domains.IntegerRing") 是 [`PythonIntegerRing`](#sympy.polys.domains.PythonIntegerRing "sympy.polys.domains.PythonIntegerRing") 和 [`GMPYIntegerRing`](#sympy.polys.domains.GMPYIntegerRing "sympy.polys.domains.GMPYIntegerRing") 的超类，根据是否安装 `gmpy` 或 `gmpy2` 中的一个来实现 [ZZ](#zz)。

另见

[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")

```py
algebraic_field(*extension, alias=None)
```

返回一个代数域，即 \(\mathbb{Q}(\alpha, \ldots)\)。

参数：

**extension**：一个或多个 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。

> 扩展的生成元。这些应该是代数上 \(\mathbb{Q}\) 的表达式。

**alias**：str，[`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")，可选（默认为 None）

> 如果提供，这将被用作返回的 [`AlgebraicField`](#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField") 的原始元的别名符号。

返回：

[`AlgebraicField`](#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")

> 表示代数域扩展的 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")。

示例

```py
>>> from sympy import ZZ, sqrt
>>> ZZ.algebraic_field(sqrt(2))
QQ<sqrt(2)> 
```

```py
exsqrt(a)
```

如果 `a` 是一个平方数，则返回 `a` 的非负平方根。

另见

[`is_square`](#sympy.polys.domains.IntegerRing.is_square "sympy.polys.domains.IntegerRing.is_square")

```py
factorial(a)
```

计算 `a` 的阶乘。

```py
from_AlgebraicField(a, K0)
```

将 [`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP") 对象转换为 [ZZ](#zz)。

参见 [`convert()`](#sympy.polys.domains.domain.Domain.convert "sympy.polys.domains.domain.Domain.convert")。

```py
from_EX(a, K0)
```

将 `Expression` 转换为 GMPY 的 `mpz`。

```py
from_FF(a, K0)
```

将 `ModularInteger(int)` 转换为 GMPY 的 `mpz`。

```py
from_FF_gmpy(a, K0)
```

将 `ModularInteger(mpz)` 转换为 GMPY 的 `mpz`。

```py
from_FF_python(a, K0)
```

将 `ModularInteger(int)` 转换为 GMPY 的 `mpz`。

```py
from_QQ(a, K0)
```

将 Python 的 `Fraction` 转换为 GMPY 的 `mpz`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 `mpq` 转换为 GMPY 的 `mpz`。

```py
from_QQ_python(a, K0)
```

将 Python 的 `Fraction` 转换为 GMPY 的 `mpz`。

```py
from_RealField(a, K0)
```

将 `mpmath` 的 `mpf` 转换为 GMPY 的 `mpz`。

```py
from_ZZ(a, K0)
```

将 Python 的 `int` 转换为 GMPY 的 `mpz`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 `mpz` 转换为 GMPY 的 `mpz`。

```py
from_ZZ_python(a, K0)
```

将 Python 的 `int` 转换为 GMPY 的 `mpz`。

```py
from_sympy(a)
```

将 SymPy 的整数转换为 `dtype`。

```py
gcd(a, b)
```

计算 `a` 和 `b` 的最大公约数。

```py
gcdex(a, b)
```

计算 `a` 和 `b` 的扩展最大公约数。

```py
get_field()
```

返回关联的分式域 [QQ](#qq)。

返回：

[QQ](#qq)：

> 关联的分式域 [QQ](#qq)，表示有理数 \(\mathbb{Q}\) 的 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")。

示例

```py
>>> from sympy import ZZ
>>> ZZ.get_field()
QQ 
```

```py
is_square(a)
```

如果 `a` 是完全平方数，则返回 `True`。

解释

如果存在整数 `b` 满足 `b * b == a`，则整数 `a` 是完全平方数。

```py
lcm(a, b)
```

计算 `a` 和 `b` 的最小公倍数。

```py
log(a, b)
```

*a* 的以 *b* 为底的对数。

参数：

**a: number**

**b: number**

返回：

\(\\lfloor\log(a, b)\\rfloor\)：

> *a* 的以 *b* 为底的对数的下取整。

示例

```py
>>> from sympy import ZZ
>>> ZZ.log(ZZ(8), ZZ(2))
3
>>> ZZ.log(ZZ(9), ZZ(2))
3 
```

注意事项

此函数使用基于 `float` 的 `math.log`，因此对于大整数参数将失败。

```py
sqrt(a)
```

计算 `a` 的平方根。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。

```py
class sympy.polys.domains.PythonIntegerRing
```

基于 Python 的 `int` 类型的整数环。

如果未安装 `gmpy` 和 `gmpy2`，将使用 [ZZ](#zz)。元素是标准 Python `int` 类型的实例。

```py
class sympy.polys.domains.GMPYIntegerRing
```

基于 GMPY 的 `mpz` 类型的整数环。

如果安装了 `gmpy` 或 `gmpy2`，这将是 [ZZ](#zz) 的实现。元素将是类型为 `gmpy.mpz` 的对象。

```py
factorial(a)
```

计算 `a` 的阶乘。

```py
from_FF_gmpy(a, K0)
```

将 `ModularInteger(mpz)` 转换为 GMPY 的 `mpz`。

```py
from_FF_python(a, K0)
```

将 `ModularInteger(int)` 转换为 GMPY 的 `mpz`。

```py
from_QQ(a, K0)
```

将 Python 的 `Fraction` 转换为 GMPY 的 `mpz`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 `mpq` 转换为 GMPY 的 `mpz`。

```py
from_QQ_python(a, K0)
```

将 Python 的 `Fraction` 转换为 GMPY 的 `mpz`。

```py
from_RealField(a, K0)
```

将 `mpmath` 的 `mpf` 转换为 GMPY 的 `mpz`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 `mpz` 转换为 GMPY 的 `mpz`。

```py
from_ZZ_python(a, K0)
```

将 Python 的 `int` 转换为 GMPY 的 `mpz`。

```py
from_sympy(a)
```

将 SymPy 的整数转换为 `dtype`。

```py
gcd(a, b)
```

计算 `a` 和 `b` 的最大公约数。

```py
gcdex(a, b)
```

计算 `a` 和 `b` 的扩展最大公约数。

```py
lcm(a, b)
```

计算 `a` 和 `b` 的最小公倍数。

```py
sqrt(a)
```

计算 `a` 的平方根。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。  ## QQ

[QQ](#qq) 领域将有理数（[rationals](https://en.wikipedia.org/wiki/Rational_number) \(\mathbb{Q}\)）表示为 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain") 的一部分（见 [Introducing the Domains of the poly module](domainsintro.html#polys-domainsintro)）。

默认情况下，从具有有理数系数的表达式创建的 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") 将具有 [QQ](#qq) 域：

```py
>>> from sympy import Poly, Symbol
>>> x = Symbol('x')
>>> p = Poly(x**2 + x/2)
>>> p
Poly(x**2 + 1/2*x, x, domain='QQ')
>>> p.domain
QQ 
```

相应的[整数环](https://en.wikipedia.org/wiki/Ring_of_integers)是整数 [ZZ](#zz) 的 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")。相反，[QQ](#qq) 是[整数环](https://en.wikipedia.org/wiki/Ring_of_integers)的[分式域](https://en.wikipedia.org/wiki/Field_of_fractions)：

```py
>>> from sympy import ZZ, QQ
>>> QQ.get_ring()
ZZ
>>> ZZ.get_field()
QQ 
```

当直接使用域[QQ](#qq)时，可以作为构造函数用于创建实例，这些实例支持操作`+,-,*,**,/`（对于[QQ](#qq)，非零除数总是可以进行真除`/`）：

```py
>>> x = QQ(5)
>>> y = QQ(2)
>>> x / y  # true division
5/2 
```

SymPy中有两种[QQ](#qq)的实现。如果安装了`gmpy`或`gmpy2`，则[QQ](#qq)将由[`GMPYRationalField`](#sympy.polys.domains.GMPYRationalField "sympy.polys.domains.GMPYRationalField")实现，元素将是`gmpy.mpq`类型的实例。否则，如果未安装`gmpy`和`gmpy2`，则[QQ](#qq)将由[`PythonRationalField`](#sympy.polys.domains.PythonRationalField "sympy.polys.domains.PythonRationalField")实现，这是SymPy的纯Python类之一。优选`gmpy`实现，因为速度显著更快。

```py
class sympy.polys.domains.RationalField
```

抽象基类，用于领域[QQ](#qq)。

[`RationalField`](#sympy.polys.domains.RationalField "sympy.polys.domains.RationalField")类将有理数域\(\mathbb{Q}\)作为[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")的一部分来表示。[`RationalField`](#sympy.polys.domains.RationalField "sympy.polys.domains.RationalField")是[`PythonRationalField`](#sympy.polys.domains.PythonRationalField "sympy.polys.domains.PythonRationalField")和[`GMPYRationalField`](#sympy.polys.domains.GMPYRationalField "sympy.polys.domains.GMPYRationalField")的超类之一，具体实现取决于是否安装了`gmpy`或`gmpy2`。[QQ](#qq)的实现将由安装了`gmpy`或`gmpy2`的情况下的[`GMPYRationalField`](#sympy.polys.domains.GMPYRationalField "sympy.polys.domains.GMPYRationalField")提供，其元素将是`gmpy.mpq`类型的实例。否则，如果未安装`gmpy`和`gmpy2`，则[QQ](#qq)将由纯Python类[`PythonRationalField`](#sympy.polys.domains.PythonRationalField "sympy.polys.domains.PythonRationalField")实现。`gmpy`实现优选，因为它速度显著更快。

另见

[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")

```py
algebraic_field(*extension, alias=None)
```

返回一个代数域，即\(\mathbb{Q}(\alpha, \ldots)\)。

参数：

**扩展**：一个或多个[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")

> 扩展的生成器。这些应该是在\(\mathbb{Q}\)上代数的表达式。

**别名**：str，[`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")，None，可选（默认=None）

> 如果提供，将用作返回的[`AlgebraicField`](#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")的原始元素的别名符号。

返回：

[`AlgebraicField`](#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")

> 代表代数域扩展的[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")。

示例

```py
>>> from sympy import QQ, sqrt
>>> QQ.algebraic_field(sqrt(2))
QQ<sqrt(2)> 
```

```py
denom(a)
```

返回`a`的分母。

```py
div(a, b)
```

`a`和`b`的除法，意味着`__truediv__`。

```py
exquo(a, b)
```

`a`和`b`的精确商，意味着`__truediv__`。

```py
exsqrt(a)
```

如果`a`是平方数，则为`a`的非负平方根。

另见

[`is_square`](#sympy.polys.domains.RationalField.is_square "sympy.polys.domains.RationalField.is_square")

```py
from_AlgebraicField(a, K0)
```

将[`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")对象转换为[QQ](#qq)。

参见[`convert()`](#sympy.polys.domains.domain.Domain.convert "sympy.polys.domains.domain.Domain.convert")

```py
from_GaussianRationalField(a, K0)
```

将 `GaussianElement` 对象转换为 `dtype`。

```py
from_QQ(a, K0)
```

将 Python 的 `Fraction` 对象转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 `mpq` 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python 的 `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath 的 `mpf` 对象转换为 `dtype`。

```py
from_ZZ(a, K0)
```

将 Python 的 `int` 对象转换为 `dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 `mpz` 对象转换为 `self.dtype`。

```py
from_ZZ_python(a, K0)
```

将 Python 的 `int` 对象转换为 `dtype`。

```py
from_sympy(a)
```

将 SymPy 的 Integer 转换为 `dtype`。

```py
get_ring()
```

返回与 `self` 关联的环。

```py
is_square(a)
```

如果 `a` 是平方数，则返回 `True`。

解释

如果存在有理数 `b` 使得 `b * b == a`，则有理数 `a` 是平方数。

```py
numer(a)
```

返回 `a` 的分子。

```py
quo(a, b)
```

`a` 和 `b` 的商，意味着 `__truediv__`。

```py
rem(a, b)
```

`a` 和 `b` 的余数，无特殊意义。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。

```py
class sympy.polys.domains.PythonRationalField
```

基于 [MPQ](#mpq) 的有理数域。

如果未安装 `gmpy` 和 `gmpy2`，则将用作 [QQ](#qq)。元素是 [MPQ](#mpq) 的实例。

```py
class sympy.polys.domains.GMPYRationalField
```

基于 GMPY 的 `mpq` 类型的有理数域。

如果安装了 `gmpy` 或 `gmpy2`，则将实现为 [QQ](#qq)。元素将是 `gmpy.mpq` 类型。

```py
denom(a)
```

返回 `a` 的分母。

```py
div(a, b)
```

`a` 和 `b` 的除法，意味着 `__truediv__`。

```py
exquo(a, b)
```

`a` 和 `b` 的精确商，意味着 `__truediv__`。

```py
factorial(a)
```

返回 `a` 的阶乘。

```py
from_GaussianRationalField(a, K0)
```

将 `GaussianElement` 对象转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 `mpq` 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python 的 `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath 的 `mpf` 对象转换为 `dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 `mpz` 对象转换为 `dtype`。

```py
from_ZZ_python(a, K0)
```

将 Python 的 `int` 对象转换为 `dtype`。

```py
from_sympy(a)
```

将 SymPy 的 Integer 转换为 `dtype`。

```py
get_ring()
```

返回与 `self` 相关联的环。

```py
numer(a)
```

返回 `a` 的分子。

```py
quo(a, b)
```

`a` 和 `b` 的商，意味着 `__truediv__`。

```py
rem(a, b)
```

`a` 和 `b` 的余数，无特殊意义。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。

```py
class sympy.external.pythonmpq.PythonMPQ(numerator, denominator=None)
```

旨在与 gmpy2 的 mpq 兼容的有理数实现。

也比 fractions.Fraction 稍快。

PythonMPQ 应被视为不可变的，尽管不会采取措施来防止突变（因为这可能会减慢计算速度）。## MPQ

`MPQ` 类型可以是 [`PythonMPQ`](#sympy.external.pythonmpq.PythonMPQ "sympy.external.pythonmpq.PythonMPQ") 或者来自 `gmpy2` 的 `mpq` 类型。

## Gaussian 域

Gaussian 域 [ZZ_I](#zz-i) 和 [QQ_I](#qq-i) 共享公共超类 [`GaussianElement`](#sympy.polys.domains.gaussiandomains.GaussianElement "sympy.polys.domains.gaussiandomains.GaussianElement") 用于域元素和 [`GaussianDomain`](#sympy.polys.domains.gaussiandomains.GaussianDomain "sympy.polys.domains.gaussiandomains.GaussianDomain") 用于域本身。

```py
class sympy.polys.domains.gaussiandomains.GaussianDomain
```

Gaussian 域的基类。

```py
from_AlgebraicField(a, K0)
```

将从 ZZ<I> 或 QQ<I> 转换为 `self.dtype` 的元素。

```py
from_QQ(a, K0)
```

将 GMPY 的 mpq 转换为 `self.dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY 的 mpq 转换为 `self.dtype`。

```py
from_QQ_python(a, K0)
```

将 QQ_python 元素转换为 `self.dtype`。

```py
from_ZZ(a, K0)
```

将 ZZ_python 元素转换为 `self.dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY 的 mpz 转换为 `self.dtype`。

```py
from_ZZ_python(a, K0)
```

将 ZZ_python 元素转换为 `self.dtype`。

```py
from_sympy(a)
```

将 SymPy 对象转换为 `self.dtype`。

```py
inject(*gens)
```

将生成器注入到此域中。

```py
is_negative(element)
```

对于任何 `GaussianElement` 返回 `False`。

```py
is_nonnegative(element)
```

对于任何 `GaussianElement` 返回 `False`。

```py
is_nonpositive(element)
```

返回任何 `高斯元素` 的 `False`。

```py
is_positive(element)
```

返回任何 `高斯元素` 的 `False`。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。

```py
class sympy.polys.domains.gaussiandomains.GaussianElement(x, y=0)
```

高斯型域元素的基类。

```py
classmethod new(x, y)
```

创建相同域的新高斯元素。

```py
parent()
```

这是所属的域 (ZZ_I 或 QQ_I) 的元素。

```py
quadrant()
```

返回象限索引 0-3。

0 包含在象限 0 中。

## ZZ_I

```py
class sympy.polys.domains.gaussiandomains.GaussianIntegerRing
```

高斯整数环 `ZZ_I`

[ZZ_I](#zz-i) 域将 [高斯整数](https://en.wikipedia.org/wiki/Gaussian_integer) \(\mathbb{Z}[i]\) 表示为域系统中的 [`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")（参见 [Introducing the Domains of the poly module](domainsintro.html#polys-domainsintro)）。

默认情况下，从整数和 `I`（\(\sqrt{-1}\)）的组合构成的表达式创建的 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") 将具有域 [ZZ_I](#zz-i)。

```py
>>> from sympy import Poly, Symbol, I
>>> x = Symbol('x')
>>> p = Poly(x**2 + I)
>>> p
Poly(x**2 + I, x, domain='ZZ_I')
>>> p.domain
ZZ_I 
```

[ZZ_I](#zz-i) 域可用于分解在高斯整数上可约的多项式。

```py
>>> from sympy import factor
>>> factor(x**2 + 1)
x**2 + 1
>>> factor(x**2 + 1, domain='ZZ_I')
(x - I)*(x + I) 
```

对应的 [分式域](https://en.wikipedia.org/wiki/Field_of_fractions) 是高斯有理数的域 [QQ_I](#qq-i)。相反，[ZZ_I](#zz-i) 是 [QQ_I](#qq-i) 的 [整数环](https://en.wikipedia.org/wiki/Ring_of_integers)。

```py
>>> from sympy import ZZ_I, QQ_I
>>> ZZ_I.get_field()
QQ_I
>>> QQ_I.get_ring()
ZZ_I 
```

直接使用域时，[ZZ_I](#zz-i) 可作为构造函数使用。

```py
>>> ZZ_I(3, 4)
(3 + 4*I)
>>> ZZ_I(5)
(5 + 0*I) 
```

[ZZ_I](#zz-i) 的域元素是支持环操作 `+,-,*,**` 的 [`高斯整数`](#sympy.polys.domains.gaussiandomains.GaussianInteger "sympy.polys.domains.gaussiandomains.GaussianInteger") 实例。

```py
>>> z1 = ZZ_I(5, 1)
>>> z2 = ZZ_I(2, 3)
>>> z1
(5 + 1*I)
>>> z2
(2 + 3*I)
>>> z1 + z2
(7 + 4*I)
>>> z1 * z2
(7 + 17*I)
>>> z1 ** 2
(24 + 10*I) 
```

地板除法 (`//`) 和模除法 (`%`) 在 [`高斯整数`](#sympy.polys.domains.gaussiandomains.GaussianInteger "sympy.polys.domains.gaussiandomains.GaussianInteger") (参见 [`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div") 方法) 上均有效。

```py
>>> z3, z4 = ZZ_I(5), ZZ_I(1, 3)
>>> z3 // z4  # floor division
(1 + -1*I)
>>> z3 % z4   # modulo division (remainder)
(1 + -2*I)
>>> (z3//z4)*z4 + z3%z4 == z3
True 
```

在 [ZZ_I](#zz-i) 中，真除法 (`/`) 给出 [QQ_I](#qq-i) 的一个元素。可以使用 [`exquo()`](#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo") 方法在 [ZZ_I](#zz-i) 上进行精确除法。

```py
>>> z1 / z2
(1 + -1*I)
>>> ZZ_I.exquo(z1, z2)
(1 + -1*I)
>>> z3 / z4
(1/2 + -3/2*I)
>>> ZZ_I.exquo(z3, z4)
Traceback (most recent call last):
  ...
ExactQuotientFailed: (1 + 3*I) does not divide (5 + 0*I) in ZZ_I 
```

[`gcd()`](#sympy.polys.domains.domain.Domain.gcd "sympy.polys.domains.domain.Domain.gcd") 方法可用于计算任意两个元素的 [gcd](https://en.wikipedia.org/wiki/Greatest_common_divisor)。

```py
>>> ZZ_I.gcd(ZZ_I(10), ZZ_I(2))
(2 + 0*I)
>>> ZZ_I.gcd(ZZ_I(5), ZZ_I(2, 1))
(2 + 1*I) 
```

```py
dtype
```

[`高斯整数`](#sympy.polys.domains.gaussiandomains.GaussianInteger "sympy.polys.domains.gaussiandomains.GaussianInteger") 的别名。

```py
from_GaussianIntegerRing(a, K0)
```

将 ZZ_I 元素转换为 ZZ_I。

```py
from_GaussianRationalField(a, K0)
```

将 QQ_I 元素转换为 ZZ_I。

```py
gcd(a, b)
```

在 ZZ_I 上 a 和 b 的最大公约数。

```py
get_field()
```

返回与 `self` 关联的一个字段。

```py
get_ring()
```

返回与 `self` 关联的一个环。

```py
lcm(a, b)
```

在 ZZ_I 上的 a 和 b 的最小公倍数。

```py
normalize(d, *args)
```

返回与 `d` 关联的第一象限元素。

也将其他参数乘以相同的 i 的幂次。

```py
class sympy.polys.domains.gaussiandomains.GaussianInteger(x, y=0)
```

高斯整数：[ZZ_I](#zz-i) 的域元素。

```py
>>> from sympy import ZZ_I
>>> z = ZZ_I(2, 3)
>>> z
(2 + 3*I)
>>> type(z)
<class 'sympy.polys.domains.gaussiandomains.GaussianInteger'> 
```  ## QQ_I

```py
class sympy.polys.domains.gaussiandomains.GaussianRationalField
```

高斯有理数域 `QQ_I`

[QQ_I](#qq-i) 域将[高斯有理数](https://en.wikipedia.org/wiki/Gaussian_rational) \(\mathbb{Q}(i)\) 表示为域系统中的[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")（参见[引入多项式模块的域](domainsintro.html#polys-domainsintro)）。

默认情况下，从具有有理数和`I`（\(\sqrt{-1}\)）组合的系数表达式创建的[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly") 将具有域[QQ_I](#qq-i)。

```py
>>> from sympy import Poly, Symbol, I
>>> x = Symbol('x')
>>> p = Poly(x**2 + I/2)
>>> p
Poly(x**2 + I/2, x, domain='QQ_I')
>>> p.domain
QQ_I 
```

即使系数不包含`I`或全为整数，polys选项`gaussian=True`也可以用来指定域应为[QQ_I](#qq-i)。

```py
>>> Poly(x**2)
Poly(x**2, x, domain='ZZ')
>>> Poly(x**2 + I)
Poly(x**2 + I, x, domain='ZZ_I')
>>> Poly(x**2/2)
Poly(1/2*x**2, x, domain='QQ')
>>> Poly(x**2, gaussian=True)
Poly(x**2, x, domain='QQ_I')
>>> Poly(x**2 + I, gaussian=True)
Poly(x**2 + I, x, domain='QQ_I')
>>> Poly(x**2/2, gaussian=True)
Poly(1/2*x**2, x, domain='QQ_I') 
```

[QQ_I](#qq-i) 域可用于分解在高斯有理数上是可约的多项式。

```py
>>> from sympy import factor, QQ_I
>>> factor(x**2/4 + 1)
(x**2 + 4)/4
>>> factor(x**2/4 + 1, domain='QQ_I')
(x - 2*I)*(x + 2*I)/4
>>> factor(x**2/4 + 1, domain=QQ_I)
(x - 2*I)*(x + 2*I)/4 
```

还可以使用 polys 函数如[`apart()`](reference.html#sympy.polys.partfrac.apart "sympy.polys.partfrac.apart") 明确指定[QQ_I](#qq-i) 域。

```py
>>> from sympy import apart
>>> apart(1/(1 + x**2))
1/(x**2 + 1)
>>> apart(1/(1 + x**2), domain=QQ_I)
I/(2*(x + I)) - I/(2*(x - I)) 
```

对应的[整数环](https://en.wikipedia.org/wiki/Ring_of_integers) 是高斯整数[ZZ_I](#zz-i)的域。反之，[QQ_I](#qq-i) 是[ZZ_I](#zz-i) 的[分式域](https://en.wikipedia.org/wiki/Field_of_fractions)。

```py
>>> from sympy import ZZ_I, QQ_I, QQ
>>> ZZ_I.get_field()
QQ_I
>>> QQ_I.get_ring()
ZZ_I 
```

直接使用域[QQ_I](#qq-i) 时，可以作为构造函数使用。

```py
>>> QQ_I(3, 4)
(3 + 4*I)
>>> QQ_I(5)
(5 + 0*I)
>>> QQ_I(QQ(2, 3), QQ(4, 5))
(2/3 + 4/5*I) 
```

[QQ_I](#qq-i) 的域元素是支持字段操作`+,-,*,**,/`的[`GaussianRational`](#sympy.polys.domains.gaussiandomains.GaussianRational "sympy.polys.domains.gaussiandomains.GaussianRational") 实例。

```py
>>> z1 = QQ_I(5, 1)
>>> z2 = QQ_I(2, QQ(1, 2))
>>> z1
(5 + 1*I)
>>> z2
(2 + 1/2*I)
>>> z1 + z2
(7 + 3/2*I)
>>> z1 * z2
(19/2 + 9/2*I)
>>> z2 ** 2
(15/4 + 2*I) 
```

在[QQ_I](#qq-i) 中，真除法(`/`) 给出[QQ_I](#qq-i) 的元素，并且始终是精确的。

```py
>>> z1 / z2
(42/17 + -2/17*I)
>>> QQ_I.exquo(z1, z2)
(42/17 + -2/17*I)
>>> z1 == (z1/z2)*z2
True 
```

对于[`GaussianRational`](#sympy.polys.domains.gaussiandomains.GaussianRational "sympy.polys.domains.gaussiandomains.GaussianRational")，可以使用 floor (`//`) 和 modulo (`%`) 运算（参见[`div()`](#sympy.polys.domains.domain.Domain.div "sympy.polys.domains.domain.Domain.div")），但是由于除法始终是精确的，因此没有余数。

```py
>>> z1 // z2
(42/17 + -2/17*I)
>>> z1 % z2
(0 + 0*I)
>>> QQ_I.div(z1, z2)
((42/17 + -2/17*I), (0 + 0*I))
>>> (z1//z2)*z2 + z1%z2 == z1
True 
```

```py
as_AlgebraicField()
```

作为`AlgebraicField`的等价域。

```py
denom(a)
```

获取`a`的分母。

```py
dtype
```

[`GaussianRational`](#sympy.polys.domains.gaussiandomains.GaussianRational "sympy.polys.domains.gaussiandomains.GaussianRational") 的别名

```py
from_ComplexField(a, K0)
```

将ComplexField元素转换为QQ_I。

```py
from_GaussianIntegerRing(a, K0)
```

将ZZ_I元素转换为QQ_I。

```py
from_GaussianRationalField(a, K0)
```

将QQ_I元素转换为QQ_I。

```py
get_field()
```

返回与`self`相关的字段。

```py
get_ring()
```

返回与`self`相关联的环。

```py
numer(a)
```

获取`a`的分子。

```py
class sympy.polys.domains.gaussiandomains.GaussianRational(x, y=0)
```

高斯有理数：[QQ_I](#qq-i) 的域元素

```py
>>> from sympy import QQ_I, QQ
>>> z = QQ_I(QQ(2, 3), QQ(4, 5))
>>> z
(2/3 + 4/5*I)
>>> type(z)
<class 'sympy.polys.domains.gaussiandomains.GaussianRational'> 
```  ## QQ<a>

```py
class sympy.polys.domains.AlgebraicField(dom, *ext, alias=None)
```

代数数域[QQ<a>](#qq-a)

[QQ<a>](#qq-a) 域将[代数数域](https://en.wikipedia.org/wiki/Algebraic_number_field) \(\mathbb{Q}(a)\) 表示为域系统中的[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")（参见[引入多项式模块的域](domainsintro.html#polys-domainsintro)）。

从涉及[algebraic numbers](https://en.wikipedia.org/wiki/Algebraic_number)的表达式创建的[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")将把代数数视为生成器（如果未指定生成器参数）。

```py
>>> from sympy import Poly, Symbol, sqrt
>>> x = Symbol('x')
>>> Poly(x**2 + sqrt(2))
Poly(x**2 + (sqrt(2)), x, sqrt(2), domain='ZZ') 
```

这是一个多变量多项式，其中`sqrt(2)`被视为生成器（变量）之一。如果明确指定生成器，则`sqrt(2)`将被视为系数，但默认情况下使用[EX](#ex)域。要在[QQ<a>](#qq-a)域中创建[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")，可以给定参数`extension=True`。

```py
>>> Poly(x**2 + sqrt(2), x)
Poly(x**2 + sqrt(2), x, domain='EX')
>>> Poly(x**2 + sqrt(2), x, extension=True)
Poly(x**2 + sqrt(2), x, domain='QQ<sqrt(2)>') 
```

如果系数全为有理数但需要扩展域（例如因式分解多项式），也可以显式指定代数域扩展的生成器。

```py
>>> Poly(x**2 + 1)
Poly(x**2 + 1, x, domain='ZZ')
>>> Poly(x**2 + 1, extension=sqrt(2))
Poly(x**2 + 1, x, domain='QQ<sqrt(2)>') 
```

可以使用`extension`参数在[QQ<a>](#qq-a)域上因式分解多项式，或者明确指定域。

```py
>>> from sympy import factor, QQ
>>> factor(x**2 - 2)
x**2 - 2
>>> factor(x**2 - 2, extension=sqrt(2))
(x - sqrt(2))*(x + sqrt(2))
>>> factor(x**2 - 2, domain='QQ<sqrt(2)>')
(x - sqrt(2))*(x + sqrt(2))
>>> factor(x**2 - 2, domain=QQ.algebraic_field(sqrt(2)))
(x - sqrt(2))*(x + sqrt(2)) 
```

可以使用参数`extension=True`，但这只会创建包含系数的扩展，通常不足以因式分解多项式。

```py
>>> p = x**3 + sqrt(2)*x**2 - 2*x - 2*sqrt(2)
>>> factor(p)                         # treats sqrt(2) as a symbol
(x + sqrt(2))*(x**2 - 2)
>>> factor(p, extension=True)
(x - sqrt(2))*(x + sqrt(2))**2
>>> factor(x**2 - 2, extension=True)  # all rational coefficients
x**2 - 2 
```

还可以在[`cancel()`](reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel")和[`gcd()`](reference.html#sympy.polys.polytools.gcd "sympy.polys.polytools.gcd")函数中使用[QQ<a>](#qq-a)。

```py
>>> from sympy import cancel, gcd
>>> cancel((x**2 - 2)/(x - sqrt(2)))
(x**2 - 2)/(x - sqrt(2))
>>> cancel((x**2 - 2)/(x - sqrt(2)), extension=sqrt(2))
x + sqrt(2)
>>> gcd(x**2 - 2, x - sqrt(2))
1
>>> gcd(x**2 - 2, x - sqrt(2), extension=sqrt(2))
x - sqrt(2) 
```

在直接使用域时，可以使用[QQ<a>](#qq-a)作为构造函数创建实例，从而支持`+,-,*,**,/`等操作。[`algebraic_field()`](#sympy.polys.domains.domain.Domain.algebraic_field "sympy.polys.domains.domain.Domain.algebraic_field")方法用于构造特定的[QQ<a>](#qq-a)域。[`from_sympy()`](#sympy.polys.domains.domain.Domain.from_sympy "sympy.polys.domains.domain.Domain.from_sympy")方法可用于从普通的SymPy表达式创建域元素。

```py
>>> K = QQ.algebraic_field(sqrt(2))
>>> K
QQ<sqrt(2)>
>>> xk = K.from_sympy(3 + 4*sqrt(2))
>>> xk  
ANP([4, 3], [1, 0, -2], QQ) 
```

[QQ<a>](#qq-a)的元素是[`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")的实例，它们具有有限的打印支持。原始显示显示元素的内部表示，例如列表`[4, 3]`，表示形式为`a * sqrt(2) + b * 1`，其中`a`和`b`是[QQ](#qq)中的元素，分别代表`1`和`sqrt(2)`的系数。生成器`(x**2 - 2)`的最小多项式也显示在[DUP representation](domainsintro.html#dup-representation)中，表示为列表`[1, 0, -2]`。我们可以使用[`to_sympy()`](#sympy.polys.domains.domain.Domain.to_sympy "sympy.polys.domains.domain.Domain.to_sympy")以获得更好的元素打印形式并查看操作的结果。

```py
>>> xk = K.from_sympy(3 + 4*sqrt(2))
>>> yk = K.from_sympy(2 + 3*sqrt(2))
>>> xk * yk  
ANP([17, 30], [1, 0, -2], QQ)
>>> K.to_sympy(xk * yk)
17*sqrt(2) + 30
>>> K.to_sympy(xk + yk)
5 + 7*sqrt(2)
>>> K.to_sympy(xk ** 2)
24*sqrt(2) + 41
>>> K.to_sympy(xk / yk)
sqrt(2)/14 + 9/7 
```

任何表示代数数的表达式都可以用来生成一个[QQ<a>](#qq-a)域，只要能计算其[最小多项式](https://en.wikipedia.org/wiki/Minimal_polynomial_(field_theory))。使用[`minpoly()`](numberfields.html#sympy.polys.numberfields.minpoly.minpoly "sympy.polys.numberfields.minpoly.minpoly")函数进行此操作。

```py
>>> from sympy import exp, I, pi, minpoly
>>> g = exp(2*I*pi/3)
>>> g
exp(2*I*pi/3)
>>> g.is_algebraic
True
>>> minpoly(g, x)
x**2 + x + 1
>>> factor(x**3 - 1, extension=g)
(x - 1)*(x - exp(2*I*pi/3))*(x + 1 + exp(2*I*pi/3)) 
```

也可以从多个扩展元素生成一个代数域。

```py
>>> K = QQ.algebraic_field(sqrt(2), sqrt(3))
>>> K
QQ<sqrt(2) + sqrt(3)>
>>> p = x**4 - 5*x**2 + 6
>>> factor(p)
(x**2 - 3)*(x**2 - 2)
>>> factor(p, domain=K)
(x - sqrt(2))*(x + sqrt(2))*(x - sqrt(3))*(x + sqrt(3))
>>> factor(p, extension=[sqrt(2), sqrt(3)])
(x - sqrt(2))*(x + sqrt(2))*(x - sqrt(3))*(x + sqrt(3)) 
```

多个扩展元素总是组合在一起形成一个单一的[原始元素](https://en.wikipedia.org/wiki/Primitive_element_theorem)。在`[sqrt(2), sqrt(3)]`的情况下，选择的原始元素是`sqrt(2) + sqrt(3)`，这就是为什么该域显示为`QQ<sqrt(2) + sqrt(3)>`。使用[`primitive_element()`](numberfields.html#sympy.polys.numberfields.subfield.primitive_element "sympy.polys.numberfields.subfield.primitive_element")函数计算原始元素的最小多项式。

```py
>>> from sympy import primitive_element
>>> primitive_element([sqrt(2), sqrt(3)], x)
(x**4 - 10*x**2 + 1, [1, 1])
>>> minpoly(sqrt(2) + sqrt(3), x)
x**4 - 10*x**2 + 1 
```

从域中可以使用[`ext`](#sympy.polys.domains.AlgebraicField.ext "sympy.polys.domains.AlgebraicField.ext")和[`orig_ext`](#sympy.polys.domains.AlgebraicField.orig_ext "sympy.polys.domains.AlgebraicField.orig_ext")属性访问生成域的扩展元素，它们是[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")的实例。作为[`DMP`](#sympy.polys.polyclasses.DMP "sympy.polys.polyclasses.DMP")实例的原始元素的最小多项式可用作[`mod`](#sympy.polys.domains.AlgebraicField.mod "sympy.polys.domains.AlgebraicField.mod")。

```py
>>> K = QQ.algebraic_field(sqrt(2), sqrt(3))
>>> K
QQ<sqrt(2) + sqrt(3)>
>>> K.ext
sqrt(2) + sqrt(3)
>>> K.orig_ext
(sqrt(2), sqrt(3))
>>> K.mod  
DMP_Python([1, 0, -10, 0, 1], QQ) 
```

从域的[`discriminant()`](#sympy.polys.domains.AlgebraicField.discriminant "sympy.polys.domains.AlgebraicField.discriminant")方法可以获取其[判别式](https://en.wikipedia.org/wiki/Discriminant_of_an_algebraic_number_field)，从[`integral_basis()`](#sympy.polys.domains.AlgebraicField.integral_basis "sympy.polys.domains.AlgebraicField.integral_basis")方法可以获取[整基](https://en.wikipedia.org/wiki/Algebraic_number_field#Integral_basis)。后者默认返回[`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")实例的列表，但可以通过传递`fmt`参数使其返回[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")或[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")实例。域的最大秩，或整数环，也可以从[`maximal_order()`](#sympy.polys.domains.AlgebraicField.maximal_order "sympy.polys.domains.AlgebraicField.maximal_order")方法获取，作为[`Submodule`](numberfields.html#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")。

```py
>>> zeta5 = exp(2*I*pi/5)
>>> K = QQ.algebraic_field(zeta5)
>>> K
QQ<exp(2*I*pi/5)>
>>> K.discriminant()
125
>>> K = QQ.algebraic_field(sqrt(5))
>>> K
QQ<sqrt(5)>
>>> K.integral_basis(fmt='sympy')
[1, 1/2 + sqrt(5)/2]
>>> K.maximal_order()
Submodule[[2, 0], [1, 1]]/2 
```

有理素数在域的素理想中的分解由[`primes_above()`](#sympy.polys.domains.AlgebraicField.primes_above "sympy.polys.domains.AlgebraicField.primes_above")方法计算，该方法返回[`PrimeIdeal`](numberfields.html#sympy.polys.numberfields.primes.PrimeIdeal "sympy.polys.numberfields.primes.PrimeIdeal")实例的列表。

```py
>>> zeta7 = exp(2*I*pi/7)
>>> K = QQ.algebraic_field(zeta7)
>>> K
QQ<exp(2*I*pi/7)>
>>> K.primes_above(11)
[(11, _x**3 + 5*_x**2 + 4*_x - 1), (11, _x**3 - 4*_x**2 - 5*_x - 1)] 
```

当域的最小多项式的次数足够小时，可以计算域的Galois闭包的Galois群。

```py
>>> K.galois_group(by_name=True)[0]
S6TransitiveSubgroups.C6 
```

注意事项

目前无法在除[QQ](#qq)以外的任何域上生成代数扩展。理想情况下，可以生成类似`QQ(x)(sqrt(x**2 - 2))`的扩展。这等同于商环`QQ(x)[y]/(y**2 - x**2 + 2)`，在[`QuotientRing`](#sympy.polys.domains.quotientring.QuotientRing "sympy.polys.domains.quotientring.QuotientRing")和[`MonogenicFiniteExtension`](agca.html#sympy.polys.agca.extensions.MonogenicFiniteExtension "sympy.polys.agca.extensions.MonogenicFiniteExtension")类中有两种实现这种商环/扩展。尽管如此，这些实现都需要一些工作才能完全可用。

```py
algebraic_field(*extension, alias=None)
```

返回一个代数域，即\(\mathbb{Q}(\alpha, \ldots)\)。

```py
denom(a)
```

返回`a`的分母。

```py
discriminant()
```

获取域的判别式。

```py
dtype
```

[`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")的别名

```py
ext
```

用于扩展的原始元素。

```py
>>> from sympy import QQ, sqrt
>>> K = QQ.algebraic_field(sqrt(2), sqrt(3))
>>> K.ext
sqrt(2) + sqrt(3) 
```

```py
from_AlgebraicField(a, K0)
```

将AlgebraicField元素‘a’转换为另一个AlgebraicField

```py
from_GaussianIntegerRing(a, K0)
```

将高斯整数元素‘a’转换为`dtype`。

```py
from_GaussianRationalField(a, K0)
```

将高斯有理数元素‘a’转换为`dtype`。

```py
from_QQ(a, K0)
```

将Python的`Fraction`对象转换为`dtype`。

```py
from_QQ_gmpy(a, K0)
```

将GMPY的`mpq`对象转换为`dtype`。

```py
from_QQ_python(a, K0)
```

将Python的`Fraction`对象转换为`dtype`。

```py
from_RealField(a, K0)
```

将mpmath的`mpf`对象转换为`dtype`。

```py
from_ZZ(a, K0)
```

将Python的`int`对象转换为`dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将GMPY的`mpz`对象转换为`dtype`。

```py
from_ZZ_python(a, K0)
```

将Python的`int`对象转换为`dtype`。

```py
from_sympy(a)
```

将SymPy的表达式转换为`dtype`。

```py
galois_group(by_name=False, max_tries=30, randomize=False)
```

计算此域的Galois闭包的Galois群。

示例

如果域是Galois域，则群的阶数将等于域的次数：

```py
>>> from sympy import QQ
>>> from sympy.abc import x
>>> k = QQ.alg_field_from_poly(x**4 + 1)
>>> G, _ = k.galois_group()
>>> G.order()
4 
```

如果域不是Galois域，则其Galois闭包是一个适当的扩展，并且Galois群的阶数将大于域的次数：

```py
>>> k = QQ.alg_field_from_poly(x**4 - 2)
>>> G, _ = k.galois_group()
>>> G.order()
8 
```

另请参阅

[`sympy.polys.numberfields.galoisgroups.galois_group`](numberfields.html#sympy.polys.numberfields.galoisgroups.galois_group "sympy.polys.numberfields.galoisgroups.galois_group")的别名

```py
get_ring()
```

返回与`self`相关联的环。

```py
integral_basis(fmt=None)
```

获取域的整数基。

参数:

**fmt**：str，可选（默认为None）

> 如果为`None`，则返回[`ANP`](#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")实例的列表。如果为`"sympy"`，则使用`self.to_sympy()`将列表中的每个元素转换为[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")。如果为`"alg"`，则使用`self.to_alg_num()`将列表中的每个元素转换为[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")。

示例

```py
>>> from sympy import QQ, AlgebraicNumber, sqrt
>>> alpha = AlgebraicNumber(sqrt(5), alias='alpha')
>>> k = QQ.algebraic_field(alpha)
>>> B0 = k.integral_basis()
>>> B1 = k.integral_basis(fmt='sympy')
>>> B2 = k.integral_basis(fmt='alg')
>>> print(B0[1])  
ANP([mpq(1,2), mpq(1,2)], [mpq(1,1), mpq(0,1), mpq(-5,1)], QQ)
>>> print(B1[1])
1/2 + alpha/2
>>> print(B2[1])
alpha/2 + 1/2 
```

在最后两种情况下，我们得到易读的表达式，由于涉及不同类型，打印方式略有不同：

```py
>>> print(type(B1[1]))
<class 'sympy.core.add.Add'>
>>> print(type(B2[1]))
<class 'sympy.core.numbers.AlgebraicNumber'> 
```

另请参阅

[`to_sympy`](#sympy.polys.domains.AlgebraicField.to_sympy "sympy.polys.domains.AlgebraicField.to_sympy"), [`to_alg_num`](#sympy.polys.domains.AlgebraicField.to_alg_num "sympy.polys.domains.AlgebraicField.to_alg_num"), [`maximal_order`](#sympy.polys.domains.AlgebraicField.maximal_order "sympy.polys.domains.AlgebraicField.maximal_order")

```py
is_negative(a)
```

如果`a`为负数，则返回True。

```py
is_nonnegative(a)
```

如果`a`是非负数，则返回True。

```py
is_nonpositive(a)
```

如果`a`是非正数，则返回True。

```py
is_positive(a)
```

如果`a`为正数，则返回True。

```py
maximal_order()
```

计算字段的最大秩或整数环。

返回：

[`子模块`](numberfields.html#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")。

另请参阅

[`整体基础`](#sympy.polys.domains.AlgebraicField.integral_basis "sympy.polys.domains.AlgebraicField.integral_basis")

```py
mod
```

扩展的原始元素的最小多项式。

```py
>>> from sympy import QQ, sqrt
>>> K = QQ.algebraic_field(sqrt(2))
>>> K.mod
DMP([1, 0, -2], QQ) 
```

```py
numer(a)
```

返回`a`的分子。

```py
orig_ext
```

给定用于生成扩展的原始元素。

```py
>>> from sympy import QQ, sqrt
>>> K = QQ.algebraic_field(sqrt(2), sqrt(3))
>>> K.orig_ext
(sqrt(2), sqrt(3)) 
```

```py
primes_above(p)
```

计算位于给定有理素数*p*之上的素数理想。

```py
to_alg_num(a)
```

将`dtype`的`a`转换为[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")。

```py
to_sympy(a)
```

将`dtype`的`a`转换为SymPy对象。## RR

```py
class sympy.polys.domains.RealField(prec=53, dps=None, tol=None)
```

给定精度的实数。

```py
almosteq(a, b, tolerance=None)
```

检查`a`和`b`是否几乎相等。

```py
exsqrt(a)
```

非负数的平方根，对于`a >= 0`，否则为`None`。

说明

由于浮点舍入误差，平方根可能略有不准确。

```py
from_sympy(expr)
```

将SymPy的数字转换为`dtype`。

```py
gcd(a, b)
```

返回`a`和`b`的最大公约数。

```py
get_exact()
```

返回与`self`相关的精确域。

```py
get_ring()
```

返回与`self`相关的环。

```py
is_square(a)
```

如果`a >= 0`则返回True，否则返回False。

```py
lcm(a, b)
```

返回`a`和`b`的最小公倍数。

```py
to_rational(element, limit=True)
```

将实数转换为有理数。

```py
to_sympy(element)
```

将`element`转换为SymPy数字。

```py
class sympy.polys.domains.mpelements.RealElement(val=(0, 0, 0, 0), **kwargs)
```

实域的一个元素。## CC

```py
class sympy.polys.domains.ComplexField(prec=53, dps=None, tol=None)
```

给定精度的复数。

```py
almosteq(a, b, tolerance=None)
```

检查`a`和`b`是否几乎相等。

```py
exsqrt(a)
```

返回`a`的主复数平方根。

说明

主平方根的参数始终在\((-\frac{\pi}{2}, \frac{\pi}{2}]\)之间。由于浮点舍入误差，平方根可能略有不准确。

```py
from_sympy(expr)
```

将SymPy的数字转换为`dtype`。

```py
gcd(a, b)
```

返回`a`和`b`的最大公约数。

```py
get_exact()
```

返回与`self`相关的精确域。

```py
get_ring()
```

返回与`self`相关的环。

```py
is_negative(element)
```

对于任何`ComplexElement`返回`False`。

```py
is_nonnegative(element)
```

对于任何`ComplexElement`返回`False`。

```py
is_nonpositive(element)
```

对于任何`ComplexElement`返回`False`。

```py
is_positive(element)
```

对于任何`ComplexElement`返回`False`。

```py
is_square(a)
```

返回 `True`。每个复数都有一个复平方根。

```py
lcm(a, b)
```

返回 \(a\) 和 \(b\) 的最小公倍数。

```py
to_sympy(element)
```

将 `element` 转换为 SymPy 数字。

```py
class sympy.polys.domains.mpelements.ComplexElement(real=0, imag=0)
```

复杂域的一个元素。  ## K[x]

```py
class sympy.polys.domains.PolynomialRing(domain_or_ring, symbols=None, order=None)
```

表示多变量多项式环的类。

```py
factorial(a)
```

返回 \(a\) 的阶乘。

```py
from_AlgebraicField(a, K0)
```

将代数数转换为 `dtype`。

```py
from_ComplexField(a, K0)
```

将 mpmath \(mpf\) 对象转换为 `dtype`。

```py
from_FractionField(a, K0)
```

将有理函数转换为 `dtype`。

```py
from_GaussianIntegerRing(a, K0)
```

将 `GaussianInteger` 对象转换为 `dtype`。

```py
from_GaussianRationalField(a, K0)
```

将 `GaussianRational` 对象转换为 `dtype`。

```py
from_GlobalPolynomialRing(a, K0)
```

从旧多项式环转换为 `dtype`。

```py
from_PolynomialRing(a, K0)
```

将多项式转换为 `dtype`。

```py
from_QQ(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY \(mpq\) 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath `mpf` 对象转换为 `dtype`。

```py
from_ZZ(a, K0)
```

将 Python \(int\) 对象转换为 \(dtype\)。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY \(mpz\) 对象转换为 \(dtype\)。

```py
from_ZZ_python(a, K0)
```

将 Python \(int\) 对象转换为 \(dtype\)。

```py
from_sympy(a)
```

将 SymPy 表达式转换为 \(dtype\)。

```py
gcd(a, b)
```

返回 \(a\) 和 \(b\) 的最大公约数。

```py
gcdex(a, b)
```

\(a\) 和 \(b\) 的扩展最大公约数。

```py
get_field()
```

返回与 \(self\) 关联的一个域。

```py
is_negative(a)
```

如果 `LC(a)` 是负则返回 True。

```py
is_nonnegative(a)
```

如果 `LC(a)` 非负则返回 True。

```py
is_nonpositive(a)
```

如果 `LC(a)` 非正则返回 True。

```py
is_positive(a)
```

如果 `LC(a)` 是正则返回 True。

```py
is_unit(a)
```

如果 `a` 是 `self` 的单元返回 `True`。

```py
lcm(a, b)
```

返回 \(a\) 和 \(b\) 的最小公倍数。

```py
to_sympy(a)
```

将 \(a\) 转换为 SymPy 对象。  ## K(x)

```py
class sympy.polys.domains.FractionField(domain_or_field, symbols=None, order=None)
```

表示多变量有理函数域的类。

```py
denom(a)
```

返回 `a` 的分母。

```py
factorial(a)
```

返回 `a` 的阶乘。

```py
from_AlgebraicField(a, K0)
```

将代数数转换为 `dtype`。

```py
from_ComplexField(a, K0)
```

将 mpmath `mpf` 对象转换为 `dtype`。

```py
from_FractionField(a, K0)
```

将有理函数转换为 `dtype`。

```py
from_GaussianIntegerRing(a, K0)
```

将 `GaussianInteger` 对象转换为 `dtype`。

```py
from_GaussianRationalField(a, K0)
```

将 `GaussianRational` 对象转换为 `dtype`。

```py
from_PolynomialRing(a, K0)
```

将多项式转换为 `dtype`。

```py
from_QQ(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY `mpq` 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath `mpf` 对象转换为 `dtype`。

```py
from_ZZ(a, K0)
```

将 Python `int` 对象转换为 `dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将 GMPY `mpz` 对象转换为 `dtype`。

```py
from_ZZ_python(a, K0)
```

将 Python `int` 对象转换为 `dtype`。

```py
from_sympy(a)
```

将 SymPy 表达式转换为 `dtype`。

```py
get_ring()
```

返回与 `self` 关联的一个域。

```py
is_negative(a)
```

如果 `LC(a)` 是负则返回 True。

```py
is_nonnegative(a)
```

如果 `LC(a)` 非负则返回 True。

```py
is_nonpositive(a)
```

如果 `LC(a)` 非正则返回 True。

```py
is_positive(a)
```

如果 `LC(a)` 是正则返回 True。

```py
numer(a)
```

返回 `a` 的分子。

```py
to_sympy(a)
```

将 `a` 转换为 SymPy 对象。  ## EX

```py
class sympy.polys.domains.ExpressionDomain
```

一个表示任意表达式的类。

```py
class Expression(ex)
```

任意表达式。

```py
denom(a)
```

返回 `a` 的分母。

```py
dtype
```

[`Expression`](#sympy.polys.domains.expressiondomain.ExpressionDomain.Expression "sympy.polys.domains.expressiondomain.ExpressionDomain.Expression") 的别名。

```py
from_AlgebraicField(a, K0)
```

将 `ANP` 对象转换为 `dtype`。

```py
from_ComplexField(a, K0)
```

将 mpmath `mpc` 对象转换为 `dtype`。

```py
from_ExpressionDomain(a, K0)
```

将 `EX` 对象转换为 `dtype`。

```py
from_FractionField(a, K0)
```

将 `DMF` 对象转换为 `dtype`。

```py
from_GaussianIntegerRing(a, K0)
```

将 `GaussianRational` 对象转换为 `dtype`。

```py
from_GaussianRationalField(a, K0)
```

将 `GaussianRational` 对象转换为 `dtype`。

```py
from_PolynomialRing(a, K0)
```

将 `DMP` 对象转换为 `dtype`。

```py
from_QQ(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_QQ_gmpy(a, K0)
```

将 GMPY `mpq` 对象转换为 `dtype`。

```py
from_QQ_python(a, K0)
```

将 Python `Fraction` 对象转换为 `dtype`。

```py
from_RealField(a, K0)
```

将 mpmath `mpf` 对象转换为 `dtype`。

```py
from_ZZ(a, K0)
```

将Python的`int`对象转换为`dtype`。

```py
from_ZZ_gmpy(a, K0)
```

将GMPY的`mpz`对象转换为`dtype`。

```py
from_ZZ_python(a, K0)
```

将Python的`int`对象转换为`dtype`。

```py
from_sympy(a)
```

将SymPy表达式转换为`dtype`。

```py
get_field()
```

返回与`self`相关联的字段。

```py
get_ring()
```

返回与`self`相关联的环。

```py
is_negative(a)
```

如果`a`为负数则返回True。

```py
is_nonnegative(a)
```

如果`a`为非负数则返回True。

```py
is_nonpositive(a)
```

如果`a`为非正数则返回True。

```py
is_positive(a)
```

如果`a`为正数则返回True。

```py
numer(a)
```

返回`a`的分子。

```py
to_sympy(a)
```

将`a`转换为SymPy对象。

```py
class ExpressionDomain.Expression(ex)
```

任意表达式。

## 商环

```py
class sympy.polys.domains.quotientring.QuotientRing(ring, ideal)
```

表示（交换）商环的类。

通常不应手动实例化此对象，而是应在构造中使用基本环的构造函数。

```py
>>> from sympy.abc import x
>>> from sympy import QQ
>>> I = QQ.old_poly_ring(x).ideal(x**3 + 1)
>>> QQ.old_poly_ring(x).quotient_ring(I)
QQ[x]/<x**3 + 1> 
```

可以有更短的版本：

```py
>>> QQ.old_poly_ring(x)/I
QQ[x]/<x**3 + 1> 
```

```py
>>> QQ.old_poly_ring(x)/[x**3 + 1]
QQ[x]/<x**3 + 1> 
```

属性：

+   环 - 基本环

+   基本理想 - 用于形成商的理想

## 稀疏多项式

稀疏多项式表示为字典。

```py
sympy.polys.rings.ring(symbols, domain, order=LexOrder())
```

构造一个多项式环，返回`(ring, x_1, ..., x_n)`。

参数：

**symbols**：str

> Symbol/Expr或str、Symbol/Expr序列（非空）

**domain**：[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")或可转换类型

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder")或可转换类型，可选，默认为`lex`

示例

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex 
```

```py
>>> R, x, y, z = ring("x,y,z", ZZ, lex)
>>> R
Polynomial ring in x, y, z over ZZ with lex order
>>> x + y + z
x + y + z
>>> type(_)
<class 'sympy.polys.rings.PolyElement'> 
```

```py
sympy.polys.rings.xring(symbols, domain, order=LexOrder())
```

构造一个多项式环，返回`(ring, (x_1, ..., x_n))`。

参数：

**symbols**：str

> Symbol/Expr或str、Symbol/Expr序列（非空）

**domain**：[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")或可转换类型

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder")或可转换类型，可选，默认为`lex`

示例

```py
>>> from sympy.polys.rings import xring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex 
```

```py
>>> R, (x, y, z) = xring("x,y,z", ZZ, lex)
>>> R
Polynomial ring in x, y, z over ZZ with lex order
>>> x + y + z
x + y + z
>>> type(_)
<class 'sympy.polys.rings.PolyElement'> 
```

```py
sympy.polys.rings.vring(symbols, domain, order=LexOrder())
```

构造一个多项式环，并将`x_1, ..., x_n`注入全局命名空间。

参数：

**symbols**：str

> Symbol/Expr或str、Symbol/Expr序列（非空）

**domain**：[`Domain`](#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")或可转换类型

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder")或可转换类型，可选，默认为`lex`

示例

```py
>>> from sympy.polys.rings import vring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex 
```

```py
>>> vring("x,y,z", ZZ, lex)
Polynomial ring in x, y, z over ZZ with lex order
>>> x + y + z # noqa:
x + y + z
>>> type(_)
<class 'sympy.polys.rings.PolyElement'> 
```

```py
sympy.polys.rings.sring(exprs, *symbols, **options)
```

构造一个环，从选项和输入表达式中派生生成器和域。

参数：

**exprs**：[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")或[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")序列（可简化）

**symbols**：[`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")/[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")序列

**options**：由[`Options`](internals.html#sympy.polys.polyoptions.Options "sympy.polys.polyoptions.Options")理解的关键字参数

示例

```py
>>> from sympy import sring, symbols 
```

```py
>>> x, y, z = symbols("x,y,z")
>>> R, f = sring(x + 2*y + 3*z)
>>> R
Polynomial ring in x, y, z over ZZ with lex order
>>> f
x + 2*y + 3*z
>>> type(_)
<class 'sympy.polys.rings.PolyElement'> 
```

```py
class sympy.polys.rings.PolyRing(symbols, domain, order=LexOrder())
```

多元分布式多项式环。

```py
add(*objs)
```

添加一系列多项式或多项式容器。

示例

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> R, x = ring("x", ZZ)
>>> R.add([ x**2 + 2*i + 3 for i in range(4) ])
4*x**2 + 24
>>> _.factor_list()
(4, [(x**2 + 6, 1)]) 
```

```py
add_gens(symbols)
```

将`symbols`的元素作为生成器添加到`self`

```py
compose(other)
```

将`other`的生成器添加到`self`中

```py
drop(*gens)
```

从此环中移除指定的生成器。

```py
drop_to_ground(*gens)
```

从环中删除指定的生成元并将其注入到其域中。

```py
index(gen)
```

计算 `self.gens` 中 `gen` 的索引。

```py
monomial_basis(i)
```

返回第 `i` 个基础元素。

```py
mul(*objs)
```

将一系列多项式或多项式容器相乘。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> R, x = ring("x", ZZ)
>>> R.mul([ x**2 + 2*i + 3 for i in range(4) ])
x**8 + 24*x**6 + 206*x**4 + 744*x**2 + 945
>>> _.factor_list()
(1, [(x**2 + 3, 1), (x**2 + 5, 1), (x**2 + 7, 1), (x**2 + 9, 1)]) 
```

```py
symmetric_poly(n)
```

返回此环生成器上的度为 *n* 的基本对称多项式。

```py
class sympy.polys.rings.PolyElement
```

多变量分布多项式环中的元素。

```py
almosteq(p2, tolerance=None)
```

多项式的近似相等性测试。

```py
cancel(g)
```

取消有理函数 `f/g` 中的公因子。

例子

```py
>>> from sympy.polys import ring, ZZ
>>> R, x,y = ring("x,y", ZZ) 
```

```py
>>> (2*x**2 - 2).cancel(x**2 - 2*x + 1)
(2*x + 2, x - 1) 
```

```py
coeff(element)
```

返回紧挨给定单项式的系数。

参数：

**element**：PolyElement（带有 `is_monomial = True`）或 1

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y, z = ring("x,y,z", ZZ)
>>> f = 3*x**2*y - x*y*z + 7*z**3 + 23 
```

```py
>>> f.coeff(x**2*y)
3
>>> f.coeff(x*y)
0
>>> f.coeff(1)
23 
```

```py
coeff_wrt(x, deg)
```

相对于 `x**deg` 的 `self` 的系数。

将 `self` 视为 `x` 中的一元多项式，找到作为其他生成元的多项式 `x**deg` 的系数。

参数：

**x**：生成元或生成元索引

> 用于计算表达式的生成元或生成元索引。

**deg**：整数

> 计算表达式的单项式的次数。

返回：

[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 作为同一环中多项式的 `x**deg` 的系数。

例子

```py
>>> from sympy.polys import ring, ZZ
>>> R, x, y, z = ring("x, y, z", ZZ) 
```

```py
>>> p = 2*x**4 + 3*y**4 + 10*z**2 + 10*x*z**2
>>> deg = 2
>>> p.coeff_wrt(2, deg) # Using the generator index
10*x + 10
>>> p.coeff_wrt(z, deg) # Using the generator
10*x + 10
>>> p.coeff(z**2) # shows the difference between coeff and coeff_wrt
10 
```

另见

[`coeff`](#sympy.polys.rings.PolyElement.coeff "sympy.polys.rings.PolyElement.coeff"), [`coeffs`](#sympy.polys.rings.PolyElement.coeffs "sympy.polys.rings.PolyElement.coeffs")

```py
coeffs(order=None)
```

多项式的有序系数列表。

参数：

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder") 或可强制类型转换，可选

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex, grlex 
```

```py
>>> _, x, y = ring("x, y", ZZ, lex)
>>> f = x*y**7 + 2*x**2*y**3 
```

```py
>>> f.coeffs()
[2, 1]
>>> f.coeffs(grlex)
[1, 2] 
```

```py
const()
```

返回常数系数。

```py
content()
```

返回多项式系数的最大公约数。

```py
copy()
```

返回多项式 `self` 的副本。

多项式是可变的；如果有人希望保留一个多项式并且打算使用原地操作，则可以复制多项式。此方法进行浅复制。

例子

```py
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.rings import ring 
```

```py
>>> R, x, y = ring('x, y', ZZ)
>>> p = (x + y)**2
>>> p1 = p.copy()
>>> p2 = p
>>> p[R.zero_monom] = 3
>>> p
x**2 + 2*x*y + y**2 + 3
>>> p1
x**2 + 2*x*y + y**2
>>> p2
x**2 + 2*x*y + y**2 + 3 
```

```py
degree(x=None)
```

`x` 的主导次数或主变量。

注意，0 的次数为负无穷 (`float('-inf')`)

```py
degrees()
```

包含所有变量中的领先次数的元组。

注意，0 的次数为负无穷 (`float('-inf')`)

```py
diff(x)
```

在 `x` 中计算偏导数。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring("x,y", ZZ)
>>> p = x + x**2*y**3
>>> p.diff(x)
2*x*y**3 + 1 
```

```py
div(fv)
```

除法算法，见 [CLO] p64。

多项式数组的 `fv`。

返回 `qv, r`，使得 `self = sum(fv[i]*qv[i]) + r`

所有多项式都要求不是 Laurent 多项式。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring('x, y', ZZ)
>>> f = x**3
>>> f0 = x - y**2
>>> f1 = x - y
>>> qv, r = f.div((f0, f1))
>>> qv[0]
x**2 + x*y**2 + y**4
>>> qv[1]
0
>>> r
y**6 
```

```py
imul_num(c)
```

将多项式 `p` 乘以系数环中的元素，如果 `p` 不是生成元之一，则原地乘；否则，不原地乘。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring('x, y', ZZ)
>>> p = x + y**2
>>> p1 = p.imul_num(3)
>>> p1
3*x + 3*y**2
>>> p1 is p
True
>>> p = x
>>> p1 = p.imul_num(3)
>>> p1
3*x
>>> p1 is p
False 
```

```py
itercoeffs()
```

多项式系数的系数迭代器。

```py
itermonoms()
```

多项式单项式的单项式迭代器。

```py
iterterms()
```

多项式项的项迭代器。

```py
leading_expv()
```

根据单项式顺序的领先单项式元组。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y, z = ring('x, y, z', ZZ)
>>> p = x**4 + x**3*y + x**2*z**2 + z**7
>>> p.leading_expv()
(4, 0, 0) 
```

```py
leading_monom()
```

领先单项式作为多项式元素。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring('x, y', ZZ)
>>> (3*x*y + y**2).leading_monom()
x*y 
```

```py
leading_term()
```

领先项作为多项式元素。

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring('x, y', ZZ)
>>> (3*x*y + y**2).leading_term()
3*x*y 
```

```py
listcoeffs()
```

多项式系数的无序列表。

```py
listmonoms()
```

多项式单项式的无序列表。

```py
listterms()
```

多项式项的无序列表。

```py
monic()
```

将所有系数除以领先系数。

```py
monoms(order=None)
```

多项式单项式的有序列表。

参数：

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder") 或可强制转换的，可选

例子

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex, grlex 
```

```py
>>> _, x, y = ring("x, y", ZZ, lex)
>>> f = x*y**7 + 2*x**2*y**3 
```

```py
>>> f.monoms()
[(2, 3), (1, 7)]
>>> f.monoms(grlex)
[(1, 7), (2, 3)] 
```

```py
pdiv(g, x=None)
```

计算与多项式`self`相对于`g`的伪除。

伪除算法用于找到伪商`q`和伪余数`r`，使得`m*f = g*q + r`，其中`m`表示乘数，`f`是被除多项式。

伪商`q`和伪余数`r`是关于变量`x`的多项式，其中`r`相对于`x`的度严格小于`g`相对于`x`的度。

乘数`m`被定义为`LC(g, x) ^ (deg(f, x) - deg(g, x) + 1)`，其中`LC(g, x)`表示`g`的主导系数。

在`prem`方法的上下文中，环中的多变量多项式，如`R[x,y,z]`，被视为具有多项式系数的单变量多项式，如`R[x,y][z]`。当相对于变量`z`除以`f`和`g`时，伪商`q`和伪余数`r`满足`m*f = g*q + r`，其中`deg(r, z) < deg(g, z)`，且`m = LC(g, z)^(deg(f, z) - deg(g, z) + 1)`。

在这个函数中，伪余数`r`可以通过`prem`方法获得，伪商`q`可以通过`pquo`方法获得，函数`pdiv`本身返回一个元组`(q, r)`。

参数：

**g**：[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 被除多项式。

**x**：生成器或生成器索引，可选

> 多项式的主变量及默认为第一个生成器。

返回：

[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 伪除多项式（元组`q`和`r`）。

引发：

**ZeroDivisionError**：如果`g`是零多项式。

例子

```py
>>> from sympy.polys import ring, ZZ
>>> R, x, y = ring("x, y", ZZ) 
```

```py
>>> f = x**2 + x*y
>>> g = 2*x + 2
>>> f.pdiv(g) # first generator is chosen by default if it is not given
(2*x + 2*y - 2, -4*y + 4)
>>> f.div(g) # shows the difference between pdiv and div
(0, x**2 + x*y)
>>> f.pdiv(g, y) # generator is given
(2*x**3 + 2*x**2*y + 6*x**2 + 2*x*y + 8*x + 4, 0)
>>> f.pdiv(g, 1) # generator index is given
(2*x**3 + 2*x**2*y + 6*x**2 + 2*x*y + 8*x + 4, 0) 
```

另见

[`prem`](#sympy.polys.rings.PolyElement.prem "sympy.polys.rings.PolyElement.prem")

比\(f.pdiv(g)[1]\)更高效地计算仅伪余数。

[`pquo`](#sympy.polys.rings.PolyElement.pquo "sympy.polys.rings.PolyElement.pquo")

仅返回伪商。

[`pexquo`](#sympy.polys.rings.PolyElement.pexquo "sympy.polys.rings.PolyElement.pexquo")

仅返回无余项的精确伪商。

[`div`](#sympy.polys.rings.PolyElement.div "sympy.polys.rings.PolyElement.div")

返回`f`和`g`多项式的商和余数。

```py
pexquo(g, x=None)
```

多变量多项式环中的精确多项式伪商。

例子

```py
>>> from sympy.polys import ring, ZZ
>>> R, x,y = ring("x,y", ZZ) 
```

```py
>>> f = x**2 + x*y
>>> g = 2*x + 2*y
>>> h = 2*x + 2
>>> f.pexquo(g)
2*x
>>> f.exquo(g) # shows the differnce between pexquo and exquo
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x + 2*y does not divide x**2 + x*y
>>> f.pexquo(h)
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x + 2 does not divide x**2 + x*y 
```

另见

[`prem`](#sympy.polys.rings.PolyElement.prem "sympy.polys.rings.PolyElement.prem")，[`pdiv`](#sympy.polys.rings.PolyElement.pdiv "sympy.polys.rings.PolyElement.pdiv")，[`pquo`](#sympy.polys.rings.PolyElement.pquo "sympy.polys.rings.PolyElement.pquo")，[`sympy.polys.domains.ring.Ring.exquo`](#sympy.polys.domains.ring.Ring.exquo "sympy.polys.domains.ring.Ring.exquo")

```py
pquo(g, x=None)
```

多变量多项式环中的多项式伪商。

例子

```py
>>> from sympy.polys import ring, ZZ
>>> R, x,y = ring("x,y", ZZ) 
```

```py
>>> f = x**2 + x*y
>>> g = 2*x + 2*y
>>> h = 2*x + 2
>>> f.pquo(g)
2*x
>>> f.quo(g) # shows the difference between pquo and quo
0
>>> f.pquo(h)
2*x + 2*y - 2
>>> f.quo(h) # shows the difference between pquo and quo
0 
```

另见

[`prem`](#sympy.polys.rings.PolyElement.prem "sympy.polys.rings.PolyElement.prem"), [`pdiv`](#sympy.polys.rings.PolyElement.pdiv "sympy.polys.rings.PolyElement.pdiv"), [`pexquo`](#sympy.polys.rings.PolyElement.pexquo "sympy.polys.rings.PolyElement.pexquo"), [`sympy.polys.domains.ring.Ring.quo`](#sympy.polys.domains.ring.Ring.quo "sympy.polys.domains.ring.Ring.quo")

```py
prem(g, x=None)
```

多项式`self`相对于`g`的伪余数。

将`f`除以`g`时，相对于`z`的伪商`q`和伪余数`r`满足`m*f = g*q + r`，其中`deg(r,z) < deg(g,z)`，并且`m = LC(g,z)**(deg(f,z) - deg(g,z)+1)`。

参见[`pdiv()`](#sympy.polys.rings.PolyElement.pdiv "sympy.polys.rings.PolyElement.pdiv")以了解伪除法的解释。

参数：

**g**：[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 被`self`除以的多项式。

**x**：生成器或生成器索引，可选

> 多项式的主变量，默认为第一个生成器。

Returns:

[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 伪余数多项式。

Raises:

**ZeroDivisionError**：如果`g`是零多项式。

示例

```py
>>> from sympy.polys import ring, ZZ
>>> R, x, y = ring("x, y", ZZ) 
```

```py
>>> f = x**2 + x*y
>>> g = 2*x + 2
>>> f.prem(g) # first generator is chosen by default if it is not given
-4*y + 4
>>> f.rem(g) # shows the differnce between prem and rem
x**2 + x*y
>>> f.prem(g, y) # generator is given
0
>>> f.prem(g, 1) # generator index is given
0 
```

另请参阅

[`pdiv`](#sympy.polys.rings.PolyElement.pdiv "sympy.polys.rings.PolyElement.pdiv"), [`pquo`](#sympy.polys.rings.PolyElement.pquo "sympy.polys.rings.PolyElement.pquo"), [`pexquo`](#sympy.polys.rings.PolyElement.pexquo "sympy.polys.rings.PolyElement.pexquo"), [`sympy.polys.domains.ring.Ring.rem`](#sympy.polys.domains.ring.Ring.rem "sympy.polys.domains.ring.Ring.rem")

```py
primitive()
```

返回内容和原始多项式。

```py
square()
```

多项式的平方

示例

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y = ring('x, y', ZZ)
>>> p = x + y**2
>>> p.square()
x**2 + 2*x*y**2 + y**4 
```

```py
strip_zero()
```

消除零系数的单项式。

```py
subresultants(g, x=None)
```

计算两个多项式`self`和`g`的次结果PRS。

参数：

**g**：[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")

> 第二个多项式。

**x**：生成器或生成器索引

> 计算次结果序列的变量。

Returns:

**R**：列表

> 返回一个表示次结果PRS的多项式列表。

示例

```py
>>> from sympy.polys import ring, ZZ
>>> R, x, y = ring("x, y", ZZ) 
```

```py
>>> f = x**2*y + x*y
>>> g = x + y
>>> f.subresultants(g) # first generator is chosen by default if not given
[x**2*y + x*y, x + y, y**3 - y**2]
>>> f.subresultants(g, 0) # generator index is given
[x**2*y + x*y, x + y, y**3 - y**2]
>>> f.subresultants(g, y) # generator is given
[x**2*y + x*y, x + y, x**3 + x**2] 
```

```py
symmetrize()
```

用基本对称多项式重新表达*self*。

Returns:

三元组`(p, r, m)`

> `p`是一个[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")，代表我们尝试将*self*表示为基本对称多项式函数的结果。`p`中的每个变量代表一个基本对称多项式，映射由`m`给出。
> 
> `r`是余数。
> 
> `m`是一个列表，给出了从`p`中的变量到基本对称多项式的映射。
> 
> 三元组满足方程`p.compose(m) + r == self`。如果余数`r`为零，则*self*是对称的。如果不为零，则我们无法将*self*表示为对称的。

Explanation

如果这个[`PolyElement`](#sympy.polys.rings.PolyElement "sympy.polys.rings.PolyElement")属于\(n\)变量的环，我们可以尝试将其写成\(n\)变量的基本对称多项式的函数。我们计算对称部分和任何无法对称化的余数的余数。

示例

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ
>>> R, x, y = ring("x,y", ZZ) 
```

```py
>>> f = x**2 + y**2
>>> f.symmetrize()
(x**2 - 2*y, 0, [(x, x + y), (y, x*y)]) 
```

```py
>>> f = x**2 - y**2
>>> f.symmetrize()
(x**2 - 2*y, -2*y**2, [(x, x + y), (y, x*y)]) 
```

另请参见

[`sympy.polys.polyfuncs.symmetrize`](reference.html#sympy.polys.polyfuncs.symmetrize "sympy.polys.polyfuncs.symmetrize")

参考

[[R783](#id14)]

Lauer, E. Symmetrical polynomials算法，Proc. 1976 ACM Symp. on Symbolic and Algebraic Computing，NY 242-247。[https://dl.acm.org/doi/pdf/10.1145/800205.806342](https://dl.acm.org/doi/pdf/10.1145/800205.806342)

```py
tail_degree(x=None)
```

`x`的尾度或主变量。

注意，0的度为负无穷（`float('-inf')`）

```py
tail_degrees()
```

包含所有变量的尾度的元组。

注意，0的度为负无穷（`float('-inf')`）

```py
terms(order=None)
```

有序多项式项的列表。

参数：

**order**：[`MonomialOrder`](reference.html#sympy.polys.orderings.MonomialOrder "sympy.polys.orderings.MonomialOrder")或者可强制转换的，可选

示例

```py
>>> from sympy.polys.rings import ring
>>> from sympy.polys.domains import ZZ
>>> from sympy.polys.orderings import lex, grlex 
```

```py
>>> _, x, y = ring("x, y", ZZ, lex)
>>> f = x*y**7 + 2*x**2*y**3 
```

```py
>>> f.terms()
[((2, 3), 2), ((1, 7), 1)]
>>> f.terms(grlex)
[((1, 7), 1), ((2, 3), 2)] 
```

## 稀疏有理函数

稀疏多项式表示为字典。

```py
sympy.polys.fields.field(symbols, domain, order=LexOrder())
```

构造新的有理函数域，返回（域，x1，…，xn）。

```py
sympy.polys.fields.xfield(symbols, domain, order=LexOrder())
```

构造新的有理函数域，返回（域，（x1，…，xn））。

```py
sympy.polys.fields.vfield(symbols, domain, order=LexOrder())
```

构造新的有理函数域，并将生成器注入全局命名空间。

```py
sympy.polys.fields.sfield(exprs, *symbols, **options)
```

根据选项和输入表达式构造一个域，并生成域。

参数：

**exprs**：py:class:\(~.Expr\) 或者 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") 的序列（可简化）

**符号**：[`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")/[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")的序列

**选项**：被[`Options`](internals.html#sympy.polys.polyoptions.Options "sympy.polys.polyoptions.Options")理解的关键字参数

示例

```py
>>> from sympy import exp, log, symbols, sfield 
```

```py
>>> x = symbols("x")
>>> K, f = sfield((x*log(x) + 4*x**2)*exp(1/x + log(x)/3)/x**2)
>>> K
Rational function field in x, exp(1/x), log(x), x**(1/3) over ZZ with lex order
>>> f
(4*x**2*(exp(1/x)) + x*(exp(1/x))*(log(x)))/((x**(1/3))**5) 
```

```py
class sympy.polys.fields.FracField(symbols, domain, order=LexOrder())
```

多变量分布有理函数域。

```py
class sympy.polys.fields.FracElement(numer, denom=None)
```

多变量分布有理函数域的元素。

```py
diff(x)
```

计算`x`中的偏导数。

示例

```py
>>> from sympy.polys.fields import field
>>> from sympy.polys.domains import ZZ 
```

```py
>>> _, x, y, z = field("x,y,z", ZZ)
>>> ((x**2 + y)/(z + 1)).diff(x)
2*x/(z + 1) 
```

## 密集多项式

```py
class sympy.polys.polyclasses.DMP(rep, dom, lev=None)
```

在\(K\)上的密集多变量多项式。

```py
LC()
```

返回`f`的首系数。

```py
TC()
```

返回`f`的尾系数。

```py
abs()
```

使`f`中的所有系数均为正。

```py
add(g)
```

添加两个多变量多项式`f`和`g`。

```py
add_ground(c)
```

将一个地域域的元素添加到`f`。

```py
all_coeffs()
```

返回`f`的所有系数。

```py
all_monoms()
```

返回`f`中的所有单项式。

```py
all_terms()
```

返回`f`的所有项。

```py
cancel(g, include=True)
```

取消有理函数`f/g`中的公因子。

```py
cauchy_lower_bound()
```

计算`f`的非零根的柯西下界。

```py
cauchy_upper_bound()
```

计算`f`的根的柯西上界。

```py
clear_denoms()
```

清除分母，但保留地域域。

```py
coeffs(order=None)
```

按字典序返回`f`中的所有非零系数。

```py
cofactors(g)
```

返回`f`和`g`的GCD及其余式。

```py
compose(g)
```

计算`f`和`g`的函数组合。

```py
content()
```

返回多项式系数的GCD。

```py
convert(dom)
```

将`f`转换为在新域上的`DMP`。

```py
count_complex_roots(inf=None, sup=None)
```

在`[inf, sup]`中计算`f`的复根的数量。

```py
count_real_roots(inf=None, sup=None)
```

返回`f`在`[inf, sup]`中的实根数。

```py
decompose()
```

计算`f`的函数分解。

```py
deflate()
```

通过将\(x_i^m\)映射到\(y_i\)来减少\(f\)的次数。

```py
degree(j=0)
```

返回`f`在`x_j`中的主导度。

```py
degree_list()
```

返回`f`的次数列表。

```py
diff(m=1, j=0)
```

计算`f`在`x_j`处的`m`阶导数。

```py
discriminant()
```

计算`f`的判别式。

```py
div(g)
```

`f`和`g`的多项式除法及余数。

```py
eject(dom, front=False)
```

将选定的生成器弹出到基域。

```py
eval(a, j=0)
```

在给定点`a`处评估`f`在`x_j`中。

```py
exclude()
```

从`f`中删除无用的生成器。

返回移除的生成器和新排除的`f`。

示例

```py
>>> from sympy.polys.polyclasses import DMP
>>> from sympy.polys.domains import ZZ 
```

```py
>>> DMP([[[ZZ(1)]], [[ZZ(1)], [ZZ(2)]]], ZZ).exclude()
([2], DMP_Python([[1], [1, 2]], ZZ)) 
```

```py
exquo(g)
```

计算`f`和`g`的多项式精确商。

```py
exquo_ground(c)
```

通过基域元素精确除`f`的商。

```py
factor_list()
```

返回`f`的不可约因子列表。

```py
factor_list_include()
```

返回`f`的不可约因子列表。

```py
classmethod from_list(rep, lev, dom)
```

给定原生系数列表，创建`cls`的实例。

```py
classmethod from_sympy_list(rep, lev, dom)
```

给定SymPy系数列表，创建`cls`的实例。

```py
gcd(g)
```

返回`f`和`g`的多项式最大公约数。

```py
gcdex(g)
```

扩展欧几里得算法，如果是一元的。

```py
gff_list()
```

计算`f`的最大阶乘因子分解。

```py
ground_new(coeff)
```

构造`f`的新基域实例。

```py
half_gcdex(g)
```

半扩展欧几里得算法，如果是一元的。

```py
homogeneous_order()
```

返回`f`的齐次阶数。

```py
homogenize(s)
```

返回`f`的齐次多项式。

```py
inject(front=False)
```

将基域生成器注入到`f`中。

```py
integrate(m=1, j=0)
```

计算`f`在`x_j`中的`m`阶不定积分。

```py
intervals(all=False, eps=None, inf=None, sup=None, fast=False, sqf=False)
```

计算`f`的根的隔离区间。

```py
invert(g)
```

如果可能，对`f`关于`g`取模倒数。

```py
property is_cyclotomic
```

如果`f`是循环多项式，则返回`True`。

```py
property is_ground
```

如果`f`是基域的元素，则返回`True`。

```py
property is_homogeneous
```

如果`f`是齐次多项式，则返回`True`。

```py
property is_irreducible
```

如果`f`在其域中没有因子，则返回`True`。

```py
property is_linear
```

如果`f`在所有变量中都是线性的，则返回`True`。

```py
property is_monic
```

如果`f`的首项系数为1，则返回`True`。

```py
property is_monomial
```

如果`f`为零或只有一项，则返回`True`。

```py
property is_one
```

如果`f`是单位多项式，则返回`True`。

```py
property is_primitive
```

如果`f`的系数的最大公约数为1，则返回`True`。

```py
property is_quadratic
```

如果`f`在所有变量中都是二次的，则返回`True`。

```py
property is_sqf
```

如果`f`是无平方根多项式，则返回`True`。

```py
property is_zero
```

如果`f`是零多项式，则返回`True`。

```py
l1_norm()
```

返回`f`的l1范数。

```py
l2_norm_squared()
```

返回`f`的平方l2范数。

```py
lcm(g)
```

返回`f`和`g`的多项式最小公倍数。

```py
lift()
```

将代数系数转换为有理数。

```py
max_norm()
```

返回`f`的最大范数。

```py
mignotte_sep_bound_squared()
```

计算`f`根分离的平方Mignotte界。

```py
monic()
```

将`f`的所有系数除以`LC(f)`。

```py
monoms(order=None)
```

返回`f`中按字典序的所有非零单项式。

```py
mul(g)
```

将两个多变量多项式`f`和`g`相乘。

```py
mul_ground(c)
```

将`f`乘以基域的元素。

```py
neg()
```

反转`f`中所有系数。

```py
norm()
```

计算`Norm(f)`。

```py
nth(*N)
```

返回`f`的第`n`个系数。

```py
pdiv(g)
```

`f`和`g`的多项式伪除法。

```py
permute(P)
```

返回在\(K[x_{P(1)}, ..., x_{P(n)}]\)中的多项式。

示例

```py
>>> from sympy.polys.polyclasses import DMP
>>> from sympy.polys.domains import ZZ 
```

```py
>>> DMP([[[ZZ(2)], [ZZ(1), ZZ(0)]], [[]]], ZZ).permute([1, 0, 2])
DMP_Python([[[2], []], [[1, 0], []]], ZZ) 
```

```py
>>> DMP([[[ZZ(2)], [ZZ(1), ZZ(0)]], [[]]], ZZ).permute([1, 2, 0])
DMP_Python([[[1], []], [[2, 0], []]], ZZ) 
```

```py
pexquo(g)
```

`f`和`g`的多项式精确伪商。

```py
pow(n)
```

将`f`提升到非负幂`n`。

```py
pquo(g)
```

`f`和`g`的多项式伪商。

```py
prem(g)
```

`f`和`g`的多项式伪余数。

```py
primitive()
```

返回`f`的内容和一个原始形式。

```py
quo(g)
```

计算`f`和`g`的多项式商。

```py
quo_ground(c)
```

通过基域元素除`f`的商。

```py
refine_root(s, t, eps=None, steps=None, fast=False)
```

精确化到给定精度的隔离区间。

`eps` 应为一个有理数。

```py
rem(g)
```

计算 `f` 和 `g` 的多项式余数。

```py
property rep
```

获取 `f` 的表示。

```py
resultant(g, includePRS=False)
```

通过 PRS 计算 `f` 和 `g` 的结果。

```py
revert(n)
```

计算 `f**(-1)` 模 `x**n`。

```py
shift(a)
```

高效计算 Taylor 移位 `f(x + a)`。

```py
shift_list(a)
```

高效计算 Taylor 移位 `f(X + A)`。

```py
slice(m, n, j=0)
```

取 `f` 的项的连续子序列。

```py
sqf_list(all=False)
```

返回 `f` 的平方自由因子列表。

```py
sqf_list_include(all=False)
```

返回 `f` 的平方自由因子列表。

```py
sqf_norm()
```

计算 `f` 的平方自由规范。

```py
sqf_part()
```

计算 `f` 的平方自由部分。

```py
sqr()
```

对多变量多项式 `f` 进行平方。

```py
sturm()
```

计算 `f` 的斯图姆序列。

```py
sub(g)
```

将两个多变量多项式 `f` 和 `g` 相减。

```py
sub_ground(c)
```

从地面域中减去 `f` 的一个元素。

```py
subresultants(g)
```

计算 `f` 和 `g` 的子结果 PRS 序列。

```py
terms(order=None)
```

返回 `f` 中按字典顺序的所有非零项。

```py
terms_gcd()
```

从多项式 `f` 中删除项的最大公因数。

```py
to_best()
```

如果可能，转换为 DUP_Flint。

当域或级别改变时应使用此方法，可能可以从 DMP_Python 转换为 DUP_Flint。

```py
to_dict(zero=False)
```

将 `f` 转换为具有本机系数的字典表示。

```py
to_exact()
```

使地面域精确。

```py
to_field()
```

使地面域成为一个域。

```py
to_list()
```

将 `f` 转换为具有本机系数的列表表示。

```py
to_ring()
```

使地面域成为一个环。

```py
to_sympy_dict(zero=False)
```

将 `f` 转换为具有 SymPy 系数的字典表示。

```py
to_sympy_list()
```

将 `f` 转换为具有 SymPy 系数的列表表示。

```py
to_tuple()
```

将 `f` 转换为具有本机系数的元组表示。

这是哈希所需的。

```py
total_degree()
```

返回 `f` 的总次数。

```py
transform(p, q)
```

评估功能变换 `q**n * f(p/q)`。

```py
trunc(p)
```

将 `f` 减去常数 `p` 的模。

```py
unify_DMP(g)
```

统一并返回 `f` 和 `g` 的 `DMP` 实例。

```py
class sympy.polys.polyclasses.DMF(rep, dom, lev=None)
```

在域 \(K\) 上的密集多变量分数。

```py
add(g)
```

将两个多变量分数 `f` 和 `g` 相加。

```py
add_ground(c)
```

向 `f` 添加地面域的一个元素。

```py
cancel()
```

从 `f.num` 和 `f.den` 中删除公共因子。

```py
denom()
```

返回 `f` 的分母。

```py
exquo(g)
```

计算分数 `f` 和 `g` 的商。

```py
frac_unify(g)
```

统一两个多变量分数的表示。

```py
half_per(rep, kill=False)
```

创建给定表示的 DMP。

```py
invert(check=True)
```

计算分数 `f` 的逆。

```py
property is_one
```

如果 `f` 是单位分数，返回 `True`。

```py
property is_zero
```

如果 `f` 是零分数，返回 `True`。

```py
mul(g)
```

乘以两个多变量分数 `f` 和 `g`。

```py
neg()
```

反转 `f` 中的所有系数。

```py
numer()
```

返回 `f` 的分子。

```py
per(num, den, cancel=True, kill=False)
```

根据给定表示创建 DMF。

```py
poly_unify(g)
```

统一多变量分数和多项式。

```py
pow(n)
```

将 `f` 提升到非负幂 `n`。

```py
quo(g)
```

计算分数 `f` 和 `g` 的商。

```py
sub(g)
```

将两个多变量分数 `f` 和 `g` 相减。

```py
class sympy.polys.polyclasses.ANP(rep, mod, dom)
```

在域上的密集代数数多项式。

```py
LC()
```

返回 `f` 的首项系数。

```py
TC()
```

返回 `f` 的尾数系数。

```py
add_ground(c)
```

向 `f` 添加地面域的一个元素。

```py
convert(dom)
```

将 `f` 转换为新域上的 `ANP`。

```py
property is_ground
```

如果 `f` 是地面域的元素，返回 `True`。

```py
property is_one
```

如果 `f` 是单位代数数，返回 `True`。

```py
property is_zero
```

如果 `f` 是零代数数，返回 `True`。

```py
mod_to_list()
```

将 `f.mod` 作为具有本机系数的列表返回。

```py
mul_ground(c)
```

将 `f` 乘以地面域的一个元素。

```py
pow(n)
```

将 `f` 提升到非负幂 `n`。

```py
quo_ground(c)
```

以地面域元素为除数`f`的商。

```py
sub_ground(c)
```

从地面域元素中减去`f`。

```py
to_dict()
```

将`f`转换为具有本地系数的字典表示。

```py
to_list()
```

将`f`转换为具有本地系数的列表表示。

```py
to_sympy_dict()
```

将`f`转换为具有SymPy系数的字典表示。

```py
to_sympy_list()
```

将`f`转换为具有SymPy系数的列表表示。

```py
to_tuple()
```

将`f`转换为具有本地系数的元组表示。

这对于哈希是必需的。

```py
unify(g)
```

统一两个代数数的表示。

```py
unify_ANP(g)
```

统一并返回`f`和`g`的`DMP`实例。
