# 李代数

> 原文：[https://docs.sympy.org/latest/modules/liealgebras/index.html](https://docs.sympy.org/latest/modules/liealgebras/index.html)

```py
class sympy.liealgebras.root_system.RootSystem(cartantype)
```

表示简单李代数的根系

每个简单李代数都有一个唯一的根系。要找到根系，我们首先考虑g的Cartan子代数，即最大的阿贝尔子代数，并考虑g对该子代数的伴随作用。与此作用相关联的是一个根系。现在，一个向量空间V上的根系是一组有限向量Phi（称为根），满足：

1.  根跨越V

1.  Phi中x的唯一标量倍数是x和-x

1.  对于Phi中的每个x，Phi集合在通过x的垂直超平面的反射下是封闭的。

1.  如果x和y是Phi中的根，则y在通过x的线上的投影是x的半整数倍。

现在，有Phi的一个子集Delta，我们称之为Delta，满足：1. Delta是V的一个基础 2. Phi中的每个根x可以写成x = sum k_y y，其中y在Delta中

Delta的元素被称为简单根。因此，我们可以看到简单根跨越了给定简单李代数的根空间。

参考文献

[[R598](#id1)]

[https://en.wikipedia.org/wiki/Root_system](https://en.wikipedia.org/wiki/Root_system)

[[R599](#id2)]

李代数与表示论 - Humphreys

```py
add_as_roots(root1, root2)
```

只有它们的和也是一个根时才将两个根相加

它以两个应该是根的向量作为输入。然后计算它们的和，并检查它是否在所有可能根的列表中。如果是，则返回总和。否则，返回一个字符串，说明总和不是一个根。

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> c.add_as_roots([1, 0, -1, 0], [0, 0, 1, -1])
[1, 0, 0, -1]
>>> c.add_as_roots([1, -1, 0, 0], [0, 0, -1, 1])
'The sum of these two roots is not a root' 
```

```py
add_simple_roots(root1, root2)
```

将两个简单根相加

此函数将两个整数root1和root2作为输入。然后，它将这些整数用作简单根字典中的键，并获取相应的简单根，然后将它们相加。

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> newroot = c.add_simple_roots(1, 2)
>>> newroot
[1, 0, -1, 0] 
```

```py
all_roots()
```

生成给定根系的所有根。

结果是一个字典，其键是整数。它通过从基类获取所有正根的字典，然后取每个根，乘以-1并加入字典来生成根。通过这种方式生成所有负根。

```py
cartan_matrix()
```

与此根系相关联的李代数的Cartan矩阵

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> c.cartan_matrix()
Matrix([
 [ 2, -1,  0],
 [-1,  2, -1],
 [ 0, -1,  2]]) 
```

```py
dynkin_diagram()
```

与此根系相关联的李代数的Dynkin图

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> print(c.dynkin_diagram())
0---0---0
1   2   3 
```

```py
root_space()
```

返回简单根的跨度

根空间是由简单根张成的向量空间，即具有显著基础的向量空间，即简单根。该方法返回一个表示根空间的字符串，作为简单根alpha[1]，...，alpha[n]的张量。

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> c.root_space()
'alpha[1] + alpha[2] + alpha[3]' 
```

```py
simple_roots()
```

生成李代数的简单根

李代数的秩决定了它具有的简单根数量。该方法获取李代数的秩，然后使用李代数类中的simple_root方法生成所有简单根。

例子

```py
>>> from sympy.liealgebras.root_system import RootSystem
>>> c = RootSystem("A3")
>>> roots = c.simple_roots()
>>> roots
{1: [1, -1, 0, 0], 2: [0, 1, -1, 0], 3: [0, 0, 1, -1]} 
```

```py
class sympy.liealgebras.type_a.TypeA(n)
```

此类包含有关简单Lie代数A系列的信息。 ====

```py
basic_root(i, j)
```

这是一种仅生成具有第i个位置为1和第j个位置为-1的根的方法。

```py
basis()
```

返回A_n的独立生成器数目

```py
cartan_matrix()
```

返回A_n的Cartan矩阵。Lie代数的Cartan矩阵是通过对简单根(alpha[1], …., alpha[l])进行排序生成的。然后Cartan矩阵的ij项是(<alpha[i],alpha[j]>).

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('A4')
>>> c.cartan_matrix()
Matrix([
[ 2, -1,  0,  0],
[-1,  2, -1,  0],
[ 0, -1,  2, -1],
[ 0,  0, -1,  2]]) 
```

```py
dimension()
```

Lie代数V空间的向量维数

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A4")
>>> c.dimension()
5 
```

```py
highest_root()
```

返回A_n的最高权根

```py
lie_algebra()
```

返回与A_n相关联的Lie代数

```py
positive_roots()
```

这种方法生成A_n的所有正根。这是A_n所有根的一半；通过将所有正根乘以-1，我们得到负根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回A_n的总根数

```py
simple_root(i)
```

每个李代数都有一个唯一的根系。给定一个根系Q，存在一个子集合根使得Q的元素称为简单根，如果它不能被写成Q中两个元素的和。如果我们让D表示简单根的集合，那么很明显，Q的每个元素都可以写成D的元素的线性组合，所有系数都是非负的。

在A_n中，第i个简单根是具有第i个位置为1，在(i+1)位置为-1，其他位置为零的根。

此方法返回A系列的第i个简单根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A4")
>>> c.simple_root(1)
[1, -1, 0, 0, 0] 
```

```py
class sympy.liealgebras.type_b.TypeB(n)
```

```py
basic_root(i, j)
```

这是一种仅生成具有第i个位置为1和第j个位置为-1的根的方法。

```py
basis()
```

返回B_n的独立生成器数目

```py
cartan_matrix()
```

返回B_n的Cartan矩阵。Lie代数的Cartan矩阵是通过对简单根(alpha[1], …., alpha[l])进行排序生成的。然后Cartan矩阵的ij项是(<alpha[i],alpha[j]>).

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('B4')
>>> c.cartan_matrix()
Matrix([
[ 2, -1,  0,  0],
[-1,  2, -1,  0],
[ 0, -1,  2, -2],
[ 0,  0, -1,  2]]) 
```

```py
dimension()
```

Lie代数V空间的向量维数

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("B3")
>>> c.dimension()
3 
```

```py
lie_algebra()
```

返回与B_n相关联的Lie代数

```py
positive_roots()
```

此方法生成A_n的所有正根。这是B_n所有根的一半；通过将所有正根乘以-1，我们得到负根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回B_n的总根数”

```py
simple_root(i)
```

每个李代数都有一个唯一的根系。给定一个根系Q，存在一个子集合根使得Q的元素称为简单根，如果它不能被写成Q中两个元素的和。如果我们让D表示简单根的集合，那么很明显，Q的每个元素都可以写成D的元素的线性组合，所有系数都是非负的。

在B_n中，前n-1个简单根与A_(n-1)中的根相同（第i个位置为1，(i+1)位置为-1，其他位置为零）。第n个简单根是在第n个位置为1，其他位置为零的根。

此方法返回B系列的第i个简单根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("B3")
>>> c.simple_root(2)
[0, 1, -1] 
```

```py
class sympy.liealgebras.type_c.TypeC(n)
```

```py
basic_root(i, j)
```

生成具有第i个位置为1和第j个位置为-1的根

```py
basis()
```

返回C_n的独立生成器数目

```py
cartan_matrix()
```

C_n的Cartan矩阵

李代数的Cartan矩阵由简单根（alpha[1], …, alpha[l]）的顺序分配生成。然后Cartan矩阵的ij项是(<alpha[i],alpha[j]>).

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('C4')
>>> c.cartan_matrix()
Matrix([
[ 2, -1,  0,  0],
[-1,  2, -1,  0],
[ 0, -1,  2, -1],
[ 0,  0, -2,  2]]) 
```

```py
dimension()
```

李代数V的基础空间V的维数

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("C3")
>>> c.dimension()
3 
```

```py
lie_algebra()
```

返回与C_n相关联的李代数”

```py
positive_roots()
```

生成A_n的所有正根

这是C_n所有根的一半；通过将所有正根乘以-1我们得到负根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回C_n的总根数”

```py
simple_root(i)
```

C系列的第i个简单根

每个李代数都有一个独特的根系。给定一个根系Q，存在根的子集，称为简单根，如果它不能被写成Q中两个元素的和。如果我们让D表示简单根集合，则显然Q中的每个元素都可以被D的元素的非负系数线性组合表示。

在C_n中，前n-1个简单根与A_(n-1)中的根相同（第i个位置为1，第(i+1)个位置为-1，其他位置为零）。第n个简单根是第n位置为2，其他位置为零的根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("C3")
>>> c.simple_root(2)
[0, 1, -1] 
```

```py
class sympy.liealgebras.type_d.TypeD(n)
```

```py
basic_root(i, j)
```

这是一种只生成第i个位置为1，第j个位置为-1的根的方法。

```py
basis()
```

返回D_n的独立生成元的数量。

```py
cartan_matrix()
```

返回D_n的Cartan矩阵。李代数的Cartan矩阵由简单根（alpha[1], …, alpha[l]）的顺序分配生成。然后Cartan矩阵的ij项是(<alpha[i],alpha[j]>).

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('D4')
>>> c.cartan_matrix()
 Matrix([
 [ 2, -1,  0,  0],
 [-1,  2, -1, -1],
 [ 0, -1,  2,  0],
 [ 0, -1,  0,  2]]) 
```

```py
dimension()
```

李代数V的基础空间V的维数

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("D4")
>>> c.dimension()
4 
```

```py
lie_algebra()
```

返回与D_n相关联的李代数”

```py
positive_roots()
```

这种方法生成A_n的所有正根。这是D_n所有根的一半，通过将所有正根乘以-1我们得到负根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回D_n的总根数”

```py
simple_root(i)
```

每个李代数都有一个独特的根系。给定一个根系Q，存在根的子集，称为简单根，如果它不能被写成Q中两个元素的和。如果我们让D表示简单根集合，则显然Q中的每个元素都可以被D的元素的非负系数线性组合表示。

在D_n中，前n-1个简单根与A_(n-1)中的根相同（第i个位置为1，第(i+1)个位置为-1，其他位置为零）。第n个简单根是第n和(n-1)位置为1，其他位置为零的根。

这种方法返回D系列的第i个简单根。

示例

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("D4")
>>> c.simple_root(2)
[0, 1, -1, 0] 
```

```py
class sympy.liealgebras.type_e.TypeE(n)
```

```py
basic_root(i, j)
```

这是一种只生成第i个位置为-1，第j个位置为1的根的方法。

```py
basis()
```

返回E_n的独立生成元的数量。

```py
cartan_matrix()
```

返回G_2的Cartan矩阵。李代数的Cartan矩阵由简单根（alpha[1], …, alpha[l]）的顺序分配生成。然后Cartan矩阵的ij项是(<alpha[i],alpha[j]>).

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('A4')
>>> c.cartan_matrix()
Matrix([
[ 2, -1,  0,  0],
[-1,  2, -1,  0],
[ 0, -1,  2, -1],
[ 0,  0, -1,  2]]) 
```

```py
dimension()
```

向量空间 V 的维数作为李代数的基础

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("E6")
>>> c.dimension()
8 
```

```py
positive_roots()
```

此方法生成 A_n 的所有正根。这是 E_n 所有根的一半；通过将所有正根乘以 -1，我们得到负根。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回 E_n 的根的总数

```py
simple_root(i)
```

每个李代数都有一个唯一的根系。给定一个根系 Q，存在一个子集合使得 Q 中的一个元素被称为简单根，如果它不能被 Q 中的两个元素之和表示。如果我们让 D 表示简单根的集合，则很明显 Q 中的每个元素都可以用 D 中元素的线性组合表示，而且所有系数都是非负的。

此方法返回 E_n 的第 i 个简单根。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("E6")
>>> c.simple_root(2)
[1, 1, 0, 0, 0, 0, 0, 0] 
```

```py
class sympy.liealgebras.type_f.TypeF(n)
```

```py
basic_root(i, j)
```

在第 i 个位置为 1 和第 j 个位置为 -1 的根

```py
basis()
```

返回 F_4 的独立生成器数目

```py
cartan_matrix()
```

F_4 的 Cartan 矩阵

对于一个李代数的 Cartan 矩阵是通过为简单根分配一个顺序生成的，(alpha[1], …., alpha[l])。然后 Cartan 矩阵的 ij 元素是 (<alpha[i],alpha[j]>).

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType('A4')
>>> c.cartan_matrix()
Matrix([
[ 2, -1,  0,  0],
[-1,  2, -1,  0],
[ 0, -1,  2, -1],
[ 0,  0, -1,  2]]) 
```

```py
dimension()
```

向量空间 V 的维数作为李代数的基础

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("F4")
>>> c.dimension()
4 
```

```py
positive_roots()
```

生成 A_n 的所有正根

这是 F_4 所有根的一半；通过将所有正根乘以 -1，我们得到负根。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回 F_4 的根的总数

```py
simple_root(i)
```

F_4 的第 i 个简单根

每个李代数都有一个唯一的根系。给定一个根系 Q，存在一个子集合使得 Q 中的一个元素被称为简单根，如果它不能被 Q 中的两个元素之和表示。如果我们让 D 表示简单根的集合，则很明显 Q 中的每个元素都可以用 D 中元素的线性组合表示，而且所有系数都是非负的。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("F4")
>>> c.simple_root(3)
[0, 0, 0, 1] 
```

```py
class sympy.liealgebras.type_g.TypeG(n)
```

```py
basis()
```

返回 G_2 的独立生成器数目

```py
cartan_matrix()
```

G_2 的 Cartan 矩阵

对于一个李代数的 Cartan 矩阵是通过为简单根分配一个顺序生成的，(alpha[1], …., alpha[l])。然后 Cartan 矩阵的 ij 元素是 (<alpha[i],alpha[j]>).

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("G2")
>>> c.cartan_matrix()
Matrix([
 [ 2, -1],
 [-3,  2]]) 
```

```py
dimension()
```

向量空间 V 的维数作为李代数的基础

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("G2")
>>> c.dimension()
3 
```

```py
positive_roots()
```

生成 A_n 的所有正根

这是 A_n 所有根的一半；通过将所有正根乘以 -1，我们得到负根。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("A3")
>>> c.positive_roots()
{1: [1, -1, 0, 0], 2: [1, 0, -1, 0], 3: [1, 0, 0, -1], 4: [0, 1, -1, 0],
 5: [0, 1, 0, -1], 6: [0, 0, 1, -1]} 
```

```py
roots()
```

返回 G_2 的根的总数”

```py
simple_root(i)
```

G_2 的第 i 个简单根

每个李代数都有一个唯一的根系。给定一个根系 Q，存在一个子集合使得 Q 中的一个元素被称为简单根，如果它不能被 Q 中的两个元素之和表示。如果我们让 D 表示简单根的集合，则很明显 Q 中的每个元素都可以用 D 中元素的线性组合表示，而且所有系数都是非负的。

例子

```py
>>> from sympy.liealgebras.cartan_type import CartanType
>>> c = CartanType("G2")
>>> c.simple_root(1)
[0, 1, -1] 
```

```py
class sympy.liealgebras.weyl_group.WeylGroup(cartantype)
```

对于每个半单Lie群，我们有一个Weyl群。它是根系的等距群的子群。具体而言，它是通过与根正交的超平面的反射生成的子群。因此，Weyl群是反射群，因此Weyl群是有限Coxeter群的一种。

```py
coxeter_diagram()
```

此方法返回与Weyl群对应的Coxeter图。通过从李代数的Dynkin图中删除所有箭头可以获得Coxeter图；Coxeter图是无向图。Coxeter图的顶点表示Weyl群的生成反射，\(s_i\)。如果\(s_i\)和\(s_j\)的顺序\(m(i, j)\)大于2，则两者之间会有一条边。如果有一条边，则顺序\(m(i, j)\)为3。如果有两条边，则顺序\(m(i, j)\)为4，如果有三条边，则顺序\(m(i, j)\)为6。

例子

```py
>>> from sympy.liealgebras.weyl_group import WeylGroup
>>> c = WeylGroup("B3")
>>> print(c.coxeter_diagram())
0---0===0
1   2   3 
```

```py
delete_doubles(reflections)
```

这是确定G2的Weyl群中元素顺序的辅助方法。它接受一个Weyl元素，并删除其中的重复简单反射。

```py
element_order(weylelt)
```

此方法返回给定Weyl群元素的顺序，用户应以生成反射的形式指定，即形如r1*r2等。

对于类型A-F，此方法当前通过获取指定元素的矩阵形式，并找到该矩阵的幂等于单位矩阵。然后返回这个幂。

例子

```py
>>> from sympy.liealgebras.weyl_group import WeylGroup
>>> b = WeylGroup("B4")
>>> b.element_order('r1*r4*r2')
4 
```

```py
generators()
```

此方法为给定李代数创建Weyl群的生成反射。对于秩为n的李代数，有n个不同的生成反射。此函数将它们作为列表返回。

例子

```py
>>> from sympy.liealgebras.weyl_group import WeylGroup
>>> c = WeylGroup("F4")
>>> c.generators()
['r1', 'r2', 'r3', 'r4'] 
```

```py
group_name()
```

此方法返回给定李代数的Weyl群的一些一般信息。它返回群的名称及其作用的元素（如果相关）。

```py
group_order()
```

此方法返回Weyl群的顺序。对于类型A、B、C、D和E，顺序取决于李代数的秩。对于类型F和G，顺序是固定的。

例子

```py
>>> from sympy.liealgebras.weyl_group import WeylGroup
>>> c = WeylGroup("D4")
>>> c.group_order()
192.0 
```

```py
matrix_form(weylelt)
```

此方法接受用户以生成反射的形式的输入，并返回对应于Weyl群元素的矩阵。由于Weyl群的每个元素都是某种类型的反射，因此有对应的矩阵表示。此方法使用所有生成反射的标准表示。

例子

```py
>>> from sympy.liealgebras.weyl_group import WeylGroup
>>> f = WeylGroup("F4")
>>> f.matrix_form('r2*r3')
Matrix([
[1, 0, 0,  0],
[0, 1, 0,  0],
[0, 0, 0, -1],
[0, 0, 1,  0]]) 
```

```py
class sympy.liealgebras.cartan_type.CartanType_generator
```

实际创建事物的构造函数

```py
class sympy.liealgebras.cartan_type.Standard_Cartan(series, n)
```

Cartan类型的具体基类，如A4等

```py
rank()
```

返回李代数的秩

```py
series()
```

返回李代数的类型

```py
sympy.liealgebras.dynkin_diagram.DynkinDiagram(t)
```

显示给定李代数的Dynkin图

通过生成输入t的CartanType来工作，然后从各个类中返回Dynkin图方法。

例子

```py
>>> from sympy.liealgebras.dynkin_diagram import DynkinDiagram
>>> print(DynkinDiagram("A3"))
0---0---0
1   2   3 
```

```py
>>> print(DynkinDiagram("B4"))
0---0---0=>=0
1   2   3   4 
```

```py
sympy.liealgebras.cartan_matrix.CartanMatrix(ct)
```

访问特定李代数的Cartan矩阵

例子

```py
>>> from sympy.liealgebras.cartan_matrix import CartanMatrix
>>> CartanMatrix("A2")
Matrix([
[ 2, -1],
[-1,  2]]) 
```

```py
>>> CartanMatrix(['C', 3])
Matrix([
[ 2, -1,  0],
[-1,  2, -1],
[ 0, -2,  2]]) 
```

此方法通过返回对应于Cartan类型t的Cartan矩阵来工作。
