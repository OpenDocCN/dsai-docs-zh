- en: numpy.cov
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.cov.html](https://numpy.org/doc/1.26/reference/generated/numpy.cov.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Estimate a covariance matrix, given data and weights.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance indicates the level to which two variables vary together. If we examine
    N-dimensional samples, \(X = [x_1, x_2, ... x_N]^T\), then the covariance matrix
    element \(C_{ij}\) is the covariance of \(x_i\) and \(x_j\). The element \(C_{ii}\)
    is the variance of \(x_i\).
  prefs: []
  type: TYPE_NORMAL
- en: See the notes for an outline of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**m**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: A 1-D or 2-D array containing multiple variables and observations. Each row
    of *m* represents a variable, and each column a single observation of all those
    variables. Also see *rowvar* below.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: An additional set of variables and observations. *y* has the same form as that
    of *m*.
  prefs: []
  type: TYPE_NORMAL
- en: '**rowvar**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *rowvar* is True (default), then each row represents a variable, with observations
    in the columns. Otherwise, the relationship is transposed: each column represents
    a variable, while the rows contain observations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**bias**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Default normalization (False) is by `(N - 1)`, where `N` is the number of observations
    given (unbiased estimate). If *bias* is True, then normalization is by `N`. These
    values can be overridden by using the keyword `ddof` in numpy versions >= 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: '**ddof**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If not `None` the default value implied by *bias* is overridden. Note that `ddof=1`
    will return the unbiased estimate, even if both *fweights* and *aweights* are
    specified, and `ddof=0` will return the simple average. See the notes for the
    details. The default value is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: '**fweights**array_like, int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D array of integer frequency weights; the number of times each observation
    vector should be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.
  prefs: []
  type: TYPE_NORMAL
- en: '**aweights**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D array of observation vector weights. These relative weights are typically
    large for observations considered “important” and smaller for observations considered
    less “important”. If `ddof=0` the array of weights can be used to assign probabilities
    to observation vectors.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**data-type, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Data-type of the result. By default, the return data-type will have at least
    [`numpy.float64`](../arrays.scalars.html#numpy.float64 "numpy.float64") precision.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The covariance matrix of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`corrcoef`](numpy.corrcoef.html#numpy.corrcoef "numpy.corrcoef")'
  prefs: []
  type: TYPE_NORMAL
- en: Normalized covariance matrix
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the observations are in the columns of the observation array *m*
    and let `f = fweights` and `a = aweights` for brevity. The steps to compute the
    weighted covariance are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that when `a == 1`, the normalization factor `v1 / (v1**2 - ddof * v2)`
    goes over to `1 / (np.sum(f) - ddof)` as it should.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider two variables, \(x_0\) and \(x_1\), which correlate perfectly, but
    in opposite directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how \(x_0\) increases while \(x_1\) decreases. The covariance matrix shows
    this clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that element \(C_{0,1}\), which shows the correlation between \(x_0\) and
    \(x_1\), is negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, note how *x* and *y* are combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
