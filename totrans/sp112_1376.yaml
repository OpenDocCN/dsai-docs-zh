- en: scipy.stats.sobol_indices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.sobol_indices.html#scipy.stats.sobol_indices](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.sobol_indices.html#scipy.stats.sobol_indices)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Global sensitivity indices of Sobol’.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable or dict(str, array_like)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *func* is a callable, function to compute the Sobol’ indices from. Its signature
    must be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'with `x` of shape `(d, n)` and output of shape `(s, n)` where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d` is the input dimensionality of *func* (number of input variables),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` is the output dimensionality of *func* (number of output variables), and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` is the number of samples (see *n* below).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function evaluation values must be finite.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *func* is a dictionary, contains the function evaluations from three different
    arrays. Keys must be: `f_A`, `f_B` and `f_AB`. `f_A` and `f_B` should have a shape
    `(s, n)` and `f_AB` should have a shape `(d, s, n)`. This is an advanced feature
    and misuse can lead to wrong analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**n**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of samples used to generate the matrices `A` and `B`. Must be a power
    of 2\. The total number of points at which *func* is evaluated will be `n*(d+2)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**dists**list(distributions), optional'
  prefs: []
  type: TYPE_NORMAL
- en: List of each parameter’s distribution. The distribution of parameters depends
    on the application and should be carefully chosen. Parameters are assumed to be
    independently distributed, meaning there is no constraint nor relationship between
    their values.
  prefs: []
  type: TYPE_NORMAL
- en: Distributions must be an instance of a class with a `ppf` method.
  prefs: []
  type: TYPE_NORMAL
- en: Must be specified if *func* is a callable, and ignored otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**Callable or str, default: ‘saltelli_2010’'
  prefs: []
  type: TYPE_NORMAL
- en: Method used to compute the first and total Sobol’ indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a callable, its signature must be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: with `f_A, f_B` of shape `(s, n)` and `f_AB` of shape `(d, s, n)`. These arrays
    contain the function evaluations from three different sets of samples. The output
    is a tuple of the first and total indices with shape `(s, d)`. This is an advanced
    feature and misuse can lead to wrong analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**random_state**{None, int, [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)")}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *random_state* is an int or None, a new [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)") is created using `np.random.default_rng(random_state)`.
    If *random_state* is already a `Generator` instance, then the provided instance
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**res**SobolResult'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: first_orderndarray of shape (s, d)
  prefs: []
  type: TYPE_NORMAL
- en: First order Sobol’ indices.
  prefs: []
  type: TYPE_NORMAL
- en: total_orderndarray of shape (s, d)
  prefs: []
  type: TYPE_NORMAL
- en: Total order Sobol’ indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'And method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bootstrap(confidence_level: float, n_resamples: int) -> BootstrapSobolResult'
  prefs: []
  type: TYPE_NORMAL
- en: A method providing confidence intervals on the indices. See [`scipy.stats.bootstrap`](scipy.stats.bootstrap.html#scipy.stats.bootstrap
    "scipy.stats.bootstrap") for more details.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The bootstrapping is done on both first and total order indices, and they are
    available in *BootstrapSobolResult* as attributes `first_order` and `total_order`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The Sobol’ method [[1]](#rb9e0fd5192f6-1), [[2]](#rb9e0fd5192f6-2) is a variance-based
    Sensitivity Analysis which obtains the contribution of each parameter to the variance
    of the quantities of interest (QoIs; i.e., the outputs of *func*). Respective
    contributions can be used to rank the parameters and also gauge the complexity
    of the model by computing the model’s effective (or mean) dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are assumed to be independently distributed. Each parameter can still
    follow any distribution. In fact, the distribution is very important and should
    match the real distribution of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: It uses a functional decomposition of the variance of the function to explore
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbb{V}(Y) = \sum_{i}^{d} \mathbb{V}_i (Y) + \sum_{i<j}^{d} \mathbb{V}_{ij}(Y)
    + ... + \mathbb{V}_{1,2,...,d}(Y),\]
  prefs: []
  type: TYPE_NORMAL
- en: 'introducing conditional variances:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbb{V}_i(Y) = \mathbb{\mathbb{V}}[\mathbb{E}(Y|x_i)] \qquad \mathbb{V}_{ij}(Y)
    = \mathbb{\mathbb{V}}[\mathbb{E}(Y|x_i x_j)] - \mathbb{V}_i(Y) - \mathbb{V}_j(Y),\]
  prefs: []
  type: TYPE_NORMAL
- en: Sobol’ indices are expressed as
  prefs: []
  type: TYPE_NORMAL
- en: \[S_i = \frac{\mathbb{V}_i(Y)}{\mathbb{V}[Y]} \qquad S_{ij} =\frac{\mathbb{V}_{ij}(Y)}{\mathbb{V}[Y]}.\]
  prefs: []
  type: TYPE_NORMAL
- en: \(S_{i}\) corresponds to the first-order term which apprises the contribution
    of the i-th parameter, while \(S_{ij}\) corresponds to the second-order term which
    informs about the contribution of interactions between the i-th and the j-th parameters.
    These equations can be generalized to compute higher order terms; however, they
    are expensive to compute and their interpretation is complex. This is why only
    first order indices are provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Total order indices represent the global contribution of the parameters to
    the variance of the QoI and are defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[S_{T_i} = S_i + \sum_j S_{ij} + \sum_{j,k} S_{ijk} + ... = 1 - \frac{\mathbb{V}[\mathbb{E}(Y|x_{\sim
    i})]}{\mathbb{V}[Y]}.\]
  prefs: []
  type: TYPE_NORMAL
- en: First order indices sum to at most 1, while total order indices sum to at least
    1\. If there are no interactions, then first and total order indices are equal,
    and both first and total order indices sum to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Negative Sobol’ values are due to numerical errors. Increasing the number of
    points *n* should help.
  prefs: []
  type: TYPE_NORMAL
- en: The number of sample required to have a good analysis increases with the dimensionality
    of the problem. e.g. for a 3 dimension problem, consider at minima `n >= 2**12`.
    The more complex the model is, the more samples will be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Even for a purely addiditive model, the indices may not sum to 1 due to numerical
    noise.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Sobol, I. M.. “Sensitivity analysis for nonlinear mathematical models.” Mathematical
    Modeling and Computational Experiment, 1:407-414, 1993.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: Sobol, I. M. (2001). “Global sensitivity indices for nonlinear mathematical
    models and their Monte Carlo estimates.” Mathematics and Computers in Simulation,
    55(1-3):271-280, [DOI:10.1016/S0378-4754(00)00270-6](https://doi.org/10.1016/S0378-4754(00)00270-6),
    2001.
  prefs: []
  type: TYPE_NORMAL
- en: '[3]'
  prefs: []
  type: TYPE_NORMAL
- en: Saltelli, A. “Making best use of model evaluations to compute sensitivity indices.”
    Computer Physics Communications, 145(2):280-297, [DOI:10.1016/S0010-4655(02)00280-1](https://doi.org/10.1016/S0010-4655(02)00280-1),
    2002.
  prefs: []
  type: TYPE_NORMAL
- en: '[4]'
  prefs: []
  type: TYPE_NORMAL
- en: Saltelli, A., M. Ratto, T. Andres, F. Campolongo, J. Cariboni, D. Gatelli, M.
    Saisana, and S. Tarantola. “Global Sensitivity Analysis. The Primer.” 2007.
  prefs: []
  type: TYPE_NORMAL
- en: '[5]'
  prefs: []
  type: TYPE_NORMAL
- en: Saltelli, A., P. Annoni, I. Azzini, F. Campolongo, M. Ratto, and S. Tarantola.
    “Variance based sensitivity analysis of model output. Design and estimator for
    the total sensitivity index.” Computer Physics Communications, 181(2):259-270,
    [DOI:10.1016/j.cpc.2009.09.018](https://doi.org/10.1016/j.cpc.2009.09.018), 2010.
  prefs: []
  type: TYPE_NORMAL
- en: '[[6](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: Ishigami, T. and T. Homma. “An importance quantification technique in uncertainty
    analysis for computer models.” IEEE, [DOI:10.1109/ISUMA.1990.151285](https://doi.org/10.1109/ISUMA.1990.151285),
    1990.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example with the Ishigami function [[6]](#rb9e0fd5192f6-6)
  prefs: []
  type: TYPE_NORMAL
- en: \[Y(\mathbf{x}) = \sin x_1 + 7 \sin^2 x_2 + 0.1 x_3^4 \sin x_1,\]
  prefs: []
  type: TYPE_NORMAL
- en: with \(\mathbf{x} \in [-\pi, \pi]^3\). This function exhibits strong non-linearity
    and non-monotonicity.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Sobol’ indices assumes that samples are independently distributed.
    In this case we use a uniform distribution on each marginals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Confidence interval can be obtained using bootstrapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, this information can be easily visualized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-stats-sobol_indices-1_00_00.png](../Images/291f6063b24b024147b63e3f40cdf9be.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, [`scipy.stats.uniform`](scipy.stats.uniform.html#scipy.stats.uniform
    "scipy.stats.uniform") has support `[0, 1]`. Using the parameters `loc` and `scale`,
    one obtains the uniform distribution on `[loc, loc + scale]`.
  prefs: []
  type: TYPE_NORMAL
- en: This result is particularly interesting because the first order index \(S_{x_3}
    = 0\) whereas its total order is \(S_{T_{x_3}} = 0.244\). This means that higher
    order interactions with \(x_3\) are responsible for the difference. Almost 25%
    of the observed variance on the QoI is due to the correlations between \(x_3\)
    and \(x_1\), although \(x_3\) by itself has no impact on the QoI.
  prefs: []
  type: TYPE_NORMAL
- en: The following gives a visual explanation of Sobol’ indices on this function.
    Let’s generate 1024 samples in \([-\pi, \pi]^3\) and calculate the value of the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now we can do scatter plots of the output with respect to each parameter. This
    gives a visual way to understand how each parameter impacts the output of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-stats-sobol_indices-1_01_00.png](../Images/ad46e13f71a25e4066908b360bbd8aa3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now Sobol’ goes a step further: by conditioning the output value by given values
    of the parameter (black lines), the conditional output mean is computed. It corresponds
    to the term \(\mathbb{E}(Y|x_i)\). Taking the variance of this term gives the
    numerator of the Sobol’ indices.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-stats-sobol_indices-1_02_00.png](../Images/0f81b07187d4f86f658433234c43cb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at \(x_3\), the variance of the mean is zero leading to \(S_{x_3} =
    0\). But we can further observe that the variance of the output is not constant
    along the parameter values of \(x_3\). This heteroscedasticity is explained by
    higher order interactions. Moreover, an heteroscedasticity is also noticeable
    on \(x_1\) leading to an interaction between \(x_3\) and \(x_1\). On \(x_2\),
    the variance seems to be constant and thus null interaction with this parameter
    can be supposed.
  prefs: []
  type: TYPE_NORMAL
- en: This case is fairly simple to analyse visually—although it is only a qualitative
    analysis. Nevertheless, when the number of input parameters increases such analysis
    becomes unrealistic as it would be difficult to conclude on high-order terms.
    Hence the benefit of using Sobol’ indices.
  prefs: []
  type: TYPE_NORMAL
