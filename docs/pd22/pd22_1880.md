# pandas 文档字符串指南

> 原文：[`pandas.pydata.org/docs/development/contributing_docstring.html`](https://pandas.pydata.org/docs/development/contributing_docstring.html)

## 关于文档字符串和标准

Python 文档字符串是用于记录 Python 模块、类、函数或方法的字符串，以便程序员可以在不阅读实现细节的情况下了解其功能。

此外，从文档字符串自动生成在线（html）文档是一种常见做法。[Sphinx](https://www.sphinx-doc.org)用于此目的。

下一个示例展示了文档字符串的样式：

```py
def add(num1, num2):
  """
 Add up two integer numbers.

 This function simply wraps the ``+`` operator, and does not
 do anything interesting, except for illustrating what
 the docstring of a very simple function looks like.

 Parameters
 ----------
 num1 : int
 First number to add.
 num2 : int
 Second number to add.

 Returns
 -------
 int
 The sum of ``num1`` and ``num2``.

 See Also
 --------
 subtract : Subtract one integer from another.

 Examples
 --------
 >>> add(2, 2)
 4
 >>> add(25, 0)
 25
 >>> add(10, -10)
 0
 """
    return num1 + num2 
```

存在一些关于文档字符串的标准，使它们更易阅读，并允许它们轻松导出到其他格式，如 html 或 pdf。

每个 Python 文档字符串应遵循的第一个约定在[PEP-257](https://www.python.org/dev/peps/pep-0257/)中定义。

由于 PEP-257 相当广泛，还存在其他更具体的标准。在 pandas 的情况下，遵循 NumPy 文档字符串约定。这些约定在本文档中有解释：

+   [numpydoc 文档字符串指南](https://numpydoc.readthedocs.io/en/latest/format.html)

numpydoc 是一个支持 NumPy 文档字符串约定的 Sphinx 扩展。

该标准使用 reStructuredText（reST）。reStructuredText 是一种标记语言，允许在纯文本文件中编码样式。关于 reStructuredText 的文档可以在以下找到：

+   [Sphinx reStructuredText 入门](https://www.sphinx-doc.org/en/stable/rest.html)

+   [快速 reStructuredText 参考](https://docutils.sourceforge.io/docs/user/rst/quickref.html)

+   [完整的 reStructuredText 规范](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html)

pandas 有一些辅助功能，用于在相关类之间共享文档字符串，请参见共享文档字符串。

本文的其余部分将总结上述所有准则，并提供特定于 pandas 项目的其他约定。

## 编写文档字符串

### 一般规则

文档字符串必须用三个双引号定义。在文档字符串之前或之后不应留下空行。文本从开头引号的下一行开始。结束引号有自己的一行（这意味着它们不在最后一句的末尾）。

在罕见情况下，文档字符串中会使用 reST 样式，如粗体文本或斜体文本，但常见的是内联代码，用反引号括起来。以下被视为内联代码：

+   参数的名称

+   Python 代码，模块，函数，内置，类型，文字…（例如`os`，`list`，`numpy.abs`，`datetime.date`，`True`）

+   一个 pandas 类（形式为`:class:`pandas.Series``）

+   一个 pandas 方法（形式为`:meth:`pandas.Series.sum``）

+   一个 pandas 函数（形式为`:func:`pandas.to_datetime``）

注意

要仅显示链接类、方法或函数的最后一个组件，请在其前面加上`~`。例如，`:class:`~pandas.Series``将链接到`pandas.Series`，但只显示最后部分`Series`作为链接文本。有关详细信息，请参阅[Sphinx 交叉引用语法](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)。

**好的：**

```py
def add_values(arr):
  """
 Add the values in ``arr``.

 This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.

 Some sections are omitted here for simplicity.
 """
    return sum(arr) 
```

**不好的：**

```py
def func():

  """Some function.

 With several mistakes in the docstring.

 It has a blank like after the signature ``def func():``.

 The text 'Some function' should go in the line after the
 opening quotes of the docstring, not in the same line.

 There is a blank line between the docstring and the first line
 of code ``foo = 1``.

 The closing quotes should be in the next line, not in this one."""

    foo = 1
    bar = 2
    return foo + bar 
```  ### 第 1 节：简短摘要

简短摘要是一个简洁表达函数功能的单个句子。

简短摘要必须以大写字���开头，以句点结束，并适合在一行内。它需要表达对象的功能，而不提供详细信息。对于函数和方法，简短摘要必须以不定式动词开头。

**好的：**

```py
def astype(dtype):
  """
 Cast Series type.

 This section will provide further details.
 """
    pass 
```

**不好的：**

```py
def astype(dtype):
  """
 Casts Series type.

 Verb in third-person of the present simple, should be infinitive.
 """
    pass 
```

```py
def astype(dtype):
  """
 Method to cast Series type.

 Does not start with verb.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type

 Missing dot at the end.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type from its current type to the new type defined in
 the parameter dtype.

 Summary is too verbose and doesn't fit in a single line.
 """
    pass 
```  ### 第 2 节：扩展摘要

扩展摘要提供了函数的详细信息。它不应该详细说明参数，或讨论实现注意事项，这些应该在其他部分中说明。

简短摘要和扩展摘要之间留有一个空行。扩展摘要中的每个段落都以句点结束。

扩展摘要应提供函数的用途及其用例的详细信息，如果不太通用的话。

```py
def unstack():
  """
 Pivot a row index to columns.

 When using a MultiIndex, a level can be pivoted so each value in
 the index becomes a column. This is especially useful when a subindex
 is repeated for the main index, and data is easier to visualize as a
 pivot table.

 The index level will be automatically removed from the index when added
 as columns.
 """
    pass 
```  ### 第 3 节：参数

参数的详细信息将添加在此部分。此部分的标题为“参数”，下面是一个以“参数”每个字母下面的连字符为分隔的线。在部分标题之前留有一个空行，但之后不留空行，也不在“参数”一词下面的线和连字符之间留空行。

在标题之后，必须记录签名中的每个参数，包括`*args`和`**kwargs`，但不包括`self`。

参数由其名称定义，后面跟着一个空格，一个冒号，另一个空格，以及类型（或类型）。请注意名称和冒号之间的空格很重要。对于`*args`和`**kwargs`不定义类型，但对于所有其他参数必须定义类型。在参数定义之后，需要有一个带缩进的参数描述行，可以有多行。描述必须以大写字母开头，并以句点结束。

对于带有默认值的关键字参数，类型后面会列出默认值，具体形式为“int, default 0”。在某些情况下，解释默认参数的含义可能很有用，可以在逗号后面添加“int, default -1，表示所有 cpu”。

在默认值为 `None` 的情况下，意味着该值不会被使用。与 `"str, default None"` 不同，更倾向于写成 `"str, optional"`。当 `None` 是被使用的值时，我们将保持`"str, default None"`形式。例如，在 `df.to_csv(compression=None)` 中，`None` 不是被使用的值，而是表示压缩是可选的，如果未提供，则不使用压缩。在这种情况下，我们将使用 `"str, optional"`。仅在类似 `func(value=None)` 和 `None` 被使用与 `0` 或 `foo` 相同的方式时，我们将指定“str, int or None, default None”。

**好：**

```py
class Series:
    def plot(self, kind, color='blue', **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Parameters
 ----------
 kind : str
 Kind of matplotlib plot.
 color : str, default 'blue'
 Color name or rgb code.
 **kwargs
 These parameters will be passed to the matplotlib plotting
 function.
 """
        pass 
```

**不好：**

```py
class Series:
    def plot(self, kind, **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Note the blank line between the parameters title and the first
 parameter. Also, note that after the name of the parameter ``kind``
 and before the colon, a space is missing.

 Also, note that the parameter descriptions do not start with a
 capital letter, and do not finish with a dot.

 Finally, the ``**kwargs`` parameter is missing.

 Parameters
 ----------

 kind: str
 kind of matplotlib plot
 """
        pass 
```

#### 参数类型

在指定参数类型时，可以直接使用 Python 内置数据类型（优选使用 Python 类型，而不是更冗长的字符串、整数、布尔值等）：

+   int

+   float

+   str

+   bool

对于复杂类型，定义子类型。对于 `dict` 和 `tuple`，由于存在多种类型，我们使用括号来帮助阅读类型（花括号用于 `dict`，普通括号用于 `tuple`）：

+   int 列表

+   {str : int} 字典

+   (str, int, int) 元组

+   (str,) 元组

+   set of str

如果只允许一组值，则用花括号将它们列出，并用逗号（后跟一个空格）分隔。如果值是有序的并且有顺序，请按此顺序列出。否则，如果有默认值，请先列出默认值：

+   {0, 10, 25}

+   {‘simple’, ‘advanced’}

+   {‘low’, ‘medium’, ‘high’}

+   {‘cat’, ‘dog’, ‘bird’}

如果类型在 Python 模块中定义，则必须指定模块：

+   datetime.date

+   datetime.datetime

+   decimal.Decimal

如果类型在包中，则还必须指定模块：

+   numpy.ndarray

+   scipy.sparse.coo_matrix

如果类型是 pandas 类型，则除了 Series 和 DataFrame 外，还要指定 pandas：

+   Series

+   DataFrame

+   pandas.Index

+   pandas.Categorical

+   pandas.arrays.SparseArray

如果确切类型不重要，但必须与 NumPy 数组兼容，则可以指定类似数组。如果接受任何可迭代的类型，则可使用 iterable：

+   array-like

+   iterable

如果接受多种类型，则用逗号分隔它们，除了最后两种类型，它们需要用‘or’分隔：

+   int 或 float

+   float, decimal.Decimal 或 None

+   str 或 str 列表

如果 `None` 是可接受的值之一，则始终需要将其列为列表的最后一项。

对于轴，惯例是使用类似以下的内容：

+   axis : {0 or ‘index’, 1 or ‘columns’, None}, 默认为 None  ### Section 4: returns or yields

如果方法返回一个值，将在此部分中记录它。如果方法输出其输出，则也会记录在这里。

与“参数”相同的方式定义部分的标题。以“Returns”或“Yields”为名称，后跟一行连字符，连字符数量与前一个单词中的字母数量相同。

返回值的文档也与参数类似。但在这种情况下，除非方法返回或产生多个值（值的元组），否则不会提供名称。

“Returns”和“Yields”的类型与“Parameters”的类型相同。此外，描述必须以句点结束。

举例来说，对于单个数值：

```py
def sample():
  """
 Generate and return a random number.

 The value is sampled from a continuous uniform distribution between
 0 and 1.

 Returns
 -------
 float
 Random number generated.
 """
    return np.random.random() 
```

对于多个数值：

```py
import string

def random_letters():
  """
 Generate and return a sequence of random letters.

 The length of the returned string is also random, and is also
 returned.

 Returns
 -------
 length : int
 Length of the returned string.
 letters : str
 String of random letters.
 """
    length = np.random.randint(1, 10)
    letters = ''.join(np.random.choice(string.ascii_lowercase)
                      for i in range(length))
    return length, letters 
```

如果该方法产生其值：

```py
def sample_values():
  """
 Generate an infinite sequence of random numbers.

 The values are sampled from a continuous uniform distribution between
 0 and 1.

 Yields
 ------
 float
 Random number generated.
 """
    while True:
        yield np.random.random() 
```  ### Section 5: see also

此部分用于让用户了解与所记录的功能相关的 pandas 功能。在极少数情况下，如果找不到任何相关方法或函数，可以跳过此部分。

一个明显的例子是 `head()` 和 `tail()` 方法。因为 `tail()` 在 `Series` 或 `DataFrame` 的末尾执行与 `head()` 类似的操作，而不是在开头，所以最好让用户知道这一点。

为了直观地了解什么可以被视为相关的，这里有一些例子：

+   `loc` 和 `iloc`，因为它们做的是相同的事情，但在一个情况下提供索引，在另一个情况下提供位置。

+   `max` 和 `min`，因为它们相反操作。

+   `iterrows`，`itertuples` 和 `items`，因为一个用户要查找遍历列的方法很容易最终找到遍历行的方法，反之亦然。

+   `fillna` 和 `dropna`，因为这两种方法都用于处理缺失值。

+   `read_csv` 和 `to_csv`，因为它们是互补的。

+   `merge` 和 `join`，因为一个是另一个的概括。

+   `astype` 和 `pandas.to_datetime`，因为用户可能正在阅读 `astype` 的文档以了解如何转换为日期，而转换方法是使用 `pandas.to_datetime`。

+   `where` 与 `numpy.where` 相关，因为其功能是基于它的。

在决定相关内容时，您应该主要凭借常识，并考虑对于阅读文档的用户来说什么可能有用，特别是对于经验较少的用户。

当与其他库（主要是 `numpy`）相关时，首先使用模块的名称（而不是别名，如 `np`）。如果函数位于不是主要的模块中，比如 `scipy.sparse`，则列出完整的模块（例如 `scipy.sparse.coo_matrix`）。

这个部分有一个标题，“See Also”（注意大写的 S 和 A），后面跟着由破折号构成的一行，并且前面有一个空行。

在标题之后，我们将为每个相关方法或函数添加一行，后跟一个空格、一个冒号、另一个空格和一个简短的描述，说明这个方法或函数做什么，在这个上下文中为什么是相关的，以及所记录的函数与被引用的函数之间的关键区别是什么。描述还必须以句点结束。

请注意在“Returns”和“Yields”中，描述位于类型之后的一行上。然而，在这个部分中，它位于同一行上，中间用冒号分隔。如果描述不适合在同一行上，则可以继续到其他必须进一步缩进的行上。

例如：

```py
class Series:
    def head(self):
  """
 Return the first 5 elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying the whole of it.

 Returns
 -------
 Series
 Subset of the original series with the 5 first values.

 See Also
 --------
 Series.tail : Return the last 5 elements of the Series.
 Series.iloc : Return a slice of the elements in the Series,
 which can also be used to return the first or last n.
 """
        return self.iloc[:5] 
```  ### Section 6: notes

这是一个可选部分，用于有关算法实现的注释，或者记录函数行为的技术方面。

如果您熟悉算法的实现，或者在编写函数示例时发现一些反直觉的行为，请随意跳过它。

本节遵循扩展摘要部分相同的格式。### 第 7 节：示例

这是文档字符串中最重要的部分之一，尽管它位于最后位置，因为人们通常通过示例而不是准确的解释更容易理解概念。

在文档字符串中的示例除了说明函数或方法的用法外，必须是有效的 Python 代码，以确定性方式返回给定输出，并且用户可以复制并运行。

示例以 Python 终端中的会话形式呈现。使用`>>>`来呈现代码。使用`...`表示从上一行继续的代码。输出立即在生成输出的最后一行代码之后呈现（中间没有空行）。可以在示例描述之前和之后添加空行以添加描述示例的注释。

展示示例的方式如下：

1.  导入所需的库（除了`numpy`和`pandas`）

1.  创建示例所需的数据

1.  展示一个非常基本的例子，给出最常见用例的概念

1.  添加带有说明的示例，说明参数如何用于扩展功能

一个简单的例子可能是：

```py
class Series:

    def head(self, n=5):
  """
 Return the first elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying all of it.

 Parameters
 ----------
 n : int
 Number of values to return.

 Return
 ------
 pandas.Series
 Subset of the original series with the n first values.

 See Also
 --------
 tail : Return the last n elements of the Series.

 Examples
 --------
 >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',
 ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])
 >>> ser.head()
 0   Ant
 1   Bear
 2   Cow
 3   Dog
 4   Falcon
 dtype: object

 With the ``n`` parameter, we can change the number of returned rows:

 >>> ser.head(n=3)
 0   Ant
 1   Bear
 2   Cow
 dtype: object
 """
        return self.iloc[:n] 
```

示例应尽可能简洁。在函数复杂性需要长示例的情况下，建议使用加粗标题的块。使用双星号`**`使文本加粗，就像`**这个例子**`中一样。

#### 示例的约定

示例中的代码始终假定以未显示的这两行开头：

```py
import numpy as np
import pandas as pd 
```

示例中使用的任何其他模块必须显式导入，每行一个（如[**PEP 8#imports**](https://peps.python.org/pep-0008/#imports)中建议的），避免使用别名。避免过多的导入，但如果需要，首先导入标准库，然后是第三方库（如 matplotlib）。

当使用单个`Series`进行示例说明时，请使用名称`ser`，如果使用单个`DataFrame`进行说明，请使用名称`df`。对于索引，首选名称为`idx`。如果使用一组同质的`Series`或`DataFrame`，请将它们命名为`ser1`、`ser2`、`ser3`...或`df1`、`df2`、`df3`... 如果数据不是同质的，并且需要多个结构，请使用有意义的名称命名它们，例如`df_main`和`df_to_join`。

示例中使用的数据应尽可能紧凑。建议行数约为 4 行，但应根据具体示例合理确定。例如，在`head`方法中，建议使用大于 5 的值，以显示具有默认值的示例。如果进行`mean`操作，我们可以使用类似`[1, 2, 3]`的数据，这样很容易看出返回的值是平均值。

对于更复杂的示例（例如分组），避免使用没有解释的数据，比如随机数字矩阵，列为 A、B、C、D…而是使用一个有意义的示例，这样更容易理解概念。除非示例要求，否则使用动物的名称，以保持示例一致。并且它们的数字属性。

调用方法时，关键字参数`head(n=3)`优先于位置参数`head(3)`。

**好：**

```py
class Series:

    def mean(self):
  """
 Compute the mean of the input.

 Examples
 --------
 >>> ser = pd.Series([1, 2, 3])
 >>> ser.mean()
 2
 """
        pass

    def fillna(self, value):
  """
 Replace missing values by ``value``.

 Examples
 --------
 >>> ser = pd.Series([1, np.nan, 3])
 >>> ser.fillna(0)
 [1, 0, 3]
 """
        pass

    def groupby_mean(self):
  """
 Group by index and return mean.

 Examples
 --------
 >>> ser = pd.Series([380., 370., 24., 26],
 ...               name='max_speed',
 ...               index=['falcon', 'falcon', 'parrot', 'parrot'])
 >>> ser.groupby_mean()
 index
 falcon    375.0
 parrot     25.0
 Name: max_speed, dtype: float64
 """
        pass

    def contains(self, pattern, case_sensitive=True, na=numpy.nan):
  """
 Return whether each value contains ``pattern``.

 In this case, we are illustrating how to use sections, even
 if the example is simple enough and does not require them.

 Examples
 --------
 >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)
 >>> ser.contains(pattern='a')
 0    False
 1    False
 2     True
 3      NaN
 dtype: bool

 **Case sensitivity**

 With ``case_sensitive`` set to ``False`` we can match ``a`` with both
 ``a`` and ``A``:

 >>> s.contains(pattern='a', case_sensitive=False)
 0     True
 1    False
 2     True
 3      NaN
 dtype: bool

 **Missing values**

 We can fill missing values in the output using the ``na`` parameter:

 >>> ser.contains(pattern='a', na=False)
 0    False
 1    False
 2     True
 3    False
 dtype: bool
 """
        pass 
```

**不好：**

```py
def method(foo=None, bar=None):
  """
 A sample DataFrame method.

 Do not import NumPy and pandas.

 Try to use meaningful data, when it makes the example easier
 to understand.

 Try to avoid positional arguments like in ``df.method(1)``. They
 can be all right if previously defined with a meaningful name,
 like in ``present_value(interest_rate)``, but avoid them otherwise.

 When presenting the behavior with different parameters, do not place
 all the calls one next to the other. Instead, add a short sentence
 explaining what the example shows.

 Examples
 --------
 >>> import numpy as np
 >>> import pandas as pd
 >>> df = pd.DataFrame(np.random.randn(3, 3),
 ...                   columns=('a', 'b', 'c'))
 >>> df.method(1)
 21
 >>> df.method(bar=14)
 123
 """
    pass 
```  #### 使示例通过 doctest 的提示

使示例通过验证脚本的 doctest 有时可能会有些棘手。以下是一些注意事项：

+   导入所有需要的库（除了 pandas 和 NumPy，它们已经作为`import pandas as pd`和`import numpy as np`导入）并定义你在示例中使用的所有变量。

+   尽量避免使用随机数据。然而，在某些情况下，随机数据可能是可以接受的，比如如果你正在记录的函数涉及概率分布，或者如果生成有意义的函数结果所需的数据量太大，手动创建会非常繁琐。在这些情况下，始终使用固定的随机种子使生成的示例可预测。例如：

    ```py
    >>> np.random.seed(42)
    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) 
    ```

+   如果你有一个跨越多行的代码片段，你需要在后续行上使用‘…’：

    ```py
    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],
    ...                   columns=['A', 'B']) 
    ```

+   如果你想展示出引发异常的情况，可以这样做：

    ```py
    >>> pd.to_datetime(["712-01-01"])
    Traceback (most recent call last):
    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 
    ```

    包含“Traceback（最近一次调用的最后）:”是必要的，但对于实际错误只需提供错误名称即可。

+   如果结果中有一小部分可能会变化（例如对象表示中的哈希），可以使用`...`表示此部分。

    如果你想要展示`s.plot()`返回一个 matplotlib AxesSubplot 对象，这将导致 doctest 失败。

    ```py
    >>> s.plot()
    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> 
    ```

    但是，你可以这样做（注意需要添加的注释）

    ```py
    >>> s.plot()  
    <matplotlib.axes._subplots.AxesSubplot at ...> 
    ```  #### 示例中的图表

pandas 中有一些返回图表的方法。为了渲染文档中示例生成的图表，存在`.. plot::`指令。

要使用它，请将下一个代码放在“示例”标题后面，如下所示。生成文档时，图表将自动生成。

```py
class Series:
    def plot(self):
  """
 Generate a plot with the ``Series`` data.

 Examples
 --------

 .. plot::
 :context: close-figs

 >>> ser = pd.Series([1, 2, 3])
 >>> ser.plot()
 """
        pass 
```  ## 共享文档字符串

pandas 有一个系统，可以在类之间共享文档字符串，稍有不同。这有助于我们保持文档字符串一致，同时为用户阅读保持清晰。在编写时会增加一些复杂性。

每个共享的文档字符串都会有一个基础模板和变量，比如`{klass}`。稍后使用`doc`装饰器填充变量。最后，文档字符串也可以使用`doc`装饰器追加。

在本示例中，我们将正常创建一个父文档字符串（这类似于`pandas.core.generic.NDFrame`）。然后我们将有两个子文档字符串（像`pandas.core.series.Series`和`pandas.core.frame.DataFrame`）。我们将在此文档字符串中替换类名。

```py
class Parent:
    @doc(klass="Parent")
    def my_function(self):
  """Apply my function to {klass}."""
        ...

class ChildA(Parent):
    @doc(Parent.my_function, klass="ChildA")
    def my_function(self):
        ...

class ChildB(Parent):
    @doc(Parent.my_function, klass="ChildB")
    def my_function(self):
        ... 
```

结果文档字符串为

```py
>>> print(Parent.my_function.__doc__)
Apply my function to Parent.
>>> print(ChildA.my_function.__doc__)
Apply my function to ChildA.
>>> print(ChildB.my_function.__doc__)
Apply my function to ChildB. 
```

注意：

1.  我们将父文档字符串“附加”到最初为空的子文档字符串上。

我们的文件通常会包含一个模块级别的`_shared_doc_kwargs`，其中包含一些常见的替换值（例如`klass`、`axes`等）。

您可以一次性进行替换和附加，例如

```py
@doc(template, **_shared_doc_kwargs)
def my_function(self):
    ... 
```

其中`template`可能来自模块级别的`_shared_docs`字典，将函数名称映射到文档字符串。在可能的情况下，我们更喜欢使用`doc`，因为文档字符串编写过程略微接近正常。

查看`pandas.core.generic.NDFrame.fillna`以获取一个示例模板，以及填充版本的`pandas.core.series.Series.fillna`和`pandas.core.generic.frame.fillna`。

## 关于文档字符串和标准

Python 文档字符串是用于记录 Python 模块、类、函数或方法的字符串，以便程序员可以了解其功能，而无需阅读实现细节。

此外，从文档字符串自动生成在线（html）文档是一种常见做法。[Sphinx](https://www.sphinx-doc.org)用于此目的。

下一个示例给出了文档字符串的外观：

```py
def add(num1, num2):
  """
 Add up two integer numbers.

 This function simply wraps the ``+`` operator, and does not
 do anything interesting, except for illustrating what
 the docstring of a very simple function looks like.

 Parameters
 ----------
 num1 : int
 First number to add.
 num2 : int
 Second number to add.

 Returns
 -------
 int
 The sum of ``num1`` and ``num2``.

 See Also
 --------
 subtract : Subtract one integer from another.

 Examples
 --------
 >>> add(2, 2)
 4
 >>> add(25, 0)
 25
 >>> add(10, -10)
 0
 """
    return num1 + num2 
```

存在一些关于文档字符串的标准，使它们更易于阅读，并允许它们轻松导出到其他格式，如 html 或 pdf。

每个 Python 文档字符串应遵循的第一个约定在[PEP-257](https://www.python.org/dev/peps/pep-0257/)中定义。

由于 PEP-257 相当广泛，还存在其他更具体的标准。在 pandas 的情况下，遵循 NumPy 文档字符串约定。这些约定在本文档中有解释：

+   [numpydoc 文档字符串指南](https://numpydoc.readthedocs.io/en/latest/format.html)

numpydoc 是一个支持 NumPy 文档字符串约定的 Sphinx 扩展。

标准使用 reStructuredText（reST）。reStructuredText 是一种标记语言，允许在纯文本文件中编码样式。关于 reStructuredText 的文档可以在以下找到：

+   [Sphinx reStructuredText 入门](https://www.sphinx-doc.org/en/stable/rest.html)

+   [快速 reStructuredText 参考](https://docutils.sourceforge.io/docs/user/rst/quickref.html)

+   [完整的 reStructuredText 规范](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html)

pandas 有一些辅助功能，用于在相关类之间共享文档字符串，请参阅共享文档字符串。

本文档的其余部分将总结上述所有准则，并提供特定于 pandas 项目的额外约定。

## 编写文档字符串

### 一般规则

文档字符串必须用三个双引号定义。在文档字符串之前或之后不应留下空行。文本从开头引号的下一行开始。结束引号有自己的一行（这意味着它们不在最后一句的末尾）。

在罕见的情况下，文档字符串中会使用 reST 样式，如粗体文本或斜体文本，但通常会使用内联代码，该代码位于反引号之间。以下内容被视为内联代码：

+   参数的名称

+   Python 代码，模块，函数，内置类型，字面值…（例如 `os`，`list`，`numpy.abs`，`datetime.date`，`True`）

+   一个 pandas 类（形式为 `:class:`pandas.Series``）

+   一个 pandas 方法（形式为 `:meth:`pandas.Series.sum``）

+   一个 pandas 函数（形式为 `:func:`pandas.to_datetime``）

注

为了仅显示链接类，方法或函数的最后组件，请以 `~` 为前缀。例如，`:class:`~pandas.Series`` 将链接到 `pandas.Series`，但只显示最后一部分 `Series` 作为链接文本。有关详细信息，请参阅 [Sphinx 交叉引用语法](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)。

**好的：**

```py
def add_values(arr):
  """
 Add the values in ``arr``.

 This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.

 Some sections are omitted here for simplicity.
 """
    return sum(arr) 
```

**不好的：**

```py
def func():

  """Some function.

 With several mistakes in the docstring.

 It has a blank like after the signature ``def func():``.

 The text 'Some function' should go in the line after the
 opening quotes of the docstring, not in the same line.

 There is a blank line between the docstring and the first line
 of code ``foo = 1``.

 The closing quotes should be in the next line, not in this one."""

    foo = 1
    bar = 2
    return foo + bar 
```  ### 第一部分：简短摘要

简短摘要是一句话，简洁地表达函数的作用。

简短摘要必须以大写字母开头，以句点结束，并适合一行。它需要表达对象的作用，而不提供细节。对于函数和方法，简短摘要必须以不定式动词开头。

**好的：**

```py
def astype(dtype):
  """
 Cast Series type.

 This section will provide further details.
 """
    pass 
```

**不好的：**

```py
def astype(dtype):
  """
 Casts Series type.

 Verb in third-person of the present simple, should be infinitive.
 """
    pass 
```

```py
def astype(dtype):
  """
 Method to cast Series type.

 Does not start with verb.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type

 Missing dot at the end.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type from its current type to the new type defined in
 the parameter dtype.

 Summary is too verbose and doesn't fit in a single line.
 """
    pass 
```  ### 第二部分：扩展摘要

扩展摘要提供了函数的详细信息。它不应该详细说明参数，或者讨论实现注意事项，这些内容在其他部分中。

简短摘要和扩展摘要之间留有一个空行。扩展摘要中的每个段落都以句点结尾。

扩展摘要应提供有关函数为什么有用以及它们的用例的详细信息，如果不太通用的话。

```py
def unstack():
  """
 Pivot a row index to columns.

 When using a MultiIndex, a level can be pivoted so each value in
 the index becomes a column. This is especially useful when a subindex
 is repeated for the main index, and data is easier to visualize as a
 pivot table.

 The index level will be automatically removed from the index when added
 as columns.
 """
    pass 
```  ### 第三部分：参数

将在此部分添加参数的详细信息。此部分的标题为“参数”，下面是一行带有单词“参数”的连字符。标题之前留有一个空行，但标题后面没有空行，在单词“参数”所在行和带连字符的行之间也没有空行。

在标题之后，必须记录签名中的每个参数，包括 `*args` 和 `**kwargs`，但不包括 `self`。

参数由其名称定义，后面跟着一个空格，一个冒号，另一个空格，以及类型（或类型）。注意名称和冒号之间的空格很重要。`*args` 和 `**kwargs` 不定义类型，但所有其他参数必须定义类型。在参数定义之后，必须有一个带缩进的参数描述行，可以有多行。描述必须以大写字母开头，并以句点结束。

对于具有默认值的关键字参数，类型后面会列出默认值。在这种情况下，类型的确切形式将是“int，默认值为 0”。在某些情况下，解释默认参数的含义可能很有用，这可以在逗号后面添加“int，默认值为-1，表示所有 CPU”。

在默认值为`None`的情况下，意味着不会使用该值。与“str，default None”相比，更倾向于写成“str，optional”。当`None`是一个被使用的值时，我们将保持形式“str，default None”。例如，在`df.to_csv(compression=None)`中，`None`不是一个被使用的值，但意味着压缩是可选的，如果未提供压缩，则不使用压缩。在这种情况下，我们将使用“str，optional”。仅在像`func(value=None)`和`None`被使用与`0`或`foo`相同的方式时，我们将指定“str，int 或 None，默认为 None”。

**好的：**

```py
class Series:
    def plot(self, kind, color='blue', **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Parameters
 ----------
 kind : str
 Kind of matplotlib plot.
 color : str, default 'blue'
 Color name or rgb code.
 **kwargs
 These parameters will be passed to the matplotlib plotting
 function.
 """
        pass 
```

**不好：**

```py
class Series:
    def plot(self, kind, **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Note the blank line between the parameters title and the first
 parameter. Also, note that after the name of the parameter ``kind``
 and before the colon, a space is missing.

 Also, note that the parameter descriptions do not start with a
 capital letter, and do not finish with a dot.

 Finally, the ``**kwargs`` parameter is missing.

 Parameters
 ----------

 kind: str
 kind of matplotlib plot
 """
        pass 
```

#### 参数类型

在指定参数类型时，可以直接使用 Python 内置数据类型（Python 类型优先于更冗长的字符串、整数、布尔值等）：

+   整数

+   浮点数

+   str

+   布尔值

对于复杂类型，定义子类型。对于`dict`和`tuple`，由于存在多种类型，我们使用括号来帮助阅读类型（大括号用于`dict`，普通括号用于`tuple`）：

+   int 列表

+   {str: int}字典

+   （str、int、int）元组

+   （str，）元组

+   str 集合

如果只有一组允许的值，请用大括号列出它们，并用逗号（后跟一个空格）分隔。如果这些值是有序的，并且它们有一个顺序，请按此顺序列出它们。否则，如果有默认值，请首先列出默认值：

+   {0, 10, 25}

+   {'simple'，'advanced'}

+   {'low'，'medium'，'high'}

+   {'cat'，'dog'，'bird'}

如果类型在 Python 模块中定义，则必须指定模块：

+   datetime.date

+   datetime.datetime

+   decimal.Decimal

如果类型在一个包中，也必须指定模块：

+   numpy.ndarray

+   scipy.sparse.coo_matrix

如果类型是 pandas 类型，则除了 Series 和 DataFrame 外，还要指定 pandas：

+   Series

+   DataFrame

+   pandas.Index

+   pandas.Categorical

+   pandas.arrays.SparseArray

如果确切的类型不相关，但必须与 NumPy 数组兼容，则可以指定 array-like。如果接受可迭代的任何类型，可以使用 iterable：

+   array-like

+   可迭代对象

如果接受的类型超过一个，用逗号分隔它们，除了最后两种类型，它们需要用单词'or'分隔：

+   整数或浮点数

+   浮点数、decimal.Decimal 或 None

+   str 或 str 列表

如果`None`是接受的值之一，则它始终需要是列表中的最后一个。

对于轴，惯例是使用类似于：

+   轴：{0 或'index'，1 或'columns'，None}，默认为 None  ### 第 4 节：返回或产出

如果方法返回一个值，将在本节中记录它。如果方法产生其输出。

该部分的标题将与“参数”相同。使用名称“返回”或“产出”，后跟一行与前一个单词中的字母数相同的连字符。

返回的文档与参数类似。但在这种情况下，不提供名称，除非该方法返回或产出多个值（值的元组）。

“返回”和“产出”的类型与“参数”的类型相同。此外，描述必须以句点结束。

例如，对于单个值：

```py
def sample():
  """
 Generate and return a random number.

 The value is sampled from a continuous uniform distribution between
 0 and 1.

 Returns
 -------
 float
 Random number generated.
 """
    return np.random.random() 
```

当有多个值时：

```py
import string

def random_letters():
  """
 Generate and return a sequence of random letters.

 The length of the returned string is also random, and is also
 returned.

 Returns
 -------
 length : int
 Length of the returned string.
 letters : str
 String of random letters.
 """
    length = np.random.randint(1, 10)
    letters = ''.join(np.random.choice(string.ascii_lowercase)
                      for i in range(length))
    return length, letters 
```

如果方法产生它的值：

```py
def sample_values():
  """
 Generate an infinite sequence of random numbers.

 The values are sampled from a continuous uniform distribution between
 0 and 1.

 Yields
 ------
 float
 Random number generated.
 """
    while True:
        yield np.random.random() 
```  ### 第 5 节：参见

本节用于让用户了解与正在文档化的功能相关的 pandas 功能。在极少数情况下，如果找不到任何相关的方法或函数，可以跳过此节。

一个明显的例子是 `head()` 和 `tail()` 方法。由于 `tail()` 做的是 `head()` 的等效操作，但是在 `Series` 或 `DataFrame` 的末尾而不是开头，因此让用户知道这一点是很好的。

为了直观地了解什么可以被视为相关，这里有一些例子：

+   `loc` 和 `iloc`，因为它们做的事情相同，但在一个情况下提供索引，在另一个情况下提供位置。

+   `max` 和 `min`，因为它们起相反的作用。

+   `iterrows`、`itertuples` 和 `items`，因为用户可能在寻找按列迭代的方法时最终找到了按行迭代的方法，反之亦然。

+   `fillna` 和 `dropna`，因为这两种方法都用于处理缺失值。

+   `read_csv` 和 `to_csv`，因为它们是互补的。

+   `merge` 和 `join`，因为其中一个是另一个的概括。

+   `astype` 和 `pandas.to_datetime`，因为用户可能在阅读 `astype` 的文档以了解如何转换为日期，而做法是使用 `pandas.to_datetime`。

+   `where` 和 `numpy.where` 相关，因为它的功能基于它。

决定相关内容时，你应该主要运用常识，考虑对于阅读文档的用户而言哪些内容可能有用，尤其是对于那些经验较少的用户。

当与其他库（主要是 `numpy`）相关时，首先使用模块的名称（而不是别名，如 `np`）。如果函数在一个不是主要的模块中，比如 `scipy.sparse`，则列出完整的模块（例如 `scipy.sparse.coo_matrix`）。

本节有一个标题，“参见”（注意大写的 S 和 A），后面跟着带有连字符的行，并且前面有一个空行。

在标题之后，我们会为每个相关的方法或函数添加一行，后跟一个空格，一个冒号，另一个空格，以及一个简短的描述，说明此方法或函数在这个上下文中的相关性，以及所记录的函数与被引用的函数之间的关键差异。描述还必须以句点结束。

注意在“返回”和“产出”中，描述位于类型之后的行。然而，在本节中，它位于同一行上，中间有一个冒号。如果描述不适合在同一行上，可以延续到其他行，必须进一步缩进。

例如：

```py
class Series:
    def head(self):
  """
 Return the first 5 elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying the whole of it.

 Returns
 -------
 Series
 Subset of the original series with the 5 first values.

 See Also
 --------
 Series.tail : Return the last 5 elements of the Series.
 Series.iloc : Return a slice of the elements in the Series,
 which can also be used to return the first or last n.
 """
        return self.iloc[:5] 
```  ### 第 6 节：注解

这是一个可选的部分，用于记录算法实现的注解，或者记录函数行为的技术方面。

请随意跳过，除非您熟悉算法的实现，或者在为函数编写示例时发现一些违反直觉的行为。

本节遵循与扩展摘要部分相同的格式。### 第 7 节：示例

这是文档字符串中最重要的部分之一，尽管通常被放在最后的位置，因为人们更容易通过示例而不是准确的解释来理解概念。

文档字符串中的示例，除了说明函数或方法的用法外，还必须是有效的 Python 代码，以确定的方式返回给定的输出，并且可以由用户复制并运行。

示例以 Python 终端中的会话形式呈现。`>>>`用于展示代码。`...`用于继续上一行的代码。输出立即在生成输出的最后一行代码之后呈现（中间没有空行）。在示例之前和之后可以添加描述示例的注释，中间有空行。

呈现示例的方式如下：

1.  导入所需的库（除了`numpy`和`pandas`）

1.  创建示例所需的数据

1.  展示一个非常基本的示例，以便了解最常见的用例

1.  添加带有说明的示例，说明参数如何用于扩展功能

一个简单的示例可能是：

```py
class Series:

    def head(self, n=5):
  """
 Return the first elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying all of it.

 Parameters
 ----------
 n : int
 Number of values to return.

 Return
 ------
 pandas.Series
 Subset of the original series with the n first values.

 See Also
 --------
 tail : Return the last n elements of the Series.

 Examples
 --------
 >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',
 ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])
 >>> ser.head()
 0   Ant
 1   Bear
 2   Cow
 3   Dog
 4   Falcon
 dtype: object

 With the ``n`` parameter, we can change the number of returned rows:

 >>> ser.head(n=3)
 0   Ant
 1   Bear
 2   Cow
 dtype: object
 """
        return self.iloc[:n] 
```

示例应尽可能简洁。在函数复杂性需要长示例的情况下，建议使用粗体标题的块。使用双星`**`使文本加粗，就像`**这个例子**`中一样。

#### 示例的约定

示例中的代码始终假定以这两行开头，但没有显示：

```py
import numpy as np
import pandas as pd 
```

示例中使用的任何其他模块必须显式导入，每行一个（如在[**PEP 8#imports**](https://peps.python.org/pep-0008/#imports)中推荐的）并避免使用别名。避免过多的导入，但如果需要，首先是来自标准库的导入，然后是第三方库（如 matplotlib）。

当用单个`Series`说明示例时，请使用名称`ser`，如果用单个`DataFrame`说明，则使用名称`df`。对于索引，`idx`是首选名称。如果使用一组同类的`Series`或`DataFrame`，请将它们命名为`ser1`、`ser2`、`ser3`...或`df1`、`df2`、`df3`... 如果数据不同类，并且需要多个结构，请用有意义的名称命名它们，例如`df_main`和`df_to_join`。

示例中使用的数据应尽可能紧凑。推荐行数约为 4，但对于特定示例，使其为合理数字。例如，在`head`方法中，它需要比 5 更高，以显示具有默认值的示例。如果进行`mean`，我们可以使用类似`[1, 2, 3]`的东西，这样很容易看到返回的值是均值。

对于更复杂的示例（例如分组），避免使用没有解释的数据，比如由随机数字组成的带有列 A、B、C、D 的矩阵…… 而是使用一个有意义的示例，这样更容易理解概念。除非示例要求，否则使用动物的名称，以保持示例的一致性。以及它们的数值属性。

在调用方法时，关键字参数 `head(n=3)` 优先于位置参数 `head(3)`。

**好：**

```py
class Series:

    def mean(self):
  """
 Compute the mean of the input.

 Examples
 --------
 >>> ser = pd.Series([1, 2, 3])
 >>> ser.mean()
 2
 """
        pass

    def fillna(self, value):
  """
 Replace missing values by ``value``.

 Examples
 --------
 >>> ser = pd.Series([1, np.nan, 3])
 >>> ser.fillna(0)
 [1, 0, 3]
 """
        pass

    def groupby_mean(self):
  """
 Group by index and return mean.

 Examples
 --------
 >>> ser = pd.Series([380., 370., 24., 26],
 ...               name='max_speed',
 ...               index=['falcon', 'falcon', 'parrot', 'parrot'])
 >>> ser.groupby_mean()
 index
 falcon    375.0
 parrot     25.0
 Name: max_speed, dtype: float64
 """
        pass

    def contains(self, pattern, case_sensitive=True, na=numpy.nan):
  """
 Return whether each value contains ``pattern``.

 In this case, we are illustrating how to use sections, even
 if the example is simple enough and does not require them.

 Examples
 --------
 >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)
 >>> ser.contains(pattern='a')
 0    False
 1    False
 2     True
 3      NaN
 dtype: bool

 **Case sensitivity**

 With ``case_sensitive`` set to ``False`` we can match ``a`` with both
 ``a`` and ``A``:

 >>> s.contains(pattern='a', case_sensitive=False)
 0     True
 1    False
 2     True
 3      NaN
 dtype: bool

 **Missing values**

 We can fill missing values in the output using the ``na`` parameter:

 >>> ser.contains(pattern='a', na=False)
 0    False
 1    False
 2     True
 3    False
 dtype: bool
 """
        pass 
```

**不好：**

```py
def method(foo=None, bar=None):
  """
 A sample DataFrame method.

 Do not import NumPy and pandas.

 Try to use meaningful data, when it makes the example easier
 to understand.

 Try to avoid positional arguments like in ``df.method(1)``. They
 can be all right if previously defined with a meaningful name,
 like in ``present_value(interest_rate)``, but avoid them otherwise.

 When presenting the behavior with different parameters, do not place
 all the calls one next to the other. Instead, add a short sentence
 explaining what the example shows.

 Examples
 --------
 >>> import numpy as np
 >>> import pandas as pd
 >>> df = pd.DataFrame(np.random.randn(3, 3),
 ...                   columns=('a', 'b', 'c'))
 >>> df.method(1)
 21
 >>> df.method(bar=14)
 123
 """
    pass 
```  #### 通过 doctest 测试的示例的提示

使示例通过验证脚本的 doctest 有时可能会很棘手。以下是一些注意点：

+   导入所有所需的库（除了 pandas 和 NumPy，它们已经被导入为 `import pandas as pd` 和 `import numpy as np`），并定义您在示例中使用的所有变量。

+   尽量避免使用随机数据。但在某些情况下，使用随机数据可能是可以的，比如您要记录的函数处理概率分布，或者如果需要创建使函数结果有意义的数据量太大，手动创建它非常麻烦。在这些情况下，始终使用固定的随机种子使生成的示例可预测。例如：

    ```py
    >>> np.random.seed(42)
    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) 
    ```

+   如果您有一个跨越多行的代码片段，您需要在连续的行上使用 '...'：

    ```py
    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],
    ...                   columns=['A', 'B']) 
    ```

+   如果要显示引发异常的情况，可以执行：

    ```py
    >>> pd.to_datetime(["712-01-01"])
    Traceback (most recent call last):
    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 
    ```

    必须包含“Traceback (most recent call last):”，但对于实际错误，只需提供错误名称即可。

+   如果结果中有一个可以变化的小部分（例如对象表示中的哈希），则可以使用 `...` 表示此部分。

    如果要显示 `s.plot()` 返回一个 matplotlib AxesSubplot 对象，这将导致 doctest 失败。

    ```py
    >>> s.plot()
    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> 
    ```

    然而，您可以执行以下操作（注意需要添加的注释）

    ```py
    >>> s.plot()  
    <matplotlib.axes._subplots.AxesSubplot at ...> 
    ```  #### 示例中的绘图

pandas 中有一些返回绘图的方法。为了渲染文档中示例生成的图形，存在 `.. plot::` 指令。

要使用它，请在“示例”标题之后放置下面显示的代码。构建文档时将自动生成图形。

```py
class Series:
    def plot(self):
  """
 Generate a plot with the ``Series`` data.

 Examples
 --------

 .. plot::
 :context: close-figs

 >>> ser = pd.Series([1, 2, 3])
 >>> ser.plot()
 """
        pass 
```  ### 通用规则

文档字符串必须用三个双引号定义。在文档字符串之前或之后不应该留下空行。文本从开头引号的下一行开始。闭合引号有它们自己的一行（这意味着它们不是在最后一个句子的末尾）。

在文档字符串中，偶尔会使用 reST 样式，比如粗体文本或斜体文本，但常见的是使用内联代码，这些代码被放置在反引号之间。以下内容被视为内联代码：

+   参数的名称

+   Python 代码、模块、函数、内置函数、类型、字面值……（例如 `os`、`list`、`numpy.abs`、`datetime.date`、`True`）

+   一个 pandas 类（以 `:class:`pandas.Series`` 形式）

+   一个 pandas 方法（以 `:meth:`pandas.Series.sum`` 形式）

+   一个 pandas 函数（以 `:func:`pandas.to_datetime`` 形式）

注意

要仅显示链接类、方法或函数的最后一个组件，请在其前面加上`~`。例如，`:class:`~pandas.Series``将链接到`pandas.Series`，但只显示最后部分`Series`作为链接文本。有关详细信息，请参阅[Sphinx 交叉引用语法](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)。

**好：**

```py
def add_values(arr):
  """
 Add the values in ``arr``.

 This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.

 Some sections are omitted here for simplicity.
 """
    return sum(arr) 
```

**不好：**

```py
def func():

  """Some function.

 With several mistakes in the docstring.

 It has a blank like after the signature ``def func():``.

 The text 'Some function' should go in the line after the
 opening quotes of the docstring, not in the same line.

 There is a blank line between the docstring and the first line
 of code ``foo = 1``.

 The closing quotes should be in the next line, not in this one."""

    foo = 1
    bar = 2
    return foo + bar 
```

### 第 1 节：简短摘要

简短摘要是一句话，简洁地表达函数的作用。

简短摘要必须以大写字母开头，以句点结束，并适合在一行内。它需要表达对象的作用，而不提供细节。对于函数和方法，简短摘要必须以不定式动词开头。

**好：**

```py
def astype(dtype):
  """
 Cast Series type.

 This section will provide further details.
 """
    pass 
```

**不好：**

```py
def astype(dtype):
  """
 Casts Series type.

 Verb in third-person of the present simple, should be infinitive.
 """
    pass 
```

```py
def astype(dtype):
  """
 Method to cast Series type.

 Does not start with verb.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type

 Missing dot at the end.
 """
    pass 
```

```py
def astype(dtype):
  """
 Cast Series type from its current type to the new type defined in
 the parameter dtype.

 Summary is too verbose and doesn't fit in a single line.
 """
    pass 
```

### 第 2 节：扩展摘要

扩展摘要提供了函数的详细信息。不应该深入讨论参数的细节，或者讨论实现注意事项，这些应该放在其他部分。

简短摘要和扩展摘要之间留有一个空行。扩展摘要中的每个段落都以句点结束。

扩展摘要应提供函数的用途及其用例的详细信息，如果不是太通用的话。

```py
def unstack():
  """
 Pivot a row index to columns.

 When using a MultiIndex, a level can be pivoted so each value in
 the index becomes a column. This is especially useful when a subindex
 is repeated for the main index, and data is easier to visualize as a
 pivot table.

 The index level will be automatically removed from the index when added
 as columns.
 """
    pass 
```

### 第 3 节：参数

参数的详细信息将在此部分添加。此部分的标题为“参数”，后跟��个下划线线，下划��下面是单词“参数”的每个字母。在部分标题之前留有一个空行，但在之后不留空行，在单词“参数”下划线和下划线之间也不留空行。

在标题之后，必须记录签名中的每个参数，包括`*args`和`**kwargs`，但不包括`self`。

参数由其名称定义，后跟一个空格，一个冒号，另一个空格，以及类型（或类型）。请注意名称和冒号之间的空格很重要。对于`*args`和`**kwargs`不定义类型，但对于所有其他参数必须定义类型。在参数定义之后，需要有一行参数描述，缩进，并且可以有多行。描述必须以大写字母开头，并以句点结束。

对于具有默认值的关键字参数，将在类型末尾的逗号后列出默认值。在这种情况下，类型的确切形式将是“int，默认值 0”。在某些情况下，解释默认参数的含义可能很有用，可以在逗号后添加“int，默认值-1，表示所有 cpu”。

在默认值为`None`的情况下，意味着该值将不被使用。与“str，默认为 None”相比，更倾向于写“str，可选”。当`None`是一个被使用的值时，我们将保持“str，默认为 None”的形式。例如，在`df.to_csv(compression=None)`中，`None`不是一个被使用的值，而是表示压缩是可选的，如果不提供，则不使用压缩。在这种情况下，我们将使用“str，可选”。只有在像`func(value=None)`和`None`被用作`0`或`foo`一样使用时，我们将指定“str，int 或 None，默认为 None”。

**好：**

```py
class Series:
    def plot(self, kind, color='blue', **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Parameters
 ----------
 kind : str
 Kind of matplotlib plot.
 color : str, default 'blue'
 Color name or rgb code.
 **kwargs
 These parameters will be passed to the matplotlib plotting
 function.
 """
        pass 
```

**不好：**

```py
class Series:
    def plot(self, kind, **kwargs):
  """
 Generate a plot.

 Render the data in the Series as a matplotlib plot of the
 specified kind.

 Note the blank line between the parameters title and the first
 parameter. Also, note that after the name of the parameter ``kind``
 and before the colon, a space is missing.

 Also, note that the parameter descriptions do not start with a
 capital letter, and do not finish with a dot.

 Finally, the ``**kwargs`` parameter is missing.

 Parameters
 ----------

 kind: str
 kind of matplotlib plot
 """
        pass 
```

#### 参数类型

在指定参数类型时，可以直接使用 Python 内置数据类型（优先使用 Python 类型，而不是更冗长的字符串、整数、布尔值等）：

+   整数

+   浮点数

+   字符串

+   布尔值

对于复杂类型，定义子类型。对于`dict`和`tuple`，由于存在多种类型，我们使用括号来帮助阅读类型（大括号用于`dict`，普通括号用于`tuple`）：

+   整数列表

+   字典{str：int}

+   元组（str，int，int）

+   元组（str，）

+   字符串集合

在只允许一组值的情况下，将它们用大括号分隔并用逗号（后跟一个空格）分隔。如果值是有序的并且有顺序，请按此顺序列出。否则，如果有默认值，请首先列出默认值：

+   {0, 10, 25}

+   {‘简单’，‘高级’}

+   {‘低’, ‘中’, ‘高’}

+   {‘猫’，‘狗’，‘鸟’}

如果类型在 Python 模块中定义，则必须指定模块：

+   datetime.date

+   datetime.datetime

+   decimal.Decimal

如果类型在一个包中，必须同时指定模块：

+   numpy.ndarray

+   scipy.sparse.coo_matrix

如果类型是 pandas 类型，则还需指定 pandas，除了 Series 和 DataFrame：

+   Series

+   数据框

+   pandas.Index

+   pandas.Categorical

+   pandas.arrays.SparseArray

如果确切的类型不重要，但必须与 NumPy 数组兼容，则可以指定类似数组。如果接受任何可迭代的类型，则可以使用可迭代：

+   类似数组

+   可迭代

如果接受多种类型，请用逗号分隔，除了最后两种类型，它们需要用“或”分隔：

+   整数或浮点数

+   浮点数、decimal.Decimal 或 None

+   字符串或字符串列表

如果`None`是被接受的值之一，则它总是需要在列表中的最后。

对于轴，惯例是使用类似于：

+   轴：{0 或‘索引’，1 或‘列’，无}，默认无  #### 参数类型

在指定参数类型时，可以直接使用 Python 内置数据类型（优先使用 Python 类型，而不是更冗长的字符串、整数、布尔值等）：

+   整数

+   浮点数

+   字符串

+   布尔值

对于复杂类型，定义子类型。对于`dict`和`tuple`，由于存在多种类型，我们使用括号来帮助阅读类型（大括号用于`dict`，普通括号用于`tuple`）：

+   整数列表

+   字典{str：int}

+   元组（str，int，int）

+   元组（str，）

+   字符串集合

如果只允许一组值，则用大括号列出它们，并用逗号（后跟一个空格）分隔。如果值是有序的并且有顺序，请按此顺序列出它们。否则，如果有默认值，请首先列出默认值：

+   {0, 10, 25}

+   {‘simple’、‘advanced’}

+   {‘low’, ‘medium’, ‘high’}

+   {‘cat’、‘dog’、‘bird’}

如果类型在 Python 模块中定义，则必须指定模块：

+   datetime.date

+   datetime.datetime

+   decimal.Decimal

如果类型在一个包中，则必须同时指定模块：

+   numpy.ndarray

+   scipy.sparse.coo_matrix

如果类型是 pandas 类型，则除了 Series 和 DataFrame 外，还要指定 pandas：

+   Series

+   DataFrame

+   pandas.Index

+   pandas.Categorical

+   pandas.arrays.SparseArray

如果确切类型不相关，但必须与 NumPy 数组兼容，则可以指定类似数组。如果接受可以迭代的任何类型，则可以使用 iterable：

+   类似数组

+   可迭代的

如果接受多种类型，请用逗号分隔它们，除了最后两种类型需要用“or”分隔的单词之外：

+   int 或 float

+   float、decimal.Decimal 或 None

+   str 或 str 的列表

如果 `None` 是可接受的值之一，则它始终需要在列表中的最后。

对于轴，惯例是使用类似以下的内容：

+   axis：{0 或 ‘index’，1 或 ‘columns’，None}，默认为 None

### 第四节：返回或产出

如果方法返回一个值，则将在此部分中记录该值。如果方法也产生其输出。

节的标题将与“Parameters”相同的方式定义。使用名称“Returns”或“Yields”，后跟一行连字符，连字符数与前面单词的字母数相同。

返回的文档也类似于参数。但是在这种情况下，除非方法返回或产出多个值（一组值的元组），否则不会提供名称。

“Returns”和“Yields”的类型与“Parameters”的类型相同。此外，描述必须以句点结束。

例如，对于单个值：

```py
def sample():
  """
 Generate and return a random number.

 The value is sampled from a continuous uniform distribution between
 0 and 1.

 Returns
 -------
 float
 Random number generated.
 """
    return np.random.random() 
```

带有多个值：

```py
import string

def random_letters():
  """
 Generate and return a sequence of random letters.

 The length of the returned string is also random, and is also
 returned.

 Returns
 -------
 length : int
 Length of the returned string.
 letters : str
 String of random letters.
 """
    length = np.random.randint(1, 10)
    letters = ''.join(np.random.choice(string.ascii_lowercase)
                      for i in range(length))
    return length, letters 
```

如果方法产生其值：

```py
def sample_values():
  """
 Generate an infinite sequence of random numbers.

 The values are sampled from a continuous uniform distribution between
 0 and 1.

 Yields
 ------
 float
 Random number generated.
 """
    while True:
        yield np.random.random() 
```

### 第五节：参见

这个部分用于让用户了解与正在文档化的功能相关的 pandas 功能。在极少数情况下，如果根本找不到任何相关的方法或函数，可以跳过此部分。

显而易见的例子是 `head()` 和 `tail()` 方法。由于 `tail()` 执行的操作与 `head()` 相当，但是在 `Series` 或 `DataFrame` 的末尾而不是开头进行，因此让用户知道这一点是很好的。

为了对什么可以被认为是相关的有所了解，这里有一些例子：

+   `loc` 和 `iloc`，因为它们执行相同的操作，但在一个情况下提供索引，在另一个情况下提供位置

+   `max` 和 `min`，因为它们执行相反的操作

+   `iterrows`、`itertuples` 和 `items`，因为很容易让寻找用于迭代列的方法的用户最终进入用于迭代行的方法，反之亦然

+   `fillna` 和 `dropna`，因为这两种方法都用于处理缺失值

+   `read_csv` 和 `to_csv`，因为它们是互补的

+   `merge` 和 `join`，因为其中一个是另一个的泛化

+   `astype` 和 `pandas.to_datetime`，因为用户可能正在阅读 `astype` 的文档以了解如何转换为日期，而正确的方法是使用 `pandas.to_datetime`

+   `where` 与 `numpy.where` 相关，因为它的功能是基于它的

在决定相关内容时，你应该主要依靠常识，思考对阅读文档的用户有用的内容，特别是对于经验较少的用户。

当涉及到其他库（主要是 `numpy`）时，首先使用模块的名称（而不是别名像 `np`）。如果函数在不是主要的模块中，比如 `scipy.sparse`，列出完整的模块（例如 `scipy.sparse.coo_matrix`）。

这一部分有一个标题，“参见”（注意大写的 S 和 A），后面跟着由破折号组成的行，并在前面有一个空行。

在标题之后，我们将为每个相关的方法或函数添加一行，后面跟着一个空格，一个冒号，另一个空格，以及一个简短的描述，说明这个方法或函数在这个上下文中的相关性，以及文档化函数和被引用函数之间的主要区别是什么。描述还必须以句点结束。

请注意，在“Returns”和“Yields”中，描述位于类型的下一行上。然而，在这一部分中，它位于同一行上，中间有一个冒号。如果描述不适合在同一行上，则可以继续到其他行，这些行必须进一步缩进。

例如：

```py
class Series:
    def head(self):
  """
 Return the first 5 elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying the whole of it.

 Returns
 -------
 Series
 Subset of the original series with the 5 first values.

 See Also
 --------
 Series.tail : Return the last 5 elements of the Series.
 Series.iloc : Return a slice of the elements in the Series,
 which can also be used to return the first or last n.
 """
        return self.iloc[:5] 
```

### 第 6 部分：注意事项

这是一个可选部分，用于关于算法实现的笔记，或者记录函数行为的技术细节。

可以跳过这部分，除非你熟悉算法的实现，或者在编写函数示例时发现了一些反直觉的行为。

这一部分的格式与扩展摘要部分相同。

### 第 7 部分：示例

尽管放在最后位置，但这是 docstring 中最重要的部分之一，因为人们通常通过示例而不是准确的解释更好地理解概念。

文档字符串中的示例除了说明函数或方法的使用方法外，还必须是有效的 Python 代码，以确定的方式返回给定的输出，并且可以被用户复制并运行。

示例被呈现为 Python 终端中的会话。 `>>>` 用于呈现代码。 `...` 用于从上一行继续的代码。输出立即在生成输出的最后一行代码之后呈现（中间没有空行）。在示例之前和之后可以添加描述示例的注释，这些注释用空行分隔。

示例的呈现方式如下：

1.  导入所需的库（除了 `numpy` 和 `pandas`）

1.  创建示例所需的数据

1.  显示一个非常基本的示例，给出最常见用例的概念

1.  添加带有解释的示例，说明参数如何用于扩展功能

一个简单的示例可能是：

```py
class Series:

    def head(self, n=5):
  """
 Return the first elements of the Series.

 This function is mainly useful to preview the values of the
 Series without displaying all of it.

 Parameters
 ----------
 n : int
 Number of values to return.

 Return
 ------
 pandas.Series
 Subset of the original series with the n first values.

 See Also
 --------
 tail : Return the last n elements of the Series.

 Examples
 --------
 >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',
 ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])
 >>> ser.head()
 0   Ant
 1   Bear
 2   Cow
 3   Dog
 4   Falcon
 dtype: object

 With the ``n`` parameter, we can change the number of returned rows:

 >>> ser.head(n=3)
 0   Ant
 1   Bear
 2   Cow
 dtype: object
 """
        return self.iloc[:n] 
```

示例应尽可能简洁。在函数复杂性要求较长示例的情况下，建议使用加粗标题的块。使用双星号`**`使文本加粗，如`**这个示例**`。

#### 示例的约定

示例中的代码始终假定以未显示的这两行开头：

```py
import numpy as np
import pandas as pd 
```

示例中使用的任何其他模块都必须显式导入，每行一个（如[**PEP 8#imports**](https://peps.python.org/pep-0008/#imports)中推荐的），避免使用别名。避免过多的导入，但如果需要，标准库的导入优先，然后是第三方库（如 matplotlib）。

当用单个`Series`说明示例时，请使用名称`ser`，如果用单个`DataFrame`说明，请使用名称`df`。对于索引，首选名称为`idx`。如果使用一组同质的`Series`或`DataFrame`，请将它们命名为`ser1`、`ser2`、`ser3`…或`df1`、`df2`、`df3`…如果数据不是同质的，并且需要多个结构，则使用有意义的名称，例如`df_main`和`df_to_join`。

示例中使用的数据应尽可能紧凑。建议行数约为 4 行，但应根据具体示例的情况确定。例如，在`head`方法中，建议行数大于 5，以显示具有默认值的示例。如果进行`mean`操作，我们可以使用类似`[1, 2, 3]`的数据，这样很容易看出返回的值是平均值。

对于更复杂的示例（例如分组），避免使用没有解释的数据，比如具有 A、B、C、D 列的随机数矩阵…而是使用一个有意义的示例，这样更容易理解概念。除非示例需要，否则使用动物的名称，以保持示例的一致性。以及它们的数值属性。

在调用该方法时，优先使用关键字参数`head(n=3)`而不是位置参数`head(3)`。

**好的做法：**

```py
class Series:

    def mean(self):
  """
 Compute the mean of the input.

 Examples
 --------
 >>> ser = pd.Series([1, 2, 3])
 >>> ser.mean()
 2
 """
        pass

    def fillna(self, value):
  """
 Replace missing values by ``value``.

 Examples
 --------
 >>> ser = pd.Series([1, np.nan, 3])
 >>> ser.fillna(0)
 [1, 0, 3]
 """
        pass

    def groupby_mean(self):
  """
 Group by index and return mean.

 Examples
 --------
 >>> ser = pd.Series([380., 370., 24., 26],
 ...               name='max_speed',
 ...               index=['falcon', 'falcon', 'parrot', 'parrot'])
 >>> ser.groupby_mean()
 index
 falcon    375.0
 parrot     25.0
 Name: max_speed, dtype: float64
 """
        pass

    def contains(self, pattern, case_sensitive=True, na=numpy.nan):
  """
 Return whether each value contains ``pattern``.

 In this case, we are illustrating how to use sections, even
 if the example is simple enough and does not require them.

 Examples
 --------
 >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)
 >>> ser.contains(pattern='a')
 0    False
 1    False
 2     True
 3      NaN
 dtype: bool

 **Case sensitivity**

 With ``case_sensitive`` set to ``False`` we can match ``a`` with both
 ``a`` and ``A``:

 >>> s.contains(pattern='a', case_sensitive=False)
 0     True
 1    False
 2     True
 3      NaN
 dtype: bool

 **Missing values**

 We can fill missing values in the output using the ``na`` parameter:

 >>> ser.contains(pattern='a', na=False)
 0    False
 1    False
 2     True
 3    False
 dtype: bool
 """
        pass 
```

**不好的做法：**

```py
def method(foo=None, bar=None):
  """
 A sample DataFrame method.

 Do not import NumPy and pandas.

 Try to use meaningful data, when it makes the example easier
 to understand.

 Try to avoid positional arguments like in ``df.method(1)``. They
 can be all right if previously defined with a meaningful name,
 like in ``present_value(interest_rate)``, but avoid them otherwise.

 When presenting the behavior with different parameters, do not place
 all the calls one next to the other. Instead, add a short sentence
 explaining what the example shows.

 Examples
 --------
 >>> import numpy as np
 >>> import pandas as pd
 >>> df = pd.DataFrame(np.random.randn(3, 3),
 ...                   columns=('a', 'b', 'c'))
 >>> df.method(1)
 21
 >>> df.method(bar=14)
 123
 """
    pass 
```  #### 通过 doctests 的提示

通过 doctests 的验证脚本使示例通过有时可能会有些棘手。以下是一些注意事项：

+   导入所有需要的库（除了 pandas 和 NumPy，它们已经作为`import pandas as pd`和`import numpy as np`导入）并定义您在示例中使用的所有变量。

+   尽量避免使用随机数据。但在某些情况下，随机数据可能是可以接受的，比如您正在记录处理概率分布的函数，或者如果需要大量数据才能使函数结果有意义，手动创建数据非常繁琐。在这些情况下，始终使用固定的随机种子使生成的示例可预测。例如：

    ```py
    >>> np.random.seed(42)
    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) 
    ```

+   如果您有一个跨越多行的代码片段，需要在续行上使用‘…’：

    ```py
    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],
    ...                   columns=['A', 'B']) 
    ```

+   如果您想展示引发异常的情况，可以执行以下操作：

    ```py
    >>> pd.to_datetime(["712-01-01"])
    Traceback (most recent call last):
    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 
    ```

    包含 “Traceback (most recent call last):” 是必不可少的，但实际错误只需提供错误名称即可。

+   如果结果中有一小部分可能会变化（例如，对象表示中的哈希值），您可以使用 `...` 来表示这部分。

    如果要显示 `s.plot()` 返回 matplotlib AxesSubplot 对象，这将导致文档测试失败。

    ```py
    >>> s.plot()
    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> 
    ```

    但是，您可以执行以下操作（注意需要添加的注释）

    ```py
    >>> s.plot()  
    <matplotlib.axes._subplots.AxesSubplot at ...> 
    ```  #### 示例中的绘图

pandas 中有一些返回图形的方法。为了渲染文档中示例生成的图形，存在 `.. plot::` 指令。

要使用它，请将下一行代码放在“示例”标题后，如下所示。当构建文档时，图形将自动生成。

```py
class Series:
    def plot(self):
  """
 Generate a plot with the ``Series`` data.

 Examples
 --------

 .. plot::
 :context: close-figs

 >>> ser = pd.Series([1, 2, 3])
 >>> ser.plot()
 """
        pass 
```  #### 示例的约定

示例中的代码始终假定以未显示的这两行开头：

```py
import numpy as np
import pandas as pd 
```

示例中使用的任何其他模块都必须明确导入，每行一个（如[**PEP 8#imports**](https://peps.python.org/pep-0008/#imports)中建议的），避免使用别名。避免过多的导入，但如果需要，标准库的导入首先进行，然后是第三方库（例如 matplotlib）。

在用单个 `Series` 说明示例时，使用名称 `ser`，如果用单个 `DataFrame` 说明，使用名称 `df`。对于索引，首选名称是 `idx`。如果使用一组同质的 `Series` 或 `DataFrame`，请将它们命名为 `ser1`、`ser2`、`ser3`… 或 `df1`、`df2`、`df3`… 如果数据不同质，并且需要多个结构，则使用有意义的名称，例如 `df_main` 和 `df_to_join`。

示例中使用的数据应尽可能紧凑。建议行数约为 4，但根据具体示例选择一个合理的数字。例如，在 `head` 方法中，需要高于 5，以显示默认值的示例。如果执行 `mean`，我们可以使用类似 `[1, 2, 3]` 的内容，这样很容易看到返回的值是平均值。

对于更复杂的示例（例如分组），避免使用没有解释的数据，比如随机数矩阵，列为 A、B、C、D… 而是使用有意义的示例，这样更容易理解概念。除非示例需要，否则使用动物的名称，以保持示例的一致性。以及它们的数值属性。

在调用方法时，关键字参数 `head(n=3)` 优先于位置参数 `head(3)`。

**好的：**

```py
class Series:

    def mean(self):
  """
 Compute the mean of the input.

 Examples
 --------
 >>> ser = pd.Series([1, 2, 3])
 >>> ser.mean()
 2
 """
        pass

    def fillna(self, value):
  """
 Replace missing values by ``value``.

 Examples
 --------
 >>> ser = pd.Series([1, np.nan, 3])
 >>> ser.fillna(0)
 [1, 0, 3]
 """
        pass

    def groupby_mean(self):
  """
 Group by index and return mean.

 Examples
 --------
 >>> ser = pd.Series([380., 370., 24., 26],
 ...               name='max_speed',
 ...               index=['falcon', 'falcon', 'parrot', 'parrot'])
 >>> ser.groupby_mean()
 index
 falcon    375.0
 parrot     25.0
 Name: max_speed, dtype: float64
 """
        pass

    def contains(self, pattern, case_sensitive=True, na=numpy.nan):
  """
 Return whether each value contains ``pattern``.

 In this case, we are illustrating how to use sections, even
 if the example is simple enough and does not require them.

 Examples
 --------
 >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)
 >>> ser.contains(pattern='a')
 0    False
 1    False
 2     True
 3      NaN
 dtype: bool

 **Case sensitivity**

 With ``case_sensitive`` set to ``False`` we can match ``a`` with both
 ``a`` and ``A``:

 >>> s.contains(pattern='a', case_sensitive=False)
 0     True
 1    False
 2     True
 3      NaN
 dtype: bool

 **Missing values**

 We can fill missing values in the output using the ``na`` parameter:

 >>> ser.contains(pattern='a', na=False)
 0    False
 1    False
 2     True
 3    False
 dtype: bool
 """
        pass 
```

**不好的：**

```py
def method(foo=None, bar=None):
  """
 A sample DataFrame method.

 Do not import NumPy and pandas.

 Try to use meaningful data, when it makes the example easier
 to understand.

 Try to avoid positional arguments like in ``df.method(1)``. They
 can be all right if previously defined with a meaningful name,
 like in ``present_value(interest_rate)``, but avoid them otherwise.

 When presenting the behavior with different parameters, do not place
 all the calls one next to the other. Instead, add a short sentence
 explaining what the example shows.

 Examples
 --------
 >>> import numpy as np
 >>> import pandas as pd
 >>> df = pd.DataFrame(np.random.randn(3, 3),
 ...                   columns=('a', 'b', 'c'))
 >>> df.method(1)
 21
 >>> df.method(bar=14)
 123
 """
    pass 
```

#### 通过文档测试使示例通过的提示

使示例在验证脚本中通过文档测试有时可能会很棘手。以下是一些注意事项：

+   导入所有需要的库（除了 pandas 和 NumPy，它们已经被导入为 `import pandas as pd` 和 `import numpy as np`），并定义您在示例中使用的所有变量。

+   尽量避免使用随机数据。但是在某些情况下，使用随机数据可能是可以的，比如您要记录的函数处理概率分布，或者使函数结果有意义所需的数据量太大，手动创建这些数据非常麻烦。在这些情况下，始终使用固定的随机种子使生成的示例可预测。例如：

    ```py
    >>> np.random.seed(42)
    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) 
    ```

+   如果您有一个跨越多行的代码片段，您需要在连续的行上使用`…`：

    ```py
    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],
    ...                   columns=['A', 'B']) 
    ```

+   如果您想展示引发异常的情况，可以这样做：

    ```py
    >>> pd.to_datetime(["712-01-01"])
    Traceback (most recent call last):
    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 
    ```

    对于实际错误，包含“Traceback（最近的调用最后）”是至关重要的，但实际错误只需要错误名称即可。

+   如果结果中有一小部分可能会变化（例如对象表示中的哈希），您可以使用`...`表示此部分。

    如果您想展示 `s.plot()` 返回 matplotlib AxesSubplot 对象，这将导致 doctest 失败

    ```py
    >>> s.plot()
    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> 
    ```

    然而，您可以这样做（注意需要添加的注释）

    ```py
    >>> s.plot()  
    <matplotlib.axes._subplots.AxesSubplot at ...> 
    ```

#### 示例中的图表

pandas 中有一些返回图表的方法。为了渲染文档中示例生成的图表，存在`.. plot::`指令。

要使用它，请按照下面所示的“示例”标题后面放置下一个代码。生成文档时，图将自动生成。

```py
class Series:
    def plot(self):
  """
 Generate a plot with the ``Series`` data.

 Examples
 --------

 .. plot::
 :context: close-figs

 >>> ser = pd.Series([1, 2, 3])
 >>> ser.plot()
 """
        pass 
```

## 共享文档字符串

pandas 有一个用于在类之间共享文档字符串的系统，其中略有不同。这帮助我们保持文档字符串的一致性，同时保持用户阅读时的清晰度。在编写时会带来一些复杂性的代价。

每个共享文档字符串都将具有基本模板和变量，如`{klass}`。稍后使用`doc`装饰器填充变量。最后，文档字符串也可以使用`doc`装饰器附加。

在这个例子中，我们将以正常方式创建一个父文档字符串（这类似于 `pandas.core.generic.NDFrame`）。然后我们会有两个子文档字符串（像 `pandas.core.series.Series` 和 `pandas.core.frame.DataFrame`）。我们将在这个文档字符串中替换类名。

```py
class Parent:
    @doc(klass="Parent")
    def my_function(self):
  """Apply my function to {klass}."""
        ...

class ChildA(Parent):
    @doc(Parent.my_function, klass="ChildA")
    def my_function(self):
        ...

class ChildB(Parent):
    @doc(Parent.my_function, klass="ChildB")
    def my_function(self):
        ... 
```

结果文档字符串是

```py
>>> print(Parent.my_function.__doc__)
Apply my function to Parent.
>>> print(ChildA.my_function.__doc__)
Apply my function to ChildA.
>>> print(ChildB.my_function.__doc__)
Apply my function to ChildB. 
```

注意：

1.  我们将父文档字符串“附加”到最初为空的子文档字符串上。

我们的文件通常包含一个模块级别的`_shared_doc_kwargs`，其中包含一些常见的替换值（如`klass`、`axes`等）。

您可以使用类似于以下内容的一次性替换和附加：

```py
@doc(template, **_shared_doc_kwargs)
def my_function(self):
    ... 
```

其中`template`可能来自一个模块级别的`_shared_docs`字典，将函数名映射到文档字符串。在可能的情况下，我们更喜欢使用`doc`，因为文档字符串编写过程稍微接近于正常。

参见 `pandas.core.generic.NDFrame.fillna` 以获取示例模板，以及填充版本的 `pandas.core.series.Series.fillna` 和 `pandas.core.generic.frame.fillna`。
