- en: scipy.interpolate.CubicSpline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.interpolate.CubicSpline.html#scipy.interpolate.CubicSpline](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.interpolate.CubicSpline.html#scipy.interpolate.CubicSpline)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Cubic spline data interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolate data with a piecewise cubic polynomial which is twice continuously
    differentiable [[1]](#r0cc18619484f-1). The result is represented as a [`PPoly`](scipy.interpolate.PPoly.html#scipy.interpolate.PPoly
    "scipy.interpolate.PPoly") instance with breakpoints matching the given data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D array containing values of the independent variable. Values must be real,
    finite and in strictly increasing order.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Array containing values of the dependent variable. It can have arbitrary number
    of dimensions, but the length along `axis` (see below) must match the length of
    `x`. Values must be finite.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Axis along which *y* is assumed to be varying. Meaning that for `x[i]` the corresponding
    values are `np.take(y, i, axis=axis)`. Default is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**bc_type**string or 2-tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Boundary condition type. Two additional equations, given by the boundary conditions,
    are required to determine all coefficients of polynomials on each segment [[2]](#r0cc18619484f-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'If *bc_type* is a string, then the specified condition will be applied at both
    ends of a spline. Available conditions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘not-a-knot’ (default): The first and second segment at a curve end are the
    same polynomial. It is a good default when there is no information on boundary
    conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘periodic’: The interpolated functions is assumed to be periodic of period
    `x[-1] - x[0]`. The first and last value of *y* must be identical: `y[0] == y[-1]`.
    This boundary condition will result in `y''[0] == y''[-1]` and `y''''[0] == y''''[-1]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘clamped’: The first derivative at curves ends are zero. Assuming a 1D *y*,
    `bc_type=((1, 0.0), (1, 0.0))` is the same condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘natural’: The second derivative at curve ends are zero. Assuming a 1D *y*,
    `bc_type=((2, 0.0), (2, 0.0))` is the same condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If *bc_type* is a 2-tuple, the first and the second value will be applied at
    the curve start and end respectively. The tuple values can be one of the previously
    mentioned strings (except ‘periodic’) or a tuple *(order, deriv_values)* allowing
    to specify arbitrary derivatives at curve ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '*order*: the derivative order, 1 or 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*deriv_value*: array_like containing derivative values, shape must be the same
    as *y*, excluding `axis` dimension. For example, if *y* is 1-D, then *deriv_value*
    must be a scalar. If *y* is 3-D with the shape (n0, n1, n2) and axis=2, then *deriv_value*
    must be 2-D and have the shape (n0, n1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**extrapolate**{bool, ‘periodic’, None}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If bool, determines whether to extrapolate to out-of-bounds points based on
    first and last intervals, or to return NaNs. If ‘periodic’, periodic extrapolation
    is used. If None (default), `extrapolate` is set to ‘periodic’ for `bc_type='periodic'`
    and to True otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Akima1DInterpolator`](scipy.interpolate.Akima1DInterpolator.html#scipy.interpolate.Akima1DInterpolator
    "scipy.interpolate.Akima1DInterpolator")'
  prefs: []
  type: TYPE_NORMAL
- en: Akima 1D interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PchipInterpolator`](scipy.interpolate.PchipInterpolator.html#scipy.interpolate.PchipInterpolator
    "scipy.interpolate.PchipInterpolator")'
  prefs: []
  type: TYPE_NORMAL
- en: PCHIP 1-D monotonic cubic interpolator.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PPoly`](scipy.interpolate.PPoly.html#scipy.interpolate.PPoly "scipy.interpolate.PPoly")'
  prefs: []
  type: TYPE_NORMAL
- en: Piecewise polynomial in terms of coefficients and breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Parameters *bc_type* and `extrapolate` work independently, i.e. the former controls
    only construction of a spline, and the latter only evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: When a boundary condition is ‘not-a-knot’ and n = 2, it is replaced by a condition
    that the first derivative is equal to the linear interpolant slope. When both
    boundary conditions are ‘not-a-knot’ and n = 3, the solution is sought as a parabola
    passing through given points.
  prefs: []
  type: TYPE_NORMAL
- en: When ‘not-a-knot’ boundary conditions is applied to both ends, the resulting
    spline will be the same as returned by [`splrep`](scipy.interpolate.splrep.html#scipy.interpolate.splrep
    "scipy.interpolate.splrep") (with `s=0`) and [`InterpolatedUnivariateSpline`](scipy.interpolate.InterpolatedUnivariateSpline.html#scipy.interpolate.InterpolatedUnivariateSpline
    "scipy.interpolate.InterpolatedUnivariateSpline"), but these two methods use a
    representation in B-spline basis.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.18.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cubic Spline Interpolation](https://en.wikiversity.org/wiki/Cubic_Spline_Interpolation)
    on Wikiversity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: Carl de Boor, “A Practical Guide to Splines”, Springer-Verlag, 1978.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: In this example the cubic spline is used to interpolate a sampled sinusoid.
    You can see that the spline continuity property holds for the first and second
    derivatives and violates only for the third derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-interpolate-CubicSpline-1_00_00.png](../Images/1ed792c6a9be605a58e54ab8ca6c633a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the second example, the unit circle is interpolated with a spline. A periodic
    boundary condition is used. You can see that the first derivative values, ds/dx=0,
    ds/dy=1 at the periodic point (1, 0) are correctly computed. Note that a circle
    cannot be exactly represented by a cubic spline. To increase precision, more breakpoints
    would be required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-interpolate-CubicSpline-1_01_00.png](../Images/e23855c3f78b64b4120b122fd527e722.png)'
  prefs: []
  type: TYPE_IMG
- en: The third example is the interpolation of a polynomial y = x**3 on the interval
    0 <= x<= 1\. A cubic spline can represent this function exactly. To achieve that
    we need to specify values and first derivatives at endpoints of the interval.
    Note that y’ = 3 * x**2 and thus y’(0) = 0 and y’(1) = 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints. The same `x` which was passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '**c**ndarray, shape (4, n-1, …)'
  prefs: []
  type: TYPE_NORMAL
- en: Coefficients of the polynomials on each segment. The trailing dimensions match
    the dimensions of *y*, excluding `axis`. For example, if *y* is 1-d, then `c[k,
    i]` is a coefficient for `(x-x[i])**(3-k)` on the segment between `x[i]` and `x[i+1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation axis. The same axis which was passed to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| [`__call__`](scipy.interpolate.CubicSpline.__call__.html#scipy.interpolate.CubicSpline.__call__
    "scipy.interpolate.CubicSpline.__call__")(x[, nu, extrapolate]) | Evaluate the
    piecewise polynomial or its derivative. |'
  prefs: []
  type: TYPE_TB
- en: '| [`derivative`](scipy.interpolate.CubicSpline.derivative.html#scipy.interpolate.CubicSpline.derivative
    "scipy.interpolate.CubicSpline.derivative")([nu]) | Construct a new piecewise
    polynomial representing the derivative. |'
  prefs: []
  type: TYPE_TB
- en: '| [`antiderivative`](scipy.interpolate.CubicSpline.antiderivative.html#scipy.interpolate.CubicSpline.antiderivative
    "scipy.interpolate.CubicSpline.antiderivative")([nu]) | Construct a new piecewise
    polynomial representing the antiderivative. |'
  prefs: []
  type: TYPE_TB
- en: '| [`integrate`](scipy.interpolate.CubicSpline.integrate.html#scipy.interpolate.CubicSpline.integrate
    "scipy.interpolate.CubicSpline.integrate")(a, b[, extrapolate]) | Compute a definite
    integral over a piecewise polynomial. |'
  prefs: []
  type: TYPE_TB
- en: '| [`roots`](scipy.interpolate.CubicSpline.roots.html#scipy.interpolate.CubicSpline.roots
    "scipy.interpolate.CubicSpline.roots")([discontinuity, extrapolate]) | Find real
    roots of the piecewise polynomial. |'
  prefs: []
  type: TYPE_TB
