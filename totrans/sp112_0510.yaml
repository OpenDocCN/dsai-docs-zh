- en: scipy.signal.choose_conv_method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.choose_conv_method.html#scipy.signal.choose_conv_method](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.choose_conv_method.html#scipy.signal.choose_conv_method)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find the fastest convolution/correlation method.
  prefs: []
  type: TYPE_NORMAL
- en: This primarily exists to be called during the `method='auto'` option in [`convolve`](scipy.signal.convolve.html#scipy.signal.convolve
    "scipy.signal.convolve") and [`correlate`](scipy.signal.correlate.html#scipy.signal.correlate
    "scipy.signal.correlate"). It can also be used to determine the value of `method`
    for many different convolutions of the same dtype/shape. In addition, it supports
    timing the convolution to adapt the value of `method` to a particular set of inputs
    and/or hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**in1**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument passed into the convolution function.
  prefs: []
  type: TYPE_NORMAL
- en: '**in2**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The second argument passed into the convolution function.
  prefs: []
  type: TYPE_NORMAL
- en: '**mode**str {‘full’, ‘valid’, ‘same’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'A string indicating the size of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`full`'
  prefs: []
  type: TYPE_NORMAL
- en: The output is the full discrete linear convolution of the inputs. (Default)
  prefs: []
  type: TYPE_NORMAL
- en: '`valid`'
  prefs: []
  type: TYPE_NORMAL
- en: The output consists only of those elements that do not rely on the zero-padding.
  prefs: []
  type: TYPE_NORMAL
- en: '`same`'
  prefs: []
  type: TYPE_NORMAL
- en: The output is the same size as *in1*, centered with respect to the ‘full’ output.
  prefs: []
  type: TYPE_NORMAL
- en: '**measure**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, run and time the convolution of *in1* and *in2* with both methods and
    return the fastest. If False (default), predict the fastest method using precomputed
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str'
  prefs: []
  type: TYPE_NORMAL
- en: A string indicating which convolution method is fastest, either ‘direct’ or
    ‘fft’
  prefs: []
  type: TYPE_NORMAL
- en: '**times**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary containing the times (in seconds) needed for each method. This
    value is only returned if `measure=True`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`convolve`](scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`correlate`](scipy.signal.correlate.html#scipy.signal.correlate "scipy.signal.correlate")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Generally, this method is 99% accurate for 2D signals and 85% accurate for 1D
    signals for randomly chosen input sizes. For precision, use `measure=True` to
    find the fastest method by timing the convolution. This can be used to avoid the
    minimal overhead of finding the fastest `method` later, or to adapt the value
    of `method` to a particular set of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiments were run on an Amazon EC2 r5a.2xlarge machine to test this function.
    These experiments measured the ratio between the time required when using `method=''auto''`
    and the time required for the fastest method (i.e., `ratio = time_auto / min(time_fft,
    time_direct)`). In these experiments, we found:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a 95% chance of this ratio being less than 1.5 for 1D signals and a
    99% chance of being less than 2.5 for 2D signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ratio was always less than 2.5/5 for 1D/2D signals respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function is most inaccurate for 1D convolutions that take between 1 and
    10 milliseconds with `method='direct'`. A good proxy for this (at least in our
    experiments) is `1e6 <= in1.size * in2.size <= 1e7`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 2D results almost certainly generalize to 3D/4D/etc because the implementation
    is the same (the 1D implementation is different).
  prefs: []
  type: TYPE_NORMAL
- en: All the numbers above are specific to the EC2 machine. However, we did find
    that this function generalizes fairly decently across hardware. The speed tests
    were of similar quality (and even slightly better) than the same tests performed
    on the machine to tune this function’s numbers (a mid-2014 15-inch MacBook Pro
    with 16GB RAM and a 2.5GHz Intel i7 processor).
  prefs: []
  type: TYPE_NORMAL
- en: There are cases when [`fftconvolve`](scipy.signal.fftconvolve.html#scipy.signal.fftconvolve
    "scipy.signal.fftconvolve") supports the inputs but this function returns *direct*
    (e.g., to protect against floating point integer precision).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.19.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Estimate the fastest method for a given input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be applied to other arrays of the same dtype and shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output of this function (`method`) works with [`correlate`](scipy.signal.correlate.html#scipy.signal.correlate
    "scipy.signal.correlate") and [`convolve`](scipy.signal.convolve.html#scipy.signal.convolve
    "scipy.signal.convolve").
  prefs: []
  type: TYPE_NORMAL
