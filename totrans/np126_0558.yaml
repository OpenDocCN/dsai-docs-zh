- en: numpy.einsum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.einsum.html](https://numpy.org/doc/1.26/reference/generated/numpy.einsum.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates the Einstein summation convention on the operands.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Einstein summation convention, many common multi-dimensional, linear
    algebraic array operations can be represented in a simple fashion. In *implicit*
    mode [`einsum`](#numpy.einsum "numpy.einsum") computes these values.
  prefs: []
  type: TYPE_NORMAL
- en: In *explicit* mode, [`einsum`](#numpy.einsum "numpy.einsum") provides further
    flexibility to compute other array operations that might not be considered classical
    Einstein summation operations, by disabling, or forcing summation over specified
    subscript labels.
  prefs: []
  type: TYPE_NORMAL
- en: See the notes and examples for clarification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subscripts**str'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the subscripts for summation as comma separated list of subscript
    labels. An implicit (classical Einstein summation) calculation is performed unless
    the explicit indicator ‘->’ is included as well as subscript labels of the precise
    output form.
  prefs: []
  type: TYPE_NORMAL
- en: '**operands**list of array_like'
  prefs: []
  type: TYPE_NORMAL
- en: These are the arrays for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**out**ndarray, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, the calculation is done into this array.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**{data-type, None}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, forces the calculation to use the data type specified. Note that
    you may have to also give a more liberal *casting* parameter to allow the conversions.
    Default is None.
  prefs: []
  type: TYPE_NORMAL
- en: '**order**{‘C’, ‘F’, ‘A’, ‘K’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Controls the memory layout of the output. ‘C’ means it should be C contiguous.
    ‘F’ means it should be Fortran contiguous, ‘A’ means it should be ‘F’ if the inputs
    are all ‘F’, ‘C’ otherwise. ‘K’ means it should be as close to the layout as the
    inputs as is possible, including arbitrarily permuted axes. Default is ‘K’.
  prefs: []
  type: TYPE_NORMAL
- en: '**casting**{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Controls what kind of data casting may occur. Setting this to ‘unsafe’ is not
    recommended, as it can adversely affect accumulations.
  prefs: []
  type: TYPE_NORMAL
- en: ‘no’ means the data types should not be cast at all.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘equiv’ means only byte-order changes are allowed.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘safe’ means only casts which can preserve values are allowed.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘same_kind’ means only safe casts or casts within a kind, like float64 to float32,
    are allowed.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘unsafe’ means any data conversions may be done.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is ‘safe’.
  prefs: []
  type: TYPE_NORMAL
- en: '**optimize**{False, True, ‘greedy’, ‘optimal’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Controls if intermediate optimization should occur. No optimization will occur
    if False and True will default to the ‘greedy’ algorithm. Also accepts an explicit
    contraction list from the `np.einsum_path` function. See `np.einsum_path` for
    more details. Defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**output**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The calculation based on the Einstein summation convention.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`einsum_path`](numpy.einsum_path.html#numpy.einsum_path "numpy.einsum_path"),
    [`dot`](numpy.dot.html#numpy.dot "numpy.dot"), [`inner`](numpy.inner.html#numpy.inner
    "numpy.inner"), [`outer`](numpy.outer.html#numpy.outer "numpy.outer"), [`tensordot`](numpy.tensordot.html#numpy.tensordot
    "numpy.tensordot"), [`linalg.multi_dot`](numpy.linalg.multi_dot.html#numpy.linalg.multi_dot
    "numpy.linalg.multi_dot")'
  prefs: []
  type: TYPE_NORMAL
- en: '`einops`'
  prefs: []
  type: TYPE_NORMAL
- en: 'similar verbose interface is provided by [einops](https://github.com/arogozhnikov/einops)
    package to cover additional operations: transpose, reshape/flatten, repeat/tile,
    squeeze/unsqueeze and reductions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`opt_einsum`'
  prefs: []
  type: TYPE_NORMAL
- en: '[opt_einsum](https://optimized-einsum.readthedocs.io/en/stable/) optimizes
    contraction order for einsum-like expressions in backend-agnostic manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: The Einstein summation convention can be used to compute many multi-dimensional,
    linear algebraic array operations. [`einsum`](#numpy.einsum "numpy.einsum") provides
    a succinct way of representing these.
  prefs: []
  type: TYPE_NORMAL
- en: 'A non-exhaustive list of these operations, which can be computed by [`einsum`](#numpy.einsum
    "numpy.einsum"), is shown below along with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Trace of an array, [`numpy.trace`](numpy.trace.html#numpy.trace "numpy.trace").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a diagonal, [`numpy.diag`](numpy.diag.html#numpy.diag "numpy.diag").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array axis summations, [`numpy.sum`](numpy.sum.html#numpy.sum "numpy.sum").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transpositions and permutations, [`numpy.transpose`](numpy.transpose.html#numpy.transpose
    "numpy.transpose").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix multiplication and dot product, [`numpy.matmul`](numpy.matmul.html#numpy.matmul
    "numpy.matmul") [`numpy.dot`](numpy.dot.html#numpy.dot "numpy.dot").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector inner and outer products, [`numpy.inner`](numpy.inner.html#numpy.inner
    "numpy.inner") [`numpy.outer`](numpy.outer.html#numpy.outer "numpy.outer").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting, element-wise and scalar multiplication, [`numpy.multiply`](numpy.multiply.html#numpy.multiply
    "numpy.multiply").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tensor contractions, [`numpy.tensordot`](numpy.tensordot.html#numpy.tensordot
    "numpy.tensordot").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chained array operations, in efficient calculation order, [`numpy.einsum_path`](numpy.einsum_path.html#numpy.einsum_path
    "numpy.einsum_path").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscripts string is a comma-separated list of subscript labels, where each
    label refers to a dimension of the corresponding operand. Whenever a label is
    repeated it is summed, so `np.einsum('i,i', a, b)` is equivalent to [`np.inner(a,b)`](numpy.inner.html#numpy.inner
    "numpy.inner"). If a label appears only once, it is not summed, so `np.einsum('i',
    a)` produces a view of `a` with no changes. A further example `np.einsum('ij,jk',
    a, b)` describes traditional matrix multiplication and is equivalent to [`np.matmul(a,b)`](numpy.matmul.html#numpy.matmul
    "numpy.matmul"). Repeated subscript labels in one operand take the diagonal. For
    example, `np.einsum('ii', a)` is equivalent to [`np.trace(a)`](numpy.trace.html#numpy.trace
    "numpy.trace").
  prefs: []
  type: TYPE_NORMAL
- en: In *implicit mode*, the chosen subscripts are important since the axes of the
    output are reordered alphabetically. This means that `np.einsum('ij', a)` doesn’t
    affect a 2D array, while `np.einsum('ji', a)` takes its transpose. Additionally,
    `np.einsum('ij,jk', a, b)` returns a matrix multiplication, while, `np.einsum('ij,jh',
    a, b)` returns the transpose of the multiplication since subscript ‘h’ precedes
    subscript ‘i’.
  prefs: []
  type: TYPE_NORMAL
- en: In *explicit mode* the output can be directly controlled by specifying output
    subscript labels. This requires the identifier ‘->’ as well as the list of output
    subscript labels. This feature increases the flexibility of the function since
    summing can be disabled or forced when required. The call `np.einsum('i->', a)`
    is like [`np.sum(a, axis=-1)`](numpy.sum.html#numpy.sum "numpy.sum"), and `np.einsum('ii->i',
    a)` is like [`np.diag(a)`](numpy.diag.html#numpy.diag "numpy.diag"). The difference
    is that [`einsum`](#numpy.einsum "numpy.einsum") does not allow broadcasting by
    default. Additionally `np.einsum('ij,jh->ih', a, b)` directly specifies the order
    of the output subscript labels and therefore returns matrix multiplication, unlike
    the example above in implicit mode.
  prefs: []
  type: TYPE_NORMAL
- en: To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting
    is done by adding an ellipsis to the left of each term, like `np.einsum('...ii->...i',
    a)`. To take the trace along the first and last axes, you can do `np.einsum('i...i',
    a)`, or to do a matrix-matrix product with the left-most indices instead of rightmost,
    one can do `np.einsum('ij...,jk...->ik...', a, b)`.
  prefs: []
  type: TYPE_NORMAL
- en: When there is only one operand, no axes are summed, and no output parameter
    is provided, a view into the operand is returned instead of a new array. Thus,
    taking the diagonal as `np.einsum('ii->i', a)` produces a view (changed in version
    1.10.0).
  prefs: []
  type: TYPE_NORMAL
- en: '[`einsum`](#numpy.einsum "numpy.einsum") also provides an alternative way to
    provide the subscripts and operands as `einsum(op0, sublist0, op1, sublist1, ...,
    [sublistout])`. If the output shape is not provided in this format [`einsum`](#numpy.einsum
    "numpy.einsum") will be calculated in implicit mode, otherwise it will be performed
    explicitly. The examples below have corresponding [`einsum`](#numpy.einsum "numpy.einsum")
    calls with the two parameter methods.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.10.0.
  prefs: []
  type: TYPE_NORMAL
- en: Views returned from einsum are now writeable whenever the input array is writeable.
    For example, `np.einsum('ijk...->kji...', a)` will now have the same effect as
    [`np.swapaxes(a, 0, 2)`](numpy.swapaxes.html#numpy.swapaxes "numpy.swapaxes")
    and `np.einsum('ii->i', a)` will return a writeable view of the diagonal of a
    2D array.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.12.0.
  prefs: []
  type: TYPE_NORMAL
- en: Added the `optimize` argument which will optimize the contraction order of an
    einsum expression. For a contraction with three or more operands this can greatly
    increase the computational efficiency at the cost of a larger memory footprint
    during computation.
  prefs: []
  type: TYPE_NORMAL
- en: Typically a ‘greedy’ algorithm is applied which empirical tests have shown returns
    the optimal path in the majority of cases. In some cases ‘optimal’ will return
    the superlative path through a more expensive, exhaustive search. For iterative
    calculations it may be advisable to calculate the optimal path once and reuse
    that path by supplying it as an argument. An example is given below.
  prefs: []
  type: TYPE_NORMAL
- en: See [`numpy.einsum_path`](numpy.einsum_path.html#numpy.einsum_path "numpy.einsum_path")
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Trace of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the diagonal (requires explicit form):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sum over an axis (requires explicit form):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For higher dimensional arrays summing a single axis can be done with ellipsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute a matrix transpose, or reorder any number of axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Vector inner products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Matrix vector multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Broadcasting and scalar multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Vector outer product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Tensor contraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Writeable returned arrays (since version 1.10.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of ellipsis use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Chained array operations. For more complicated contractions, speed ups might
    be achieved by repeatedly computing a ‘greedy’ path or pre-computing the ‘optimal’
    path and repeatedly applying it, using an [`einsum_path`](numpy.einsum_path.html#numpy.einsum_path
    "numpy.einsum_path") insertion (since version 1.12.0). Performance improvements
    can be particularly significant with larger arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic [`einsum`](#numpy.einsum "numpy.einsum"): ~1520ms (benchmarked on 3.1GHz
    Intel i5.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Sub-optimal [`einsum`](#numpy.einsum "numpy.einsum") (due to repeated path
    calculation time): ~330ms'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Greedy [`einsum`](#numpy.einsum "numpy.einsum") (faster optimal path approximation):
    ~160ms'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Optimal [`einsum`](#numpy.einsum "numpy.einsum") (best usage pattern in some
    use cases): ~110ms'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
