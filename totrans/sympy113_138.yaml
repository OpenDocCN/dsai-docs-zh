- en: Number Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数论
- en: Original text：[https://docs.sympy.org/latest/modules/ntheory.html](https://docs.sympy.org/latest/modules/ntheory.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/ntheory.html](https://docs.sympy.org/latest/modules/ntheory.html)
- en: '## Ntheory Class Reference'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## Ntheory 类参考'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.
    When a lookup is requested involving an odd number that has not been sieved, the
    sieve is automatically extended up to that number. Implementation details limit
    the number of primes to `2^32-1`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 质数列表，实现为动态增长的埃拉托斯特尼筛。当请求涉及尚未筛选的奇数时，筛网自动扩展至该数。实现细节限制了质数数量为 `2^32-1`。
- en: Examples
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Grow the sieve to cover all primes <= n.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展筛以涵盖所有小于等于 n 的质数。
- en: Examples
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extend to include the ith prime number.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展以包括第 i 个质数。
- en: 'Parameters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**i** : integer'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**：整数'
- en: Examples
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notes
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: The list is extended by 50% if it is too short, so it is likely that it will
    be longer than requested.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表过短，会增加 50%，因此它很可能比请求的要长。
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Generate all mobius numbers for the range [a, b).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成范围 [a, b) 内的所有莫比乌斯函数数。
- en: 'Parameters:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: First number in range
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 范围内的第一个数字
- en: '**b** : integer'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**b**：整数'
- en: First number outside of range
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 超出范围的第一个数字
- en: Examples
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generate all prime numbers in the range [2, a) or [a, b).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成范围 [2, a) 或 [a, b) 内的所有质数。
- en: Examples
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All primes less than 19:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小于 19 的所有质数：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All primes greater than or equal to 7 and less than 19:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大于等于 7 且小于 19 的所有质数：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All primes through the 10th prime
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第 10 个质数的所有质数
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Return the indices i, j of the primes that bound n.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 返回界定 n 的质数的索引 i, j。
- en: If n is prime then i == j.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 n 是质数，则 i == j。
- en: Although n can be an expression, if ceiling cannot convert it to an integer
    then an n error will be raised.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 n 可以是一个表达式，但如果 ceiling 不能将其转换为整数，则会引发一个 n 错误。
- en: Examples
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE14]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Generate all totient numbers for the range [a, b).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生成范围 [a, b) 内的所有欧拉函数数。
- en: Examples
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE16]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ntheory Functions Reference
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ntheory 函数参考
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3,
    etc…. The nth prime is approximately \(n\log(n)\).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 n 个质数，质数索引为 prime(1) = 2, prime(2) = 3，等等… 第 n 个质数大约是 \(n\log(n)\)。
- en: Logarithmic integral of \(x\) is a pretty nice approximation for number of primes
    \(\le x\), i.e. li(x) ~ pi(x) In fact, for the numbers we are concerned about(
    x<1e11 ), li(x) - pi(x) < 50000
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 x 的对数积分是小于等于 x 的质数数的一个相当不错的近似值，即 li(x) ~ pi(x) 实际上，对于我们关心的数字（ x<1e11 ），li(x)
    - pi(x) < 50000
- en: Also, li(x) > pi(x) can be safely assumed for the numbers which can be evaluated
    by this function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以安全地假设对于此函数可以评估的数字，li(x) > pi(x)。
- en: Here, we find the least integer m such that li(m) > n using binary search. Now
    pi(m-1) < li(m-1) <= n,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用二分查找找到最小的整数 m，使得 li(m) > n。现在 pi(m-1) < li(m-1) <= n，
- en: We find pi(m - 1) using primepi function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `primepi` 函数找到 pi(m - 1)。
- en: Starting from m, we have to find n - pi(m-1) more primes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从 m 开始，我们必须找到 n - pi(m-1) 更多的质数。
- en: For the inputs this implementation can handle, we will have to test primality
    for at max about 10**5 numbers, to get our answer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此实现可以处理的输入，我们最多需要测试约 10**5 个数的素性以获得答案。
- en: Examples
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
- en: Test if n is prime
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 n 是否为质数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有质数
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
- en: Return the number of primes less than or equal to n
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于 n 的质数的数量
- en: References
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[R648](#id1)]'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R648](#id1)]'
- en: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29](https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29](https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29)'
- en: '[[R649](#id2)]'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R649](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number](https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number](https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number)'
- en: '[[R650](#id3)]'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R650](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Skewes%27_number](https://en.wikipedia.org/wiki/Skewes%27_number)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Skewes%27_number](https://en.wikipedia.org/wiki/Skewes%27_number)'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Represents the prime counting function pi(n) = the number of prime numbers less
    than or equal to n.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表示质数计数函数pi(n) = 小于或等于n的质数的数量。
- en: 'Deprecated since version 1.13: The `primepi` function is deprecated. Use [`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.13开始不推荐使用：`primepi`函数已弃用。请改用[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi")。有关更多信息，请参阅其文档。有关详细信息，请参阅[从ntheory移动到functions的符号函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: 'Algorithm Description:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 算法描述：
- en: In sieve method, we remove all multiples of prime p except p itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在筛法中，我们移除所有质数p的倍数，除了p本身。
- en: Let phi(i,j) be the number of integers 2 <= k <= i which remain after sieving
    from primes less than or equal to j. Clearly, pi(n) = phi(n, sqrt(n))
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让phi(i,j)为从小于或等于j的质数中筛除后剩余的2 <= k <= i的整数数量。显然，pi(n) = phi(n, sqrt(n))
- en: If j is not a prime, phi(i,j) = phi(i, j - 1)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果j不是一个质数，phi(i,j) = phi(i, j - 1)
- en: if j is a prime, We remove all numbers(except j) whose smallest prime factor
    is j.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果j是一个质数，我们删除所有最小质因数为j的数（除了j本身）。
- en: Let \(x= j \times a\) be such a number, where \(2 \le a \le i / j\) Now, after
    sieving from primes \(\le j - 1\), a must remain (because x, and hence a has no
    prime factor \(\le j - 1\)) Clearly, there are phi(i / j, j - 1) such a which
    remain on sieving from primes \(\le j - 1\)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让\(x= j \times a\)为这样一个数，其中\(2 \le a \le i / j\)。现在，在从质数\(\le j - 1\)中筛选后，a必须保留（因为x，因此a没有质因数\(\le
    j - 1\)）。显然，有phi(i / j, j - 1)个这样的a在从质数\(\le j - 1\)中筛选后保留。
- en: 'Now, if a is a prime less than equal to j - 1, \(x= j \times a\) has smallest
    prime factor = a, and has already been removed(by sieving from a). So, we do not
    need to remove it again. (Note: there will be pi(j - 1) such x)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果a是小于等于j-1的质数，\(x= j \times a\) 的最小质因数为a，并且已经被移除（通过筛法从a中）。因此，我们不需要再次移除它。（注意：这样的x有pi(j-1)个）
- en: 'Thus, number of x, that will be removed are: phi(i / j, j - 1) - phi(j - 1,
    j - 1) (Note that pi(j - 1) = phi(j - 1, j - 1))'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将被移除的x的数量为：phi(i / j, j - 1) - phi(j - 1, j - 1)（注意pi(j - 1) = phi(j - 1,
    j - 1)）
- en: \(\Rightarrow\) phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j
    - 1)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: \(\Rightarrow\) phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j
    - 1)
- en: 'So,following recursion is used and implemented as dp:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用以下递归并实现dp：
- en: phi(a, b) = phi(a, b - 1), if b is not a prime phi(a, b) = phi(a, b-1)-phi(a
    / b, b-1) + phi(b-1, b-1), if b is prime
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: phi(a, b) = phi(a, b - 1)，如果b不是质数phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1,
    b-1)，如果b是质数
- en: Clearly a is always of the form floor(n / k), which can take at most \(2\sqrt{n}\)
    values. Two arrays arr1,arr2 are maintained arr1[i] = phi(i, j), arr2[i] = phi(n
    // i, j)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然a总是形式为floor(n / k)，最多可以取\(2\sqrt{n}\)个值。维护两个数组arr1，arr2，arr1[i] = phi(i, j)，arr2[i]
    = phi(n // i, j)
- en: Finally the answer is arr2[1]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的答案是arr2[1]
- en: Examples
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So there are 9 primes less than or equal to 25\. Is 25 prime?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，小于或等于25的有9个质数。25是质数吗？
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is not. So the first prime less than 25 must be the 9th prime:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不是。因此，小于25的第一个质数必须是第9个质数：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
- en: Test if n is prime
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试n是否为质数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有的质数
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
- en: Return the nth prime
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第n个质数
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Return the ith prime greater than n.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回大于n的第ith个质数。
- en: 'Parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 整数'
- en: '**ith** : positive integer'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**ith** : 正整数'
- en: 'Returns:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**int** : Return the ith prime greater than n'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**int** : 返回大于n的第ith个质数'
- en: 'Raises:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 异常：
- en: '**ValueError**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: If `ith <= 0`. If `n` or `ith` is not an integer.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`ith <= 0`。如果`n`或`ith`不是整数。
- en: Notes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Potential primes are located at 6*j +/- 1\. This property is used during searching.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的质数位于6*j +/- 1。这个性质在搜索中被使用。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
- en: Return the largest prime smaller than n
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于 n 的最大素数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 生成给定范围内的所有素数
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Return the largest prime smaller than n.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于 n 的最大素数。
- en: Notes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Potential primes are located at 6*j +/- 1\. This property is used during searching.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的素数位于 6*j +/- 1。这个性质在搜索时使用。
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
- en: Return the ith prime greater than n
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回大于 n 的第 i 个素数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generates all primes in a given range
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成给定范围内的所有素数
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Generate a list of all prime numbers in the range [2, a), or [a, b).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生成范围为 [2, a) 或 [a, b) 的所有素数列表。
- en: If the range exists in the default sieve, the values will be returned from there;
    otherwise values will be returned but will not modify the sieve.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认筛选器中存在范围，则将从那里返回值；否则将返回值但不会修改筛选器。
- en: Examples
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All primes less than 19:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 小于 19 的所有素数：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All primes greater than or equal to 7 and less than 19:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或等于 7 且小于 19 的所有素数：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All primes through the 10th prime
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有小于第 10 个素数的素数
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Sieve method, primerange, is generally faster but it will occupy more memory
    as the sieve stores values. The default instance of Sieve, named sieve, can be
    used:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 筛法方法 primerange 通常更快，但由于筛选器存储值，内存占用更多。可以使用名为 sieve 的默认筛选器实例：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notes
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: 'Some famous conjectures about the occurrence of primes in a given range are
    [1]:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于素数出现频率的著名猜想是 [1]：
- en: 'Twin primes: though often not, the following will give 2 primes'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 孪生素数：尽管经常不是，以下将给出两个素数
- en: 'an infinite number of times:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无限次数：
- en: primerange(6*n - 1, 6*n + 2)
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: primerange(6*n - 1, 6*n + 2)
- en: 'Legendre’s: the following always yields at least one prime'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 勒让德定理：以下始终至少产生一个素数
- en: primerange(n**2, (n+1)**2+1)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: primerange(n**2, (n+1)**2+1)
- en: 'Bertrand’s (proven): there is always a prime in the range'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贝特朗定理（已证明）：在范围内总是有一个素数
- en: primerange(n, 2*n)
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: primerange(n, 2*n)
- en: 'Brocard’s: there are at least four primes in the range'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布洛卡德定理：在给定范围内至少有四个素数
- en: primerange(prime(n)**2, prime(n+1)**2)
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: primerange(prime(n)**2, prime(n+1)**2)
- en: The average gap between primes is log(n) [2]; the gap between primes can be
    arbitrarily large since sequences of composite numbers are arbitrarily large,
    e.g. the numbers in the sequence n! + 2, n! + 3 … n! + n are all composite.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 素数之间的平均间隔是 log(n) [2]；素数之间的间隔可以任意大，因为合数序列可以任意大，例如序列 n! + 2, n! + 3 … n! + n
    中的数字都是合数。
- en: See also
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
- en: Return the nth prime
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 n 个素数
- en: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
- en: Return the ith prime greater than n
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 返回大于 n 的第 i 个素数
- en: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
- en: Return the largest prime smaller than n
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于 n 的最大素数
- en: '[`randprime`](#sympy.ntheory.generate.randprime "sympy.ntheory.generate.randprime")'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[`randprime`](#sympy.ntheory.generate.randprime "sympy.ntheory.generate.randprime")'
- en: Returns a random prime in a given range
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定范围内的随机素数
- en: '[`primorial`](#sympy.ntheory.generate.primorial "sympy.ntheory.generate.primorial")'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primorial`](#sympy.ntheory.generate.primorial "sympy.ntheory.generate.primorial")'
- en: Returns the product of primes based on condition
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基于条件返回素数的乘积
- en: '[`Sieve.primerange`](#sympy.ntheory.generate.Sieve.primerange "sympy.ntheory.generate.Sieve.primerange")'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sieve.primerange`](#sympy.ntheory.generate.Sieve.primerange "sympy.ntheory.generate.Sieve.primerange")'
- en: return range from already computed primes or extend the sieve to contain the
    requested range.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从已计算的素数范围或扩展筛选器以包含所请求范围的范围。
- en: References
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R651](#id4)]'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R651](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
- en: '[[R652](#id5)]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R652](#id5)]'
- en: '[https://primes.utm.edu/notes/gaps.html](https://primes.utm.edu/notes/gaps.html)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://primes.utm.edu/notes/gaps.html](https://primes.utm.edu/notes/gaps.html)'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Return a random prime number in the range [a, b).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在区间 [a, b) 中的随机素数。
- en: Bertrand’s postulate assures that randprime(a, 2*a) will always succeed for
    a > 1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 贝特朗定理确保 randprime(a, 2*a) 对于 a > 1 总是成功。
- en: Note that due to implementation difficulties, the prime numbers chosen are not
    uniformly random. For example, there are two primes in the range [112, 128), `113`
    and `127`, but `randprime(112, 128)` returns `127` with a probability of 15/17.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于实现困难，选择的素数不是均匀随机的。例如，在范围 [112, 128) 中有两个素数 `113` 和 `127`，但 `randprime(112,
    128)` 以 15/17 的概率返回 `127`。
- en: Examples
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有素数
- en: References
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[R653](#id6)]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R653](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Bertrand’s_postulate](https://en.wikipedia.org/wiki/Bertrand''s_postulate)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/贝特朗假设](https://zh.wikipedia.org/wiki/贝特朗假设)'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Returns the product of the first n primes (default) or the primes less than
    or equal to n (when `nth=False`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回前 n 个素数的乘积（默认）或小于等于 n 的素数（当 `nth=False` 时）。
- en: Examples
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: One can argue that the primes are infinite since if you take a set of primes
    and multiply them together (e.g. the primorial) and then add or subtract 1, the
    result cannot be divided by any of the original factors, hence either 1 or more
    new primes must divide this product of primes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以认为素数是无限的，因为如果你取一组素数并将它们相乘（例如，素数阶乘），然后加或减 1，结果不能被任何原始因子之一整除，因此这个素数的乘积必须被除以1或多个新的素数。
- en: 'In this case, the number itself is a new prime:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数本身是一个新的素数：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this case two new primes are the factors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两个新的素数是因子：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, some primes smaller and larger than the primes multiplied together are
    obtained:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，乘在一起的素数比这些素数更大或更小：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有素数
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For a given iterated sequence, return a generator that gives the length of the
    iterated cycle (lambda) and the length of terms before the cycle begins (mu);
    if `values` is True then the terms of the sequence will be returned instead. The
    sequence is started with value `x0`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的迭代序列，返回一个生成器，提供迭代周期的长度（lambda）和循环开始之前的项的长度（mu）；如果 `values` 为 True，则将返回序列的项。序列以值
    `x0` 开始。
- en: 'Note: more than the first lambda + mu terms may be returned and this is the
    cost of cycle detection with Brent’s method; there are, however, generally less
    terms calculated than would have been calculated if the proper ending point were
    determined, e.g. by using Floyd’s method.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：可能会返回多于第一个 lambda + mu 项，这是使用布伦特方法进行循环检测的成本；然而，通常比使用弗洛伊德方法确定的正确结束点计算的项要少。
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will yield successive values of i <– func(i):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生 i <– func(i) 的连续值：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A function is defined:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义如下：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and given a seed of 4 and the mu and lambda terms calculated:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 并给定种子 4 和计算的 mu 和 lambda 项：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can see what is meant by looking at the output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到输出的含义：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are 6 repeating values after the first 3.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 3 之后有 6 个重复值。
- en: 'If a sequence is suspected of being longer than you might wish, `nmax` can
    be used to exit early (and mu will be returned as None):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果怀疑一个序列的长度比你希望的长，可以使用 `nmax` 提前退出（mu 将返回为 None）：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Code modified from:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修改自：
- en: '[https://en.wikipedia.org/wiki/Cycle_detection](https://en.wikipedia.org/wiki/Cycle_detection).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/循环检测](https://zh.wikipedia.org/wiki/循环检测)。'
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Return the nth composite number, with the composite numbers indexed as composite(1)
    = 4, composite(2) = 6, etc….
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 n 个复合数，其中复合数索引为 composite(1) = 4，composite(2) = 6，等等……
- en: Examples
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: See also
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
- en: Test if n is prime
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 n 是否为素数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有素数
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
- en: Return the number of primes less than or equal to n
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于 n 的素数的数量
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
- en: Return the nth prime
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 n 个素数
- en: '[`compositepi`](#sympy.ntheory.generate.compositepi "sympy.ntheory.generate.compositepi")'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[`compositepi`](#sympy.ntheory.generate.compositepi "sympy.ntheory.generate.compositepi")'
- en: Return the number of positive composite numbers less than or equal to n
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于 `n` 的正复合数的数量
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Return the number of positive composite numbers less than or equal to n. The
    first positive composite is 4, i.e. compositepi(4) = 1.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于 `n` 的正复合数的数量。第一个正复合数是 `4`，即 `compositepi(4) = 1`。
- en: Examples
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
- en: Test if n is prime
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `n` 是否为素数
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generate all primes in a given range
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有素数
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
- en: Return the nth prime
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 `n` 个质数
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
- en: Return the number of primes less than or equal to n
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于 `n` 的素数的数量
- en: '[`composite`](#sympy.ntheory.generate.composite "sympy.ntheory.generate.composite")'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[`composite`](#sympy.ntheory.generate.composite "sympy.ntheory.generate.composite")'
- en: Return the nth composite number
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 `n` 个复合数
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Return the B-smooth and B-power smooth values of n.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `n` 的 B-平滑和 B-幂平滑值。
- en: The smoothness of n is the largest prime factor of n; the power- smoothness
    is the largest divisor raised to its multiplicity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`n` 的平滑性是 `n` 的最大素因子；幂平滑性是最大除数升至其重数。'
- en: Examples
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: See also
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p")'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p")'
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Return a list of [m, (p, (M, sm(p + m), psm(p + m)))…] where:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表 `[m, (p, (M, sm(p + m), psm(p + m)))…]` 其中：
- en: p**M is the base-p divisor of n
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`p**M` 是 `n` 的基数 `p` 除数'
- en: sm(p + m) is the smoothness of p + m (m = -1 by default)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sm(p + m)` 是 `p + m` 的平滑性（默认情况下 `m = -1`）'
- en: psm(p + m) is the power smoothness of p + m
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`psm(p + m)` 是 `p + m` 的幂平滑性'
- en: The list is sorted according to smoothness (default) or by power smoothness
    if power=1.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表按平滑性（默认）或按幂平滑性（如果 `power=1`）排序。
- en: The smoothness of the numbers to the left (m = -1) or right (m = 1) of a factor
    govern the results that are obtained from the p +/- 1 type factoring methods.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧（`m = -1`）或右侧（`m = 1`）的平滑性决定了从 `p +/- 1` 类型的因式方法获得的结果。
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If visual=True then an annotated string will be returned:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `visual=True`，则返回带注释的字符串：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This string can also be generated directly from a factorization dictionary
    and vice versa:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该字符串也可以直接从因数分解字典生成，反之亦然：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The table of the output logic is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出逻辑的表格如下：
- en: '|  | Visual |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  | 可视化 |'
- en: '| --- | --- |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input | True | False | other |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 输入 | 真 | 假 | 其他 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| dict | str | tuple | str |'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| dict | str | tuple | str |'
- en: '| str | str | tuple | dict |'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| str | str | tuple | dict |'
- en: '| tuple | str | tuple | str |'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| tuple | str | tuple | str |'
- en: '| n | str | tuple | tuple |'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| n | str | tuple | tuple |'
- en: '| mul | str | tuple | tuple |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| mul | str | tuple | tuple |'
- en: See also
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness")'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness")'
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Find the greatest integer m such that p**m divides n.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最大整数 `m`，使得 `p**m` 可整除 `n`。
- en: Examples
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Note: when checking for the multiplicity of a number in a large factorial it
    is most efficient to send it as an unevaluated factorial or to call `multiplicity_in_factorial`
    directly:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在检查大阶乘中数字的重复性时，最有效的方法是将其作为未评估的阶乘发送或直接调用 `multiplicity_in_factorial`：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`trailing`](core.html#sympy.core.intfunc.trailing "sympy.core.intfunc.trailing")'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[`trailing`](core.html#sympy.core.intfunc.trailing "sympy.core.intfunc.trailing")'
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Return `(b, e)` such that `n` == `b**e` if `n` is a unique perfect power with
    `e > 1`, else `False` (e.g. 1 is not a perfect power). A ValueError is raised
    if `n` is not Rational.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `(b, e)`，使得若 `n` 是具有 `e > 1` 的唯一完全幂，则 `n` == `b**e`，否则返回 `False`（例如 `1` 不是完全幂）。如果
    `n` 不是有理数，则引发 `ValueError`。
- en: By default, the base is recursively decomposed and the exponents collected so
    the largest possible `e` is sought. If `big=False` then the smallest possible
    `e` (thus prime) will be chosen.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基数将递归分解并收集指数，因此寻找最大可能的 `e`。如果 `big=False` 则选择最小可能的 `e`（因此是素数）。
- en: If `factor=True` then simultaneous factorization of `n` is attempted since finding
    a factor indicates the only possible root for `n`. This is True by default since
    only a few small factors will be tested in the course of searching for the perfect
    power.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`factor=True`，则尝试同时因式分解`n`，因为找到一个因子表明`n`的唯一可能根。这是默认值，因为在搜索完美幂的过程中只会测试几个小因子。
- en: The use of `candidates` is primarily for internal use; if provided, False will
    be returned if `n` cannot be written as a power with one of the candidates as
    an exponent and factoring (beyond testing for a factor of 2) will not be attempted.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`candidates`主要是为了内部使用；如果提供，则如果`n`不能写成其中一个候选数的幂，则返回False，并且不会尝试因式分解（超出测试因子2）。
- en: Examples
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Negative numbers can only have odd perfect powers:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 负数只能有奇数完全幂：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Rationals are also recognized:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数也被识别：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notes
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: To know whether an integer is a perfect power of 2 use
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道一个整数是否是2的完全幂，使用
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is not necessary to provide `candidates`. When provided it will be assumed
    that they are ints. The first one that is larger than the computed maximum possible
    exponent will signal failure for the routine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要提供`candidates`。提供时，假定它们是整数。第一个大于计算的最大可能指数的候选数将为该程序的常规信号。
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.core.intfunc.integer_nthroot`](core.html#sympy.core.intfunc.integer_nthroot
    "sympy.core.intfunc.integer_nthroot"), [`sympy.ntheory.primetest.is_square`](#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square")'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.integer_nthroot`](core.html#sympy.core.intfunc.integer_nthroot
    "sympy.core.intfunc.integer_nthroot")，[`sympy.ntheory.primetest.is_square`](#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square")'
- en: '[PRE66]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Use Pollard’s rho method to try to extract a nontrivial factor of `n`. The returned
    factor may be a composite number. If no factor is found, `None` is returned.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用波拉德ρ方法尝试提取`n`的非平凡因子。返回的因子可能是复合数。如果找不到因子，则返回`None`。
- en: The algorithm generates pseudo-random values of x with a generator function,
    replacing x with F(x). If F is not supplied then the function x**2 + `a` is used.
    The first value supplied to F(x) is `s`. Upon failure (if `retries` is > 0) a
    new `a` and `s` will be supplied; the `a` will be ignored if F was supplied.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 算法使用生成器函数生成x的伪随机值，并用F(x)替换x。如果未提供F，则使用函数x**2 + `a`。提供给F(x)的第一个值是`s`。如果失败（如果`retries`
    > 0），将提供新的`a`和`s`；如果提供了F，则将忽略`a`。
- en: The sequence of numbers generated by such functions generally have a a lead-up
    to some number and then loop around back to that number and begin to repeat the
    sequence, e.g. 1, 2, 3, 4, 5, 3, 4, 5 – this leader and loop look a bit like the
    Greek letter rho, and thus the name, ‘rho’.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数生成的数字序列通常会引导到某个数字，然后循环回到该数字并开始重复序列，例如1, 2, 3, 4, 5, 3, 4, 5 – 这种引导和循环看起来有点像希腊字母ρ，因此得名‘rho’。
- en: 'For a given function, very different leader-loop values can be obtained so
    it is a good idea to allow for retries:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的函数，可能会得到非常不同的主循环值，因此允许重试是个好主意：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here is an explicit example where there is a three element leadup to a sequence
    of 3 numbers (11, 14, 4) that then repeat:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明确的例子，其中有一个三元素引导到一个序列的3个数字（11, 14, 4），然后重复：
- en: '[PRE68]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Instead of checking the differences of all generated values for a gcd with n,
    only the kth and 2*kth numbers are checked, e.g. 1st and 2nd, 2nd and 4th, 3rd
    and 6th until it has been detected that the loop has been traversed. Loops may
    be many thousands of steps long before rho finds a factor or reports failure.
    If `max_steps` is specified, the iteration is cancelled with a failure after the
    specified number of steps.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 不是检查所有生成的值与n的差异的替代品，仅检查第k和2*k个数字，例如第一个和第二个，第二个和第四个，第三个和第六个，直到检测到循环已遍历。在rho找到因子或报告失败之前，循环可能会有数千个步骤长。如果指定了`max_steps`，则在指定的步数后取消迭代并失败。
- en: Examples
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE69]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use the default setting with a bad value of `a` and no retries:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置和糟糕的`a`值和无重试：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If retries is > 0 then perhaps the problem will correct itself when new values
    are generated for a:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重试> 0，则当为a生成新值时，问题可能会得到纠正：
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: References
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R654](#id7)]'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R654](#id7)]'
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 229-231'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Richard Crandall & Carl Pomerance（2005年），《素数：计算视角》，Springer，第二版，229-231
- en: '[PRE72]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Use Pollard’s p-1 method to try to extract a nontrivial factor of `n`. Either
    a divisor (perhaps composite) or `None` is returned.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用波拉德p-1方法尝试提取`n`的非平凡因子。返回一个除数（可能是复合数）或`None`。
- en: The value of `a` is the base that is used in the test gcd(a**M - 1, n). The
    default is 2\. If `retries` > 0 then if no factor is found after the first attempt,
    a new `a` will be generated randomly (using the `seed`) and the process repeated.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 的值是在测试 gcd(a**M - 1, n) 中使用的基数。默认值为 2\. 如果 `retries` > 0，则在第一次尝试未找到因子后，将随机生成一个新的
    `a`（使用 `seed`），并重复该过程。'
- en: 'Note: the value of M is lcm(1..B) = reduce(ilcm, range(2, B + 1)).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：M 的值是 lcm(1..B) = reduce(ilcm, range(2, B + 1))。
- en: A search is made for factors next to even numbers having a power smoothness
    less than `B`. Choosing a larger B increases the likelihood of finding a larger
    factor but takes longer. Whether a factor of n is found or not depends on `a`
    and the power smoothness of the even number just less than the factor p (hence
    the name p - 1).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找具有比 `B` 小的幂平滑度的偶数旁边的因子。选择更大的 B 增加找到较大因子的可能性，但需要更长时间。无论是否找到 n 的因子取决于 `a` 和略小于因子
    p 的偶数的幂平滑度（因此称为 p - 1）。
- en: 'Although some discussion of what constitutes a good `a` some descriptions are
    hard to interpret. At the modular.math site referenced below it is stated that
    if gcd(a**M - 1, n) = N then a**M % q**r is 1 for every prime power divisor of
    N. But consider the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有关什么构成一个好的 `a` 的讨论，有些描述很难解释。在下面引用的模块化数学网站中指出，如果 gcd(a**M - 1, n) = N，则对于 N
    的每个素数幂除数，a**M % q**r 等于 1。但请考虑以下情况：
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'So we should (and can) find a root with B=16:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该（并且可以）找到一个具有 B=16 的根：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we attempt to increase B to 256 we find that it does not work:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将 B 增加到 256，我们发现它不起作用：
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'But if the value of `a` is changed we find that only multiples of 257 work,
    e.g.:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 `a` 的值改变，我们发现只有 257 的倍数有效，例如：
- en: '[PRE76]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Checking different `a` values shows that all the ones that did not work had
    a gcd value not equal to `n` but equal to one of the factors:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 检查不同的 `a` 值表明所有未能成功的值都具有不等于 `n` 而等于其中一个因子的 gcd 值：
- en: '[PRE77]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: But does aM % d for every divisor of n give 1?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于 n 的每个除数，aM % d 是否都等于 1？
- en: '[PRE78]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'No, only one of them. So perhaps the principle is that a root will be found
    for a given value of B provided that:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 不，只有其中一个。因此，也许原则是，在给定 B 值的情况下，可以找到一个根，只要：
- en: the power smoothness of the p - 1 value next to the root does not exceed B
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: p - 1 值旁边的幂平滑度不超过 B
- en: a**M % p != 1 for any of the divisors of n.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个 n 的除数，a**M % p != 1。
- en: By trying more than one `a` it is possible that one of them will yield a factor.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尝试多个 `a` 可能会有一个能够产生一个因子。
- en: Examples
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: 'With the default smoothness bound, this number cannot be cracked:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认平滑界限，这个数字无法破解：
- en: '[PRE79]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Increasing the smoothness bound helps:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 增加平滑界限有助于：
- en: '[PRE80]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Looking at the smoothness of the factors of this number we find:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 查看该数字的因子的平滑度时，我们发现：
- en: '[PRE81]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The B and B-pow are the same for the p - 1 factorizations of the divisors because
    those factorizations had a very large prime factor:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: p - 1 的因子化的除数的 B 和 B-pow 是相同的，因为这些因子化有一个非常大的素因子：
- en: '[PRE82]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that until B reaches the B-pow value of 1787, the number is not cracked;
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到 B 达到 B-pow 值为 1787，该数字才能被破解；
- en: '[PRE83]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The B value has to do with the factors of the number next to the divisor, not
    the divisors themselves. A worst case scenario is that the number next to the
    factor p has a large prime divisisor or is a perfect power. If these conditions
    apply then the power-smoothness will be about p/2 or p. The more realistic is
    that there will be a large prime factor next to p requiring a B value on the order
    of p/2\. Although primes may have been searched for up to this level, the p/2
    is a factor of p - 1, something that we do not know. The modular.math reference
    below states that 15% of numbers in the range of 10**15 to 15**15 + 10**4 are
    10**6 power smooth so a B of 10**6 will fail 85% of the time in that range. From
    10**8 to 10**8 + 10**3 the percentages are nearly reversed…but in that range the
    simple trial division is quite fast.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: B 值与除数旁边的数字的因子有关，而不是除数本身。最坏的情况是，旁边的数字 p 有一个大的素数除数或者是一个完美的幂。如果这些条件适用，则幂平滑度将约为
    p/2 或 p。更现实的情况是，旁边将有一个大的素数因子需要一个大约 p/2 的 B 值。尽管可能已经在这个级别搜索了素数，但 p/2 是 p - 1 的一个因子，我们不知道。下面的模块化数学引用表示，在
    10**15 到 15**15 + 10**4 范围内的数的 15% 是 10**6 平滑的，因此在该范围内 B=10**6 的失败率为 85%。从 10**8
    到 10**8 + 10**3，百分比几乎颠倒了…但在该范围内，简单的试除法非常快。
- en: References
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R655](#id8)]'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R655](#id8)]'
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 236-238'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 第二版, 236-238'
- en: '[[R656](#id9)]'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R656](#id9)]'
- en: '[https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html](https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html](https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html)'
- en: '[[R657](#id10)]'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R657](#id10)]'
- en: '[https://www.cs.toronto.edu/~yuvalf/Factorization.pdf](https://www.cs.toronto.edu/~yuvalf/Factorization.pdf)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.cs.toronto.edu/~yuvalf/Factorization.pdf](https://www.cs.toronto.edu/~yuvalf/Factorization.pdf)'
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Given a positive integer `n`, `factorint(n)` returns a dict containing the
    prime factors of `n` as keys and their respective multiplicities as values. For
    example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 给定正整数`n`，`factorint(n)`返回一个字典，其中包含`n`的素因子作为键和它们的重数作为值。例如：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For input less than 2, factorint behaves as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小于2的输入，`factorint`的行为如下：
- en: '`factorint(1)` returns the empty factorization, `{}`'
  id: totrans-365
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`factorint(1)`返回空因式分解`{}`'
- en: ''
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`factorint(0)` returns `{0:1}`'
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`factorint(0)`返回`{0:1}`'
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`factorint(-n)` adds `-1:1` to the factors and then factors `n`'
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`factorint(-n)`将`-1:1`添加到因子中，然后因式分解`n`'
- en: 'Partial Factorization:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 部分因式分解：
- en: If `limit` (> 3) is specified, the search is stopped after performing trial
    division up to (and including) the limit (or taking a corresponding number of
    rho/p-1 steps). This is useful if one has a large number and only is interested
    in finding small factors (if any). Note that setting a limit does not prevent
    larger factors from being found early; it simply means that the largest factor
    may be composite. Since checking for perfect power is relatively cheap, it is
    done regardless of the limit setting.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`limit`（>3），则在执行试除法达到（包括）限制（或进行相应数量的rho/p-1步骤）后停止搜索。如果有一个大数，并且只想找到小因子（如果有的话），这是很有用的。注意，设置限制并不阻止较大的因子提前被发现；它仅仅意味着最大因子可能是复合的。由于检查完全幂的成本相对较低，因此无论限制设置如何，都会执行此检查。
- en: 'This number, for example, has two small factors and a huge semi-prime factor
    that cannot be reduced easily:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此数字有两个小因子和一个难以轻易分解的巨大半素数因子：
- en: '[PRE86]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This number has a small factor and a residual perfect power whose base is greater
    than the limit:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此数有一个小因子和一个基数大于限制的剩余完全幂：
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'List of Factors:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 因子列表：
- en: If `multiple` is set to `True` then a list containing the prime factors including
    multiplicities is returned.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`multiple`为`True`，则返回包含素因子及其重数的列表。
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Visual Factorization:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉因式分解：
- en: 'If `visual` is set to `True`, then it will return a visual factorization of
    the integer. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`visual`设置为`True`，则会返回整数的视觉因式分解。例如：
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that this is achieved by using the evaluate=False flag in Mul and Pow.
    If you do other manipulations with an expression where evaluate=False, it may
    evaluate. Therefore, you should use the visual option only for visualization,
    and use the normal dictionary returned by visual=False if you want to perform
    operations on the factors.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是通过在Mul和Pow中使用evaluate=False标志实现的。如果您对evaluate=False的表达式进行其他操作，它可能会计算。因此，如果您希望执行因式分解后的操作，请仅在可视化时使用visual选项，并且在visual=False时使用正常的字典返回。
- en: 'You can easily switch between the two forms by sending them back to factorint:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将它们发送回`factorint`轻松地在这两种形式之间切换。
- en: '[PRE90]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If you want to send a number to be factored in a partially factored form you
    can do so with a dictionary or unevaluated expression:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望发送一个部分因式分解形式的数字，可以使用字典或未评估的表达式进行发送：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The table of the output logic is:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输出逻辑表格如下：
- en: '|  |  |'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  |  |'
- en: '| --- | --- |'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Input | True | False | other |'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| Input | True | False | other |'
- en: '| --- | --- | --- | --- |'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| dict | mul | dict | mul |'
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| dict | mul | dict | mul |'
- en: '| n | mul | dict | dict |'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| n | mul | dict | dict |'
- en: '| mul | mul | dict | dict |'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| mul | mul | dict | dict |'
- en: Notes
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Algorithm:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：
- en: 'The function switches between multiple algorithms. Trial division quickly finds
    small factors (of the order 1-5 digits), and finds all large factors if given
    enough time. The Pollard rho and p-1 algorithms are used to find large factors
    ahead of time; they will often find factors of the order of 10 digits within a
    few seconds:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在多个算法之间切换。试除法快速找到小因子（约1-5位数字的顺序），如果给定足够时间，它会找到所有大因子。波拉德·罗和p-1算法用于提前找到大因子；它们通常在几秒钟内找到大约10位数字的因子：
- en: '[PRE93]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Any of these methods can optionally be disabled with the following boolean
    parameters:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以上任何方法均可选择性地使用以下布尔参数禁用：
- en: '`use_trial`: Toggle use of trial division'
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_trial`：切换使用试除法'
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_rho`: Toggle use of Pollard’s rho method'
  id: totrans-406
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_rho`：切换使用波拉德·罗方法'
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-408
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_pm1`: Toggle use of Pollard’s p-1 method'
  id: totrans-409
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_pm1`：切换使用Pollard的p-1方法'
- en: '`factorint` also periodically checks if the remaining part is a prime number
    or a perfect power, and in those cases stops.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorint` 还定期检查剩余部分是否为质数或完全幂，并在这些情况下停止。'
- en: For unevaluated factorial, it uses Legendre’s formula(theorem).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未评估的阶乘，它使用Legendre的公式（定理）。
- en: If `verbose` is set to `True`, detailed progress is printed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `verbose` 设置为 `True`，则会打印详细进度。
- en: See also
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
- en: '[PRE94]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Given a Rational `r`, `factorrat(r)` returns a dict containing the prime factors
    of `r` as keys and their respective multiplicities as values. For example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 给定有理数 `r`，`factorrat(r)` 返回一个包含 `r` 的质因子为键和它们相应重数为值的字典。例如：
- en: '[PRE95]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Please see the docstring for `factorint` for detailed explanations and examples
    of the following keywords:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `factorint` 的文档字符串，了解以下关键字的详细说明和示例：
- en: '`limit`: Integer limit up to which trial division is done'
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`：执行试除的整数限制'
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_trial`: Toggle use of trial division'
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_trial`：切换使用试除法'
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_rho`: Toggle use of Pollard’s rho method'
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_rho`：切换使用Pollard的rho方法'
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_pm1`: Toggle use of Pollard’s p-1 method'
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_pm1`：切换使用Pollard的p-1方法'
- en: ''
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`verbose`: Toggle detailed printing of progress'
  id: totrans-431
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`verbose`：切换详细打印进度'
- en: ''
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-433
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`multiple`: Toggle returning a list of factors or dict'
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiple`：切换返回因子列表或字典'
- en: ''
  id: totrans-435
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`visual`: Toggle product form of output'
  id: totrans-437
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visual`：切换输出的乘积形式'
- en: '[PRE96]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Return a sorted list of n’s prime factors, ignoring multiplicity and any composite
    factor that remains if the limit was set too low for complete factorization. Unlike
    factorint(), primefactors() does not return -1 or 0.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 返回n的质因子的排序列表，忽略重复性和任何如果限制太低而残留的复合因子的完全因子分解。与 `factorint()` 不同，`primefactors()`
    不返回-1或0。
- en: 'Parameters:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '**limit, verbose, **kwargs :**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**limit, verbose, **kwargs：**'
- en: Additional keyword arguments to be passed to `factorint`. Since `kwargs` is
    new in version 1.13, `limit` and `verbose` are retained for compatibility purposes.
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要传递给 `factorint` 的额外关键字参数。由于 `kwargs` 是1.13版本中的新内容，因此保留 `limit` 和 `verbose`
    以确保兼容性。
- en: 'Returns:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**list(int)** : List of prime numbers dividing `n`'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**list(int)**：整数 n 的质数列表'
- en: Examples
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE97]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: See also
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
- en: '[PRE100]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Return all divisors of n sorted from 1..n by default. If generator is `True`
    an unordered generator is returned.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回从1到n排序的n的所有除数。如果 `generator` 设置为 `True`，则返回一个无序生成器。
- en: The number of divisors of n can be quite large if there are many prime factors
    (counting repeated factors). If only the number of factors is desired use divisor_count(n).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有许多质因子（计算重复因子），则 n 的除数数量可能会很大。如果只需要因子的数量，请使用 `divisor_count(n)`。
- en: Examples
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE101]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Notes
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: 'This is a slightly modified version of Tim Peters referenced at: [https://stackoverflow.com/questions/1010381/python-factorization](https://stackoverflow.com/questions/1010381/python-factorization)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这是稍作修改的Tim Peters版本，参考自：[https://stackoverflow.com/questions/1010381/python-factorization](https://stackoverflow.com/questions/1010381/python-factorization)
- en: See also
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
- en: '[PRE103]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Return all divisors of n except n, sorted by default. If generator is `True`
    an unordered generator is returned.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回除n以外的n的所有除数。如果 `generator` 设置为 `True`，则返回一个无序生成器。
- en: Examples
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE104]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: See also
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count "sympy.ntheory.factor_.proper_divisor_count")'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count "sympy.ntheory.factor_.proper_divisor_count")'
- en: '[PRE105]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Return the number of divisors of `n`. If `modulus` is not 1 then only those
    that are divisible by `modulus` are counted. If `proper` is True then the divisor
    of `n` will not be counted.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `n` 的除数的数量。如果 `modulus` 不为 1，则仅计算可被 `modulus` 整除的除数。如果 `proper` 为 `True`，则
    `n` 的除数将不被计算。
- en: Examples
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE106]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: See also
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count
    "sympy.ntheory.factor_.proper_divisor_count")'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count
    "sympy.ntheory.factor_.proper_divisor_count")'
- en: '[PRE107]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Return the number of proper divisors of `n`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `n` 的真除数的数量。
- en: Examples
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE108]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: See also
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisors`](#sympy.ntheory.factor_.proper_divisors "sympy.ntheory.factor_.proper_divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisors`](#sympy.ntheory.factor_.proper_divisors "sympy.ntheory.factor_.proper_divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
- en: '[PRE109]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Return all unitary divisors of n sorted from 1..n by default. If generator is
    `True` an unordered generator is returned.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回排序后的 n 的所有单位除数。如果 `generator` 为 `True`，则返回一个无序生成器。
- en: The number of unitary divisors of n can be quite large if there are many prime
    factors. If only the number of unitary divisors is desired use udivisor_count(n).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在许多质因数，则 `n` 的单位除数数量可能非常大。如果只需单位除数的数量，请使用 `udivisor_count(n)`。
- en: Examples
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE110]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See also
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count "sympy.ntheory.factor_.udivisor_count")'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count "sympy.ntheory.factor_.udivisor_count")'
- en: References
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R658](#id11)]'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R658](#id11)]'
- en: '[https://en.wikipedia.org/wiki/Unitary_divisor](https://en.wikipedia.org/wiki/Unitary_divisor)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Unitary_divisor](https://en.wikipedia.org/wiki/Unitary_divisor)'
- en: '[[R659](#id12)]'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R659](#id12)]'
- en: '[https://mathworld.wolfram.com/UnitaryDivisor.html](https://mathworld.wolfram.com/UnitaryDivisor.html)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/UnitaryDivisor.html](https://mathworld.wolfram.com/UnitaryDivisor.html)'
- en: '[PRE112]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Return the number of unitary divisors of `n`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `n` 的单位除数的数量。
- en: 'Parameters:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: Examples
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE113]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See also
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`udivisors`](#sympy.ntheory.factor_.udivisors "sympy.ntheory.factor_.udivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`udivisors`](#sympy.ntheory.factor_.udivisors "sympy.ntheory.factor_.udivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
- en: References
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R660](#id13)]'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R660](#id13)]'
- en: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
- en: '[PRE114]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Return all antidivisors of n sorted from 1..n by default.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回排序后的 n 的所有反除数。
- en: Antidivisors [[R661]](#r661) of n are numbers that do not divide n by the largest
    possible margin. If generator is True an unordered generator is returned.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: n 的反除数[[R661]](#r661)是不以最大可能边界除 n 的数。如果 generator 为 True，则返回无序生成器。
- en: Examples
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE115]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: See also
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`antidivisor_count`](#sympy.ntheory.factor_.antidivisor_count "sympy.ntheory.factor_.antidivisor_count")'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`antidivisor_count`](#sympy.ntheory.factor_.antidivisor_count "sympy.ntheory.factor_.antidivisor_count")'
- en: References
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R661] ([1](#id14),[2](#id15))'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[R661] ([1](#id14),[2](#id15))'
- en: definition is described in [https://oeis.org/A066272/a066272a.html](https://oeis.org/A066272/a066272a.html)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 定义见[https://oeis.org/A066272/a066272a.html](https://oeis.org/A066272/a066272a.html)
- en: '[PRE117]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Return the number of antidivisors [[R662]](#r662) of `n`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `n` 的反除数数目[[R662]](#r662)。
- en: 'Parameters:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: Examples
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE118]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: See also
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`antidivisors`](#sympy.ntheory.factor_.antidivisors "sympy.ntheory.factor_.antidivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`antidivisors`](#sympy.ntheory.factor_.antidivisors "sympy.ntheory.factor_.antidivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
- en: References
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R662] ([1](#id16),[2](#id17))'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[R662] ([1](#id16),[2](#id17))'
- en: formula from [https://oeis.org/A066272](https://oeis.org/A066272)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 公式来自[https://oeis.org/A066272](https://oeis.org/A066272)
- en: '[PRE119]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Calculate the Euler totient function phi(n)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 计算欧拉 totient 函数 phi(n)
- en: 'Deprecated since version 1.13: The `totient` function is deprecated. Use [`sympy.functions.combinatorial.numbers.totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.13 版本起不推荐使用：`totient` 函数已被弃用。请使用[`sympy.functions.combinatorial.numbers.totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient")。更多信息请参见其文档。详细信息请参见[将 ntheory
    中的符号函数重定位到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: '`totient(n)` or \(\phi(n)\) is the number of positive integers \(\leq\) n that
    are relatively prime to n.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`totient(n)` 或 \(\phi(n)\) 是小于等于 n 的与 n 互质的正整数的数量。'
- en: 'Parameters:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: Examples
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE120]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: See also
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
- en: References
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R663](#id18)]'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R663](#id18)]'
- en: '[https://en.wikipedia.org/wiki/Euler%27s_totient_function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euler%27s_totient_function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)'
- en: '[[R664](#id19)]'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R664](#id19)]'
- en: '[https://mathworld.wolfram.com/TotientFunction.html](https://mathworld.wolfram.com/TotientFunction.html)'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/TotientFunction.html](https://mathworld.wolfram.com/TotientFunction.html)'
- en: '[PRE121]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Calculate the Carmichael reduced totient function lambda(n)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 Carmichael 减少的欧拉 totient 函数 lambda(n)
- en: 'Deprecated since version 1.13: The `reduced_totient` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.reduced_totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.13 版本起不推荐使用：`reduced_totient` 函数已被弃用。请使用[`sympy.functions.combinatorial.numbers.reduced_totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient")。更多信息请参见其文档。详细信息请参见[将
    ntheory 中的符号函数重定位到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: '`reduced_totient(n)` or \(\lambda(n)\) is the smallest m > 0 such that \(k^m
    \equiv 1 \mod n\) for all k relatively prime to n.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduced_totient(n)` 或 \(\lambda(n)\) 是最小的m > 0，使得对于所有与n互质的k，都有 \(k^m \equiv
    1 \mod n\)。'
- en: Examples
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE122]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: See also
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
- en: References
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R665](#id20)]'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R665](#id20)]'
- en: '[https://en.wikipedia.org/wiki/Carmichael_function](https://en.wikipedia.org/wiki/Carmichael_function)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Carmichael_function](https://en.wikipedia.org/wiki/Carmichael_function)'
- en: '[[R666](#id21)]'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R666](#id21)]'
- en: '[https://mathworld.wolfram.com/CarmichaelFunction.html](https://mathworld.wolfram.com/CarmichaelFunction.html)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/CarmichaelFunction.html](https://mathworld.wolfram.com/CarmichaelFunction.html)'
- en: '[PRE123]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Calculate the divisor function \(\sigma_k(n)\) for positive integer n
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正整数n的除数函数 \(\sigma_k(n)\)
- en: 'Deprecated since version 1.13: The `divisor_sigma` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.divisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.13起不推荐使用：函数`divisor_sigma`已不推荐使用。请使用[`sympy.functions.combinatorial.numbers.divisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma")。有关详细信息，请参阅其文档。有关详细信息，请参见[将符号函数从ntheory移至函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: '`divisor_sigma(n, k)` is equal to `sum([x**k for x in divisors(n)])`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`divisor_sigma(n, k)` 等于 `sum([x**k for x in divisors(n)])`'
- en: 'If n’s prime factorization is:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n的素因数分解为：
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
- en: then
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 则
- en: \[\sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots + p_i^{m_ik}).\]
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots + p_i^{m_ik}).\]
- en: 'Parameters:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '**k** : integer, optional'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：整数，可选'
- en: power of divisors in the sum
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 和的除数的幂
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for k = 0, 1: `divisor_sigma(n, 0)` is equal to `divisor_count(n)` `divisor_sigma(n,
    1)` is equal to `sum(divisors(n))`'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于k = 0, 1：`divisor_sigma(n, 0)` 等于 `divisor_count(n)`，`divisor_sigma(n, 1)`
    等于 `sum(divisors(n))`
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for k is 1.
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，k为1。
- en: Examples
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE124]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See also
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")，[`totient`](#sympy.ntheory.factor_.totient
    "sympy.ntheory.factor_.totient")，[`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors")，[`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
- en: References
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R667](#id22)]'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R667](#id22)]'
- en: '[https://en.wikipedia.org/wiki/Divisor_function](https://en.wikipedia.org/wiki/Divisor_function)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Divisor_function](https://en.wikipedia.org/wiki/Divisor_function)'
- en: '[PRE125]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Calculate the unitary divisor function \(\sigma_k^*(n)\) for positive integer
    n
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正整数n的单位除数函数 \(\sigma_k^*(n)\)
- en: 'Deprecated since version 1.13: The `udivisor_sigma` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.udivisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.udivisor_sigma
    "sympy.functions.combinatorial.numbers.udivisor_sigma") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.13起不推荐使用：函数`udivisor_sigma`已不推荐使用。请使用[`sympy.functions.combinatorial.numbers.udivisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.udivisor_sigma
    "sympy.functions.combinatorial.numbers.udivisor_sigma")。有关详细信息，请参阅其文档。有关详细信息，请参见[将符号函数从ntheory移至函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: '`udivisor_sigma(n, k)` is equal to `sum([x**k for x in udivisors(n)])`'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`udivisor_sigma(n, k)` 等于 `sum([x**k for x in udivisors(n)])`'
- en: 'If n’s prime factorization is:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n的素因数分解为：
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
- en: then
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 则
- en: \[\sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).\]
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).\]
- en: 'Parameters:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**k** : power of divisors in the sum'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：和的除数的幂'
- en: 'for k = 0, 1: `udivisor_sigma(n, 0)` is equal to `udivisor_count(n)` `udivisor_sigma(n,
    1)` is equal to `sum(udivisors(n))`'
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于k = 0, 1：`udivisor_sigma(n, 0)` 等于 `udivisor_count(n)`，`udivisor_sigma(n,
    1)` 等于 `sum(udivisors(n))`
- en: ''
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for k is 1.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，k为1。
- en: Examples
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE126]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: See also
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`udivisors`](#sympy.ntheory.factor_.udivisors
    "sympy.ntheory.factor_.udivisors"), [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count
    "sympy.ntheory.factor_.udivisor_count"), [`divisor_sigma`](#sympy.ntheory.factor_.divisor_sigma
    "sympy.ntheory.factor_.divisor_sigma"), [`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`udivisors`](#sympy.ntheory.factor_.udivisors
    "sympy.ntheory.factor_.udivisors"), [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count
    "sympy.ntheory.factor_.udivisor_count"), [`divisor_sigma`](#sympy.ntheory.factor_.divisor_sigma
    "sympy.ntheory.factor_.divisor_sigma"), [`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
- en: References
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R668](#id23)]'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R668](#id23)]'
- en: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
- en: '[PRE127]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Calculate core(n, t) = \(core_t(n)\) of a positive integer n
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正整数n的`core_t(n)` = `core(n, t)`
- en: '`core_2(n)` is equal to the squarefree part of n'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`core_2(n)`等于n的无平方数部分'
- en: 'If n’s prime factorization is:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果n的质因数分解为：
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
- en: then
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 则
- en: \[core_t(n) = \prod_{i=1}^\omega p_i^{m_i \mod t}.\]
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: \[core_t(n) = \prod_{i=1}^\omega p_i^{m_i \mod t}.\]
- en: 'Parameters:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : integer'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '**t** : integer'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**：整数'
- en: core(n, t) calculates the t-th power free part of n
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`core(n, t)`计算n的第t个无幂次方部分'
- en: ''
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`core(n, 2)` is the squarefree part of `n` `core(n, 3)` is the cubefree part
    of `n`'
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`core(n, 2)`是n的无平方数部分，`core(n, 3)`是n的无立方数部分'
- en: ''
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for t is 2.
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: t的默认值为2。
- en: Examples
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE128]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: See also
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`sympy.solvers.diophantine.diophantine.square_factor`](solvers/diophantine.html#sympy.solvers.diophantine.diophantine.square_factor
    "sympy.solvers.diophantine.diophantine.square_factor")'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`sympy.solvers.diophantine.diophantine.square_factor`](solvers/diophantine.html#sympy.solvers.diophantine.diophantine.square_factor
    "sympy.solvers.diophantine.diophantine.square_factor")'
- en: References
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R669](#id24)]'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R669](#id24)]'
- en: '[https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core](https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core)'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core](https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core)'
- en: '[PRE129]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Return a list of the digits of `n` in base `b`. The first element in the list
    is `b` (or `-b` if `n` is negative).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 返回n在b进制下的数字列表。列表中的第一个元素是b（如果n为负，则为-b）。
- en: 'Parameters:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n: integer**'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**n：整数**'
- en: The number whose digits are returned.
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要返回其数字的数字。
- en: '**b: integer**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**b：整数**'
- en: The base in which digits are computed.
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算数字的基数。
- en: '**digits: integer (or None for all digits)**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**digits：整数（或所有数字为None）**'
- en: The number of digits to be returned (padded with zeros, if necessary).
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要返回的数字位数（如有必要，用零填充）。
- en: Examples
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE130]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If the number is negative, the negative sign will be placed on the base (which
    is the first element in the returned list):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字为负，则负号将放置在基数上（即返回列表中的第一个元素）：
- en: '[PRE131]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Bases other than 10 (and greater than 1) can be selected with `b`:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择除10以外（且大于1）的基数`b`：
- en: '[PRE132]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Use the `digits` keyword if a certain number of digits is desired:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要确定特定位数的数字，请使用`digits`关键字：
- en: '[PRE133]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: See also
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
- en: '[PRE134]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Calculate the number of distinct prime factors for a positive integer n.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 计算正整数n的不同质因子的数量。
- en: 'Deprecated since version 1.13: The `primenu` function is deprecated. Use [`sympy.functions.combinatorial.numbers.primenu`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primenu
    "sympy.functions.combinatorial.numbers.primenu") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.13起已弃用：`primenu`函数已弃用。请使用[`sympy.functions.combinatorial.numbers.primenu`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primenu
    "sympy.functions.combinatorial.numbers.primenu")。有关详细信息，请参见其文档。有关详细信息，请参阅[从ntheory移动符号函数到函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: 'If n’s prime factorization is:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 n 的素因数分解是：
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: \[n = \prod_{i=1}^k p_i^{m_i},\]
- en: 'then `primenu(n)` or \(\nu(n)\) is:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `primenu(n)` 或者 \(\nu(n)\) 是：
- en: \[\nu(n) = k.\]
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: \[\nu(n) = k.\]
- en: Examples
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE135]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: See also
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
- en: References
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R670](#id25)]'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R670](#id25)]'
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
- en: '[PRE136]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Calculate the number of prime factors counting multiplicities for a positive
    integer n.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个正整数 n 的素因数的个数（包括重数）。
- en: 'Deprecated since version 1.13: The `primeomega` function is deprecated. Use
    [`sympy.functions.combinatorial.numbers.primeomega`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primeomega
    "sympy.functions.combinatorial.numbers.primeomega") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.13 起已弃用：`primeomega` 函数已弃用。使用 [`sympy.functions.combinatorial.numbers.primeomega`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primeomega
    "sympy.functions.combinatorial.numbers.primeomega") 替代。更多信息请参见其文档。详情请见 [将符号函数从
    ntheory 移至 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: 'If n’s prime factorization is:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 n 的素因数分解是：
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: \[n = \prod_{i=1}^k p_i^{m_i},\]
- en: 'then `primeomega(n)` or \(\Omega(n)\) is:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `primeomega(n)` 或者 \(\Omega(n)\) 是：
- en: \[\Omega(n) = \sum_{i=1}^k m_i.\]
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: \[\Omega(n) = \sum_{i=1}^k m_i.\]
- en: Examples
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE137]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: See also
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
- en: References
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R671](#id26)]'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R671](#id26)]'
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
- en: '[PRE138]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Returns the exponent `i` for the nth Mersenne prime (which has the form \(2^i
    - 1\)).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第 n 个 Mersenne prime 的指数 `i`（形式为 \(2^i - 1\))。
- en: Examples
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE139]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Returns True if `n` is a perfect number, else False.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True 如果 `n` 是一个 perfect number，否则返回 False。
- en: A perfect number is equal to the sum of its positive, proper divisors.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 perfect number 等于其正的真因数之和。
- en: Examples
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE141]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: References
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R672](#id27)]'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R672](#id27)]'
- en: '[https://mathworld.wolfram.com/PerfectNumber.html](https://mathworld.wolfram.com/PerfectNumber.html)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/PerfectNumber.html](https://mathworld.wolfram.com/PerfectNumber.html)'
- en: '[[R673](#id28)]'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R673](#id28)]'
- en: '[https://en.wikipedia.org/wiki/Perfect_number](https://en.wikipedia.org/wiki/Perfect_number)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Perfect_number](https://en.wikipedia.org/wiki/Perfect_number)'
- en: '[PRE142]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Returns the difference between the sum of the positive proper divisors of a
    number and the number.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个数的正因数之和与该数之差。
- en: Examples
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE143]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Returns True if `n` is an abundant number, else False.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True 如果 `n` 是一个 abundant number，否则返回 False。
- en: A abundant number is smaller than the sum of its positive proper divisors.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 abundant number 是小于其正因数之和的数。
- en: Examples
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE145]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: References
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R674](#id29)]'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R674](#id29)]'
- en: '[https://mathworld.wolfram.com/AbundantNumber.html](https://mathworld.wolfram.com/AbundantNumber.html)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/AbundantNumber.html](https://mathworld.wolfram.com/AbundantNumber.html)'
- en: '[PRE146]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Returns True if `n` is a deficient number, else False.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True 如果 `n` 是一个 deficient number，否则返回 False。
- en: A deficient number is greater than the sum of its positive proper divisors.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 deficient number 是大于其正因数之和的数。
- en: Examples
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE147]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: References
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R675](#id30)]'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R675](#id30)]'
- en: '[https://mathworld.wolfram.com/DeficientNumber.html](https://mathworld.wolfram.com/DeficientNumber.html)'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/DeficientNumber.html](https://mathworld.wolfram.com/DeficientNumber.html)'
- en: '[PRE148]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Returns True if the numbers \(m\) and \(n\) are “amicable”, else False.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True 如果数字 \(m\) 和 \(n\) 是“amicable”，否则返回 False。
- en: Amicable numbers are two different numbers so related that the sum of the proper
    divisors of each is equal to that of the other.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: Amicable numbers 是两个不同的相关数，其各自的真因数之和相等。
- en: Examples
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE149]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: References
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R676](#id31)]'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R676](#id31)]'
- en: '[https://en.wikipedia.org/wiki/Amicable_numbers](https://en.wikipedia.org/wiki/Amicable_numbers)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Amicable_numbers](https://en.wikipedia.org/wiki/Amicable_numbers)'
- en: '[PRE150]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Returns True if the numbers \(n\) is Carmichael number, else False.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 True 如果数字 \(n\) 是 Carmichael number，否则返回 False。
- en: 'Parameters:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 整数'
- en: References
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R677](#id32)]'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R677](#id32)]'
- en: '[https://en.wikipedia.org/wiki/Carmichael_number](https://en.wikipedia.org/wiki/Carmichael_number)'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Carmichael_number](https://en.wikipedia.org/wiki/Carmichael_number)'
- en: '[[R678](#id33)]'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R678](#id33)]'
- en: '[https://oeis.org/A002997](https://oeis.org/A002997)'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://oeis.org/A002997](https://oeis.org/A002997)'
- en: '[PRE151]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Returns a list of the number of Carmichael in the range
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在范围内的 Carmichael 数的列表。
- en: See also
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
- en: '[PRE152]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Returns the first n Carmichael numbers.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 返回前 `n` 个 Carmichael 数。
- en: 'Parameters:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: See also
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
- en: '[PRE153]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Return the residual mod m such that it is within half of the modulus.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 返回模 `m` 内的剩余部分，使其在模的一半范围内。
- en: '[PRE154]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Chinese Remainder Theorem.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 中国剩余定理。
- en: The moduli in m are assumed to be pairwise coprime. The output is then an integer
    f, such that f = v_i mod m_i for each pair out of v and m. If `symmetric` is False
    a positive integer will be returned, else |f| will be less than or equal to the
    LCM of the moduli, and thus f may be negative.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `m` 中的模数被假设为两两互质。然后输出是一个整数 `f`，使得对于 `v` 和 `m` 中的每对，都有 `f = v_i mod m_i`。如果
    `symmetric` 为 False，则返回一个正整数，否则 |f| 小于或等于模数的 LCM，因此 `f` 可能为负数。
- en: If the moduli are not co-prime the correct result will be returned if/when the
    test of the result is found to be incorrect. This result will be None if there
    is no solution.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模数不互质，则在发现结果不正确时将返回正确结果。如果没有解决方案，则结果将为 `None`。
- en: The keyword `check` can be set to False if it is known that the moduli are coprime.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知模数是互质的，则可以将关键字 `check` 设置为 False。
- en: Examples
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'As an example consider a set of residues `U = [49, 76, 65]` and a set of moduli
    `M = [99, 97, 95]`. Then we have:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一组剩余 `U = [49, 76, 65]` 和一组模数 `M = [99, 97, 95]`。那么我们有：
- en: '[PRE156]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This is the correct result because:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的结果，因为：
- en: '[PRE157]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'If the moduli are not co-prime, you may receive an incorrect result if you
    use `check=False`:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模数不互质，如果使用 `check=False`，则可能会得到不正确的结果：
- en: '[PRE158]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Note: the order of gf_crt’s arguments is reversed relative to crt, and that
    solve_congruence takes residue, modulus pairs.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：相对于 `crt`，`gf_crt` 的参数顺序被颠倒了，`solve_congruence` 接受剩余，模数对。
- en: 'Programmer’s note: rather than checking that all pairs of moduli share no GCD
    (an O(n**2) test) and rather than factoring all moduli and seeing that there is
    no factor in common, a check that the result gives the indicated residuals is
    performed – an O(n) operation.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员注意：与检查所有模数对不共享 GCD（O(n**2) 测试）或者分解所有模数然后看是否有共同因子的方法不同，这里执行的操作是检查结果是否给出了指定的剩余部分
    - 这是一个 O(n) 操作。
- en: See also
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`solve_congruence`](#sympy.ntheory.modular.solve_congruence "sympy.ntheory.modular.solve_congruence")'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve_congruence`](#sympy.ntheory.modular.solve_congruence "sympy.ntheory.modular.solve_congruence")'
- en: '[`sympy.polys.galoistools.gf_crt`](polys/internals.html#sympy.polys.galoistools.gf_crt
    "sympy.polys.galoistools.gf_crt")'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.galoistools.gf_crt`](polys/internals.html#sympy.polys.galoistools.gf_crt
    "sympy.polys.galoistools.gf_crt")'
- en: low level crt routine used by this routine
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 低级 Chinese Remainder Theorem 运行在这个例程中使用。
- en: '[PRE159]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: First part of Chinese Remainder Theorem, for multiple application.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 多个应用的 Chinese Remainder Theorem 的第一部分。
- en: Examples
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE160]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The following two codes have the same result.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个代码具有相同的结果。
- en: '[PRE161]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'However, it is faster when we want to fix `m` and compute for multiple `v`,
    i.e. the following cases:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们希望固定 `m` 并计算多个 `v` 时，速度更快，即以下情况：
- en: '[PRE163]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: See also
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.polys.galoistools.gf_crt1`](polys/internals.html#sympy.polys.galoistools.gf_crt1
    "sympy.polys.galoistools.gf_crt1")'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.galoistools.gf_crt1`](polys/internals.html#sympy.polys.galoistools.gf_crt1
    "sympy.polys.galoistools.gf_crt1")'
- en: low level crt routine used by this routine
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 低级 Chinese Remainder Theorem 运行在这个例程中使用。
- en: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt2`](#sympy.ntheory.modular.crt2 "sympy.ntheory.modular.crt2")'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt2`](#sympy.ntheory.modular.crt2 "sympy.ntheory.modular.crt2")'
- en: '[PRE164]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Second part of Chinese Remainder Theorem, for multiple application.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 多个应用的 Chinese Remainder Theorem 的第二部分。
- en: See `crt1` for usage.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 `crt1` 以获取用法。
- en: Examples
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE165]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: See also
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.polys.galoistools.gf_crt2`](polys/internals.html#sympy.polys.galoistools.gf_crt2
    "sympy.polys.galoistools.gf_crt2")'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.galoistools.gf_crt2`](polys/internals.html#sympy.polys.galoistools.gf_crt2
    "sympy.polys.galoistools.gf_crt2")'
- en: low level crt routine used by this routine
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 低级 Chinese Remainder Theorem 运行在这个例程中使用。
- en: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt1`](#sympy.ntheory.modular.crt1 "sympy.ntheory.modular.crt1")'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt1`](#sympy.ntheory.modular.crt1 "sympy.ntheory.modular.crt1")'
- en: '[PRE166]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Compute the integer `n` that has the residual `ai` when it is divided by `mi`
    where the `ai` and `mi` are given as pairs to this function: ((a1, m1), (a2, m2),
    …). If there is no solution, return None. Otherwise return `n` and its modulus.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 计算整数`n`，当它被分别除以`mi`时，余数为`ai`，其中`ai`和`mi`作为此函数的一对给定：((a1, m1), (a2, m2), ...)。如果没有解决方案，则返回None。否则返回`n`及其模数。
- en: The `mi` values need not be co-prime. If it is known that the moduli are not
    co-prime then the hint `check` can be set to False (default=True) and the check
    for a quicker solution via crt() (valid when the moduli are co-prime) will be
    skipped.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '`mi`值不需要互质。如果已知模数不互质，则可以将提示`check`设置为False（默认为True），并且将跳过通过crt()（在模数互质时有效）寻找更快解决方案的检查。'
- en: If the hint `symmetric` is True (default is False), the value of `n` will be
    within 1/2 of the modulus, possibly negative.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示`symmetric`为True（默认为False），则`n`的值将在模数的1/2范围内，可能为负。
- en: Examples
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE167]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: What number is 2 mod 3, 3 mod 5 and 2 mod 7?
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是2模3、3模5和2模7的数字？
- en: '[PRE168]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'If you prefer to work with all remainder in one list and all moduli in another,
    send the arguments like this:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢将所有余数放在一个列表中，将所有模数放在另一个列表中，则可以像这样发送参数：
- en: '[PRE169]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The moduli need not be co-prime; in this case there may or may not be a solution:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 模数不需要互质；在这种情况下可能存在或不存在解决方案：
- en: '[PRE170]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The symmetric flag will make the result be within 1/2 of the modulus:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 对称标志将使结果在模数的1/2范围内：
- en: '[PRE172]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: See also
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[`crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")'
- en: high level routine implementing the Chinese Remainder Theorem
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中国余数定理的高级程序
- en: '[PRE173]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Return a dictionary containing pairs \({(k1,k2) : C_kn}\) where \(C_kn\) are
    binomial coefficients and \(n=k1+k2\).'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '返回包含对`{(k1,k2) : C_kn}`的字典，其中`C_kn`为二项式系数且`n=k1+k2`。'
- en: Examples
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE174]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: See also
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`binomial_coefficients_list`](#sympy.ntheory.multinomial.binomial_coefficients_list
    "sympy.ntheory.multinomial.binomial_coefficients_list"), [`multinomial_coefficients`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '[`二项式系数列表`](#sympy.ntheory.multinomial.binomial_coefficients_list "sympy.ntheory.multinomial.binomial_coefficients_list")，[`多项式系数`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
- en: '[PRE175]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Return a list of binomial coefficients as rows of the Pascal’s triangle.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 返回帕斯卡三角形的行作为二项式系数的列表。
- en: Examples
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE176]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: See also
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`binomial_coefficients`](#sympy.ntheory.multinomial.binomial_coefficients
    "sympy.ntheory.multinomial.binomial_coefficients"), [`multinomial_coefficients`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[`二项式系数`](#sympy.ntheory.multinomial.binomial_coefficients "sympy.ntheory.multinomial.binomial_coefficients")，[`多项式系数`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
- en: '[PRE177]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Return a dictionary containing pairs `{(k1,k2,..,km) : C_kn}` where `C_kn`
    are multinomial coefficients such that `n=k1+k2+..+km`.'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '返回包含对`{(k1,k2,..,km) : C_kn}`的字典，其中`C_kn`为多项式系数，使得`n=k1+k2+..+km`。'
- en: Examples
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE178]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Notes
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: 'The algorithm is based on the following result:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法基于以下结果：
- en: \[\binom{n}{k_1, \ldots, k_m} = \frac{k_1 + 1}{n - k_1} \sum_{i=2}^m \binom{n}{k_1
    + 1, \ldots, k_i - 1, \ldots}\]
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: \[\binom{n}{k_1, \ldots, k_m} = \frac{k_1 + 1}{n - k_1} \sum_{i=2}^m \binom{n}{k_1
    + 1, \ldots, k_i - 1, \ldots}\]
- en: Code contributed to Sage by Yann Laigle-Chapuy, copied with permission of the
    author.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 由Yann Laigle-Chapuy贡献的代码，经作者许可复制。
- en: See also
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`binomial_coefficients_list`](#sympy.ntheory.multinomial.binomial_coefficients_list
    "sympy.ntheory.multinomial.binomial_coefficients_list"), [`binomial_coefficients`](#sympy.ntheory.multinomial.binomial_coefficients
    "sympy.ntheory.multinomial.binomial_coefficients")'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '[`二项式系数列表`](#sympy.ntheory.multinomial.binomial_coefficients_list "sympy.ntheory.multinomial.binomial_coefficients_list")，[`二项式系数`](#sympy.ntheory.multinomial.binomial_coefficients
    "sympy.ntheory.multinomial.binomial_coefficients")'
- en: '[PRE179]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: multinomial coefficient iterator
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式系数迭代器
- en: This routine has been optimized for \(m\) large with respect to \(n\) by taking
    advantage of the fact that when the monomial tuples \(t\) are stripped of zeros,
    their coefficient is the same as that of the monomial tuples from `multinomial_coefficients(n,
    n)`. Therefore, the latter coefficients are precomputed to save memory and time.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用从`multinomial_coefficients(n, n)`获取的单项式元组`t`去除零时的系数与后者的系数相同，因此，后者的系数预先计算以节省内存和时间。
- en: '[PRE180]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Examples
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE181]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Calculate the partition function P(n), i.e. the number of ways that n can be
    written as a sum of positive integers.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 计算分割函数P(n)，即将n写为正整数和的方式数。
- en: 'Deprecated since version 1.13: The `npartitions` function is deprecated. Use
    [`sympy.functions.combinatorial.numbers.partition`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.partition
    "sympy.functions.combinatorial.numbers.partition") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.13 起弃用：`npartitions` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.partition`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.partition
    "sympy.functions.combinatorial.numbers.partition")。有关更多信息，请参阅其文档。详细信息请参见 [将符号函数从
    ntheory 移至 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: P(n) is computed using the Hardy-Ramanujan-Rademacher formula [[R679]](#r679).
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hardy-Ramanujan-Rademacher 公式计算 P(n) [[R679]](#r679)。
- en: The correctness of this implementation has been tested through \(10^{10}\).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现的正确性已通过 \(10^{10}\) 的测试。
- en: Examples
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE183]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: References
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R679] ([1](#id34),[2](#id35))'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '[R679] ([1](#id34),[2](#id35))'
- en: '[https://mathworld.wolfram.com/PartitionFunctionP.html](https://mathworld.wolfram.com/PartitionFunctionP.html)'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/PartitionFunctionP.html](https://mathworld.wolfram.com/PartitionFunctionP.html)'
- en: '[PRE184]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：
- en: \[a^{n-1} \equiv 1 \pmod{n}\]
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: \[a^{n-1} \equiv 1 \pmod{n}\]
- en: (where mod refers to the modulo operation).
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: （其中 mod 指的是模运算）。
- en: 'Parameters:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '`n` is a positive integer.'
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n` 是正整数。'
- en: '**a** : Integer'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a` 是正整数。`a` 和 `n` 应该互质。'
- en: 'Returns:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If `n` is prime, it always returns `True`.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**bool**：如果 `n` 是素数，则总是返回 `True`。'
- en: The composite number that returns `True` is called an Fermat pseudoprime.
  id: totrans-837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回称为 Fermat 伪素数的合数。
- en: Examples
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE185]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: References
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R680](#id36)]'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R680](#id36)]'
- en: '[https://en.wikipedia.org/wiki/Fermat_pseudoprime](https://en.wikipedia.org/wiki/Fermat_pseudoprime)'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Fermat_pseudoprime](https://en.wikipedia.org/wiki/Fermat_pseudoprime)'
- en: '[PRE186]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：
- en: \[a^{(n-1)/2} \equiv \pm 1 \pmod{n}\]
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: \[a^{(n-1)/2} \equiv \pm 1 \pmod{n}\]
- en: (where mod refers to the modulo operation).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: （其中 mod 指的是模运算）。
- en: 'Parameters:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '`n` is a positive integer.'
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n` 是正整数。'
- en: '**a** : Integer'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a` 是正整数。`a` 和 `n` 应该互质。'
- en: 'Returns:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If `n` is prime, it always returns `True`.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**bool**：如果 `n` 是素数，则总是返回 `True`。'
- en: The composite number that returns `True` is called an Euler pseudoprime.
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回称为 Euler 伪素数的合数。
- en: Examples
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE187]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: References
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R681](#id37)]'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R681](#id37)]'
- en: '[https://en.wikipedia.org/wiki/Euler_pseudoprime](https://en.wikipedia.org/wiki/Euler_pseudoprime)'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euler_pseudoprime](https://en.wikipedia.org/wiki/Euler_pseudoprime)'
- en: '[PRE188]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：
- en: \[a^{(n-1)/2} \equiv \left(\frac{a}{n}\right) \pmod{n}\]
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: \[a^{(n-1)/2} \equiv \left(\frac{a}{n}\right) \pmod{n}\]
- en: (where mod refers to the modulo operation).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: （其中 mod 指的是模运算）。
- en: 'Parameters:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '`n` is a positive integer.'
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n` 是正整数。'
- en: '**a** : Integer'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  id: totrans-868
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a` 是正整数。`a` 和 `n` 应该互质。'
- en: 'Returns:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If `n` is prime, it always returns `True`.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**bool**：如果 `n` 是素数，则总是返回 `True`。'
- en: The composite number that returns `True` is called an Euler-Jacobi pseudoprime.
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回称为 Euler-Jacobi 伪素数的合数。
- en: Examples
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE189]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: References
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R682](#id38)]'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R682](#id38)]'
- en: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime](https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime)'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime](https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime)'
- en: '[PRE190]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Return True if n == a * a for some integer a, else False. If n is suspected
    of *not* being a square then this is a quick method of confirming that it is not.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 n == a * a 则返回 True，否则返回 False。如果怀疑 n *不* 是一个平方数，则这是确认其不是的快速方法。
- en: Examples
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE191]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: See also
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.intfunc.isqrt`](core.html#sympy.core.intfunc.isqrt "sympy.core.intfunc.isqrt")'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.isqrt`](core.html#sympy.core.intfunc.isqrt "sympy.core.intfunc.isqrt")'
- en: References
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R683](#id39)]'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R683](#id39)]'
- en: '[https://mersenneforum.org/showpost.php?p=110896](https://mersenneforum.org/showpost.php?p=110896)'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mersenneforum.org/showpost.php?p=110896](https://mersenneforum.org/showpost.php?p=110896)'
- en: '[PRE192]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Perform a Miller-Rabin strong pseudoprime test on n using a given list of bases/witnesses.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 对 n 执行 Miller-Rabin 强伪素数测试，使用给定的基数/见证者列表。
- en: Examples
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE193]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: References
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R684](#id40)]'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R684](#id40)]'
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 135-138'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 135-138'
- en: 'A list of thresholds and the bases they require are here: [https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants)'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 一个阈值列表及其所需的基数见这里：[https://zh.wikipedia.org/wiki/Miller%E2%80%93Rabin%E8%B4%A8%E6%80%A7%E6%80%A7%E6%A3%80%E6%B5%8B#确定性变体](https://zh.wikipedia.org/wiki/Miller%E2%80%93Rabin%E8%B4%A8%E6%80%A7%E6%80%A7%E6%A3%80%E6%B5%8B#确定性变体)
- en: '[PRE194]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Standard Lucas compositeness test with Selfridge parameters. Returns False if
    n is definitely composite, and True if n is a Lucas probable prime.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 Lucas 复合性测试，使用 Selfridge 参数。如果 n 明确是复合数，则返回 False；如果 n 是 Lucas 可能质数，则返回 True。
- en: This is typically used in combination with the Miller-Rabin test.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常与米勒-拉宾测试结合使用。
- en: Examples
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE195]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: References
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R685](#id41)]'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R685](#id41)]'
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
- en: '[[R686](#id42)]'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R686](#id42)]'
- en: 'OEIS A217120: Lucas Pseudoprimes [https://oeis.org/A217120](https://oeis.org/A217120)'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 'OEIS A217120: Lucas 伪素数 [https://oeis.org/A217120](https://oeis.org/A217120)'
- en: '[[R687](#id43)]'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R687](#id43)]'
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90](https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90)'
- en: '[PRE196]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Strong Lucas compositeness test with Selfridge parameters. Returns False if
    n is definitely composite, and True if n is a strong Lucas probable prime.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 强 Lucas 复合性测试，使用 Selfridge 参数。如果 n 明确是复合数，则返回 False；如果 n 是强 Lucas 可能质数，则返回 True。
- en: This is often used in combination with the Miller-Rabin test, and in particular,
    when combined with M-R base 2 creates the strong BPSW test.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常与米勒-拉宾测试结合使用，特别是与 M-R 基数 2 结合创建强 BPSW 测试时。
- en: Examples
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE197]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: References
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R688](#id44)]'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R688](#id44)]'
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
- en: '[[R689](#id45)]'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R689](#id45)]'
- en: 'OEIS A217255: Strong Lucas Pseudoprimes [https://oeis.org/A217255](https://oeis.org/A217255)'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 'OEIS A217255: 强 Lucas 伪素数 [https://oeis.org/A217255](https://oeis.org/A217255)'
- en: '[[R690](#id46)]'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R690](#id46)]'
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90](https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90)'
- en: '[[R691](#id47)]'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R691](#id47)]'
- en: '[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Baillie-PSW%E8%B4%A8%E6%95%B0%E6%B5%8B%E8%AF%95](https://zh.wikipedia.org/wiki/Baillie-PSW%E8%B4%A8%E6%95%B0%E6%B5%8B%E8%AF%95)'
- en: '[PRE198]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Extra Strong Lucas compositeness test. Returns False if n is definitely composite,
    and True if n is an “extra strong” Lucas probable prime.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 额外强 Lucas 复合性测试。如果 n 明确是复合数，则返回 False；如果 n 是“额外强” Lucas 可能质数，则返回 True。
- en: The parameters are selected using P = 3, Q = 1, then incrementing P until (D|n)
    == -1\. The test itself is as defined in [[R692]](#r692), from the Mo and Jones
    preprint. The parameter selection and test are the same as used in OEIS A217719,
    Perl’s Math::Prime::Util, and the Lucas pseudoprime page on Wikipedia.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 P = 3，Q = 1 选择参数，然后递增 P 直到 (D|n) == -1\. 测试本身如 [[R692]](#r692) 中所定义，出自 Mo
    和 Jones 的预印本。参数选择和测试与 OEIS A217719、Perl 的 Math::Prime::Util 以及维基百科上的 Lucas 伪素数页面相同。
- en: It is 20-50% faster than the strong test.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 它比强测试快 20-50%。
- en: Because of the different parameters selected, there is no relationship between
    the strong Lucas pseudoprimes and extra strong Lucas pseudoprimes. In particular,
    one is not a subset of the other.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择了不同的参数，强Lucas伪素数和额外强Lucas伪素数之间没有关系。特别地，一个不是另一个的子集。
- en: Examples
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE199]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: References
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R692] ([1](#id48),[2](#id49))'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '[R692] ([1](#id48),[2](#id49))'
- en: Jon Grantham, Frobenius Pseudoprimes, Math. Comp. Vol 70, Number 234 (2001),
    pp. 873-891, [https://doi.org/10.1090%2FS0025-5718-00-01197-2](https://doi.org/10.1090%2FS0025-5718-00-01197-2)
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: Jon Grantham，Frobenius伪素数，Math. Comp. Vol 70, Number 234 (2001)，pp. 873-891，[https://doi.org/10.1090%2FS0025-5718-00-01197-2](https://doi.org/10.1090%2FS0025-5718-00-01197-2)
- en: '[[R693](#id50)]'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R693](#id50)]'
- en: 'OEIS A217719: Extra Strong Lucas Pseudoprimes [https://oeis.org/A217719](https://oeis.org/A217719)'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: OEIS A217719：额外强Lucas伪素数 [https://oeis.org/A217719](https://oeis.org/A217719)
- en: '[[R694](#id51)]'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R694](#id51)]'
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Lucas伪素数](https://zh.wikipedia.org/wiki/Lucas伪素数)'
- en: '[PRE200]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Test if the Proth number \(n = k2^m + 1\) is prime. where k is a positive odd
    number and \(2^m > k\).
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Proth数\(n = k2^m + 1\)是否为素数，其中k是正奇数且\(2^m > k\)。
- en: 'Parameters:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Integer'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '`n` is Proth number'
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n`是Proth数'
- en: 'Returns:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If `True`, then `n` is the Proth prime'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '**bool**：如果为`True`，则`n`是Proth素数'
- en: 'Raises:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常：
- en: '**ValueError**'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: If `n` is not Proth number.
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`n`不是Proth数。
- en: Examples
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE201]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: References
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R695](#id52)]'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R695](#id52)]'
- en: '[https://en.wikipedia.org/wiki/Proth_prime](https://en.wikipedia.org/wiki/Proth_prime)'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Proth素数](https://zh.wikipedia.org/wiki/Proth素数)'
- en: '[PRE202]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Returns True if `n` is a Mersenne prime, else False.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`n`是梅森素数则返回True，否则返回False。
- en: A Mersenne prime is a prime number having the form \(2^i - 1\).
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 梅森素数是形如\(2^i - 1\)的素数。
- en: Examples
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE203]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: References
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R696](#id53)]'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R696](#id53)]'
- en: '[https://mathworld.wolfram.com/MersennePrime.html](https://mathworld.wolfram.com/MersennePrime.html)'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/MersennePrime.html](https://mathworld.wolfram.com/MersennePrime.html)'
- en: '[PRE204]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Test if n is a prime number (True) or not (False). For n < 2^64 the answer is
    definitive; larger n values have a small probability of actually being pseudoprimes.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 测试n是否为素数（True）或不是素数（False）。对于n < 2^64，答案是确定的；较大的n值可能实际上是伪素数。
- en: Negative numbers (e.g. -2) are not considered prime.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 负数（例如 -2）不被认为是素数。
- en: The first step is looking for trivial factors, which if found enables a quick
    return. Next, if the sieve is large enough, use bisection search on the sieve.
    For small numbers, a set of deterministic Miller-Rabin tests are performed with
    bases that are known to have no counterexamples in their range. Finally if the
    number is larger than 2^64, a strong BPSW test is performed. While this is a probable
    prime test and we believe counterexamples exist, there are no known counterexamples.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是寻找显著因子，如果找到则可以快速返回。接下来，如果筛选器足够大，则在筛选器上使用二分搜索。对于小数字，使用已知在其范围内没有反例的基数进行确定性Miller-Rabin测试。最后，如果数字大于2^64，则执行强BPSW测试。虽然这是一个可能的素数测试，我们相信存在反例，但目前没有已知的反例。
- en: Examples
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE205]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Notes
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This routine is intended only for integer input, not numerical expressions
    which may represent numbers. Floats are also rejected as input because they represent
    numbers of limited precision. While it is tempting to permit 7.0 to represent
    an integer there are errors that may “pass silently” if this is allowed:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序仅适用于整数输入，不适用于可能代表数字的数值表达式。浮点数也会被拒绝，因为它们代表有限精度的数字。虽然允许7.0表示整数很诱人，但如果允许这样做可能会“悄悄地”传递错误：
- en: '[PRE206]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: See also
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.ntheory.generate.primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.generate.primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
- en: Generates all primes in a given range
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定范围内生成所有素数
- en: '[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi")'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi")'
- en: Return the number of primes less than or equal to n
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 返回小于或等于n的素数数量
- en: '[`sympy.ntheory.generate.prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.generate.prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
- en: Return the nth prime
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第n个素数
- en: References
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R697](#id54)]'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R697](#id54)]'
- en: '[https://en.wikipedia.org/wiki/Strong_pseudoprime](https://en.wikipedia.org/wiki/Strong_pseudoprime)'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/强伪素数](https://zh.wikipedia.org/wiki/强伪素数)'
- en: '[[R698](#id55)]'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R698](#id55)]'
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
- en: '[[R699](#id56)]'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R699](#id56)]'
- en: '[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)'
- en: '[PRE208]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Test if num is a Gaussian prime number.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 num 是否为高斯素数。
- en: References
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R700](#id57)]'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R700](#id57)]'
- en: '[https://oeis.org/wiki/Gaussian_primes](https://oeis.org/wiki/Gaussian_primes)'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://oeis.org/wiki/Gaussian_primes](https://oeis.org/wiki/Gaussian_primes)'
- en: '[PRE209]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Returns the order of `a` modulo `n`.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `a` 模 `n` 的阶数。
- en: 'Parameters:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: '**n** : integer, n > 1\. a and n should be relatively prime'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数，n > 1。`a` 和 `n` 应该是相对素的。'
- en: 'Returns:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**int** : the order of `a` modulo `n`'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数**：`a` 模 `n` 的阶数'
- en: 'Raises:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: If \(n \le 1\) or \(\gcd(a, n) \neq 1\). If `a` or `n` is not an integer.
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 \(n \le 1\) 或 \(\gcd(a, n) \neq 1\)。如果 `a` 或 `n` 不是整数。
- en: Explanation
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The order of `a` modulo `n` is the smallest integer `k` such that \(a^k\) leaves
    a remainder of 1 with `n`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 模 `n` 的阶数是最小的整数 `k`，使得 \(a^k\) 在 `n` 上留下余数。'
- en: Examples
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE210]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: See also
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
- en: We say that `a` is a primitive root of `n` when the order of `a` modulo `n`
    equals `totient(n)`
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `a` 模 `n` 的阶数等于 `totient(n)` 时，我们说 `a` 是 `n` 的原根。
- en: '[PRE211]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Returns True if `a` is a primitive root of `p`.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a` 是 `p` 的原根，则返回 True。
- en: 'Parameters:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**a**：整数'
- en: '**p** : integer, `p` > 1\. `a` and `p` should be relatively prime'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '**p**：整数，`p` > 1。`a` 和 `p` 应该是相对素的。'
- en: 'Returns:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If True, `a` is the primitive root of `p`.'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔**：如果为 True，则 `a` 是 `p` 的原根。'
- en: 'Raises:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: If \(p \le 1\) or \(\gcd(a, p) \neq 1\). If `a` or `p` is not an integer.
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 \(p \le 1\) 或 \(\gcd(a, p) \neq 1\)。如果 `a` 或 `p` 不是整数。
- en: Explanation
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`a` is said to be the primitive root of `p` if \(\gcd(a, p) = 1\) and \(\phi(p)\)
    is the smallest positive number s.t.'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(\gcd(a, p) = 1\) 并且 \(\phi(p)\) 是最小的正数，`a` 被称为 `p` 的原根。
- en: \(a^{\phi(p)} \equiv 1 \pmod{p}\).
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(a^{\phi(p)} \equiv 1 \pmod{p}\)。
- en: where \(\phi(p)\) is Euler’s totient function.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\phi(p)\) 是欧拉函数。
- en: The primitive root of `p` exist only for \(p = 2, 4, q^e, 2q^e\) (`q` is an
    odd prime). Hence, if it is not such a `p`, it returns False. To determine the
    primitive root, we need to know the prime factorization of `q-1`. The hardness
    of the determination depends on this complexity.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 只有对于 \(p = 2, 4, q^e, 2q^e\)（`q` 是奇素数），`p` 的原根才存在。因此，如果不是这样的 `p`，则返回 False。要确定原根，我们需要知道
    `q-1` 的素因子分解。这种确定的难度取决于这种复杂性。
- en: Examples
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE212]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: See also
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`primitive_root`](#sympy.ntheory.residue_ntheory.primitive_root "sympy.ntheory.residue_ntheory.primitive_root")'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '[`primitive_root`](#sympy.ntheory.residue_ntheory.primitive_root "sympy.ntheory.residue_ntheory.primitive_root")'
- en: '[PRE213]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Returns a primitive root of `p` or None.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `p` 的一个原根或 None。
- en: 'Parameters:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**p** : integer, p > 1'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**p**：整数，p > 1'
- en: '**smallest** : if True the smallest primitive root is returned or None'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小**：如果为 True，则返回最小的原根，否则返回 None。'
- en: 'Returns:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: 'int | None :'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: int | None：
- en: If the primitive root exists, return the primitive root of `p`. If not, return
    None.
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果存在原根，则返回 `p` 的原根。否则，返回 None。
- en: 'Raises:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: If \(p \le 1\) or `p` is not an integer.
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 \(p \le 1\) 或 `p` 不是整数。
- en: Explanation
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: For the definition of primitive root, see the explanation of `is_primitive_root`.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 有关原根定义，请参阅 `is_primitive_root` 的解释。
- en: The primitive root of `p` exist only for \(p = 2, 4, q^e, 2q^e\) (`q` is an
    odd prime). Now, if we know the primitive root of `q`, we can calculate the primitive
    root of \(q^e\), and if we know the primitive root of \(q^e\), we can calculate
    the primitive root of \(2q^e\). When there is no need to find the smallest primitive
    root, this property can be used to obtain a fast primitive root. On the other
    hand, when we want the smallest primitive root, we naively determine whether it
    is a primitive root or not.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`p`的原始根仅适用于\(p = 2, 4, q^e, 2q^e\)（`q`是奇质数）。现在，如果我们知道`q`的原始根，我们可以计算\(q^e\)的原始根，如果我们知道\(q^e\)的原始根，我们可以计算\(2q^e\)的原始根。当不需要找到最小的原始根时，这个性质可以用来获取快速的原始根。另一方面，当我们想要最小的原始根时，我们会天真地确定是否是原始根。
- en: Examples
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE214]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: See also
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
- en: References
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: '[[R701](#id58)]'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R701](#id58)]'
- en: Stein “Elementary Number Theory” (2011), page 44
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stein“初等数论”（2011年），第44页
- en: '[[R702](#id59)]'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R702](#id59)]'
- en: Hackman “Elementary Number Theory” (2009), Chapter C
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hackman“初等数论”（2009年），第C章
- en: '[PRE215]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Find a root of `x**2 = a mod p`.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`x**2 = a mod p`的根。
- en: 'Parameters:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** ：整数'
- en: '**p** : positive integer'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** ：正整数'
- en: '**all_roots** : if True the list of roots is returned or None'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**all_roots** ：如果为True则返回根列表或None'
- en: Notes
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 注：
- en: If there is no root it is returned None; else the returned root is less or equal
    to `p // 2`; in general is not the smallest one. It is returned `p // 2` only
    if it is the only root.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有根则返回None；否则返回的根小于或等于`p // 2`；一般来说不是最小的。仅当它是唯一的根时返回`p // 2`。
- en: Use `all_roots` only when it is expected that all the roots fit in memory; otherwise
    use `sqrt_mod_iter`.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在预期所有根都适合内存时使用`all_roots`；否则使用`sqrt_mod_iter`。
- en: Examples
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE216]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Iterate over solutions to `x**2 = a mod p`.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代解决`x**2 = a mod p`。
- en: 'Parameters:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** ：整数'
- en: '**p** : positive integer'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** ：正整数'
- en: '**domain** : integer domain, `int`, `ZZ` or `Integer`'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**domain** ：整数域，`int`，`ZZ` 或 `Integer`'
- en: Examples
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE218]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: See also
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
- en: Same functionality, but you want a sorted list or only one solution.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同功能，但要求排序列表或仅有一个解。
- en: '[PRE219]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Returns the list of quadratic residues.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 返回二次剩余的列表。
- en: Examples
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE220]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Find the solutions to `x**n = a mod p`.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`x**n = a mod p`的解决方案。
- en: 'Parameters:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** ：整数'
- en: '**n** : positive integer'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** ：正整数'
- en: '**p** : positive integer'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** ：正整数'
- en: '**all_roots** : if False returns the smallest root, else the list of roots'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**all_roots** ：如果为False，则返回最小的根，否则返回根列表'
- en: 'Returns:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: 'list[int] | int | None :'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: list[int] | int | None：
- en: 'solutions to `x**n = a mod p`. The table of the output type is:'
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决`x**n = a mod p`。输出类型表如下：
- en: ''
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| all_roots | has roots | Returns |'
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| all_roots | has roots | Returns |'
- en: '| --- | --- | --- |'
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| True | Yes | list[int] |'
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| True | Yes | list[int] |'
- en: '| True | No | [] |'
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| True | No | [] |'
- en: '| False | Yes | int |'
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| False | Yes | int |'
- en: '| False | No | None |'
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| False | No | None |'
- en: 'Raises:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: If `a`, `n` or `p` is not integer. If `n` or `p` is not positive.
  id: totrans-1090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`，`n`或`p`不是整数。如果`n`或`p`不是正数。
- en: Examples
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE222]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: References
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: '[[R703](#id60)]'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R703](#id60)]'
- en: Hackman “Elementary Number Theory” (2009), page 76
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hackman“初等数论”（2009年），第76页
- en: '[PRE223]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Returns True if `x**n == a (mod m)` has solutions.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x**n == a (mod m)`有解则返回True。
- en: References
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: '[[R704](#id61)]'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R704](#id61)]'
- en: Hackman “Elementary Number Theory” (2009), page 76
  id: totrans-1100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hackman“初等数论”（2009年），第76页
- en: '[PRE224]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Returns True if `a` (mod `p`) is in the set of squares mod `p`, i.e a % p in
    set([i**2 % p for i in range(p)]).
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`a`（mod `p`）在`p`的平方集中，则返回True，即a % p在set([i**2 % p for i in range(p)])中。
- en: 'Parameters:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** ：整数'
- en: '**p** : positive integer'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** ：正整数'
- en: 'Returns:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**bool** : If True, `x**2 == a (mod p)` has solution.'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '**bool** ：如果为True，则`x**2 == a (mod p)`有解。'
- en: 'Raises:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: If `a`, `p` is not integer. If `p` is not positive.
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`，`p`不是整数。如果`p`不是正数。
- en: Examples
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE225]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Indeed, `pow(39, 2, 100)` would be 21.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`pow(39, 2, 100)`将是21。
- en: '[PRE226]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: That is, for any integer `x`, `pow(x, 2, 120)` is not 21.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 即，对于任何整数`x`，`pow(x, 2, 120)`不是21。
- en: 'If `p` is an odd prime, an iterative method is used to make the determination:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`p`是奇质数，则使用迭代方法进行确定：
- en: '[PRE227]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: See also
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol"),
    [`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol"),
    [`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
- en: '[PRE228]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Returns the Legendre symbol \((a / p)\).
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回勒让德符号 \((a / p)\)。
- en: 'Deprecated since version 1.13: The `legendre_symbol` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.legendre_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.legendre_symbol
    "sympy.functions.combinatorial.numbers.legendre_symbol") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.13 起已弃用：`legendre_symbol` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.legendre_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.legendre_symbol
    "sympy.functions.combinatorial.numbers.legendre_symbol") 替代。更多信息请参阅其文档。参见 [将符号函数从
    ntheory 迁移到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    以获取详细信息。
- en: For an integer `a` and an odd prime `p`, the Legendre symbol is defined as
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数 `a` 和奇素数 `p`，勒让德符号定义为
- en: \[\begin{split}\genfrac(){}{}{a}{p} = \begin{cases} 0 & \text{if } p \text{
    divides } a\\ 1 & \text{if } a \text{ is a quadratic residue modulo } p\\ -1 &
    \text{if } a \text{ is a quadratic nonresidue modulo } p \end{cases}\end{split}\]
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\genfrac(){}{}{a}{p} = \begin{cases} 0 & \text{如果 } p \text{
    整除 } a\\ 1 & \text{如果 } a \text{ 是模 } p \text{ 的二次剩余}\\ -1 & \text{如果 } a \text{
    是模 } p \text{ 的二次非剩余} \end{cases}\end{split}\]
- en: 'Parameters:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : integer'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** : 整数'
- en: '**p** : odd prime'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** : 奇素数'
- en: Examples
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE229]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: See also
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol")'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol")'
- en: '[PRE230]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Returns the Jacobi symbol \((m / n)\).
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回雅可比符号 \((m / n)\)。
- en: 'Deprecated since version 1.13: The `jacobi_symbol` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.jacobi_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.jacobi_symbol
    "sympy.functions.combinatorial.numbers.jacobi_symbol") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.13 起已弃用：`jacobi_symbol` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.jacobi_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.jacobi_symbol
    "sympy.functions.combinatorial.numbers.jacobi_symbol") 替代。更多信息请参阅其文档。参见 [将符号函数从
    ntheory 迁移到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    以获取详细信息。
- en: 'For any integer `m` and any positive odd integer `n` the Jacobi symbol is defined
    as the product of the Legendre symbols corresponding to the prime factors of `n`:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意整数 `m` 和任意正奇整数 `n`，雅可比符号定义为 `n` 的素因子对应的勒让德符号的乘积：
- en: \[\genfrac(){}{}{m}{n} = \genfrac(){}{}{m}{p^{1}}^{\alpha_1} \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
    ... \genfrac(){}{}{m}{p^{k}}^{\alpha_k} \text{ where } n = p_1^{\alpha_1} p_2^{\alpha_2}
    ... p_k^{\alpha_k}\]
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: \[\genfrac(){}{}{m}{n} = \genfrac(){}{}{m}{p^{1}}^{\alpha_1} \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
    ... \genfrac(){}{}{m}{p^{k}}^{\alpha_k} \text{ 其中 } n = p_1^{\alpha_1} p_2^{\alpha_2}
    ... p_k^{\alpha_k}\]
- en: Like the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n} = -1\)
    then `m` is a quadratic nonresidue modulo `n`.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 像勒让德符号一样，如果雅可比符号 \(\genfrac(){}{}{m}{n} = -1\)，则 `m` 是模 `n` 的二次非剩余。
- en: But, unlike the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n}
    = 1\) then `m` may or may not be a quadratic residue modulo `n`.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 但与勒让德符号不同的是，如果雅可比符号 \(\genfrac(){}{}{m}{n} = 1\)，则 `m` 可能是模 `n` 的二次剩余，也可能不是。
- en: 'Parameters:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**m** : integer'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '**m** : 整数'
- en: '**n** : odd positive integer'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 奇正整数'
- en: Examples
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE231]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The relationship between the `jacobi_symbol` and `legendre_symbol` can be demonstrated
    as follows:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '`jacobi_symbol` 和 `legendre_symbol` 之间的关系可以如下所示：'
- en: '[PRE232]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: See also
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"),
    [`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol")'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue")，[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol
    "sympy.ntheory.residue_ntheory.legendre_symbol")'
- en: '[PRE233]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Mobius function maps natural number to {-1, 0, 1}
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: Möbius 函数将自然数映射到{-1, 0, 1}
- en: 'Deprecated since version 1.13: The `mobius` function is deprecated. Use [`sympy.functions.combinatorial.numbers.mobius`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.mobius
    "sympy.functions.combinatorial.numbers.mobius") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.13起不推荐使用`mobius`函数。请使用[`sympy.functions.combinatorial.numbers.mobius`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.mobius
    "sympy.functions.combinatorial.numbers.mobius")。有关详细信息，请参阅其文档。有关详细信息，请参阅[从ntheory移动符号函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。
- en: 'It is defined as follows:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 定义如下：
- en: \(1\) if \(n = 1\).
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果\(n = 1\)，则为\(1\)。
- en: \(0\) if \(n\) has a squared prime factor.
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果\(n\)有一个平方素因子，则为\(0\)。
- en: \((-1)^k\) if \(n\) is a square-free positive integer with \(k\) number of prime
    factors.
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果\(n\)是具有\(k\)个素因子的无平方正整数，则为\((-1)^k\)。
- en: It is an important multiplicative function in number theory and combinatorics.
    It has applications in mathematical series, algebraic number theory and also physics
    (Fermion operator has very concrete realization with Mobius Function model).
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 它是数论和组合数学中的重要乘性函数。在数学级数、代数数论以及物理学中（费米子算子与 Möbius 函数模型有着非常具体的实现）有应用。
- en: 'Parameters:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : positive integer'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 正整数'
- en: Examples
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE234]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: References
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R705](#id62)]'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R705](#id62)]'
- en: '[https://en.wikipedia.org/wiki/M%C3%B6bius_function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/M%C3%B6bius_function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)'
- en: '[[R706](#id63)]'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R706](#id63)]'
- en: Thomas Koshy “Elementary Number Theory with Applications”
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: Thomas Koshy 的《Elementary Number Theory with Applications》
- en: '[PRE235]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Compute the discrete logarithm of `a` to the base `b` modulo `n`.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`a`以模`n`为底的离散对数。
- en: This is a recursive function to reduce the discrete logarithm problem in cyclic
    groups of composite order to the problem in cyclic groups of prime order.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归函数，用于将复合阶循环群中的离散对数问题简化为素数阶循环群中的问题。
- en: 'It employs different algorithms depending on the problem (subgroup order size,
    prime order or not):'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据问题使用不同的算法（子群阶大小，是否为素数阶）：
- en: Trial multiplication
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 试乘法
- en: ''
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Baby-step giant-step
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Baby-step giant-step算法
- en: ''
  id: totrans-1173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1174
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Pollard’s Rho
  id: totrans-1175
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 波拉德Rho算法
- en: ''
  id: totrans-1176
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1177
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Index Calculus
  id: totrans-1178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数演算法
- en: ''
  id: totrans-1179
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1180
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Pohlig-Hellman
  id: totrans-1181
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pohlig-Hellman
- en: Examples
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE236]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: References
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R707](#id64)]'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R707](#id64)]'
- en: '[https://mathworld.wolfram.com/DiscreteLogarithm.html](https://mathworld.wolfram.com/DiscreteLogarithm.html)'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/DiscreteLogarithm.html](https://mathworld.wolfram.com/DiscreteLogarithm.html)'
- en: '[[R708](#id65)]'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R708](#id65)]'
- en: “Handbook of applied cryptography”, Menezes, A. J., Van, O. P. C., & Vanstone,
    S. A. (1997).
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: “应用密码学手册”，Menezes, A. J., Van, O. P. C., & Vanstone, S. A. (1997).
- en: '[PRE237]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Find the solutions to \(a x^2 + b x + c \equiv 0 \pmod{n}\).
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 找到满足\(a x^2 + b x + c \equiv 0 \pmod{n}\)的解。
- en: 'Parameters:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a** : int'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '**a** : int'
- en: '**b** : int'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**b** : int'
- en: '**c** : int'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '**c** : int'
- en: '**n** : int'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : int'
- en: A positive integer.
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正整数。
- en: 'Returns:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: 'list[int] :'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: list[int]：
- en: A sorted list of solutions. If no solution exists, `[]`.
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解的排序列表。如果没有解，则为`[]`。
- en: Examples
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE238]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: See also
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`polynomial_congruence`](#sympy.ntheory.residue_ntheory.polynomial_congruence
    "sympy.ntheory.residue_ntheory.polynomial_congruence")'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '[`polynomial_congruence`](#sympy.ntheory.residue_ntheory.polynomial_congruence
    "sympy.ntheory.residue_ntheory.polynomial_congruence")'
- en: Solve the polynomial congruence
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 解多项式同余方程
- en: '[PRE239]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Find the solutions to a polynomial congruence equation modulo m.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 解多项式同余方程模m。
- en: 'Parameters:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : integer coefficient polynomial'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr** : 整数系数多项式'
- en: '**m** : positive integer'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '**m** : 正整数'
- en: Examples
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE240]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: See also
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.polys.galoistools.gf_csolve`](polys/internals.html#sympy.polys.galoistools.gf_csolve
    "sympy.polys.galoistools.gf_csolve")'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.galoistools.gf_csolve`](polys/internals.html#sympy.polys.galoistools.gf_csolve
    "sympy.polys.galoistools.gf_csolve")'
- en: low level solving routine used by this routine
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 低级解决例程由该例程使用
- en: '[PRE241]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Compute `binomial(n, m) % k`.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`binomial(n, m) % k`。
- en: 'Parameters:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : an integer'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 整数'
- en: '**m** : an integer'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '**m** : 整数'
- en: '**k** : a positive integer'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '**k** : 正整数'
- en: Explanation
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Returns `binomial(n, m) % k` using a generalization of Lucas’ Theorem for prime
    powers given by Granville [[R709]](#r709), in conjunction with the Chinese Remainder
    Theorem. The residue for each prime power is calculated in time O(log^2(n) + q^4*log(n)log(p)
    + q^4*p*log^3(p)).
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Lucas 定理的一般化与 Granville 的 [R709](#r709)（由中国剩余定理）提供的素数幂的余数计算时间为 O(log^2(n)
    + q^4*log(n)log(p) + q^4*p*log^3(p))。
- en: Examples
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE242]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: References
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R709] ([1](#id66),[2](#id67))'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '[R709] ([1](#id66),[2](#id67))'
- en: 'Binomial coefficients modulo prime powers, Andrew Granville, Available: [https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf)'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 模素数幂的二项式系数，Andrew Granville，可用：[https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf)
- en: '[PRE243]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Return the continued fraction representation of a Rational or quadratic irrational.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 返回有理数或二次无理数的连分数表示。
- en: Examples
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE244]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: See also
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce"), [`continued_fraction_convergents`](#sympy.ntheory.continued_fraction.continued_fraction_convergents
    "sympy.ntheory.continued_fraction.continued_fraction_convergents")'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce"), [`continued_fraction_convergents`](#sympy.ntheory.continued_fraction.continued_fraction_convergents
    "sympy.ntheory.continued_fraction.continued_fraction_convergents")'
- en: '[PRE245]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Return an iterator over the convergents of a continued fraction (cf).
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个连分数（CF）的收敛数迭代器。
- en: 'The parameter should be in either of the following to forms: - A list of partial
    quotients, possibly with the last element being a list of repeating partial quotients,
    such as might be returned by continued_fraction and continued_fraction_periodic.
    - An iterable returning successive partial quotients of the continued fraction,
    such as might be returned by continued_fraction_iterator.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 参数应该是以下两种形式之一：- 部分商的列表，最后一个元素可能是重复的部分商列表，例如由 continued_fraction 和 continued_fraction_periodic
    返回的形式。- 返回连分数的连续部分商的可迭代对象，例如由 continued_fraction_iterator 返回的形式。
- en: In computing the convergents, the continued fraction need not be strictly in
    canonical form (all integers, all but the first positive). Rational and negative
    elements may be present in the expansion.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算收敛分数时，连分数不必严格处于规范形式（全为整数，除了第一个为正数）。分数和负数元素可能存在于展开中。
- en: Examples
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE246]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: See also
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction`](#sympy.ntheory.continued_fraction.continued_fraction
    "sympy.ntheory.continued_fraction.continued_fraction"), [`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction`](#sympy.ntheory.continued_fraction.continued_fraction
    "sympy.ntheory.continued_fraction.continued_fraction"), [`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
- en: '[PRE251]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Return continued fraction expansion of x as iterator.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 x 的连分数展开作为迭代器。
- en: Examples
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE252]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: References
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R710](#id68)]'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R710](#id68)]'
- en: '[https://en.wikipedia.org/wiki/Continued_fraction](https://en.wikipedia.org/wiki/Continued_fraction)'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/连分数](https://zh.wikipedia.org/wiki/连分数)'
- en: '[PRE255]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Find the periodic continued fraction expansion of a quadratic irrational.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 找到二次无理数的周期连分数展开。
- en: Compute the continued fraction expansion of a rational or a quadratic irrational
    number, i.e. \(\frac{p + s\sqrt{d}}{q}\), where \(p\), \(q \ne 0\) and \(d \ge
    0\) are integers.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 计算有理数或二次无理数的连分数展开，即 \(\frac{p + s\sqrt{d}}{q}\)，其中 \(p\)，\(q \ne 0\)，\(d \ge
    0\) 为整数。
- en: Returns the continued fraction representation (canonical form) as a list of
    integers, optionally ending (for quadratic irrationals) with list of integers
    representing the repeating digits.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为整数列表返回连分数表示（规范形式），对于二次无理数，可选地以表示重复数字的整数列表结束。
- en: 'Parameters:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**p** : int'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** : int'
- en: the rational part of the number’s numerator
  id: totrans-1261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数字的有理数部分
- en: '**q** : int'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**q**：整数'
- en: the denominator of the number
  id: totrans-1263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数字的分母
- en: '**d** : int, optional'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**d**：整数，可选'
- en: the irrational part (discriminator) of the number’s numerator
  id: totrans-1265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数字的分母
- en: '**s** : int, optional'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**：整数，可选'
- en: the coefficient of the irrational part
  id: totrans-1267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无理部分的系数
- en: Examples
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE256]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Golden ratio has the simplest continued fraction expansion:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金分割率具有最简单的连分数展开：
- en: '[PRE257]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'If the discriminator is zero or a perfect square then the number will be a
    rational number:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鉴别器为零或完全平方数，则该数字将是有理数：
- en: '[PRE258]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: See also
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce")'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce")'
- en: References
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R711](#id69)]'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R711](#id69)]'
- en: '[https://en.wikipedia.org/wiki/Periodic_continued_fraction](https://en.wikipedia.org/wiki/Periodic_continued_fraction)'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/周期连分数](https://zh.wikipedia.org/wiki/周期连分数)'
- en: '[[R712](#id70)]'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R712](#id70)]'
- en: K. Rosen. Elementary Number theory and its applications. Addison-Wesley, 3 Sub
    edition, pages 379-381, January 1992.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: K. Rosen. Elementary Number theory and its applications. Addison-Wesley, 3 Sub
    edition, pages 379-381, January 1992.
- en: '[PRE259]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Reduce a continued fraction to a rational or quadratic irrational.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个连分数化简为有理数或二次无理数。
- en: Compute the rational or quadratic irrational number from its terminating or
    periodic continued fraction expansion. The continued fraction expansion (cf) should
    be supplied as a terminating iterator supplying the terms of the expansion. For
    terminating continued fractions, this is equivalent to `list(continued_fraction_convergents(cf))[-1]`,
    only a little more efficient. If the expansion has a repeating part, a list of
    the repeating terms should be returned as the last element from the iterator.
    This is the format returned by continued_fraction_periodic.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 从其终止或周期连分数展开计算有理或二次无理数。连分数展开（cf）应被视为提供展开项的终止迭代器。对于终止连分数，这相当于`list(continued_fraction_convergents(cf))[-1]`，只是效率稍高。如果展开部分重复，迭代器应返回重复项的列表作为最后一个元素。这是由continued_fraction_periodic返回的格式。
- en: For quadratic irrationals, returns the largest solution found, which is generally
    the one sought, if the fraction is in canonical form (all terms positive except
    possibly the first).
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二次无理数，如果分数处于规范形式（除第一个外所有项均为正），则返回找到的最大解，通常是所需解。
- en: Examples
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE260]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: See also
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
- en: '[PRE261]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Return a dictionary whose keys are the digits of `n` in the given base, `b`,
    with keys indicating the digits appearing in the number and values indicating
    how many times that digit appeared.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个字典，其键是数字`n`在给定基数`b`中的数字，键表示数字出现在数字中的位置，值表示该数字出现的次数。
- en: Examples
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE262]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'The digits returned are always represented in base-10 but the number itself
    can be entered in any format that is understood by Python; the base of the number
    can also be given if it is different than 10:'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数字始终以十进制表示，但数字本身可以以Python理解的任何格式输入；如果数字的基数与10不同，也可以给出数字的基数：
- en: '[PRE264]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'The default dictionary will return a 0 for any digit that did not appear in
    the number. For example, which digits appear 7 times in `77!`:'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字典将对任何未出现在数字中的数字返回0。例如，`77!`中出现7次的数字有哪些：
- en: '[PRE265]'
  id: totrans-1297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: See also
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`digits`](#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits")'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`digits`](#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits")'
- en: '[PRE266]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Return a list of the digits of `n` in base `b`. The first element in the list
    is `b` (or `-b` if `n` is negative).
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`n`在基数`b`中的数字列表。列表中的第一个元素是`b`（如果`n`为负，则为`-b`）。
- en: 'Parameters:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n: integer**'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '**n：整数**'
- en: The number whose digits are returned.
  id: totrans-1304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回数字的位数。
- en: '**b: integer**'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '**b：整数**'
- en: The base in which digits are computed.
  id: totrans-1306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算数字的基数。
- en: '**digits: integer (or None for all digits)**'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '**digits：整数（或所有数字的None）**'
- en: The number of digits to be returned (padded with zeros, if necessary).
  id: totrans-1308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要返回的数字位数（如有必要，用零填充）。
- en: Examples
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE267]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'If the number is negative, the negative sign will be placed on the base (which
    is the first element in the returned list):'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字为负，则负号将放在基数上（即返回列表中的第一个元素）：
- en: '[PRE268]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Bases other than 10 (and greater than 1) can be selected with `b`:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择除了 10（大于 1 的）以外的基数 `b`：
- en: '[PRE269]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Use the `digits` keyword if a certain number of digits is desired:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要某个特定数量的数字，请使用 `digits` 关键字：
- en: '[PRE270]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: See also
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
- en: '[PRE271]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: return True if `n` is the same when read from left to right or right to left
    in the given base, `b`.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在给定的基数 `b` 中从左到右或从右到左读取 `n` 时相同，则返回 True。
- en: Examples
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE272]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The second argument allows you to test numbers in other bases. For example,
    88 is palindromic in base-10 but not in base-8:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数允许您在其他基数中测试数字。例如，88 在十进制中是回文的，但在八进制中不是：
- en: '[PRE274]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'On the other hand, a number can be palindromic in base-8 but not in base-10:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个数字在八进制中可能是回文的，但在十进制中不是：
- en: '[PRE275]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Or it might be palindromic in both bases:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在两个基础上是回文的：
- en: '[PRE276]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Return the list of denominators of an Egyptian fraction expansion [[R713]](#r713)
    of the said rational \(r\).
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所述有理数 \(r\) 的埃及分数展开的分母列表[[R713]](#r713)。
- en: 'Parameters:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**r** : Rational or (p, q)'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '**r**：有理数或（p，q）'
- en: a positive rational number, `p/q`.
  id: totrans-1334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正有理数 `p/q`。
- en: '**algorithm** : { “Greedy”, “Graham Jewett”, “Takenouchi”, “Golomb” }, optional'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '**algorithm**：{“贪婪”，“Graham Jewett”，“Takenouchi”，“Golomb”}，可选'
- en: Denotes the algorithm to be used (the default is “Greedy”).
  id: totrans-1336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定要使用的算法（默认为“贪婪”）。
- en: Examples
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE278]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: Notes
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Currently the following algorithms are supported:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 目前支持以下算法：
- en: Greedy Algorithm
  id: totrans-1341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: Also called the Fibonacci-Sylvester algorithm [[R714]](#r714). At each step,
    extract the largest unit fraction less than the target and replace the target
    with the remainder.
  id: totrans-1342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也称为 Fibonacci-Sylvester 算法[[R714]](#r714)。在每一步中，提取小于目标的最大单位分数，并用余数替换目标。
- en: 'It has some distinct properties:'
  id: totrans-1343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它具有一些独特的属性：
- en: Given \(p/q\) in lowest terms, generates an expansion of maximum length \(p\).
    Even as the numerators get large, the number of terms is seldom more than a handful.
  id: totrans-1344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定最简分数 \(p/q\)，生成最大长度 \(p\) 的展开。即使分子变大，项数也很少超过一把。
- en: Uses minimal memory.
  id: totrans-1345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最小内存。
- en: The terms can blow up (standard examples of this are 5/121 and 31/311). The
    denominator is at most squared at each step (doubly-exponential growth) and typically
    exhibits singly-exponential growth.
  id: totrans-1346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语可以爆炸（其标准示例为 5/121 和 31/311）。每一步中的分母最多是平方的（双指数增长），通常表现出单指数增长。
- en: Graham Jewett Algorithm
  id: totrans-1347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Graham Jewett 算法
- en: 'The algorithm suggested by the result of Graham and Jewett. Note that this
    has a tendency to blow up: the length of the resulting expansion is always `2**(x/gcd(x,
    y)) - 1`. See [[R715]](#r715).'
  id: totrans-1348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 Graham 和 Jewett 的结果建议的算法。请注意，这倾向于爆炸：结果展开的长度始终为 `2**(x/gcd(x, y)) - 1`。参见[[R715]](#r715)。
- en: Takenouchi Algorithm
  id: totrans-1349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Takenouchi 算法
- en: The algorithm suggested by Takenouchi (1921). Differs from the Graham-Jewett
    algorithm only in the handling of duplicates. See [[R715]](#r715).
  id: totrans-1350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 Takenouchi（1921）建议的算法。与 Graham-Jewett 算法仅在处理重复项时有所不同。参见[[R715]](#r715)。
- en: Golomb’s Algorithm
  id: totrans-1351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Golomb 算法
- en: A method given by Golumb (1962), using modular arithmetic and inverses. It yields
    the same results as a method using continued fractions proposed by Bleicher (1972).
    See [[R716]](#r716).
  id: totrans-1352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 Golumb（1962）提出的方法，使用模算术和逆元。它与 Bleicher（1972）提出的使用连分数的方法产生相同的结果。参见[[R716]](#r716)。
- en: If the given rational is greater than or equal to 1, a greedy algorithm of summing
    the harmonic sequence 1/1 + 1/2 + 1/3 + … is used, taking all the unit fractions
    of this sequence until adding one more would be greater than the given number.
    This list of denominators is prefixed to the result from the requested algorithm
    used on the remainder. For example, if r is 8/3, using the Greedy algorithm, we
    get [1, 2, 3, 4, 5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2,
    3, 4, 5, 6, 7] is part of the harmonic sequence summing to 363/140, leaving a
    remainder of 31/420, which yields [14, 420] by the Greedy algorithm. The result
    of egyptian_fraction(Rational(8, 3), “Golomb”) is [1, 2, 3, 4, 5, 6, 7, 14, 574,
    2788, 6460, 11590, 33062, 113820], and so on.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的有理数大于或等于1，则使用贪婪算法对和谐序列1/1 + 1/2 + 1/3 + …进行求和，直到添加一个以上的单位分数会比给定的数字大。这些分母的列表被添加到从剩余部分使用的请求算法的结果前面。例如，如果r是8/3，使用贪婪算法，我们得到[1,
    2, 3, 4, 5, 6, 7, 14, 420]，其中序列的开头[1, 2, 3, 4, 5, 6, 7]是和谐序列的一部分，总和为363/140，剩余31/420，贪婪算法产生[14,
    420]。埃及分数(Rational(8, 3),“Golomb”)的结果是[1, 2, 3, 4, 5, 6, 7, 14, 574, 2788, 6460,
    11590, 33062, 113820]，等等。
- en: See also
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.numbers.Rational`](core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.numbers.Rational`](core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
- en: References
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R713] ([1](#id71),[2](#id76))'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '[R713] ([1](#id71),[2](#id76))'
- en: '[https://en.wikipedia.org/wiki/Egyptian_fraction](https://en.wikipedia.org/wiki/Egyptian_fraction)'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Egyptian_fraction](https://en.wikipedia.org/wiki/Egyptian_fraction)'
- en: '[R714] ([1](#id72),[2](#id77))'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '[R714] ([1](#id72),[2](#id77))'
- en: '[https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions](https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions)'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions](https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions)'
- en: '[R715] ([1](#id73),[2](#id74),[3](#id78))'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '[R715] ([1](#id73),[2](#id74),[3](#id78))'
- en: '[https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html](https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html)'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html](https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html)'
- en: '[R716] ([1](#id75),[2](#id79))'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '[R716] ([1](#id75),[2](#id79))'
- en: '[https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf](https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf)'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf](https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf)'
- en: '[PRE279]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Returns a string containing `prec` (default 14) digits starting at the nth digit
    of pi in hex. Counting of digits starts at 0 and the decimal is not counted, so
    for n = 0 the returned value starts with 3; n = 1 corresponds to the first digit
    past the decimal point (which in hex is 2).
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含`prec`（默认为14）个十六进制π的第n位开始的数字的字符串。数字的计数从0开始，小数点不计入，所以当n = 0时，返回的值以3开头；n
    = 1对应于小数点后的第一个数字（在十六进制中为2）。
- en: 'Parameters:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : non-negative integer'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：非负整数'
- en: '**prec** : non-negative integer. default = 14'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '**prec**：非负整数，默认为14'
- en: 'Returns:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**str** : Returns a string containing `prec` digits'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '**str**：返回一个包含`prec`个数字的字符串'
- en: starting at the nth digit of pi in hex. If `prec` = 0, returns empty string.
  id: totrans-1372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从π的第n位开始的十六进制。如果`prec` = 0，则返回空字符串。
- en: 'Raises:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 提升：
- en: '**ValueError**'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: If `n` < 0 or `prec` < 0. Or `n` or `prec` is not an integer.
  id: totrans-1375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`n` < 0或`prec` < 0。或`n`或`prec`不是整数。
- en: Examples
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE280]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: These are consistent with the following results
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与以下结果一致
- en: '[PRE281]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: References
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R717](#id80)]'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R717](#id80)]'
- en: '[http://www.numberworld.org/digits/Pi/](http://www.numberworld.org/digits/Pi/)'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.numberworld.org/digits/Pi/](http://www.numberworld.org/digits/Pi/)'
- en: '## ECM function'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: '## ECM函数'
- en: The \(ecm\) function is a subexponential factoring algorithm capable of factoring
    numbers of around ~35 digits comfortably within few seconds. The time complexity
    of \(ecm\) is dependent on the smallest proper factor of the number. So even if
    the number is really large but its factors are comparatively smaller then \(ecm\)
    can easily factor them. For example we take \(N\) with 15 digit factors \(15154262241479\),
    \(15423094826093\), \(799333555511111\), \(809709509409109\), \(888888877777777\),
    \(914148152112161\). Now N is a 87 digit number. \(ECM\) takes under around 47s
    to factorise this.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecm`函数是一个次指数因数分解算法，能够在几秒钟内轻松地因式分解大约35位数的数字。`ecm`的时间复杂度取决于该数的最小真因数。因此，即使数字很大，但其因子相对较小，`ecm`也可以轻松地对其进行因式分解。例如，我们取带有15位数因子的N，如15154262241479，15423094826093，799333555511111，809709509409109，888888877777777，914148152112161。现在N是一个87位数。`ECM`需要大约47秒来因式分解它。'
- en: '[PRE282]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Performs factorization using Lenstra’s Elliptic curve method.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lenstra的椭圆曲线方法进行因式分解。
- en: This function repeatedly calls `_ecm_one_factor` to compute the factors of n.
    First all the small factors are taken out using trial division. Then `_ecm_one_factor`
    is used to compute one factor at a time.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数重复调用 `_ecm_one_factor` 来计算n的因子。首先通过试除法去除所有小因子。然后使用 `_ecm_one_factor` 逐个计算一个因子。
- en: 'Parameters:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : Number to be Factored'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 待分解的数'
- en: '**B1** : Stage 1 Bound. Must be an even number.'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: '**B1** : 第1阶段界限。必须是偶数。'
- en: '**B2** : Stage 2 Bound. Must be an even number.'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '**B2** : 第2阶段界限。必须是偶数。'
- en: '**max_curve** : Maximum number of curves generated'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: '**max_curve** : 生成的最大曲线数'
- en: '**seed** : Initialize pseudorandom generator'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: '**seed** : 初始化伪随机生成器'
- en: Examples
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE283]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Examples
  id: totrans-1396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE284]  ## QS function'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE284]  ## QS函数'
- en: The \(qs\) function is a subexponential factoring algorithm, the fastest factoring
    algorithm for numbers within 100 digits. The time complexity of \(qs\) is dependent
    on the size of the number so it is used if the number contains large factors.
    Due to this while factoring numbers first \(ecm\) is used to get smaller factors
    of around ~15 digits then \(qs\) is used to get larger factors.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: qs函数是一种亚指数复杂度的因式分解算法，适用于100位数以内的最快因式分解算法。qs的时间复杂度取决于数的大小，因此如果数包含大因子，则使用qs。因此，在因式分解数时，首先使用ecm获得约15位数的较小因子，然后使用qs获取较大因子。
- en: For factoring \(2709077133180915240135586837960864768806330782747\) which is
    a semi-prime number with two 25 digit factors. \(qs\) is able to factorize this
    in around 248s.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 用于因式分解 \(2709077133180915240135586837960864768806330782747\) 的半素数，其具有两个25位数的因子。qs能在大约248秒内完成对其的因式分解。
- en: '[PRE285]'
  id: totrans-1400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Performs factorization using Self-Initializing Quadratic Sieve. In SIQS, let
    N be a number to be factored, and this N should not be a perfect power. If we
    find two integers such that `X**2 = Y**2 modN` and `X != +-Y modN`, then \(gcd(X
    + Y, N)\) will reveal a proper factor of N. In order to find these integers X
    and Y we try to find relations of form t**2 = u modN where u is a product of small
    primes. If we have enough of these relations then we can form `(t1*t2...ti)**2
    = u1*u2...ui modN` such that the right hand side is a square, thus we found a
    relation of `X**2 = Y**2 modN`.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自初始化二次筛法进行因式分解。在SIQS中，令N为待分解的数，且N不应为完全幂。如果我们找到两个整数使得 `X**2 = Y**2 modN` 且
    `X != +-Y modN`，那么 \(gcd(X + Y, N)\) 将显示出N的一个正确因子。为了找到这些整数X和Y，我们试图找到形如 t**2 =
    u modN 的关系，其中u是小质数的乘积。如果我们有足够多的这些关系，我们可以形成 `(t1*t2...ti)**2 = u1*u2...ui modN`，使右边是一个平方数，因此我们找到了一个关系
    `X**2 = Y**2 modN`。
- en: Here, several optimizations are done like using multiple polynomials for sieving,
    fast changing between polynomials and using partial relations. The use of partial
    relations can speeds up the factoring by 2 times.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里进行了几项优化，如使用多项式筛选、快速切换多项式和使用部分关系。部分关系的使用可以使因式分解加速2倍。
- en: 'Parameters:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**N** : Number to be Factored'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: '**N** : 待分解的数'
- en: '**prime_bound** : upper bound for primes in the factor base'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: '**prime_bound** : 质因数基中的质数上限'
- en: '**M** : Sieve Interval'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '**M** : 筛选区间'
- en: '**ERROR_TERM** : Error term for checking smoothness'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '**ERROR_TERM** : 检查平滑性的误差项'
- en: '**threshold** : Extra smooth relations for factorization'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '**threshold** : 因式分解的额外平滑关系'
- en: '**seed** : generate pseudo prime numbers'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '**seed** : 生成伪质数'
- en: Examples
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE286]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: References
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R718](#id81)]'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R718](#id81)]'
- en: '[https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf](https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf)'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf](https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf)'
- en: '[[R719](#id82)]'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R719](#id82)]'
- en: '[https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve](https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve)'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve](https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve)'
- en: Examples
  id: totrans-1417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE287]'
  id: totrans-1418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
