- en: scipy.optimize.newton_krylov
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.newton_krylov.html#scipy.optimize.newton_krylov](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.newton_krylov.html#scipy.optimize.newton_krylov)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of a function, using Krylov approximation for inverse Jacobian.
  prefs: []
  type: TYPE_NORMAL
- en: This method is suitable for solving large-scale problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**F**function(x) -> f'
  prefs: []
  type: TYPE_NORMAL
- en: Function whose root to find; should take and return an array-like object.
  prefs: []
  type: TYPE_NORMAL
- en: '**xin**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess for the solution
  prefs: []
  type: TYPE_NORMAL
- en: '**rdiff**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative step size to use in numerical differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str or callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Krylov method to use to approximate the Jacobian. Can be a string, or a function
    implementing the same interface as the iterative solvers in [`scipy.sparse.linalg`](../sparse.linalg.html#module-scipy.sparse.linalg
    "scipy.sparse.linalg"). If a string, needs to be one of: `''lgmres''`, `''gmres''`,
    `''bicgstab''`, `''cgs''`, `''minres''`, `''tfqmr''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The default is [`scipy.sparse.linalg.lgmres`](scipy.sparse.linalg.lgmres.html#scipy.sparse.linalg.lgmres
    "scipy.sparse.linalg.lgmres").
  prefs: []
  type: TYPE_NORMAL
- en: '**inner_maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter to pass to the “inner” Krylov solver: maximum number of iterations.
    Iteration will stop after maxiter steps even if the specified tolerance has not
    been achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: '**inner_M**LinearOperator or InverseJacobian'
  prefs: []
  type: TYPE_NORMAL
- en: Preconditioner for the inner Krylov iteration. Note that you can use also inverse
    Jacobians as (adaptive) preconditioners. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the preconditioner has a method named ‘update’, it will be called as `update(x,
    f)` after each nonlinear step, with `x` giving the current point, and `f` the
    current function value.
  prefs: []
  type: TYPE_NORMAL
- en: '**outer_k**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Size of the subspace kept across LGMRES nonlinear iterations. See [`scipy.sparse.linalg.lgmres`](scipy.sparse.linalg.lgmres.html#scipy.sparse.linalg.lgmres
    "scipy.sparse.linalg.lgmres") for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**inner_kwargs**kwargs'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword parameters for the “inner” Krylov solver (defined with *method*). Parameter
    names must start with the *inner_* prefix which will be stripped before passing
    on the inner method. See, e.g., [`scipy.sparse.linalg.gmres`](scipy.sparse.linalg.gmres.html#scipy.sparse.linalg.gmres
    "scipy.sparse.linalg.gmres") for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**iter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of iterations to make. If omitted (default), make as many as required
    to meet tolerances.
  prefs: []
  type: TYPE_NORMAL
- en: '**verbose**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Print status to stdout on every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations to make. If more are needed to meet convergence,
    *NoConvergence* is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '**f_tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute tolerance (in max-norm) for the residual. If omitted, default is 6e-6.
  prefs: []
  type: TYPE_NORMAL
- en: '**f_rtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative tolerance for the residual. If omitted, not used.
  prefs: []
  type: TYPE_NORMAL
- en: '**x_tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute minimum step size, as determined from the Jacobian approximation. If
    the step size is smaller than this, optimization is terminated as successful.
    If omitted, not used.
  prefs: []
  type: TYPE_NORMAL
- en: '**x_rtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative minimum step size. If omitted, not used.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol_norm**function(vector) -> scalar, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Norm to use in convergence check. Default is the maximum norm.
  prefs: []
  type: TYPE_NORMAL
- en: '**line_search**{None, ‘armijo’ (default), ‘wolfe’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Which type of a line search to use to determine the step size in the direction
    given by the Jacobian approximation. Defaults to ‘armijo’.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Optional callback function. It is called on every iteration as `callback(x,
    f)` where *x* is the current solution and *f* the corresponding residual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sol**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: An array (of similar array type as *x0*) containing the final solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: NoConvergence
  prefs: []
  type: TYPE_NORMAL
- en: When a solution was not found.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`root`](scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root")'
  prefs: []
  type: TYPE_NORMAL
- en: Interface to root finding algorithms for multivariate functions. See `method='krylov'`
    in particular.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.sparse.linalg.gmres`](scipy.sparse.linalg.gmres.html#scipy.sparse.linalg.gmres
    "scipy.sparse.linalg.gmres")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.sparse.linalg.lgmres`](scipy.sparse.linalg.lgmres.html#scipy.sparse.linalg.lgmres
    "scipy.sparse.linalg.lgmres")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This function implements a Newton-Krylov solver. The basic idea is to compute
    the inverse of the Jacobian with an iterative Krylov method. These methods require
    only evaluating the Jacobian-vector products, which are conveniently approximated
    by a finite difference:'
  prefs: []
  type: TYPE_NORMAL
- en: \[J v \approx (f(x + \omega*v/|v|) - f(x)) / \omega\]
  prefs: []
  type: TYPE_NORMAL
- en: Due to the use of iterative matrix inverses, these methods can deal with large
    nonlinear problems.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy’s [`scipy.sparse.linalg`](../sparse.linalg.html#module-scipy.sparse.linalg
    "scipy.sparse.linalg") module offers a selection of Krylov solvers to choose from.
    The default here is *lgmres*, which is a variant of restarted GMRES iteration
    that reuses some of the information obtained in the previous Newton steps to invert
    Jacobians in subsequent steps.
  prefs: []
  type: TYPE_NORMAL
- en: For a review on Newton-Krylov methods, see for example [[1]](#rbbc42047c80d-1),
    and for the LGMRES sparse inverse method, see [[2]](#rbbc42047c80d-2).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: C. T. Kelley, Solving Nonlinear Equations with Newton’s Method, SIAM, pp.57-83,
    2003. [DOI:10.1137/1.9780898718898.ch3](https://doi.org/10.1137/1.9780898718898.ch3)
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: D.A. Knoll and D.E. Keyes, J. Comp. Phys. 193, 357 (2004). [DOI:10.1016/j.jcp.2003.08.010](https://doi.org/10.1016/j.jcp.2003.08.010)
  prefs: []
  type: TYPE_NORMAL
- en: '[3]'
  prefs: []
  type: TYPE_NORMAL
- en: A.H. Baker and E.R. Jessup and T. Manteuffel, SIAM J. Matrix Anal. Appl. 26,
    962 (2005). [DOI:10.1137/S0895479803422014](https://doi.org/10.1137/S0895479803422014)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The following functions define a system of nonlinear equations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A solution can be obtained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
