["```py\n@pd.api.extensions.register_dataframe_accessor(\"geo\")\nclass GeoAccessor:\n    def __init__(self, pandas_obj):\n        self._validate(pandas_obj)\n        self._obj = pandas_obj\n\n    @staticmethod\n    def _validate(obj):\n        # verify there is a column latitude and a column longitude\n        if \"latitude\" not in obj.columns or \"longitude\" not in obj.columns:\n            raise AttributeError(\"Must have 'latitude' and 'longitude'.\")\n\n    @property\n    def center(self):\n        # return the geographic center point of this DataFrame\n        lat = self._obj.latitude\n        lon = self._obj.longitude\n        return (float(lon.mean()), float(lat.mean()))\n\n    def plot(self):\n        # plot this array's data on a map, e.g., using Cartopy\n        pass \n```", "```py\n>>> ds = pd.DataFrame(\n...     {\"longitude\": np.linspace(0, 10), \"latitude\": np.linspace(0, 20)}\n... )\n>>> ds.geo.center\n(5.0, 10.0)\n>>> ds.geo.plot()\n# plots data on a map \n```", "```py\nfrom pandas.api.extensions import ExtensionArray, ExtensionScalarOpsMixin\n\nclass MyExtensionArray(ExtensionArray, ExtensionScalarOpsMixin):\n    pass\n\nMyExtensionArray._add_arithmetic_ops()\nMyExtensionArray._add_comparison_ops() \n```", "```py\nfrom pandas.tests.extension import base\n\nclass TestConstructors(base.BaseConstructorsTests):\n    pass \n```", "```py\nclass MyExtensionArray(ExtensionArray):\n    ...\n\n    def __arrow_array__(self, type=None):\n        # convert the underlying array values to a pyarrow Array\n        import pyarrow\n\n        return pyarrow.array(..., type=type) \n```", "```py\nclass ExtensionDtype:\n    ...\n\n    def __from_arrow__(self, array: pyarrow.Array/ChunkedArray) -> ExtensionArray:\n        ... \n```", "```py\nclass SubclassedSeries(pd.Series):\n    @property\n    def _constructor(self):\n        return SubclassedSeries\n\n    @property\n    def _constructor_expanddim(self):\n        return SubclassedDataFrame\n\nclass SubclassedDataFrame(pd.DataFrame):\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame\n\n    @property\n    def _constructor_sliced(self):\n        return SubclassedSeries \n```", "```py\n>>> s = SubclassedSeries([1, 2, 3])\n>>> type(s)\n<class '__main__.SubclassedSeries'>\n\n>>> to_framed = s.to_frame()\n>>> type(to_framed)\n<class '__main__.SubclassedDataFrame'>\n\n>>> df = SubclassedDataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> type(df)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced1 = df[[\"A\", \"B\"]]\n>>> sliced1\n A  B\n0  1  4\n1  2  5\n2  3  6\n\n>>> type(sliced1)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced2 = df[\"A\"]\n>>> sliced2\n0    1\n1    2\n2    3\nName: A, dtype: int64\n\n>>> type(sliced2)\n<class '__main__.SubclassedSeries'> \n```", "```py\nclass SubclassedDataFrame2(pd.DataFrame):\n\n    # temporary properties\n    _internal_names = pd.DataFrame._internal_names + [\"internal_cache\"]\n    _internal_names_set = set(_internal_names)\n\n    # normal properties\n    _metadata = [\"added_property\"]\n\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame2 \n```", "```py\n>>> df = SubclassedDataFrame2({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> df.internal_cache = \"cached\"\n>>> df.added_property = \"property\"\n\n>>> df.internal_cache\ncached\n>>> df.added_property\nproperty\n\n# properties defined in _internal_names is reset after manipulation\n>>> df[[\"A\", \"B\"]].internal_cache\nAttributeError: 'SubclassedDataFrame2' object has no attribute 'internal_cache'\n\n# properties defined in _metadata are retained\n>>> df[[\"A\", \"B\"]].added_property\nproperty \n```", "```py\n>>> pd.set_option(\"plotting.backend\", \"backend.module\")\n>>> pd.Series([1, 2, 3]).plot() \n```", "```py\n>>> import backend.module\n>>> backend.module.plot(pd.Series([1, 2, 3])) \n```", "```py\n# in setup.py\nsetup(  # noqa: F821\n    ...,\n    entry_points={\n        \"pandas_plotting_backends\": [\n            \"matplotlib = pandas:plotting._matplotlib\",\n        ],\n    },\n) \n```", "```py\n>>> pd.Series([1, 2]) + [10, 20]\n0    11\n1    22\ndtype: int64 \n```", "```py\nclass CustomList(list):\n    __pandas_priority__ = 5000\n\n    def __radd__(self, other):\n        # return `self` and not the addition for simplicity\n        return self\n\ncustom = CustomList()\nseries = pd.Series([1, 2, 3])\n\n# Series refuses to add custom, since it's an unknown type with higher priority\nassert series.__add__(custom) is NotImplemented\n\n# This will cause the custom class `__radd__` being used instead\nassert series + custom is custom \n```", "```py\n@pd.api.extensions.register_dataframe_accessor(\"geo\")\nclass GeoAccessor:\n    def __init__(self, pandas_obj):\n        self._validate(pandas_obj)\n        self._obj = pandas_obj\n\n    @staticmethod\n    def _validate(obj):\n        # verify there is a column latitude and a column longitude\n        if \"latitude\" not in obj.columns or \"longitude\" not in obj.columns:\n            raise AttributeError(\"Must have 'latitude' and 'longitude'.\")\n\n    @property\n    def center(self):\n        # return the geographic center point of this DataFrame\n        lat = self._obj.latitude\n        lon = self._obj.longitude\n        return (float(lon.mean()), float(lat.mean()))\n\n    def plot(self):\n        # plot this array's data on a map, e.g., using Cartopy\n        pass \n```", "```py\n>>> ds = pd.DataFrame(\n...     {\"longitude\": np.linspace(0, 10), \"latitude\": np.linspace(0, 20)}\n... )\n>>> ds.geo.center\n(5.0, 10.0)\n>>> ds.geo.plot()\n# plots data on a map \n```", "```py\nfrom pandas.api.extensions import ExtensionArray, ExtensionScalarOpsMixin\n\nclass MyExtensionArray(ExtensionArray, ExtensionScalarOpsMixin):\n    pass\n\nMyExtensionArray._add_arithmetic_ops()\nMyExtensionArray._add_comparison_ops() \n```", "```py\nfrom pandas.tests.extension import base\n\nclass TestConstructors(base.BaseConstructorsTests):\n    pass \n```", "```py\nclass MyExtensionArray(ExtensionArray):\n    ...\n\n    def __arrow_array__(self, type=None):\n        # convert the underlying array values to a pyarrow Array\n        import pyarrow\n\n        return pyarrow.array(..., type=type) \n```", "```py\nclass ExtensionDtype:\n    ...\n\n    def __from_arrow__(self, array: pyarrow.Array/ChunkedArray) -> ExtensionArray:\n        ... \n```", "```py\nfrom pandas.api.extensions import ExtensionArray, ExtensionScalarOpsMixin\n\nclass MyExtensionArray(ExtensionArray, ExtensionScalarOpsMixin):\n    pass\n\nMyExtensionArray._add_arithmetic_ops()\nMyExtensionArray._add_comparison_ops() \n```", "```py\nfrom pandas.tests.extension import base\n\nclass TestConstructors(base.BaseConstructorsTests):\n    pass \n```", "```py\nclass MyExtensionArray(ExtensionArray):\n    ...\n\n    def __arrow_array__(self, type=None):\n        # convert the underlying array values to a pyarrow Array\n        import pyarrow\n\n        return pyarrow.array(..., type=type) \n```", "```py\nclass ExtensionDtype:\n    ...\n\n    def __from_arrow__(self, array: pyarrow.Array/ChunkedArray) -> ExtensionArray:\n        ... \n```", "```py\nclass SubclassedSeries(pd.Series):\n    @property\n    def _constructor(self):\n        return SubclassedSeries\n\n    @property\n    def _constructor_expanddim(self):\n        return SubclassedDataFrame\n\nclass SubclassedDataFrame(pd.DataFrame):\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame\n\n    @property\n    def _constructor_sliced(self):\n        return SubclassedSeries \n```", "```py\n>>> s = SubclassedSeries([1, 2, 3])\n>>> type(s)\n<class '__main__.SubclassedSeries'>\n\n>>> to_framed = s.to_frame()\n>>> type(to_framed)\n<class '__main__.SubclassedDataFrame'>\n\n>>> df = SubclassedDataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> type(df)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced1 = df[[\"A\", \"B\"]]\n>>> sliced1\n A  B\n0  1  4\n1  2  5\n2  3  6\n\n>>> type(sliced1)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced2 = df[\"A\"]\n>>> sliced2\n0    1\n1    2\n2    3\nName: A, dtype: int64\n\n>>> type(sliced2)\n<class '__main__.SubclassedSeries'> \n```", "```py\nclass SubclassedDataFrame2(pd.DataFrame):\n\n    # temporary properties\n    _internal_names = pd.DataFrame._internal_names + [\"internal_cache\"]\n    _internal_names_set = set(_internal_names)\n\n    # normal properties\n    _metadata = [\"added_property\"]\n\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame2 \n```", "```py\n>>> df = SubclassedDataFrame2({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> df.internal_cache = \"cached\"\n>>> df.added_property = \"property\"\n\n>>> df.internal_cache\ncached\n>>> df.added_property\nproperty\n\n# properties defined in _internal_names is reset after manipulation\n>>> df[[\"A\", \"B\"]].internal_cache\nAttributeError: 'SubclassedDataFrame2' object has no attribute 'internal_cache'\n\n# properties defined in _metadata are retained\n>>> df[[\"A\", \"B\"]].added_property\nproperty \n```", "```py\nclass SubclassedSeries(pd.Series):\n    @property\n    def _constructor(self):\n        return SubclassedSeries\n\n    @property\n    def _constructor_expanddim(self):\n        return SubclassedDataFrame\n\nclass SubclassedDataFrame(pd.DataFrame):\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame\n\n    @property\n    def _constructor_sliced(self):\n        return SubclassedSeries \n```", "```py\n>>> s = SubclassedSeries([1, 2, 3])\n>>> type(s)\n<class '__main__.SubclassedSeries'>\n\n>>> to_framed = s.to_frame()\n>>> type(to_framed)\n<class '__main__.SubclassedDataFrame'>\n\n>>> df = SubclassedDataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> type(df)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced1 = df[[\"A\", \"B\"]]\n>>> sliced1\n A  B\n0  1  4\n1  2  5\n2  3  6\n\n>>> type(sliced1)\n<class '__main__.SubclassedDataFrame'>\n\n>>> sliced2 = df[\"A\"]\n>>> sliced2\n0    1\n1    2\n2    3\nName: A, dtype: int64\n\n>>> type(sliced2)\n<class '__main__.SubclassedSeries'> \n```", "```py\nclass SubclassedDataFrame2(pd.DataFrame):\n\n    # temporary properties\n    _internal_names = pd.DataFrame._internal_names + [\"internal_cache\"]\n    _internal_names_set = set(_internal_names)\n\n    # normal properties\n    _metadata = [\"added_property\"]\n\n    @property\n    def _constructor(self):\n        return SubclassedDataFrame2 \n```", "```py\n>>> df = SubclassedDataFrame2({\"A\": [1, 2, 3], \"B\": [4, 5, 6], \"C\": [7, 8, 9]})\n>>> df\n A  B  C\n0  1  4  7\n1  2  5  8\n2  3  6  9\n\n>>> df.internal_cache = \"cached\"\n>>> df.added_property = \"property\"\n\n>>> df.internal_cache\ncached\n>>> df.added_property\nproperty\n\n# properties defined in _internal_names is reset after manipulation\n>>> df[[\"A\", \"B\"]].internal_cache\nAttributeError: 'SubclassedDataFrame2' object has no attribute 'internal_cache'\n\n# properties defined in _metadata are retained\n>>> df[[\"A\", \"B\"]].added_property\nproperty \n```", "```py\n>>> pd.set_option(\"plotting.backend\", \"backend.module\")\n>>> pd.Series([1, 2, 3]).plot() \n```", "```py\n>>> import backend.module\n>>> backend.module.plot(pd.Series([1, 2, 3])) \n```", "```py\n# in setup.py\nsetup(  # noqa: F821\n    ...,\n    entry_points={\n        \"pandas_plotting_backends\": [\n            \"matplotlib = pandas:plotting._matplotlib\",\n        ],\n    },\n) \n```", "```py\n>>> pd.Series([1, 2]) + [10, 20]\n0    11\n1    22\ndtype: int64 \n```", "```py\nclass CustomList(list):\n    __pandas_priority__ = 5000\n\n    def __radd__(self, other):\n        # return `self` and not the addition for simplicity\n        return self\n\ncustom = CustomList()\nseries = pd.Series([1, 2, 3])\n\n# Series refuses to add custom, since it's an unknown type with higher priority\nassert series.__add__(custom) is NotImplemented\n\n# This will cause the custom class `__radd__` being used instead\nassert series + custom is custom \n```"]