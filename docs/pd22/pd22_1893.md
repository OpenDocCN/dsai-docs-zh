# 2.2.0 中的新内容（2024 年 1 月 19 日）

> 原文：[`pandas.pydata.org/docs/whatsnew/v2.2.0.html`](https://pandas.pydata.org/docs/whatsnew/v2.2.0.html)

这些是 pandas 2.2.0 中的更改。查看发布说明以获取包括其他版本的 pandas 在内的完整更改日志。

## pandas 3.0 中即将发生的更改

pandas 3.0 将对 pandas 的默认行为进行两个较大的更改。

### Copy-on-Write

在 pandas 3.0 中，当前可选的 Copy-on-Write 模式将默认启用。不会有选项来保持当前行为启用。有关 Copy-on-Write 的新行为语义在关于 Copy-on-Write 的用户指南中有解释。

自 pandas 2.0 以来，可以通过以下选项启用新行为：

```py
pd.options.mode.copy_on_write = True 
```

此更改会在 pandas 操作副本和视图方面带来不同的行为变化。其中一些更改允许明确弃用，例如链式赋值中的更改。其他更改则更为微妙，因此警告隐藏在一个选项后面，在 pandas 2.2 中可以启用该选项。

```py
pd.options.mode.copy_on_write = "warn" 
```

此模式将在许多不实际相关的场景中发出警告，对于大多数查询实际上并不相关。我们建议探索此模式，但不必消除所有这些警告。迁移指南更详细地解释了升级过程。

### 默认情况下，使用（由 Arrow 支持的）专用字符串数据类型。

历史上，pandas 用 NumPy 对象数据类型表示字符串列。此表示方法存在许多问题，包括性能慢和内存占用大。这将在 pandas 3.0 中更改。pandas 将开始推断字符串列为新的`string`数据类型，由 Arrow 支持，表示内存连续的字符串。这将带来巨大的性能和内存改进。

旧行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: object 
```

新行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: string 
```

在这些场景中使用的字符串数据类型大多会像 NumPy 对象一样运行，包括缺失值语义和对这些列的一般操作。

此更改还涉及 API 中的一些其他更改：

+   目前，指定 `dtype="string"` 会创建一个由存储在 NumPy 数组中的 Python 字符串支持的 dtype。在 pandas 3.0 中，此 dtype 将创建一个由 Arrow 支持的字符串列。

+   列名和索引也将由 Arrow 字符串支持。

+   PyArrow 将成为 pandas 3.0 的必需依赖项，以适应此更改。

此未来的 dtype 推断逻辑可以通过以下方式启用：

```py
pd.options.future.infer_string = True 
```  ## 增强功能

### to_sql 和 read_sql 中的 ADBC 驱动程序支持

`read_sql()` 和 `to_sql()` 现在可以使用 [Apache Arrow ADBC](https://arrow.apache.org/adbc/current/index.html) 驱动程序。与通过 SQLAlchemy 使用的传统驱动程序相比，ADBC 驱动程序应该提供显着的性能改进，更好的类型支持和更清洁的空值处理。

```py
import adbc_driver_postgresql.dbapi as pg_dbapi

df = pd.DataFrame(
    [
        [1, 2, 3],
        [4, 5, 6],
    ],
    columns=['a', 'b', 'c']
)
uri = "postgresql://postgres:postgres@localhost/postgres"
with pg_dbapi.connect(uri) as conn:
    df.to_sql("pandas_table", conn, index=False)

# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn) 
```

Arrow 类型系统提供了更广泛的类型，可以更接近于 PostgreSQL 等数据库提供的内容。为了说明这一点，注意以下不同数据库和 pandas 后端中可用的类型的（非详尽）列表：

| numpy/pandas | arrow | postgres | sqlite |
| --- | --- | --- | --- |
| int16/Int16 | int16 | SMALLINT | INTEGER |
| int32/Int32 | int32 | INTEGER | INTEGER |
| int64/Int64 | int64 | BIGINT | INTEGER |
| float32 | float32 | REAL | REAL |
| float64 | float64 | DOUBLE PRECISION | REAL |
| object | string | TEXT | TEXT |
| bool | `bool_` | BOOLEAN |  |
| datetime64[ns] | timestamp(us) | TIMESTAMP |  |
| datetime64[ns,tz] | timestamp(us,tz) | TIMESTAMPTZ |  |
|  | date32 | DATE |  |
|  | month_day_nano_interval | INTERVAL |  |
|  | binary | BINARY | BLOB |
|  | decimal128 | DECIMAL [[1]](#f1) |  |
|  | list | ARRAY [[1]](#f1) |  |
|  | struct |

复合类型

[[1]](#f1)

|  |
| --- |

脚注

如果您希望在 DataFrame 的生命周期中尽可能保留数据库类型，请鼓励用户利用 `read_sql()` 的 `dtype_backend="pyarrow"` 参数。

```py
# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn, dtype_backend="pyarrow") 
```

这将阻止您的数据被转换为传统的 pandas/NumPy 类型系统，该系统经常以使它们无法往返的方式转换 SQL 类型。

有关 ADBC 驱动程序及其开发状态的完整列表，请参阅 [ADBC 驱动程序实现状态](https://arrow.apache.org/adbc/current/driver/status.html) 文档。  ### 根据一个或多个条件创建 pandas Series

`Series.case_when()` 函数已添加，用于根据一个或多个条件创建 Series 对象。([GH 39154](https://github.com/pandas-dev/pandas/issues/39154))

```py
In [1]: import pandas as pd

In [2]: df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6]))

In [3]: default=pd.Series('default', index=df.index)

In [4]: default.case_when(
 ...:     caselist=[
 ...:         (df.a == 1, 'first'),                              # condition, replacement
 ...:         (df.a.gt(1) & df.b.eq(5), 'second'),  # condition, replacement
 ...:     ],
 ...: )
 ...: 
Out[4]: 
0      first
1     second
2    default
dtype: object 
```  ### 对于 NumPy 可空和 Arrow 类型，`to_numpy` 转换为适当的 NumPy 数据类型

对于 NumPy 可空和 Arrow 类型，`to_numpy` 现在将转换为适当的 NumPy 数据类型，而不是对于可空和 PyArrow 支持的扩展数据类型的 `object` 数据类型。

*旧行为：*

```py
In [1]: ser = pd.Series([1, 2, 3], dtype="Int64")
In [2]: ser.to_numpy()
Out[2]: array([1, 2, 3], dtype=object) 
```

*新行为：*

```py
In [5]: ser = pd.Series([1, 2, 3], dtype="Int64")

In [6]: ser.to_numpy()
Out[6]: array([1, 2, 3])

In [7]: ser = pd.Series([1, 2, 3], dtype="timestamp[ns][pyarrow]")

In [8]: ser.to_numpy()
Out[8]: 
array(['1970-01-01T00:00:00.000000001', '1970-01-01T00:00:00.000000002',
 '1970-01-01T00:00:00.000000003'], dtype='datetime64[ns]') 
```

默认的 NumPy 数据类型（不带任何参数）确定如下：

+   浮点数数据类型将被转换为 NumPy 浮点数

+   整数数据类型（没有缺失值）将被转换为 NumPy 整数数据类型

+   带有缺失值的整数数据类型将被转换为 NumPy 浮点数数据类型，并使用 `NaN` 作为缺失值指示符

+   没有缺失值的布尔类型将转换为 NumPy 的 bool 类型

+   具有缺失值的布尔类型保持对象 dtype

+   datetime 和 timedelta 类型分别转换为 Numpy 的 datetime64 和 timedelta64 类型，`NaT` 用作缺失值指示符  ### Series.struct accessor for PyArrow structured data

`Series.struct` accessor 提供了用于处理带有 `struct[pyarrow]` dtype Series 数据的属性和方法。例如，`Series.struct.explode()` 将 PyArrow 结构化数据转换为 pandas DataFrame。 （[GH 54938](https://github.com/pandas-dev/pandas/issues/54938)）

```py
In [9]: import pyarrow as pa

In [10]: series = pd.Series(
 ....:    [
 ....:        {"project": "pandas", "version": "2.2.0"},
 ....:        {"project": "numpy", "version": "1.25.2"},
 ....:        {"project": "pyarrow", "version": "13.0.0"},
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.struct([
 ....:            ("project", pa.string()),
 ....:            ("version", pa.string()),
 ....:        ])
 ....:    ),
 ....: )
 ....: 

In [11]: series.struct.explode()
Out[11]: 
 project version
0   pandas   2.2.0
1    numpy  1.25.2
2  pyarrow  13.0.0 
```

使用 `Series.struct.field()` 来索引（可能嵌套的）结构字段。

```py
In [12]: series.struct.field("project")
Out[12]: 
0     pandas
1      numpy
2    pyarrow
Name: project, dtype: string[pyarrow] 
```  ### Series.list accessor for PyArrow list data

`Series.list` accessor 提供了用于处理带有 `list[pyarrow]` dtype Series 数据的属性和方法。例如，`Series.list.__getitem__()` 允许在 Series 中索引 pyarrow 列表。 （[GH 55323](https://github.com/pandas-dev/pandas/issues/55323)）

```py
In [13]: import pyarrow as pa

In [14]: series = pd.Series(
 ....:    [
 ....:        [1, 2, 3],
 ....:        [4, 5],
 ....:        [6],
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.list_(pa.int64())
 ....:    ),
 ....: )
 ....: 

In [15]: series.list[0]
Out[15]: 
0    1
1    4
2    6
dtype: int64[pyarrow] 
```  ### Calamine engine for `read_excel()`

`calamine` 引擎被添加到 `read_excel()` 中。它使用 `python-calamine`，该库提供了 Rust 库 [calamine](https://crates.io/crates/calamine) 的 Python 绑定。该引擎支持 Excel 文件（`.xlsx`、`.xlsm`、`.xls`、`.xlsb`）和 OpenDocument 电子表格（`.ods`）（[GH 50395](https://github.com/pandas-dev/pandas/issues/50395)）。

这个引擎有两个优点：

1.  Calamine 通常比其他引擎快，一些基准测试显示结果比 ‘openpyxl’ 快了高达 5 倍，‘odf’ 快了 20 倍，‘pyxlsb’ 快了 4 倍，‘xlrd’ 快了 1.5 倍。但是，由于对行的惰性迭代，‘openpyxl’ 和 ‘pyxlsb’ 在从大文件中读取少量行时更快。

1.  Calamine 支持在 `.xlsb` 文件中识别 datetime，而 ‘pyxlsb’ 则是 pandas 中唯一可以读取 `.xlsb` 文件的其他引擎。

```py
pd.read_excel("path_to_file.xlsb", engine="calamine") 
```

更多信息，请参阅 IO 工具中用户指南中的 Calamine（Excel 和 ODS 文件）  ### Other enhancements

+   当 method 参数设置为 `multi` 时，`to_sql()` 在后端与 Oracle 一起工作

+   `Series.attrs` / `DataFrame.attrs` 现在使用深度复制来传播 `attrs`（[GH 54134](https://github.com/pandas-dev/pandas/issues/54134)）。

+   `get_dummies()` 现在返回与输入类型兼容的扩展类型 `boolean` 或 `bool[pyarrow]`（[GH 56273](https://github.com/pandas-dev/pandas/issues/56273)）

+   `read_csv()` 现在支持 `on_bad_lines` 参数，并使用 `engine="pyarrow"`（[GH 54480](https://github.com/pandas-dev/pandas/issues/54480)）

+   `read_sas()` 返回 `datetime64` 类型的结果，其分辨率更适合与 SAS 中本地存储的类型匹配，并且在无法使用 `datetime64[ns]` 类型存储的情况下避免返回对象类型（[GH 56127](https://github.com/pandas-dev/pandas/issues/56127)）

+   `read_spss()` 现在返回一个存储元数据的 `DataFrame`，该元数据存储在 `DataFrame.attrs` 中（[GH 54264](https://github.com/pandas-dev/pandas/issues/54264)）

+   `tseries.api.guess_datetime_format()` 现在是公共 API 的一部分（[GH 54727](https://github.com/pandas-dev/pandas/issues/54727)）

+   `DataFrame.apply()` 现在允许使用 numba（通过 `engine="numba"`）对传递的函数进行 JIT 编译，从而可能提高速度（[GH 54666](https://github.com/pandas-dev/pandas/issues/54666)）

+   `ExtensionArray._explode()` 接口方法已添加，允许扩展类型实现 `explode` 方法（[GH 54833](https://github.com/pandas-dev/pandas/issues/54833)）

+   `ExtensionArray.duplicated()` 已添加，允许扩展类型实现 `duplicated` 方法（[GH 55255](https://github.com/pandas-dev/pandas/issues/55255)）

+   `Series.ffill()`、`Series.bfill()`、`DataFrame.ffill()` 和 `DataFrame.bfill()` 增加了参数 `limit_area`；第三方 `ExtensionArray` 的作者需要将此参数添加到方法 `_pad_or_backfill` 中（[GH 56492](https://github.com/pandas-dev/pandas/issues/56492)）

+   允许通过 `engine_kwargs` 使用 `read_only`、`data_only` 和 `keep_links` 参数来传递给 openpyxl 的 `read_excel()` ([GH 55027](https://github.com/pandas-dev/pandas/issues/55027))

+   为 `ArrowDtype` 和掩码 dtypes 实现了 `Series.interpolate()` 和 `DataFrame.interpolate()` ([GH 56267](https://github.com/pandas-dev/pandas/issues/56267))

+   为 `Series.value_counts()` 实现了掩码算法（[GH 54984](https://github.com/pandas-dev/pandas/issues/54984))

+   为具有 `pyarrow.duration` 类型的 `ArrowDtype` 实现了 `Series.dt()` 方法和属性（[GH 52284](https://github.com/pandas-dev/pandas/issues/52284))

+   为 `ArrowDtype` 实现了 `Series.str.extract()` ([GH 56268](https://github.com/pandas-dev/pandas/issues/56268))

+   改进了在不支持作为周期频率的频率（例如 `"BMS"`）的情况下在 `DatetimeIndex.to_period()` 中出现的错误消息 ([GH 56243](https://github.com/pandas-dev/pandas/issues/56243))

+   在使用无效偏移量（例如 `"QS"`）构造 `Period` 时改进了错误消息 ([GH 55785](https://github.com/pandas-dev/pandas/issues/55785))

+   dtypes `string[pyarrow]` 和 `string[pyarrow_numpy]` 现在都利用 PyArrow 的 `large_string` 类型，以避免长列的溢出 ([GH 56259](https://github.com/pandas-dev/pandas/issues/56259))  ## 显着的错误修复

这些是可能具有显着行为变化的错误修复。

### `merge()` 和 `DataFrame.join()` 现在一致地遵循了文档化的排序行为

在之前的 pandas 版本中，`merge()` 和 `DataFrame.join()` 并不总是返回遵循文档排序行为的结果。 pandas 现在在合并和连接操作中遵循文档排序行为（[GH 54611](https://github.com/pandas-dev/pandas/issues/54611)，[GH 56426](https://github.com/pandas-dev/pandas/issues/56426)，[GH 56443](https://github.com/pandas-dev/pandas/issues/56443)）。

如文档所述，`sort=True` 在生成的`DataFrame`中按词典顺序对连接键进行排序。对于`sort=False`，连接键的顺序取决于连接类型（`how`关键字）：

+   `how="left"`: 保留左侧键的顺序

+   `how="right"`: 保留右侧键的顺序

+   `how="inner"`: 保留左侧键的顺序

+   `how="outer"`: 按词典顺序排序键

一个具有变化行为的例子是具有非唯一左连接键和 `sort=False` 的内部连接：

```py
In [16]: left = pd.DataFrame({"a": [1, 2, 1]})

In [17]: right = pd.DataFrame({"a": [1, 2]})

In [18]: result = pd.merge(left, right, how="inner", on="a", sort=False) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 a
0  1
1  1
2  2 
```

*新行为*

```py
In [19]: result
Out[19]: 
 a
0  1
1  2
2  1 
```  ### `merge()` 和 `DataFrame.join()` 不再在级别不同时重新排序

在之前的 pandas 版本中，当在两个具有不同级别的索引上进行连接时，`merge()` 和 `DataFrame.join()` 会重新排序索引级别（[GH 34133](https://github.com/pandas-dev/pandas/issues/34133)）。

```py
In [20]: left = pd.DataFrame({"left": 1}, index=pd.MultiIndex.from_tuples([("x", 1), ("x", 2)], names=["A", "B"]))

In [21]: right = pd.DataFrame({"right": 2}, index=pd.MultiIndex.from_tuples([(1, 1), (2, 2)], names=["B", "C"]))

In [22]: left
Out[22]: 
 left
A B 
x 1     1
 2     1

In [23]: right
Out[23]: 
 right
B C 
1 1      2
2 2      2

In [24]: result = left.join(right) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 left  right
B A C
1 x 1     1      2
2 x 2     1      2 
```

*新行为*

```py
In [25]: result
Out[25]: 
 left  right
A B C 
x 1 1     1      2
 2 2     1      2 
```  ### 增加了依赖项的最小版本

对于[可选依赖项](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最新版本。测试过的最低版本以下的可选依赖项可能仍然可用，但不被认为是支持的。以下表格列出了最低测试版本已增加的可选依赖项。

| Package | 新最小版本 |
| --- | --- |
| beautifulsoup4 | 4.11.2 |
| blosc | 1.21.3 |
| bottleneck | 1.3.6 |
| fastparquet | 2022.12.0 |
| fsspec | 2022.11.0 |
| gcsfs | 2022.11.0 |
| lxml | 4.9.2 |
| matplotlib | 3.6.3 |
| numba | 0.56.4 |
| numexpr | 2.8.4 |
| qtpy | 2.3.0 |
| openpyxl | 3.1.0 |
| psycopg2 | 2.9.6 |
| pyreadstat | 1.2.0 |
| pytables | 3.8.0 |
| pyxlsb | 1.0.10 |
| s3fs | 2022.11.0 |
| scipy | 1.10.0 |
| sqlalchemy | 2.0.0 |
| tabulate | 0.9.0 |
| xarray | 2022.12.0 |
| xlsxwriter | 3.0.5 |
| zstandard | 0.19.0 |
| pyqt5 | 5.15.8 |
| tzdata | 2022.7 |

有关更多信息，请参见依赖项和可选依赖项。 ### 其他 API 更改

+   可空扩展数据类型的哈希值已更改以提高哈希操作的性能（[GH 56507](https://github.com/pandas-dev/pandas/issues/56507)）

+   `check_exact` 现在仅对浮点数据类型在`testing.assert_frame_equal()`和`testing.assert_series_equal()`中生效。特别地，整数数据类型始终会被精确检查（[GH 55882](https://github.com/pandas-dev/pandas/issues/55882)）  ## 废弃

### 链式赋值

为了准备在 pandas 3.0 中对复制/视图行为进行更大的即将到来的更改（写时复制（CoW），PDEP-7），我们开始废弃*链式赋值*。

当您尝试通过两个连续的索引操作更新 pandas DataFrame 或 Series 时，就会发生链式赋值。取决于这些操作的类型和顺序，当前可能会或可能不会起作用。

典型示例如下：

```py
df = pd.DataFrame({"foo": [1, 2, 3], "bar": [4, 5, 6]})

# first selecting rows with a mask, then assigning values to a column
# -> this has never worked and raises a SettingWithCopyWarning
df[df["bar"] > 5]["foo"] = 100

# first selecting the column, and then assigning to a subset of that column
# -> this currently works
df["foo"][df["bar"] > 5] = 100 
```

这是链式赋值的第二个示例，目前可以更新原始`df`。在 pandas 3.0 中将不再起作用，因此我们开始废弃这种做法：

```py
>>> df["foo"][df["bar"] > 5] = 100
FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy 
```

您可以通过删除链式赋值的用法来解决此警告，并确保您的代码已准备好迎接 pandas 3.0。通常，可以通过一步完成赋值来完成此操作，例如使用`.loc`。对于上面的示例，我们可以这样做：

```py
df.loc[df["bar"] > 5, "foo"] = 100 
```

相同的废弃适用于以链式方式执行的就地方法，例如：

```py
>>> df["foo"].fillna(0, inplace=True)
FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0\. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. 
```

当目标是更新 DataFrame `df` 中的列时，这里的替代方法是在`df`本身上调用方法，例如`df.fillna({"foo": 0}, inplace=True)`。 

在迁移指南中查看更多细节。

### 废弃别名`M`、`Q`、`Y`等，而支持`ME`、`QE`、`YE`等用于偏移

废弃了以下频率别名（[GH 9586](https://github.com/pandas-dev/pandas/issues/9586)）：

| 偏移 | 废弃别名 | 新别名 |
| --- | --- | --- |
| `MonthEnd` | `M` | `ME` |
| `BusinessMonthEnd` | `BM` | `BME` |
| `SemiMonthEnd` | `SM` | `SME` |
| `CustomBusinessMonthEnd` | `CBM` | `CBME` |
| `QuarterEnd` | `Q` | `QE` |
| `BQuarterEnd` | `BQ` | `BQE` |
| `YearEnd` | `Y` | `YE` |
| `BYearEnd` | `BY` | `BYE` |

例如：

*先前行为*：

```py
In [8]: pd.date_range('2020-01-01', periods=3, freq='Q-NOV')
Out[8]:
DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'],
 dtype='datetime64[ns]', freq='Q-NOV') 
```

*未来行为*：

```py
In [26]: pd.date_range('2020-01-01', periods=3, freq='QE-NOV')
Out[26]: DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'], dtype='datetime64[ns]', freq='QE-NOV') 
```

### 废弃了自动向下转换

废弃了多种方法中对象数据类型结果的自动向下转换。由于行为取决于值，这些方法会以难以预测的方式悄悄更改数据类型。此外，pandas 正在摆脱静默的数据类型更改（[GH 54710](https://github.com/pandas-dev/pandas/issues/54710)，[GH 54261](https://github.com/pandas-dev/pandas/issues/54261)）。

这些方法包括：

+   `Series.replace()` 和 `DataFrame.replace()`

+   `DataFrame.fillna()`, `Series.fillna()`

+   `DataFrame.ffill()`, `Series.ffill()`

+   `DataFrame.bfill()`, `Series.bfill()`

+   `DataFrame.mask()`, `Series.mask()`

+   `DataFrame.where()`, `Series.where()`

+   `DataFrame.clip()`, `Series.clip()`

明确调用 `DataFrame.infer_objects()` 来复制未来的当前行为。

```py
result = result.infer_objects(copy=False) 
```

或者使用 `astype` 将所有四舍五入的浮点数显式转换为整数。

将以下选项设置为选择未来行为：

```py
In [9]: pd.set_option("future.no_silent_downcasting", True) 
```

### 其他弃用内容

+   将 `Timedelta.resolution_string()` 改为返回 `h`, `min`, `s`, `ms`, `us`, 和 `ns` 而不是 `H`, `T`, `S`, `L`, `U`, 和 `N`，以兼容频率别名中相应的弃用内容 ([GH 52536](https://github.com/pandas-dev/pandas/issues/52536))

+   弃用 `offsets.Day.delta`, `offsets.Hour.delta`, `offsets.Minute.delta`, `offsets.Second.delta`, `offsets.Milli.delta`, `offsets.Micro.delta`, `offsets.Nano.delta`，改用 `pd.Timedelta(obj)`（[GH 55498](https://github.com/pandas-dev/pandas/issues/55498)）

+   弃用 `pandas.api.types.is_interval()` 和 `pandas.api.types.is_period()`，改用 `isinstance(obj, pd.Interval)` 和 `isinstance(obj, pd.Period)`（[GH 55264](https://github.com/pandas-dev/pandas/issues/55264))

+   弃用`read_gbq()`和`DataFrame.to_gbq()`。请改用`pandas_gbq.read_gbq`和`pandas_gbq.to_gbq` [`pandas-gbq.readthedocs.io/en/latest/api.html`](https://pandas-gbq.readthedocs.io/en/latest/api.html) ([GH 55525](https://github.com/pandas-dev/pandas/issues/55525))

+   弃用`DataFrameGroupBy.fillna()`和`SeriesGroupBy.fillna()`；请使用`DataFrameGroupBy.ffill()`、`DataFrameGroupBy.bfill()`进行向前和向后填充，或使用`DataFrame.fillna()`填充单个值（或其 Series 等效项）([GH 55718](https://github.com/pandas-dev/pandas/issues/55718))

+   弃用`DateOffset.is_anchored()`，对于非`Tick`子类，请使用`obj.n == 1`（对于`Tick`，这总是`False`）([GH 55388](https://github.com/pandas-dev/pandas/issues/55388))

+   弃用`DatetimeArray.__init__()`和`TimedeltaArray.__init__()`，请改用`array()`代替([GH 55623](https://github.com/pandas-dev/pandas/issues/55623))

+   弃用`Index.format()`，请使用`index.astype(str)`或`index.map(formatter)`代替([GH 55413](https://github.com/pandas-dev/pandas/issues/55413))

+   弃用`Series.ravel()`，底层数组已经是 1D，因此不需要`ravel`([GH 52511](https://github.com/pandas-dev/pandas/issues/52511))

+   弃用`Series.resample()`和`DataFrame.resample()`与`PeriodIndex`（以及‘convention’关键字），在重新采样之前转换为`DatetimeIndex`（使用`.to_timestamp()`）([GH 53481](https://github.com/pandas-dev/pandas/issues/53481))

+   不再建议使用 `Series.view()`，改用 `Series.astype()` 来更改数据类型（[GH 20251](https://github.com/pandas-dev/pandas/issues/20251)）

+   不再建议使用 `offsets.Tick.is_anchored()`，而是使用 `False`（[GH 55388](https://github.com/pandas-dev/pandas/issues/55388)）

+   不再建议使用 `core.internals` 成员 `Block`、`ExtensionBlock` 和 `DatetimeTZBlock`，改用公共 API（[GH 55139](https://github.com/pandas-dev/pandas/issues/55139)）

+   不再允许在 `PeriodIndex` 构造函数中使用 `year`、`month`、`quarter`、`day`、`hour`、`minute` 和 `second` 关键字，改用 `PeriodIndex.from_fields()`（[GH 55960](https://github.com/pandas-dev/pandas/issues/55960)）

+   不再允许在 `Index.view()` 中接受类型作为参数，而是不带任何参数进行调用（[GH 55709](https://github.com/pandas-dev/pandas/issues/55709)）

+   不再允许在 `date_range()`、`timedelta_range()`、`period_range()` 和 `interval_range()` 中使用非整数 `periods` 参数（[GH 56036](https://github.com/pandas-dev/pandas/issues/56036)）

+   不再允许在 `DataFrame.to_clipboard()` 中使用非关键字参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   不再允许在 `DataFrame.to_csv()` 中使用非关键字参数，除非有 `path_or_buf` 参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   不再允许在 `DataFrame.to_dict()` 中使用非关键字参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   不再允许在 `DataFrame.to_excel()` 中使用非关键字参数，除非有 `excel_writer` 参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_gbq()`中不再允许非关键字参数，除了`destination_table`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_hdf()`中不再允许非关键字参数，除了`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_html()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_json()`中不再允许非关键字参数，除了`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_latex()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_markdown()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_parquet()`中不再允许非关键字参数，除了`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_pickle()`中不再允许非关键字参数，除了`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_string()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_xml()`中不再允许非关键字参数，除了`path_or_buffer`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   不再允许将`BlockManager`对象传递给`DataFrame`或将`SingleBlockManager`对象传递给`Series`（[GH 52419](https://github.com/pandas-dev/pandas/issues/52419)）

+   在使用具有对象 dtype 索引的`Index.insert()`时，不推荐在结果上隐式执行类型推断；而是明确调用`result.infer_objects(copy=False)`以保留旧行为（[GH 51363](https://github.com/pandas-dev/pandas/issues/51363))

+   在`Series.isin()`和`Index.isin()`中不推荐将非日期时间值（主要是字符串）转换为`datetime64`、`timedelta64`和`PeriodDtype` dtypes ([GH 53111](https://github.com/pandas-dev/pandas/issues/53111))

+   在给定 pandas 输入时，不推荐在`Index`、`Series`和`DataFrame`构造函数中进行 dtype 推断；在输入上调用`.infer_objects`以保持当前行为（[GH 56012](https://github.com/pandas-dev/pandas/issues/56012))

+   当将`Index`设置到`DataFrame`中时，不推荐使用 dtype 推断，而应明确转换（[GH 56102](https://github.com/pandas-dev/pandas/issues/56102))

+   在使用`DataFrameGroupBy.apply()`和`DataFrameGroupBy.resample()`进行计算时，不推荐包含分组；传递`include_groups=False`以排除分组（[GH 7155](https://github.com/pandas-dev/pandas/issues/7155))

+   不推荐使用长度为零的布尔索引器对`Index`进行索引（[GH 55820](https://github.com/pandas-dev/pandas/issues/55820))

+   当通过长度为 1 的类似列表进行分组时，不推荐在`DataFrameGroupBy.get_group`或`SeriesGroupBy.get_group`中不传递元组（[GH 25971](https://github.com/pandas-dev/pandas/issues/25971))

+   在`YearBegin`中不推荐使用字符串`AS`表示频率，以及在各种财政年度开始时使用字符串`AS-DEC`、`AS-JAN`等表示年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   在`YearEnd`中不推荐使用字符串`A`表示频率，以及在各种财政年度结束时使用字符串`A-DEC`、`A-JAN`等表示年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   在`BYearBegin`中不再支持字符串`BAS`表示频率，以及在各种财政年度开始的年度频率中不再支持字符串`BAS-DEC`、`BAS-JAN`等（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   在`BYearEnd`中不再支持字符串`BA`表示频率，以及在各种财政年度结束的年度频率中不再支持字符串`BA-DEC`、`BA-JAN`等（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   在`Hour`、`BusinessHour`、`CustomBusinessHour`中不再支持字符串`H`、`BH`和`CBH`表示频率（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   在`to_timedelta()`中不再支持字符串`H`、`S`、`U`和`N`表示单位（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   在`Timedelta`中不再支持字符串`H`、`T`、`S`、`L`、`U`和`N`表示单位（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   在`Minute`、`Second`、`Milli`、`Micro`、`Nano`中不再支持字符串`T`、`S`、`L`、`U`和`N`表示频率（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   在`read_csv()`中不再支持解析日期时间列的组合，同时也不再支持`keep_date_col`关键字（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   在`DataFrameGroupBy.grouper`和`SeriesGroupBy.grouper`中不再支持；这些属性将在未来的 pandas 版本中移除（[GH 56521](https://github.com/pandas-dev/pandas/issues/56521)）

+   在`Grouping`属性`group_index`、`result_index`和`group_arraylike`中不再支持；这些将在未来的 pandas 版本中移除（[GH 56148](https://github.com/pandas-dev/pandas/issues/56148)）

+   在`read_csv()`和`read_table()`中不再支持`delim_whitespace`关键字，改用`sep="\\s+"`代替（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   在`to_datetime()`、`to_timedelta()`和`to_numeric()`中不再支持`errors="ignore"`选项；请明确捕获异常代替（[GH 54467](https://github.com/pandas-dev/pandas/issues/54467)）

+   在`Series`构造函数中不再支持`fastpath`关键字（[GH 20110](https://github.com/pandas-dev/pandas/issues/20110))

+   废弃了`Series.resample()`和`DataFrame.resample()`中的`kind`关键字，明确转换对象的`index`代替（[GH 55895](https://github.com/pandas-dev/pandas/issues/55895)）

+   废弃了`PeriodIndex`中的`ordinal`关键字，改用`PeriodIndex.from_ordinals()`代替（[GH 55960](https://github.com/pandas-dev/pandas/issues/55960)）

+   废弃了`TimedeltaIndex`构造中的`unit`关键字，改用`to_timedelta()`代替（[GH 55499](https://github.com/pandas-dev/pandas/issues/55499)）

+   废弃了`read_csv()`和`read_table()`中的`verbose`关键字（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   废弃了`DataFrame.replace()`和`Series.replace()`与`CategoricalDtype`的行为；在未来版本中，replace 将更改值，同时保留类别。要更改类别，请使用`ser.cat.rename_categories`代替（[GH 55147](https://github.com/pandas-dev/pandas/issues/55147)）

+   废弃了`Series.value_counts()`和`Index.value_counts()`与对象 dtype 的行为；在未来版本中，这些将不会对结果的`Index`执行 dtype 推断，执行`result.index = result.index.infer_objects()`以保留旧行为（[GH 56161](https://github.com/pandas-dev/pandas/issues/56161)）

+   废弃了`DataFrame.pivot_table()`中`observed=False`的默认值；将在未来版本中变为`True`（[GH 56236](https://github.com/pandas-dev/pandas/issues/56236)）

+   废弃了扩展测试类 `BaseNoReduceTests`、`BaseBooleanReduceTests` 和 `BaseNumericReduceTests`，请使用 `BaseReduceTests` 代替（[GH 54663](https://github.com/pandas-dev/pandas/issues/54663)）

+   废弃了选项 `mode.data_manager` 和 `ArrayManager`；在未来版本中只会提供 `BlockManager`（[GH 55043](https://github.com/pandas-dev/pandas/issues/55043)）

+   废弃了先前的`DataFrame.stack`的实现；指定 `future_stack=True` 以采用未来版本（[GH 53515](https://github.com/pandas-dev/pandas/issues/53515)）## 性能改进

+   在 `testing.assert_frame_equal()` 和 `testing.assert_series_equal()` 中性能有所提升（[GH 55949](https://github.com/pandas-dev/pandas/issues/55949), [GH 55971](https://github.com/pandas-dev/pandas/issues/55971)）

+   在 `concat()` 中性能有所提升当 `axis=1` 并且对象具有不对齐索引时（[GH 55084](https://github.com/pandas-dev/pandas/issues/55084)）

+   在 `get_dummies()` 中性能有所提升（[GH 56089](https://github.com/pandas-dev/pandas/issues/56089)）

+   在 `merge()` 和 `merge_ordered()` 中性能有所提升当在排序升序键上进行连接时（[GH 56115](https://github.com/pandas-dev/pandas/issues/56115)）

+   在 `merge_asof()` 中性能有所提升当 `by` 不是 `None` 时（[GH 55580](https://github.com/pandas-dev/pandas/issues/55580), [GH 55678](https://github.com/pandas-dev/pandas/issues/55678)）

+   在 `read_stata()` 中性能有所提升对于变量较多的文件（[GH 55515](https://github.com/pandas-dev/pandas/issues/55515)）

+   在 `DataFrame.groupby()` 中性能有所提升当聚合 pyarrow 时间戳和持续时间类型时（[GH 55031](https://github.com/pandas-dev/pandas/issues/55031)）

+   在 `DataFrame.join()` 中性能有所提升当在无序分类索引上进行连接时（[GH 56345](https://github.com/pandas-dev/pandas/issues/56345)）

+   当使用`MultiIndex`进行索引时，对`DataFrame.loc()`和`Series.loc()`的性能改进（[GH 56062](https://github.com/pandas-dev/pandas/issues/56062))

+   当由`MultiIndex`索引时，对`DataFrame.sort_index()`和`Series.sort_index()`的性能改进（[GH 54835](https://github.com/pandas-dev/pandas/issues/54835))

+   在将 DataFrame 转换为字典时，对`DataFrame.to_dict()`的性能改进（[GH 50990](https://github.com/pandas-dev/pandas/issues/50990))

+   对`Index.difference()`的性能改进（[GH 55108](https://github.com/pandas-dev/pandas/issues/55108))

+   在`Index.sort_values()`中对已排序索引的性能改进（[GH 56128](https://github.com/pandas-dev/pandas/issues/56128))

+   当`method`不为`None`时，对`MultiIndex.get_indexer()`的性能改进（[GH 55839](https://github.com/pandas-dev/pandas/issues/55839))

+   对 pyarrow 数据类型的`Series.duplicated()`的性能改进（[GH 55255](https://github.com/pandas-dev/pandas/issues/55255))

+   在数据类型为`"string[pyarrow]"`或`"string[pyarrow_numpy]"`时，对`Series.str.get_dummies()`的性能改进（[GH 56110](https://github.com/pandas-dev/pandas/issues/56110))

+   对`Series.str()`方法的性能改进（[GH 55736](https://github.com/pandas-dev/pandas/issues/55736))

+   在遮蔽数据类型的情况下，对`Series.value_counts()`和`Series.mode()`的性能改进（[GH 54984](https://github.com/pandas-dev/pandas/issues/54984), [GH 55340](https://github.com/pandas-dev/pandas/issues/55340))

+   `DataFrameGroupBy.nunique()` 和 `SeriesGroupBy.nunique()` 的性能改进（[GH 55972](https://github.com/pandas-dev/pandas/issues/55972))

+   `SeriesGroupBy.idxmax()`, `SeriesGroupBy.idxmin()`, `DataFrameGroupBy.idxmax()`, `DataFrameGroupBy.idxmin()` 的性能改进（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234))

+   在哈希可空扩展数组时的性能改进 ([GH 56507](https://github.com/pandas-dev/pandas/issues/56507))

+   在非唯一索引中进行索引时的性能改进 ([GH 55816](https://github.com/pandas-dev/pandas/issues/55816))

+   使用超过 4 个键进行索引时的性能改进 ([GH 54550](https://github.com/pandas-dev/pandas/issues/54550))

+   将时间本地化到 UTC 时的性能改进 ([GH 55241](https://github.com/pandas-dev/pandas/issues/55241))  ## Bug 修复

### 分类

+   `Categorical.isin()` 对包含重叠`Interval`值的分类引发`InvalidIndexError`的错误 ([GH 34974](https://github.com/pandas-dev/pandas/issues/34974))

+   `CategoricalDtype.__eq__()` 在混合类型的无序分类数据中返回`False`的错误 ([GH 55468](https://github.com/pandas-dev/pandas/issues/55468))

+   将`pa.dictionary`转换为`CategoricalDtype`时，使用`pa.DictionaryArray`作为类别时的错误 ([GH 56672](https://github.com/pandas-dev/pandas/issues/56672))

### 日期时间类

+   在传递`tz`和`dayfirst`或`yearfirst`时，`DatetimeIndex` 构造中的错误，忽略 dayfirst/yearfirst ([GH 55813](https://github.com/pandas-dev/pandas/issues/55813))

+   在传递浮点对象和`tz`的对象 dtype ndarray 时，`DatetimeIndex`错误地本地化结果（[GH 55780](https://github.com/pandas-dev/pandas/issues/55780))

+   使用`DatetimeTZDtype` dtype 和所有比较值为`NaT`的比较值时，`Series.isin()`错误地返回所有`False`，即使系列包含`NaT`条目（[GH 56427](https://github.com/pandas-dev/pandas/issues/56427))

+   `concat()`中的错误在将所有空数据框与`DatetimeTZDtype` dtype 数据框连接时引发`AttributeError`（[GH 52093](https://github.com/pandas-dev/pandas/issues/52093))

+   在比较分辨率时，`testing.assert_extension_array_equal()`可能使用错误的单位（[GH 55730](https://github.com/pandas-dev/pandas/issues/55730))

+   在传递混合字符串和数值类型列表时，`to_datetime()`和`DatetimeIndex`错误地引发错误（[GH 55780](https://github.com/pandas-dev/pandas/issues/55780))

+   在传递混合类型对象与时区混合或时区感知性混合时，`to_datetime()`和`DatetimeIndex`中的错误未能引发`ValueError`（[GH 55693](https://github.com/pandas-dev/pandas/issues/55693))

+   很大的刻度在`Tick.delta()`中引发`OverflowError`而不是`OutOfBoundsTimedelta`的错误（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   在非纳秒分辨率中，`DatetimeIndex.shift()`错误地返回纳秒分辨率（[GH 56117](https://github.com/pandas-dev/pandas/issues/56117))

+   在具有相同时区但不同单位的时区感知索引中，`DatetimeIndex.union()`返回对象 dtype 的错误（[GH 55238](https://github.com/pandas-dev/pandas/issues/55238))

+   在 `Index.is_monotonic_increasing()` 和 `Index.is_monotonic_decreasing()` 中存在 Bug，当索引中的第一个值为 `NaT` 时，始终将 `Index.is_unique()` 缓存为 `True` ([GH 55755](https://github.com/pandas-dev/pandas/issues/55755))

+   在将非支持的分辨率的 `datetime64` 转换为日期时间格式时，`Index.view()`存在 Bug，错误地引发了问题 ([GH 55710](https://github.com/pandas-dev/pandas/issues/55710))

+   在具有非纳秒分辨率和 `NaT` 条目的情况下，`Series.dt.round()`存在 Bug，错误地引发了 `OverflowError` ([GH 56158](https://github.com/pandas-dev/pandas/issues/56158))

+   具有非纳秒分辨率的 `Series.fillna()` 中存在 Bug，高分辨率矢量值返回不正确（内部损坏）的结果 ([GH 56410](https://github.com/pandas-dev/pandas/issues/56410))

+   从具有分钟或小时分辨率和时区偏移的 ISO8601 格式字符串中不正确地推断出 `Timestamp.unit()` 的 Bug ([GH 56208](https://github.com/pandas-dev/pandas/issues/56208))

+   从较高分辨率的 `datetime64` 类型转换为较低分辨率的 `datetime64` 类型（例如 `datetime64[us]->datetime64[ms]`）时存在 Bug，靠近下限实现的值会静默溢出 ([GH 55979](https://github.com/pandas-dev/pandas/issues/55979))

+   将 `Week` 偏移量添加或减去到 `datetime64` 的 `Series`、`Index` 或 `DataFrame` 列存在 Bug，返回不正确的结果 ([GH 55583](https://github.com/pandas-dev/pandas/issues/55583))

+   将 `BusinessDay` 偏移量与 `offset` 属性相加或相减到非纳秒的 `Index`、`Series` 或 `DataFrame` 列存在 Bug，给出了不正确的结果 ([GH 55608](https://github.com/pandas-dev/pandas/issues/55608))

+   在将微秒分量的`DateOffset`对象与非纳秒分辨率的`datetime64` `Index`、`Series`或`DataFrame`列相加或相减时存在的错误（[GH 55595](https://github.com/pandas-dev/pandas/issues/55595)）

+   在将非常大的`Tick`对象与`Timestamp`或`Timedelta`对象相加或相减时存在的错误，错误地引发`OverflowError`而不是`OutOfBoundsTimedelta`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503)）

+   在创建具有非纳秒`DatetimeTZDtype`和输入的`Index`、`Series`或`DataFrame`时存在的错误，这些输入超出了纳秒分辨率的范围，错误地引发`OutOfBoundsDatetime`（[GH 54620](https://github.com/pandas-dev/pandas/issues/54620)）

+   在使用混合数值输入创建具有非纳秒`datetime64`（或`DatetimeTZDtype`）的`Index`、`Series`或`DataFrame`时存在的错误，将这些输入视为纳秒而不是 dtype 单位的倍数（与非混合数值输入不同）（[GH 56004](https://github.com/pandas-dev/pandas/issues/56004)）

+   在创建具有非纳秒`datetime64` dtype 和输入的`Index`、`Series`或`DataFrame`时存在的错误，这些输入超出了`datetime64[ns]`的范围，错误地引发`OutOfBoundsDatetime`（[GH 55756](https://github.com/pandas-dev/pandas/issues/55756)）

+   在使用非 ISO8601 格式解析带有纳秒分辨率的日期时间字符串时存在的错误，错误地截断亚微秒分量（[GH 56051](https://github.com/pandas-dev/pandas/issues/56051)）

+   解析带有亚秒分辨率和尾随零的日期时间字符串存在 bug，不正确地推断秒或毫秒分辨率（[GH 55737](https://github.com/pandas-dev/pandas/issues/55737)）

+   使用浮点型参数调用 `to_datetime()` 的结果存在 bug，其 `unit` 与 `Timestamp` 的逐点结果不匹配（[GH 56037](https://github.com/pandas-dev/pandas/issues/56037)）

+   修复了当 `concat()` 连接具有不同分辨率的 `datetime64` 列时会引发错误的回归问题（[GH 53641](https://github.com/pandas-dev/pandas/issues/53641)）

### 时间差

+   在构造 `Timedelta` 时出现 bug，应该抛出 `OutOfBoundsTimedelta` 而非 `OverflowError`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503)）

+   在渲染 `TimedeltaIndex` 和 `Series` 时存在 bug，当 timedelta64 值具有非纳秒分辨率的条目，并且所有值都是 24 小时的倍数时，未能使用纳秒情况下使用的紧凑表示（[GH 55405](https://github.com/pandas-dev/pandas/issues/55405)）

### 时区

+   在计算假期时，`AbstractHolidayCalendar` 存在 bug，时区数据未在计算假期时传播（[GH 54580](https://github.com/pandas-dev/pandas/issues/54580)）

+   在具有模糊值和 `pytz` 时区的 `Timestamp` 构造中存在 bug，未能引发 `pytz.AmbiguousTimeError`（[GH 55657](https://github.com/pandas-dev/pandas/issues/55657)）

+   在 `Timestamp.tz_localize()` 中存在 bug，当 DST 期间 UTC+0 周围的 `nonexistent="shift_forward` 时存在 bug（[GH 51501](https://github.com/pandas-dev/pandas/issues/51501)）

### 数字

+   使用 `engine="pyarrow"` 时 `read_csv()` 存在 bug，导致大整数出现舍入错误（[GH 52505](https://github.com/pandas-dev/pandas/issues/52505)）

+   对于具有整数 dtypes 的 `ArrowDtype`，`Series.__floordiv__()` 和 `Series.__truediv__()` 存在 bug，当除数较大时会引发错误（[GH 56706](https://github.com/pandas-dev/pandas/issues/56706)）

+   对于具有整数 dtypes 的 `ArrowDtype`，`Series.__floordiv__()` 存在 bug，当值较大时会引发错误（[GH 56645](https://github.com/pandas-dev/pandas/issues/56645)）

+   `Series.pow()` 中的 Bug 没有正确填充缺失值（[GH 55512](https://github.com/pandas-dev/pandas/issues/55512)）

+   在 `Series.replace()` 和 `DataFrame.replace()` 中的 Bug，将浮点数 `0.0` 与 `False` 匹配，反之亦然（[GH 55398](https://github.com/pandas-dev/pandas/issues/55398)）

+   在 `Series.round()` 中的 Bug，针对可空布尔 dtype 报错（[GH 55936](https://github.com/pandas-dev/pandas/issues/55936)）

### 转换

+   在 `DataFrame.astype()` 中的 Bug，使用 `str` 对未反序列化的数组调用时可能会原地更改数组（[GH 54654](https://github.com/pandas-dev/pandas/issues/54654)）

+   在 `DataFrame.astype()` 中的 Bug，当 `errors="ignore"` 时对扩展类型没有影响（[GH 54654](https://github.com/pandas-dev/pandas/issues/54654)）

+   在 `Series.convert_dtypes()` 中的 Bug，没有将所有 NA 列转换为 `null[pyarrow]`（[GH 55346](https://github.com/pandas-dev/pandas/issues/55346)）

+   在使用 :meth:`DataFrame.loc` 时出现的 Bug 没有抛出“不兼容的 dtype 警告”（参见 [PDEP6](https://pandas.pydata.org/pdeps/0006-ban-upcasting.html)），当使用完整列设置器时，将具有不同 dtype 的 `Series` 赋值给整列时（例如 `df.loc[:, 'a'] = incompatible_value`）（[GH 39584](https://github.com/pandas-dev/pandas/issues/39584)）

### 字符串

+   在 `pandas.api.types.is_string_dtype()` 中的 Bug，检查没有元素的对象数组是否为字符串 dtype 时出现错误（[GH 54661](https://github.com/pandas-dev/pandas/issues/54661)）

+   在 `DataFrame.apply()` 中的 Bug，在 `engine="numba"` 且列或索引具有 `StringDtype` 时失败（[GH 56189](https://github.com/pandas-dev/pandas/issues/56189)）

+   在 `DataFrame.reindex()` 中的 Bug，不能将具有 `string[pyarrow_numpy]` dtype 的 `Index` 与之匹配（[GH 56106](https://github.com/pandas-dev/pandas/issues/56106)）

+   在 `Index.str.cat()` 中的 Bug，始终将结果转换为对象 dtype（[GH 56157](https://github.com/pandas-dev/pandas/issues/56157)）

+   `Series.__mul__()` 中存在漏洞，对于具有 `pyarrow.string` 数据类型的 `ArrowDtype` 和 `pyarrow` 后端的 `string[pyarrow]` （[GH 51970](https://github.com/pandas-dev/pandas/issues/51970)）

+   `Series.str.find()` 中存在漏洞，当 `start < 0` 时，对于具有 `pyarrow.string` 的 `ArrowDtype` （[GH 56411](https://github.com/pandas-dev/pandas/issues/56411)）

+   `Series.str.fullmatch()` 中存在漏洞，当 `dtype=pandas.ArrowDtype(pyarrow.string()))` 时，当正则表达式以文字结束时，允许部分匹配 //$ （[GH 56652](https://github.com/pandas-dev/pandas/issues/56652)）

+   `Series.str.replace()` 中存在漏洞，当 `n < 0` 时，对于具有 `pyarrow.string` 的 `ArrowDtype` （[GH 56404](https://github.com/pandas-dev/pandas/issues/56404)）

+   `Series.str.startswith()` 和 `Series.str.endswith()` 中存在漏洞，类型为 `tuple[str, ...]` 的参数对于具有 `pyarrow.string` 数据类型的 `ArrowDtype` （[GH 56579](https://github.com/pandas-dev/pandas/issues/56579)）

+   `Series.str.startswith()` 和 `Series.str.endswith()` 中存在漏洞，类型为 `tuple[str, ...]` 的参数对于 `string[pyarrow]` （[GH 54942](https://github.com/pandas-dev/pandas/issues/54942)）

+   对于 `dtype="string[pyarrow_numpy]"` 的比较操作存在漏洞，如果数据类型无法进行比较，则会引发错误（[GH 56008](https://github.com/pandas-dev/pandas/issues/56008)）

### Interval

+   `Interval` 中的 `__repr__` 存在漏洞，不显示 `Timestamp` 边界的 UTC 偏移量。此外，小时、分钟和秒组件现在将被显示（[GH 55015](https://github.com/pandas-dev/pandas/issues/55015)）

+   `IntervalIndex.factorize()` 和 `Series.factorize()` 存在错误，对于带有 datetime64 或 timedelta64 的间隔，未能保留非纳秒单位 ([GH 56099](https://github.com/pandas-dev/pandas/issues/56099))

+   在使用不匹配分辨率的 `datetime64` 或 `timedelta64` 数组时，`IntervalIndex.from_arrays()` 出现错误，构造无效的 `IntervalArray` 对象 ([GH 55714](https://github.com/pandas-dev/pandas/issues/55714))

+   在子类型为可空扩展 dtype 时，`IntervalIndex.from_tuples()` 出现错误 ([GH 56765](https://github.com/pandas-dev/pandas/issues/56765))

+   `IntervalIndex.get_indexer()` 存在错误，对于带有 datetime 或 timedelta 的间隔，与整数目标不正确匹配 ([GH 47772](https://github.com/pandas-dev/pandas/issues/47772))

+   在带有时区感知 datetime 区间的情况下，`IntervalIndex.get_indexer()` 在与一系列时区非感知目标不正确匹配时存在错误 ([GH 47772](https://github.com/pandas-dev/pandas/issues/47772))

+   在使用切片将值设置在带有 `IntervalIndex` 的 `Series` 上时，存在错误 ([GH 54722](https://github.com/pandas-dev/pandas/issues/54722))

### 索引

+   当 `DataFrame` 具有 `MultiIndex` 时，`DataFrame.loc()` 在变异布尔索引器时出现错误 ([GH 56635](https://github.com/pandas-dev/pandas/issues/56635))

+   在将扩展 dtype 的 `Series` 设置为 NumPy dtype 时，`DataFrame.loc()` 存在错误 ([GH 55604](https://github.com/pandas-dev/pandas/issues/55604))

+   当 `other` 为空或 `other` 被视为不可比较时，`Index.difference()` 未返回唯一值集合 ([GH 55113](https://github.com/pandas-dev/pandas/issues/55113))

+   在设置 `Categorical` 值到具有 numpy dtypes 的 `DataFrame` 中时的 Bug，会引发 `RecursionError`（[GH 52927](https://github.com/pandas-dev/pandas/issues/52927)）

+   修复了在设置单个字符串值时创建具有缺失值的新列时的 Bug（[GH 56204](https://github.com/pandas-dev/pandas/issues/56204)）

### 缺失

+   在 `DataFrame.update()` 中的 Bug，对于带有时区信息的 datetime64 dtypes 未进行原地更新（[GH 56227](https://github.com/pandas-dev/pandas/issues/56227)）

### MultiIndex

+   在 `MultiIndex.get_indexer()` 中的 Bug，在提供了 `method` 并且索引是非单调的情况下未引发 `ValueError`（[GH 53452](https://github.com/pandas-dev/pandas/issues/53452)）

### I/O

+   在 `read_csv()` 中的 Bug，当指定了 `skiprows` 时，`engine="python"` 不会尊重 `chunksize` 参数（[GH 56323](https://github.com/pandas-dev/pandas/issues/56323)）

+   在 `read_csv()` 中的 Bug，当设置 `engine="python"` 时，如果指定了可调用的 `skiprows` 和一个 chunk size，会导致 `TypeError`（[GH 55677](https://github.com/pandas-dev/pandas/issues/55677)）

+   在 `read_csv()` 中的 Bug，当 `on_bad_lines="warn"` 时，会将信息写入 `stderr` 而不是引发 Python 警告；现在将产生一个 `errors.ParserWarning`（[GH 54296](https://github.com/pandas-dev/pandas/issues/54296)）

+   在 `read_csv()` 中的 Bug，使用 `engine="pyarrow"` 时，`quotechar` 被忽略了（[GH 52266](https://github.com/pandas-dev/pandas/issues/52266)）

+   在 `read_csv()` 中的 Bug，使用 `engine="pyarrow"` 时，`usecols` 在没有标题的 CSV 中无法正常工作（[GH 54459](https://github.com/pandas-dev/pandas/issues/54459)）

+   在 `read_excel()` 中的 Bug，在使用 `engine="xlrd"`（`xls` 文件）时，当文件包含 `NaN` 或 `Inf` 时会出错（[GH 54564](https://github.com/pandas-dev/pandas/issues/54564)）

+   在 `read_json()` 中的 Bug，如果设置了 `infer_string`，则无法正确处理 dtype 转换（[GH 56195](https://github.com/pandas-dev/pandas/issues/56195)）

+   `DataFrame.to_excel()` 中的 Bug，使用 `OdsWriter`（`ods` 文件）写入布尔值/字符串值时出现问题（[GH 54994](https://github.com/pandas-dev/pandas/issues/54994))

+   `DataFrame.to_hdf()` 和 `read_hdf()` 中的 Bug，`datetime64` 数据类型的分辨率为非纳秒时无法正确往返（[GH 55622](https://github.com/pandas-dev/pandas/issues/55622))

+   `DataFrame.to_stata()` 中的 Bug 引发了扩展数据类型的问题（[GH 54671](https://github.com/pandas-dev/pandas/issues/54671))

+   `read_excel()` 中的 Bug，使用 `engine="odf"`（`ods` 文件）时，字符串单元格包含注释时出现问题（[GH 55200](https://github.com/pandas-dev/pandas/issues/55200))

+   `read_excel()` 中的 Bug，在不带缓存格式化单元格的 ODS 文件中，浮点值出现问题（[GH 55219](https://github.com/pandas-dev/pandas/issues/55219))

+   `DataFrame.to_json()` 中的 Bug，不支持的 NumPy 类型导致引发 `OverflowError` 而不是 `TypeError`（[GH 55403](https://github.com/pandas-dev/pandas/issues/55403))

### 时期

+   `PeriodIndex` 构造中，传递了多个参数 `data`、`ordinal` 和 `**fields` 时未能引发 `ValueError`（[GH 55961](https://github.com/pandas-dev/pandas/issues/55961))

+   `Period` 加法中，静默包装而不是引发 `OverflowError`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   从 `PeriodDtype` 使用 `astype` 转换为 `datetime64` 或 `DatetimeTZDtype` 时，以非纳秒单位错误地返回纳秒单位（[GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

### 绘图

+   `DataFrame.plot.box()` 中的 Bug，在 `vert=False` 且使用 `sharey=True` 创建的 Matplotlib `Axes` 时出现问题（[GH 54941](https://github.com/pandas-dev/pandas/issues/54941))

+   在调用`DataFrame.plot.scatter()`时存在 bug，会丢弃字符串列（[GH 56142](https://github.com/pandas-dev/pandas/issues/56142)）

+   在重复使用`ax`对象时，`Series.plot()`存在一个 bug，当传递`how`关键字时未能引发错误（[GH 55953](https://github.com/pandas-dev/pandas/issues/55953)）

### Groupby/resample/rolling

+   当索引为包含 NA 值的`CategoricalIndex`时，`DataFrameGroupBy.idxmin()`、`DataFrameGroupBy.idxmax()`、`SeriesGroupBy.idxmin()`和`SeriesGroupBy.idxmax()`存在 bug，未能保留`Categorical` dtype（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）

+   当`observed=False`且`f="idxmin"`或`f="idxmax"`时，`DataFrameGroupBy.transform()`和`SeriesGroupBy.transform()`存在 bug，会在未观察到的类别上错误引发异常（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）

+   当 DataFrame 的列或 Series 的名称为整数时，`DataFrameGroupBy.value_counts()`和`SeriesGroupBy.value_counts()`存在 bug，可能导致排序不正确（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）

+   Bug in `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 在 `DataFrame.groupby()` 和 `Series.groupby()` 中不会尊重 `sort=False`（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951))

+   Bug in `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 当 `sort=True` 和 `normalize=True` 时，会按比例而不是频率排序（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951))

+   Bug in `DataFrame.asfreq()` 和 `Series.asfreq()` 在具有非纳秒分辨率的 `DatetimeIndex` 错误地转换为纳秒分辨率（[GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

+   Bug in `DataFrame.ewm()` 当传递非纳秒 `datetime64` 或 `DatetimeTZDtype` 类型的 `times` 时出现问题（[GH 56262](https://github.com/pandas-dev/pandas/issues/56262))

+   Bug in `DataFrame.groupby()` 和 `Series.groupby()` 在通过 `Decimal` 和 NA 值的组合进行分组时，当 `sort=True` 时会失败（[GH 54847](https://github.com/pandas-dev/pandas/issues/54847))

+   Bug in `DataFrame.groupby()` 在 DataFrame 子类中选择要应用函数的列子集时出现问题（[GH 56761](https://github.com/pandas-dev/pandas/issues/56761))

+   在对`BusinessDay`进行重新取样时，`DataFrame.resample()`不遵守`closed`和`label`参数的 bug（[GH 55282](https://github.com/pandas-dev/pandas/issues/55282))

+   在对`pyarrow.timestamp`或`pyarrow.duration`类型的`ArrowDtype`进行重新取样时，`DataFrame.resample()`存在 bug（[GH 55989](https://github.com/pandas-dev/pandas/issues/55989)）

+   在对`BusinessDay`进行重新取样时，`DataFrame.resample()`存在 bin 边界不正确的 bug（[GH 55281](https://github.com/pandas-dev/pandas/issues/55281)）

+   在对`MonthBegin`进行重新取样时，`DataFrame.resample()`存在 bin 边界不正确的 bug（[GH 55271](https://github.com/pandas-dev/pandas/issues/55271)）

+   在使用`closed='left'`和`closed='neither'`时，`DataFrame.rolling()`和`Series.rolling()`存在重复的 datetimelike 索引被视为连续而不是相等的 bug（[GH 20712](https://github.com/pandas-dev/pandas/issues/20712)）

+   当`index`或`on`列为具有`pyarrow.timestamp`类型的`ArrowDtype`时，`DataFrame.rolling()`和`Series.rolling()`存在 bug（[GH 55849](https://github.com/pandas-dev/pandas/issues/55849)）

### 重塑

+   当传递`DatetimeIndex`索引时，`concat()`存在忽略`sort`参数的 bug（[GH 54769](https://github.com/pandas-dev/pandas/issues/54769)）

+   `concat()` 函数中的 Bug：当 `ignore_index=False` 时重命名 `Series`（[GH 15047](https://github.com/pandas-dev/pandas/issues/15047))

+   `merge_asof()` 函数中的 Bug：当 `by` 的 dtype 不是 `object`、`int64` 或 `uint64` 时引发 `TypeError` 错误（[GH 22794](https://github.com/pandas-dev/pandas/issues/22794))

+   `merge_asof()` 函数中的 Bug：对于字符串 dtype 引发错误的错误消息不正确（[GH 56444](https://github.com/pandas-dev/pandas/issues/56444))

+   `merge_asof()` 函数中的 Bug：在对具有 `Timedelta` 容差的 `ArrowDtype` 列进行合并时出现问题（[GH 56486](https://github.com/pandas-dev/pandas/issues/56486))

+   `merge()` 函数中的 Bug：当合并日期时间列和时间增量列时未引发错误（[GH 56455](https://github.com/pandas-dev/pandas/issues/56455))

+   `merge()` 函数中的 Bug：当合并字符串列和数值列时未引发错误（[GH 56441](https://github.com/pandas-dev/pandas/issues/56441))

+   `merge()` 函数中的 Bug：未按正确顺序返回新字符串 dtype 的列（[GH 56442](https://github.com/pandas-dev/pandas/issues/56442))

+   `merge()` 函数中的 Bug：当左侧和/或右侧为空时，返回列的顺序不正确（[GH 51929](https://github.com/pandas-dev/pandas/issues/51929))

+   `DataFrame.melt()` 函数中的 Bug：如果 `var_name` 不是字符串，则会引发异常（[GH 55948](https://github.com/pandas-dev/pandas/issues/55948))

+   `DataFrame.melt()` 函数中的 Bug：无法保留日期时间信息（[GH 55254](https://github.com/pandas-dev/pandas/issues/55254))

+   `DataFrame.pivot_table()` 函数中的 Bug：当列具有数值名称时，行边距不正确（[GH 26568](https://github.com/pandas-dev/pandas/issues/26568))

+   `DataFrame.pivot()` 函数中的 Bug：针对具有数值列和扩展 dtype 数据的情况（[GH 56528](https://github.com/pandas-dev/pandas/issues/56528))

+   `DataFrame.stack()` 中的 Bug，使用 `future_stack=True` 时不会保留索引中的 NA 值（[GH 56573](https://github.com/pandas-dev/pandas/issues/56573)）

### 稀疏

+   `arrays.SparseArray.take()` 中的 Bug，在使用与数组填充值不同的填充值时出现问题（[GH 55181](https://github.com/pandas-dev/pandas/issues/55181)）

### 其他

+   `DataFrame.__dataframe__()` 不支持 pyarrow 大字符串（[GH 56702](https://github.com/pandas-dev/pandas/issues/56702)）

+   `DataFrame.describe()` 中的 Bug，在格式化结果中的百分位数时，百分位数 99.999% 被四舍五入为 100%（[GH 55765](https://github.com/pandas-dev/pandas/issues/55765)）

+   `api.interchange.from_dataframe()` 中的 Bug，在处理空字符串列时引发 `NotImplementedError`（[GH 56703](https://github.com/pandas-dev/pandas/issues/56703)）

+   `cut()` 和 `qcut()` 中的 Bug，对于具有非纳秒单位的 `datetime64` dtype 值，错误地返回纳秒单位的区间（[GH 56101](https://github.com/pandas-dev/pandas/issues/56101)）

+   `cut()` 中的 Bug，错误地允许使用时区感知的日期时间进行切割，并使用时区不感知的区间（[GH 54964](https://github.com/pandas-dev/pandas/issues/54964)）

+   `infer_freq()` 和 `DatetimeIndex.inferred_freq()` 中的 Bug，在周频率和非纳秒分辨率下出现问题（[GH 55609](https://github.com/pandas-dev/pandas/issues/55609)）

+   `DataFrame.apply()` 中的 Bug，当传递 `raw=True` 时会忽略传递给应用函数的 `args`（[GH 55009](https://github.com/pandas-dev/pandas/issues/55009)）

+   `DataFrame.from_dict()` 中的 Bug，会始终对创建的 `DataFrame` 的行进行排序（[GH 55683](https://github.com/pandas-dev/pandas/issues/55683)）

+   当传递 `axis="columns"` 和 `ignore_index=True` 时，`DataFrame.sort_index()` 引发 `ValueError` 的 bug（[GH 56478](https://github.com/pandas-dev/pandas/issues/56478)）

+   当启用 `use_inf_as_na` 选项时，在 `DataFrame` 中渲染 `inf` 值的 bug（[GH 55483](https://github.com/pandas-dev/pandas/issues/55483)）

+   当 `Series` 具有 `MultiIndex` 且索引级别之一的名称为 0 时不显示该名称的 bug（[GH 55415](https://github.com/pandas-dev/pandas/issues/55415)）

+   当向空 `DataFrame` 赋予一列时出现错误信息的 bug（[GH 55956](https://github.com/pandas-dev/pandas/issues/55956)）

+   当将类似时间的字符串转换为具有 `pyarrow.time64` 类型的 `ArrowDtype` 时的 bug（[GH 56463](https://github.com/pandas-dev/pandas/issues/56463)）

+   修复了当在 `core.window.Rolling.apply` 中传递一个 numpy ufunc 且 `engine="numba"` 时，`numba` >= 0.58.0 会发出不必要的弃用警告的 bug（[GH 55247](https://github.com/pandas-dev/pandas/issues/55247)）  ## 贡献者

共有 162 人为此版本做出了贡献。名字后面带有 “+” 的人第一次为此提交了补丁。

+   AG

+   Aaron Rahman +

+   Abdullah Ihsan Secer +

+   Abhijit Deo +

+   Adrian D’Alessandro

+   Ahmad Mustafa Anis +

+   Amanda Bizzinotto

+   Amith KK +

+   Aniket Patil +

+   Antonio Fonseca +

+   Artur Barseghyan

+   Ben Greiner

+   Bill Blum +

+   Boyd Kane

+   Damian Kula

+   Dan King +

+   Daniel Weindl +

+   Daniele Nicolodi

+   David Poznik

+   David Toneian +

+   Dea María Léon

+   Deepak George +

+   Dmitriy +

+   Dominique Garmier +

+   Donald Thevalingam +

+   Doug Davis +

+   Dukastlik +

+   Elahe Sharifi +

+   Eric Han +

+   Fangchen Li

+   Francisco Alfaro +

+   Gadea Autric +

+   Guillaume Lemaitre

+   Hadi Abdi Khojasteh

+   Hedeer El Showk +

+   Huanghz2001 +

+   Isaac Virshup

+   Issam +

+   Itay Azolay +

+   Itayazolay +

+   Jaca +

+   Jack McIvor +

+   JackCollins91 +

+   James Spencer +

+   Jay

+   Jessica Greene

+   Jirka Borovec +

+   JohannaTrost +

+   John C +

+   Joris Van den Bossche

+   José Lucas Mayer +

+   José Lucas Silva Mayer +

+   João Andrade +

+   Kai Mühlbauer

+   Katharina Tielking, MD +

+   Kazuto Haruguchi +

+   Kevin

+   Lawrence Mitchell

+   Linus +

+   Linus Sommer +

+   Louis-Émile Robitaille +

+   Luke Manley

+   Lumberbot（又名 Jack）

+   Maggie Liu +

+   MainHanzo +

+   Marc Garcia

+   Marco Edward Gorelli

+   MarcoGorelli

+   Martin Šícho +

+   Mateusz Sokół

+   Matheus Felipe +

+   Matthew Roeschke

+   Matthias Bussonnier

+   Maxwell Bileschi +

+   Michael Tiemann

+   Michał Górny

+   Molly Bowers +

+   Moritz Schubert +

+   NNLNR +

+   Natalia Mokeeva

+   Nils Müller-Wendt +

+   Omar Elbaz

+   Pandas 开发团队

+   Paras Gupta +

+   Parthi

+   Patrick Hoefler

+   Paul Pellissier +

+   Paul Uhlenbruck +

+   Philip Meier

+   Philippe THOMY +

+   Quang Nguyễn

+   Raghav

+   Rajat Subhra Mukherjee

+   Ralf Gommers

+   Randolf Scholz +

+   Richard Shadrach

+   Rob +

+   Rohan Jain +

+   Ryan Gibson +

+   Sai-Suraj-27 +

+   Samuel Oranyeli +

+   Sara Bonati +

+   Sebastian Berg

+   Sergey Zakharov +

+   Shyamala Venkatakrishnan +

+   StEmGeo +

+   Stefanie Molin

+   Stijn de Gooijer +

+   Thiago Gariani +

+   Thomas A Caswell

+   Thomas Baumann +

+   Thomas Guillet +

+   Thomas Lazarus +

+   Thomas Li

+   Tim Hoffmann

+   Tim Swast

+   Tom Augspurger

+   Toro +

+   Torsten Wörtwein

+   Ville Aikas +

+   Vinita Parasrampuria +

+   Vyas Ramasubramani +

+   William Andrea

+   William Ayd

+   Willian Wang +

+   Xiao Yuan

+   Yao Xiao

+   Yves Delley

+   Zemux1613 +

+   Ziad Kermadi +

+   aaron-robeson-8451 +

+   aram-cinnamon +

+   caneff +

+   ccccjone +

+   chris-caballero +

+   cobalt

+   color455nm +

+   denisrei +

+   dependabot[bot]

+   jbrockmendel

+   jfadia +

+   johanna.trost +

+   kgmuzungu +

+   mecopur +

+   mhb143 +

+   morotti +

+   mvirts +

+   omar-elbaz

+   paulreece

+   pre-commit-ci[bot]

+   raj-thapa

+   rebecca-palmer

+   rmhowe425

+   rohanjain101

+   shiersansi +

+   smij720

+   srkds +

+   taytzehao

+   torext

+   vboxuser +

+   xzmeng +

+   yashb +  ## pandas 3.0 中即将到来的变化

pandas 3.0 将为 pandas 的默认行为带来两个较大的变化。

### 写时复制

在 pandas 3.0 中，当前可选的写时复制模式将默认启用。不会有选项保留当前行为。有关写时复制的新行为语义在写时复制用户指南中有解释。

新行为可以在 pandas 2.0 中通过以下选项启用：

```py
pd.options.mode.copy_on_write = True 
```

这一变化带来了 pandas 在复制和视图方面操作方式的不同变化。其中一些变化允许明确弃用，比如链式赋值的变化。其他变化更加微妙，因此警告被隐藏在一个选项后面，可以在 pandas 2.2 中启用。

```py
pd.options.mode.copy_on_write = "warn" 
```

这种模式将在许多不实际相关于大多数查询的情况下发出警告。我们建议探索这种模式，但没有必要消除所有这些警告。迁移指南更详细地解释了升级过程。

### 默认情况下使用专用字符串数据类型（由 Arrow 支持）

历史上，pandas 用 NumPy 对象数据类型表示字符串列。这种表示方式存在许多问题，包括性能慢和内存占用大。这将在 pandas 3.0 中改变。pandas 将开始将字符串列推断为新的`string`数据类型，由 Arrow 支持，表示内存中连续的字符串。这带来了巨大的性能和内存改进。

旧行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: object 
```

新行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: string 
```

在这些场景中使用的字符串数据类型将大多数情况下表现得像 NumPy 对象一样，包括缺失值语义和对这些列的一般操作。

这一变化涉及 API 中的一些其他变化：

+   目前，指定 `dtype="string"` 会创建一个由 Python 字符串支持的 dtype，这些字符串存储在 NumPy 数组中。这将在 pandas 3.0 中改变，该 dtype 将创建一个由 Arrow 支持的字符串列。

+   列名和索引也将由 Arrow 字符串支持。

+   为了适应这一变更，PyArrow 将成为 pandas 3.0 的必需依赖项。

这种未来的 dtype 推断逻辑可以通过以下方式启用：

```py
pd.options.future.infer_string = True 
```

### 写时复制

当前可选的写时复制模式将在 pandas 3.0 中默认启用。不会有选项来保持当前行为不变。关于新的行为语义在写时复制的用户指南中有解释。

新的行为可以在 pandas 2.0 中使用以下选项启用：

```py
pd.options.mode.copy_on_write = True 
```

这一变更将在 pandas 的操作行为上带来不同的变化，涉及到副本和视图的操作。其中一些变更可以明确地弃用，比如链式赋值的变更。其他变更更加微妙，因此警告被隐藏在一个选项后面，在 pandas 2.2 中可以启用。

```py
pd.options.mode.copy_on_write = "warn" 
```

这种模式将在许多实际上与大多数查询无关的情况下发出警告。我们建议尝试使用这种模式，但不必摆脱所有这些警告。迁移指南 详细解释了升级过程。

### 默认情况下，将使用专用的字符串数据类型（由 Arrow 支持）。

在历史上，pandas 用 NumPy 对象数据类型表示字符串列。这种表示方法存在许多问题，包括性能慢和内存占用大。这将在 pandas 3.0 中改变。pandas 将开始将字符串列推断为新的 `string` 数据类型，由 Arrow 支持，该类型表示内存连续的字符串。这将带来巨大的性能和内存改进。

旧行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: object 
```

新行为：

```py
In [1]: ser = pd.Series(["a", "b"])
Out[1]:
0    a
1    b
dtype: string 
```

在这些情景中使用的字符串数据类型将主要表现为 NumPy 对象的行为，包括对这些列的缺失值语义和一般操作。

这一变更还涉及 API 中的一些其他变更：

+   目前，指定 `dtype="string"` 会创建一个由 Python 字符串支持的 dtype，这些字符串存储在 NumPy 数组中。这将在 pandas 3.0 中改变，该 dtype 将创建一个由 Arrow 支持的字符串列。

+   列名和索引也将由 Arrow 字符串支持。

+   为了适应这一变更，PyArrow 将成为 pandas 3.0 的必需依赖项。

这种未来的 dtype 推断逻辑可以通过以下方式启用：

```py
pd.options.future.infer_string = True 
```

## 增强功能

### 在 to_sql 和 read_sql 中支持 ADBC 驱动程序

`read_sql()` 和 `to_sql()` 现在可以使用 [Apache Arrow ADBC](https://arrow.apache.org/adbc/current/index.html) 驱动程序。 与通过 SQLAlchemy 使用的传统驱动程序相比，ADBC 驱动程序应提供显著的性能改进，更好的类型支持和更清晰的空值处理。

```py
import adbc_driver_postgresql.dbapi as pg_dbapi

df = pd.DataFrame(
    [
        [1, 2, 3],
        [4, 5, 6],
    ],
    columns=['a', 'b', 'c']
)
uri = "postgresql://postgres:postgres@localhost/postgres"
with pg_dbapi.connect(uri) as conn:
    df.to_sql("pandas_table", conn, index=False)

# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn) 
```

Arrow 类型系统提供了更广泛的类型，可以更接近像 PostgreSQL 这样的数据库所提供的内容。 举例来说，以下是不完整的不同数据库和 pandas 后端可用类型的列表：

| numpy/pandas | arrow | postgres | sqlite |
| --- | --- | --- | --- |
| int16/Int16 | int16 | SMALLINT | INTEGER |
| int32/Int32 | int32 | INTEGER | INTEGER |
| int64/Int64 | int64 | BIGINT | INTEGER |
| float32 | float32 | REAL | REAL |
| float64 | float64 | DOUBLE PRECISION | REAL |
| object | string | TEXT | TEXT |
| bool | `bool_` | BOOLEAN |  |
| datetime64[ns] | timestamp(us) | TIMESTAMP |  |
| datetime64[ns,tz] | timestamp(us,tz) | TIMESTAMPTZ |  |
|  | date32 | DATE |  |
|  | month_day_nano_interval | INTERVAL |  |
|  | binary | BINARY | BLOB |
|  | decimal128 | DECIMAL [[1]](#f1) |  |
|  | list | ARRAY [[1]](#f1) |  |
|  | struct |

复合类型

[[1]](#f1)

|  |
| --- |

脚注

如果您希望在 DataFrame 的整个生命周期中尽可能保留数据库类型，建议用户利用 `read_sql()` 的 `dtype_backend="pyarrow"` 参数。

```py
# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn, dtype_backend="pyarrow") 
```

这将防止数据被转换为传统的 pandas/NumPy 类型系统，后者通常以使它们无法往返的方式转换 SQL 类型。

欲了解完整的 ADBC 驱动程序列表及其开发状态，请参阅 [ADBC 驱动程序实现状态](https://arrow.apache.org/adbc/current/driver/status.html) 文档。  ### 基于一个或多个条件创建 pandas Series

`Series.case_when()` 函数已添加，可根据一个或多个条件创建 Series 对象。 ([GH 39154](https://github.com/pandas-dev/pandas/issues/39154))

```py
In [1]: import pandas as pd

In [2]: df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6]))

In [3]: default=pd.Series('default', index=df.index)

In [4]: default.case_when(
 ...:     caselist=[
 ...:         (df.a == 1, 'first'),                              # condition, replacement
 ...:         (df.a.gt(1) & df.b.eq(5), 'second'),  # condition, replacement
 ...:     ],
 ...: )
 ...: 
Out[4]: 
0      first
1     second
2    default
dtype: object 
```  ### `to_numpy` 用于 NumPy 可空和 Arrow 类型将转换为适当的 NumPy 类型

`to_numpy` 用于 NumPy 可空和 Arrow 类型现在将转换为适当的 NumPy 类型，而不是对于可空和 PyArrow 支持的扩展类型使用 `object` 类型。

*旧行为：*

```py
In [1]: ser = pd.Series([1, 2, 3], dtype="Int64")
In [2]: ser.to_numpy()
Out[2]: array([1, 2, 3], dtype=object) 
```

*新行为：*

```py
In [5]: ser = pd.Series([1, 2, 3], dtype="Int64")

In [6]: ser.to_numpy()
Out[6]: array([1, 2, 3])

In [7]: ser = pd.Series([1, 2, 3], dtype="timestamp[ns][pyarrow]")

In [8]: ser.to_numpy()
Out[8]: 
array(['1970-01-01T00:00:00.000000001', '1970-01-01T00:00:00.000000002',
 '1970-01-01T00:00:00.000000003'], dtype='datetime64[ns]') 
```

默认的 NumPy 类型（没有任何参数）确定如下：

+   浮点类型被转换为 NumPy 浮点类型

+   没有缺失值的整数类型被转换为 NumPy 整数类型

+   具有缺失值的整数类型被转换为 NumPy 浮点类型，并使用 `NaN` 作为缺失值指示符

+   没有缺失值的布尔类型被转换为 NumPy 的布尔类型。

+   带有缺失值的布尔类型保持对象类型。

+   将 datetime 和 timedelta 类型分别转换为 Numpy datetime64 和 timedelta64 类型，并使用`NaT`作为缺失值指示符。### Series.struct accessor for PyArrow structured data

`Series.struct`访问器提供了处理具有`struct[pyarrow]`数据类型 Series 的属性和方法。例如，`Series.struct.explode()`将 PyArrow 结构化数据转换为 pandas DataFrame。 ([GH 54938](https://github.com/pandas-dev/pandas/issues/54938))

```py
In [9]: import pyarrow as pa

In [10]: series = pd.Series(
 ....:    [
 ....:        {"project": "pandas", "version": "2.2.0"},
 ....:        {"project": "numpy", "version": "1.25.2"},
 ....:        {"project": "pyarrow", "version": "13.0.0"},
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.struct([
 ....:            ("project", pa.string()),
 ....:            ("version", pa.string()),
 ....:        ])
 ....:    ),
 ....: )
 ....: 

In [11]: series.struct.explode()
Out[11]: 
 project version
0   pandas   2.2.0
1    numpy  1.25.2
2  pyarrow  13.0.0 
```

使用`Series.struct.field()`来索引（可能嵌套的）结构字段。

```py
In [12]: series.struct.field("project")
Out[12]: 
0     pandas
1      numpy
2    pyarrow
Name: project, dtype: string[pyarrow] 
```### PyArrow 列表数据的`Series.list`访问器

`Series.list`访问器提供了处理具有`list[pyarrow]`数据类型 Series 的属性和方法。例如，`Series.list.__getitem__()`允许在 Series 中索引 pyarrow 列表。 ([GH 55323](https://github.com/pandas-dev/pandas/issues/55323))

```py
In [13]: import pyarrow as pa

In [14]: series = pd.Series(
 ....:    [
 ....:        [1, 2, 3],
 ....:        [4, 5],
 ....:        [6],
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.list_(pa.int64())
 ....:    ),
 ....: )
 ....: 

In [15]: series.list[0]
Out[15]: 
0    1
1    4
2    6
dtype: int64[pyarrow] 
```### `read_excel()`的 Calamine 引擎

将`calamine`引擎添加到`read_excel()`中。它使用`python-calamine`，该工具提供了 Rust 库[calamine](https://crates.io/crates/calamine)的 Python 绑定。此引擎支持 Excel 文件（`.xlsx`、`.xlsm`、`.xls`、`.xlsb`）和 OpenDocument 电子表格（`.ods`）（[GH 50395](https://github.com/pandas-dev/pandas/issues/50395)）。

此引擎有两个优点：

1.  Calamine 通常比其他引擎快，一些基准测试显示其结果比‘openpyxl’快 5 倍，比‘odf’快 20 倍，比‘pyxlsb’快 4 倍，比‘xlrd’快 1.5 倍。但是，由于对行的惰性迭代，‘openpyxl’和‘pyxlsb’在从大文件中读取少量行时更快。

1.  Calamine 支持在`.xlsb`文件中识别日期时间，与 pandas 中唯一可以读取`.xlsb`文件的另一个引擎‘pyxlsb’不同。

```py
pd.read_excel("path_to_file.xlsb", engine="calamine") 
```

更多内容，请参阅 Calamine（Excel 和 ODS 文件）中的用户指南中的 IO 工具。###其他增强功能

+   将 method 参数设置为`multi`的`to_sql()`与后端 Oracle 一起使用。

+   `Series.attrs` / `DataFrame.attrs` 现在使用深拷贝来传播`attrs`（[GH 54134](https://github.com/pandas-dev/pandas/issues/54134)）。

+   `get_dummies()` 现在返回扩展数据类型 `boolean` 或 `bool[pyarrow]`，与输入数据类型兼容（[GH 56273](https://github.com/pandas-dev/pandas/issues/56273)）

+   `read_csv()` 现在支持 `on_bad_lines` 参数，使用 `engine="pyarrow"`（[GH 54480](https://github.com/pandas-dev/pandas/issues/54480)）

+   `read_sas()` 返回 `datetime64` 数据类型，其分辨率更好地匹配原生存储在 SAS 中的数据，并避免在无法使用 `datetime64[ns]` 数据类型存储的情况下返回对象数据类型（[GH 56127](https://github.com/pandas-dev/pandas/issues/56127)）

+   `read_spss()` 现在返回一个存储元数据的 `DataFrame`，元数据存储在 `DataFrame.attrs` 中（[GH 54264](https://github.com/pandas-dev/pandas/issues/54264)）

+   `tseries.api.guess_datetime_format()` 现在是公共 API 的一部分（[GH 54727](https://github.com/pandas-dev/pandas/issues/54727))

+   `DataFrame.apply()` 现在允许使用 numba（通过 `engine="numba"`）对传递的函数进行 JIT 编译，从而可能加快速度（[GH 54666](https://github.com/pandas-dev/pandas/issues/54666)）

+   `ExtensionArray._explode()` 接口方法已添加，允许扩展类型实现 `explode` 方法（[GH 54833](https://github.com/pandas-dev/pandas/issues/54833)）

+   `ExtensionArray.duplicated()` 已添加，允许扩展类型实现 `duplicated` 方法（[GH 55255](https://github.com/pandas-dev/pandas/issues/55255)）

+   `Series.ffill()`，`Series.bfill()`，`DataFrame.ffill()` 和 `DataFrame.bfill()` 现在增加了参数 `limit_area`；第三方 `ExtensionArray` 作者需要将此参数添加到方法 `_pad_or_backfill` 中（[GH 56492](https://github.com/pandas-dev/pandas/issues/56492)）

+   允许通过`engine_kwargs`在`read_excel()`中传递`read_only`、`data_only`和`keep_links`参数给 openpyxl（[GH 55027](https://github.com/pandas-dev/pandas/issues/55027))

+   为`ArrowDtype`和掩码数据类型实现了`Series.interpolate()`和`DataFrame.interpolate()` ([GH 56267](https://github.com/pandas-dev/pandas/issues/56267))

+   为`Series.value_counts()`实现了掩码算法（[GH 54984](https://github.com/pandas-dev/pandas/issues/54984))

+   为具有`pyarrow.duration`类型的`ArrowDtype`实现了`Series.dt()`方法和属性 ([GH 52284](https://github.com/pandas-dev/pandas/issues/52284))

+   为`ArrowDtype`实现了`Series.str.extract()` ([GH 56268](https://github.com/pandas-dev/pandas/issues/56268))

+   改进了在`DatetimeIndex.to_period()`中出现的错误消息，当频率不受支持作为期间频率时，如`"BMS"`（[GH 56243](https://github.com/pandas-dev/pandas/issues/56243))

+   当构造`Period`时出现无效偏移量（如`"QS"`）时，改进了错误消息（[GH 55785](https://github.com/pandas-dev/pandas/issues/55785))

+   数据类型`string[pyarrow]`和`string[pyarrow_numpy]`现在都利用了 PyArrow 的`large_string`类型，以避免长列的溢出（[GH 56259](https://github.com/pandas-dev/pandas/issues/56259))  ### ADBC 驱动程序支持在 to_sql 和 read_sql 中

`read_sql()`和`to_sql()`现在可以与[Apache Arrow ADBC](https://arrow.apache.org/adbc/current/index.html)驱动程序一起使用。与通过 SQLAlchemy 使用的传统驱动程序相比，ADBC 驱��程序应该提供显著的性能改进，更好的类型支持和更清晰的空值处理。

```py
import adbc_driver_postgresql.dbapi as pg_dbapi

df = pd.DataFrame(
    [
        [1, 2, 3],
        [4, 5, 6],
    ],
    columns=['a', 'b', 'c']
)
uri = "postgresql://postgres:postgres@localhost/postgres"
with pg_dbapi.connect(uri) as conn:
    df.to_sql("pandas_table", conn, index=False)

# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn) 
```

Arrow 类型系统提供了更多类型，可以更接近 PostgreSQL 等数据库提供的类型。举例来说，注意以下不完整的列举，展示了不同数据库和 pandas 后端可用的类型：

| numpy/pandas | arrow | postgres | sqlite |
| --- | --- | --- | --- |
| int16/Int16 | int16 | SMALLINT | INTEGER |
| int32/Int32 | int32 | INTEGER | INTEGER |
| int64/Int64 | int64 | BIGINT | INTEGER |
| float32 | float32 | REAL | REAL |
| float64 | float64 | DOUBLE PRECISION | REAL |
| object | string | TEXT | TEXT |
| bool | `bool_` | BOOLEAN |  |
| datetime64[ns] | timestamp(us) | TIMESTAMP |  |
| datetime64[ns,tz] | timestamp(us,tz) | TIMESTAMPTZ |  |
|  | date32 | DATE |  |
|  | month_day_nano_interval | INTERVAL |  |
|  | binary | BINARY | BLOB |
|  | decimal128 | DECIMAL [[1]](#f1) |  |
|  | list | ARRAY [[1]](#f1) |  |
|  | struct |

复合类型

[[1]](#f1)

|  |
| --- |

脚注

如果你希望在 DataFrame 的生命周期中尽可能地保留数据库类型，建议用户利用 `read_sql()` 的 `dtype_backend="pyarrow"` 参数。

```py
# for round-tripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn, dtype_backend="pyarrow") 
```

这将防止你的数据被转换为传统的 pandas/NumPy 类型系统，该系统经常以使 SQL 类型不可能往返的方式转换它们。

完整的 ADBC 驱动程序列表及其开发状态，请参阅 [ADBC 驱动程序实现状态](https://arrow.apache.org/adbc/current/driver/status.html) 文档。

### 根据一个或多个条件创建 pandas Series

`Series.case_when()` 函数已添加，用于基于一个或多个条件创建 Series 对象。([GH 39154](https://github.com/pandas-dev/pandas/issues/39154))

```py
In [1]: import pandas as pd

In [2]: df = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6]))

In [3]: default=pd.Series('default', index=df.index)

In [4]: default.case_when(
 ...:     caselist=[
 ...:         (df.a == 1, 'first'),                              # condition, replacement
 ...:         (df.a.gt(1) & df.b.eq(5), 'second'),  # condition, replacement
 ...:     ],
 ...: )
 ...: 
Out[4]: 
0      first
1     second
2    default
dtype: object 
```

### `to_numpy` 用于 NumPy 的可空类型和 Arrow 类型，转换为适当的 NumPy dtype

`to_numpy` 用于 NumPy 的可空类型和 Arrow 类型将转换为适当的 NumPy dtype，而不再是 `object` dtype 用于可空和 PyArrow 支持的扩展 dtype。

*旧行为：*

```py
In [1]: ser = pd.Series([1, 2, 3], dtype="Int64")
In [2]: ser.to_numpy()
Out[2]: array([1, 2, 3], dtype=object) 
```

*新行为：*

```py
In [5]: ser = pd.Series([1, 2, 3], dtype="Int64")

In [6]: ser.to_numpy()
Out[6]: array([1, 2, 3])

In [7]: ser = pd.Series([1, 2, 3], dtype="timestamp[ns][pyarrow]")

In [8]: ser.to_numpy()
Out[8]: 
array(['1970-01-01T00:00:00.000000001', '1970-01-01T00:00:00.000000002',
 '1970-01-01T00:00:00.000000003'], dtype='datetime64[ns]') 
```

默认的 NumPy dtype（无任何参数）确定如下：

+   float 类型的数据将被转换为 NumPy 的浮点数。

+   integer 类型的数据（不包含缺失值）将被转换为 NumPy 的整数类型。

+   integer 类型的数据（包含缺失值）将被转换为 NumPy 的 float 类型，`NaN` 用作缺失值指示符。

+   boolean 类型的数据（不包含缺失值）将被转换为 NumPy 的 bool 类型。

+   boolean 类型的数据（包含缺失值）将保持 object 类型。

+   datetime 和 timedelta 类型将被转换为 Numpy 的 datetime64 和 timedelta64 类型，分别使用 `NaT` 作为缺失值指示符。

### Series.struct 访问器用于 PyArrow 结构化数据

`Series.struct` 访问器提供了用于处理具有 `struct[pyarrow]` 数据类型的 Series 的属性和方法。例如，`Series.struct.explode()` 将 PyArrow 结构化数据转换为 pandas DataFrame。([GH 54938](https://github.com/pandas-dev/pandas/issues/54938))

```py
In [9]: import pyarrow as pa

In [10]: series = pd.Series(
 ....:    [
 ....:        {"project": "pandas", "version": "2.2.0"},
 ....:        {"project": "numpy", "version": "1.25.2"},
 ....:        {"project": "pyarrow", "version": "13.0.0"},
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.struct([
 ....:            ("project", pa.string()),
 ....:            ("version", pa.string()),
 ....:        ])
 ....:    ),
 ....: )
 ....: 

In [11]: series.struct.explode()
Out[11]: 
 project version
0   pandas   2.2.0
1    numpy  1.25.2
2  pyarrow  13.0.0 
```

使用 `Series.struct.field()` 来索引（可能是嵌套的）结构字段。

```py
In [12]: series.struct.field("project")
Out[12]: 
0     pandas
1      numpy
2    pyarrow
Name: project, dtype: string[pyarrow] 
```

### 用于 PyArrow 列表数据的 Series.list 访问器

`Series.list` 访问器提供了用于处理具有 `list[pyarrow]` 数据类型 Series 的属性和方法。例如，`Series.list.__getitem__()` 允许在 Series 中索引 pyarrow 列表。 ([GH 55323](https://github.com/pandas-dev/pandas/issues/55323))

```py
In [13]: import pyarrow as pa

In [14]: series = pd.Series(
 ....:    [
 ....:        [1, 2, 3],
 ....:        [4, 5],
 ....:        [6],
 ....:    ],
 ....:    dtype=pd.ArrowDtype(
 ....:        pa.list_(pa.int64())
 ....:    ),
 ....: )
 ....: 

In [15]: series.list[0]
Out[15]: 
0    1
1    4
2    6
dtype: int64[pyarrow] 
```

### `read_excel()` 的 Calamine 引擎

`calamine` 引擎已添加到 `read_excel()` 中。它使用 `python-calamine`，该工具提供了 Rust 库 [calamine](https://crates.io/crates/calamine) 的 Python 绑定。此引擎支持 Excel 文件（`.xlsx`、`.xlsm`、`.xls`、`.xlsb`）和 OpenDocument 电子表格（`.ods`） ([GH 50395](https://github.com/pandas-dev/pandas/issues/50395)).

这个引擎有两个优点：

1.  Calamine 往往比其他引擎更快，一些基准测试显示结果比 ‘openpyxl’ 快 5 倍，比 ‘odf’ 快 20 倍，比 ‘pyxlsb’ 快 4 倍，比 ‘xlrd’ 快 1.5 倍。但是，由于对行的惰性迭代，‘openpyxl’ 和 ‘pyxlsb’ 在从大文件中读取少量行时更快。

1.  Calamine 支持在 `.xlsb` 文件中识别日期时间，而 ‘pyxlsb’ 是 pandas 中唯一可以读取 `.xlsb` 文件的其他引擎。

```py
pd.read_excel("path_to_file.xlsb", engine="calamine") 
```

更多信息，请参阅用户指南中有关 IO 工具的 Calamine (Excel 和 ODS 文件)。

### 其他增强功能

+   将 `method` 参数设置为 `multi` 的 `to_sql()` 可与 Oracle 在后端一起使用

+   `Series.attrs` / `DataFrame.attrs` 现在使用深拷贝来传播 `attrs` ([GH 54134](https://github.com/pandas-dev/pandas/issues/54134)).

+   `get_dummies()` 现在返回扩展数据类型 `boolean` 或 `bool[pyarrow]`，与输入数据类型兼容 ([GH 56273](https://github.com/pandas-dev/pandas/issues/56273))

+   `read_csv()` 现在支持 `engine="pyarrow"` 参数的 `on_bad_lines` 参数（[GH 54480](https://github.com/pandas-dev/pandas/issues/54480)）

+   `read_sas()` 现在返回 `datetime64` dtypes，其分辨率更适合与 SAS 本地存储的内容匹配，并且避免在无法使用 `datetime64[ns]` dtypes 存储的情况下返回对象 dtype（[GH 56127](https://github.com/pandas-dev/pandas/issues/56127)）

+   `read_spss()` 现在返回一个 `DataFrame`，它将元数据存储在 `DataFrame.attrs` 中（[GH 54264](https://github.com/pandas-dev/pandas/issues/54264)）

+   `tseries.api.guess_datetime_format()` 现在是公共 API 的一部分（[GH 54727](https://github.com/pandas-dev/pandas/issues/54727)）

+   `DataFrame.apply()` 现在允许使用 numba（通过 `engine="numba"`）来 JIT 编译传递的函数，从而可能实现加速（[GH 54666](https://github.com/pandas-dev/pandas/issues/54666)）

+   `ExtensionArray._explode()` 接口方法已添加以允许扩展类型实现 `explode` 方法（[GH 54833](https://github.com/pandas-dev/pandas/issues/54833)）

+   `ExtensionArray.duplicated()` 添加以允许扩展类型实现 `duplicated` 方法（[GH 55255](https://github.com/pandas-dev/pandas/issues/55255)）

+   `Series.ffill()`、`Series.bfill()`、`DataFrame.ffill()` 和 `DataFrame.bfill()` 现在具有参数 `limit_area`；第三方 `ExtensionArray` 作者需要将此参数添加到方法 `_pad_or_backfill` 中（[GH 56492](https://github.com/pandas-dev/pandas/issues/56492)）

+   允许通过 `read_excel()` 的 `engine_kwargs` 参数传递 `read_only`、`data_only` 和 `keep_links` 参数给 openpyxl（[GH 55027](https://github.com/pandas-dev/pandas/issues/55027)）

+   为 `Series.interpolate()` 和 `DataFrame.interpolate()` 实现了 `ArrowDtype` 和掩码类型的插值（[GH 56267](https://github.com/pandas-dev/pandas/issues/56267)）

+   为 `Series.value_counts()` 实现了掩码算法（[GH 54984](https://github.com/pandas-dev/pandas/issues/54984)）

+   实现了 `Series.dt()` 方法和属性，用于带有 `pyarrow.duration` 类型的 `ArrowDtype`（[GH 52284](https://github.com/pandas-dev/pandas/issues/52284)）

+   实现了 `Series.str.extract()` 方法用于 `ArrowDtype` （[GH 56268](https://github.com/pandas-dev/pandas/issues/56268)）

+   改进了在频率不受支持的情况下（如 `"BMS"`）出现的错误消息，例如在 `DatetimeIndex.to_period()` 中（[GH 56243](https://github.com/pandas-dev/pandas/issues/56243)）

+   当使用无效偏移量（例如 `"QS"`）构建 `Period` 时，改进了错误消息的显示（[GH 55785](https://github.com/pandas-dev/pandas/issues/55785)）

+   现在 `string[pyarrow]` 和 `string[pyarrow_numpy]` 类型都利用 PyArrow 的 `large_string` 类型来避免长列的溢出问题（[GH 56259](https://github.com/pandas-dev/pandas/issues/56259)）

## 显着的错误修复

这些是可能具有显着行为更改的错误修复。

### `merge()` 和 `DataFrame.join()` 现在一致地遵循了文档中的排序行为

在 pandas 的早期版本中，`merge()` 和 `DataFrame.join()` 并不总是返回符合文档中排序行为的结果。pandas 现在在合并和连接操作中遵循了文档中的排序行为（[GH 54611](https://github.com/pandas-dev/pandas/issues/54611)，[GH 56426](https://github.com/pandas-dev/pandas/issues/56426)，[GH 56443](https://github.com/pandas-dev/pandas/issues/56443)）。

按照文档，`sort=True` 会按字典顺序对结果 `DataFrame` 中的连接键进行排序。使用 `sort=False` 时，连接键的顺序取决于连接类型（`how` 关键字）：

+   `how="left"`: 保持左侧键的顺序不变。

+   `how="right"`: 保持右侧键的顺序不变。

+   `how="inner"`: 保持左侧键的顺序不变

+   `how="outer"`: 按字典顺序对键进行排序

一个具有变更行为的例子是具有非唯一左连接键和 `sort=False` 的内部连接：

```py
In [16]: left = pd.DataFrame({"a": [1, 2, 1]})

In [17]: right = pd.DataFrame({"a": [1, 2]})

In [18]: result = pd.merge(left, right, how="inner", on="a", sort=False) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 a
0  1
1  1
2  2 
```

*新行为*

```py
In [19]: result
Out[19]: 
 a
0  1
1  2
2  1 
```### `merge()` 和 `DataFrame.join()` 在级别不同时不再重新排序

在之前的 pandas 版本中，当在具有不同级别的两个索引上进行连接时，`merge()` 和 `DataFrame.join()` 会重新排列索引级别（[GH 34133](https://github.com/pandas-dev/pandas/issues/34133)）。

```py
In [20]: left = pd.DataFrame({"left": 1}, index=pd.MultiIndex.from_tuples([("x", 1), ("x", 2)], names=["A", "B"]))

In [21]: right = pd.DataFrame({"right": 2}, index=pd.MultiIndex.from_tuples([(1, 1), (2, 2)], names=["B", "C"]))

In [22]: left
Out[22]: 
 left
A B 
x 1     1
 2     1

In [23]: right
Out[23]: 
 right
B C 
1 1      2
2 2      2

In [24]: result = left.join(right) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 left  right
B A C
1 x 1     1      2
2 x 2     1      2 
```

*新行为*

```py
In [25]: result
Out[25]: 
 left  right
A B C 
x 1 1     1      2
 2 2     1      2 
```### 增加了依赖项的最低版本

对于[可选依赖项](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最新版本。低于最低测试版本的可选依赖项可能仍然可用，但不被视为受支持。以下表格列出了其最低测试版本已增加的可选依赖项。

| 包 | 新的最低版本 |
| --- | --- |
| beautifulsoup4 | 4.11.2 |
| blosc | 1.21.3 |
| bottleneck | 1.3.6 |
| fastparquet | 2022.12.0 |
| fsspec | 2022.11.0 |
| gcsfs | 2022.11.0 |
| lxml | 4.9.2 |
| matplotlib | 3.6.3 |
| numba | 0.56.4 |
| numexpr | 2.8.4 |
| qtpy | 2.3.0 |
| openpyxl | 3.1.0 |
| psycopg2 | 2.9.6 |
| pyreadstat | 1.2.0 |
| pytables | 3.8.0 |
| pyxlsb | 1.0.10 |
| s3fs | 2022.11.0 |
| scipy | 1.10.0 |
| sqlalchemy | 2.0.0 |
| tabulate | 0.9.0 |
| xarray | 2022.12.0 |
| xlsxwriter | 3.0.5 |
| zstandard | 0.19.0 |
| pyqt5 | 5.15.8 |
| tzdata | 2022.7 |

请参阅依赖项和可选依赖项获取更多信息。### 其他 API 更改

+   可空扩展数据类型的哈希值已更改以提高哈希操作的性能（[GH 56507](https://github.com/pandas-dev/pandas/issues/56507)）。

+   `check_exact` 现在仅对 `testing.assert_frame_equal()` 和 `testing.assert_series_equal()` 中的浮点数数据类型生效。特别地，整数数据类型始终会被精确检查（[GH 55882](https://github.com/pandas-dev/pandas/issues/55882)）  ### `merge()` 和 `DataFrame.join()` 现在一致遵循文档排序行为

在之前的 pandas 版本中，`merge()` 和 `DataFrame.join()` 并不总是返回遵循文档排序行为的结果。pandas 现在在合并和连接操作中遵循文档排序行为（[GH 54611](https://github.com/pandas-dev/pandas/issues/54611), [GH 56426](https://github.com/pandas-dev/pandas/issues/56426), [GH 56443](https://github.com/pandas-dev/pandas/issues/56443))。

如文档所述，`sort=True` 会按字典顺序对结果中的连接键进行排序。当 `sort=False` 时，连接键的顺序取决于连接类型（`how` 关键字）：

+   `how="left"`: 保留左侧键的顺序

+   `how="right"`: 保留右侧键的顺序

+   `how="inner"`: 保留左侧键的顺序

+   `how="outer"`: 按字典顺序排序键

一个具有变化行为的例子是内连接与非唯一左连接键以及 `sort=False`：

```py
In [16]: left = pd.DataFrame({"a": [1, 2, 1]})

In [17]: right = pd.DataFrame({"a": [1, 2]})

In [18]: result = pd.merge(left, right, how="inner", on="a", sort=False) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 a
0  1
1  1
2  2 
```

*新行为*

```py
In [19]: result
Out[19]: 
 a
0  1
1  2
2  1 
```

### `merge()` 和 `DataFrame.join()` 在级别不同时不再重新排序

在之前的 pandas 版本中，当在具有不同级别的两个索引上进行连接时，`merge()` 和 `DataFrame.join()` 会重新排序索引级别（[GH 34133](https://github.com/pandas-dev/pandas/issues/34133)）。

```py
In [20]: left = pd.DataFrame({"left": 1}, index=pd.MultiIndex.from_tuples([("x", 1), ("x", 2)], names=["A", "B"]))

In [21]: right = pd.DataFrame({"right": 2}, index=pd.MultiIndex.from_tuples([(1, 1), (2, 2)], names=["B", "C"]))

In [22]: left
Out[22]: 
 left
A B 
x 1     1
 2     1

In [23]: right
Out[23]: 
 right
B C 
1 1      2
2 2      2

In [24]: result = left.join(right) 
```

*旧行为*

```py
In [5]: result
Out[5]:
 left  right
B A C
1 x 1     1      2
2 x 2     1      2 
```

*新行为*

```py
In [25]: result
Out[25]: 
 left  right
A B C 
x 1 1     1      2
 2 2     1      2 
```

### 增加了依赖项的最低版本要求

对于[可选依赖项](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最��版本。低于最低测试版本的可选依赖项可能仍然可用，但不被视为受支持。以下表格列出了已增加最低测试版本的可选依赖项。

| 包 | 新的最低版本 |
| --- | --- |
| beautifulsoup4 | 4.11.2 |
| blosc | 1.21.3 |
| bottleneck | 1.3.6 |
| fastparquet | 2022.12.0 |
| fsspec | 2022.11.0 |
| gcsfs | 2022.11.0 |
| lxml | 4.9.2 |
| matplotlib | 3.6.3 |
| numba | 0.56.4 |
| numexpr | 2.8.4 |
| qtpy | 2.3.0 |
| openpyxl | 3.1.0 |
| psycopg2 | 2.9.6 |
| pyreadstat | 1.2.0 |
| pytables | 3.8.0 |
| pyxlsb | 1.0.10 |
| s3fs | 2022.11.0 |
| scipy | 1.10.0 |
| sqlalchemy | 2.0.0 |
| tabulate | 0.9.0 |
| xarray | 2022.12.0 |
| xlsxwriter | 3.0.5 |
| zstandard | 0.19.0 |
| pyqt5 | 5.15.8 |
| tzdata | 2022.7 |

更多信息请参见依赖项 和 可选依赖项。

### 其他 API 更改

+   可空扩展数据类型的哈希值已更改，以提高哈希操作的性能 ([GH 56507](https://github.com/pandas-dev/pandas/issues/56507))

+   `check_exact` 现在只在 `testing.assert_frame_equal()` 和 `testing.assert_series_equal()` 中对浮点类型的数据类型生效。特别地，整数类型数据类型总是被精确检查的 ([GH 55882](https://github.com/pandas-dev/pandas/issues/55882))

## 弃用

### 链式赋值

在准备好对 pandas 3.0 中的复制 / 视图行为进行较大的即将到来的更改（写时复制 (CoW), PDEP-7）之前，我们已开始弃用 *chained assignment*。

链式赋值发生在您尝试通过两个后续的索引操作更新 pandas DataFrame 或 Series 时。根据这些操作的类型和顺序，当前可能会或可能不会工作。

典型的例子如下：

```py
df = pd.DataFrame({"foo": [1, 2, 3], "bar": [4, 5, 6]})

# first selecting rows with a mask, then assigning values to a column
# -> this has never worked and raises a SettingWithCopyWarning
df[df["bar"] > 5]["foo"] = 100

# first selecting the column, and then assigning to a subset of that column
# -> this currently works
df["foo"][df["bar"] > 5] = 100 
```

这第二个链式赋值的例子目前可以更新原始 `df`。在 pandas 3.0 中，这将不再起作用，因此我们开始弃用这个：

```py
>>> df["foo"][df["bar"] > 5] = 100
FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy 
```

您可以通过删除链式赋值的使用来修复此警告，并确保您的代码准备好用于 pandas 3.0。通常，这可以通过使用例如 `.loc` 在一步中进行赋值来完成。对于上面的例子，我们可以这样做：

```py
df.loc[df["bar"] > 5, "foo"] = 100 
```

同样的弃用也适用于以链式方式执行的 inplace 方法，例如：

```py
>>> df["foo"].fillna(0, inplace=True)
FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0\. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. 
```

当目标是更新 DataFrame `df` 中的列时，此处的替代方法是在 `df` 上调用方法，例如 `df.fillna({"foo": 0}, inplace=True)`。

请在迁移指南中查看更多细节。

### 弃用别名 `M`、`Q`、`Y` 等，采用 `ME`、`QE`、`YE` 等作为偏移量

弃用以下频率别名 ([GH 9586](https://github.com/pandas-dev/pandas/issues/9586))：

| offsets | 弃用别名 | 新别名 |
| --- | --- | --- |
| `MonthEnd` | `M` | `ME` |
| `BusinessMonthEnd` | `BM` | `BME` |
| `SemiMonthEnd` | `SM` | `SME` |
| `CustomBusinessMonthEnd` | `CBM` | `CBME` |
| `QuarterEnd` | `Q` | `QE` |
| `BQuarterEnd` | `BQ` | `BQE` |
| `YearEnd` | `Y` | `YE` |
| `BYearEnd` | `BY` | `BYE` |

例如：

*先前的行为*：

```py
In [8]: pd.date_range('2020-01-01', periods=3, freq='Q-NOV')
Out[8]:
DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'],
 dtype='datetime64[ns]', freq='Q-NOV') 
```

*未来的行为*：

```py
In [26]: pd.date_range('2020-01-01', periods=3, freq='QE-NOV')
Out[26]: DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'], dtype='datetime64[ns]', freq='QE-NOV') 
```

### 废弃的自动向下转换

废弃了对象 dtype 结果的自动向下转换，这影响了多个方法。由于行为是值相关的，它们会以难以预测的方式默默地改变 dtype。此外，pandas 正在摒弃默默的 dtype 更改（[GH 54710](https://github.com/pandas-dev/pandas/issues/54710), [GH 54261](https://github.com/pandas-dev/pandas/issues/54261))。

这些方法是：

+   `Series.replace()` 和 `DataFrame.replace()`

+   `DataFrame.fillna()`, `Series.fillna()`

+   `DataFrame.ffill()`, `Series.ffill()`

+   `DataFrame.bfill()`, `Series.bfill()`

+   `DataFrame.mask()`, `Series.mask()`

+   `DataFrame.where()`, `Series.where()`

+   `DataFrame.clip()`, `Series.clip()`

明确调用 `DataFrame.infer_objects()` 以在未来复制当前行为。

```py
result = result.infer_objects(copy=False) 
```

或使用 `astype` 明确将所有四舍五入的浮点数转换为整数。

设置以下选项以选择未来行为：

```py
In [9]: pd.set_option("future.no_silent_downcasting", True) 
```

### 其他废弃情况

+   将 `Timedelta.resolution_string()` 的返回值更改为 `h`、`min`、`s`、`ms`、`us` 和 `ns`，而不是 `H`、`T`、`S`、`L`、`U` 和 `N`，以兼容频率别名中的相应弃用情况（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   废弃 `offsets.Day.delta`、`offsets.Hour.delta`、`offsets.Minute.delta`、`offsets.Second.delta`、`offsets.Milli.delta`、`offsets.Micro.delta`、`offsets.Nano.delta`，使用 `pd.Timedelta(obj)` 替代（[GH 55498](https://github.com/pandas-dev/pandas/issues/55498)）

+   废弃 `pandas.api.types.is_interval()` 和 `pandas.api.types.is_period()`，改用 `isinstance(obj, pd.Interval)` 和 `isinstance(obj, pd.Period)` 替代（[GH 55264](https://github.com/pandas-dev/pandas/issues/55264)）

+   废弃 `read_gbq()` 和 `DataFrame.to_gbq()`。使用 `pandas_gbq.read_gbq` 和 `pandas_gbq.to_gbq` 替代 [`pandas-gbq.readthedocs.io/en/latest/api.html`](https://pandas-gbq.readthedocs.io/en/latest/api.html)（[GH 55525](https://github.com/pandas-dev/pandas/issues/55525)）

+   废弃 `DataFrameGroupBy.fillna()` 和 `SeriesGroupBy.fillna()`；使用 `DataFrameGroupBy.ffill()`、`DataFrameGroupBy.bfill()` 进行向前和向后填充，或使用 `DataFrame.fillna()` 以填充单个值（或其 Series 等效项）（[GH 55718](https://github.com/pandas-dev/pandas/issues/55718)）

+   废弃 `DateOffset.is_anchored()`，对于非 Tick 子类使用 `obj.n == 1`（对于 Tick，这总是 False）（[GH 55388](https://github.com/pandas-dev/pandas/issues/55388)）

+   废弃 `DatetimeArray.__init__()` 和 `TimedeltaArray.__init__()`，使用 `array()` 替代（[GH 55623](https://github.com/pandas-dev/pandas/issues/55623)）

+   废弃 `Index.format()`，使用 `index.astype(str)` 或 `index.map(formatter)` 替代（[GH 55413](https://github.com/pandas-dev/pandas/issues/55413)）

+   废弃 `Series.ravel()`，底层数组已经是一维的，因此不需要 ravel（[GH 52511](https://github.com/pandas-dev/pandas/issues/52511)）

+   已弃用带有`PeriodIndex`（以及`convention`关键字）的`Series.resample()`和`DataFrame.resample()`，在重新取样之前转换为`DatetimeIndex`（使用`.to_timestamp()`）（[GH 53481](https://github.com/pandas-dev/pandas/issues/53481)）。

+   已弃用`Series.view()`，改用`Series.astype()`来更改 dtype（[GH 20251](https://github.com/pandas-dev/pandas/issues/20251)）。

+   已弃用`offsets.Tick.is_anchored()`中接受`False`作为参数的功能，改用`False`（[GH 55388](https://github.com/pandas-dev/pandas/issues/55388)）。

+   已弃用`core.internals`成员`Block`、`ExtensionBlock`和`DatetimeTZBlock`，改用公共 API（[GH 55139](https://github.com/pandas-dev/pandas/issues/55139)）。

+   在`PeriodIndex`构造函数中，已弃用`year`、`month`、`quarter`、`day`、`hour`、`minute`和`second`关键字，改用`PeriodIndex.from_fields()`（[GH 55960](https://github.com/pandas-dev/pandas/issues/55960)）。

+   已弃用在`Index.view()`中接受类型作为参数的功能，改为不带任何参数的调用（[GH 55709](https://github.com/pandas-dev/pandas/issues/55709)）。

+   已弃用在`date_range()`、`timedelta_range()`、`period_range()`和`interval_range()`中接受非整数`periods`参数的功能（[GH 56036](https://github.com/pandas-dev/pandas/issues/56036)）。

+   已弃用在`DataFrame.to_clipboard()`中接受非关键字参数的功能（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）。

+   已弃用在`DataFrame.to_csv()`中除`path_or_buf`之外接受非关键字参数的功能（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）。

+   在`DataFrame.to_dict()`中不再允许非关键字参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_excel()`中不再允许非关键字参数，除了`excel_writer`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_gbq()`中不再允许非关键字参数，除了`destination_table`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_hdf()`中不再允许非关键字参数，除了`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_html()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_json()`中不再允许非关键字参数，除了`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_latex()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_markdown()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_parquet()`中不再允许非关键字参数，除了`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_pickle()`中不再允许非关键字参数，除了`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_string()`中不再允许非关键字参数，除了`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   已经不推荐在 `DataFrame.to_xml()` 中允许除 `path_or_buffer` 之外的非关键字参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   已经不推荐将 `BlockManager` 对象传递给 `DataFrame` 或将 `SingleBlockManager` 对象传递给 `Series`（[GH 52419](https://github.com/pandas-dev/pandas/issues/52419)）

+   已经不推荐在 `Index.insert()` 中使用对象类型索引，隐式执行结果的类型推断，而是显式调用 `result.infer_objects(copy=False)` 以保留旧行为（[GH 51363](https://github.com/pandas-dev/pandas/issues/51363)）

+   在 `Series.isin()` 和 `Index.isin()` 中已经不推荐将非日期时间值（主要是字符串）转换为 `datetime64`、`timedelta64` 和 `PeriodDtype` dtypes （[GH 53111](https://github.com/pandas-dev/pandas/issues/53111)）

+   在给定 pandas 输入时，`Index`、`Series` 和 `DataFrame` 构造函数中已经不推荐使用 dtype 推断，调用输入的 `.infer_objects` 来保持当前行为（[GH 56012](https://github.com/pandas-dev/pandas/issues/56012)）

+   在将 `Index` 设置为 `DataFrame` 时不推荐使用 dtype 推断，应明确转换（[GH 56102](https://github.com/pandas-dev/pandas/issues/56102)）

+   在使用 `DataFrameGroupBy.apply()` 和 `DataFrameGroupBy.resample()` 时，不推荐在计算中包含分组；传递 `include_groups=False` 来排除分组（[GH 7155](https://github.com/pandas-dev/pandas/issues/7155)）

+   已经不推荐使用长度为零的布尔索引器索引 `Index`（[GH 55820](https://github.com/pandas-dev/pandas/issues/55820)）

+   弃用了在通过长度为 1 的类似列表进行分组时，未将元组传递给 `DataFrameGroupBy.get_group` 或 `SeriesGroupBy.get_group` ([GH 25971](https://github.com/pandas-dev/pandas/issues/25971))

+   弃用了字符串 `AS`，表示 `YearBegin` 中的频率，以及字符串 `AS-DEC`, `AS-JAN` 等，表示具有不同财政年度开始的年度频率 ([GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   弃用了字符串 `A`，表示 `YearEnd` 中的频率，以及字符串 `A-DEC`, `A-JAN` 等，表示具有不同财政年度结束的年度频率 ([GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   弃用了字符串 `BAS`，表示 `BYearBegin` 中的频率，以及字符串 `BAS-DEC`, `BAS-JAN` 等，表示具有不同财政年度开始的年度频率 ([GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   弃用了字符串 `BA`，表示 `BYearEnd` 中的频率，以及字符串 `BA-DEC`, `BA-JAN` 等，表示具有不同财政年度结束的年度频率 ([GH 54275](https://github.com/pandas-dev/pandas/issues/54275))

+   弃用了字符串 `H`, `BH`, 和 `CBH`，表示 `Hour`, `BusinessHour`, `CustomBusinessHour` 中的频率 ([GH 52536](https://github.com/pandas-dev/pandas/issues/52536))

+   弃用了字符串 `H`, `S`, `U`, 和 `N`，表示 `to_timedelta()` 中的单位 ([GH 52536](https://github.com/pandas-dev/pandas/issues/52536))

+   弃用字符串 `H`, `T`, `S`, `L`, `U` 和 `N`，它们表示 `Timedelta` 中的单位（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   弃用了字符串 `T`, `S`, `L`, `U`, 和 `N`，它们表示 `Minute`, `Second`, `Milli`, `Micro`, `Nano` 中的频率 ([GH 52536](https://github.com/pandas-dev/pandas/issues/52536))

+   弃用了在 `read_csv()` 中结合解析的日期时间列以及 `keep_date_col` 关键字的支持 ([GH 55569](https://github.com/pandas-dev/pandas/issues/55569))

+   弃用了 `DataFrameGroupBy.grouper` 和 `SeriesGroupBy.grouper`；这些属性将在 pandas 的未来版本中移除 ([GH 56521](https://github.com/pandas-dev/pandas/issues/56521))

+   弃用了 `Grouping` 属性 `group_index`, `result_index`, 和 `group_arraylike`；这些将在 pandas 的未来版本中移除 ([GH 56148](https://github.com/pandas-dev/pandas/issues/56148))

+   弃用了在 `read_csv()` 和 `read_table()` 中的 `delim_whitespace` 关键字，请改用 `sep="\\s+"` ([GH 55569](https://github.com/pandas-dev/pandas/issues/55569))

+   在`to_datetime()`、`to_timedelta()`和`to_numeric()`中弃用了`errors="ignore"`选项；请显式捕获异常代替（[GH 54467](https://github.com/pandas-dev/pandas/issues/54467)）

+   在`Series`构造函数中弃用了`fastpath`关键字（[GH 20110](https://github.com/pandas-dev/pandas/issues/20110)）

+   在`Series.resample()`和`DataFrame.resample()`中弃用了`kind`关键字，请显式转换对象的`index`代替（[GH 55895](https://github.com/pandas-dev/pandas/issues/55895)）

+   在`PeriodIndex`中弃用了`ordinal`关键字，请改用`PeriodIndex.from_ordinals()`代替（[GH 55960](https://github.com/pandas-dev/pandas/issues/55960)）

+   在`TimedeltaIndex`构造中弃用了`unit`关键字，请改用`to_timedelta()`代替（[GH 55499](https://github.com/pandas-dev/pandas/issues/55499)）

+   在`read_csv()`和`read_table()`中弃用了`verbose`关键字（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   在`DataFrame.replace()`和`Series.replace()`的行为中弃用了`CategoricalDtype`；在将来的版本中，replace 将更改值，同时保留类别。要更改类别，请改用`ser.cat.rename_categories`（[GH 55147](https://github.com/pandas-dev/pandas/issues/55147)）

+   废弃了 `Series.value_counts()` 和 `Index.value_counts()` 的行为，如果 dtype 为对象类型；在未来版本中，这些将不会对生成的 `Index` 进行 dtype 推断，请执行 `result.index = result.index.infer_objects()` 以保留旧行为（[GH 56161](https://github.com/pandas-dev/pandas/issues/56161))

+   废弃了 `DataFrame.pivot_table()` 中 `observed=False` 的默认值；在未来版本中将为 `True`（[GH 56236](https://github.com/pandas-dev/pandas/issues/56236))

+   废弃了扩展测试类 `BaseNoReduceTests`、`BaseBooleanReduceTests` 和 `BaseNumericReduceTests`，请改用 `BaseReduceTests`（[GH 54663](https://github.com/pandas-dev/pandas/issues/54663))

+   废弃了选项 `mode.data_manager` 和 `ArrayManager`；在未来版本中只会提供 `BlockManager`（[GH 55043](https://github.com/pandas-dev/pandas/issues/55043))

+   废弃了先前的 `DataFrame.stack` 实现；指定 `future_stack=True` 以采用未来版本（[GH 53515](https://github.com/pandas-dev/pandas/issues/53515))

### 链式赋值

为了准备 pandas 3.0 中对副本 / 视图行为的较大更改（Copy-on-Write (CoW), PDEP-7），我们已经开始废弃*链式赋值*。

当您尝试通过两个连续的索引操作更新 pandas DataFrame 或 Series 时，会发生链式赋值。取决于这些操作的类型和顺序，目前可能有效或无效。

典型示例如下：

```py
df = pd.DataFrame({"foo": [1, 2, 3], "bar": [4, 5, 6]})

# first selecting rows with a mask, then assigning values to a column
# -> this has never worked and raises a SettingWithCopyWarning
df[df["bar"] > 5]["foo"] = 100

# first selecting the column, and then assigning to a subset of that column
# -> this currently works
df["foo"][df["bar"] > 5] = 100 
```

这是链式赋值的第二个例子，目前可以更新原始的 `df`。在 pandas 3.0 中将不再支持此功能，因此我们已经开始废弃这个功能：

```py
>>> df["foo"][df["bar"] > 5] = 100
FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
You are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.
A typical example is when you are setting values in a column of a DataFrame, like:

df["col"][row_indexer] = value

Use `df.loc[row_indexer, "col"] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy 
```

您可以通过删除链式赋值的用法来消除此警告，并确保您的代码已准备好用于 pandas 3.0。通常，可以通过一步完成赋值来实现这一点，例如使用 `.loc`。对于上面的示例，我们可以这样做：

```py
df.loc[df["bar"] > 5, "foo"] = 100 
```

对于以链式方式执行的 inplace 方法，也适用相同的废弃策略，例如：

```py
>>> df["foo"].fillna(0, inplace=True)
FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.
The behavior will change in pandas 3.0\. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.

For example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object. 
```

当目标是更新 DataFrame `df` 中的列时，这里的替代方法是在 `df` 本身上调用方法，例如 `df.fillna({"foo": 0}, inplace=True)`。

在迁移指南中查看更多细节。

### 废弃了 `M`、`Q`、`Y` 等别名，推荐使用 `ME`、`QE`、`YE` 等偏移量

弃用了以下频率别名 ([GH 9586](https://github.com/pandas-dev/pandas/issues/9586))：

| 偏移量 | 弃用的别名 | 新的别名 |
| --- | --- | --- |
| `MonthEnd` | `M` | `ME` |
| `BusinessMonthEnd` | `BM` | `BME` |
| `SemiMonthEnd` | `SM` | `SME` |
| `CustomBusinessMonthEnd` | `CBM` | `CBME` |
| `QuarterEnd` | `Q` | `QE` |
| `BQuarterEnd` | `BQ` | `BQE` |
| `YearEnd` | `Y` | `YE` |
| `BYearEnd` | `BY` | `BYE` |

例如：

*先前行为*：

```py
In [8]: pd.date_range('2020-01-01', periods=3, freq='Q-NOV')
Out[8]:
DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'],
 dtype='datetime64[ns]', freq='Q-NOV') 
```

*未来行为*：

```py
In [26]: pd.date_range('2020-01-01', periods=3, freq='QE-NOV')
Out[26]: DatetimeIndex(['2020-02-29', '2020-05-31', '2020-08-31'], dtype='datetime64[ns]', freq='QE-NOV') 
```

### 弃用了自动转换

弃用了一些方法中自动将对象 dtype 转换的功能。由于这些方法在行为上依赖于数值，因此会在难以预测的方式下悄然改变 dtype。另外，pandas 正在摆脱默默改变 dtype 的做法 ([GH 54710](https://github.com/pandas-dev/pandas/issues/54710), [GH 54261](https://github.com/pandas-dev/pandas/issues/54261))。

这些方法包括：

+   `Series.replace()` 和 `DataFrame.replace()`

+   `DataFrame.fillna()`, `Series.fillna()`

+   `DataFrame.ffill()`, `Series.ffill()`

+   `DataFrame.bfill()`, `Series.bfill()`

+   `DataFrame.mask()`, `Series.mask()`

+   `DataFrame.where()`, `Series.where()`

+   `DataFrame.clip()`, `Series.clip()`

明确调用 `DataFrame.infer_objects()` 以在未来复制当前的行为。

```py
result = result.infer_objects(copy=False) 
```

或者使用 `astype` 明确地将所有四舍五入的浮点数转换为整数。

设置以下选项以选择未来行为：

```py
In [9]: pd.set_option("future.no_silent_downcasting", True) 
```

### 其他弃用项

+   将 `Timedelta.resolution_string()` 的返回值改为 `h`、`min`、`s`、`ms`、`us` 和 `ns`，而不是 `H`、`T`、`S`、`L`、`U` 和 `N`，以与频率别名中相应的弃用进行兼容（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   弃用了 `offsets.Day.delta`、`offsets.Hour.delta`、`offsets.Minute.delta`、`offsets.Second.delta`、`offsets.Milli.delta`、`offsets.Micro.delta`、`offsets.Nano.delta`，请改用 `pd.Timedelta(obj)`（[GH 55498](https://github.com/pandas-dev/pandas/issues/55498)）

+   弃用了 `pandas.api.types.is_interval()` 和 `pandas.api.types.is_period()`，请改用 `isinstance(obj, pd.Interval)` 和 `isinstance(obj, pd.Period)`（[GH 55264](https://github.com/pandas-dev/pandas/issues/55264)）

+   弃用了 `read_gbq()` 和 `DataFrame.to_gbq()`。请使用 `pandas_gbq.read_gbq` 和 `pandas_gbq.to_gbq`（[`pandas-gbq.readthedocs.io/en/latest/api.html`](https://pandas-gbq.readthedocs.io/en/latest/api.html)）（[GH 55525](https://github.com/pandas-dev/pandas/issues/55525)）

+   弃用了 `DataFrameGroupBy.fillna()` 和 `SeriesGroupBy.fillna()`；请使用 `DataFrameGroupBy.ffill()`、`DataFrameGroupBy.bfill()` 进行向前和向后填充，或者使用 `DataFrame.fillna()` 来填充单个值（或其 Series 等效）（[GH 55718](https://github.com/pandas-dev/pandas/issues/55718)）

+   弃用了 `DateOffset.is_anchored()`，对于非 Tick 子类，请使用 `obj.n == 1`（对于 Tick 类，这总是 False）（[GH 55388](https://github.com/pandas-dev/pandas/issues/55388)）

+   弃用了 `DatetimeArray.__init__()` 和 `TimedeltaArray.__init__()`，请改用 `array()`（[GH 55623](https://github.com/pandas-dev/pandas/issues/55623)）

+   弃用了 `Index.format()`，请改用 `index.astype(str)` 或 `index.map(formatter)`（[GH 55413](https://github.com/pandas-dev/pandas/issues/55413)）

+   废弃了`Series.ravel()`，底层数组已经是一维的，因此不需要 ravel ([GH 52511](https://github.com/pandas-dev/pandas/issues/52511))

+   废弃了`Series.resample()`和`DataFrame.resample()`与`PeriodIndex`（以及‘convention’关键字），在重新采样之前转换为`DatetimeIndex`（使用`.to_timestamp()`） ([GH 53481](https://github.com/pandas-dev/pandas/issues/53481))

+   废弃了`Series.view()`，请改用`Series.astype()`来改变 dtype ([GH 20251](https://github.com/pandas-dev/pandas/issues/20251))

+   废弃了`offsets.Tick.is_anchored()`中允许的非整数`periods`参数，改用`False` ([GH 55388](https://github.com/pandas-dev/pandas/issues/55388))

+   废弃了`core.internals`成员`Block`、`ExtensionBlock`和`DatetimeTZBlock`，请改用公共 API ([GH 55139](https://github.com/pandas-dev/pandas/issues/55139))

+   废弃了`PeriodIndex`构造函数中的`year`、`month`、`quarter`、`day`、`hour`、`minute`和`second`关键字，改用`PeriodIndex.from_fields()` ([GH 55960](https://github.com/pandas-dev/pandas/issues/55960))

+   在`Index.view()`中不再接受类型作为参数，而是不带任何参数调用 ([GH 55709](https://github.com/pandas-dev/pandas/issues/55709))

+   在`date_range()`、`timedelta_range()`、`period_range()`和`interval_range()`中不再允许非整数`periods`参数 ([GH 56036](https://github.com/pandas-dev/pandas/issues/56036))

+   在`DataFrame.to_clipboard()`中不再允许非关键字参数 ([GH 54229](https://github.com/pandas-dev/pandas/issues/54229))

+   在`DataFrame.to_csv()`中不再允许非关键字参数，除非是`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_dict()`中不再允许非关键字参数（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_excel()`中不再允许非关键字参数，除非是`excel_writer`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_gbq()`中不再允许非关键字参数，除非是`destination_table`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_hdf()`中不再允许非关键字参数，除非是`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_html()`中不再允许非关键字参数，除非是`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_json()`中不再允许非关键字参数，除非是`path_or_buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_latex()`中不再允许非关键字参数，除非是`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_markdown()`中不再允许非关键字参数，除非是`buf`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_parquet()`中不再允许非关键字参数，除非是`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在`DataFrame.to_pickle()`中不再允许非关键字参数，除非是`path`（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在 `DataFrame.to_string()` 中已弃用非关键字参数，除了 `buf` 外（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在 `DataFrame.to_xml()` 中已弃用非关键字参数，除了 `path_or_buffer` 外（[GH 54229](https://github.com/pandas-dev/pandas/issues/54229)）

+   在 `DataFrame` 中已弃用传递 `BlockManager` 对象或在 `Series` 中已弃用传递 `SingleBlockManager` 对象（[GH 52419](https://github.com/pandas-dev/pandas/issues/52419)）

+   在使用 `Index.insert()` 与对象 dtype 索引时已弃用行为，会对结果进行隐式类型推断，应显式调用 `result.infer_objects(copy=False)` 来保留旧行为（[GH 51363](https://github.com/pandas-dev/pandas/issues/51363)）

+   在 `Series.isin()` 和 `Index.isin()` 中已弃用对非日期时间类型值（主要是字符串）进行转换，使用 `datetime64`、`timedelta64` 和 `PeriodDtype` 类型（[GH 53111](https://github.com/pandas-dev/pandas/issues/53111)）

+   在给定 pandas 输入时，在 `Index`、`Series` 和 `DataFrame` 构造函数中已弃用 dtype 推断，应在输入上调用 `.infer_objects` 以保持当前行为（[GH 56012](https://github.com/pandas-dev/pandas/issues/56012)）

+   在将 `Index` 设置为 `DataFrame` 时，已弃用 dtype 推断，应显式进行转换（[GH 56102](https://github.com/pandas-dev/pandas/issues/56102)）

+   在使用 `DataFrameGroupBy.apply()` 和 `DataFrameGroupBy.resample()` 进行计算时，已弃用包含分组；应传递 `include_groups=False` 来排除分组（[GH 7155](https://github.com/pandas-dev/pandas/issues/7155)）

+   使用长度为零的布尔索引器对 `Index` 进行索引已弃用（[GH 55820](https://github.com/pandas-dev/pandas/issues/55820)）

+   在将长度为 1 的类列表分组时，弃用不将元组传递给 `DataFrameGroupBy.get_group` 或 `SeriesGroupBy.get_group`（[GH 25971](https://github.com/pandas-dev/pandas/issues/25971)）

+   字符串 `AS` 表示 `YearBegin` 中的频率，字符串 `AS-DEC`、`AS-JAN` 等表示具有不同财政年度开始的年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   字符串 `A` 表示 `YearEnd` 中的频率，字符串 `A-DEC`、`A-JAN` 等表示具有不同财政年度结束的年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   字符串 `BAS` 表示 `BYearBegin` 中的频率，字符串 `BAS-DEC`、`BAS-JAN` 等表示具有不同财政年度开始的年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   字符串 `BA` 表示 `BYearEnd` 中的频率，字符串 `BA-DEC`、`BA-JAN` 等表示具有不同财政年度结束的年度频率（[GH 54275](https://github.com/pandas-dev/pandas/issues/54275)）

+   字符串 `H`、`BH` 和 `CBH` 表示 `Hour`、`BusinessHour`、`CustomBusinessHour` 中的频率（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   字符串 `H`、`S`、`U` 和 `N` 表示 `to_timedelta()` 中的单位（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   字符串 `H`、`T`、`S`、`L`、`U` 和 `N` 表示 `Timedelta` 中的单位（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   字符串 `T`、`S`、`L`、`U` 和 `N` 表示 `Minute`、`Second`、`Milli`、`Micro`、`Nano` 中的频率（[GH 52536](https://github.com/pandas-dev/pandas/issues/52536)）

+   在 `read_csv()` 中弃用对解析的日期时间列的组合支持，同时使用 `keep_date_col` 关键字（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   弃用 `DataFrameGroupBy.grouper` 和 `SeriesGroupBy.grouper`；这些属性将在未来的 pandas 版本中被移除（[GH 56521](https://github.com/pandas-dev/pandas/issues/56521)）

+   弃用 `Grouping` 属性 `group_index`、`result_index` 和 `group_arraylike`；这些属性将在未来的 pandas 版本中被移除（[GH 56148](https://github.com/pandas-dev/pandas/issues/56148)）

+   废弃了 `read_csv()` 和 `read_table()` 中的 `delim_whitespace` 关键字，请使用 `sep="\\s+"` 替代（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   废弃了 `to_datetime()`、`to_timedelta()` 和 `to_numeric()` 中的 `errors="ignore"` 选项，请显式捕获异常（[GH 54467](https://github.com/pandas-dev/pandas/issues/54467)）

+   废弃了 `Series` 构造函数中的 `fastpath` 关键字（[GH 20110](https://github.com/pandas-dev/pandas/issues/20110)）

+   废弃了 `Series.resample()` 和 `DataFrame.resample()` 中的 `kind` 关键字，请显式转换对象的 `index`（[GH 55895](https://github.com/pandas-dev/pandas/issues/55895)）

+   废弃了 `PeriodIndex` 中的 `ordinal` 关键字，请使用 `PeriodIndex.from_ordinals()` 替代（[GH 55960](https://github.com/pandas-dev/pandas/issues/55960)）

+   废弃了 `TimedeltaIndex` 构造函数中的 `unit` 关键字，请使用 `to_timedelta()` 替代（[GH 55499](https://github.com/pandas-dev/pandas/issues/55499)）

+   废弃了 `read_csv()` 和 `read_table()` 中的 `verbose` 关键字（[GH 55569](https://github.com/pandas-dev/pandas/issues/55569)）

+   废弃了 `DataFrame.replace()` 和 `Series.replace()` 中与 `CategoricalDtype` 相关的行为；在将来的版本中，replace 将更改值，同时保留类别。要更改类别，请改用 `ser.cat.rename_categories`（[GH 55147](https://github.com/pandas-dev/pandas/issues/55147)）

+   废弃了 `Series.value_counts()` 和 `Index.value_counts()` 的行为，当对象类型为 object 时；在将来的版本中，这些操作不会对结果的 `Index` 进行数据类型推断，使用 `result.index = result.index.infer_objects()` 以保留旧行为 ([GH 56161](https://github.com/pandas-dev/pandas/issues/56161))

+   废弃了 `DataFrame.pivot_table()` 中 `observed=False` 的默认设置；在未来版本中将为 `True` ([GH 56236](https://github.com/pandas-dev/pandas/issues/56236))

+   废弃了扩展测试类 `BaseNoReduceTests`、`BaseBooleanReduceTests` 和 `BaseNumericReduceTests`，请改用 `BaseReduceTests` ([GH 54663](https://github.com/pandas-dev/pandas/issues/54663))

+   废弃了选项 `mode.data_manager` 和 `ArrayManager`；未来版本中只会提供 `BlockManager` ([GH 55043](https://github.com/pandas-dev/pandas/issues/55043))

+   废弃了以前的 `DataFrame.stack` 实现；指定 `future_stack=True` 以采用未来版本 ([GH 53515](https://github.com/pandas-dev/pandas/issues/53515))

## 性能改进

+   `testing.assert_frame_equal()` 和 `testing.assert_series_equal()` 的性能提升（[GH 55949](https://github.com/pandas-dev/pandas/issues/55949), [GH 55971](https://github.com/pandas-dev/pandas/issues/55971))

+   `concat()` 在 `axis=1` 和具有非对齐索引的对象上的性能提升 ([GH 55084](https://github.com/pandas-dev/pandas/issues/55084))

+   `get_dummies()` 的性能改进 ([GH 56089](https://github.com/pandas-dev/pandas/issues/56089))

+   在按升序排序键进行连接时 `merge()` 和 `merge_ordered()` 的性能改进 ([GH 56115](https://github.com/pandas-dev/pandas/issues/56115))

+   当 `by` 不为 `None` 时，`merge_asof()` 的性能提升（[GH 55580](https://github.com/pandas-dev/pandas/issues/55580), [GH 55678](https://github.com/pandas-dev/pandas/issues/55678)）

+   对于具有许多变量的文件，`read_stata()` 的性能提升（[GH 55515](https://github.com/pandas-dev/pandas/issues/55515)）

+   在聚合 pyarrow 时间戳和持续时间数据类型时，`DataFrame.groupby()` 的性能提升（[GH 55031](https://github.com/pandas-dev/pandas/issues/55031)）

+   在无序分类索引上进行连接时，`DataFrame.join()` 的性能提升（[GH 56345](https://github.com/pandas-dev/pandas/issues/56345)）

+   在使用 `DataFrame.loc()` 和 `Series.loc()` 对 `MultiIndex` 进行索引时的性能提升（[GH 56062](https://github.com/pandas-dev/pandas/issues/56062)）

+   当由 `MultiIndex` 索引时，`DataFrame.sort_index()` 和 `Series.sort_index()` 的性能提升（[GH 54835](https://github.com/pandas-dev/pandas/issues/54835)）

+   在将 DataFrame 转换为字典时的 `DataFrame.to_dict()` 性能提升（[GH 50990](https://github.com/pandas-dev/pandas/issues/50990)）

+   `Index.difference()` 的性能提升（[GH 55108](https://github.com/pandas-dev/pandas/issues/55108)）

+   当索引已排序时，`Index.sort_values()` 的性能提升（[GH 56128](https://github.com/pandas-dev/pandas/issues/56128)）

+   当 `method` 不为 `None` 时，`MultiIndex.get_indexer()` 的性能提升（[GH 55839](https://github.com/pandas-dev/pandas/issues/55839)）

+   针对 pyarrow 数据类型的`Series.duplicated()` 的性能改进（[GH 55255](https://github.com/pandas-dev/pandas/issues/55255)）

+   当 dtype 为`"string[pyarrow]"`或`"string[pyarrow_numpy]"`时，`Series.str.get_dummies()` 中的性能改进（[GH 56110](https://github.com/pandas-dev/pandas/issues/56110)）

+   `Series.str()` 方法中的性能改进（[GH 55736](https://github.com/pandas-dev/pandas/issues/55736)）

+   面向掩码数据类型的`Series.value_counts()` 和 `Series.mode()` 的性能改进（[GH 54984](https://github.com/pandas-dev/pandas/issues/54984)、[GH 55340](https://github.com/pandas-dev/pandas/issues/55340)）

+   `DataFrameGroupBy.nunique()` 和 `SeriesGroupBy.nunique()` 中的性能改进（[GH 55972](https://github.com/pandas-dev/pandas/issues/55972)）

+   `SeriesGroupBy.idxmax()`、`SeriesGroupBy.idxmin()`、`DataFrameGroupBy.idxmax()`、`DataFrameGroupBy.idxmin()` 中的性能改进（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）

+   对可空扩展数组进行哈希时的性能改进（[GH 56507](https://github.com/pandas-dev/pandas/issues/56507)）

+   在非唯一索引中进行索引时的性能改进（[GH 55816](https://github.com/pandas-dev/pandas/issues/55816)）

+   使用超过 4 个键进行索引时的性能改进（[GH 54550](https://github.com/pandas-dev/pandas/issues/54550)）

+   将时间本地化到 UTC 时的性能改进（[GH 55241](https://github.com/pandas-dev/pandas/issues/55241)）

## Bug 修复

### 分类

+   包含重叠的`Interval`值的类别数据引发`InvalidIndexError`的`Categorical.isin()`存在 Bug（[GH 34974](https://github.com/pandas-dev/pandas/issues/34974)）。

+   对于混合类型的无序分类数据，`CategoricalDtype.__eq__()`返回`False`存在 Bug（[GH 55468](https://github.com/pandas-dev/pandas/issues/55468)）。

+   当使用`pa.DictionaryArray`作为类别时，将`pa.dictionary`转换为`CategoricalDtype`时存在 Bug（[GH 56672](https://github.com/pandas-dev/pandas/issues/56672)）。

### 日期时间类

+   当同时传递一个`tz`和`dayfirst`或`yearfirst`时，`DatetimeIndex`的构造存在 Bug，忽略了 dayfirst/yearfirst（[GH 55813](https://github.com/pandas-dev/pandas/issues/55813)）。

+   当传递一个对象数据类型的浮点数 ndarray 和一个`tz`时，`DatetimeIndex`中的错误本地化结果（[GH 55780](https://github.com/pandas-dev/pandas/issues/55780)）存在 Bug。

+   当比较值全部为`NaT`的`DatetimeTZDtype` dtype 和比较值全部为`NaT`的情况下，`Series.isin()`中存在 Bug，即使系列包含`NaT`条目，也会错误地返回全部为`False`（[GH 56427](https://github.com/pandas-dev/pandas/issues/56427)）。

+   当将所有 NA DataFrame 与具有`DatetimeTZDtype` dtype DataFrame 连接时，`concat()`引发`AttributeError`的 Bug（[GH 52093](https://github.com/pandas-dev/pandas/issues/52093)）。

+   当比较分辨率时，`testing.assert_extension_array_equal()`可能使用错误的单位存在 Bug（[GH 55730](https://github.com/pandas-dev/pandas/issues/55730)）。

+   当传递一个混合字符串和数值类型列表时，`to_datetime()`和`DatetimeIndex`存在 Bug，会错误地引发异常（[GH 55780](https://github.com/pandas-dev/pandas/issues/55780)）。

+   `to_datetime()`和`DatetimeIndex`中的错误，传递混合类型对象，其中包含混合时区或混合时区感知度时未能引发`ValueError`（[GH 55693](https://github.com/pandas-dev/pandas/issues/55693))

+   `Tick.delta()`中的错误，非常大的刻度引发`OverflowError`而不是`OutOfBoundsTimedelta`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   `DatetimeIndex.shift()`中的错误，具有非纳秒分辨率时错误地返回纳秒分辨率（[GH 56117](https://github.com/pandas-dev/pandas/issues/56117))

+   `DatetimeIndex.union()`中的错误，对于具有相同时区但不同单位的 tz-aware 索引返回对象 dtype（[GH 55238](https://github.com/pandas-dev/pandas/issues/55238))

+   `Index.is_monotonic_increasing()`和`Index.is_monotonic_decreasing()`中的错误，始终将`Index.is_unique()`缓存为`True`，当索引中的第一个值为`NaT`时（[GH 55755](https://github.com/pandas-dev/pandas/issues/55755))

+   `Index.view()`中的错误，将非支持的分辨率转换为 datetime64 dtype 时错误地引发异常（[GH 55710](https://github.com/pandas-dev/pandas/issues/55710))

+   `Series.dt.round()`中的错误，具有非纳秒分辨率和`NaT`条目时错误地引发`OverflowError`（[GH 56158](https://github.com/pandas-dev/pandas/issues/56158))

+   `Series.fillna()`中的错误，具有非纳秒分辨率 dtype 和更高分辨率向量值时返回不正确（内部损坏）的结果（[GH 56410](https://github.com/pandas-dev/pandas/issues/56410))

+   `Timestamp.unit()`中的错误，从 ISO8601 格式字符串中错误地推断出分钟或小时分辨率和时区偏移（[GH 56208](https://github.com/pandas-dev/pandas/issues/56208))

+   `.astype`中的错误，从更高分辨率的`datetime64` dtype 转换为更低分辨率的`datetime64` dtype（例如`datetime64[us]->datetime64[ms]`）在接近较低实现边界的值时静默溢出（[GH 55979](https://github.com/pandas-dev/pandas/issues/55979))

+   在将 `Week` 偏移加减至具有非纳秒分辨率的 `datetime64` `Series`、`Index` 或 `DataFrame` 列时返回不正确结果的 Bug（[GH 55583](https://github.com/pandas-dev/pandas/issues/55583)）

+   在将 `BusinessDay` 偏移与 `offset` 属性加减至非纳秒分辨率的 `Index`、`Series` 或 `DataFrame` 列时给出不正确结果的 Bug（[GH 55608](https://github.com/pandas-dev/pandas/issues/55608)）

+   在将带有微秒分量的 `DateOffset` 对象加减至具有非纳秒分辨率的 `datetime64` `Index`、`Series` 或 `DataFrame` 列时引发 Bug（[GH 55595](https://github.com/pandas-dev/pandas/issues/55595)）

+   在对超大 `Tick` 对象与 `Timestamp` 或 `Timedelta` 对象进行加减时引发 `OverflowError` 而非 `OutOfBoundsTimedelta` 的 Bug（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503)）

+   在使用非纳秒分辨率的 `DatetimeTZDtype` 和会导致越界的输入创建 `Index`、`Series` 或 `DataFrame` 时不正确地引发 `OutOfBoundsDatetime` 的 Bug（[GH 54620](https://github.com/pandas-dev/pandas/issues/54620)）

+   用混合数字输入创建具有非纳秒 `datetime64`（或 `DatetimeTZDtype`）的 `Index`、`Series` 或 `DataFrame` 时的错误，将这些数字视为纳秒而不是 dtype 单位的倍数（这将发生在非混合数字输入时）（[GH 56004](https://github.com/pandas-dev/pandas/issues/56004))

+   创建具有非纳秒 `datetime64` dtype 和对于 `datetime64[ns]` 超出边界的输入的 `Index`、`Series` 或 `DataFrame` 时的错误，不正确地引发 `OutOfBoundsDatetime`（[GH 55756](https://github.com/pandas-dev/pandas/issues/55756))

+   用非 ISO8601 格式解析带有纳秒分辨率的日期时间字符串时的错误，会不正确地截断次微秒组件（[GH 56051](https://github.com/pandas-dev/pandas/issues/56051))

+   用次秒分辨率和尾随零的日期时间字符串解析时的错误，不正确地推断为秒或毫秒分辨率（[GH 55737](https://github.com/pandas-dev/pandas/issues/55737))

+   具有浮点 dtype 参数的 `to_datetime()` 结果的错误，`unit` 不匹配 `Timestamp` 的逐点结果（[GH 56037](https://github.com/pandas-dev/pandas/issues/56037))

+   修复了当 `concat()` 连接具有不同分辨率的 `datetime64` 列时会引发错误的回归（[GH 53641](https://github.com/pandas-dev/pandas/issues/53641))

### 时间增量

+   创建 `Timedelta` 时的错误，应该引发 `OverflowError` 而不是 `OutOfBoundsTimedelta`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   渲染（`__repr__`）具有非纳秒分辨率 24 小时的时间增量值的 `TimedeltaIndex` 和 `Series` 时的错误，未能使用纳秒情况下使用的紧凑表示形式（[GH 55405](https://github.com/pandas-dev/pandas/issues/55405))

### 时区

+   `AbstractHolidayCalendar` 中时区数据未在计算节假日时传播的错误（[GH 54580](https://github.com/pandas-dev/pandas/issues/54580))

+   在具有模糊值和`pytz`时区的`Timestamp`构造中失败引发`pytz.AmbiguousTimeError`的错误（[GH 55657](https://github.com/pandas-dev/pandas/issues/55657)）

+   在夏令时期间围绕 UTC+0 进行`nonexistent="shift_forward"`的`Timestamp.tz_localize()`中的错误（[GH 51501](https://github.com/pandas-dev/pandas/issues/51501)）

### 数字

+   在`engine="pyarrow"`情况下的`read_csv()`中的错误，导致大整数的四舍五入错误（[GH 52505](https://github.com/pandas-dev/pandas/issues/52505)）

+   在带有整数数据类型的`Series.__floordiv__()`和`Series.__truediv__()`中的错误，对于大除数引发异常的`ArrowDtype`（[GH 56706](https://github.com/pandas-dev/pandas/issues/56706)）

+   在带有整数数据类型的`ArrowDtype`的`Series.__floordiv__()`中的错误，对于大值引发异常（[GH 56645](https://github.com/pandas-dev/pandas/issues/56645)）

+   在未正确填充缺失值的`Series.pow()`中的错误（[GH 55512](https://github.com/pandas-dev/pandas/issues/55512)）

+   在匹配浮点数`0.0`与`False`及反之的`Series.replace()`和`DataFrame.replace()`中的错误（[GH 55398](https://github.com/pandas-dev/pandas/issues/55398)）

+   在`Series.round()`中的错误，对于可空布尔型数据类型引发异常（[GH 55936](https://github.com/pandas-dev/pandas/issues/55936)）

### 转换

+   在调用时带有`str`的`DataFrame.astype()`的错误 - 数组可能在原地改变（[GH 54654](https://github.com/pandas-dev/pandas/issues/54654)）

+   在`errors="ignore"`情况下对扩展类型无效的`DataFrame.astype()`中的错误（[GH 54654](https://github.com/pandas-dev/pandas/issues/54654)）

+   在未将所有 NA 列转换为`null[pyarrow]`的`Series.convert_dtypes()`中的错误（[GH 55346](https://github.com/pandas-dev/pandas/issues/55346)）

+   在使用全列设置器（例如 `df.loc[:, 'a'] = incompatible_value`）时，:meth:`DataFrame.loc` 存在 bug，未抛出“不兼容 dtype 警告”（参见 [PDEP6](https://pandas.pydata.org/pdeps/0006-ban-upcasting.html)）（[GH 39584](https://github.com/pandas-dev/pandas/issues/39584))

### 字符串

+   在检查没有元素的对象数组是否为字符串 dtype 时，`pandas.api.types.is_string_dtype()` 存在 bug（[GH 54661](https://github.com/pandas-dev/pandas/issues/54661))

+   当 `engine="numba"` 且列或索引具有 `StringDtype` 时，`DataFrame.apply()` 存在 bug（[GH 56189](https://github.com/pandas-dev/pandas/issues/56189))

+   当 `Index` 具有 `string[pyarrow_numpy]` dtype 时，`DataFrame.reindex()` 存在 bug 未匹配（[GH 56106](https://github.com/pandas-dev/pandas/issues/56106))

+   在 `Index.str.cat()` 中存在 bug，总是将结果转换为对象 dtype（[GH 56157](https://github.com/pandas-dev/pandas/issues/56157))

+   在使用 `pyarrow` 后端时，`ArrowDtype` 的 `Series.__mul__()` 存在 bug，其 dtype 为 `pyarrow.string` 且 `string[pyarrow]`（[GH 51970](https://github.com/pandas-dev/pandas/issues/51970))

+   当 `start < 0` 时，`Series.str.find()` 在使用 `pyarrow.string` 的 `ArrowDtype` 时存在 bug（[GH 56411](https://github.com/pandas-dev/pandas/issues/56411))

+   当 `dtype=pandas.ArrowDtype(pyarrow.string()))` 时，`Series.str.fullmatch()` 存在 bug，允许正则表达式以字面值 //$ 结尾时出现部分匹配（[GH 56652](https://github.com/pandas-dev/pandas/issues/56652))

+   当 `n < 0` 时，`Series.str.replace()` 在使用 `pyarrow.string` 的 `ArrowDtype` 时存在 bug（[GH 56404](https://github.com/pandas-dev/pandas/issues/56404))

+   `Series.str.startswith()` 和 `Series.str.endswith()` 的 bug，参数类型为 `tuple[str, ...]`，对于具有 `pyarrow.string` dtype 的 `ArrowDtype`（[GH 56579](https://github.com/pandas-dev/pandas/issues/56579))

+   `Series.str.startswith()` 和 `Series.str.endswith()` 的 bug，参数类型为 `tuple[str, ...]`，对于 `string[pyarrow]`（[GH 54942](https://github.com/pandas-dev/pandas/issues/54942))

+   比较操作的 bug，`dtype="string[pyarrow_numpy]"`，如果 dtype 不能进行比较，则会引发问题（[GH 56008](https://github.com/pandas-dev/pandas/issues/56008))

### Interval

+   `Interval` 的 bug，`__repr__` 不显示 `Timestamp` 边界的 UTC 偏移量。另外，小时、分钟和秒组件现在会显示（[GH 55015](https://github.com/pandas-dev/pandas/issues/55015))

+   `IntervalIndex.factorize()` 和 `Series.factorize()` 的 bug，对于具有 datetime64 或 timedelta64 intervals 的 `IntervalDtype`，不保留非纳秒单位（[GH 56099](https://github.com/pandas-dev/pandas/issues/56099))

+   `IntervalIndex.from_arrays()` 的 bug，当传递具有不匹配分辨率的 `datetime64` 或 `timedelta64` 数组时，构建一个无效的 `IntervalArray` 对象（[GH 55714](https://github.com/pandas-dev/pandas/issues/55714))

+   `IntervalIndex.from_tuples()` 存在 bug，如果 subtype 是可空扩展 dtype，则会引发问题（[GH 56765](https://github.com/pandas-dev/pandas/issues/56765))

+   `IntervalIndex.get_indexer()` 的 bug，datetime 或 timedelta intervals 与整数 targets 不正确匹配（[GH 47772](https://github.com/pandas-dev/pandas/issues/47772))

+   `IntervalIndex.get_indexer()`中的 Bug 在处理带有时区信息的 datetime 区间时，与一系列无时区信息的目标不正确匹配（[GH 47772](https://github.com/pandas-dev/pandas/issues/47772)）

+   在使用切片时，将值设置到具有 `IntervalIndex` 的 `Series` 上时出现的 Bug ([GH 54722](https://github.com/pandas-dev/pandas/issues/54722))

### 索引

+   当 `DataFrame` 具有 `MultiIndex` 时，`DataFrame.loc()` 在变异布尔索引器时出现的 Bug ([GH 56635](https://github.com/pandas-dev/pandas/issues/56635))

+   当将扩展数据类型的 `Series` 设置为 NumPy 数据类型时，`DataFrame.loc()` 中的 Bug ([GH 55604](https://github.com/pandas-dev/pandas/issues/55604))

+   当 `other` 为空或被视为不可比较时，`Index.difference()` 中未返回唯一值集合的 Bug ([GH 55113](https://github.com/pandas-dev/pandas/issues/55113))

+   设置 `Categorical` 值到一个带有 numpy 数据类型的 `DataFrame` 时，引发 `RecursionError` 的 Bug ([GH 52927](https://github.com/pandas-dev/pandas/issues/52927))

+   在设置单个字符串值时，创建具有缺失值的新列的 Bug 被修复（[GH 56204](https://github.com/pandas-dev/pandas/issues/56204)）

### 缺失

+   `DataFrame.update()`中的 Bug 在处理带有时区信息的 datetime64 类型时未原地更新（[GH 56227](https://github.com/pandas-dev/pandas/issues/56227)）

### 多重索引

+   当提供 `method` 且索引非单调时，`MultiIndex.get_indexer()` 中未引发 `ValueError` 的 Bug ([GH 53452](https://github.com/pandas-dev/pandas/issues/53452))

### 输入/输出

+   当指定 `skiprows` 时，`read_csv()` 中 `engine="python"` 未遵守 `chunksize` 参数的 Bug ([GH 56323](https://github.com/pandas-dev/pandas/issues/56323))

+   `read_csv()`中的错误，`engine="python"`导致在指定可调用的`skiprows`和块大小时引发`TypeError`（[GH 55677](https://github.com/pandas-dev/pandas/issues/55677))

+   `read_csv()`中的错误，`on_bad_lines="warn"`会写入`stderr`而不是引发 Python 警告；现在会产生一个`errors.ParserWarning`（[GH 54296](https://github.com/pandas-dev/pandas/issues/54296))

+   `read_csv()`中的错误，`engine="pyarrow"`时，`quotechar`被忽略（[GH 52266](https://github.com/pandas-dev/pandas/issues/52266))

+   `read_csv()`中的错误，`engine="pyarrow"`时，`usecols`在没有标题的 CSV 中无法工作（[GH 54459](https://github.com/pandas-dev/pandas/issues/54459))

+   `read_excel()`中的错误，`engine="xlrd"`（`xls`文件）在文件包含`NaN`或`Inf`时出错（[GH 54564](https://github.com/pandas-dev/pandas/issues/54564))

+   `read_json()`中的错误，如果设置了`infer_string`，则无法正确处理 dtype 转换（[GH 56195](https://github.com/pandas-dev/pandas/issues/56195))

+   `DataFrame.to_excel()`中的错误，`OdsWriter`（`ods`文件）写入布尔值/字符串值（[GH 54994](https://github.com/pandas-dev/pandas/issues/54994))

+   `DataFrame.to_hdf()`和`read_hdf()`中的错误，`datetime64`数据类型的非纳秒分辨率无法正确往返（[GH 55622](https://github.com/pandas-dev/pandas/issues/55622))

+   `DataFrame.to_stata()`中的错误引发了扩展数据类型（[GH 54671](https://github.com/pandas-dev/pandas/issues/54671))

+   `read_excel()`中的错误，`engine="odf"`（`ods`文件）当一个字符串单元格包含注释时出错（[GH 55200](https://github.com/pandas-dev/pandas/issues/55200))

+   `read_excel()`中的错误，对于没有缓存格式化单元格的 ODS 文件的浮点值出现问题（[GH 55219](https://github.com/pandas-dev/pandas/issues/55219))

+   `DataFrame.to_json()` 中的 Bug 在遇到不支持的 NumPy 类型时引发 `OverflowError` 而不是 `TypeError` ([GH 55403](https://github.com/pandas-dev/pandas/issues/55403))

### Period

+   在传递了 `data`、`ordinal` 和 `**fields` 中超过一个参数时，`PeriodIndex` 构造失败未能引发 `ValueError` 的 Bug ([GH 55961](https://github.com/pandas-dev/pandas/issues/55961))

+   `Period` 加法中的 Bug 默默地循环而不是引发 `OverflowError` ([GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   从 `PeriodDtype` 使用 `astype` 转换为 `datetime64` 或者 `DatetimeTZDtype` 时，单位为非纳秒时错误地返回纳秒单位的转换 Bug ([GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

### 绘图

+   `DataFrame.plot.box()` 中的 Bug，`vert=False` 且使用 `sharey=True` 创建的 Matplotlib `Axes` ([GH 54941](https://github.com/pandas-dev/pandas/issues/54941))

+   `DataFrame.plot.scatter()` 中的 Bug 丢弃字符串列 ([GH 56142](https://github.com/pandas-dev/pandas/issues/56142))

+   当传递 `how` 关键字时，`Series.plot()` 中重复使用 `ax` 对象时未能引发的 Bug ([GH 55953](https://github.com/pandas-dev/pandas/issues/55953))

### Groupby/resample/rolling

+   DataFrameGroupBy.idxmin()、DataFrameGroupBy.idxmax()、SeriesGroupBy.idxmin() 和 SeriesGroupBy.idxmax() 中的 Bug 在索引是包含 NA 值的 CategoricalIndex 时不会保留 Categorical 类型（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）

+   DataFrameGroupBy.transform() 和 SeriesGroupBy.transform() 中的 Bug 在 `observed=False` 且 `f="idxmin"` 或 `f="idxmax"` 时会在未观察到的类别上错误地引发异常（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）

+   DataFrameGroupBy.value_counts() 和 SeriesGroupBy.value_counts() 中的 Bug 可能导致 DataFrame 的列或 Series 的名称为整数时排序不正确（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）

+   DataFrameGroupBy.value_counts() 和 SeriesGroupBy.value_counts() 中的 Bug 在 DataFrame.groupby() 和 Series.groupby() 中不尊重 `sort=False`（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）

+   Bug in `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 当 `sort=True` 和 `normalize=True` 时，会按比例而不是频率排序（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951))

+   Bug in `DataFrame.asfreq()` 和 `Series.asfreq()` 在具有非纳秒分辨率的 `DatetimeIndex` 上错误地转换为纳秒分辨率（[GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

+   Bug in `DataFrame.ewm()` 在传递具有非纳秒 `datetime64` 或 `DatetimeTZDtype` dtype 的 `times` 时出现问题（[GH 56262](https://github.com/pandas-dev/pandas/issues/56262))

+   Bug in `DataFrame.groupby()` 和 `Series.groupby()` 在通过 `Decimal` 和 NA 值的组合进行分组时，当 `sort=True` 时会失败（[GH 54847](https://github.com/pandas-dev/pandas/issues/54847))

+   Bug in `DataFrame.groupby()` 在选择要应用函数的列子集时，对 DataFrame 子类出现问题（[GH 56761](https://github.com/pandas-dev/pandas/issues/56761))

+   Bug in `DataFrame.resample()` 不遵守 `BusinessDay` 的 `closed` 和 `label` 参数（[GH 55282](https://github.com/pandas-dev/pandas/issues/55282))

+   Bug in `DataFrame.resample()` 在对 `pyarrow.timestamp` 或 `pyarrow.duration` 类型的 `ArrowDtype` 进行重新采样时出现问题（[GH 55989](https://github.com/pandas-dev/pandas/issues/55989))

+   在`DataFrame.resample()`中存在错误，对于`BusinessDay`，bin 边界不正确（[GH 55281](https://github.com/pandas-dev/pandas/issues/55281)）

+   在`DataFrame.resample()`中存在错误，对于`MonthBegin`，bin 边界不正确（[GH 55271](https://github.com/pandas-dev/pandas/issues/55271)）

+   在`DataFrame.rolling()`和`Series.rolling()`中存在错误，在`closed='left'`和`closed='neither'`时，重复的 datetimelike 索引被视为连续而不是相等（[GH 20712](https://github.com/pandas-dev/pandas/issues/20712)）

+   在`DataFrame.rolling()`和`Series.rolling()`中存在错误，其中`index`或`on`列是`ArrowDtype`类型，其类型为`pyarrow.timestamp`（[GH 55849](https://github.com/pandas-dev/pandas/issues/55849)）

### 重塑

+   在`concat()`中存在错误，当传入`DatetimeIndex`索引时，会忽略`sort`参数（[GH 54769](https://github.com/pandas-dev/pandas/issues/54769)）

+   在`concat()`中存在错误，在`ignore_index=False`时重命名`Series`（[GH 15047](https://github.com/pandas-dev/pandas/issues/15047)）

+   在`merge_asof()`中存在错误，当`by`的类型不是`object`，`int64`或`uint64`时会引发`TypeError`（[GH 22794](https://github.com/pandas-dev/pandas/issues/22794)）

+   在`merge_asof()`中存在错误，对于字符串类型引发了错误的错误（[GH 56444](https://github.com/pandas-dev/pandas/issues/56444)）

+   当在 `ArrowDtype` 列上使用 `Timedelta` 容差时，`merge_asof()` 存在 bug（[GH 56486](https://github.com/pandas-dev/pandas/issues/56486)）

+   当将 datetime 列与 timedelta 列合并时，`merge()` 未引发异常（[GH 56455](https://github.com/pandas-dev/pandas/issues/56455)）

+   在将字符串列与数字列合并时，`merge()` 未引发异常（[GH 56441](https://github.com/pandas-dev/pandas/issues/56441)）

+   在新的字符串 dtype 中，`merge()` 未排序（[GH 56442](https://github.com/pandas-dev/pandas/issues/56442)）

+   当左侧和/或右侧为空时，`merge()` 返回的列顺序不正确（[GH 51929](https://github.com/pandas-dev/pandas/issues/51929)）

+   当 `var_name` 不是字符串时，`DataFrame.melt()` 存在 bug，会引发异常（[GH 55948](https://github.com/pandas-dev/pandas/issues/55948)）

+   `DataFrame.melt()`中存在一个 bug，它无法保留 datetime（[GH 55254](https://github.com/pandas-dev/pandas/issues/55254)）

+   当列具有数字名称时，`DataFrame.pivot_table()`中存在 bug，行边距不正确（[GH 26568](https://github.com/pandas-dev/pandas/issues/26568)）

+   当数据中存在数字列和扩展 dtype 时，`DataFrame.pivot()` 存在 bug（[GH 56528](https://github.com/pandas-dev/pandas/issues/56528)）

+   当使用 `future_stack=True` 时，`DataFrame.stack()` 存在 bug，无法保留索引中的 NA 值（[GH 56573](https://github.com/pandas-dev/pandas/issues/56573)）

### 稀疏

+   当使用与数组的填充值不同的填充值时，[`arrays.SparseArray.take()`](https://github.com/pandas-dev/pandas/issues/55181) 存在 bug

### 其他

+   `DataFrame.__dataframe__()` 不支持 pyarrow 大字符串（[GH 56702](https://github.com/pandas-dev/pandas/issues/56702)）

+   在格式化百分位数时，`DataFrame.describe()` 中的一个 bug，导致结果中的百分位数 99.999% 被四舍五入为 100% ([GH 55765](https://github.com/pandas-dev/pandas/issues/55765))

+   在处理空字符串列时，`api.interchange.from_dataframe()` 中的一个 bug，抛出 `NotImplementedError` ([GH 56703](https://github.com/pandas-dev/pandas/issues/56703))

+   在具有非纳秒单位的 `datetime64` 类型值中，`cut()` 和 `qcut()` 中的一个 bug，不正确地返回纳秒单位的区间 ([GH 56101](https://github.com/pandas-dev/pandas/issues/56101))

+   在处理时区感知日期时间与时区无关的区间时，`cut()` 不正确地允许切割的 bug ([GH 54964](https://github.com/pandas-dev/pandas/issues/54964))

+   `infer_freq()` 和 `DatetimeIndex.inferred_freq()` 中的一个 bug，涉及周频率和非纳秒分辨率（[GH 55609](https://github.com/pandas-dev/pandas/issues/55609))

+   在 `DataFrame.apply()` 中，传递 `raw=True` 会忽略传递给应用函数的 `args` 的 bug ([GH 55009](https://github.com/pandas-dev/pandas/issues/55009))

+   在创建 `DataFrame` 时，`DataFrame.from_dict()` 中的一个 bug，总是对行进行排序。([GH 55683](https://github.com/pandas-dev/pandas/issues/55683))

+   在传递 `axis="columns"` 和 `ignore_index=True` 时，`DataFrame.sort_index()` 中的一个 bug，引发 `ValueError` ([GH 56478](https://github.com/pandas-dev/pandas/issues/56478))

+   在启用 `use_inf_as_na` 选项的情况下，`DataFrame` 中渲染 `inf` 值的 bug ([GH 55483](https://github.com/pandas-dev/pandas/issues/55483))

+   当索引级别名称为 0 时，渲染带有 `MultiIndex` 的 `Series` 时出现 bug，未显示该名称 ([GH 55415](https://github.com/pandas-dev/pandas/issues/55415))

+   在将空的`DataFrame`分配给列时出现错误消息 ([GH 55956](https://github.com/pandas-dev/pandas/issues/55956))

+   当将时间类字符串转换为具有`pyarrow.time64`类型的`ArrowDtype`时出现错误 ([GH 56463](https://github.com/pandas-dev/pandas/issues/56463))

+   修复了当在`core.window.Rolling.apply`中传递 numpy ufunc 并使用`engine="numba"`时，从`numba` >= 0.58.0 出现的虚假弃用警告 ([GH 55247](https://github.com/pandas-dev/pandas/issues/55247))

### 分类

+   对包含重叠的`Interval`值的分类进行`Categorical.isin()`时引发`InvalidIndexError`错误 ([GH 34974](https://github.com/pandas-dev/pandas/issues/34974))

+   在无序分类数据中，使用`CategoricalDtype.__eq__()`返回`False`，并且类型混合时出现错误 ([GH 55468](https://github.com/pandas-dev/pandas/issues/55468))

+   当将`pa.dictionary`转换为`CategoricalDtype`时，使用`pa.DictionaryArray`作为类别时出现错误 ([GH 56672](https://github.com/pandas-dev/pandas/issues/56672))

### 日期时间类

+   在传递`tz`以及`dayfirst`或`yearfirst`时，忽略 dayfirst/yearfirst 时，在构造`DatetimeIndex`时出现错误 ([GH 55813](https://github.com/pandas-dev/pandas/issues/55813))

+   在传递对象数据类型的浮点对象 ndarray 和`tz`时，在`DatetimeIndex`中错误地本地化结果 ([GH 55780](https://github.com/pandas-dev/pandas/issues/55780))

+   在具有`DatetimeTZDtype`数据类型和所有比较值为`NaT`的情况下，`Series.isin()`中出现错误，即使系列包含`NaT`条目也会错误地返回全部`False` ([GH 56427](https://github.com/pandas-dev/pandas/issues/56427))

+   在使用`concat()`时出现`AttributeError`错误，当将所有值为 NA 的 DataFrame 与具有`DatetimeTZDtype`数据类型的 DataFrame 进行连接时（[GH 52093](https://github.com/pandas-dev/pandas/issues/52093))

+   在比较分辨率时，`testing.assert_extension_array_equal()`中出现错误，可能会使用错误的单位 ([GH 55730](https://github.com/pandas-dev/pandas/issues/55730))

+   在传递混合字符串和数值类型列表时 `to_datetime()` 和 `DatetimeIndex` 中的 Bug 不正确地引发错误 ([GH 55780](https://github.com/pandas-dev/pandas/issues/55780))

+   在传递具有混合时区或混合时区感知性的对象时 `to_datetime()` 和 `DatetimeIndex` 中的 Bug 未能引发 `ValueError` ([GH 55693](https://github.com/pandas-dev/pandas/issues/55693))

+   在非常大的刻度上使用 `Tick.delta()` 中的 Bug 引发 `OverflowError` 而不是 `OutOfBoundsTimedelta` ([GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   在非纳秒分辨率的 `DatetimeIndex.shift()` 中的 Bug 不正确地以纳秒分辨率返回 ([GH 56117](https://github.com/pandas-dev/pandas/issues/56117))

+   `DatetimeIndex.union()` 中的 Bug 在具有相同时区但不同单位的时区感知索引中返回对象 dtype ([GH 55238](https://github.com/pandas-dev/pandas/issues/55238))

+   在首个索引值为 `NaT` 时 `Index.is_monotonic_increasing()` 和 `Index.is_monotonic_decreasing()` 中的 Bug 总是将 `Index.is_unique()` 缓存为 `True` ([GH 55755](https://github.com/pandas-dev/pandas/issues/55755))

+   `Index.view()` 中的 Bug 在具有不支持的分辨率的 datetime64 dtype 中不正确地引发错误 ([GH 55710](https://github.com/pandas-dev/pandas/issues/55710))

+   在非纳秒分辨率和 `NaT` 条目的 `Series.dt.round()` 中的 Bug 不正确地引发 `OverflowError` ([GH 56158](https://github.com/pandas-dev/pandas/issues/56158))

+   `Series.fillna()` 中的 Bug 在非纳秒分辨率 dtypes 和更高分辨率向量值返回不正确（内部损坏）的结果 ([GH 56410](https://github.com/pandas-dev/pandas/issues/56410))

+   在从 ISO8601 格式字符串中错误地推断出具有分钟或小时分辨率和时区偏移的 `Timestamp.unit()` 的 Bug ([GH 56208](https://github.com/pandas-dev/pandas/issues/56208))

+   在从高分辨率`datetime64` dtype 转换为低分辨率`datetime64` dtype（例如`datetime64[us]->datetime64[ms]`）时，`.astype`中的 bug 会在接近较低实现边界的值时静默溢出（[GH 55979](https://github.com/pandas-dev/pandas/issues/55979)）

+   在将`Week`偏移量添加或减去到具有非纳秒分辨率的`datetime64` `Series`、`Index`或`DataFrame`列时，会返回不正确的结果（[GH 55583](https://github.com/pandas-dev/pandas/issues/55583)）

+   在将`BusinessDay`偏移量与具有`offset`属性的非纳秒`Index`、`Series`或`DataFrame`列进行加法或减法运算时，会产生不正确的结果（[GH 55608](https://github.com/pandas-dev/pandas/issues/55608)）

+   在将具有微秒分量的`DateOffset`对象与具有非纳秒分辨率的`datetime64` `Index`、`Series`或`DataFrame`列进行加法或减法运算时（[GH 55595](https://github.com/pandas-dev/pandas/issues/55595)）

+   在对非常大的`Tick`对象进行加法或减法运算时，与`Timestamp`或`Timedelta`对象一起，会引发`OverflowError`而不是`OutOfBoundsTimedelta`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503)）

+   在创建具有非纳秒`DatetimeTZDtype`和可能超出纳秒分辨率范围的输入的`Index`、`Series`或`DataFrame`时，会错误地引发`OutOfBoundsDatetime`（[GH 54620](https://github.com/pandas-dev/pandas/issues/54620)）

+   创建 `Index`、`Series` 或 `DataFrame` 时的错误，当输入的非纳秒 `datetime64`（或 `DatetimeTZDtype`）来自混合数字输入时，将这些数字视为纳秒的倍数而不是 dtype 单位的倍数（与非混合数字输入时的情况相反）（[GH 56004](https://github.com/pandas-dev/pandas/issues/56004)）

+   创建 `Index`、`Series` 或 `DataFrame` 时的错误，当输入的非纳秒 `datetime64` dtype 超出了 `datetime64[ns]` 的范围时错误地引发 `OutOfBoundsDatetime`（[GH 55756](https://github.com/pandas-dev/pandas/issues/55756)）

+   使用非 ISO8601 格式解析纳秒分辨率的日期时间字符串时的错误，错误地截断次微秒组件（[GH 56051](https://github.com/pandas-dev/pandas/issues/56051)）

+   解析带有次秒分辨率和尾随零的日期时间字符串的错误，错误地推断为秒或毫秒分辨率（[GH 55737](https://github.com/pandas-dev/pandas/issues/55737)）

+   `to_datetime()` 结果中的错误，使用浮点数类型参数 `unit` 与 `Timestamp` 的结果不匹配（[GH 56037](https://github.com/pandas-dev/pandas/issues/56037)）

+   修复了 `concat()` 在连接具有不同分辨率的 `datetime64` 列时引发错误的回归问题（[GH 53641](https://github.com/pandas-dev/pandas/issues/53641)）

### Timedelta

+   `Timedelta` 构造中的错误，引发 `OverflowError` 而不是 `OutOfBoundsTimedelta`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503)）

+   渲染（`__repr__`）`TimedeltaIndex` 和 `Series` 中带有非纳秒分辨率的 timedelta64 值的错误，所有值都是 24 小时的倍数，无法使用纳秒情况下使用的紧凑表示（[GH 55405](https://github.com/pandas-dev/pandas/issues/55405)）

### 时区

+   `AbstractHolidayCalendar` 中的错误，当计算节假日时未传播时区数据（[GH 54580](https://github.com/pandas-dev/pandas/issues/54580)）

+   使用模糊值和`pytz`时区构造`Timestamp`时出现错误，未引发`pytz.AmbiguousTimeError` ([GH 55657](https://github.com/pandas-dev/pandas/issues/55657))

+   在 UTC+0 期间使用`nonexistent="shift_forward`时，`Timestamp.tz_localize()`存在错误 ([GH 51501](https://github.com/pandas-dev/pandas/issues/51501))

### 数字

+   使用`engine="pyarrow"`时，`read_csv()`存在错误，导致大整数出现四舍五入错误 ([GH 52505](https://github.com/pandas-dev/pandas/issues/52505))

+   在具有整数类型的`ArrowDtype`中，对于较大的除数，`Series.__floordiv__()`和`Series.__truediv__()`存在错误 ([GH 56706](https://github.com/pandas-dev/pandas/issues/56706))

+   在具有整数类型的`ArrowDtype`中，对于较大的值，`Series.__floordiv__()`存在错误 ([GH 56645](https://github.com/pandas-dev/pandas/issues/56645))

+   在`Series.pow()`中存在错误，未正确填充缺失值 ([GH 55512](https://github.com/pandas-dev/pandas/issues/55512))

+   在`Series.replace()`和`DataFrame.replace()`中，将浮点数`0.0`与`False`相匹配，反之亦然 ([GH 55398](https://github.com/pandas-dev/pandas/issues/55398))

+   在可空布尔类型中，`Series.round()`存在错误 ([GH 55936](https://github.com/pandas-dev/pandas/issues/55936))

### 转换

+   在对未 pickle 的数组调用`DataFrame.astype()`时存在错误 - 数组可能会原地更改 ([GH 54654](https://github.com/pandas-dev/pandas/issues/54654))

+   在`errors="ignore"`情况下，`DataFrame.astype()`中没有效果，对于扩展类型 ([GH 54654](https://github.com/pandas-dev/pandas/issues/54654))

+   在`Series.convert_dtypes()`中存在错误，未将所有 NA 列转换为`null[pyarrow]` ([GH 55346](https://github.com/pandas-dev/pandas/issues/55346))

+   修复了:meth:`DataFrame.loc`在使用全列设置器（例如`df.loc[:, 'a'] = incompatible_value`）时未抛出“不兼容的 dtype 警告”的错误（参见[PDEP6](https://pandas.pydata.org/pdeps/0006-ban-upcasting.html)) ([GH 39584](https://github.com/pandas-dev/pandas/issues/39584))

### 字符串

+   修复了`pandas.api.types.is_string_dtype()`中的错误，当检查没有元素的对象数组是否为字符串 dtype 时出错 ([GH 54661](https://github.com/pandas-dev/pandas/issues/54661))

+   修复了`DataFrame.apply()`中的错误，当`engine="numba"`且列或索引具有`StringDtype`时失败 ([GH 56189](https://github.com/pandas-dev/pandas/issues/56189))

+   修复了`DataFrame.reindex()`中不匹配的`Index`的错误，该错误涉及到`string[pyarrow_numpy]`的 dtype ([GH 56106](https://github.com/pandas-dev/pandas/issues/56106))

+   修复了`Index.str.cat()`中始终将结果强制转换为对象 dtype 的错误 ([GH 56157](https://github.com/pandas-dev/pandas/issues/56157))

+   修复了`ArrowDtype`的`Series.__mul__()`中的错误，其中`pyarrow.string`的 dtype 和 pyarrow 后端的`string[pyarrow]`不匹配([GH 51970](https://github.com/pandas-dev/pandas/issues/51970))

+   修复了`Series.str.find()`中的错误，当`start < 0`时，`ArrowDtype`的`pyarrow.string`错误 ([GH 56411](https://github.com/pandas-dev/pandas/issues/56411))

+   修复了`Series.str.fullmatch()`中的错误，当`dtype=pandas.ArrowDtype(pyarrow.string()))`时，当正则表达式以文字//$结束时允许部分匹配 ([GH 56652](https://github.com/pandas-dev/pandas/issues/56652))

+   修复了`Series.str.replace()`中的错误，当`n < 0`时，`ArrowDtype`的`pyarrow.string`错误 ([GH 56404](https://github.com/pandas-dev/pandas/issues/56404))

+   修复了当参数为具有 `pyarrow.string` 数据类型的 `ArrowDtype` 的元组时，`Series.str.startswith()` 和 `Series.str.endswith()` 的错误（[GH 56579](https://github.com/pandas-dev/pandas/issues/56579)）

+   修复了当参数为 `tuple[str, ...]` 类型的元组时，`Series.str.startswith()` 和 `Series.str.endswith()` 在 `string[pyarrow]` 上的错误（[GH 54942](https://github.com/pandas-dev/pandas/issues/54942)）

+   修复了对 `dtype="string[pyarrow_numpy]"` 的比较操作中的错误，如果数据类型不能比较，则会引发异常（[GH 56008](https://github.com/pandas-dev/pandas/issues/56008)）

### 区间

+   修复了 `Interval` 的 `__repr__` 在 `Timestamp` 边界上未显示 UTC 偏移量的错误。此外，现在还将显示小时、分钟和秒组件（[GH 55015](https://github.com/pandas-dev/pandas/issues/55015)）

+   修复了具有日期时间或时间间隔的 `IntervalDtype` 的 `IntervalIndex.factorize()` 和 `Series.factorize()` 未保留非纳秒单位的错误（[GH 56099](https://github.com/pandas-dev/pandas/issues/56099)）

+   修复了在传递具有不匹配分辨率的 `datetime64` 或 `timedelta64` 数组时，`IntervalIndex.from_arrays()` 构造无效的 `IntervalArray` 对象的错误（[GH 55714](https://github.com/pandas-dev/pandas/issues/55714)）

+   修复了在子类型为可空扩展数据类型时，`IntervalIndex.from_tuples()` 引发异常的错误（[GH 56765](https://github.com/pandas-dev/pandas/issues/56765)）

+   修复了在具有日期时间或时间间隔的区间中，`IntervalIndex.get_indexer()` 在整数目标上错误地匹配的错误（[GH 47772](https://github.com/pandas-dev/pandas/issues/47772)）

+   在带有时区感知的日期时间间隔的情况下，`IntervalIndex.get_indexer()`中的 Bug，在一个时区无关的目标序列上不正确地进行匹配（[GH 47772](https://github.com/pandas-dev/pandas/issues/47772))

+   在使用切片不正确的情况下，在 `Series` 上设置值时存在 Bug，该系列具有 `IntervalIndex`（[GH 54722](https://github.com/pandas-dev/pandas/issues/54722))

### 索引

+   当 `DataFrame` 具有 `MultiIndex` 时，在 `DataFrame.loc()` 中的 Bug 改变了布尔索引器（[GH 56635](https://github.com/pandas-dev/pandas/issues/56635))

+   当将具有扩展数据类型的 `Series` 设置为 NumPy 数据类型时，`DataFrame.loc()` 中存在的 Bug（[GH 55604](https://github.com/pandas-dev/pandas/issues/55604))

+   当 `other` 为空或被视为不可比较时，`Index.difference()`中的 Bug 不返回唯一的值集合（[GH 55113](https://github.com/pandas-dev/pandas/issues/55113))

+   在使用 numpy 数据类型的情况下，将 `Categorical` 值设置到带有 `DataFrame` 中会引发 `RecursionError` 的 Bug（[GH 52927](https://github.com/pandas-dev/pandas/issues/52927))

+   在设置单个字符串值时，创建新列丢失值时存在的 Bug（[GH 56204](https://github.com/pandas-dev/pandas/issues/56204))

### 缺失

+   对于 tz-aware datetime64 数据类型，`DataFrame.update()` 中的 Bug 未原地更新（[GH 56227](https://github.com/pandas-dev/pandas/issues/56227))

### 多重索引

+   当提供了 `method` 并且索引是非单调的时，`MultiIndex.get_indexer()`中的 Bug 没有引发 `ValueError`（[GH 53452](https://github.com/pandas-dev/pandas/issues/53452))

### 输入/输出

+   `read_csv()`中存在的 Bug，当 `engine="python"` 时，如果指定了 `skiprows` 参数，则不遵守 `chunksize` 参数（[GH 56323](https://github.com/pandas-dev/pandas/issues/56323))

+   `read_csv()` 中存在 Bug，在指定可调用的 `skiprows` 和块大小时，`engine="python"` 导致 `TypeError`（[GH 55677](https://github.com/pandas-dev/pandas/issues/55677)）

+   `read_csv()` 中存在 Bug，`on_bad_lines="warn"` 将写入 `stderr` 而不是引发 Python 警告；现在会产生 `errors.ParserWarning`（[GH 54296](https://github.com/pandas-dev/pandas/issues/54296)）

+   `read_csv()` 中存在 Bug，`engine="pyarrow"` 时忽略了 `quotechar`（[GH 52266](https://github.com/pandas-dev/pandas/issues/52266)）

+   `read_csv()` 中存在 Bug，`engine="pyarrow"` 在 CSV 没有标题的情况下 `usecols` 不起作用（[GH 54459](https://github.com/pandas-dev/pandas/issues/54459)）

+   `read_excel()` 中存在 Bug，`engine="xlrd"`（`xls` 文件）在文件包含 `NaN` 或 `Inf` 时会出错（[GH 54564](https://github.com/pandas-dev/pandas/issues/54564)）

+   `read_json()` 中存在 Bug，如果设置了 `infer_string`，则无法正确处理 dtype 转换（[GH 56195](https://github.com/pandas-dev/pandas/issues/56195)）

+   `DataFrame.to_excel()` 中存在 Bug，使用 `OdsWriter`（`ods` 文件）会写入布尔值/字符串值（[GH 54994](https://github.com/pandas-dev/pandas/issues/54994)）

+   `DataFrame.to_hdf()` 和 `read_hdf()` 存在 Bug，对于具有非纳秒分辨率的 `datetime64` 类型无法正确往返转换（[GH 55622](https://github.com/pandas-dev/pandas/issues/55622)）

+   `DataFrame.to_stata()` 中存在 Bug，对于扩展数据类型引发错误（[GH 54671](https://github.com/pandas-dev/pandas/issues/54671)）

+   `read_excel()` 中存在 Bug，在 `engine="odf"`（`ods` 文件）时，如果字符串单元格包含注释，则会发生错误（[GH 55200](https://github.com/pandas-dev/pandas/issues/55200)）

+   `read_excel()` 中存在 Bug，对于没有缓存格式化单元格的 ODS 文件中的浮点值会出现错误（[GH 55219](https://github.com/pandas-dev/pandas/issues/55219)）

+   在不支持的 NumPy 类型上，`DataFrame.to_json()`会引发`OverflowError`而不是`TypeError`的错误（[GH 55403](https://github.com/pandas-dev/pandas/issues/55403))

### 时间周期

+   在传递了`data`、`ordinal`和`**fields`中的多个参数时，`PeriodIndex`构造中的错误未能引发`ValueError`（[GH 55961](https://github.com/pandas-dev/pandas/issues/55961))

+   在进行`Period`加法时，默默地进行环绕而不是引发`OverflowError`（[GH 55503](https://github.com/pandas-dev/pandas/issues/55503))

+   在从`PeriodDtype`进行`astype`转换为`datetime64`或`DatetimeTZDtype`时，使用非纳秒单位错误地返回了纳秒单位（[GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

### 绘图

+   在使用`vert=False`和使用`sharey=True`创建的 Matplotlib `Axes`时，`DataFrame.plot.box()`存在错误（[GH 54941](https://github.com/pandas-dev/pandas/issues/54941))

+   在舍弃字符串列时，`DataFrame.plot.scatter()`存在错误（[GH 56142](https://github.com/pandas-dev/pandas/issues/56142))

+   在重用`ax`对象时，`Series.plot()`存在错误，当传递了`how`关键字时未能引发错误（[GH 55953](https://github.com/pandas-dev/pandas/issues/55953))

### 分组/重新采样/滚动

+   `DataFrameGroupBy.idxmin()`、`DataFrameGroupBy.idxmax()`、`SeriesGroupBy.idxmin()` 和 `SeriesGroupBy.idxmax()` 中的 Bug 在索引是包含 NA 值的 `CategoricalIndex` 时不会保留 `Categorical` dtype（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）。

+   当 `observed=False` 且 `f="idxmin"` 或 `f="idxmax"` 时，`DataFrameGroupBy.transform()` 和 `SeriesGroupBy.transform()` 中的 Bug 会在未观察到的类别上错误地引发异常（[GH 54234](https://github.com/pandas-dev/pandas/issues/54234)）。

+   `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 中的 Bug 可能会导致 DataFrame 的列或 Series 的名称是整数时排序不正确（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）。

+   `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 中的 Bug 在 `DataFrame.groupby()` 和 `Series.groupby()` 的 `sort=False` 参数不起作用时不会保留排序（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）。

+   `DataFrameGroupBy.value_counts()` 和 `SeriesGroupBy.value_counts()` 中的 Bug，在 `sort=True` 和 `normalize=True` 时会按比例而不是频率排序（[GH 55951](https://github.com/pandas-dev/pandas/issues/55951)）

+   `DataFrame.asfreq()` 和 `Series.asfreq()` 中的 Bug，使用非纳秒分辨率的 `DatetimeIndex` 不正确地转换为纳秒分辨率 ([GH 55958](https://github.com/pandas-dev/pandas/issues/55958))

+   `DataFrame.ewm()` 中的 Bug，当传入非纳秒 `datetime64` 或 `DatetimeTZDtype` 类型的 `times` 时 ([GH 56262](https://github.com/pandas-dev/pandas/issues/56262))

+   在使用 `sort=True` 时，由于 Decimal 和 NA 值的组合而分组的 `DataFrame.groupby()` 和 `Series.groupby()` 的 Bug ([GH 54847](https://github.com/pandas-dev/pandas/issues/54847))

+   在 DataFrame 子类中选择要应用函数的列子集时，`DataFrame.groupby()` 中的 Bug ([GH 56761](https://github.com/pandas-dev/pandas/issues/56761))

+   对于 `BusinessDay`，`DataFrame.resample()` 不尊重 `closed` 和 `label` 参数的 Bug ([GH 55282](https://github.com/pandas-dev/pandas/issues/55282))

+   在 `pyarrow.timestamp` 或 `pyarrow.duration` 类型的 `ArrowDtype` 上重采样时的 Bug ([GH 55989](https://github.com/pandas-dev/pandas/issues/55989))

+   在 `DataFrame.resample()` 中，对于 `BusinessDay`，bin 边界不正确（[GH 55281](https://github.com/pandas-dev/pandas/issues/55281)）

+   在 `DataFrame.resample()` 中，对于 `MonthBegin`，bin 边界不正确（[GH 55271](https://github.com/pandas-dev/pandas/issues/55271)）

+   在 `DataFrame.rolling()` 和 `Series.rolling()` 中，重复的 datetimelike 索引被视为连续而不是相等，使用 `closed='left'` 和 `closed='neither'` 时出现错误（[GH 20712](https://github.com/pandas-dev/pandas/issues/20712)）

+   在 `DataFrame.rolling()` 和 `Series.rolling()` 中，`index` 或 `on` 列中的一个是具有 `pyarrow.timestamp` 类型的 `ArrowDtype` 时出现错误（[GH 55849](https://github.com/pandas-dev/pandas/issues/55849)）

### 重塑

+   当传递 `DatetimeIndex` 索引时，`concat()` 忽略了 `sort` 参数（[GH 54769](https://github.com/pandas-dev/pandas/issues/54769)）

+   当 `ignore_index=False` 时，在 `concat()` 重命名 `Series` 时出现错误（[GH 15047](https://github.com/pandas-dev/pandas/issues/15047)）

+   当 `by` 的 dtype 不是 `object`、`int64` 或 `uint64` 时，`merge_asof()` 中引发了 `TypeError` 的错误（[GH 22794](https://github.com/pandas-dev/pandas/issues/22794)）

+   `merge_asof()` 中的错误引发了字符串 dtype 的错误（[GH 56444](https://github.com/pandas-dev/pandas/issues/56444)）

+   `merge_asof()` 中的一个错误，当在 `ArrowDtype` 列上使用 `Timedelta` 容差时（[GH 56486](https://github.com/pandas-dev/pandas/issues/56486))

+   `merge()` 中的一个错误，当合并日期时间列与时间间隔列时不会引发异常（[GH 56455](https://github.com/pandas-dev/pandas/issues/56455))

+   `merge()` 中的一个错误，当合并字符串列与数字列时不会引发异常（[GH 56441](https://github.com/pandas-dev/pandas/issues/56441))

+   `merge()` 中的一个错误，在新的字符串 dtype 中不进行排序（[GH 56442](https://github.com/pandas-dev/pandas/issues/56442))

+   `merge()` 中的一个错误，在左侧和/或右侧为空时返回列的顺序不正确（[GH 51929](https://github.com/pandas-dev/pandas/issues/51929))

+   `DataFrame.melt()` 中的一个错误，如果 `var_name` 不是字符串，则会引发异常（[GH 55948](https://github.com/pandas-dev/pandas/issues/55948))

+   `DataFrame.melt()` 中的一个错误，它不会保留日期时间（[GH 55254](https://github.com/pandas-dev/pandas/issues/55254))

+   `DataFrame.pivot_table()` 中的一个错误，当列具有数字名称时，行边距不正确（[GH 26568](https://github.com/pandas-dev/pandas/issues/26568))

+   `DataFrame.pivot()` 中的一个错误，具有数字列和数据扩展 dtype 时（[GH 56528](https://github.com/pandas-dev/pandas/issues/56528))

+   `DataFrame.stack()` 中的一个错误，使用 `future_stack=True` 时不会保留索引中的 NA 值（[GH 56573](https://github.com/pandas-dev/pandas/issues/56573))

### 稀疏

+   `arrays.SparseArray.take()` 中的一个错误，当使用与数组的填充值不同的填充值时（[GH 55181](https://github.com/pandas-dev/pandas/issues/55181))

### 其他

+   `DataFrame.__dataframe__()` 不支持 pyarrow 大字符串（[GH 56702](https://github.com/pandas-dev/pandas/issues/56702))

+   在格式化百分位数时的`DataFrame.describe()`中的错误，结果的百分位数 99.999%四舍五入为 100% ([GH 55765](https://github.com/pandas-dev/pandas/issues/55765))

+   在处理空字符串列时，在`api.interchange.from_dataframe()`中引发`NotImplementedError`的错误 ([GH 56703](https://github.com/pandas-dev/pandas/issues/56703))

+   在与非纳秒单位的`datetime64` dtype 值一起的`cut()`和`qcut()`中的错误，错误地返回了纳秒单位的 bins ([GH 56101](https://github.com/pandas-dev/pandas/issues/56101))

+   在`cut()`中的错误，错误地允许将具有时区感知的日期时间与时区无关的 bins 进行切割 ([GH 54964](https://github.com/pandas-dev/pandas/issues/54964))

+   在具有周频率和非纳秒分辨率的周频率中的`infer_freq()`和`DatetimeIndex.inferred_freq()`中的错误 ([GH 55609](https://github.com/pandas-dev/pandas/issues/55609))

+   在`DataFrame.apply()`中的错误，当传递`raw=True`时，忽略了传递给应用函数的`args` ([GH 55009](https://github.com/pandas-dev/pandas/issues/55009))

+   在`DataFrame.from_dict()`中的错误，它总是会对创建的`DataFrame`的行进行排序。 ([GH 55683](https://github.com/pandas-dev/pandas/issues/55683))

+   在传递`axis="columns"`和`ignore_index=True`时，在`DataFrame.sort_index()`中引发`ValueError`的错误 ([GH 56478](https://github.com/pandas-dev/pandas/issues/56478))

+   在启用`use_inf_as_na`选项的`DataFrame`内部渲染`inf`值时的错误 ([GH 55483](https://github.com/pandas-dev/pandas/issues/55483))

+   渲染``[`Series``]时的错误`，其中一个索引级别的名称为 0，但没有显示该名称 ([GH 55415](https://github.com/pandas-dev/pandas/issues/55415))

+   给一个空的 `DataFrame` 分配给一列时出现了错误信息（[GH 55956](https://github.com/pandas-dev/pandas/issues/55956)）

+   当将时间字符串转换为带有 `pyarrow.time64` 类型的 `ArrowDtype` 时出现错误（[GH 56463](https://github.com/pandas-dev/pandas/issues/56463)）

+   修复了当在 `core.window.Rolling.apply` 中传递一个 numpy ufunc 并且使用 `engine="numba"` 时，从 `numba` >= 0.58.0 中产生的不必要的弃用警告（[GH 55247](https://github.com/pandas-dev/pandas/issues/55247)）

## 贡献者

一共有 162 人为这个版本做出了贡献。名字后面有“+”的人第一次为这个版本贡献了补丁。

+   AG

+   Aaron Rahman +

+   Abdullah Ihsan Secer +

+   Abhijit Deo +

+   Adrian D’Alessandro

+   Ahmad Mustafa Anis +

+   Amanda Bizzinotto

+   Amith KK +

+   Aniket Patil +

+   Antonio Fonseca +

+   Artur Barseghyan

+   Ben Greiner

+   Bill Blum +

+   Boyd Kane

+   Damian Kula

+   Dan King +

+   Daniel Weindl +

+   Daniele Nicolodi

+   David Poznik

+   David Toneian +

+   Dea María Léon

+   Deepak George +

+   Dmitriy +

+   Dominique Garmier +

+   Donald Thevalingam +

+   Doug Davis +

+   Dukastlik +

+   Elahe Sharifi +

+   Eric Han +

+   Fangchen Li

+   Francisco Alfaro +

+   Gadea Autric +

+   Guillaume Lemaitre

+   Hadi Abdi Khojasteh

+   Hedeer El Showk +

+   Huanghz2001 +

+   Isaac Virshup

+   Issam +

+   Itay Azolay +

+   Itayazolay +

+   Jaca +

+   Jack McIvor +

+   JackCollins91 +

+   James Spencer +

+   Jay

+   Jessica Greene

+   Jirka Borovec +

+   JohannaTrost +

+   John C +

+   Joris Van den Bossche

+   José Lucas Mayer +

+   José Lucas Silva Mayer +

+   João Andrade +

+   Kai Mühlbauer

+   Katharina Tielking, MD +

+   Kazuto Haruguchi +

+   Kevin

+   Lawrence Mitchell

+   Linus +

+   Linus Sommer +

+   Louis-Émile Robitaille +

+   Luke Manley

+   木工机器人（又名杰克）

+   Maggie Liu +

+   MainHanzo +

+   Marc Garcia

+   Marco Edward Gorelli

+   MarcoGorelli

+   Martin Šícho +

+   Mateusz Sokół

+   Matheus Felipe +

+   Matthew Roeschke

+   Matthias Bussonnier

+   Maxwell Bileschi +

+   Michael Tiemann

+   Michał Górny

+   Molly Bowers +

+   Moritz Schubert +

+   NNLNR +

+   Natalia Mokeeva

+   Nils Müller-Wendt +

+   Omar Elbaz

+   Pandas 开发团队

+   Paras Gupta +

+   Parthi

+   Patrick Hoefler

+   Paul Pellissier +

+   Paul Uhlenbruck +

+   Philip Meier

+   Philippe THOMY +

+   Quang Nguyễn

+   Raghav

+   Rajat Subhra Mukherjee

+   Ralf Gommers

+   Randolf Scholz +

+   Richard Shadrach

+   Rob +

+   Rohan Jain +

+   Ryan Gibson +

+   Sai-Suraj-27 +

+   Samuel Oranyeli +

+   Sara Bonati +

+   Sebastian Berg

+   Sergey Zakharov +

+   Shyamala Venkatakrishnan +

+   StEmGeo +

+   Stefanie Molin

+   Stijn de Gooijer +

+   Thiago Gariani +

+   Thomas A Caswell

+   Thomas Baumann +

+   Thomas Guillet +

+   Thomas Lazarus +

+   Thomas Li

+   Tim Hoffmann

+   Tim Swast

+   Tom Augspurger

+   Toro +

+   Torsten Wörtwein

+   Ville Aikas +

+   Vinita Parasrampuria +

+   Vyas Ramasubramani +

+   William Andrea

+   William Ayd

+   Willian Wang +

+   Xiao Yuan

+   Yao Xiao

+   Yves Delley

+   Zemux1613 +

+   Ziad Kermadi +

+   aaron-robeson-8451 +

+   aram-cinnamon +

+   caneff +

+   ccccjone +

+   chris-caballero +

+   cobalt

+   color455nm +

+   denisrei +

+   dependabot[bot]

+   jbrockmendel

+   jfadia +

+   johanna.trost +

+   kgmuzungu +

+   mecopur +

+   mhb143 +

+   morotti +

+   mvirts +

+   omar-elbaz

+   paulreece

+   pre-commit-ci[bot]

+   raj-thapa

+   rebecca-palmer

+   rmhowe425

+   rohanjain101

+   shiersansi +

+   smij720

+   srkds +

+   taytzehao

+   torext

+   vboxuser +

+   xzmeng +

+   yashb +
