- en: Writing Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写测试
- en: Original text：[https://docs.sympy.org/latest/contributing/new-contributors-guide/writing-tests.html](https://docs.sympy.org/latest/contributing/new-contributors-guide/writing-tests.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/contributing/new-contributors-guide/writing-tests.html](https://docs.sympy.org/latest/contributing/new-contributors-guide/writing-tests.html)
- en: The most important thing for a mathematical library like SymPy is correctness.
    Functions should never return mathematically incorrect results. Correctness is
    always the top concern, even if it comes at the cost of things like performance
    or modularity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像SymPy这样的数学库来说，最重要的是正确性。函数永远不应返回数学上不正确的结果。正确性始终是首要关注点，即使这可能会牺牲性能或模块化。
- en: Consequently, all functionality in SymPy is tested extensively. This guide goes
    over how tests in SymPy are written.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SymPy中的所有功能都经过了广泛测试。本指南介绍了SymPy中测试的编写方法。
- en: Testing Policies
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试策略
- en: 'In order to ensure the high standard of correctness, SymPy has the following
    rules that apply to all pull requests:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保高标准的正确性，SymPy有以下适用于所有拉取请求的规则：
- en: All new functionality must be tested. Tests should aim to cover all possible
    cases to best ensure correctness. This means not only maximizing code coverage,
    but also covering all possible corner cases.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有新功能必须经过测试。测试应该尽可能覆盖所有可能的情况以确保正确性。这意味着不仅要最大化代码覆盖率，还要覆盖所有可能的边界情况。
- en: Every pull request must pass all tests before it can be merged. The tests are
    automatically run by the GitHub Actions CI on every pull request. If any tests
    fail, the CI will fail with a red ❌. These failures must be addressed before the
    pull request can be merged.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在合并之前，每个拉取请求必须通过所有测试。测试会在每个拉取请求上自动运行GitHub Actions CI。如果任何测试失败，CI将以红色❌失败。必须在合并拉取请求之前解决这些失败。
- en: Bug fixes should be accompanied by a [regression test](#writing-tests-regression-tests).
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缺陷修复应该伴随着[回归测试](#writing-tests-regression-tests)。
- en: '## Basics for Writing Tests'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '## 编写测试的基础知识'
- en: Tests are located alongside the code in `tests/` directories, in files named
    `test_<thing>.py`. In most cases, if you modified `sympy/<submodule>/<file>.py`
    then the test for the functionality will go in `sympy/<submodule>/tests/test_<file>.py`.
    For example, the tests for the functions in `sympy/simplify/sqrtdenest.py` are
    in `sympy/simplify/tests/test_sqrtdenest.py`. There are some exceptions to this
    rule, so in general try to find where the existing tests are for a function and
    add your tests alongside them. If you are adding tests for a new function, follow
    the general pattern of tests in the module you are adding to.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试位于`tests/`目录中的代码旁边，文件名为`test_<thing>.py`。在大多数情况下，如果您修改了`sympy/<submodule>/<file>.py`，则该功能的测试将放在`sympy/<submodule>/tests/test_<file>.py`中。例如，`sympy/simplify/sqrtdenest.py`中函数的测试在`sympy/simplify/tests/test_sqrtdenest.py`中。有一些例外情况，因此通常尝试找到函数的现有测试所在位置，并将您的测试添加到其旁边。如果您为新功能添加测试，请遵循要添加到的模块中的测试的一般模式。
- en: Tests follow a simple pattern, which should be apparent from reading the existing
    test files. Tests are in functions that start with `test_` and contain lines like
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试遵循一个简单的模式，从阅读现有测试文件中可以看出。测试在以`test_`开头的函数中，包含如下行
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: New test cases can be added to an existing test function if it is relevant,
    or you can create a new test function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相关，新的测试案例可以添加到现有测试功能中，或者您可以创建一个新的测试功能。
- en: Running Tests
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: The basic way to run the tests is to use
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的基本方法是使用
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: to run the tests, and
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，以及
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: to run the doctests. Note that the full test suite can take some time to run,
    so typically you should just run a subset of the tests, e.g., corresponding to
    the module you modified. You can do this by passing the name of the submodules
    or tests files to the test command. For example,
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行doctests。请注意，完整的测试套件可能需要一些时间才能运行，因此通常您应该只运行一部分测试，例如，对应于您修改的模块。您可以通过将子模块或测试文件的名称传递给测试命令来执行此操作。例如，
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: will run only the tests for the solvers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 仅运行求解器的测试。
- en: If you want, you can also use `pytest` to run the tests instead of the `./bin/test`
    tool, for example
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您也可以使用`pytest`来运行测试，而不是使用`./bin/test`工具，例如
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Another option is to just push your code up to GitHub and let the tests run
    on the CI. The GitHub Actions CI will run all the tests. However, it can take
    some time to finish, so it is usually advisable to run at least the basic tests
    before committing to avoid having to wait.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将您的代码推送到GitHub，并让测试在CI上运行。GitHub Actions CI将运行所有测试。但是，它可能需要一些时间才能完成，因此通常建议在提交之前至少运行基本测试，以避免等待。
- en: Debugging Test Failures on GitHub Actions
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 上调试测试失败
- en: When you see a test failure on CI, like
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 CI 上看到测试失败时，例如
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The bit in between `_________________` is the name of the test. You can reproduce
    the test locally by copying and pasting this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`_________________`之间的部分是测试的名称。您可以通过复制并粘贴此内容在本地复现测试：'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: or
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The test also shows the file and line number (in this example, 317 in `sympy/printing/pretty/tests/test_pretty.py`)
    of the assertion that fails, so you can look it up to see what the test is testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试还显示了断言失败的文件和行号（在本例中为`sympy/printing/pretty/tests/test_pretty.py`的第317行），因此您可以查看以了解测试在测试什么。
- en: 'Sometimes when you do this, you will not be able to reproduce the test failure
    locally. Some common causes of this are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当您执行此操作时，可能无法在本地复现测试失败。此类情况的一些常见原因包括：
- en: You may need to merge the latest `master` into your branch to reproduce the
    failure (GitHub Actions will always merge your branch with the latest `master`
    before running the tests).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要将最新的 `master` 分支合并到您的分支以重现失败（GitHub Actions 在运行测试之前始终会将您的分支与最新的 `master`
    合并）。
- en: Something about the CI testing environment may be different from yours (this
    is especially likely for tests that depend on [optional dependencies](../dependencies.html#optional-dependencies).
    Check which versions of relevant packages are installed at the top of the CI log.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI 测试环境与您的可能有所不同（特别是依赖于[可选依赖项](../dependencies.html#optional-dependencies)的测试）。检查
    CI 日志顶部安装的相关软件包的版本。
- en: It’s possible that some other test that ran prior to yours may have somehow
    influenced your test. SymPy is not supposed to have global state, but sometimes
    some state can sneak in on accident. The only way to check this is to run the
    exact same test command that was run on CI.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是您之前运行的某些其他测试可能以某种方式影响了您的测试。SymPy不应该具有全局状态，但有时可能会意外地引入某些状态。唯一检查这一点的方法是运行与
    CI 上运行的完全相同的测试命令。
- en: A test may fail sporadically. Try rerunning the test multiple times. The beginning
    of the test log on CI prints the random seed, which can be passed to `./bin/test
    --seed`, and the `PYTHONHASHSEED` environment variable, which may be helpful for
    reproducing such failures.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能偶尔会失败。尝试多次重新运行测试。CI 上的测试日志开头打印了随机种子，可以传递给 `./bin/test --seed`，以及可能有助于重现此类失败的
    `PYTHONHASHSEED` 环境变量。
- en: It is also sometimes possible that a failure on CI may be unrelated to your
    branch. We only merge branches that have passing CI, so that master always ideally
    has passing tests. But sometimes a failure can slip in. Typically this is either
    because the failure is sporadic (see the previous bullet), and it wasn’t noticed,
    or because some [optional dependency](../dependencies.html#optional-dependencies)
    was updated which broken an optional dependency test. If a test failure seems
    like it is unrelated to your change, check if the [CI builds for master](https://github.com/sympy/sympy/actions?query=branch%3Amaster)
    and if CI builds on other recent PRs have the same failure. If they do, this is
    likely the case. If they don’t, you should check more carefully if your change
    is causing the failure, even if it seems unrelated.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 CI 上的失败可能与您的分支无关。我们只合并通过 CI 的分支，因此理想情况下，主分支始终具有通过的测试。但有时失败可能会发生。通常情况下，这要么是因为失败是偶发的（参见上一个项目符号），并且没有注意到，要么是因为某些[可选依赖项](../dependencies.html#optional-dependencies)已更新，这会破坏可选依赖项测试。如果测试失败似乎与您的更改无关，请检查主分支的[CI
    构建](https://github.com/sympy/sympy/actions?query=branch%3Amaster)以及其他最近的 PR 是否具有相同的失败。如果是这样，那么很可能如此。如果不是，请仔细检查您的更改是否导致失败，即使看起来与此无关。
- en: When there is a CI failure in the master branch, be aware that your pull request
    cannot be merged until it is fixed. This is not required, but if you know how
    to fix it, please do this to help everyone (if you do this, do it in a separate
    pull request so that it can be merged expeditiously).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当主分支中的 CI 失败时，请注意在修复之前无法合并您的拉取请求。这不是必需的，但如果您知道如何修复，请这样做以帮助所有人（如果这样做，请在单独的拉取请求中执行，以便可以迅速合并）。
- en: '## Regression Tests'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '## 回归测试'
- en: Regression tests are tests that would fail before a bug fix but now pass. Often
    you can use a code example from an issue as a test case, although it is also OK
    to simplify such examples or to write your own, so long as it tests the issue
    in question.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试是指在修复错误之前会失败但现在通过的测试。通常，您可以使用问题示例中的代码示例作为测试用例，尽管也可以简化这些示例或编写自己的示例，只要测试问题本身。
- en: 'For example, consider [issue #21177](https://github.com/sympy/sympy/issues/21177),
    which identified the following wrong result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，考虑[问题 #21177](https://github.com/sympy/sympy/issues/21177)，该问题确定了以下错误结果：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the first expression was correct but the second was not. In the issue,
    the cause of the issue was identified in the `as_leading_term` method, and several
    other related issues were also found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，第一个表达式是正确的，但第二个表达式是错误的。在问题中，问题的根源被确定在`as_leading_term`方法中，并且还发现了几个其他相关问题。
- en: 'In the corresponding pull request ([#21253](https://github.com/sympy/sympy/pull/21253/files)),
    several regression tests were added. For example (from that PR):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在相应的拉取请求（[#21253](https://github.com/sympy/sympy/pull/21253/files)）中，添加了几个回归测试。例如（从该PR中）：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This example shows some important aspects of regression tests:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了回归测试的一些重要方面：
- en: Tests should be added for the underlying fix, not just the originally reported
    issue. The originally reported issue in this example was with the `residue()`
    function but the underlying issue was with the `as_leading_term()` method.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应添加用于修复根本问题的测试，而不仅仅是最初报告的问题。例如，此示例中最初报告的问题是`residue()`函数，但根本问题是`as_leading_term()`方法。
- en: At the same time, it can also be beneficial to add a test for the high-level
    issue as reported. This ensures that `residue` itself won’t break in the future,
    even if the implementation details of it change so that it no longer uses the
    same code path that was fixed.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，还可以有利于添加用于报告的高级问题的测试。这确保了即使其实现细节发生变化而不再使用已修复的代码路径，`residue`本身也不会在未来出现问题。
- en: This example does not show it, but in some cases it may be prudent to simplify
    the originally reported issue for the test case. For example, sometimes users
    will include unnecessary details in the report that don’t actually matter for
    the reproduction of the issue (like unnecessary assumptions on symbols), or make
    the input expression too large or have too many unnecessary constant symbols.
    This is especially important to do if the code from the originally stated issue
    is slow to compute. If the same thing can be tested with a test that runs more
    quickly, this should be preferred.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此示例未显示，但在某些情况下，为测试用例简化最初报告的问题可能是明智的选择。例如，有时用户会在报告中包含不必要的细节，这些细节对问题的重现实际上并不重要（例如，符号上的不必要假设），或者使输入表达式过于复杂或包含太多不必要的常数符号。如果最初报告的代码运行速度慢，尤其重要。如果可以用更快执行的测试来测试相同的内容，则应优先考虑此选项。
- en: Regression tests should also be added for additional bugs that are identified
    in the issue. In this example, the second test (the test added to `test_as_leading_term()`)
    was identified as a related problem in a [comment on the issue](https://github.com/sympy/sympy/issues/21177#issuecomment-812816346).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试还应添加用于在问题中标识的其他错误。例如，此示例中第二个测试（添加到`test_as_leading_term()`的测试）被确定为问题评论中的相关问题（[评论链接](https://github.com/sympy/sympy/issues/21177#issuecomment-812816346)）。
- en: It is useful to cross-reference the issue number in a regression test, either
    using a comment or in the test name. A comment is preferred if the test is being
    added to an existing test.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回归测试中交叉引用问题编号非常有用，无论是使用注释还是在测试名称中。如果将测试添加到现有测试中，则更倾向于使用注释。
- en: Regression tests aren’t just for bug fixes. They should also be used for new
    features, to make sure the newly implemented functionality remains implemented
    and correct.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试不仅用于修复错误。它们还应该用于新功能，以确保新实现的功能保持正确和稳定。
- en: Special Types of Tests
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊类型的测试
- en: Most tests will be of the form `assert function(input) == output`. However,
    there are other types of things that you might want to test that should be tested
    in certain ways.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试将采用`assert function(input) == output`的形式。然而，有些需要测试的事物应该以特定方式进行测试。
- en: Testing Exceptions
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试异常
- en: To test that a function raises a given exception, use `sympy.testing.pytest.raises`.
    `raises()` takes an exception class and a lambda. For example
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试函数是否引发给定异常，请使用`sympy.testing.pytest.raises`。`raises()`接受异常类和lambda表达式。例如
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember to include the `lambda`. Otherwise, the code will be executed immediately
    and will raise the exception, causing the test to fail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记得包括`lambda`。否则，代码将立即执行并引发异常，导致测试失败。
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`raises` can also be used as a context manager, like'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`raises`也可以作为上下文管理器使用，例如'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, be careful using this form, as it can only check one expression at
    a time. If the code under context manager raises multiple exceptions, only the
    first one will actually be tested
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用此形式时要小心，因为它只能检查一个表达式。如果上下文管理器下的代码引发多个异常，则实际上只会测试第一个异常。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `lambda` form is generally better because it avoids this problem, although
    if you are testing something that cannot be represented in a `lambda` you will
    need to use the context manager form.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 形式通常更好，因为它避免了这个问题，尽管如果你要测试无法用 `lambda` 表示的内容，则需要使用上下文管理器形式。'
- en: '### Testing Warnings'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '### 测试警告'
- en: '[Warnings](https://docs.python.org/3/library/warnings.html) can be tested with
    the [`sympy.testing.pytest.warns()`](../../modules/testing/pytest.html#sympy.testing.pytest.warns
    "sympy.testing.pytest.warns") context manager. Note that `SymPyDeprecationWarning`
    is special and should be tested with `warns_deprecated_sympy()` instead (see [below](#writing-tests-test-deprecated-functionality)).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`sympy.testing.pytest.warns()`](../../modules/testing/pytest.html#sympy.testing.pytest.warns
    "sympy.testing.pytest.warns")上下文管理器来测试[警告](https://docs.python.org/3/library/warnings.html)。请注意，`SymPyDeprecationWarning`
    是特殊的，应该使用 `warns_deprecated_sympy()` 进行测试（参见[下文](#writing-tests-test-deprecated-functionality)）。
- en: The context manager should take a warning class (`warnings.warn()` uses `UserWarning`
    by default), and, optionally, a regular expression that the warning message should
    match as the `match` keyword argument.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器应该接受警告类（`warnings.warn()` 默认使用 `UserWarning`），以及可选的正则表达式，用作 `match` 关键字参数来匹配警告消息。
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Any test functionality that emits a warning should use `warns()`.** That
    way, no warnings are actually emitted during the tests themselves. This includes
    warnings coming from external libraries.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**任何发出警告的测试功能都应该使用 `warns()`。** 这样，在测试过程中实际上不会发出任何警告。这包括来自外部库的警告。'
- en: Warnings within SymPy itself should be used very sparingly. Aside from [deprecation
    warnings](../deprecations.html#deprecation-policy), warnings are generally not
    used in SymPy, as they may be too annoying for users, especially those who use
    SymPy as a library, to be warranted.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 本身应该非常谨慎地使用警告。除了[弃用警告](../deprecations.html#deprecation-policy)之外，SymPy
    通常不使用警告，因为对于使用 SymPy 作为库的用户来说，这些警告可能会过于烦人，不值得。
- en: 'When you do use them, you must set the `stacklevel` parameter in the warning
    so that it shows the user code that called the function that emitted the warning.
    If the `stacklevel` parameter is impossible to set correctly, use `warns(test_stacklevel=False)`
    to disable the check in `warns` that `stacklevel` is used properly. `warns(SymPyDeprecationWarning,
    test_stacklevel=False)` must be used in place of `warns_deprecated_sympy()` if
    this applies to a `SymPyDeprecationWarning`  ### Test Deprecated Functionality'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用它们时，必须设置警告的 `stacklevel` 参数，以便显示调用引发警告函数的用户代码。如果无法正确设置 `stacklevel` 参数，则使用
    `warns(test_stacklevel=False)` 来禁用 `warns` 中对正确使用 `stacklevel` 的检查。如果这适用于 `SymPyDeprecationWarning`，则必须使用
    `warns(SymPyDeprecationWarning, test_stacklevel=False)` 替代 `warns_deprecated_sympy()`。###
    测试弃用功能
- en: Deprecated functionality should be tested with the [`sympy.testing.pytest.warns_deprecated_sympy()`](../../modules/testing/pytest.html#sympy.testing.pytest.warns_deprecated_sympy
    "sympy.testing.pytest.warns_deprecated_sympy") context manager.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用[`sympy.testing.pytest.warns_deprecated_sympy()`](../../modules/testing/pytest.html#sympy.testing.pytest.warns_deprecated_sympy
    "sympy.testing.pytest.warns_deprecated_sympy")上下文管理器来测试弃用功能。
- en: The only purpose of this context manager is to test that the deprecation warning
    itself is functioning correctly. This should be the only place in the test suite
    where deprecated functionality is called. All other tests should use non-deprecated
    functionality. If it is impossible to avoid deprecated functionality, this may
    be a sign that the functionality should not actually be deprecated.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此上下文管理器的唯一目的是测试弃用警告本身是否正常工作。这应该是测试套件中唯一一个调用弃用功能的地方。所有其他测试应该使用非弃用功能。如果无法避免使用弃用功能，则可能表明实际上不应该弃用该功能。
- en: The [deprecation policy](../deprecations.html#deprecation-policy) page goes
    into detail about how to add a deprecation to a function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[弃用策略](../deprecations.html#deprecation-policy)页面详细说明了如何向函数添加弃用。'
- en: For example,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If code is using deprecated functionality from another library, this code should
    be updated. Until then, the normal [`warns()`](#writing-tests-testing-warnings)
    context manager should be used in the corresponding tests to prevent the warning
    from being emitted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码使用另一个库的已弃用功能，则应更新该代码。 在此之前，应在相应的测试中使用常规的 [`warns()`](#writing-tests-testing-warnings)
    上下文管理器以防止发出警告。
- en: Testing that Something is Unchanged
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测某些东西是否保持不变
- en: The normal test style of
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 普通测试样式
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'works for most types of tests. However, it doesn’t work in the case where a
    SymPy object should remain unchanged. Consider the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数测试都有效。 但是，在 SymPy 对象应保持不变的情况下不起作用。 考虑以下示例：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first two tests here are fine. The test that `sin` returns the corresponding
    special value for the inputs `pi` and `pi/2`. However, the last test nominally
    checks that `sin(1)` doesn’t return anything. But upon closer inspection, we see
    that it doesn’t do that at all. `sin(1)` could in fact return anything. It could
    return complete nonsense or even a wrong answer like `0`. The test would still
    pass, because all it is doing is checking that the result of `sin(1)` equals the
    result of `sin(1)`, which it always will so long as it always returns the same
    thing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的前两个测试很好。 测试 `sin` 是否为输入 `pi` 和 `pi/2` 返回相应的特殊值。 但是，最后一个测试名义上检查 `sin(1)` 不返回任何东西。
    但仔细检查后，我们发现它根本没有这样做。 `sin(1)` 实际上可以返回任何东西。 它可以返回完全荒谬的内容，甚至是错误的答案，如 `0`。 测试仍然会通过，因为它只是检查
    `sin(1)` 的结果是否等于 `sin(1)` 的结果，这总是会成立的，只要它总是返回相同的东西。
- en: We really want to check that `sin(1)` remains unevaluated. The `sympy.core.expr.unchanged`
    helper will do this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的想检查 `sin(1)` 保持不变。 `sympy.core.expr.unchanged` 助手将会做到这一点。
- en: Use it like
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This test now actually checks the correct thing. If `sin(1)` were made to return
    some value, the test would fail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个测试实际上检查了正确的内容。 如果 `sin(1)` 被设置为返回某个值，则测试将失败。
- en: Testing Expressions with [`Dummy`](../../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy")
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 [`Dummy`](../../modules/core.html#sympy.core.symbol.Dummy "sympy.core.symbol.Dummy")
    进行表达式测试
- en: 'Expressions that return [`Dummy`](../../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy") cannot be tested with `==` directly, due to the nature
    of `Dummy`. In such cases, use the [`dummy_eq()`](../../modules/core.html#sympy.core.basic.Basic.dummy_eq
    "sympy.core.basic.Basic.dummy_eq") method. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 [`Dummy`](../../modules/core.html#sympy.core.symbol.Dummy "sympy.core.symbol.Dummy")
    的表达式不能直接使用 `==` 进行测试，因为 `Dummy` 的特性。 在这种情况下，请使用 [`dummy_eq()`](../../modules/core.html#sympy.core.basic.Basic.dummy_eq
    "sympy.core.basic.Basic.dummy_eq") 方法。 例如：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Consistency Checks
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一致性检查
- en: Checking a set of known inputs and outputs can only get you so far. A test like
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过已知输入和输出的集合来测试可以有所限制。 例如
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: will check that `function(input)` returns `expression`, but it doesn’t check
    that `expression` itself is actually mathematically correct.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将检查 `function(input)` 返回 `expression`，但不检查 `expression` 本身是否数学上正确。
- en: However, depending on what `function` is, sometimes a consistency check can
    be done to check that `expression` itself is correct. This typically boils down
    to “computing `expression` in two different ways”. If both ways agree, there is
    a pretty high chance it is correct, as it is unlikely that two completely different
    methods will produce the same wrong answer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，根据 `function` 的不同，有时可以进行一致性检查，以验证 `expression` 本身是否正确。 这通常归结为“以两种不同的方式计算
    `expression`”。 如果两种方式一致，则它正确的可能性很高，因为两种完全不同的方法产生相同错误答案的可能性很小。
- en: 'For example, the inverse of indefinite integration is differentiation. The
    tests for integrals can be checked for consistency by seeing if the derivative
    of the result produces the original integrand:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不定积分的反函数是微分。 可以通过检查结果的导数是否产生原始被积函数来验证积分的一致性：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The implementation for `diff` is very simple compared to `integrate`, and it
    is tested separately, so this confirms the answer is correct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `integrate` 相比，`diff` 的实现非常简单，并且已经单独进行了测试，因此可以确认答案是正确的。
- en: Of course, one could also just confirm the answer by hand, and this is what
    most tests in SymPy do. But a consistency check does not hurt, especially when
    it is easy to do.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以手动确认答案，这是 SymPy 中大多数测试所做的。 但是一致性检查并不会有什么坏处，尤其是当它很容易做到时。
- en: The use of consistency checks in the SymPy test suite is not, itself, consistent.
    Some modules make heavy use of them, e.g., every test in the ODE module checks
    itself using [`checkodesol()`](../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol"), for instance. Other modules do not use consistency
    checks in their tests at all, although some of these could be updated to do so.
    In some cases, there are no reasonable consistency checks and other sources of
    truth must be used to verify the test outputs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy测试套件中使用一致性检查本身并不一致。一些模块大量使用它们，例如ODE模块中的每个测试都使用[`checkodesol()`](../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol")进行自我检查。而其他模块在其测试中根本不使用一致性检查，尽管其中一些可以更新以执行此操作。在某些情况下，没有合理的一致性检查方法，必须使用其他真实来源验证测试输出。
- en: When making heavy use of consistency checks, it’s often a good idea to factor
    out the logic into a helper function in the test file to avoid duplication. Helper
    functions should start with an underscore so they aren’t mistaken for test functions
    by the test runner.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量使用一致性检查时，通常最好将逻辑提取到测试文件中的辅助函数中，以避免重复。辅助函数应该以下划线开头，这样它们不会被测试运行程序误认为是测试函数。
- en: Random Tests
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机测试
- en: Another way that tests can check themselves for consistency is to check the
    expressions on random numerical inputs. The helper functions in `sympy.core.random`
    can be used for this. See the tests in `sympy/functions/special/` which make heavy
    use of this functionality.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种测试自我一致性的方法是在随机数输入上检查表达式。可以使用`sympy.core.random`中的辅助函数来实现这一点。请参阅在`sympy/functions/special/`中大量使用此功能的测试。
- en: If you add a random test, be sure to run the test multiple times to ensure that
    it always passes. Random tests can be reproduced by using the random seed printed
    at the top of the tests. For example
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果添加了一个随机测试，请确保多次运行测试以确保测试始终通过。可以通过使用打印在测试顶部的随机种子来复现随机测试。例如
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here the random seed is `7357232`. It can be reproduced with
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的随机种子是`7357232`。可以通过以下方法复现：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In general you may need to use the same Python version and architecture as shown
    in the test header to reproduce a random test failure. You may also in some situations,
    need to run the tests using the exact same input arguments (i.e., running the
    full test suite or running only a subset) in order to reproduce a test that fails
    randomly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，为了复现随机测试失败，您可能需要使用与测试头部显示的相同的Python版本和架构。在某些情况下，为了复现随机失败的测试，您可能还需要使用完全相同的输入参数运行测试（即运行完整的测试套件或仅运行子集）。
- en: '### Skipping Tests'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '### 跳过测试'
- en: Tests can be skipped using the `sympy.testing.pytest.SKIP` decorator or using
    the `sympy.testing.pytest.skip()` function. Note that tests that are skipped because
    they are expected to fail should use the `@XFAIL` decorator instead (see [below](#writing-tests-xfail)).
    Test that are skipped because they are too slow should use the [`@slow` decorator
    instead](#writing-tests-slow).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以使用`sympy.testing.pytest.SKIP`装饰器或使用`sympy.testing.pytest.skip()`函数来跳过。请注意，由于预期失败而跳过的测试应该使用`@XFAIL`装饰器（参见[下文](#writing-tests-xfail)）。因为测试速度太慢而跳过的测试应该使用[`@slow`装饰器](#writing-tests-slow)。
- en: Tests that are skipped unconditionally should be avoided. Such a test is almost
    completely useless, as it will never be actually run. The only reason to skip
    a test unconditionally is if it would otherwise be `@XFAIL` or `@slow` but cannot
    use one of those decorators for some reason.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免无条件跳过的测试。这样的测试几乎完全无用，因为它实际上永远不会被运行。无条件跳过测试的唯一原因是，如果有其他原因无法使用`@XFAIL`或`@slow`装饰器。
- en: Both `@SKIP()` and `skip()` should include a message that explains why the test
    is being skipped, like `skip('numpy not installed')`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SKIP()`和`skip()`都应包含解释为何跳过测试的消息，例如`skip(''numpy not installed'')`。'
- en: The typical usage of skipping a test is when a test depends on an [optional
    dependency](../dependencies.html#optional-dependencies).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过测试的典型用法是当测试依赖于[可选依赖项](../dependencies.html#optional-dependencies)时。
- en: Such tests are generally written like
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这类测试通常写成
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When the test is written in this way, the test will not fail when NumPy is
    not installed, which is important since NumPy is not a hard dependency of SymPy.
    See also [Writing Tests with External Dependencies](#writing-tests-external-dependencies)
    below.  ### Marking Tests as Expected to Fail'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '当以这种方式编写测试时，如果没有安装NumPy，测试不会失败，这很重要，因为NumPy不是SymPy的硬依赖项。另请参阅[使用外部依赖项编写测试](#writing-tests-external-dependencies)。
    ### 将测试标记为预期失败'
- en: Some tests in SymPy are expected to fail. They are written so that when the
    functionality the check is finally implemented, a test is already written for
    it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的一些测试预期会失败。它们被设计为，在实现检查功能时，测试已经为其编写。
- en: Tests that are expected to fail are called XFAIL tests. They show up as `f`
    in the test runner when they fail as expected and `X` when they pass (or “XPASS”).
    A test that XPASSes should have its `@XFAIL` decorator removed so that it becomes
    a normal test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 预期失败的测试称为XFAIL测试。当它们如预期般失败时，它们将显示为测试运行器中的`f`，而当它们通过时则显示为`X`（或“XPASS”）。一个XPASS测试应该移除其`@XFAIL`装饰器，以使其成为正常测试。
- en: To XFAIL a test, add the `sympy.testing.pytest.XFAIL` decorator to it
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记一个测试为XFAIL，请将`sympy.testing.pytest.XFAIL`装饰器添加到其中。
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Care should be taken when writing an XFAIL test so that it actually passes when
    the functionality starts working. If you mistype the output, for example, the
    test may never pass. For example, the integral in the above test might start working,
    but return a result in a slightly different form than the one being checked. A
    more robust test would be
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编写XFAIL测试时需要注意，确保在功能启用时它能够通过。例如，如果误输入输出，则该测试可能永远无法通过。例如，上述测试中的积分可能开始起作用，但返回的结果形式可能与正在检查的形式略有不同。更健壮的测试应该是：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will cause the test to XPASS once the integral starts working, at which
    time the test can be updated with the actual output of `integrate()` (which can
    be compared against the expected output).  ### Marking Tests as Slow'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦积分开始工作，这将导致测试XPASS，届时测试可以更新为`integrate()`的实际输出（可以与预期输出进行比较）。### 标记测试为慢
- en: A test that is slow to run should be marked with the `@slow` decorator from
    `sympy.testing.pytest.slow`. The `@slow` decorator should be used for tests that
    take more than a minute to run. Tests that hang should use `@SKIP` instead of
    `@slow`. The slow tests will be run automatically in a separate CI job, but are
    skipped by default. You can manually run the slow tests with
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运行缓慢的测试应该用来自`sympy.testing.pytest.slow`的`@slow`装饰器标记。`@slow`装饰器应该用于运行时间超过一分钟的测试。挂起的测试应该使用`@SKIP`而不是`@slow`。慢测试将在单独的CI作业中自动运行，但默认情况下会被跳过。你可以手动运行慢测试，方法如下：
- en: '[PRE30]  ### Writing Tests with External Dependencies'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30] ### 使用外部依赖项编写测试'
- en: When writing a test for a function that uses one of SymPy’s [optional dependencies](../dependencies.html#optional-dependencies),
    the test should be written in a way that makes it so that the test does not fail
    when the module is not installed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在为使用SymPy的一个[可选依赖项](../dependencies.html#optional-dependencies)的函数编写测试时，应该以一种方式编写测试，使得在未安装模块时该测试不会失败。
- en: The way to do this is to use `sympy.external.import_module()`. This will import
    the module if it is installed and return `None` otherwise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的方法是使用`sympy.external.import_module()`。如果已安装，则导入模块，否则返回`None`。
- en: '`sympy.testing.pytest.skip` should be used to skip tests when the module in
    question is not installed (see [Skipping Tests](#writing-tests-skip) above). This
    can be done at the module level if the entire test file should be skippped, or
    in each individual function.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及模块未安装时，应使用`sympy.testing.pytest.skip`来跳过测试（参见[跳过测试](#writing-tests-skip)）。如果整个测试文件应该跳过，可以在模块级别执行此操作，或者在每个单独的函数中执行。
- en: You should also make sure the test is run in the “Optional Dependencies” CI
    run. To do this, edit `bin/test_optional_dependencies.py` and make sure the test
    is included (most SymPy submodules that test optional dependencies are already
    included automatically).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应确保在“可选依赖项”CI运行中运行测试。要做到这一点，请编辑`bin/test_optional_dependencies.py`，确保包含测试（大多数测试SymPy子模块的可选依赖项已自动包含）。
- en: If the optional dependency is new, add it to the list of packages that are installed
    in the optional dependencies build in `.github/workflows/runtests.yml`, and add
    it to the optional dependencies document at `doc/src/contributing/dependencies.md`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可选依赖项是新的，请将其添加到在`.github/workflows/runtests.yml`中的可选依赖项构建的安装列表，并将其添加到`doc/src/contributing/dependencies.md`的可选依赖项文档中。
- en: 'Note that it is not necessary to do any of this when using `mpmath`, as it
    is already a [hard dependency](../dependencies.html#hard-dependencies) of SymPy
    and will always be installed.  ## Doctests'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`mpmath`时，不需要执行任何这些操作，因为它已经是SymPy的[硬依赖项](../dependencies.html#hard-dependencies)，并且将始终安装。
- en: Every public function should have a docstring, and every docstring should have
    a examples. Code examples are all tested, which is why they are also sometimes
    called *doctests*. The [docstring style guide](../docstring.html#style-guide-docstring-examples-section)
    has more details on how to format examples in docstrings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公共函数应该有文档字符串，每个文档字符串都应该有示例。代码示例都是经过测试的，这也是它们有时被称为*文档测试*的原因。[文档字符串风格指南](../docstring.html#style-guide-docstring-examples-section)详细介绍了如何在文档字符串中格式化示例的更多细节。
- en: To run the doctests, use the
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行文档测试，请使用
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: command. This command can also take arguments to test a specific file or submodule,
    similar to `bin/test`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 命令。此命令还可以带参数来测试特定文件或子模块，类似于`bin/test`。
- en: Doctests should be written in a self-contained manner, with each doctest acting
    like a fresh Python session. This means that each doctest must manually import
    each function used in the doctest and define the symbols used. This may seem verbose,
    but it is helpful to users who are new to SymPy or even to Python who may not
    know where different functions come from. It also makes it easy for a user to
    copy and paste an example into a Python session of their own (the HTML documentation
    includes a button in the top right of every code example that copies the whole
    example to the clipboard).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 文档测试应该以一种自包含的方式编写，每个文档测试都像一个新的Python会话。这意味着每个文档测试必须手动导入在文档测试中使用的每个函数，并定义使用的符号。这看起来可能有些啰嗦，但对于对SymPy甚至Python都不熟悉的用户来说是有帮助的。它还使得用户可以轻松地将示例复制粘贴到他们自己的Python会话中（HTML文档中的每个代码示例的右上角都包含一个按钮，用于将整个示例复制到剪贴板）。
- en: For example
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The doctest output should look exactly as it would in a `python` session, with
    `>>>` before the inputs and the outputs after. The doctester tests that the output
    string matches, unlike normal tests which typically check that the Python objects
    are the same with `==`. Consequently, the output needs to look *exactly* the same
    as it does in a Python session.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 文档测试的输出应该与在`python`会话中看到的完全一样，输入前有`>>>`，输出后有结果。文档测试器检查输出字符串是否匹配，不像通常使用`==`检查Python对象是否相同的测试那样。因此，输出需要*完全*与Python会话中的一样。
- en: Like tests, all doctests must pass for a change to be accepted. However, when
    writing doctests, it is important to remember that **doctests should not be thought
    of as tests. Rather, they are examples that happen to be tested.**
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 像测试一样，所有的文档测试都必须通过才能接受更改。但是，在编写文档测试时，重要的是要记住**文档测试不应被视为测试。相反，它们是经过测试的示例。**
- en: Therefore, you should always think about what will make a good, readable example
    when writing doctests. Doctests do not need to extensively cover all possible
    inputs, and should not include corner or extreme cases unless they are important
    for users to be aware of.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在编写文档测试时，应始终考虑如何编写一个好的、易读的示例。文档测试不需要广泛覆盖所有可能的输入，并且不应包含边界或极端情况，除非这些情况对用户有重要意义。
- en: Everything that is tested in a doctest should also be tested in a [normal test](#writing-tests-basics).
    You should always be free to remove or change a doctest example at any time if
    it improves the documentation (to contrast, a normal test should never be changed
    or removed, except in [certain exceptional situations](#writing-tests-updating-existing-tests)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档测试中测试的所有内容也应在[正常测试](#writing-tests-basics)中进行测试。如果改进文档，则随时可以自由删除或更改文档测试示例（相比之下，正常测试在[某些特殊情况下](#writing-tests-updating-existing-tests)以外的情况下不应更改或删除）。
- en: This also means that doctests should be written first and foremost in a way
    that makes them understandable by someone reading the documentation. It can sometimes
    be tempting to write a doctest in some indirect way to please the doctester, but
    this should be avoided if it makes the example harder to understand. For example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，文档测试应首先以一种使得它们可以被阅读文档的人理解的方式编写。有时可能会诱人以某种间接的方式编写文档测试，以满足文档测试器的要求，但如果这样做使示例变得更难理解，则应避免。例如
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This passes the doctest, and something along these lines would be fine a normal
    test. But in a docstring example, it is much clearer to just show the actual output
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过了文档测试，而类似这样的内容在正常测试中是可以接受的。但在文档字符串示例中，直接显示实际输出会更清晰。
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, in some situations, the full output is unwieldy and showing it would
    make the example harder to read, so this sort of thing may be appropriate. Use
    your best judgment, keeping in mind that the understandability of the doctest
    as a *documentation example* is the most important thing. In some extreme instances,
    it may be preferable to just skip testing an example (see [below](#writing-tests-doctest-skip))
    rather than writing it in a convoluted way that is difficult to read just to please
    the doctester.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在某些情况下，完整的输出过于笨重，显示它会使示例更难阅读，所以这种情况可能是合适的。在做出决定时，请慎重考虑，记住文档示例的可理解性是最重要的事情。在极端情况下，可能更倾向于跳过测试示例而不是为了迎合文档测试而写成难以阅读的方式（见[下文](#writing-tests-doctest-skip)）。
- en: 'Here are some additional tips for writing doctests:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编写文档测试的额外提示：
- en: Long input lines can be broken into multiple lines by using `...` as a continuation
    prompt, as in the example above. The doctest runner also allows long outputs to
    be line wrapped (it ignores newlines in the output).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用 `...` 作为续行提示将长输入行分成多行，如上例所示。文档测试运行器还允许将长输出行进行换行（忽略输出中的换行符）。
- en: Common symbol names can be imported from `sympy.abc`. Uncommon symbol names
    or symbols that use assumptions should be defined using `symbols`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的符号名称可以从 `sympy.abc` 导入。不常见的符号名称或需要使用假设的符号应该使用 `symbols` 进行定义。
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If a test shows a traceback, everything between `Traceback (most recent call
    last):` and the last line with the exception message should be replaced with `...`,
    like
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试显示了回溯信息，则应将 `Traceback (most recent call last):` 和最后一行异常消息之间的所有内容替换为 `...`，例如
- en: '[PRE37]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`...` is special in that whenever it appears in the output of an example, the
    doctester will allow it to replace any amount of text. It should also be used
    in instances where the exact output differs between runs, like'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`...` 是特殊的，每当它出现在示例的输出中时，文档测试器都允许其替换任意数量的文本。在确切输出在运行之间不同的情况下，也应使用它，例如'
- en: '[PRE38]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here the actual output is something like `<function simplify at 0x10e997790>`
    but the `0x10e997790` is a memory address which will differ with every Python
    session.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里实际输出类似于 `<function simplify at 0x10e997790>`，但 `0x10e997790` 是一个内存地址，每个Python会话都会不同。
- en: '`...` in outputs should be used sparingly, as it prevents the doctest from
    actually checking that part of the output. It also may not be clear to the reader
    of the documentation what it is meant. Note that it’s fine if the output of a
    doctest is updated to something else in the future. `...` should not be used in
    an attempt to “future-proof” doctest output. Also note that the doctester already
    automatically handles things like whitespace-only differences in the output and
    floating-point values.'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出中的 `...` 应该谨慎使用，因为它会阻止文档测试实际检查输出的那部分。对文档的读者来说，可能不清楚它的含义。请注意，如果将来文档测试的输出更新为其他内容是可以的。`...`
    不应用于试图“未来保护”文档测试输出。还请注意，文档测试器已经自动处理输出中的空白差异和浮点数值。
- en: 'You can line break output lines. The doctester automatically ignores whitespace-only
    differences in the output, which includes newlines. Long lines should be broken
    so that they do not extend beyond the page in the HTML documentation (and so that
    the source code does not have lines longer than 80 characters). For example:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在输出行中进行换行。文档测试器会自动忽略输出中的空白差异，包括换行符。长行应该被打断，以避免在HTML文档中超出页面（并确保源代码行不超过80个字符）。例如：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Another option if a doctest cannot pass is to skip it, by adding `# doctest:+SKIP`
    to the end of the input line, like
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文档测试不能通过，另一种选择是通过在输入行的末尾添加 `# doctest:+SKIP` 来跳过它，例如
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `# doctest:+SKIP` part will be automatically hidden in the HTML documentation.
    When skipping a doctest, always be sure to test the output manually, as the doctester
    will not check it for you.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`# doctest:+SKIP` 部分会在HTML文档中自动隐藏。在跳过文档测试时，务必手动测试输出，因为文档测试器不会为您检查它。'
- en: '`# doctest:+SKIP` should be used sparingly. Ideally a doctest should only be
    skipped when it is impossible to run it. A doctest that is skipped will never
    be tested, meaning it may become outdated (i.e., incorrect), which will be confusing
    to users.'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该谨慎使用 `# doctest:+SKIP`。理想情况下，只有当无法运行时才应跳过文档测试。跳过的文档测试永远不会被测试，这意味着它可能会过时（即不正确），这会让用户感到困惑。
- en: 'Doctests that require a dependency to run should not be skipped with `# doctest:
    +SKIP`. Instead, use the [`@doctest_depends_on`](../../modules/utilities/decorator.html#sympy.utilities.decorator.doctest_depends_on
    "sympy.utilities.decorator.doctest_depends_on") decorator on the function to indicate
    which libraries should be installed for the doctest to run.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '需要依赖项才能运行的doctest不应该用`# doctest: +SKIP`跳过。相反，应该在函数上使用[`@doctest_depends_on`](../../modules/utilities/decorator.html#sympy.utilities.decorator.doctest_depends_on
    "sympy.utilities.decorator.doctest_depends_on")装饰器来指示为了运行doctest应该安装哪些库。'
- en: If the test output includes a blank line, use `<BLANKLINE>` in place of the
    blank line. Otherwise the doctester will think that the output ends at the blank
    line. `<BLANKLINE>` will be automatically hidden in the HTML documentation. This
    is not common as most SymPy objects do not print with blank lines.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试输出包含空行，请用`<BLANKLINE>`代替空行。否则，doctester会认为输出在空行结束。`<BLANKLINE>`会在HTML文档中自动隐藏。这种情况并不常见，因为大多数SymPy对象不会打印出空行。
- en: Avoid using `pprint()` in doctest examples. If you need to show an expression
    in an easier to read way, you can include it inline as LaTeX math using dollar
    signs. If you absolutely must use `pprint()`, always use `pprint(use_unicode=False)`
    as the Unicode characters used for pretty printing do not always render correctly
    in the HTML documentation.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在doctest示例中使用`pprint()`。如果你需要以更易读的方式显示表达式，可以使用美元符号内联包含LaTeX数学。如果你绝对必须使用`pprint()`，请始终使用`pprint(use_unicode=False)`，因为用于漂亮打印的Unicode字符在HTML文档中的呈现不总是正确的。
- en: If you want to show that something returns `None` use `print`, like
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想显示某些东西返回`None`，可以使用`print`，比如
- en: '[PRE41]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can add short comments to doctests, either at the end of a line or by themselves
    after `>>>`. However, these should typically be only a few words long. Detailed
    explanations of what is happening in the doctest should go in the surrounding
    text.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在doctest中添加简短的注释，可以是在一行的末尾或者在`>>>`之后单独使用。然而，这些注释通常应该只有几个词。关于doctest中发生的事情的详细解释应该放在周围的文本中。
- en: Dictionaries and sets are automatically sorted by the doctester, and any expressions
    are automatically sorted so that the order of terms is always printed in the same
    way. Usually you can just include the output that the doctester “expects” it and
    it will always pass subsequently.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典和集合会被doctester自动排序，任何表达式都会自动排序，以便术语的顺序总是以相同的方式打印。通常你可以只包含doctester“预期”的输出，它将随后总是通过。
- en: '[PRE42]  ## Updating Existing Tests'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE42]  ## 更新现有测试'
- en: Sometimes when you change something or fix a bug, some existing tests will fail.
    If this happens, you should check the test to see why it is failing. In many cases,
    the test will be checking for something you didn’t consider, or your change has
    an unexpected side effect that broke something else. When this happens, you may
    need to revisit your change. If you are unsure what to do, you should discuss
    it on the issue or pull request.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当你改变了某些东西或者修复了一个bug，一些现有的测试会失败。如果这种情况发生，你应该检查测试看看为什么会失败。在许多情况下，测试将检查你没有考虑到的东西，或者你的变更具有意外的副作用破坏了其他东西。当这种情况发生时，你可能需要重新审视你的变更。如果你不确定该怎么做，你应该在问题或拉取请求上讨论一下。
- en: If the test that fails is a [code quality test](#code-quality-checks), that
    usually means you just need to fix your code so that it satisfies the code quality
    check (e.g., remove trailing whitespace).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败的测试是一个[代码质量测试](#code-quality-checks)，通常意味着你只需要修复代码以满足代码质量检查（例如，删除尾随空白）。
- en: Occasionally, however, it can happen that the test fails but there is nothing
    wrong. In this case, the test should be updated. The most common instance of this
    is a test that checks for a specific expression, but the function now returns
    a different, but mathematically equivalent expression. This is especially common
    with [doctests](#writing-tests-doctests), since they check not just the output
    expression but the way it is printed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，偶尔会发生测试失败但没有任何问题的情况。这种情况下，应该更新测试。最常见的情况是检查特定表达式的测试，但是函数现在返回一个不同但在数学上等价的表达式。这在[doctests](#writing-tests-doctests)中特别常见，因为它们不仅检查输出表达式，还检查打印方式。
- en: 'If a function output is mathematically equivalent, the existing test can be
    updated with the new output. However, even when doing this, you should be careful:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数的输出在数学上是等价的，现有的测试可以用新的输出进行更新。但是，即使这样做，你也应该小心：
- en: Carefully check that the new output is indeed the same. Manually check something
    like if the difference of old and new expressions simplifies to 0. Sometimes,
    two expressions are equivalent for some assumptions but not for all, so check
    that the two expressions are really the same for all complex numbers. This can
    particularly happen with expressions involving square roots or other radicals.
    You can check random numbers, or use the `equals()` method to do this.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细检查新输出确实是相同的。手动检查像是如果旧表达式和新表达式的差异简化为0。有时，两个表达式对于某些假设是等价的，但不是对于所有的，因此检查这两个表达式对于所有复数确实是相同的。这特别可能发生在涉及平方根或其他根的表达式中。你可以检查随机数，或使用`equals()`方法来做到这一点。
- en: If the new output is considerably more complicated than the old output, then
    it may not be a good idea to update the test, even if they are mathematically
    equivalent. Instead, you may need to adjust the change so that the function still
    returns the simpler result.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果新的输出比旧输出复杂得多，那么即使在数学上它们是等价的，更新测试也可能不是一个好主意。相反，你可能需要调整更改，使函数仍然返回更简单的结果。
- en: It’s not common, but it can happen that an existing test is itself incorrect.
    If a test is plain wrong, it should just be deleted, and updated.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不常见，但确实可能发生现有测试本身是错误的情况。如果一个测试是明显错误的，应该删除并更新。
- en: In any case, when updating an existing test, you should always explain the rationale
    for doing so in a commit message or in a pull request comment. Do not explain
    the change in a code comment or documentation. Code comments and documentation
    should only refer to the code as it is. Discussion of changes belongs in the commit
    messages or issue tracker. Code comments that talk about how the code used to
    be will only become confusing and won’t actually be relevant anymore once the
    change is made.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在更新现有测试时，你应该总是在提交消息或拉取请求评论中解释做出此更改的原因。不要在代码注释或文档中解释更改。代码注释和文档应该只涉及当前的代码。关于更改的讨论应该放在提交消息或问题跟踪器中。关于代码曾经如何的代码注释只会变得令人困惑，并且在更改后实际上不再相关。
- en: 'Again, the default should be to not change existing tests. The tests exist
    for a reason, and changing them defeats the purpose of having them in the first
    place. The exception to this rule is doctests, which are allowed to change or
    be removed if they improve the documentation, as the primary purpose of doctests
    is to serve as examples for users.  ## Code Quality Checks'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，默认情况下不要更改现有的测试。这些测试存在是有原因的，改变它们会背离最初的目的。这条规则的例外是doctests，如果它们改进了文档，可以允许它们被更改或删除，因为doctests的主要目的是为用户提供示例。
    ## 代码质量检查'
- en: SymPy has several code quality checks that must pass. The first job that is
    run on the CI on a pull request is the code quality checks. If this job fails,
    none of the other tests are run. Your PR may be ignored by reviewers until they
    are fixed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy有几个必须通过的代码质量检查。在拉取请求上运行的第一个任务是代码质量检查。如果此任务失败，其他测试都不会运行。直到它们被修复，你的PR可能会被审阅者忽略。
- en: The code quality checks are all straightforward to fix. You can run the checks
    locally using
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量检查都很容易修复。你可以在本地运行检查，
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: and
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This second command requires you to install `flake8`. Make sure you have the
    latest version of flake8 and its dependencies `pycodestyle` and `pyflakes` installed.
    Sometimes newer versions of these packages will add new checks and if you have
    an older version installed you won’t see the checks for them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令需要你安装`flake8`。确保你安装了最新版本的flake8及其依赖项`pycodestyle`和`pyflakes`。有时，这些包的新版本会添加新的检查，如果你安装了旧版本，你将看不到这些检查。
- en: The `./bin/test quality` check tests for very basic code quality things. The
    most common of these that will cause the test to fail is trailing whitespace.
    Trailing whitespace is when a line of code has spaces at the end of it. These
    spaces do nothing, and they only cause the code diff to be polluted. The best
    way to handle trailing whitespace is to configure your text editor to automatically
    strip trailing whitespace when you save. You can also use the `./bin/strip_whitepace`
    command in the SymPy repo.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`./bin/test quality`检查非常基本的代码质量问题。导致测试失败的最常见问题是尾随空格。尾随空格是指代码行末尾有空格。这些空格无任何作用，只会污染代码差异。处理尾随空格的最佳方法是配置文本编辑器在保存时自动去除尾随空格。你也可以在SymPy仓库中使用`./bin/strip_whitepace`命令。'
- en: 'The `flake8` command will check the code for basic code errors like undefined
    variables. These are restricted by the configuration in `setup.cfg` to only check
    for things that are logical errors. The usual flake8 checks for cosmetic style
    errors are disabled. In rare situations, a flake8 warning will be a false positive.
    If this happens, add a `# noqa: <CODE>` comment to the corresponding line, where
    `<CODE>` is the code for the error from [https://flake8.pycqa.org/en/latest/user/error-codes.html](https://flake8.pycqa.org/en/latest/user/error-codes.html).
    For example, code that uses `multipledispatch` will need to use'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`flake8` 命令会检查代码中的基本错误，如未定义变量。这些错误由 `setup.cfg` 中的配置限制，仅检查逻辑错误。通常情况下，flake8
    检查的代码风格错误是禁用的。在罕见情况下，flake8 的警告可能是误报。如果发生这种情况，请在相应行添加 `# noqa: <CODE>` 注释，其中 `<CODE>`
    是来自 [https://flake8.pycqa.org/en/latest/user/error-codes.html](https://flake8.pycqa.org/en/latest/user/error-codes.html)
    的错误代码。例如，使用 `multipledispatch` 的代码将需要使用'
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: to avoid warnings about redefining the same function multiple times.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 避免关于多次重新定义相同函数的警告。
- en: Tests Style Guide
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试风格指南
- en: In most cases, tests should be written in a way that matches the surrounding
    tests in the same test file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，测试应该以与同一测试文件中周围测试相匹配的方式编写。
- en: 'A few important stylistic points should be followed when writing tests:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时应遵循一些重要的风格点：
- en: Test functions should start with `test_`. If they do not, the test runner will
    not test them. Any helper functions which are not test functions should not start
    with `test_`. Usually it is best to start test helper functions with an underscore.
    If you find yourself reusing the same helper function for many test files, consider
    whether it should be moved to somewhere like `sympy.testing`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数应以 `test_` 开头。如果不是，测试运行器将不会测试它们。任何不是测试函数的辅助函数不应以 `test_` 开头。通常最好将测试辅助函数以下划线开头。如果发现自己在多个测试文件中重用相同的辅助函数，请考虑是否应将其移动到类似
    `sympy.testing` 的地方。
- en: Format expressions using the same whitespace that would be produced by `str()`
    (e.g., spaces around binary `+` and `-`, no spaces around `*` and `**`, space
    after comma, no redundant parentheses, etc.)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与 `str()` 生成的相同空白字符格式化表达式（例如，在二进制 `+` 和 `-` 周围加上空格，`*` 和 `**` 周围不加空格，逗号后面加空格，不要冗余的括号等）
- en: Avoid the use of Float values in test cases. Unless the test is explicitly testing
    the result of a function on floating-point inputs, test expressions should use
    exact values.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在测试用例中使用浮点值。除非测试明确测试了浮点输入上的函数结果，否则测试表达式应使用精确值。
- en: 'In particular, avoid using integer division like `1/2` that will create a float
    value (see [the gotchas section of the tutorial](../../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)).
    For example:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是要避免使用像 `1/2` 这样会创建浮点值的整数除法（参见 [教程的注意事项部分](../../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)）。例如：
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you do actually intend to explicitly test an expression with a floating-point
    value, use a float (like `0.5` instead of `1/2`) so that it is clear this is intentional
    and not accidental.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你确实打算显式测试一个带有浮点值的表达式，请使用浮点数（如`0.5`而不是`1/2`），这样可以清楚表明这是有意为之而非意外发生。
- en: Symbols may be defined at the top of the test file or within each test function.
    Symbols with assumptions that are defined at the top of the test file should be
    named in a way that makes it clear they have an assumption (e.g., `xp = Symbol('x',
    positive=True)`). It is often best to define symbols that have assumptions inside
    each test function so that they are not accidentally reused in another test that
    doesn’t expect them to have the assumption defined (which can often change the
    behavior of the test).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号可以在测试文件顶部或每个测试函数内定义。在测试文件顶部定义带有假设的符号应命名为明确表明它们具有假设的方式（例如，`xp = Symbol('x',
    positive=True)`）。通常最好在每个测试函数内定义具有假设的符号，以免它们被意外地重用在其他不希望它们具有定义假设的测试中（这通常会改变测试的行为）。
- en: Test files are typically named corresponding to the code file they test (e.g.,
    `sympy/core/tests/test_symbol.py` has the tests for `sympy/core/symbol.py`). However,
    this rule can be broken if there are tests that don’t exactly correspond to a
    specific code file.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文件通常以它们测试的代码文件命名（例如，`sympy/core/tests/test_symbol.py` 包含对 `sympy/core/symbol.py`
    的测试）。然而，如果有些测试与特定的代码文件并不完全对应，这个规则是可以打破的。
- en: Avoid using string forms of expressions in tests (obviously strings should be
    used in the printing tests; this rule applies to other types of tests). This makes
    the test depend on the exact printing output, rather than just the expression
    output. This makes the test harder to read, and if the printer is ever changed
    in some way, the test would have be updated.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中避免使用表达式的字符串形式（显然在打印测试中应该使用字符串；这条规则适用于其他类型的测试）。这会使测试依赖于精确的打印输出，而不仅仅是表达式的输出。这会使测试难以阅读，并且如果打印机以某种方式更改，测试就需要更新。
- en: 'For example:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE48]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Similarly, do not parse the string form of an expression for input (unless the
    test is explicitly testing parsing strings). Just create the expression directly.
    Even if this requires creating many symbols or extensive use of `S()` to wrap
    rationals, this is still cleaner.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样地，不要解析表达式的字符串形式作为输入（除非测试明确测试解析字符串）。直接创建表达式即可。即使这需要创建许多符号或广泛使用`S()`来包装有理数，这仍然更清晰。
- en: '[PRE50]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Use `is True`, `is False` and `is None` when testing assumptions. Don’t rely
    on truthiness, as it’s easy to forget that `None` is considered false by Python.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试假设时使用`is True`、`is False`和`is None`。不要依赖真值性，因为很容易忘记`None`在Python中被视为假。
- en: '[PRE52]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Test Coverage
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: To generate a test coverage report, first install [coverage.py](https://coverage.readthedocs.io/en/latest/)
    (e.g., with `pip install coverage`). Then run
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成测试覆盖报告，首先安装[coverage.py](https://coverage.readthedocs.io/en/latest/)（例如，使用`pip
    install coverage`）。然后运行
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will run the test suite and analyze which lines of the codebase are covered
    by at least one test. Note that this will take longer than running the tests normally
    with `./bin/test` because the coverage tooling makes Python run a little bit slower.
    You can also run a subset of the tests, e.g., `./bin/coverage_report.py sympy/solvers`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行测试套件并分析代码库中哪些行至少被一个测试覆盖。请注意，这比使用`./bin/test`正常运行测试需要更长时间，因为覆盖工具会使Python运行稍慢。您也可以运行测试的子集，例如`./bin/coverage_report.py
    sympy/solvers`。
- en: Once the tests are done, the coverage report will be in `covhtml`, which you
    can view by opening `covhtml/index.html`. Each file will show which lines were
    covered by a test (in green) and which were not covered by any test (in red).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试完成，覆盖报告将位于`covhtml`中，您可以通过打开`covhtml/index.html`来查看。每个文件将显示哪些行被测试覆盖（绿色显示），哪些行没有被任何测试覆盖（红色显示）。
- en: Lines that are not covered by any test should have a test added for them, if
    possible. Note that 100% coverage is generally impossible. There may be a line
    of defensive code that checks if something has gone wrong, but which would only
    be triggered if there is a bug. Or there may be some functionality that is simply
    too hard to test (e.g., some code that interfaces with [external dependencies](../dependencies.html#optional-dependencies)),
    or that is only triggered when a given optional dependency is installed. However,
    if a line of code can be tested, it should be. And, for instance, the test files
    themselves should have 100% coverage. If a line in a test file is not covered,
    that generally indicates a mistake (see [https://nedbatchelder.com/blog/202008/you_should_include_your_tests_in_coverage.html](https://nedbatchelder.com/blog/202008/you_should_include_your_tests_in_coverage.html)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，应为未被任何测试覆盖的行添加测试。注意，通常不可能实现100%的覆盖率。可能会有一行防御性代码，用于检查是否出现错误，但仅在出现错误时才会触发。或者可能会有一些与[外部依赖](../dependencies.html#optional-dependencies)交互的代码，或者只有在安装了特定的可选依赖项时才会触发。然而，如果一行代码可以测试，就应该进行测试。例如，测试文件本身应该实现100%的覆盖率。如果测试文件中的一行未被覆盖，通常这表示一个错误（参见[https://nedbatchelder.com/blog/202008/you_should_include_your_tests_in_coverage.html](https://nedbatchelder.com/blog/202008/you_should_include_your_tests_in_coverage.html)）。
- en: Also be aware that coverage is not the end of the story. While a line of code
    that is not tested has no guarantees of being correct, a line of code that is
    covered is not guaranteed to be correct either. Maybe it is only tested for general
    inputs, but not for corner cases. Sometimes code may have a conditional, like
    `if a or b`, and `a` is always true in every test, so that the `b` condition is
    never tested. And of course, just because a line of code is executed, doesn’t
    mean that is correct. The test needs to actually check that the output of the
    function is what it is supposed to be. Test coverage is just one part of ensuring
    the correctness of a codebase. See [https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html](https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，覆盖率并不是结束的全部。虽然未测试的代码行无法保证正确性，但覆盖的代码行也不一定正确。有时代码可能有条件，比如`if a or b`，并且在每个测试中`a`总是为真，所以`b`条件从未被测试过。当然，仅因为代码行被执行，并不意味着它是正确的。测试需要实际检查函数的输出是否符合预期。测试覆盖率只是确保代码库正确性的一部分。参见[https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html](https://nedbatchelder.com/blog/200710/flaws_in_coverage_measurement.html)。
- en: Hypothesis Testing
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设测试
- en: 'Property based tests can now be created using the [Hypothesis](https://hypothesis.readthedocs.io/en/latest/quickstart.html)
    library. Tests should be added to the `test_hypothesis.py` file in the respective
    `tests` subdirectory. If the file does not exist, create one. Below is an example
    of hypothesis test for modular arithmetic:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用[Hypothesis](https://hypothesis.readthedocs.io/en/latest/quickstart.html)库创建基于属性的测试。测试应添加到相应的`tests`子目录中的`test_hypothesis.py`文件中。如果文件不存在，请创建一个。以下是模数算术的假设测试示例：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
