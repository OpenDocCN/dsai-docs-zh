- en: numpy.take
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.take.html](https://numpy.org/doc/1.26/reference/generated/numpy.take.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Take elements from an array along an axis.
  prefs: []
  type: TYPE_NORMAL
- en: When axis is not None, this function does the same thing as “fancy” indexing
    (indexing arrays using arrays); however, it can be easier to use if you need elements
    along a given axis. A call such as `np.take(arr, indices, axis=3)` is equivalent
    to `arr[:,:,:,indices,...]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explained without fancy indexing, this is equivalent to the following use of
    [`ndindex`](numpy.ndindex.html#numpy.ndindex "numpy.ndindex"), which sets each
    of `ii`, `jj`, and `kk` to a tuple of indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**array_like (Ni…, M, Nk…)'
  prefs: []
  type: TYPE_NORMAL
- en: The source array.
  prefs: []
  type: TYPE_NORMAL
- en: '**indices**array_like (Nj…)'
  prefs: []
  type: TYPE_NORMAL
- en: The indices of the values to extract.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: Also allow scalars for indices.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The axis over which to select values. By default, the flattened input array
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**out**ndarray, optional (Ni…, Nj…, Nk…)'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, the result will be placed in this array. It should be of the appropriate
    shape and dtype. Note that *out* is always buffered if *mode=’raise’*; use other
    modes for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**mode**{‘raise’, ‘wrap’, ‘clip’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies how out-of-bounds indices will behave.
  prefs: []
  type: TYPE_NORMAL
- en: ‘raise’ – raise an error (default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘wrap’ – wrap around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘clip’ – clip to the range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘clip’ mode means that all indices that are too large are replaced by the index
    that addresses the last element along that axis. Note that this disables indexing
    with negative numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out**ndarray (Ni…, Nj…, Nk…)'
  prefs: []
  type: TYPE_NORMAL
- en: The returned array has the same type as *a*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`compress`](numpy.compress.html#numpy.compress "numpy.compress")'
  prefs: []
  type: TYPE_NORMAL
- en: Take elements using a boolean mask
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.take`](numpy.ndarray.take.html#numpy.ndarray.take "numpy.ndarray.take")'
  prefs: []
  type: TYPE_NORMAL
- en: equivalent method
  prefs: []
  type: TYPE_NORMAL
- en: '[`take_along_axis`](numpy.take_along_axis.html#numpy.take_along_axis "numpy.take_along_axis")'
  prefs: []
  type: TYPE_NORMAL
- en: Take elements by matching the array and the index arrays
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'By eliminating the inner loop in the description above, and using [`s_`](numpy.s_.html#numpy.s_
    "numpy.s_") to build simple slice objects, [`take`](#numpy.take "numpy.take")
    can be expressed in terms of applying fancy indexing to each 1-d slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For this reason, it is equivalent to (but faster than) the following use of
    [`apply_along_axis`](numpy.apply_along_axis.html#numpy.apply_along_axis "numpy.apply_along_axis"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example if *a* is an ndarray, “fancy” indexing can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If [`indices`](numpy.indices.html#numpy.indices "numpy.indices") is not one
    dimensional, the output also has these dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
