- en: Comparison with SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 SQL 比较
- en: 原文：[https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html](https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html](https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html)
- en: Since many potential pandas users have some familiarity with [SQL](https://en.wikipedia.org/wiki/SQL),
    this page is meant to provide some examples of how various SQL operations would
    be performed using pandas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多潜在的 pandas 用户对 [SQL](https://en.wikipedia.org/wiki/SQL) 有一定的了解，本页旨在提供使用
    pandas 执行各种 SQL 操作的一些示例。
- en: If you’re new to pandas, you might want to first read through [10 Minutes to
    pandas](../../user_guide/10min.html#min) to familiarize yourself with the library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 pandas 的新手，你可能想先阅读 [10 分钟入门 pandas](../../user_guide/10min.html#min) 来熟悉这个库。
- en: 'As is customary, we import pandas and NumPy as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 惯例上，我们导入 pandas 和 NumPy 如下：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most of the examples will utilize the `tips` dataset found within pandas tests.
    We’ll read the data into a DataFrame called `tips` and assume we have a database
    table of the same name and structure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数示例将利用 pandas 测试中找到的 `tips` 数据集。我们将数据读入一个名为 `tips` 的 DataFrame，并假设我们有一个具有相同名称和结构的数据库表。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Copies vs. in place operations
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制 vs. 原地操作
- en: 'Most pandas operations return copies of the `Series`/`DataFrame`. To make the
    changes “stick”, you’ll need to either assign to a new variable:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 pandas 操作返回 `Series`/`DataFrame` 的副本。要使更改“生效”，你需要将其分配给一个新变量：
- en: '[PRE2]'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'or overwrite the original one:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 或者覆盖原始的：
- en: '[PRE3]'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will see an `inplace=True` or `copy=False` keyword argument available for
    some methods:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些方法（如 `dropna`），可以看到一个 `inplace=True` 或 `copy=False` 的关键字参数：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is an active discussion about deprecating and removing `inplace` and `copy`
    for most methods (e.g. `dropna`) except for a very small subset of methods (including
    `replace`). Both keywords won’t be necessary anymore in the context of Copy-on-Write.
    The proposal can be found [here](https://github.com/pandas-dev/pandas/pull/51466).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有关取消和移除大多数方法（例如 `dropna`）的 `inplace` 和 `copy` 的活跃讨论，除了非常小的一部分方法（包括 `replace`）之外，这两个关键字在
    Copy-on-Write 的上下文中将不再需要。提案可以在 [这里](https://github.com/pandas-dev/pandas/pull/51466)
    找到。
- en: SELECT
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELECT
- en: 'In SQL, selection is done using a comma-separated list of columns you’d like
    to select (or a `*` to select all columns):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，使用逗号分隔的列列表来进行选择（或者使用 `*` 来选择所有列）：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With pandas, column selection is done by passing a list of column names to
    your DataFrame:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas，列选择是通过将列名列表传递给你的 DataFrame 完成的：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calling the DataFrame without the list of column names would display all columns
    (akin to SQL’s `*`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有列名列表的情况下调用 DataFrame 将显示所有列（类似于 SQL 的 `*`）。
- en: 'In SQL, you can add a calculated column:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，你可以添加一个计算列：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With pandas, you can use the [`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method of a DataFrame to append a new column:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pandas，你可以使用 DataFrame 的 [`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") 方法来追加一个新列：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: WHERE
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WHERE
- en: Filtering in SQL is done via a WHERE clause.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，过滤是通过 WHERE 子句完成的。
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: DataFrames can be filtered in multiple ways; the most intuitive of which is
    using [boolean indexing](../../user_guide/indexing.html#indexing-boolean).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrames 可以以多种方式进行过滤；其中最直观的是使用 [布尔索引](../../user_guide/indexing.html#indexing-boolean)。
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The above statement is simply passing a `Series` of `True`/`False` objects to
    the DataFrame, returning all rows with `True`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句简单地将一系列 `True`/`False` 对象传递给 DataFrame，返回所有带有 `True` 的行。
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just like SQL’s `OR` and `AND`, multiple conditions can be passed to a DataFrame
    using `|` (`OR`) and `&` (`AND`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SQL 的 `OR` 和 `AND` 一样，可以使用 `|`（`OR`）和 `&`（`AND`）将多个条件传递给 DataFrame。
- en: 'Tips of more than $5 at Dinner meals:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 晚餐小费超过 $5 的提示：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Tips by parties of at least 5 diners OR bill total was more than $45:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有 5 名用餐者的小费或者账单总额超过 $45 的小费：
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: NULL checking is done using the [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") and [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") 和 [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") 方法进行 NULL 检查。
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Assume we have a table of the same structure as our DataFrame above. We can
    see only the records where `col2` IS NULL with the following query:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个与上面的 DataFrame 结构相同的表。我们可以使用以下查询仅查看 `col2` 为 NULL 的记录：
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting items where `col1` IS NOT NULL can be done with [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") 来获取 `col1` IS NOT NULL 的项目。
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: GROUP BY
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP BY
- en: In pandas, SQL’s `GROUP BY` operations are performed using the similarly named
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method. [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") typically refers to a process where we’d like to split
    a dataset into groups, apply some function (typically aggregation) , and then
    combine the groups together.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，SQL 的 `GROUP BY` 操作是使用同名的 [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") 方法执行的。[`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") 通常指的是将数据集拆分为组，应用某些函数（通常是聚合函数），然后将组合并在一起的过程。
- en: 'A common SQL operation would be getting the count of records in each group
    throughout a dataset. For instance, a query getting us the number of tips left
    by sex:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的 SQL 操作是在数据集中获取每个组中记录的计数。例如，一个查询可以获取性别留下的小费数目：
- en: '[PRE21]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The pandas equivalent would be:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的等价方法将是：
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that in the pandas code we used [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") and not [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count"). This is because [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") applies the function to each column,
    returning the number of `NOT NULL` records within each.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 pandas 代码中我们使用了 [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") 而不是 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count")。这是因为 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") 将函数应用于每列，返回每列中的 `NOT NULL` 记录数。
- en: '[PRE23]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, we could have applied the [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") method to an individual column:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") 方法应用于单个列：
- en: '[PRE24]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiple functions can also be applied at once. For instance, say we’d like
    to see how tip amount differs by day of the week - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") allows you to pass a dictionary to
    your grouped DataFrame, indicating which functions to apply to specific columns.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以一次应用多个函数。例如，假设我们想看到小费金额如何随一周中的日期而异 - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") 允许您将字典传递给您的分组 DataFrame，指示要应用于特定列的函数。
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Grouping by more than one column is done by passing a list of columns to the
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列的列表传递给 [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") 方法来进行按多列分组。
- en: '[PRE27]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '## JOIN'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '## JOIN'
- en: '`JOIN`s can be performed with [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") or [`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge"). By default, [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") will join the DataFrames on their indices. Each method
    has parameters allowing you to specify the type of join to perform (`LEFT`, `RIGHT`,
    `INNER`, `FULL`) or the columns to join on (column names or indices).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") 或 [`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge") 执行 `JOIN`。默认情况下，[`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") 将在它们的索引上连接数据框。每种方法都有参数，允许您指定要执行的连接类型（`LEFT`、`RIGHT`、`INNER`、`FULL`）或要连接的列（列名或索引）。
- en: Warning
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If both key columns contain rows where the key is a null value, those rows will
    be matched against each other. This is different from usual SQL join behaviour
    and can lead to unexpected results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个关键列都包含键为null值的行，则这些行将相互匹配。这与通常的SQL连接行为不同，可能会导致意外结果。
- en: '[PRE29]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Assume we have two database tables of the same name and structure as our DataFrames.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个与我们的DataFrame具有相同名称和结构的数据库表。
- en: Now let’s go over the various types of `JOIN`s.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看各种类型的`JOIN`。
- en: INNER JOIN
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内连接
- en: '[PRE30]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    还提供了参数，用于当你想要将一个DataFrame的列与另一个DataFrame的索引进行连接时。'
- en: '[PRE32]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: LEFT OUTER JOIN
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左外连接
- en: Show all records from `df1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显示所有来自`df1`的记录。
- en: '[PRE33]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: RIGHT JOIN
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右外连接
- en: Show all records from `df2`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 显示所有来自`df2`的记录。
- en: '[PRE35]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: FULL JOIN
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全连接
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: pandas还允许进行`FULL JOIN`，它显示数据集的两侧，无论连接的列是否找到匹配。截至目前，不是所有的RDBMS（MySQL）都支持`FULL
    JOIN`。
- en: Show all records from both tables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显示两个表中的所有记录。
- en: '[PRE37]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: UNION
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNION
- en: '`UNION ALL` can be performed using [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat").'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`concat()`](../../reference/api/pandas.concat.html#pandas.concat "pandas.concat")可以执行`UNION
    ALL`。
- en: '[PRE39]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: SQL’s `UNION` is similar to `UNION ALL`, however `UNION` will remove duplicate
    rows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SQL的`UNION`类似于`UNION ALL`，但`UNION`将删除重复行。
- en: '[PRE42]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In pandas, you can use [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat") in conjunction with [`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，您可以使用[`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat")与[`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates")结合使用。
- en: '[PRE43]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: LIMIT
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: '[PRE44]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: pandas equivalents for some SQL analytic and aggregate functions
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些SQL分析和聚合函数的pandas等效函数
- en: Top n rows with offset
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有偏移的前n行
- en: '[PRE46]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Top n rows per group
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个组的前n行
- en: '[PRE48]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: the same using `rank(method='first')` function
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rank(method='first')`函数也是一样的
- en: '[PRE50]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出每个性别组中（rank < 3）的小费小于2的提示。请注意，当使用`rank(method='min')`函数时，`rnk_min`对于相同的`tip`（类似于Oracle的`RANK()`函数）保持不变。
- en: '[PRE52]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: UPDATE
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: '[PRE53]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: DELETE
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: '[PRE55]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In pandas we select the rows that should remain instead of deleting them:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，我们选择应保留的行而不是删除它们：
- en: '[PRE56]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Copies vs. in place operations
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制与原地操作
- en: 'Most pandas operations return copies of the `Series`/`DataFrame`. To make the
    changes “stick”, you’ll need to either assign to a new variable:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数pandas操作返回`Series`/`DataFrame`的副本。要使更改“生效”，您需要将其分配给一个新变量：
- en: '[PRE57]'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'or overwrite the original one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或覆盖原始数据：
- en: '[PRE58]'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will see an `inplace=True` or `copy=False` keyword argument available for
    some methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些方法，您将看到一个可用的`inplace=True`或`copy=False`关键字参数：
- en: '[PRE59]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There is an active discussion about deprecating and removing `inplace` and `copy`
    for most methods (e.g. `dropna`) except for a very small subset of methods (including
    `replace`). Both keywords won’t be necessary anymore in the context of Copy-on-Write.
    The proposal can be found [here](https://github.com/pandas-dev/pandas/pull/51466).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在大多数方法（例如`dropna`）中弃用和移除`inplace`和`copy`进行了活跃的讨论，除了一小部分方法（包括`replace`）。在写时复制的情况下，这两个关键字将不再是必需的。提案可以在[这里](https://github.com/pandas-dev/pandas/pull/51466)找到。
- en: SELECT
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择
- en: 'In SQL, selection is done using a comma-separated list of columns you’d like
    to select (or a `*` to select all columns):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，使用逗号分隔的列列表来进行选择（或使用`*`选择所有列）：
- en: '[PRE60]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'With pandas, column selection is done by passing a list of column names to
    your DataFrame:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，通过将列名列表传递给DataFrame来进行列选择：
- en: '[PRE61]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Calling the DataFrame without the list of column names would display all columns
    (akin to SQL’s `*`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用不带列名列表的DataFrame将显示所有列（类似于SQL的`*`）。
- en: 'In SQL, you can add a calculated column:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，您可以添加一个计算列：
- en: '[PRE62]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With pandas, you can use the [`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method of a DataFrame to append a new column:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在pandas中，您可以使用DataFrame的[`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign")方法来附加一个新列：
- en: '[PRE63]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: WHERE
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WHERE
- en: Filtering in SQL is done via a WHERE clause.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，过滤是通过 WHERE 子句完成的。
- en: '[PRE64]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: DataFrames can be filtered in multiple ways; the most intuitive of which is
    using [boolean indexing](../../user_guide/indexing.html#indexing-boolean).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 可以通过多种方式进行过滤；其中最直观的是使用[布尔索引](../../user_guide/indexing.html#indexing-boolean)。
- en: '[PRE65]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The above statement is simply passing a `Series` of `True`/`False` objects to
    the DataFrame, returning all rows with `True`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句简单地将 `True`/`False` 对象的 `Series` 传递给 DataFrame，返回所有具有 `True` 的行。
- en: '[PRE66]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Just like SQL’s `OR` and `AND`, multiple conditions can be passed to a DataFrame
    using `|` (`OR`) and `&` (`AND`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 SQL 的 `OR` 和 `AND` 一样，可以使用 `|`（`OR`）和 `&`（`AND`）将多个条件传递给 DataFrame。
- en: 'Tips of more than $5 at Dinner meals:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 晚餐小费超过 $5：
- en: '[PRE67]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Tips by parties of at least 5 diners OR bill total was more than $45:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 5 人以上的派对小费或者账单总额超过 $45：
- en: '[PRE69]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: NULL checking is done using the [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") and [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") methods.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") 和 [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") 方法进行 NULL 检查。
- en: '[PRE71]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Assume we have a table of the same structure as our DataFrame above. We can
    see only the records where `col2` IS NULL with the following query:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一张与上面 DataFrame 结构相同的表格。我们可以使用以下查询仅查看 `col2` 为空的记录：
- en: '[PRE72]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Getting items where `col1` IS NOT NULL can be done with [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna").
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") 可以获取 `col1` 不为空的项。
- en: '[PRE74]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: GROUP BY
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP BY
- en: In pandas, SQL’s `GROUP BY` operations are performed using the similarly named
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method. [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") typically refers to a process where we’d like to split
    a dataset into groups, apply some function (typically aggregation) , and then
    combine the groups together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，使用同名的 [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") 方法执行 SQL 的 `GROUP BY` 操作。[`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") 通常指的是将数据集拆分为组，应用某些函数（通常是聚合），然后将组合并在一起的过程。
- en: 'A common SQL operation would be getting the count of records in each group
    throughout a dataset. For instance, a query getting us the number of tips left
    by sex:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的 SQL 操作是获取数据集中每个组中记录的计数。例如，一个查询可以获取按性别留下的小费数量：
- en: '[PRE76]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The pandas equivalent would be:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 中的等效操作将是：
- en: '[PRE77]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Notice that in the pandas code we used [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") and not [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count"). This is because [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") applies the function to each column,
    returning the number of `NOT NULL` records within each.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 pandas 代码中，我们使用的是 [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") 而不是 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count")。这是因为 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") 将函数应用于每列，返回每列中 `NOT NULL` 记录的数量。
- en: '[PRE78]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Alternatively, we could have applied the [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") method to an individual column:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将 [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") 方法应用于单个列：
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Multiple functions can also be applied at once. For instance, say we’d like
    to see how tip amount differs by day of the week - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") allows you to pass a dictionary to
    your grouped DataFrame, indicating which functions to apply to specific columns.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以一次应用多个函数。例如，假设我们想看到小费金额如何随一周中的日期而变化 - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg")允许您向分组的数据框传递一个字典，指示要应用于特定列的函数。
- en: '[PRE80]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Grouping by more than one column is done by passing a list of columns to the
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列的列表传递给[`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby")方法，可以按多个列进行分组。
- en: '[PRE82]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '## JOIN'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '## JOIN'
- en: '`JOIN`s can be performed with [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") or [`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge"). By default, [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") will join the DataFrames on their indices. Each method
    has parameters allowing you to specify the type of join to perform (`LEFT`, `RIGHT`,
    `INNER`, `FULL`) or the columns to join on (column names or indices).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join")或[`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge")执行`JOIN`。默认情况下，[`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join")将在它们的索引上连接数据框。每种方法都有参数，允许您指定要执行的连接类型（`LEFT`、`RIGHT`、`INNER`、`FULL`）或要连接的列（列名或索引）。
- en: Warning
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If both key columns contain rows where the key is a null value, those rows will
    be matched against each other. This is different from usual SQL join behaviour
    and can lead to unexpected results.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个关键列都包含键为null值的行，则这些行将相互匹配。这与通常的SQL连接行为不同，可能会导致意外结果。
- en: '[PRE84]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Assume we have two database tables of the same name and structure as our DataFrames.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个与我们的数据框相同名称和结构的数据库表。
- en: Now let’s go over the various types of `JOIN`s.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来了解各种类型的`JOIN`。
- en: INNER JOIN
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INNER JOIN
- en: '[PRE85]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")还提供参数，用于在您希望将一个数据框的列与另一个数据框的索引进行连接的情况。'
- en: '[PRE87]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: LEFT OUTER JOIN
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LEFT OUTER JOIN
- en: Show all records from `df1`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`df1`中的所有记录。
- en: '[PRE88]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: RIGHT JOIN
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIGHT JOIN
- en: Show all records from `df2`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`df2`中的所有记录。
- en: '[PRE90]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: FULL JOIN
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FULL JOIN
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: pandas还允许进行`FULL JOIN`，它会显示数据集的两侧，无论连接列是否找到匹配。截至目前，不是所有的RDBMS（MySQL）都支持`FULL
    JOIN`。
- en: Show all records from both tables.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 显示两个表中的所有记录。
- en: '[PRE92]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: INNER JOIN
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INNER JOIN
- en: '[PRE94]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")还提供参数，用于在您希望将一个数据框的列与另一个数据框的索引进行连接的情况。'
- en: '[PRE96]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: LEFT OUTER JOIN
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LEFT OUTER JOIN
- en: Show all records from `df1`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`df1`中的所有记录。
- en: '[PRE97]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: RIGHT JOIN
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RIGHT JOIN
- en: Show all records from `df2`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`df2`中的所有记录。
- en: '[PRE99]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: FULL JOIN
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FULL JOIN
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: pandas还允许进行`FULL JOIN`，它会显示数据集的两侧，无论连接列是否找到匹配。截至目前，不是所有的RDBMS（MySQL）都支持`FULL
    JOIN`。
- en: Show all records from both tables.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 显示两个表中的所有记录。
- en: '[PRE101]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: UNION
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNION
- en: '`UNION ALL` can be performed using [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat").'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`concat()`](../../reference/api/pandas.concat.html#pandas.concat "pandas.concat")执行`UNION
    ALL`。
- en: '[PRE103]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: SQL’s `UNION` is similar to `UNION ALL`, however `UNION` will remove duplicate
    rows.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: SQL的`UNION`类似于`UNION ALL`，但`UNION`会删除重复行。
- en: '[PRE106]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In pandas, you can use [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat") in conjunction with [`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates").
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，您可以结合使用 [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat") 和 [`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates")。
- en: '[PRE107]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: LIMIT
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: '[PRE108]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: pandas equivalents for some SQL analytic and aggregate functions
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pandas 中一些 SQL 分析和聚合函数的等效函数
- en: Top n rows with offset
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有偏移的前 n 行
- en: '[PRE110]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Top n rows per group
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个组的前 n 行
- en: '[PRE112]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: the same using `rank(method='first')` function
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rank(method='first')` 函数相同
- en: '[PRE114]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到每个性别组中 (rank < 3) 的小费，对于 (tips < 2)。请注意，当使用 `rank(method='min')` 函数时，相同
    `tip` 的 `rnk_min` 保持不变（类似于 Oracle 的 `RANK()` 函数）
- en: '[PRE116]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Top n rows with offset
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有偏移的前 n 行
- en: '[PRE117]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Top n rows per group
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个组的前 n 行
- en: '[PRE119]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: the same using `rank(method='first')` function
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rank(method='first')` 函数相同
- en: '[PRE121]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找到每个性别组中 (rank < 3) 的小费，对于 (tips < 2)。请注意，当使用 `rank(method='min')` 函数时，相同
    `tip` 的 `rnk_min` 保持不变（类似于 Oracle 的 `RANK()` 函数）
- en: '[PRE123]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: UPDATE
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: '[PRE124]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: DELETE
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: '[PRE126]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In pandas we select the rows that should remain instead of deleting them:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 中，我们选择应该保留的行，而不是删除它们：
- en: '[PRE127]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
