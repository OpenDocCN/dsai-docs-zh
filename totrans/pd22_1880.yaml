- en: pandas docstring guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/development/contributing_docstring.html](https://pandas.pydata.org/docs/development/contributing_docstring.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## About docstrings and standards'
  prefs: []
  type: TYPE_NORMAL
- en: A Python docstring is a string used to document a Python module, class, function
    or method, so programmers can understand what it does without having to read the
    details of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is a common practice to generate online (html) documentation automatically
    from docstrings. [Sphinx](https://www.sphinx-doc.org) serves this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example gives an idea of what a docstring looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some standards regarding docstrings exist, which make them easier to read, and
    allow them be easily exported to other formats such as html or pdf.
  prefs: []
  type: TYPE_NORMAL
- en: The first conventions every Python docstring should follow are defined in [PEP-257](https://www.python.org/dev/peps/pep-0257/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As PEP-257 is quite broad, other more specific standards also exist. In the
    case of pandas, the NumPy docstring convention is followed. These conventions
    are explained in this document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[numpydoc docstring guide](https://numpydoc.readthedocs.io/en/latest/format.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: numpydoc is a Sphinx extension to support the NumPy docstring convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard uses reStructuredText (reST). reStructuredText is a markup language
    that allows encoding styles in plain text files. Documentation about reStructuredText
    can be found in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sphinx reStructuredText primer](https://www.sphinx-doc.org/en/stable/rest.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quick reStructuredText reference](https://docutils.sourceforge.io/docs/user/rst/quickref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Full reStructuredText specification](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas has some helpers for sharing docstrings between related classes, see
    [Sharing docstrings](#docstring-sharing).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this document will summarize all the above guidelines, and will
    provide additional conventions specific to the pandas project.
  prefs: []
  type: TYPE_NORMAL
- en: '## Writing a docstring'
  prefs: []
  type: TYPE_NORMAL
- en: '### General rules'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings must be defined with three double-quotes. No blank lines should be
    left before or after the docstring. The text starts in the next line after the
    opening quotes. The closing quotes have their own line (meaning that they are
    not at the end of the last sentence).
  prefs: []
  type: TYPE_NORMAL
- en: 'On rare occasions reST styles like bold text or italics will be used in docstrings,
    but is it common to have inline code, which is presented between backticks. The
    following are considered inline code:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code, a module, function, built-in, type, literal… (e.g. `os`, `list`,
    `numpy.abs`, `datetime.date`, `True`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas class (in the form `:class:`pandas.Series``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas method (in the form `:meth:`pandas.Series.sum``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas function (in the form `:func:`pandas.to_datetime``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To display only the last component of the linked class, method or function,
    prefix it with `~`. For example, `:class:`~pandas.Series`` will link to `pandas.Series`
    but only display the last part, `Series` as the link text. See [Sphinx cross-referencing
    syntax](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]  ### Section 1: short summary'
  prefs: []
  type: TYPE_NORMAL
- en: The short summary is a single sentence that expresses what the function does
    in a concise way.
  prefs: []
  type: TYPE_NORMAL
- en: The short summary must start with a capital letter, end with a dot, and fit
    in a single line. It needs to express what the object does without providing details.
    For functions and methods, the short summary must start with an infinitive verb.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]  ### Section 2: extended summary'
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary provides details on what the function does. It should not
    go into the details of the parameters, or discuss implementation notes, which
    go in other sections.
  prefs: []
  type: TYPE_NORMAL
- en: A blank line is left between the short summary and the extended summary. Every
    paragraph in the extended summary ends with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary should provide details on why the function is useful and
    their use cases, if it is not too generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]  ### Section 3: parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The details of the parameters will be added in this section. This section has
    the title “Parameters”, followed by a line with a hyphen under each letter of
    the word “Parameters”. A blank line is left before the section title, but not
    after, and not between the line with the word “Parameters” and the one with the
    hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: After the title, each parameter in the signature must be documented, including
    `*args` and `**kwargs`, but not `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters are defined by their name, followed by a space, a colon, another
    space, and the type (or types). Note that the space between the name and the colon
    is important. Types are not defined for `*args` and `**kwargs`, but must be defined
    for all other parameters. After the parameter definition, it is required to have
    a line with the parameter description, which is indented, and can have multiple
    lines. The description must start with a capital letter, and finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: For keyword arguments with a default value, the default will be listed after
    a comma at the end of the type. The exact form of the type in this case will be
    “int, default 0”. In some cases it may be useful to explain what the default argument
    means, which can be added after a comma “int, default -1, meaning all cpus”.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the default value is `None`, meaning that the value will not
    be used. Instead of `"str, default None"`, it is preferred to write `"str, optional"`.
    When `None` is a value being used, we will keep the form “str, default None”.
    For example, in `df.to_csv(compression=None)`, `None` is not a value being used,
    but means that compression is optional, and no compression is being used if not
    provided. In this case we will use `"str, optional"`. Only in cases like `func(value=None)`
    and `None` is being used in the same way as `0` or `foo` would be used, then we
    will specify “str, int or None, default None”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#### Parameter types'
  prefs: []
  type: TYPE_NORMAL
- en: 'When specifying the parameter types, Python built-in data types can be used
    directly (the Python type is preferred to the more verbose string, integer, boolean,
    etc):'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For complex types, define the subtypes. For `dict` and `tuple`, as more than
    one type is present, we use the brackets to help read the type (curly brackets
    for `dict` and normal brackets for `tuple`):'
  prefs: []
  type: TYPE_NORMAL
- en: list of int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dict of {str : int}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str, int, int)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str,)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case where there are just a set of values allowed, list them in curly brackets
    and separated by commas (followed by a space). If the values are ordinal and they
    have an order, list them in this order. Otherwise, list the default value first,
    if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0, 10, 25}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘simple’, ‘advanced’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘low’, ‘medium’, ‘high’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘cat’, ‘dog’, ‘bird’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is defined in a Python module, the module must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: datetime.date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datetime.datetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decimal.Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is in a package, the module must be also specified:'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scipy.sparse.coo_matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is a pandas type, also specify pandas except for Series and DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.arrays.SparseArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the exact type is not relevant, but must be compatible with a NumPy array,
    array-like can be specified. If Any type that can be iterated is accepted, iterable
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: array-like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iterable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If more than one type is accepted, separate them by commas, except the last
    two types, that need to be separated by the word ‘or’:'
  prefs: []
  type: TYPE_NORMAL
- en: int or float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float, decimal.Decimal or None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str or list of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `None` is one of the accepted values, it always needs to be the last in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For axis, the convention is to use something like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'axis : {0 or ‘index’, 1 or ‘columns’, None}, default None  ### Section 4: returns
    or yields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the method returns a value, it will be documented in this section. Also if
    the method yields its output.
  prefs: []
  type: TYPE_NORMAL
- en: The title of the section will be defined in the same way as the “Parameters”.
    With the names “Returns” or “Yields” followed by a line with as many hyphens as
    the letters in the preceding word.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the return is also similar to the parameters. But in this
    case, no name will be provided, unless the method returns or yields more than
    one value (a tuple of values).
  prefs: []
  type: TYPE_NORMAL
- en: The types for “Returns” and “Yields” are the same as the ones for the “Parameters”.
    Also, the description must finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With more than one value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the method yields its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]  ### Section 5: see also'
  prefs: []
  type: TYPE_NORMAL
- en: This section is used to let users know about pandas functionality related to
    the one being documented. In rare cases, if no related methods or functions can
    be found at all, this section can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious example would be the `head()` and `tail()` methods. As `tail()` does
    the equivalent as `head()` but at the end of the `Series` or `DataFrame` instead
    of at the beginning, it is good to let the users know about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an intuition on what can be considered related, here there are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` and `iloc`, as they do the same, but in one case providing indices and
    in the other positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` and `min`, as they do the opposite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterrows`, `itertuples` and `items`, as it is easy that a user looking for
    the method to iterate over columns ends up in the method to iterate over rows,
    and vice-versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillna` and `dropna`, as both methods are used to handle missing values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_csv` and `to_csv`, as they are complementary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge` and `join`, as one is a generalization of the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`astype` and `pandas.to_datetime`, as users may be reading the documentation
    of `astype` to know how to cast as a date, and the way to do it is with `pandas.to_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where` is related to `numpy.where`, as its functionality is based on it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deciding what is related, you should mainly use your common sense and think
    about what can be useful for the users reading the documentation, especially the
    less experienced ones.
  prefs: []
  type: TYPE_NORMAL
- en: When relating to other libraries (mainly `numpy`), use the name of the module
    first (not an alias like `np`). If the function is in a module which is not the
    main one, like `scipy.sparse`, list the full module (e.g. `scipy.sparse.coo_matrix`).
  prefs: []
  type: TYPE_NORMAL
- en: This section has a header, “See Also” (note the capital S and A), followed by
    the line with hyphens and preceded by a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: After the header, we will add a line for each related method or function, followed
    by a space, a colon, another space, and a short description that illustrates what
    this method or function does, why is it relevant in this context, and what the
    key differences are between the documented function and the one being referenced.
    The description must also end with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in “Returns” and “Yields”, the description is located on the line
    after the type. In this section, however, it is located on the same line, with
    a colon in between. If the description does not fit on the same line, it can continue
    onto other lines which must be further indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]  ### Section 6: notes'
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional section used for notes about the implementation of the algorithm,
    or to document technical aspects of the function behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip it, unless you are familiar with the implementation of the
    algorithm, or you discover some counter-intuitive behavior while writing the examples
    for the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section follows the same format as the extended summary section.  ###
    Section 7: examples'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most important sections of a docstring, despite being placed
    in the last position, as often people understand concepts better by example than
    through accurate explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples in docstrings, besides illustrating the usage of the function or method,
    must be valid Python code, that returns the given output in a deterministic way,
    and that can be copied and run by users.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are presented as a session in the Python terminal. `>>>` is used to
    present code. `...` is used for code continuing from the previous line. Output
    is presented immediately after the last line of code generating the output (no
    blank lines in between). Comments describing the examples can be added with blank
    lines before and after them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to present examples is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import required libraries (except `numpy` and `pandas`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the data required for the example
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a very basic example that gives an idea of the most common use case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add examples with explanations that illustrate how the parameters can be used
    for extended functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simple example could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The examples should be as concise as possible. In cases where the complexity
    of the function requires long examples, is recommended to use blocks with headers
    in bold. Use double star `**` to make a text bold, like in `**this example**`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Conventions for the examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code in examples is assumed to always start with these two lines which are
    not shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Any other module used in the examples must be explicitly imported, one per line
    (as recommended in [**PEP 8#imports**](https://peps.python.org/pep-0008/#imports))
    and avoiding aliases. Avoid excessive imports, but if needed, imports from the
    standard library go first, followed by third-party libraries (like matplotlib).
  prefs: []
  type: TYPE_NORMAL
- en: When illustrating examples with a single `Series` use the name `ser`, and if
    illustrating with a single `DataFrame` use the name `df`. For indices, `idx` is
    the preferred name. If a set of homogeneous `Series` or `DataFrame` is used, name
    them `ser1`, `ser2`, `ser3`… or `df1`, `df2`, `df3`… If the data is not homogeneous,
    and more than one structure is needed, name them with something meaningful, for
    example `df_main` and `df_to_join`.
  prefs: []
  type: TYPE_NORMAL
- en: Data used in the example should be as compact as possible. The number of rows
    is recommended to be around 4, but make it a number that makes sense for the specific
    example. For example in the `head` method, it requires to be higher than 5, to
    show the example with the default values. If doing the `mean`, we could use something
    like `[1, 2, 3]`, so it is easy to see that the value returned is the mean.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex examples (grouping for example), avoid using data without interpretation,
    like a matrix of random numbers with columns A, B, C, D… And instead use a meaningful
    example, which makes it easier to understand the concept. Unless required by the
    example, use names of animals, to keep examples consistent. And numerical properties
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the method, keywords arguments `head(n=3)` are preferred to positional
    arguments `head(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]  #### Tips for getting your examples pass the doctests'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the examples pass the doctests in the validation script can sometimes
    be tricky. Here are some attention points:'
  prefs: []
  type: TYPE_NORMAL
- en: Import all needed libraries (except for pandas and NumPy, those are already
    imported as `import pandas as pd` and `import numpy as np`) and define all variables
    you use in the example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to avoid using random data. However random data might be OK in some cases,
    like if the function you are documenting deals with probability distributions,
    or if the amount of data needed to make the function result meaningful is too
    much, such that creating it manually is very cumbersome. In those cases, always
    use a fixed random seed to make the generated examples predictable. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a code snippet that wraps multiple lines, you need to use ‘…’ on
    the continued lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to show a case where an exception is raised, you can do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is essential to include the “Traceback (most recent call last):”, but for
    the actual error only the error name is sufficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is a small part of the result that can vary (e.g. a hash in an object
    representation), you can use `...` to represent this part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to show that `s.plot()` returns a matplotlib AxesSubplot object,
    this will fail the doctest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, you can do (notice the comment that needs to be added)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]  #### Plots in examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are some methods in pandas returning plots. To render the plots generated
    by the examples in the documentation, the `.. plot::` directive exists.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, place the next code after the “Examples” header as shown below. The
    plot will be generated automatically when building the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]  ## Sharing docstrings'
  prefs: []
  type: TYPE_NORMAL
- en: pandas has a system for sharing docstrings, with slight variations, between
    classes. This helps us keep docstrings consistent, while keeping things clear
    for the user reading. It comes at the cost of some complexity when writing.
  prefs: []
  type: TYPE_NORMAL
- en: Each shared docstring will have a base template with variables, like `{klass}`.
    The variables filled in later on using the `doc` decorator. Finally, docstrings
    can also be appended to with the `doc` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll create a parent docstring normally (this is like `pandas.core.generic.NDFrame`.
    Then we’ll have two children (like `pandas.core.series.Series` and `pandas.core.frame.DataFrame`).
    We’ll substitute the class names in this docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The resulting docstrings are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice:'
  prefs: []
  type: TYPE_NORMAL
- en: We “append” the parent docstring to the children docstrings, which are initially
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our files will often contain a module-level `_shared_doc_kwargs` with some common
    substitution values (things like `klass`, `axes`, etc).
  prefs: []
  type: TYPE_NORMAL
- en: You can substitute and append in one shot with something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: where `template` may come from a module-level `_shared_docs` dictionary mapping
    function names to docstrings. Wherever possible, we prefer using `doc`, since
    the docstring-writing processes is slightly closer to normal.
  prefs: []
  type: TYPE_NORMAL
- en: See `pandas.core.generic.NDFrame.fillna` for an example template, and `pandas.core.series.Series.fillna`
    and `pandas.core.generic.frame.fillna` for the filled versions.
  prefs: []
  type: TYPE_NORMAL
- en: About docstrings and standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Python docstring is a string used to document a Python module, class, function
    or method, so programmers can understand what it does without having to read the
    details of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is a common practice to generate online (html) documentation automatically
    from docstrings. [Sphinx](https://www.sphinx-doc.org) serves this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example gives an idea of what a docstring looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Some standards regarding docstrings exist, which make them easier to read, and
    allow them be easily exported to other formats such as html or pdf.
  prefs: []
  type: TYPE_NORMAL
- en: The first conventions every Python docstring should follow are defined in [PEP-257](https://www.python.org/dev/peps/pep-0257/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As PEP-257 is quite broad, other more specific standards also exist. In the
    case of pandas, the NumPy docstring convention is followed. These conventions
    are explained in this document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[numpydoc docstring guide](https://numpydoc.readthedocs.io/en/latest/format.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: numpydoc is a Sphinx extension to support the NumPy docstring convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard uses reStructuredText (reST). reStructuredText is a markup language
    that allows encoding styles in plain text files. Documentation about reStructuredText
    can be found in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sphinx reStructuredText primer](https://www.sphinx-doc.org/en/stable/rest.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Quick reStructuredText reference](https://docutils.sourceforge.io/docs/user/rst/quickref.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Full reStructuredText specification](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas has some helpers for sharing docstrings between related classes, see
    [Sharing docstrings](#docstring-sharing).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this document will summarize all the above guidelines, and will
    provide additional conventions specific to the pandas project.
  prefs: []
  type: TYPE_NORMAL
- en: '## Writing a docstring'
  prefs: []
  type: TYPE_NORMAL
- en: '### General rules'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings must be defined with three double-quotes. No blank lines should be
    left before or after the docstring. The text starts in the next line after the
    opening quotes. The closing quotes have their own line (meaning that they are
    not at the end of the last sentence).
  prefs: []
  type: TYPE_NORMAL
- en: 'On rare occasions reST styles like bold text or italics will be used in docstrings,
    but is it common to have inline code, which is presented between backticks. The
    following are considered inline code:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code, a module, function, built-in, type, literal… (e.g. `os`, `list`,
    `numpy.abs`, `datetime.date`, `True`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas class (in the form `:class:`pandas.Series``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas method (in the form `:meth:`pandas.Series.sum``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas function (in the form `:func:`pandas.to_datetime``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To display only the last component of the linked class, method or function,
    prefix it with `~`. For example, `:class:`~pandas.Series`` will link to `pandas.Series`
    but only display the last part, `Series` as the link text. See [Sphinx cross-referencing
    syntax](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]  ### Section 1: short summary'
  prefs: []
  type: TYPE_NORMAL
- en: The short summary is a single sentence that expresses what the function does
    in a concise way.
  prefs: []
  type: TYPE_NORMAL
- en: The short summary must start with a capital letter, end with a dot, and fit
    in a single line. It needs to express what the object does without providing details.
    For functions and methods, the short summary must start with an infinitive verb.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]  ### Section 2: extended summary'
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary provides details on what the function does. It should not
    go into the details of the parameters, or discuss implementation notes, which
    go in other sections.
  prefs: []
  type: TYPE_NORMAL
- en: A blank line is left between the short summary and the extended summary. Every
    paragraph in the extended summary ends with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary should provide details on why the function is useful and
    their use cases, if it is not too generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]  ### Section 3: parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The details of the parameters will be added in this section. This section has
    the title “Parameters”, followed by a line with a hyphen under each letter of
    the word “Parameters”. A blank line is left before the section title, but not
    after, and not between the line with the word “Parameters” and the one with the
    hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: After the title, each parameter in the signature must be documented, including
    `*args` and `**kwargs`, but not `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters are defined by their name, followed by a space, a colon, another
    space, and the type (or types). Note that the space between the name and the colon
    is important. Types are not defined for `*args` and `**kwargs`, but must be defined
    for all other parameters. After the parameter definition, it is required to have
    a line with the parameter description, which is indented, and can have multiple
    lines. The description must start with a capital letter, and finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: For keyword arguments with a default value, the default will be listed after
    a comma at the end of the type. The exact form of the type in this case will be
    “int, default 0”. In some cases it may be useful to explain what the default argument
    means, which can be added after a comma “int, default -1, meaning all cpus”.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the default value is `None`, meaning that the value will not
    be used. Instead of `"str, default None"`, it is preferred to write `"str, optional"`.
    When `None` is a value being used, we will keep the form “str, default None”.
    For example, in `df.to_csv(compression=None)`, `None` is not a value being used,
    but means that compression is optional, and no compression is being used if not
    provided. In this case we will use `"str, optional"`. Only in cases like `func(value=None)`
    and `None` is being used in the same way as `0` or `foo` would be used, then we
    will specify “str, int or None, default None”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '#### Parameter types'
  prefs: []
  type: TYPE_NORMAL
- en: 'When specifying the parameter types, Python built-in data types can be used
    directly (the Python type is preferred to the more verbose string, integer, boolean,
    etc):'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For complex types, define the subtypes. For `dict` and `tuple`, as more than
    one type is present, we use the brackets to help read the type (curly brackets
    for `dict` and normal brackets for `tuple`):'
  prefs: []
  type: TYPE_NORMAL
- en: list of int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dict of {str : int}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str, int, int)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str,)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case where there are just a set of values allowed, list them in curly brackets
    and separated by commas (followed by a space). If the values are ordinal and they
    have an order, list them in this order. Otherwise, list the default value first,
    if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0, 10, 25}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘simple’, ‘advanced’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘low’, ‘medium’, ‘high’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘cat’, ‘dog’, ‘bird’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is defined in a Python module, the module must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: datetime.date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datetime.datetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decimal.Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is in a package, the module must be also specified:'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scipy.sparse.coo_matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is a pandas type, also specify pandas except for Series and DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.arrays.SparseArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the exact type is not relevant, but must be compatible with a NumPy array,
    array-like can be specified. If Any type that can be iterated is accepted, iterable
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: array-like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iterable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If more than one type is accepted, separate them by commas, except the last
    two types, that need to be separated by the word ‘or’:'
  prefs: []
  type: TYPE_NORMAL
- en: int or float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float, decimal.Decimal or None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str or list of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `None` is one of the accepted values, it always needs to be the last in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For axis, the convention is to use something like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'axis : {0 or ‘index’, 1 or ‘columns’, None}, default None  ### Section 4: returns
    or yields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the method returns a value, it will be documented in this section. Also if
    the method yields its output.
  prefs: []
  type: TYPE_NORMAL
- en: The title of the section will be defined in the same way as the “Parameters”.
    With the names “Returns” or “Yields” followed by a line with as many hyphens as
    the letters in the preceding word.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the return is also similar to the parameters. But in this
    case, no name will be provided, unless the method returns or yields more than
    one value (a tuple of values).
  prefs: []
  type: TYPE_NORMAL
- en: The types for “Returns” and “Yields” are the same as the ones for the “Parameters”.
    Also, the description must finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With more than one value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the method yields its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]  ### Section 5: see also'
  prefs: []
  type: TYPE_NORMAL
- en: This section is used to let users know about pandas functionality related to
    the one being documented. In rare cases, if no related methods or functions can
    be found at all, this section can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious example would be the `head()` and `tail()` methods. As `tail()` does
    the equivalent as `head()` but at the end of the `Series` or `DataFrame` instead
    of at the beginning, it is good to let the users know about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an intuition on what can be considered related, here there are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` and `iloc`, as they do the same, but in one case providing indices and
    in the other positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` and `min`, as they do the opposite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterrows`, `itertuples` and `items`, as it is easy that a user looking for
    the method to iterate over columns ends up in the method to iterate over rows,
    and vice-versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillna` and `dropna`, as both methods are used to handle missing values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_csv` and `to_csv`, as they are complementary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge` and `join`, as one is a generalization of the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`astype` and `pandas.to_datetime`, as users may be reading the documentation
    of `astype` to know how to cast as a date, and the way to do it is with `pandas.to_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where` is related to `numpy.where`, as its functionality is based on it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deciding what is related, you should mainly use your common sense and think
    about what can be useful for the users reading the documentation, especially the
    less experienced ones.
  prefs: []
  type: TYPE_NORMAL
- en: When relating to other libraries (mainly `numpy`), use the name of the module
    first (not an alias like `np`). If the function is in a module which is not the
    main one, like `scipy.sparse`, list the full module (e.g. `scipy.sparse.coo_matrix`).
  prefs: []
  type: TYPE_NORMAL
- en: This section has a header, “See Also” (note the capital S and A), followed by
    the line with hyphens and preceded by a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: After the header, we will add a line for each related method or function, followed
    by a space, a colon, another space, and a short description that illustrates what
    this method or function does, why is it relevant in this context, and what the
    key differences are between the documented function and the one being referenced.
    The description must also end with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in “Returns” and “Yields”, the description is located on the line
    after the type. In this section, however, it is located on the same line, with
    a colon in between. If the description does not fit on the same line, it can continue
    onto other lines which must be further indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]  ### Section 6: notes'
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional section used for notes about the implementation of the algorithm,
    or to document technical aspects of the function behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip it, unless you are familiar with the implementation of the
    algorithm, or you discover some counter-intuitive behavior while writing the examples
    for the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section follows the same format as the extended summary section.  ###
    Section 7: examples'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most important sections of a docstring, despite being placed
    in the last position, as often people understand concepts better by example than
    through accurate explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples in docstrings, besides illustrating the usage of the function or method,
    must be valid Python code, that returns the given output in a deterministic way,
    and that can be copied and run by users.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are presented as a session in the Python terminal. `>>>` is used to
    present code. `...` is used for code continuing from the previous line. Output
    is presented immediately after the last line of code generating the output (no
    blank lines in between). Comments describing the examples can be added with blank
    lines before and after them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to present examples is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import required libraries (except `numpy` and `pandas`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the data required for the example
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a very basic example that gives an idea of the most common use case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add examples with explanations that illustrate how the parameters can be used
    for extended functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simple example could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The examples should be as concise as possible. In cases where the complexity
    of the function requires long examples, is recommended to use blocks with headers
    in bold. Use double star `**` to make a text bold, like in `**this example**`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Conventions for the examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code in examples is assumed to always start with these two lines which are
    not shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Any other module used in the examples must be explicitly imported, one per line
    (as recommended in [**PEP 8#imports**](https://peps.python.org/pep-0008/#imports))
    and avoiding aliases. Avoid excessive imports, but if needed, imports from the
    standard library go first, followed by third-party libraries (like matplotlib).
  prefs: []
  type: TYPE_NORMAL
- en: When illustrating examples with a single `Series` use the name `ser`, and if
    illustrating with a single `DataFrame` use the name `df`. For indices, `idx` is
    the preferred name. If a set of homogeneous `Series` or `DataFrame` is used, name
    them `ser1`, `ser2`, `ser3`… or `df1`, `df2`, `df3`… If the data is not homogeneous,
    and more than one structure is needed, name them with something meaningful, for
    example `df_main` and `df_to_join`.
  prefs: []
  type: TYPE_NORMAL
- en: Data used in the example should be as compact as possible. The number of rows
    is recommended to be around 4, but make it a number that makes sense for the specific
    example. For example in the `head` method, it requires to be higher than 5, to
    show the example with the default values. If doing the `mean`, we could use something
    like `[1, 2, 3]`, so it is easy to see that the value returned is the mean.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex examples (grouping for example), avoid using data without interpretation,
    like a matrix of random numbers with columns A, B, C, D… And instead use a meaningful
    example, which makes it easier to understand the concept. Unless required by the
    example, use names of animals, to keep examples consistent. And numerical properties
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the method, keywords arguments `head(n=3)` are preferred to positional
    arguments `head(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]  #### Tips for getting your examples pass the doctests'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the examples pass the doctests in the validation script can sometimes
    be tricky. Here are some attention points:'
  prefs: []
  type: TYPE_NORMAL
- en: Import all needed libraries (except for pandas and NumPy, those are already
    imported as `import pandas as pd` and `import numpy as np`) and define all variables
    you use in the example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to avoid using random data. However random data might be OK in some cases,
    like if the function you are documenting deals with probability distributions,
    or if the amount of data needed to make the function result meaningful is too
    much, such that creating it manually is very cumbersome. In those cases, always
    use a fixed random seed to make the generated examples predictable. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a code snippet that wraps multiple lines, you need to use ‘…’ on
    the continued lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to show a case where an exception is raised, you can do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is essential to include the “Traceback (most recent call last):”, but for
    the actual error only the error name is sufficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is a small part of the result that can vary (e.g. a hash in an object
    representation), you can use `...` to represent this part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to show that `s.plot()` returns a matplotlib AxesSubplot object,
    this will fail the doctest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, you can do (notice the comment that needs to be added)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]  #### Plots in examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are some methods in pandas returning plots. To render the plots generated
    by the examples in the documentation, the `.. plot::` directive exists.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, place the next code after the “Examples” header as shown below. The
    plot will be generated automatically when building the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]  ### General rules'
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings must be defined with three double-quotes. No blank lines should be
    left before or after the docstring. The text starts in the next line after the
    opening quotes. The closing quotes have their own line (meaning that they are
    not at the end of the last sentence).
  prefs: []
  type: TYPE_NORMAL
- en: 'On rare occasions reST styles like bold text or italics will be used in docstrings,
    but is it common to have inline code, which is presented between backticks. The
    following are considered inline code:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python code, a module, function, built-in, type, literal… (e.g. `os`, `list`,
    `numpy.abs`, `datetime.date`, `True`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas class (in the form `:class:`pandas.Series``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas method (in the form `:meth:`pandas.Series.sum``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pandas function (in the form `:func:`pandas.to_datetime``)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To display only the last component of the linked class, method or function,
    prefix it with `~`. For example, `:class:`~pandas.Series`` will link to `pandas.Series`
    but only display the last part, `Series` as the link text. See [Sphinx cross-referencing
    syntax](https://www.sphinx-doc.org/en/stable/domains.html#cross-referencing-syntax)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '### Section 1: short summary'
  prefs: []
  type: TYPE_NORMAL
- en: The short summary is a single sentence that expresses what the function does
    in a concise way.
  prefs: []
  type: TYPE_NORMAL
- en: The short summary must start with a capital letter, end with a dot, and fit
    in a single line. It needs to express what the object does without providing details.
    For functions and methods, the short summary must start with an infinitive verb.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '### Section 2: extended summary'
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary provides details on what the function does. It should not
    go into the details of the parameters, or discuss implementation notes, which
    go in other sections.
  prefs: []
  type: TYPE_NORMAL
- en: A blank line is left between the short summary and the extended summary. Every
    paragraph in the extended summary ends with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: The extended summary should provide details on why the function is useful and
    their use cases, if it is not too generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '### Section 3: parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The details of the parameters will be added in this section. This section has
    the title “Parameters”, followed by a line with a hyphen under each letter of
    the word “Parameters”. A blank line is left before the section title, but not
    after, and not between the line with the word “Parameters” and the one with the
    hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: After the title, each parameter in the signature must be documented, including
    `*args` and `**kwargs`, but not `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters are defined by their name, followed by a space, a colon, another
    space, and the type (or types). Note that the space between the name and the colon
    is important. Types are not defined for `*args` and `**kwargs`, but must be defined
    for all other parameters. After the parameter definition, it is required to have
    a line with the parameter description, which is indented, and can have multiple
    lines. The description must start with a capital letter, and finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: For keyword arguments with a default value, the default will be listed after
    a comma at the end of the type. The exact form of the type in this case will be
    “int, default 0”. In some cases it may be useful to explain what the default argument
    means, which can be added after a comma “int, default -1, meaning all cpus”.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the default value is `None`, meaning that the value will not
    be used. Instead of `"str, default None"`, it is preferred to write `"str, optional"`.
    When `None` is a value being used, we will keep the form “str, default None”.
    For example, in `df.to_csv(compression=None)`, `None` is not a value being used,
    but means that compression is optional, and no compression is being used if not
    provided. In this case we will use `"str, optional"`. Only in cases like `func(value=None)`
    and `None` is being used in the same way as `0` or `foo` would be used, then we
    will specify “str, int or None, default None”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '#### Parameter types'
  prefs: []
  type: TYPE_NORMAL
- en: 'When specifying the parameter types, Python built-in data types can be used
    directly (the Python type is preferred to the more verbose string, integer, boolean,
    etc):'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For complex types, define the subtypes. For `dict` and `tuple`, as more than
    one type is present, we use the brackets to help read the type (curly brackets
    for `dict` and normal brackets for `tuple`):'
  prefs: []
  type: TYPE_NORMAL
- en: list of int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dict of {str : int}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str, int, int)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str,)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case where there are just a set of values allowed, list them in curly brackets
    and separated by commas (followed by a space). If the values are ordinal and they
    have an order, list them in this order. Otherwise, list the default value first,
    if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0, 10, 25}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘simple’, ‘advanced’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘low’, ‘medium’, ‘high’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘cat’, ‘dog’, ‘bird’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is defined in a Python module, the module must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: datetime.date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datetime.datetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decimal.Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is in a package, the module must be also specified:'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scipy.sparse.coo_matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is a pandas type, also specify pandas except for Series and DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.arrays.SparseArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the exact type is not relevant, but must be compatible with a NumPy array,
    array-like can be specified. If Any type that can be iterated is accepted, iterable
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: array-like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iterable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If more than one type is accepted, separate them by commas, except the last
    two types, that need to be separated by the word ‘or’:'
  prefs: []
  type: TYPE_NORMAL
- en: int or float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float, decimal.Decimal or None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str or list of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `None` is one of the accepted values, it always needs to be the last in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For axis, the convention is to use something like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'axis : {0 or ‘index’, 1 or ‘columns’, None}, default None  #### Parameter types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When specifying the parameter types, Python built-in data types can be used
    directly (the Python type is preferred to the more verbose string, integer, boolean,
    etc):'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: bool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For complex types, define the subtypes. For `dict` and `tuple`, as more than
    one type is present, we use the brackets to help read the type (curly brackets
    for `dict` and normal brackets for `tuple`):'
  prefs: []
  type: TYPE_NORMAL
- en: list of int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'dict of {str : int}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str, int, int)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tuple of (str,)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: set of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case where there are just a set of values allowed, list them in curly brackets
    and separated by commas (followed by a space). If the values are ordinal and they
    have an order, list them in this order. Otherwise, list the default value first,
    if there is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '{0, 10, 25}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘simple’, ‘advanced’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘low’, ‘medium’, ‘high’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{‘cat’, ‘dog’, ‘bird’}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is defined in a Python module, the module must be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: datetime.date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: datetime.datetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: decimal.Decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is in a package, the module must be also specified:'
  prefs: []
  type: TYPE_NORMAL
- en: numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scipy.sparse.coo_matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the type is a pandas type, also specify pandas except for Series and DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataFrame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.Categorical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pandas.arrays.SparseArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the exact type is not relevant, but must be compatible with a NumPy array,
    array-like can be specified. If Any type that can be iterated is accepted, iterable
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: array-like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iterable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If more than one type is accepted, separate them by commas, except the last
    two types, that need to be separated by the word ‘or’:'
  prefs: []
  type: TYPE_NORMAL
- en: int or float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float, decimal.Decimal or None
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: str or list of str
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `None` is one of the accepted values, it always needs to be the last in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For axis, the convention is to use something like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'axis : {0 or ‘index’, 1 or ‘columns’, None}, default None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Section 4: returns or yields'
  prefs: []
  type: TYPE_NORMAL
- en: If the method returns a value, it will be documented in this section. Also if
    the method yields its output.
  prefs: []
  type: TYPE_NORMAL
- en: The title of the section will be defined in the same way as the “Parameters”.
    With the names “Returns” or “Yields” followed by a line with as many hyphens as
    the letters in the preceding word.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation of the return is also similar to the parameters. But in this
    case, no name will be provided, unless the method returns or yields more than
    one value (a tuple of values).
  prefs: []
  type: TYPE_NORMAL
- en: The types for “Returns” and “Yields” are the same as the ones for the “Parameters”.
    Also, the description must finish with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'With more than one value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If the method yields its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '### Section 5: see also'
  prefs: []
  type: TYPE_NORMAL
- en: This section is used to let users know about pandas functionality related to
    the one being documented. In rare cases, if no related methods or functions can
    be found at all, this section can be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious example would be the `head()` and `tail()` methods. As `tail()` does
    the equivalent as `head()` but at the end of the `Series` or `DataFrame` instead
    of at the beginning, it is good to let the users know about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an intuition on what can be considered related, here there are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` and `iloc`, as they do the same, but in one case providing indices and
    in the other positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max` and `min`, as they do the opposite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterrows`, `itertuples` and `items`, as it is easy that a user looking for
    the method to iterate over columns ends up in the method to iterate over rows,
    and vice-versa'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillna` and `dropna`, as both methods are used to handle missing values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_csv` and `to_csv`, as they are complementary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge` and `join`, as one is a generalization of the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`astype` and `pandas.to_datetime`, as users may be reading the documentation
    of `astype` to know how to cast as a date, and the way to do it is with `pandas.to_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where` is related to `numpy.where`, as its functionality is based on it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deciding what is related, you should mainly use your common sense and think
    about what can be useful for the users reading the documentation, especially the
    less experienced ones.
  prefs: []
  type: TYPE_NORMAL
- en: When relating to other libraries (mainly `numpy`), use the name of the module
    first (not an alias like `np`). If the function is in a module which is not the
    main one, like `scipy.sparse`, list the full module (e.g. `scipy.sparse.coo_matrix`).
  prefs: []
  type: TYPE_NORMAL
- en: This section has a header, “See Also” (note the capital S and A), followed by
    the line with hyphens and preceded by a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: After the header, we will add a line for each related method or function, followed
    by a space, a colon, another space, and a short description that illustrates what
    this method or function does, why is it relevant in this context, and what the
    key differences are between the documented function and the one being referenced.
    The description must also end with a dot.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in “Returns” and “Yields”, the description is located on the line
    after the type. In this section, however, it is located on the same line, with
    a colon in between. If the description does not fit on the same line, it can continue
    onto other lines which must be further indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '### Section 6: notes'
  prefs: []
  type: TYPE_NORMAL
- en: This is an optional section used for notes about the implementation of the algorithm,
    or to document technical aspects of the function behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip it, unless you are familiar with the implementation of the
    algorithm, or you discover some counter-intuitive behavior while writing the examples
    for the function.
  prefs: []
  type: TYPE_NORMAL
- en: This section follows the same format as the extended summary section.
  prefs: []
  type: TYPE_NORMAL
- en: '### Section 7: examples'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most important sections of a docstring, despite being placed
    in the last position, as often people understand concepts better by example than
    through accurate explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples in docstrings, besides illustrating the usage of the function or method,
    must be valid Python code, that returns the given output in a deterministic way,
    and that can be copied and run by users.
  prefs: []
  type: TYPE_NORMAL
- en: Examples are presented as a session in the Python terminal. `>>>` is used to
    present code. `...` is used for code continuing from the previous line. Output
    is presented immediately after the last line of code generating the output (no
    blank lines in between). Comments describing the examples can be added with blank
    lines before and after them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to present examples is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import required libraries (except `numpy` and `pandas`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the data required for the example
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a very basic example that gives an idea of the most common use case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add examples with explanations that illustrate how the parameters can be used
    for extended functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simple example could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The examples should be as concise as possible. In cases where the complexity
    of the function requires long examples, is recommended to use blocks with headers
    in bold. Use double star `**` to make a text bold, like in `**this example**`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Conventions for the examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code in examples is assumed to always start with these two lines which are
    not shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Any other module used in the examples must be explicitly imported, one per line
    (as recommended in [**PEP 8#imports**](https://peps.python.org/pep-0008/#imports))
    and avoiding aliases. Avoid excessive imports, but if needed, imports from the
    standard library go first, followed by third-party libraries (like matplotlib).
  prefs: []
  type: TYPE_NORMAL
- en: When illustrating examples with a single `Series` use the name `ser`, and if
    illustrating with a single `DataFrame` use the name `df`. For indices, `idx` is
    the preferred name. If a set of homogeneous `Series` or `DataFrame` is used, name
    them `ser1`, `ser2`, `ser3`… or `df1`, `df2`, `df3`… If the data is not homogeneous,
    and more than one structure is needed, name them with something meaningful, for
    example `df_main` and `df_to_join`.
  prefs: []
  type: TYPE_NORMAL
- en: Data used in the example should be as compact as possible. The number of rows
    is recommended to be around 4, but make it a number that makes sense for the specific
    example. For example in the `head` method, it requires to be higher than 5, to
    show the example with the default values. If doing the `mean`, we could use something
    like `[1, 2, 3]`, so it is easy to see that the value returned is the mean.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex examples (grouping for example), avoid using data without interpretation,
    like a matrix of random numbers with columns A, B, C, D… And instead use a meaningful
    example, which makes it easier to understand the concept. Unless required by the
    example, use names of animals, to keep examples consistent. And numerical properties
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the method, keywords arguments `head(n=3)` are preferred to positional
    arguments `head(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]  #### Tips for getting your examples pass the doctests'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the examples pass the doctests in the validation script can sometimes
    be tricky. Here are some attention points:'
  prefs: []
  type: TYPE_NORMAL
- en: Import all needed libraries (except for pandas and NumPy, those are already
    imported as `import pandas as pd` and `import numpy as np`) and define all variables
    you use in the example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to avoid using random data. However random data might be OK in some cases,
    like if the function you are documenting deals with probability distributions,
    or if the amount of data needed to make the function result meaningful is too
    much, such that creating it manually is very cumbersome. In those cases, always
    use a fixed random seed to make the generated examples predictable. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a code snippet that wraps multiple lines, you need to use ‘…’ on
    the continued lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to show a case where an exception is raised, you can do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is essential to include the “Traceback (most recent call last):”, but for
    the actual error only the error name is sufficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is a small part of the result that can vary (e.g. a hash in an object
    representation), you can use `...` to represent this part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to show that `s.plot()` returns a matplotlib AxesSubplot object,
    this will fail the doctest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, you can do (notice the comment that needs to be added)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]  #### Plots in examples'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are some methods in pandas returning plots. To render the plots generated
    by the examples in the documentation, the `.. plot::` directive exists.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, place the next code after the “Examples” header as shown below. The
    plot will be generated automatically when building the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]  #### Conventions for the examples'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code in examples is assumed to always start with these two lines which are
    not shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Any other module used in the examples must be explicitly imported, one per line
    (as recommended in [**PEP 8#imports**](https://peps.python.org/pep-0008/#imports))
    and avoiding aliases. Avoid excessive imports, but if needed, imports from the
    standard library go first, followed by third-party libraries (like matplotlib).
  prefs: []
  type: TYPE_NORMAL
- en: When illustrating examples with a single `Series` use the name `ser`, and if
    illustrating with a single `DataFrame` use the name `df`. For indices, `idx` is
    the preferred name. If a set of homogeneous `Series` or `DataFrame` is used, name
    them `ser1`, `ser2`, `ser3`… or `df1`, `df2`, `df3`… If the data is not homogeneous,
    and more than one structure is needed, name them with something meaningful, for
    example `df_main` and `df_to_join`.
  prefs: []
  type: TYPE_NORMAL
- en: Data used in the example should be as compact as possible. The number of rows
    is recommended to be around 4, but make it a number that makes sense for the specific
    example. For example in the `head` method, it requires to be higher than 5, to
    show the example with the default values. If doing the `mean`, we could use something
    like `[1, 2, 3]`, so it is easy to see that the value returned is the mean.
  prefs: []
  type: TYPE_NORMAL
- en: For more complex examples (grouping for example), avoid using data without interpretation,
    like a matrix of random numbers with columns A, B, C, D… And instead use a meaningful
    example, which makes it easier to understand the concept. Unless required by the
    example, use names of animals, to keep examples consistent. And numerical properties
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the method, keywords arguments `head(n=3)` are preferred to positional
    arguments `head(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Bad:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '#### Tips for getting your examples pass the doctests'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the examples pass the doctests in the validation script can sometimes
    be tricky. Here are some attention points:'
  prefs: []
  type: TYPE_NORMAL
- en: Import all needed libraries (except for pandas and NumPy, those are already
    imported as `import pandas as pd` and `import numpy as np`) and define all variables
    you use in the example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try to avoid using random data. However random data might be OK in some cases,
    like if the function you are documenting deals with probability distributions,
    or if the amount of data needed to make the function result meaningful is too
    much, such that creating it manually is very cumbersome. In those cases, always
    use a fixed random seed to make the generated examples predictable. Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have a code snippet that wraps multiple lines, you need to use ‘…’ on
    the continued lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to show a case where an exception is raised, you can do:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is essential to include the “Traceback (most recent call last):”, but for
    the actual error only the error name is sufficient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is a small part of the result that can vary (e.g. a hash in an object
    representation), you can use `...` to represent this part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to show that `s.plot()` returns a matplotlib AxesSubplot object,
    this will fail the doctest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, you can do (notice the comment that needs to be added)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#### Plots in examples'
  prefs: []
  type: TYPE_NORMAL
- en: There are some methods in pandas returning plots. To render the plots generated
    by the examples in the documentation, the `.. plot::` directive exists.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, place the next code after the “Examples” header as shown below. The
    plot will be generated automatically when building the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '## Sharing docstrings'
  prefs: []
  type: TYPE_NORMAL
- en: pandas has a system for sharing docstrings, with slight variations, between
    classes. This helps us keep docstrings consistent, while keeping things clear
    for the user reading. It comes at the cost of some complexity when writing.
  prefs: []
  type: TYPE_NORMAL
- en: Each shared docstring will have a base template with variables, like `{klass}`.
    The variables filled in later on using the `doc` decorator. Finally, docstrings
    can also be appended to with the `doc` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll create a parent docstring normally (this is like `pandas.core.generic.NDFrame`.
    Then we’ll have two children (like `pandas.core.series.Series` and `pandas.core.frame.DataFrame`).
    We’ll substitute the class names in this docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The resulting docstrings are
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice:'
  prefs: []
  type: TYPE_NORMAL
- en: We “append” the parent docstring to the children docstrings, which are initially
    empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our files will often contain a module-level `_shared_doc_kwargs` with some common
    substitution values (things like `klass`, `axes`, etc).
  prefs: []
  type: TYPE_NORMAL
- en: You can substitute and append in one shot with something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: where `template` may come from a module-level `_shared_docs` dictionary mapping
    function names to docstrings. Wherever possible, we prefer using `doc`, since
    the docstring-writing processes is slightly closer to normal.
  prefs: []
  type: TYPE_NORMAL
- en: See `pandas.core.generic.NDFrame.fillna` for an example template, and `pandas.core.series.Series.fillna`
    and `pandas.core.generic.frame.fillna` for the filled versions.
  prefs: []
  type: TYPE_NORMAL
