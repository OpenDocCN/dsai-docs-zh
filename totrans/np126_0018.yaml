- en: Glossary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/glossary.html](https://numpy.org/doc/1.26/glossary.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (*n*,)
  prefs: []
  type: TYPE_NORMAL
- en: A parenthesized number followed by a comma denotes a tuple with one element.
    The trailing comma distinguishes a one-element tuple from a parenthesized `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  prefs: []
  type: TYPE_NORMAL
- en: '**In a dimension entry**, instructs NumPy to choose the length that will keep
    the total number of array elements the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**In an index**, any negative value [denotes](https://docs.python.org/dev/faq/programming.html#what-s-a-negative-index)
    indexing from the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: An [`Ellipsis`](https://docs.python.org/3/library/constants.html#Ellipsis "(in
    Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: '**When indexing an array**, shorthand that the missing axes, if they exist,
    are full slices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It can be used at most once; `a[...,0,...]` raises an [`IndexError`](https://docs.python.org/3/library/exceptions.html#IndexError
    "(in Python v3.11)").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**In printouts**, NumPy substitutes `...` for the middle elements of large
    arrays. To see the entire array, use [`numpy.printoptions`](reference/generated/numpy.printoptions.html#numpy.printoptions
    "numpy.printoptions")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python [slice](https://docs.python.org/3/glossary.html#term-slice "(in
    Python v3.11)") operator. In ndarrays, slicing can be applied to every axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Trailing slices can be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to Python, where slicing creates a copy, in NumPy slicing creates
    a [view](#term-view).
  prefs: []
  type: TYPE_NORMAL
- en: For details, see [Combining advanced and basic indexing](user/basics.indexing.html#combining-advanced-and-basic-indexing).
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: In a dtype declaration, indicates that the data is [little-endian](#term-little-endian)
    (the bracket is big on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: In a dtype declaration, indicates that the data is [big-endian](#term-big-endian)
    (the bracket is big on the left).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: advanced indexing
  prefs: []
  type: TYPE_NORMAL
- en: Rather than using a [scalar](reference/arrays.scalars.html) or slice as an index,
    an axis can be indexed with an array, providing fine-grained selection. This is
    known as [advanced indexing](user/basics.indexing.html#advanced-indexing) or “fancy
    indexing”.
  prefs: []
  type: TYPE_NORMAL
- en: along an axis
  prefs: []
  type: TYPE_NORMAL
- en: An operation *along axis n* of array `a` behaves as if its argument were an
    array of slices of `a` where each slice has a successive index of axis *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if `a` is a 3 x *N* array, an operation along axis 0 behaves as
    if its argument were an array containing slices of each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it concrete, we can pick the operation to be the array-reversal function
    [`numpy.flip`](reference/generated/numpy.flip.html#numpy.flip "numpy.flip"), which
    accepts an `axis` argument. We construct a 3 x 4 array `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reversing along axis 0 (the row axis) yields
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Recalling the definition of *along an axis*, `flip` along axis 0 is treating
    its argument as if it were
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'and the result of `np.flip(a,axis=0)` is to reverse the slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: array
  prefs: []
  type: TYPE_NORMAL
- en: Used synonymously in the NumPy docs with [ndarray](#term-ndarray).
  prefs: []
  type: TYPE_NORMAL
- en: array_like
  prefs: []
  type: TYPE_NORMAL
- en: Any [scalar](reference/arrays.scalars.html) or [sequence](https://docs.python.org/3/glossary.html#term-sequence
    "(in Python v3.11)") that can be interpreted as an ndarray. In addition to ndarrays
    and scalars this category includes lists (possibly nested and with different element
    types) and tuples. Any argument accepted by [numpy.array](reference/generated/numpy.array.html)
    is array_like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: array scalar
  prefs: []
  type: TYPE_NORMAL
- en: An [array scalar](reference/arrays.scalars.html) is an instance of the types/classes
    float32, float64, etc.. For uniformity in handling operands, NumPy treats a scalar
    as an array of zero dimension. In contrast, a 0-dimensional array is an [ndarray](reference/arrays.ndarray.html)
    instance containing precisely one value.
  prefs: []
  type: TYPE_NORMAL
- en: axis
  prefs: []
  type: TYPE_NORMAL
- en: Another term for an array dimension. Axes are numbered left to right; axis 0
    is the first element in the shape tuple.
  prefs: []
  type: TYPE_NORMAL
- en: In a two-dimensional vector, the elements of axis 0 are rows and the elements
    of axis 1 are columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In higher dimensions, the picture changes. NumPy prints higher-dimensional
    vectors as replications of row-by-column building blocks, as in this three-dimensional
    vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is depicted as a two-element array whose elements are 2x3 vectors. From
    this point of view, rows and columns are the final two axes, respectively, in
    any shape.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule helps you anticipate how a vector will be printed, and conversely
    how to find the index of any of the printed elements. For instance, in the example,
    the last two values of 8’s index must be 0 and 2\. Since 8 appears in the second
    of the two 2x3’s, the first index must be 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A convenient way to count dimensions in a printed vector is to count `[` symbols
    after the open-parenthesis. This is useful in distinguishing, say, a (1,2,3) shape
    from a (2,3) shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: .base
  prefs: []
  type: TYPE_NORMAL
- en: If an array does not own its memory, then its [base](reference/generated/numpy.ndarray.base.html)
    attribute returns the object whose memory the array is referencing. That object
    may be referencing the memory from still another object, so the owning object
    may be `a.base.base.base...`. Some writers erroneously claim that testing `base`
    determines if arrays are [view](#term-view)s. For the correct way, see [`numpy.shares_memory`](reference/generated/numpy.shares_memory.html#numpy.shares_memory
    "numpy.shares_memory").
  prefs: []
  type: TYPE_NORMAL
- en: big-endian
  prefs: []
  type: TYPE_NORMAL
- en: See [Endianness](https://en.wikipedia.org/wiki/Endianness).
  prefs: []
  type: TYPE_NORMAL
- en: BLAS
  prefs: []
  type: TYPE_NORMAL
- en: '[Basic Linear Algebra Subprograms](https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms)'
  prefs: []
  type: TYPE_NORMAL
- en: broadcast
  prefs: []
  type: TYPE_NORMAL
- en: '*broadcasting* is NumPy’s ability to process ndarrays of different sizes as
    if all were the same size.'
  prefs: []
  type: TYPE_NORMAL
- en: It permits an elegant do-what-I-mean behavior where, for instance, adding a
    scalar to a vector adds the scalar value to every element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Ordinarly, vector operands must all be the same size, because NumPy works element
    by element – for instance, `c = a * b` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But in certain useful cases, NumPy can duplicate data along “missing” axes or
    “too-short” dimensions so shapes will match. The duplication costs no memory or
    time. For details, see [Broadcasting.](user/basics.broadcasting.html)
  prefs: []
  type: TYPE_NORMAL
- en: C order
  prefs: []
  type: TYPE_NORMAL
- en: Same as [row-major](#term-row-major).
  prefs: []
  type: TYPE_NORMAL
- en: column-major
  prefs: []
  type: TYPE_NORMAL
- en: See [Row- and column-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
  prefs: []
  type: TYPE_NORMAL
- en: contiguous
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is contiguous if:'
  prefs: []
  type: TYPE_NORMAL
- en: it occupies an unbroken block of memory, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array elements with higher indexes occupy higher addresses (that is, no [stride](#term-stride)
    is negative).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two types of proper-contiguous NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Fortran-contiguous arrays refer to data that is stored column-wise, i.e. the
    indexing of data as stored in memory starts from the lowest dimension;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C-contiguous, or simply contiguous arrays, refer to data that is stored row-wise,
    i.e. the indexing of data as stored in memory starts from the highest dimension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For one-dimensional arrays these notions coincide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a 2x2 array `A` is Fortran-contiguous if its elements are stored
    in memory in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and C-contiguous if the order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To test whether an array is C-contiguous, use the `.flags.c_contiguous` attribute
    of NumPy arrays. To test for Fortran contiguity, use the `.flags.f_contiguous`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: copy
  prefs: []
  type: TYPE_NORMAL
- en: See [view](#term-view).
  prefs: []
  type: TYPE_NORMAL
- en: dimension
  prefs: []
  type: TYPE_NORMAL
- en: See [axis](#term-axis).
  prefs: []
  type: TYPE_NORMAL
- en: dtype
  prefs: []
  type: TYPE_NORMAL
- en: The datatype describing the (identically typed) elements in an ndarray. It can
    be changed to reinterpret the array contents. For details, see [Data type objects
    (dtype).](reference/arrays.dtypes.html)
  prefs: []
  type: TYPE_NORMAL
- en: fancy indexing
  prefs: []
  type: TYPE_NORMAL
- en: Another term for [advanced indexing](#term-advanced-indexing).
  prefs: []
  type: TYPE_NORMAL
- en: field
  prefs: []
  type: TYPE_NORMAL
- en: In a [structured data type](#term-structured-data-type), each subtype is called
    a *field*. The *field* has a name (a string), a type (any valid dtype), and an
    optional *title*. See [Data type objects (dtype)](reference/arrays.dtypes.html#arrays-dtypes).
  prefs: []
  type: TYPE_NORMAL
- en: Fortran order
  prefs: []
  type: TYPE_NORMAL
- en: Same as [column-major](#term-column-major).
  prefs: []
  type: TYPE_NORMAL
- en: flattened
  prefs: []
  type: TYPE_NORMAL
- en: See [ravel](#term-ravel).
  prefs: []
  type: TYPE_NORMAL
- en: homogeneous
  prefs: []
  type: TYPE_NORMAL
- en: All elements of a homogeneous array have the same type. ndarrays, in contrast
    to Python lists, are homogeneous. The type can be complicated, as in a [structured
    array](#term-structured-array), but all elements have that type.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy [object arrays](#term-object-array), which contain references to Python
    objects, fill the role of heterogeneous arrays.
  prefs: []
  type: TYPE_NORMAL
- en: itemsize
  prefs: []
  type: TYPE_NORMAL
- en: The size of the dtype element in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: little-endian
  prefs: []
  type: TYPE_NORMAL
- en: See [Endianness](https://en.wikipedia.org/wiki/Endianness).
  prefs: []
  type: TYPE_NORMAL
- en: mask
  prefs: []
  type: TYPE_NORMAL
- en: 'A boolean array used to select only certain elements for an operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: masked array
  prefs: []
  type: TYPE_NORMAL
- en: Bad or missing data can be cleanly ignored by putting it in a masked array,
    which has an internal boolean array indicating invalid entries. Operations with
    masked arrays ignore these entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For details, see [Masked arrays.](reference/maskedarray.html)
  prefs: []
  type: TYPE_NORMAL
- en: matrix
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s two-dimensional [matrix class](reference/generated/numpy.matrix.html)
    should no longer be used; use regular ndarrays.
  prefs: []
  type: TYPE_NORMAL
- en: ndarray
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy’s basic structure](reference/arrays.html).'
  prefs: []
  type: TYPE_NORMAL
- en: object array
  prefs: []
  type: TYPE_NORMAL
- en: An array whose dtype is `object`; that is, it contains references to Python
    objects. Indexing the array dereferences the Python objects, so unlike other ndarrays,
    an object array has the ability to hold heterogeneous objects.
  prefs: []
  type: TYPE_NORMAL
- en: ravel
  prefs: []
  type: TYPE_NORMAL
- en: '[numpy.ravel](reference/generated/numpy.ravel.html) and [numpy.flatten](reference/generated/numpy.ndarray.flatten.html)
    both flatten an ndarray. `ravel` will return a view if possible; `flatten` always
    returns a copy.'
  prefs: []
  type: TYPE_NORMAL
- en: Flattening collapses a multidimensional array to a single dimension; details
    of how this is done (for instance, whether `a[n+1]` should be the next row or
    next column) are parameters.
  prefs: []
  type: TYPE_NORMAL
- en: record array
  prefs: []
  type: TYPE_NORMAL
- en: A [structured array](#term-structured-array) with allowing access in an attribute
    style (`a.field`) in addition to `a['field']`. For details, see [numpy.recarray.](reference/generated/numpy.recarray.html)
  prefs: []
  type: TYPE_NORMAL
- en: row-major
  prefs: []
  type: TYPE_NORMAL
- en: See [Row- and column-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    NumPy creates arrays in row-major order by default.
  prefs: []
  type: TYPE_NORMAL
- en: scalar
  prefs: []
  type: TYPE_NORMAL
- en: In NumPy, usually a synonym for [array scalar](#term-array-scalar).
  prefs: []
  type: TYPE_NORMAL
- en: shape
  prefs: []
  type: TYPE_NORMAL
- en: A tuple showing the length of each dimension of an ndarray. The length of the
    tuple itself is the number of dimensions ([numpy.ndim](reference/generated/numpy.ndarray.ndim.html)).
    The product of the tuple elements is the number of elements in the array. For
    details, see [numpy.ndarray.shape](reference/generated/numpy.ndarray.shape.html).
  prefs: []
  type: TYPE_NORMAL
- en: stride
  prefs: []
  type: TYPE_NORMAL
- en: Physical memory is one-dimensional; strides provide a mechanism to map a given
    index to an address in memory. For an N-dimensional array, its `strides` attribute
    is an N-element tuple; advancing from index `i` to index `i+1` on axis `n` means
    adding `a.strides[n]` bytes to the address.
  prefs: []
  type: TYPE_NORMAL
- en: Strides are computed automatically from an array’s dtype and shape, but can
    be directly specified using [as_strided.](reference/generated/numpy.lib.stride_tricks.as_strided.html)
  prefs: []
  type: TYPE_NORMAL
- en: For details, see [numpy.ndarray.strides](reference/generated/numpy.ndarray.strides.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how striding underlies the power of NumPy views, see [The NumPy array:
    a structure for efficient numerical computation.](https://arxiv.org/pdf/1102.1523.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: structured array
  prefs: []
  type: TYPE_NORMAL
- en: Array whose [dtype](#term-dtype) is a [structured data type](#term-structured-data-type).
  prefs: []
  type: TYPE_NORMAL
- en: structured data type
  prefs: []
  type: TYPE_NORMAL
- en: Users can create arbitrarily complex [dtypes](#term-dtype) that can include
    other arrays and dtypes. These composite dtypes are called [structured data types.](user/basics.rec.html)
  prefs: []
  type: TYPE_NORMAL
- en: subarray
  prefs: []
  type: TYPE_NORMAL
- en: 'An array nested in a [structured data type](#term-structured-data-type), as
    `b` is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: subarray data type
  prefs: []
  type: TYPE_NORMAL
- en: An element of a structured datatype that behaves like an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: title
  prefs: []
  type: TYPE_NORMAL
- en: An alias for a field name in a structured datatype.
  prefs: []
  type: TYPE_NORMAL
- en: type
  prefs: []
  type: TYPE_NORMAL
- en: In NumPy, usually a synonym for [dtype](#term-dtype). For the more general Python
    meaning, [see here.](https://docs.python.org/3/glossary.html#term-type "(in Python
    v3.11)")
  prefs: []
  type: TYPE_NORMAL
- en: ufunc
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s fast element-by-element computation ([vectorization](#term-vectorization))
    gives a choice which function gets applied. The general term for the function
    is `ufunc`, short for `universal function`. NumPy routines have built-in ufuncs,
    but users can also [write their own.](reference/ufuncs.html)
  prefs: []
  type: TYPE_NORMAL
- en: vectorization
  prefs: []
  type: TYPE_NORMAL
- en: NumPy hands off array processing to C, where looping and computation are much
    faster than in Python. To exploit this, programmers using NumPy eliminate Python
    loops in favor of array-to-array operations. [vectorization](#term-vectorization)
    can refer both to the C offloading and to structuring NumPy code to leverage it.
  prefs: []
  type: TYPE_NORMAL
- en: view
  prefs: []
  type: TYPE_NORMAL
- en: Without touching underlying data, NumPy can make one array appear to change
    its datatype and shape.
  prefs: []
  type: TYPE_NORMAL
- en: An array created this way is a *view*, and NumPy often exploits the performance
    gain of using a view versus making a new array.
  prefs: []
  type: TYPE_NORMAL
- en: A potential drawback is that writing to a view can alter the original as well.
    If this is a problem, NumPy instead needs to create a physically distinct array
    – a [`copy`](https://docs.python.org/3/library/copy.html#module-copy "(in Python
    v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Some NumPy routines always return views, some always return copies, some may
    return one or the other, and for some the choice can be specified. Responsibility
    for managing views and copies falls to the programmer. [`numpy.shares_memory`](reference/generated/numpy.shares_memory.html#numpy.shares_memory
    "numpy.shares_memory") will check whether `b` is a view of `a`, but an exact answer
    isn’t always feasible, as the documentation page explains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
