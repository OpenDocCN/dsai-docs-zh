["```py\nimport pandas as pd\n\ndf = pd.DataFrame({'a': [1, 2, 3]})\ndf[:2].loc[:, 'a'] = 5 \n```", "```py\n.../site-packages/pandas/core/indexing.py:1951: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nsetting_with_copy_warning.py:4: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nIn [1]: arr = pd.array([1, 2, pd.NA])\n\nIn [2]: idx = pd.Index(arr) \n```", "```py\nIn [1]: idx\nOut[1]: Index([1, 2, <NA>], dtype='object') \n```", "```py\nIn [3]: idx\nOut[3]: Index([1, 2, <NA>], dtype='Int64') \n```", "```py\nIn [4]: s = pd.Series([1, 4, 2, 3, 5, 3])\n\nIn [5]: s.rolling(3).rank()\nOut[5]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    1.5\ndtype: float64\n\nIn [6]: s.rolling(3).rank(method=\"max\")\nOut[6]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    2.0\ndtype: float64 \n```", "```py\nIn [7]: df = pd.DataFrame([[\"g\", \"g0\"], [\"g\", \"g1\"], [\"g\", \"g2\"], [\"g\", \"g3\"],\n ...:                   [\"h\", \"h0\"], [\"h\", \"h1\"]], columns=[\"A\", \"B\"])\n ...: \n\nIn [8]: df.groupby(\"A\").head(-1)\nOut[8]: \n A   B\n0  g  g0\n1  g  g1\n2  g  g2\n4  h  h0 \n```", "```py\nIn [9]: df.groupby(\"A\").nth(slice(1, -1))\nOut[9]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [10]: df.groupby(\"A\").nth([slice(None, 1), slice(-1, None)])\nOut[10]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [11]: df.groupby(\"A\").nth[1, -1]\nOut[11]: \n A   B\n1  g  g1\n3  g  g3\n5  h  h1\n\nIn [12]: df.groupby(\"A\").nth[1:-1]\nOut[12]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [13]: df.groupby(\"A\").nth[:1, -1:]\nOut[13]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [14]: df = pd.DataFrame.from_records(\n ....:    [[1, 3], [2, 4]],\n ....:    index=pd.MultiIndex.from_tuples([(\"a\", \"b\"), (\"a\", \"c\")],\n ....:                                    names=[\"n1\", \"n2\"]),\n ....:    columns=pd.MultiIndex.from_tuples([(\"x\", 1), (\"y\", 2)],\n ....:                                      names=[\"z1\", \"z2\"]),\n ....: )\n ....: \n\nIn [15]: df\nOut[15]: \nz1     x  y\nz2     1  2\nn1 n2 \na  b   1  3\n c   2  4\n\nIn [16]: df.to_dict(orient='tight')\nOut[16]: \n{'index': [('a', 'b'), ('a', 'c')],\n 'columns': [('x', 1), ('y', 2)],\n 'data': [[1, 3], [2, 4]],\n 'index_names': ['n1', 'n2'],\n 'column_names': ['z1', 'z2']} \n```", "```py\nIn [17]: pd.to_datetime([\"31-12-2021\"], dayfirst=False)\nOut[17]: DatetimeIndex(['2021-12-31'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [3]: df1 = pd.DataFrame({\"bar\": [pd.Timestamp(\"2013-01-01\")]}, index=range(1))\nIn [4]: df2 = pd.DataFrame({\"bar\": np.nan}, index=range(1, 2))\nIn [5]: res = pd.concat([df1, df2]) \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0 2013-01-01\n1        NaT \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0  2013-01-01 00:00:00\n1                  NaN \n```", "```py\nIn [18]: s = pd.Series([True, None, pd.NaT, None, pd.NaT, None])\n\nIn [19]: res = s.value_counts(dropna=False) \n```", "```py\nIn [3]: res\nOut[3]:\nNaN     5\nTrue    1\ndtype: int64 \n```", "```py\nIn [20]: res\nOut[20]: \nNone    3\nNaT     2\nTrue    1\nName: count, dtype: int64 \n```", "```py\nIn [21]: import io\n\nIn [22]: data = \"a,a,a.1\\n1,2,3\"\n\nIn [23]: res = pd.read_csv(io.StringIO(data)) \n```", "```py\nIn [3]: res\nOut[3]:\n a  a.1  a.1.1\n0   1    2      3 \n```", "```py\nIn [24]: res\nOut[24]: \n a  a.2  a.1\n0  1    2    3 \n```", "```py\nIn [3]: df = DataFrame({\"ind1\": np.arange(2 ** 16), \"ind2\": np.arange(2 ** 16), \"count\": 0})\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nValueError: Unstacked DataFrame is too big, causing int32 overflow \n```", "```py\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nPerformanceWarning: The following operation may generate 4294967296 cells in the resulting pandas object. \n```", "```py\nIn [25]: def func(x):\n ....:    return x.copy()\n ....: \n\nIn [26]: df = pd.DataFrame({'a': [1, 2], 'b': [3, 4], 'c': [5, 6]})\n\nIn [27]: df\nOut[27]: \n a  b  c\n0  1  3  5\n1  2  4  6 \n```", "```py\nIn [3]: df.groupby(['a']).apply(func)\nOut[3]:\n a  b  c\na\n1 0  1  3  5\n2 1  2  4  6\n\nIn [4]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[4]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\nIn [5]: df.groupby(['a']).apply(func)\nOut[5]:\n a  b  c\n0  1  3  5\n1  2  4  6\n\nIn [6]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[6]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\n# replace\npd.Int64Index([1, 2, 3])\n# with\npd.Index([1, 2, 3], dtype=\"int64\") \n```", "```py\n# replace\nisinstance(idx, pd.Int64Index)\n# with\nidx.dtype == \"int64\" \n```", "```py\nIn [1]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [1]: Int64Index([1, 2, 3], dtype='int64')\nIn [1]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [1]: UInt64Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [3]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [3]: Index([1, 2, 3], dtype='int32')\nIn [4]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [4]: Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [1]: pd.Series([1, 2]).append(pd.Series([3, 4])\nOut [1]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [2]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\nIn [3]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\nIn [4]: df1.append(df2)\nOut [4]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```", "```py\nIn [28]: pd.concat([pd.Series([1, 2]), pd.Series([3, 4])])\nOut[28]: \n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [29]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n\nIn [30]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n\nIn [31]: pd.concat([df1, df2])\nOut[31]: \n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```", "```py\nimport pandas as pd\n\ndf = pd.DataFrame({'a': [1, 2, 3]})\ndf[:2].loc[:, 'a'] = 5 \n```", "```py\n.../site-packages/pandas/core/indexing.py:1951: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nsetting_with_copy_warning.py:4: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nIn [1]: arr = pd.array([1, 2, pd.NA])\n\nIn [2]: idx = pd.Index(arr) \n```", "```py\nIn [1]: idx\nOut[1]: Index([1, 2, <NA>], dtype='object') \n```", "```py\nIn [3]: idx\nOut[3]: Index([1, 2, <NA>], dtype='Int64') \n```", "```py\nIn [4]: s = pd.Series([1, 4, 2, 3, 5, 3])\n\nIn [5]: s.rolling(3).rank()\nOut[5]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    1.5\ndtype: float64\n\nIn [6]: s.rolling(3).rank(method=\"max\")\nOut[6]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    2.0\ndtype: float64 \n```", "```py\nIn [7]: df = pd.DataFrame([[\"g\", \"g0\"], [\"g\", \"g1\"], [\"g\", \"g2\"], [\"g\", \"g3\"],\n ...:                   [\"h\", \"h0\"], [\"h\", \"h1\"]], columns=[\"A\", \"B\"])\n ...: \n\nIn [8]: df.groupby(\"A\").head(-1)\nOut[8]: \n A   B\n0  g  g0\n1  g  g1\n2  g  g2\n4  h  h0 \n```", "```py\nIn [9]: df.groupby(\"A\").nth(slice(1, -1))\nOut[9]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [10]: df.groupby(\"A\").nth([slice(None, 1), slice(-1, None)])\nOut[10]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [11]: df.groupby(\"A\").nth[1, -1]\nOut[11]: \n A   B\n1  g  g1\n3  g  g3\n5  h  h1\n\nIn [12]: df.groupby(\"A\").nth[1:-1]\nOut[12]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [13]: df.groupby(\"A\").nth[:1, -1:]\nOut[13]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [14]: df = pd.DataFrame.from_records(\n ....:    [[1, 3], [2, 4]],\n ....:    index=pd.MultiIndex.from_tuples([(\"a\", \"b\"), (\"a\", \"c\")],\n ....:                                    names=[\"n1\", \"n2\"]),\n ....:    columns=pd.MultiIndex.from_tuples([(\"x\", 1), (\"y\", 2)],\n ....:                                      names=[\"z1\", \"z2\"]),\n ....: )\n ....: \n\nIn [15]: df\nOut[15]: \nz1     x  y\nz2     1  2\nn1 n2 \na  b   1  3\n c   2  4\n\nIn [16]: df.to_dict(orient='tight')\nOut[16]: \n{'index': [('a', 'b'), ('a', 'c')],\n 'columns': [('x', 1), ('y', 2)],\n 'data': [[1, 3], [2, 4]],\n 'index_names': ['n1', 'n2'],\n 'column_names': ['z1', 'z2']} \n```", "```py\nimport pandas as pd\n\ndf = pd.DataFrame({'a': [1, 2, 3]})\ndf[:2].loc[:, 'a'] = 5 \n```", "```py\n.../site-packages/pandas/core/indexing.py:1951: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nsetting_with_copy_warning.py:4: SettingWithCopyWarning:\nA value is trying to be set on a copy of a slice from a DataFrame. \n```", "```py\nIn [1]: arr = pd.array([1, 2, pd.NA])\n\nIn [2]: idx = pd.Index(arr) \n```", "```py\nIn [1]: idx\nOut[1]: Index([1, 2, <NA>], dtype='object') \n```", "```py\nIn [3]: idx\nOut[3]: Index([1, 2, <NA>], dtype='Int64') \n```", "```py\nIn [4]: s = pd.Series([1, 4, 2, 3, 5, 3])\n\nIn [5]: s.rolling(3).rank()\nOut[5]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    1.5\ndtype: float64\n\nIn [6]: s.rolling(3).rank(method=\"max\")\nOut[6]: \n0    NaN\n1    NaN\n2    2.0\n3    2.0\n4    3.0\n5    2.0\ndtype: float64 \n```", "```py\nIn [7]: df = pd.DataFrame([[\"g\", \"g0\"], [\"g\", \"g1\"], [\"g\", \"g2\"], [\"g\", \"g3\"],\n ...:                   [\"h\", \"h0\"], [\"h\", \"h1\"]], columns=[\"A\", \"B\"])\n ...: \n\nIn [8]: df.groupby(\"A\").head(-1)\nOut[8]: \n A   B\n0  g  g0\n1  g  g1\n2  g  g2\n4  h  h0 \n```", "```py\nIn [9]: df.groupby(\"A\").nth(slice(1, -1))\nOut[9]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [10]: df.groupby(\"A\").nth([slice(None, 1), slice(-1, None)])\nOut[10]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [11]: df.groupby(\"A\").nth[1, -1]\nOut[11]: \n A   B\n1  g  g1\n3  g  g3\n5  h  h1\n\nIn [12]: df.groupby(\"A\").nth[1:-1]\nOut[12]: \n A   B\n1  g  g1\n2  g  g2\n\nIn [13]: df.groupby(\"A\").nth[:1, -1:]\nOut[13]: \n A   B\n0  g  g0\n3  g  g3\n4  h  h0\n5  h  h1 \n```", "```py\nIn [14]: df = pd.DataFrame.from_records(\n ....:    [[1, 3], [2, 4]],\n ....:    index=pd.MultiIndex.from_tuples([(\"a\", \"b\"), (\"a\", \"c\")],\n ....:                                    names=[\"n1\", \"n2\"]),\n ....:    columns=pd.MultiIndex.from_tuples([(\"x\", 1), (\"y\", 2)],\n ....:                                      names=[\"z1\", \"z2\"]),\n ....: )\n ....: \n\nIn [15]: df\nOut[15]: \nz1     x  y\nz2     1  2\nn1 n2 \na  b   1  3\n c   2  4\n\nIn [16]: df.to_dict(orient='tight')\nOut[16]: \n{'index': [('a', 'b'), ('a', 'c')],\n 'columns': [('x', 1), ('y', 2)],\n 'data': [[1, 3], [2, 4]],\n 'index_names': ['n1', 'n2'],\n 'column_names': ['z1', 'z2']} \n```", "```py\nIn [17]: pd.to_datetime([\"31-12-2021\"], dayfirst=False)\nOut[17]: DatetimeIndex(['2021-12-31'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [3]: df1 = pd.DataFrame({\"bar\": [pd.Timestamp(\"2013-01-01\")]}, index=range(1))\nIn [4]: df2 = pd.DataFrame({\"bar\": np.nan}, index=range(1, 2))\nIn [5]: res = pd.concat([df1, df2]) \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0 2013-01-01\n1        NaT \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0  2013-01-01 00:00:00\n1                  NaN \n```", "```py\nIn [18]: s = pd.Series([True, None, pd.NaT, None, pd.NaT, None])\n\nIn [19]: res = s.value_counts(dropna=False) \n```", "```py\nIn [3]: res\nOut[3]:\nNaN     5\nTrue    1\ndtype: int64 \n```", "```py\nIn [20]: res\nOut[20]: \nNone    3\nNaT     2\nTrue    1\nName: count, dtype: int64 \n```", "```py\nIn [21]: import io\n\nIn [22]: data = \"a,a,a.1\\n1,2,3\"\n\nIn [23]: res = pd.read_csv(io.StringIO(data)) \n```", "```py\nIn [3]: res\nOut[3]:\n a  a.1  a.1.1\n0   1    2      3 \n```", "```py\nIn [24]: res\nOut[24]: \n a  a.2  a.1\n0  1    2    3 \n```", "```py\nIn [3]: df = DataFrame({\"ind1\": np.arange(2 ** 16), \"ind2\": np.arange(2 ** 16), \"count\": 0})\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nValueError: Unstacked DataFrame is too big, causing int32 overflow \n```", "```py\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nPerformanceWarning: The following operation may generate 4294967296 cells in the resulting pandas object. \n```", "```py\nIn [25]: def func(x):\n ....:    return x.copy()\n ....: \n\nIn [26]: df = pd.DataFrame({'a': [1, 2], 'b': [3, 4], 'c': [5, 6]})\n\nIn [27]: df\nOut[27]: \n a  b  c\n0  1  3  5\n1  2  4  6 \n```", "```py\nIn [3]: df.groupby(['a']).apply(func)\nOut[3]:\n a  b  c\na\n1 0  1  3  5\n2 1  2  4  6\n\nIn [4]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[4]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\nIn [5]: df.groupby(['a']).apply(func)\nOut[5]:\n a  b  c\n0  1  3  5\n1  2  4  6\n\nIn [6]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[6]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\nIn [17]: pd.to_datetime([\"31-12-2021\"], dayfirst=False)\nOut[17]: DatetimeIndex(['2021-12-31'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [3]: df1 = pd.DataFrame({\"bar\": [pd.Timestamp(\"2013-01-01\")]}, index=range(1))\nIn [4]: df2 = pd.DataFrame({\"bar\": np.nan}, index=range(1, 2))\nIn [5]: res = pd.concat([df1, df2]) \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0 2013-01-01\n1        NaT \n```", "```py\nIn [6]: res\nOut[6]:\n bar\n0  2013-01-01 00:00:00\n1                  NaN \n```", "```py\nIn [18]: s = pd.Series([True, None, pd.NaT, None, pd.NaT, None])\n\nIn [19]: res = s.value_counts(dropna=False) \n```", "```py\nIn [3]: res\nOut[3]:\nNaN     5\nTrue    1\ndtype: int64 \n```", "```py\nIn [20]: res\nOut[20]: \nNone    3\nNaT     2\nTrue    1\nName: count, dtype: int64 \n```", "```py\nIn [21]: import io\n\nIn [22]: data = \"a,a,a.1\\n1,2,3\"\n\nIn [23]: res = pd.read_csv(io.StringIO(data)) \n```", "```py\nIn [3]: res\nOut[3]:\n a  a.1  a.1.1\n0   1    2      3 \n```", "```py\nIn [24]: res\nOut[24]: \n a  a.2  a.1\n0  1    2    3 \n```", "```py\nIn [3]: df = DataFrame({\"ind1\": np.arange(2 ** 16), \"ind2\": np.arange(2 ** 16), \"count\": 0})\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nValueError: Unstacked DataFrame is too big, causing int32 overflow \n```", "```py\nIn [4]: df.pivot_table(index=\"ind1\", columns=\"ind2\", values=\"count\", aggfunc=\"count\")\nPerformanceWarning: The following operation may generate 4294967296 cells in the resulting pandas object. \n```", "```py\nIn [25]: def func(x):\n ....:    return x.copy()\n ....: \n\nIn [26]: df = pd.DataFrame({'a': [1, 2], 'b': [3, 4], 'c': [5, 6]})\n\nIn [27]: df\nOut[27]: \n a  b  c\n0  1  3  5\n1  2  4  6 \n```", "```py\nIn [3]: df.groupby(['a']).apply(func)\nOut[3]:\n a  b  c\na\n1 0  1  3  5\n2 1  2  4  6\n\nIn [4]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[4]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\nIn [5]: df.groupby(['a']).apply(func)\nOut[5]:\n a  b  c\n0  1  3  5\n1  2  4  6\n\nIn [6]: df.set_index(['a', 'b']).groupby(['a']).apply(func)\nOut[6]:\n c\na b\n1 3  5\n2 4  6 \n```", "```py\n# replace\npd.Int64Index([1, 2, 3])\n# with\npd.Index([1, 2, 3], dtype=\"int64\") \n```", "```py\n# replace\nisinstance(idx, pd.Int64Index)\n# with\nidx.dtype == \"int64\" \n```", "```py\nIn [1]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [1]: Int64Index([1, 2, 3], dtype='int64')\nIn [1]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [1]: UInt64Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [3]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [3]: Index([1, 2, 3], dtype='int32')\nIn [4]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [4]: Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [1]: pd.Series([1, 2]).append(pd.Series([3, 4])\nOut [1]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [2]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\nIn [3]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\nIn [4]: df1.append(df2)\nOut [4]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```", "```py\nIn [28]: pd.concat([pd.Series([1, 2]), pd.Series([3, 4])])\nOut[28]: \n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [29]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n\nIn [30]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n\nIn [31]: pd.concat([df1, df2])\nOut[31]: \n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```", "```py\n# replace\npd.Int64Index([1, 2, 3])\n# with\npd.Index([1, 2, 3], dtype=\"int64\") \n```", "```py\n# replace\nisinstance(idx, pd.Int64Index)\n# with\nidx.dtype == \"int64\" \n```", "```py\nIn [1]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [1]: Int64Index([1, 2, 3], dtype='int64')\nIn [1]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [1]: UInt64Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [3]: pd.Index([1, 2, 3], dtype=\"int32\")\nOut [3]: Index([1, 2, 3], dtype='int32')\nIn [4]: pd.Index([1, 2, 3], dtype=\"uint64\")\nOut [4]: Index([1, 2, 3], dtype='uint64') \n```", "```py\nIn [1]: pd.Series([1, 2]).append(pd.Series([3, 4])\nOut [1]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [2]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\nIn [3]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\nIn [4]: df1.append(df2)\nOut [4]:\n<stdin>:1: FutureWarning: The series.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.\n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```", "```py\nIn [28]: pd.concat([pd.Series([1, 2]), pd.Series([3, 4])])\nOut[28]: \n0    1\n1    2\n0    3\n1    4\ndtype: int64\n\nIn [29]: df1 = pd.DataFrame([[1, 2], [3, 4]], columns=list('AB'))\n\nIn [30]: df2 = pd.DataFrame([[5, 6], [7, 8]], columns=list('AB'))\n\nIn [31]: pd.concat([df1, df2])\nOut[31]: \n A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8 \n```"]