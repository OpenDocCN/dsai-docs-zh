- en: scipy.stats.multinomial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.multinomial.html#scipy.stats.multinomial](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.multinomial.html#scipy.stats.multinomial)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A multinomial random variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of trials
  prefs: []
  type: TYPE_NORMAL
- en: '**p**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Probability of a trial falling into each category; should sum to 1
  prefs: []
  type: TYPE_NORMAL
- en: '**seed**{None, int, np.random.RandomState, np.random.Generator}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Used for drawing random variates. If *seed* is *None*, the *RandomState* singleton
    is used. If *seed* is an int, a new `RandomState` instance is used, seeded with
    seed. If *seed* is already a `RandomState` or `Generator` instance, then that
    object is used. Default is *None*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.stats.binom`](scipy.stats.binom.html#scipy.stats.binom "scipy.stats.binom")'
  prefs: []
  type: TYPE_NORMAL
- en: The binomial distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.random.Generator.multinomial`](https://numpy.org/devdocs/reference/random/generated/numpy.random.Generator.multinomial.html#numpy.random.Generator.multinomial
    "(in NumPy v2.0.dev0)")'
  prefs: []
  type: TYPE_NORMAL
- en: Sampling from the multinomial distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.stats.multivariate_hypergeom`](scipy.stats.multivariate_hypergeom.html#scipy.stats.multivariate_hypergeom
    "scipy.stats.multivariate_hypergeom")'
  prefs: []
  type: TYPE_NORMAL
- en: The multivariate hypergeometric distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '*n* should be a nonnegative integer. Each element of *p* should be in the interval
    \([0,1]\) and the elements should sum to 1\. If they do not sum to 1, the last
    element of the *p* array is not used and is replaced with the remaining probability
    left over from the earlier elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The probability mass function for [`multinomial`](#scipy.stats.multinomial "scipy.stats.multinomial")
    is
  prefs: []
  type: TYPE_NORMAL
- en: \[f(x) = \frac{n!}{x_1! \cdots x_k!} p_1^{x_1} \cdots p_k^{x_k},\]
  prefs: []
  type: TYPE_NORMAL
- en: supported on \(x=(x_1, \ldots, x_k)\) where each \(x_i\) is a nonnegative integer
    and their sum is \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.19.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The multinomial distribution for \(k=2\) is identical to the corresponding
    binomial distribution (tiny numerical differences notwithstanding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions `pmf`, `logpmf`, `entropy`, and `cov` support broadcasting, under
    the convention that the vector parameters (`x` and `p`) are interpreted as if
    each row along the last axis is a single object. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `x.shape == (2, 2)`, `n.shape == (2,)`, and `p.shape == (2,)`, but following
    the rules mentioned above they behave as if the rows `[3, 4]` and `[3, 5]` in
    `x` and `[.3, .7]` in `p` were a single object, and as if we had `x.shape = (2,)`,
    `n.shape = (2,)`, and `p.shape = ()`. To obtain the individual elements without
    broadcasting, we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This broadcasting also works for `cov`, where the output objects are square
    matrices of size `p.shape[-1]`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `n.shape == (2,)` and `p.shape == (2, 2)`, and following the
    rules above, these broadcast as if `p.shape == (2,)`. Thus the result should also
    be of shape `(2,)`, but since each output is a \(2 \times 2\) matrix, the result
    in fact has shape `(2, 2, 2)`, where `result[0]` is equal to `multinomial.cov(n=4,
    p=[.3, .7])` and `result[1]` is equal to `multinomial.cov(n=5, p=[.4, .6])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the object may be called (as a function) to fix the *n* and
    *p* parameters, returning a “frozen” multinomial random variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| **pmf(x, n, p)** | Probability mass function. |'
  prefs: []
  type: TYPE_TB
- en: '| **logpmf(x, n, p)** | Log of the probability mass function. |'
  prefs: []
  type: TYPE_TB
- en: '| **rvs(n, p, size=1, random_state=None)** | Draw random samples from a multinomial
    distribution. |'
  prefs: []
  type: TYPE_TB
- en: '| **entropy(n, p)** | Compute the entropy of the multinomial distribution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **cov(n, p)** | Compute the covariance matrix of the multinomial distribution.
    |'
  prefs: []
  type: TYPE_TB
