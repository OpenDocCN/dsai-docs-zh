["```py\n>>> from sympy import Symbol, symbols\n>>> xpos = Symbol('xpos', positive=True)\n>>> xneg = Symbol('xneg', negative=True)\n>>> x = Symbol('x')\n>>> print(xpos.is_positive)\nTrue\n>>> print(xneg.is_positive)\nFalse\n>>> print(x.is_positive)\nNone \n```", "```py\n>>> xpos > 0\nTrue\n>>> xneg > 0\nFalse\n>>> x > 0\nx > 0\n>>> type(x > 0)\n<class 'sympy.core.relational.StrictGreaterThan'> \n```", "```py\n>>> from sympy import S\n>>> xpos.is_positive is True\nTrue\n>>> xpos.is_positive is S.true\nFalse\n>>> (xpos > 0) is True\nFalse\n>>> (xpos > 0) is S.true\nTrue \n```", "```py\n>>> from sympy import Piecewise\n>>> p = Piecewise((1, x > 0), (2, True))\n>>> p\nPiecewise((1, x > 0), (2, True))\n>>> p.subs(x, 3)\n1 \n```", "```py\n>>> p2 = Piecewise((1, x.is_positive), (2, True))\nTraceback (most recent call last):\n...\nTypeError: Second argument must be a Boolean, not `NoneType` \n```", "```py\n>>> from sympy import Reals, Contains\n>>> x = Symbol('x', real=True)\n>>> y = Symbol('y')\n>>> Contains(x, Reals)\nTrue\n>>> Contains(y, Reals)\nContains(y, Reals)\n>>> Contains(y, Reals).subs(y, 1)\nTrue \n```", "```py\n>>> from sympy import I\n>>> 2 in Reals\nTrue\n>>> I in Reals\nFalse\n>>> x in Reals\nTrue\n>>> y in Reals\nTraceback (most recent call last):\n...\nTypeError: did not evaluate to a bool: (-oo < y) & (y < oo) \n```", "```py\n>>> def both_positive(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     if a.is_positive and b.is_positive:\n...         return True\n...     else:\n...         return False \n```", "```py\n>>> print(both_positive(S(1), S(1)))\nTrue\n>>> print(both_positive(S(1), S(-1)))\nFalse\n>>> print(both_positive(S(-1), S(-1)))\nFalse\n>>> x = Symbol('x') # may or may not be positive\n>>> print(both_positive(S(1), x))\nFalse \n```", "```py\n>>> def both_positive_better(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     if a.is_positive is False or b.is_positive is False:\n...         return False\n...     elif a.is_positive is True and b.is_positive is True:\n...         return True\n...     else:\n...         return None \n```", "```py\n>>> print(both_positive_better(S(1), S(1)))\nTrue\n>>> print(both_positive_better(S(1), S(-1)))\nFalse\n>>> x = Symbol('x')\n>>> y = Symbol('y', positive=True)\n>>> print(both_positive_better(S(1), x))\nNone\n>>> print(both_positive_better(S(-1), x))\nFalse\n>>> print(both_positive_better(S(1), y))\nTrue \n```", "```py\n>>> x = Symbol('x')\n>>> print(x.is_positive)\nNone\n>>> not x.is_positive\nTrue \n```", "```py\n>>> bool(None)\nFalse\n>>> not bool(None)\nTrue\n>>> not None\nTrue \n```", "```py\n>>> x = Symbol('x', positive=True)\n>>> if x.is_positive:\n...     print(\"x is definitely positive\")\n... else:\n...     print(\"x may or may not be positive\")\nx is definitely positive \n```", "```py\n>>> from sympy.core.logic import fuzzy_not, fuzzy_and\n>>> print(fuzzy_not(True))\nFalse\n>>> print(fuzzy_not(False))\nTrue\n>>> print(fuzzy_not(None))\nNone\n>>> print(fuzzy_and([True, True]))\nTrue\n>>> print(fuzzy_and([True, None]))\nNone\n>>> print(fuzzy_and([False, None]))\nFalse \n```", "```py\n>>> def both_positive_best(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     return fuzzy_and([a.is_positive, b.is_positive]) \n```", "```py\n>>> def both_positive(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     if a > 0 and b > 0:\n...         return S.true\n...     else:\n...         return S.false \n```", "```py\n>>> both_positive(1, 2)\nTrue\n>>> both_positive(-1, 1)\nFalse\n>>> x = Symbol('x')  # may or may not be positive\n>>> both_positive(x, 1)\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational \n```", "```py\n>>> x > 0\nx > 0\n>>> bool(x > 0)\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational\n>>> if x > 0:\n...     print(\"x is positive\")\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational \n```", "```py\n>>> from sympy import And, Or, Not\n>>> x > 0\nx > 0\n>>> x > 0 and x < 1\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational\n>>> And(x > 0, x < 1)\n(x > 0) & (x < 1)\n>>> (x > 0) & (x < 1)\n(x > 0) & (x < 1)\n>>> Or(x < 0, x > 1)\n(x > 1) | (x < 0)\n>>> Not(x < 0)\nx >= 0\n>>> ~(x < 0)\nx >= 0 \n```", "```py\n>>> def both_positive_better(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     if (a > 0) is S.false or (b > 0) is S.false:\n...         return S.false\n...     elif (a > 0) is S.true and (b > 0) is S.true:\n...         return S.true\n...     else:\n...         return And(a > 0, b > 0) \n```", "```py\n>>> both_positive_better(S(1), S(2))\nTrue\n>>> both_positive_better(S(1), S(-1))\nFalse\n>>> x, y = symbols(\"x, y\")\n>>> both_positive_better(x, y + 1)\n(x > 0) & (y + 1 > 0)\n>>> both_positive_better(x, S(3))\nx > 0 \n```", "```py\n>>> And(x > 0, 3 > 0)\nx > 0\n>>> And(4 > 0, 3 > 0)\nTrue\n>>> And(-1 > 0, 3 > 0)\nFalse \n```", "```py\n>>> def both_positive_best(a, b):\n...  \"\"\"ask whether a and b are both positive\"\"\"\n...     return And(a > 0, b > 0) \n```", "```py\n>>> both_positive_best(2, 1)\nTrue\n>>> both_positive_best(-1, 2)\nFalse\n>>> both_positive_best(x, 3)\nx > 0\n>>> condition = both_positive_best(x/y, x + y)\n>>> condition\n(x + y > 0) & (x/y > 0)\n>>> condition.subs(x, 1)\n(1/y > 0) & (y + 1 > 0)\n>>> condition.subs(x, 1).subs(y, 2)\nTrue \n```"]