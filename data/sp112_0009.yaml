- en: Linear Algebra (scipy.linalg)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性代数（scipy.linalg）
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html)
- en: When SciPy is built using the optimized ATLAS LAPACK and BLAS libraries, it
    has very fast linear algebra capabilities. If you dig deep enough, all of the
    raw LAPACK and BLAS libraries are available for your use for even more speed.
    In this section, some easier-to-use interfaces to these routines are described.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用优化过的 ATLAS LAPACK 和 BLAS 库构建 SciPy 时，它具有非常快的线性代数功能。如果你深入挖掘，所有原始的 LAPACK 和
    BLAS 库都可以用于更快的计算。在本节中，描述了这些例程的一些更易于使用的接口。
- en: All of these linear algebra routines expect an object that can be converted
    into a 2-D array. The output of these routines is also a 2-D array.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些线性代数例程都期望一个可以转换为二维数组的对象。这些例程的输出也是一个二维数组。
- en: scipy.linalg vs numpy.linalg
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: scipy.linalg vs numpy.linalg
- en: '[`scipy.linalg`](../reference/linalg.html#module-scipy.linalg "scipy.linalg")
    contains all the functions in [numpy.linalg](https://www.numpy.org/devdocs/reference/routines.linalg.html).
    plus some other more advanced ones not contained in `numpy.linalg`.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.linalg`](../reference/linalg.html#module-scipy.linalg "scipy.linalg")
    包含了所有 [numpy.linalg](https://www.numpy.org/devdocs/reference/routines.linalg.html)
    中的函数，还包括一些在 `numpy.linalg` 中不包含的更高级的函数。'
- en: Another advantage of using `scipy.linalg` over `numpy.linalg` is that it is
    always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore,
    the SciPy version might be faster depending on how NumPy was installed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `scipy.linalg` 而不是 `numpy.linalg` 的另一个优势是，它始终编译了 BLAS/LAPACK 支持，而对于 NumPy
    这是可选的。因此，根据 NumPy 的安装方式，SciPy 版本可能更快。
- en: Therefore, unless you don’t want to add `scipy` as a dependency to your `numpy`
    program, use `scipy.linalg` instead of `numpy.linalg`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非你不希望将 `scipy` 作为 `numpy` 程序的依赖项，否则请使用 `scipy.linalg` 而不是 `numpy.linalg`。
- en: numpy.matrix vs 2-D numpy.ndarray
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: numpy.matrix vs 2-D numpy.ndarray
- en: The classes that represent matrices, and basic operations, such as matrix multiplications
    and transpose are a part of `numpy`. For convenience, we summarize the differences
    between [`numpy.matrix`](https://numpy.org/devdocs/reference/generated/numpy.matrix.html#numpy.matrix
    "(in NumPy v2.0.dev0)") and [`numpy.ndarray`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0.dev0)") here.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表示矩阵的类和基本操作，如矩阵乘法和转置，是 `numpy` 的一部分。为了方便起见，我们在这里总结了 [`numpy.matrix`](https://numpy.org/devdocs/reference/generated/numpy.matrix.html#numpy.matrix
    "(in NumPy v2.0.dev0)") 和 [`numpy.ndarray`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0.dev0)") 之间的区别。
- en: '`numpy.matrix` is matrix class that has a more convenient interface than `numpy.ndarray`
    for matrix operations. This class supports, for example, MATLAB-like creation
    syntax via the semicolon, has matrix multiplication as default for the `*` operator,
    and contains `I` and `T` members that serve as shortcuts for inverse and transpose:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.matrix` 是一个矩阵类，其接口比 `numpy.ndarray` 更方便用于矩阵操作。例如，这个类支持类似 MATLAB 的通过分号创建语法，`*`
    运算符默认进行矩阵乘法，并包含 `I` 和 `T` 成员，分别用作求逆和转置的快捷方式：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Despite its convenience, the use of the `numpy.matrix` class is discouraged,
    since it adds nothing that cannot be accomplished with 2-D `numpy.ndarray` objects,
    and may lead to a confusion of which class is being used. For example, the above
    code can be rewritten as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `numpy.matrix` 类很方便，但不建议使用，因为它并没有添加任何不能通过二维 `numpy.ndarray` 对象完成的功能，而且可能导致使用的类混淆。例如，上述代码可以重写为：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`scipy.linalg` operations can be applied equally to `numpy.matrix` or to 2D
    `numpy.ndarray` objects.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.linalg` 的操作可以同样应用于 `numpy.matrix` 或二维 `numpy.ndarray` 对象。'
- en: Basic routines
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本例程
- en: Finding the inverse
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求逆
- en: The inverse of a matrix \(\mathbf{A}\) is the matrix \(\mathbf{B}\), such that
    \(\mathbf{AB}=\mathbf{I}\), where \(\mathbf{I}\) is the identity matrix consisting
    of ones down the main diagonal. Usually, \(\mathbf{B}\) is denoted \(\mathbf{B}=\mathbf{A}^{-1}\)
    . In SciPy, the matrix inverse of the NumPy array, A, is obtained using [`linalg.inv`](../reference/generated/scipy.linalg.inv.html#scipy.linalg.inv
    "scipy.linalg.inv") `(A)`, or using `A.I` if `A` is a Matrix. For example, let
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵 \(\mathbf{A}\) 的逆矩阵是矩阵 \(\mathbf{B}\)，使得 \(\mathbf{AB}=\mathbf{I}\)，其中 \(\mathbf{I}\)
    是由主对角线上的元素为1组成的单位矩阵。通常，\(\mathbf{B}\) 被表示为 \(\mathbf{B}=\mathbf{A}^{-1}\)。在 SciPy
    中，可以使用 [`linalg.inv`](../reference/generated/scipy.linalg.inv.html#scipy.linalg.inv
    "scipy.linalg.inv") `(A)` 获得 NumPy 数组 A 的逆矩阵，或者如果 A 是一个矩阵，则使用 `A.I`。例如，令
- en: \[\begin{split}\mathbf{A} = \left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\
    2 & 3 & 8\end{array}\right],\end{split}\]
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{A} = \left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\
    2 & 3 & 8\end{array}\right],\end{split}\]
- en: then
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: \[\begin{split}\mathbf{A^{-1}} = \frac{1}{25} \left[\begin{array}{ccc} -37 &
    9 & 22 \\ 14 & 2 & -9 \\ 4 & -3 & 1 \end{array}\right] = % \left[\begin{array}{ccc}
    -1.48 & 0.36 & 0.88 \\ 0.56 & 0.08 & -0.36 \\ 0.16 & -0.12 & 0.04 \end{array}\right].\end{split}\]
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{A^{-1}} = \frac{1}{25} \left[\begin{array}{ccc} -37 &
    9 & 22 \\ 14 & 2 & -9 \\ 4 & -3 & 1 \end{array}\right] = % \left[\begin{array}{ccc}
    -1.48 & 0.36 & 0.88 \\ 0.56 & 0.08 & -0.36 \\ 0.16 & -0.12 & 0.04 \end{array}\right].\end{split}\]
- en: The following example demonstrates this computation in SciPy
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了SciPy中的计算过程
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Solving a linear system
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解线性系统
- en: 'Solving linear systems of equations is straightforward using the scipy command
    [`linalg.solve`](../reference/generated/scipy.linalg.solve.html#scipy.linalg.solve
    "scipy.linalg.solve"). This command expects an input matrix and a right-hand side
    vector. The solution vector is then computed. An option for entering a symmetric
    matrix is offered, which can speed up the processing when applicable. As an example,
    suppose it is desired to solve the following simultaneous equations:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SciPy命令[`linalg.solve`](../reference/generated/scipy.linalg.solve.html#scipy.linalg.solve
    "scipy.linalg.solve")可以直接解线性方程组。该命令需要输入一个矩阵和一个右手边向量，然后计算解向量。提供了一个输入对称矩阵的选项，适用时可以加快处理速度。例如，假设要解以下同时方程组：
- en: \begin{eqnarray*} x + 3y + 5z & = & 10 \\ 2x + 5y + z & = & 8 \\ 2x + 3y + 8z
    & = & 3 \end{eqnarray*}
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} x + 3y + 5z & = & 10 \\ 2x + 5y + z & = & 8 \\ 2x + 3y + 8z
    & = & 3 \end{eqnarray*}
- en: 'We could find the solution vector using a matrix inverse:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过矩阵求逆找到解向量：
- en: \[\begin{split}\left[\begin{array}{c} x\\ y\\ z\end{array}\right]=\left[\begin{array}{ccc}
    1 & 3 & 5\\ 2 & 5 & 1\\ 2 & 3 & 8\end{array}\right]^{-1}\left[\begin{array}{c}
    10\\ 8\\ 3\end{array}\right]=\frac{1}{25}\left[\begin{array}{c} -232\\ 129\\ 19\end{array}\right]=\left[\begin{array}{c}
    -9.28\\ 5.16\\ 0.76\end{array}\right].\end{split}\]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\left[\begin{array}{c} x\\ y\\ z\end{array}\right]=\left[\begin{array}{ccc}
    1 & 3 & 5\\ 2 & 5 & 1\\ 2 & 3 & 8\end{array}\right]^{-1}\left[\begin{array}{c}
    10\\ 8\\ 3\end{array}\right]=\frac{1}{25}\left[\begin{array}{c} -232\\ 129\\ 19\end{array}\right]=\left[\begin{array}{c}
    -9.28\\ 5.16\\ 0.76\end{array}\right].\end{split}\]
- en: 'However, it is better to use the linalg.solve command, which can be faster
    and more numerically stable. In this case, it, however, gives the same answer
    as shown in the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好使用 `linalg.solve` 命令，这样可以更快速和更稳定地数值计算。在这种情况下，如下示例所示，它将给出相同的答案：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finding the determinant
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求行列式
- en: The determinant of a square matrix \(\mathbf{A}\) is often denoted \(\left|\mathbf{A}\right|\)
    and is a quantity often used in linear algebra. Suppose \(a_{ij}\) are the elements
    of the matrix \(\mathbf{A}\) and let \(M_{ij}=\left|\mathbf{A}_{ij}\right|\) be
    the determinant of the matrix left by removing the \(i^{\textrm{th}}\) row and
    \(j^{\textrm{th}}\) column from \(\mathbf{A}\) . Then, for any row \(i,\)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 方阵 \(\mathbf{A}\) 的行列式通常表示为 \(\left|\mathbf{A}\right|\)，在线性代数中经常使用。假设 \(a_{ij}\)
    是矩阵 \(\mathbf{A}\) 的元素，并且令 \(M_{ij}=\left|\mathbf{A}_{ij}\right|\) 是通过从 \(\mathbf{A}\)
    中去除第 \(i^{\textrm{th}}\) 行和第 \(j^{\textrm{th}}\) 列后留下的矩阵的行列式。那么，对于任意行 \(i\),
- en: \[\left|\mathbf{A}\right|=\sum_{j}\left(-1\right)^{i+j}a_{ij}M_{ij}.\]
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left|\mathbf{A}\right|=\sum_{j}\left(-1\right)^{i+j}a_{ij}M_{ij}.\]
- en: This is a recursive way to define the determinant, where the base case is defined
    by accepting that the determinant of a \(1\times1\) matrix is the only matrix
    element. In SciPy the determinant can be calculated with [`linalg.det`](../reference/generated/scipy.linalg.det.html#scipy.linalg.det
    "scipy.linalg.det"). For example, the determinant of
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义行列式的递归方式，其中基本情况是接受 \(1\times1\) 矩阵的行列式仅为矩阵元素。在SciPy中，可以使用[`linalg.det`](../reference/generated/scipy.linalg.det.html#scipy.linalg.det
    "scipy.linalg.det")计算行列式。例如，矩阵的行列式为
- en: \[\begin{split}\mathbf{A=}\left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\ 2
    & 3 & 8\end{array}\right]\end{split}\]
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{A=}\left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\ 2
    & 3 & 8\end{array}\right]\end{split}\]
- en: is
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: \begin{eqnarray*} \left|\mathbf{A}\right| & = & 1\left|\begin{array}{cc} 5 &
    1\\ 3 & 8\end{array}\right|-3\left|\begin{array}{cc} 2 & 1\\ 2 & 8\end{array}\right|+5\left|\begin{array}{cc}
    2 & 5\\ 2 & 3\end{array}\right|\\ & = & 1\left(5\cdot8-3\cdot1\right)-3\left(2\cdot8-2\cdot1\right)+5\left(2\cdot3-2\cdot5\right)=-25.\end{eqnarray*}.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \left|\mathbf{A}\right| & = & 1\left|\begin{array}{cc} 5 &
    1\\ 3 & 8\end{array}\right|-3\left|\begin{array}{cc} 2 & 1\\ 2 & 8\end{array}\right|+5\left|\begin{array}{cc}
    2 & 5\\ 2 & 3\end{array}\right|\\ & = & 1\left(5\cdot8-3\cdot1\right)-3\left(2\cdot8-2\cdot1\right)+5\left(2\cdot3-2\cdot5\right)=-25.\end{eqnarray*}.
- en: 'In SciPy, this is computed as shown in this example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在SciPy中，计算如下所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Computing norms
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算范数
- en: Matrix and vector norms can also be computed with SciPy. A wide range of norm
    definitions are available using different parameters to the order argument of
    [`linalg.norm`](../reference/generated/scipy.linalg.norm.html#scipy.linalg.norm
    "scipy.linalg.norm"). This function takes a rank-1 (vectors) or a rank-2 (matrices)
    array and an optional order argument (default is 2). Based on these inputs, a
    vector or matrix norm of the requested order is computed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用SciPy计算矩阵和向量的范数。使用`linalg.norm`函数可以根据order参数（默认为2）计算所需阶数的向量或矩阵范数。这个函数接受一个秩为1（向量）或秩为2（矩阵）的数组以及一个可选的order参数。
- en: For vector *x*, the order parameter can be any real number including `inf` or
    `-inf`. The computed norm is
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量*x*，参数可以是任意实数，包括`inf`或`-inf`。计算得到的范数为
- en: \[\begin{split}\left\Vert \mathbf{x}\right\Vert =\left\{ \begin{array}{cc} \max\left|x_{i}\right|
    & \textrm{ord}=\textrm{inf}\\ \min\left|x_{i}\right| & \textrm{ord}=-\textrm{inf}\\
    \left(\sum_{i}\left|x_{i}\right|^{\textrm{ord}}\right)^{1/\textrm{ord}} & \left|\textrm{ord}\right|<\infty.\end{array}\right.\end{split}\]
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\left\Vert \mathbf{x}\right\Vert =\left\{ \begin{array}{cc} \max\left|x_{i}\right|
    & \textrm{ord}=\textrm{inf}\\ \min\left|x_{i}\right| & \textrm{ord}=-\textrm{inf}\\
    \left(\sum_{i}\left|x_{i}\right|^{\textrm{ord}}\right)^{1/\textrm{ord}} & \left|\textrm{ord}\right|<\infty.\end{array}\right.\end{split}\]
- en: For matrix \(\mathbf{A}\), the only valid values for norm are \(\pm2,\pm1,\)
    \(\pm\) inf, and ‘fro’ (or ‘f’) Thus,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于矩阵\(\mathbf{A}\)，范数的有效值只有\(\pm2,\pm1,\) \(\pm\) inf和‘fro’（或‘f’）。因此，
- en: \[\begin{split}\left\Vert \mathbf{A}\right\Vert =\left\{ \begin{array}{cc} \max_{i}\sum_{j}\left|a_{ij}\right|
    & \textrm{ord}=\textrm{inf}\\ \min_{i}\sum_{j}\left|a_{ij}\right| & \textrm{ord}=-\textrm{inf}\\
    \max_{j}\sum_{i}\left|a_{ij}\right| & \textrm{ord}=1\\ \min_{j}\sum_{i}\left|a_{ij}\right|
    & \textrm{ord}=-1\\ \max\sigma_{i} & \textrm{ord}=2\\ \min\sigma_{i} & \textrm{ord}=-2\\
    \sqrt{\textrm{trace}\left(\mathbf{A}^{H}\mathbf{A}\right)} & \textrm{ord}=\textrm{'fro'}\end{array}\right.\end{split}\]
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\left\Vert \mathbf{A}\right\Vert =\left\{ \begin{array}{cc} \max_{i}\sum_{j}\left|a_{ij}\right|
    & \textrm{ord}=\textrm{inf}\\ \min_{i}\sum_{j}\left|a_{ij}\right| & \textrm{ord}=-\textrm{inf}\\
    \max_{j}\sum_{i}\left|a_{ij}\right| & \textrm{ord}=1\\ \min_{j}\sum_{i}\left|a_{ij}\right|
    & \textrm{ord}=-1\\ \max\sigma_{i} & \textrm{ord}=2\\ \min\sigma_{i} & \textrm{ord}=-2\\
    \sqrt{\textrm{trace}\left(\mathbf{A}^{H}\mathbf{A}\right)} & \textrm{ord}=\textrm{'fro'}\end{array}\right.\end{split}\]
- en: where \(\sigma_{i}\) are the singular values of \(\mathbf{A}\).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(\sigma_{i}\)是矩阵\(\mathbf{A}\)的奇异值。
- en: 'Examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Solving linear least-squares problems and pseudo-inverses
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决线性最小二乘问题和伪逆
- en: Linear least-squares problems occur in many branches of applied mathematics.
    In this problem, a set of linear scaling coefficients is sought that allows a
    model to fit the data. In particular, it is assumed that data \(y_{i}\) is related
    to data \(\mathbf{x}_{i}\) through a set of coefficients \(c_{j}\) and model functions
    \(f_{j}\left(\mathbf{x}_{i}\right)\) via the model
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 线性最小二乘问题在应用数学的许多分支中出现。在这个问题中，寻找一组线性缩放系数，使得模型能够拟合数据。特别地，假设数据\(y_{i}\)通过系数\(c_{j}\)和模型函数\(f_{j}\left(\mathbf{x}_{i}\right)\)与数据\(\mathbf{x}_{i}\)相关联，模型表达式为
- en: \[y_{i}=\sum_{j}c_{j}f_{j}\left(\mathbf{x}_{i}\right)+\epsilon_{i},\]
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: \[y_{i}=\sum_{j}c_{j}f_{j}\left(\mathbf{x}_{i}\right)+\epsilon_{i},\]
- en: where \(\epsilon_{i}\) represents uncertainty in the data. The strategy of least
    squares is to pick the coefficients \(c_{j}\) to minimize
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(\epsilon_{i}\)表示数据中的不确定性。最小二乘策略是选择系数\(c_{j}\)使得
- en: \[J\left(\mathbf{c}\right)=\sum_{i}\left|y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right|^{2}.\]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: \[J\left(\mathbf{c}\right)=\sum_{i}\left|y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right|^{2}.\]
- en: Theoretically, a global minimum will occur when
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，全局最小值发生在
- en: \[\frac{\partial J}{\partial c_{n}^{*}}=0=\sum_{i}\left(y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right)\left(-f_{n}^{*}\left(x_{i}\right)\right)\]
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{\partial J}{\partial c_{n}^{*}}=0=\sum_{i}\left(y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right)\left(-f_{n}^{*}\left(x_{i}\right)\right)\]
- en: or
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: \begin{eqnarray*} \sum_{j}c_{j}\sum_{i}f_{j}\left(x_{i}\right)f_{n}^{*}\left(x_{i}\right)
    & = & \sum_{i}y_{i}f_{n}^{*}\left(x_{i}\right)\\ \mathbf{A}^{H}\mathbf{Ac} & =
    & \mathbf{A}^{H}\mathbf{y}\end{eqnarray*},
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \sum_{j}c_{j}\sum_{i}f_{j}\left(x_{i}\right)f_{n}^{*}\left(x_{i}\right)
    & = & \sum_{i}y_{i}f_{n}^{*}\left(x_{i}\right)\\ \mathbf{A}^{H}\mathbf{Ac} & =
    & \mathbf{A}^{H}\mathbf{y}\end{eqnarray*},
- en: where
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: \[\left\{ \mathbf{A}\right\} _{ij}=f_{j}\left(x_{i}\right).\]
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left\{ \mathbf{A}\right\} _{ij}=f_{j}\left(x_{i}\right).\]
- en: When \(\mathbf{A^{H}A}\) is invertible, then
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当\(\mathbf{A^{H}A}\)可逆时，
- en: \[\mathbf{c}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\mathbf{y}=\mathbf{A}^{\dagger}\mathbf{y},\]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{c}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\mathbf{y}=\mathbf{A}^{\dagger}\mathbf{y},\]
- en: where \(\mathbf{A}^{\dagger}\) is called the pseudo-inverse of \(\mathbf{A}.\)
    Notice that using this definition of \(\mathbf{A}\) the model can be written
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(\mathbf{A}^{\dagger}\)被称为\(\mathbf{A}\)的伪逆。请注意，使用此定义的\(\mathbf{A}\)模型可以写成
- en: \[\mathbf{y}=\mathbf{Ac}+\boldsymbol{\epsilon}.\]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{y}=\mathbf{Ac}+\boldsymbol{\epsilon}.\]
- en: The command [`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq") will solve the linear least-squares problem for \(\mathbf{c}\)
    given \(\mathbf{A}\) and \(\mathbf{y}\) . In addition, [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv") will find \(\mathbf{A}^{\dagger}\) given \(\mathbf{A}.\)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 命令[`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq")将解决线性最小二乘问题，给定\(\mathbf{A}\)和\(\mathbf{y}\)。此外，[`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv")将给出\(\mathbf{A}^{\dagger}\)，给定\(\mathbf{A}\)。
- en: 'The following example and figure demonstrate the use of [`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq") and [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv") for solving a data-fitting problem. The data shown below
    were generated using the model:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的示例和图表演示了使用[`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq")和[`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv")解决数据拟合问题。下面显示的数据是使用以下模型生成的:'
- en: \[y_{i}=c_{1}e^{-x_{i}}+c_{2}x_{i},\]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: \[y_{i}=c_{1}e^{-x_{i}}+c_{2}x_{i},\]
- en: where \(x_{i}=0.1i\) for \(i=1\ldots10\) , \(c_{1}=5\), and \(c_{2}=4.\) Noise
    is added to \(y_{i}\) and the coefficients \(c_{1}\) and \(c_{2}\) are estimated
    using linear least squares.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当\(i=1\ldots10\)时，\(x_{i}=0.1i\)，\(c_{1}=5\)，\(c_{2}=4\)。在\(y_{i}\)和系数\(c_{1}\)、\(c_{2}\)上添加噪声，并使用线性最小二乘法估计。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![" "](../Images/ca5015be6607724281e9ca72e23c1053.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/ca5015be6607724281e9ca72e23c1053.png)'
- en: Generalized inverse
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广义逆
- en: The generalized inverse is calculated using the command [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv"). Let \(\mathbf{A}\) be an \(M\times N\) matrix, then if \(M>N\),
    the generalized inverse is
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令[`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv")计算广义逆。设\(\mathbf{A}\)为一个\(M\times N\)矩阵，若\(M>N\)，则广义逆为
- en: \[\mathbf{A}^{\dagger}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H},\]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}^{\dagger}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H},\]
- en: while if \(M<N\) matrix, the generalized inverse is
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(M<N\)，则矩阵的广义逆是
- en: \[\mathbf{A}^{\#}=\mathbf{A}^{H}\left(\mathbf{A}\mathbf{A}^{H}\right)^{-1}.\]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}^{\#}=\mathbf{A}^{H}\left(\mathbf{A}\mathbf{A}^{H}\right)^{-1}.\]
- en: In the case that \(M=N\), then
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(M=N\)，则
- en: \[\mathbf{A}^{\dagger}=\mathbf{A}^{\#}=\mathbf{A}^{-1},\]
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}^{\dagger}=\mathbf{A}^{\#}=\mathbf{A}^{-1},\]
- en: as long as \(\mathbf{A}\) is invertible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 只要\(\mathbf{A}\)是可逆的。
- en: Decompositions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解
- en: In many applications, it is useful to decompose a matrix using other representations.
    There are several decompositions supported by SciPy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，使用其他表示法对矩阵进行分解是有用的。SciPy支持几种分解方法。
- en: Eigenvalues and eigenvectors
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特征值和特征向量
- en: The eigenvalue-eigenvector problem is one of the most commonly employed linear
    algebra operations. In one popular form, the eigenvalue-eigenvector problem is
    to find for some square matrix \(\mathbf{A}\) scalars \(\lambda\) and corresponding
    vectors \(\mathbf{v}\), such that
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值-特征向量问题是最常用的线性代数操作之一。在一个流行的形式中，特征值-特征向量问题是为某个方阵\(\mathbf{A}\)找到标量\(\lambda\)和相应向量\(\mathbf{v}\)，使得
- en: \[\mathbf{Av}=\lambda\mathbf{v}.\]
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{Av}=\lambda\mathbf{v}.\]
- en: For an \(N\times N\) matrix, there are \(N\) (not necessarily distinct) eigenvalues
    — roots of the (characteristic) polynomial
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个\(N\times N\)矩阵，有\(N\)（不一定是不同的）特征值 — 是多项式的根
- en: \[\left|\mathbf{A}-\lambda\mathbf{I}\right|=0.\]
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left|\mathbf{A}-\lambda\mathbf{I}\right|=0.\]
- en: The eigenvectors, \(\mathbf{v}\), are also sometimes called right eigenvectors
    to distinguish them from another set of left eigenvectors that satisfy
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量\(\mathbf{v}\)有时也被称为右特征向量，以区别于满足以下条件的另一组左特征向量
- en: \[\mathbf{v}_{L}^{H}\mathbf{A}=\lambda\mathbf{v}_{L}^{H}\]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{v}_{L}^{H}\mathbf{A}=\lambda\mathbf{v}_{L}^{H}\]
- en: or
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: \[\mathbf{A}^{H}\mathbf{v}_{L}=\lambda^{*}\mathbf{v}_{L}.\]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}^{H}\mathbf{v}_{L}=\lambda^{*}\mathbf{v}_{L}.\]
- en: With its default optional arguments, the command [`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") returns \(\lambda\) and \(\mathbf{v}.\) However, it can also
    return \(\mathbf{v}_{L}\) and just \(\lambda\) by itself ( [`linalg.eigvals`](../reference/generated/scipy.linalg.eigvals.html#scipy.linalg.eigvals
    "scipy.linalg.eigvals") returns just \(\lambda\) as well).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，命令 [`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") 返回 \(\lambda\) 和 \(\mathbf{v}.\) 然而，它也可以只返回 \(\mathbf{v}_{L}\)
    和 \(\lambda\) 本身（ [`linalg.eigvals`](../reference/generated/scipy.linalg.eigvals.html#scipy.linalg.eigvals
    "scipy.linalg.eigvals") 也只返回 \(\lambda\)）。
- en: In addition, [`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") can also solve the more general eigenvalue problem
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") 也可以解决更一般的特征值问题。
- en: \begin{eqnarray*} \mathbf{Av} & = & \lambda\mathbf{Bv}\\ \mathbf{A}^{H}\mathbf{v}_{L}
    & = & \lambda^{*}\mathbf{B}^{H}\mathbf{v}_{L}\end{eqnarray*}
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \mathbf{Av} & = & \lambda\mathbf{Bv}\\ \mathbf{A}^{H}\mathbf{v}_{L}
    & = & \lambda^{*}\mathbf{B}^{H}\mathbf{v}_{L}\end{eqnarray*}
- en: for square matrices \(\mathbf{A}\) and \(\mathbf{B}.\) The standard eigenvalue
    problem is an example of the general eigenvalue problem for \(\mathbf{B}=\mathbf{I}.\)
    When a generalized eigenvalue problem can be solved, it provides a decomposition
    of \(\mathbf{A}\) as
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方阵 \(\mathbf{A}\) 和 \(\mathbf{B}.\) 标准特征值问题是 \(\mathbf{B}=\mathbf{I}.\) 的一个示例。当可以解决广义特征值问题时，它提供了
    \(\mathbf{A}\) 的分解如下：
- en: \[\mathbf{A}=\mathbf{BV}\boldsymbol{\Lambda}\mathbf{V}^{-1},\]
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}=\mathbf{BV}\boldsymbol{\Lambda}\mathbf{V}^{-1},\]
- en: where \(\mathbf{V}\) is the collection of eigenvectors into columns and \(\boldsymbol{\Lambda}\)
    is a diagonal matrix of eigenvalues.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\mathbf{V}\) 是特征向量的集合列，\(\boldsymbol{\Lambda}\) 是特征值的对角线矩阵。
- en: By definition, eigenvectors are only defined up to a constant scale factor.
    In SciPy, the scaling factor for the eigenvectors is chosen so that \(\left\Vert
    \mathbf{v}\right\Vert ^{2}=\sum_{i}v_{i}^{2}=1.\)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按定义，特征向量仅在一个常数比例因子内定义。在 SciPy 中，特征向量的缩放因子被选择为 \(\left\Vert \mathbf{v}\right\Vert
    ^{2}=\sum_{i}v_{i}^{2}=1.\)
- en: As an example, consider finding the eigenvalues and eigenvectors of the matrix
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑找到矩阵的特征值和特征向量
- en: \[\begin{split}\mathbf{A}=\left[\begin{array}{ccc} 1 & 5 & 2\\ 2 & 4 & 1\\ 3
    & 6 & 2\end{array}\right].\end{split}\]
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{A}=\left[\begin{array}{ccc} 1 & 5 & 2\\ 2 & 4 & 1\\ 3
    & 6 & 2\end{array}\right].\end{split}\]
- en: The characteristic polynomial is
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 特征多项式是
- en: \begin{eqnarray*} \left|\mathbf{A}-\lambda\mathbf{I}\right| & = & \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(2-\lambda\right)-6\right]-\\
    & & 5\left[2\left(2-\lambda\right)-3\right]+2\left[12-3\left(4-\lambda\right)\right]\\
    & = & -\lambda^{3}+7\lambda^{2}+8\lambda-3.\end{eqnarray*}
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \left|\mathbf{A}-\lambda\mathbf{I}\right| & = & \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(2-\lambda\right)-6\right]-\\
    & & 5\left[2\left(2-\lambda\right)-3\right]+2\left[12-3\left(4-\lambda\right)\right]\\
    & = & -\lambda^{3}+7\lambda^{2}+8\lambda-3.\end{eqnarray*}
- en: 'The roots of this polynomial are the eigenvalues of \(\mathbf{A}\):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多项式的根是 \(\mathbf{A}\) 的特征值：
- en: \begin{eqnarray*} \lambda_{1} & = & 7.9579\\ \lambda_{2} & = & -1.2577\\ \lambda_{3}
    & = & 0.2997.\end{eqnarray*}
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \lambda_{1} & = & 7.9579\\ \lambda_{2} & = & -1.2577\\ \lambda_{3}
    & = & 0.2997.\end{eqnarray*}
- en: The eigenvectors corresponding to each eigenvalue can be found using the original
    equation. The eigenvectors associated with these eigenvalues can then be found.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个特征值对应的特征向量可以使用原方程找到。然后可以找到与这些特征值相关的特征向量。
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Singular value decomposition
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奇异值分解
- en: Singular value decomposition (SVD) can be thought of as an extension of the
    eigenvalue problem to matrices that are not square. Let \(\mathbf{A}\) be an \(M\times
    N\) matrix with \(M\) and \(N\) arbitrary. The matrices \(\mathbf{A}^{H}\mathbf{A}\)
    and \(\mathbf{A}\mathbf{A}^{H}\) are square hermitian matrices [[1]](#id3) of
    size \(N\times N\) and \(M\times M\), respectively. It is known that the eigenvalues
    of square hermitian matrices are real and non-negative. In addition, there are
    at most \(\min\left(M,N\right)\) identical non-zero eigenvalues of \(\mathbf{A}^{H}\mathbf{A}\)
    and \(\mathbf{A}\mathbf{A}^{H}.\) Define these positive eigenvalues as \(\sigma_{i}^{2}.\)
    The square-root of these are called singular values of \(\mathbf{A}.\) The eigenvectors
    of \(\mathbf{A}^{H}\mathbf{A}\) are collected by columns into an \(N\times N\)
    unitary [[2]](#id4) matrix \(\mathbf{V}\), while the eigenvectors of \(\mathbf{A}\mathbf{A}^{H}\)
    are collected by columns in the unitary matrix \(\mathbf{U}\), the singular values
    are collected in an \(M\times N\) zero matrix \(\mathbf{\boldsymbol{\Sigma}}\)
    with main diagonal entries set to the singular values. Then
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 奇异值分解（SVD）可以看作是对不是方阵的矩阵的特征值问题的扩展。设\(\mathbf{A}\)是一个\(M\times N\)矩阵，其中\(M\)和\(N\)是任意的。矩阵\(\mathbf{A}^{H}\mathbf{A}\)和\(\mathbf{A}\mathbf{A}^{H}\)是大小分别为\(N\times
    N\)和\(M\times M\)的方正定矩阵。已知方正定矩阵的特征值是实数且非负。此外，\(\mathbf{A}^{H}\mathbf{A}\)和\(\mathbf{A}\mathbf{A}^{H}\)最多有\(\min\left(M,N\right)\)个相同的非零特征值。将这些正特征值定义为\(\sigma_{i}^{2}\)。这些的平方根称为\(\mathbf{A}\)的奇异值。\(\mathbf{A}^{H}\mathbf{A}\)的特征向量按列收集在一个\(N\times
    N\)的酉矩阵\(\mathbf{V}\)中，而\(\mathbf{A}\mathbf{A}^{H}\)的特征向量按列收集在酉矩阵\(\mathbf{U}\)中，奇异值按主对角线项设置为奇异值的\(M\times
    N\)零矩阵\(\mathbf{\boldsymbol{\Sigma}}\)。然后
- en: \[\mathbf{A=U}\boldsymbol{\Sigma}\mathbf{V}^{H}\]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A=U}\boldsymbol{\Sigma}\mathbf{V}^{H}\]
- en: 'is the singular value decomposition of \(\mathbf{A}.\) Every matrix has a singular
    value decomposition. Sometimes, the singular values are called the spectrum of
    \(\mathbf{A}.\) The command [`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd") will return \(\mathbf{U}\) , \(\mathbf{V}^{H}\), and \(\sigma_{i}\)
    as an array of the singular values. To obtain the matrix \(\boldsymbol{\Sigma}\),
    use [`linalg.diagsvd`](../reference/generated/scipy.linalg.diagsvd.html#scipy.linalg.diagsvd
    "scipy.linalg.diagsvd"). The following example illustrates the use of [`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd"):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是矩阵\(\mathbf{A}\)的奇异值分解。每个矩阵都有一个奇异值分解。有时，奇异值被称为\(\mathbf{A}\)的频谱。使用命令[`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd")将返回\(\mathbf{U}\)，\(\mathbf{V}^{H}\)和\(\sigma_{i}\)作为奇异值数组。要获取矩阵\(\boldsymbol{\Sigma}\)，请使用[`linalg.diagsvd`](../reference/generated/scipy.linalg.diagsvd.html#scipy.linalg.diagsvd
    "scipy.linalg.diagsvd")。以下示例说明了[`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd")的使用：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: LU decomposition
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LU分解
- en: The LU decomposition finds a representation for the \(M\times N\) matrix \(\mathbf{A}\)
    as
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解将\(M\times N\)矩阵\(\mathbf{A}\)表示为
- en: \[\mathbf{A}=\mathbf{P}\,\mathbf{L}\,\mathbf{U},\]
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}=\mathbf{P}\,\mathbf{L}\,\mathbf{U},\]
- en: where \(\mathbf{P}\) is an \(M\times M\) permutation matrix (a permutation of
    the rows of the identity matrix), \(\mathbf{L}\) is in \(M\times K\) lower triangular
    or trapezoidal matrix ( \(K=\min\left(M,N\right)\)) with unit-diagonal, and \(\mathbf{U}\)
    is an upper triangular or trapezoidal matrix. The SciPy command for this decomposition
    is [`linalg.lu`](../reference/generated/scipy.linalg.lu.html#scipy.linalg.lu "scipy.linalg.lu").
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(\mathbf{P}\)是一个\(M\times M\)的置换矩阵（单位矩阵的行置换），\(\mathbf{L}\)是一个\(M\times K\)的下三角或梯形矩阵（\(K=\min\left(M,N\right)\)），具有单位对角线，\(\mathbf{U}\)是一个上三角或梯形矩阵。SciPy中进行这种分解的命令是[`linalg.lu`](../reference/generated/scipy.linalg.lu.html#scipy.linalg.lu
    "scipy.linalg.lu")。
- en: Such a decomposition is often useful for solving many simultaneous equations
    where the left-hand side does not change but the right-hand side does. For example,
    suppose we are going to solve
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的分解通常用于解决许多同时方程组，其中左边不变，但右边会发生变化。例如，假设我们要解决
- en: \[\mathbf{A}\mathbf{x}_{i}=\mathbf{b}_{i}\]
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}\mathbf{x}_{i}=\mathbf{b}_{i}\]
- en: for many different \(\mathbf{b}_{i}\). The LU decomposition allows this to be
    written as
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多不同的\(\mathbf{b}_{i}\)，LU分解允许将其写为
- en: \[\mathbf{PLUx}_{i}=\mathbf{b}_{i}.\]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{PLUx}_{i}=\mathbf{b}_{i}.\]
- en: Because \(\mathbf{L}\) is lower-triangular, the equation can be solved for \(\mathbf{U}\mathbf{x}_{i}\)
    and, finally, \(\mathbf{x}_{i}\) very rapidly using forward- and back-substitution.
    An initial time spent factoring \(\mathbf{A}\) allows for very rapid solution
    of similar systems of equations in the future. If the intent for performing LU
    decomposition is for solving linear systems, then the command [`linalg.lu_factor`](../reference/generated/scipy.linalg.lu_factor.html#scipy.linalg.lu_factor
    "scipy.linalg.lu_factor") should be used followed by repeated applications of
    the command [`linalg.lu_solve`](../reference/generated/scipy.linalg.lu_solve.html#scipy.linalg.lu_solve
    "scipy.linalg.lu_solve") to solve the system for each new right-hand side.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 \(\mathbf{L}\) 是下三角形矩阵，这个方程可以通过前向和后向替换非常快速地解出 \(\mathbf{U}\mathbf{x}_{i}\)，最终，通过
    [`linalg.lu_factor`](../reference/generated/scipy.linalg.lu_factor.html#scipy.linalg.lu_factor
    "scipy.linalg.lu_factor") 命令求解每个新右手边的系统。
- en: Cholesky decomposition
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cholesky 分解
- en: Cholesky decomposition is a special case of LU decomposition applicable to Hermitian
    positive definite matrices. When \(\mathbf{A}=\mathbf{A}^{H}\) and \(\mathbf{x}^{H}\mathbf{Ax}\geq0\)
    for all \(\mathbf{x}\), then decompositions of \(\mathbf{A}\) can be found so
    that
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Cholesky 分解是 LU 分解适用于 Hermitian 正定矩阵的特例。当 \(\mathbf{A}=\mathbf{A}^{H}\) 并且对于所有的
    \(\mathbf{x}\)，\(\mathbf{x}^{H}\mathbf{Ax}\geq0\)，则可以找到 \(\mathbf{A}\) 的分解，使得
- en: \begin{eqnarray*} \mathbf{A} & = & \mathbf{U}^{H}\mathbf{U}\\ \mathbf{A} & =
    & \mathbf{L}\mathbf{L}^{H}\end{eqnarray*},
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \mathbf{A} & = & \mathbf{U}^{H}\mathbf{U}\\ \mathbf{A} & =
    & \mathbf{L}\mathbf{L}^{H}\end{eqnarray*}，
- en: where \(\mathbf{L}\) is lower triangular and \(\mathbf{U}\) is upper triangular.
    Notice that \(\mathbf{L}=\mathbf{U}^{H}.\) The command [`linalg.cholesky`](../reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky
    "scipy.linalg.cholesky") computes the Cholesky factorization. For using the Cholesky
    factorization to solve systems of equations, there are also [`linalg.cho_factor`](../reference/generated/scipy.linalg.cho_factor.html#scipy.linalg.cho_factor
    "scipy.linalg.cho_factor") and [`linalg.cho_solve`](../reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve
    "scipy.linalg.cho_solve") routines that work similarly to their LU decomposition
    counterparts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\mathbf{L}\) 是下三角形矩阵，\(\mathbf{U}\) 是上三角形矩阵。注意，\(\mathbf{L}=\mathbf{U}^{H}\)。Cholesky
    分解的命令 [`linalg.cholesky`](../reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky
    "scipy.linalg.cholesky") 计算 Cholesky 因子分解。对于使用 Cholesky 因子分解来解方程组，还有 [`linalg.cho_factor`](../reference/generated/scipy.linalg.cho_factor.html#scipy.linalg.cho_factor
    "scipy.linalg.cho_factor") 和 [`linalg.cho_solve`](../reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve
    "scipy.linalg.cho_solve") 类似于它们的 LU 分解对应的例程。
- en: QR decomposition
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QR 分解
- en: The QR decomposition (sometimes called a polar decomposition) works for any
    \(M\times N\) array and finds an \(M\times M\) unitary matrix \(\mathbf{Q}\) and
    an \(M\times N\) upper-trapezoidal matrix \(\mathbf{R}\), such that
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: QR 分解（有时称为极分解）适用于任何 \(M\times N\) 数组，并找到一个 \(M\times M\) 的酉矩阵 \(\mathbf{Q}\)
    和一个 \(M\times N\) 的上梯形矩阵 \(\mathbf{R}\)，使得
- en: \[\mathbf{A=QR}.\]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A=QR}\]。
- en: Notice that if the SVD of \(\mathbf{A}\) is known, then the QR decomposition
    can be found.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果已知 \(\mathbf{A}\) 的 SVD 分解，则可以找到 QR 分解。
- en: \[\mathbf{A}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{H}=\mathbf{QR}\]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{H}=\mathbf{QR}\]。
- en: implies that \(\mathbf{Q}=\mathbf{U}\) and \(\mathbf{R}=\boldsymbol{\Sigma}\mathbf{V}^{H}.\)
    Note, however, that in SciPy independent algorithms are used to find QR and SVD
    decompositions. The command for QR decomposition is [`linalg.qr`](../reference/generated/scipy.linalg.qr.html#scipy.linalg.qr
    "scipy.linalg.qr").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着 \(\mathbf{Q}=\mathbf{U}\) 和 \(\mathbf{R}=\boldsymbol{\Sigma}\mathbf{V}^{H}\)。然而，在
    SciPy 中使用独立的算法来找到 QR 和 SVD 分解。QR 分解的命令是 [`linalg.qr`](../reference/generated/scipy.linalg.qr.html#scipy.linalg.qr
    "scipy.linalg.qr")。
- en: Schur decomposition
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Schur 分解
- en: For a square \(N\times N\) matrix, \(\mathbf{A}\), the Schur decomposition finds
    (not necessarily unique) matrices \(\mathbf{T}\) and \(\mathbf{Z}\), such that
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个方阵 \(N\times N\)，\(\mathbf{A}\)，Schur 分解找到（不一定唯一的）矩阵 \(\mathbf{T}\) 和 \(\mathbf{Z}\)，使得
- en: \[\mathbf{A}=\mathbf{ZT}\mathbf{Z}^{H},\]
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}=\mathbf{ZT}\mathbf{Z}^{H}\]，
- en: where \(\mathbf{Z}\) is a unitary matrix and \(\mathbf{T}\) is either upper
    triangular or quasi upper triangular, depending on whether or not a real Schur
    form or complex Schur form is requested. For a real Schur form both \(\mathbf{T}\)
    and \(\mathbf{Z}\) are real-valued when \(\mathbf{A}\) is real-valued. When \(\mathbf{A}\)
    is a real-valued matrix, the real Schur form is only quasi upper triangular because
    \(2\times2\) blocks extrude from the main diagonal corresponding to any complex-valued
    eigenvalues. The command [`linalg.schur`](../reference/generated/scipy.linalg.schur.html#scipy.linalg.schur
    "scipy.linalg.schur") finds the Schur decomposition, while the command [`linalg.rsf2csf`](../reference/generated/scipy.linalg.rsf2csf.html#scipy.linalg.rsf2csf
    "scipy.linalg.rsf2csf") converts \(\mathbf{T}\) and \(\mathbf{Z}\) from a real
    Schur form to a complex Schur form. The Schur form is especially useful in calculating
    functions of matrices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\mathbf{Z}\) 是一个酉矩阵，\(\mathbf{T}\) 是上三角或准上三角，具体取决于是否请求实舒尔形式或复舒尔形式。当 \(\mathbf{A}\)
    是实值时，实舒尔形式中 \(\mathbf{T}\) 和 \(\mathbf{Z}\) 都是实数值。当 \(\mathbf{A}\) 是实值矩阵时，实舒尔形式只是准上三角，因为
    \(2\times2\) 块从主对角线伸出，对应于任何复值特征值。命令 [`linalg.schur`](../reference/generated/scipy.linalg.schur.html#scipy.linalg.schur
    "scipy.linalg.schur") 找到舒尔分解，而命令 [`linalg.rsf2csf`](../reference/generated/scipy.linalg.rsf2csf.html#scipy.linalg.rsf2csf
    "scipy.linalg.rsf2csf") 将 \(\mathbf{T}\) 和 \(\mathbf{Z}\) 从实舒尔形式转换为复舒尔形式。舒尔形式在计算矩阵函数时特别有用。
- en: 'The following example illustrates the Schur decomposition:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了舒尔分解：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Interpolative decomposition
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插值分解
- en: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") contains routines for computing the interpolative
    decomposition (ID) of a matrix. For a matrix \(A \in \mathbb{C}^{m \times n}\)
    of rank \(k \leq \min \{ m, n \}\) this is a factorization'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") 包含用于计算矩阵的插值分解（ID）的例程。对于秩为 \(k \leq \min \{ m, n
    \}\) 的矩阵 \(A \in \mathbb{C}^{m \times n}\)，这是一种分解'
- en: \[A \Pi = \begin{bmatrix} A \Pi_{1} & A \Pi_{2} \end{bmatrix} = A \Pi_{1} \begin{bmatrix}
    I & T \end{bmatrix},\]
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: \[A \Pi = \begin{bmatrix} A \Pi_{1} & A \Pi_{2} \end{bmatrix} = A \Pi_{1} \begin{bmatrix}
    I & T \end{bmatrix},\]
- en: where \(\Pi = [\Pi_{1}, \Pi_{2}]\) is a permutation matrix with \(\Pi_{1} \in
    \{ 0, 1 \}^{n \times k}\), i.e., \(A \Pi_{2} = A \Pi_{1} T\). This can equivalently
    be written as \(A = BP\), where \(B = A \Pi_{1}\) and \(P = [I, T] \Pi^{\mathsf{T}}\)
    are the *skeleton* and *interpolation matrices*, respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\Pi = [\Pi_{1}, \Pi_{2}]\) 是一个带有 \(\Pi_{1} \in \{ 0, 1 \}^{n \times k}\)
    的置换矩阵，即 \(A \Pi_{2} = A \Pi_{1} T\)。这等效地可以写成 \(A = BP\)，其中 \(B = A \Pi_{1}\) 和
    \(P = [I, T] \Pi^{\mathsf{T}}\) 是 *骨架* 和 *插值* 矩阵。
- en: See also
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") — for more information.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") — 获取更多信息。'
- en: Matrix functions
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵函数
- en: Consider the function \(f\left(x\right)\) with Taylor series expansion
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑具有泰勒级数展开的函数 \(f\left(x\right)\)
- en: \[f\left(x\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}x^{k}.\]
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: \[f\left(x\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}x^{k}.\]
- en: A matrix function can be defined using this Taylor series for the square matrix
    \(\mathbf{A}\) as
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用这个泰勒级数为方阵 \(\mathbf{A}\) 定义矩阵函数
- en: \[f\left(\mathbf{A}\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}\mathbf{A}^{k}.\]
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: \[f\left(\mathbf{A}\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}\mathbf{A}^{k}.\]
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While this serves as a useful representation of a matrix function, it is rarely
    the best way to calculate a matrix function. In particular, if the matrix is not
    diagonalizable, results may be inaccurate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这提供了矩阵函数的一个有用表示，但这很少是计算矩阵函数的最佳方法。特别是，如果矩阵不可对角化，结果可能不准确。
- en: Exponential and logarithm functions
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指数和对数函数
- en: The matrix exponential is one of the more common matrix functions. The preferred
    method for implementing the matrix exponential is to use scaling and a Padé approximation
    for \(e^{x}\). This algorithm is implemented as [`linalg.expm`](../reference/generated/scipy.linalg.expm.html#scipy.linalg.expm
    "scipy.linalg.expm").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵指数是更常见的矩阵函数之一。实现矩阵指数的首选方法是使用缩放和 Padé 近似来计算 \(e^{x}\)。此算法实现为 [`linalg.expm`](../reference/generated/scipy.linalg.expm.html#scipy.linalg.expm
    "scipy.linalg.expm")。
- en: 'The inverse of the matrix exponential is the matrix logarithm defined as the
    inverse of the matrix exponential:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵指数的逆是作为矩阵对数定义的矩阵对数：
- en: \[\mathbf{A}\equiv\exp\left(\log\left(\mathbf{A}\right)\right).\]
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{A}\equiv\exp\left(\log\left(\mathbf{A}\right)\right).\]
- en: The matrix logarithm can be obtained with [`linalg.logm`](../reference/generated/scipy.linalg.logm.html#scipy.linalg.logm
    "scipy.linalg.logm").
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`linalg.logm`](../reference/generated/scipy.linalg.logm.html#scipy.linalg.logm
    "scipy.linalg.logm") 获得矩阵对数。
- en: Trigonometric functions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三角函数
- en: The trigonometric functions, \(\sin\), \(\cos\), and \(\tan\), are implemented
    for matrices in [`linalg.sinm`](../reference/generated/scipy.linalg.sinm.html#scipy.linalg.sinm
    "scipy.linalg.sinm"), [`linalg.cosm`](../reference/generated/scipy.linalg.cosm.html#scipy.linalg.cosm
    "scipy.linalg.cosm"), and [`linalg.tanm`](../reference/generated/scipy.linalg.tanm.html#scipy.linalg.tanm
    "scipy.linalg.tanm"), respectively. The matrix sine and cosine can be defined
    using Euler’s identity as
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的三角函数，\(\sin\), \(\cos\), 和 \(\tan\), 在 [`linalg.sinm`](../reference/generated/scipy.linalg.sinm.html#scipy.linalg.sinm
    "scipy.linalg.sinm"), [`linalg.cosm`](../reference/generated/scipy.linalg.cosm.html#scipy.linalg.cosm
    "scipy.linalg.cosm"), 和 [`linalg.tanm`](../reference/generated/scipy.linalg.tanm.html#scipy.linalg.tanm
    "scipy.linalg.tanm") 中实现。矩阵正弦和余弦可以使用欧拉恒等式定义为
- en: \begin{eqnarray*} \sin\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}-e^{-j\mathbf{A}}}{2j}\\
    \cos\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}+e^{-j\mathbf{A}}}{2}.\end{eqnarray*}
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \sin\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}-e^{-j\mathbf{A}}}{2j}\\
    \cos\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}+e^{-j\mathbf{A}}}{2}.\end{eqnarray*}
- en: The tangent is
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 切线是
- en: \[\tan\left(x\right)=\frac{\sin\left(x\right)}{\cos\left(x\right)}=\left[\cos\left(x\right)\right]^{-1}\sin\left(x\right)\]
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: \[\tan\left(x\right)=\frac{\sin\left(x\right)}{\cos\left(x\right)}=\left[\cos\left(x\right)\right]^{-1}\sin\left(x\right)\]
- en: and so the matrix tangent is defined as
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，矩阵切线被定义为
- en: \[\left[\cos\left(\mathbf{A}\right)\right]^{-1}\sin\left(\mathbf{A}\right).\]
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left[\cos\left(\mathbf{A}\right)\right]^{-1}\sin\left(\mathbf{A}\right).\]
- en: Hyperbolic trigonometric functions
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超bolic三角函数
- en: 'The hyperbolic trigonometric functions, \(\sinh\), \(\cosh\), and \(\tanh\),
    can also be defined for matrices using the familiar definitions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 超bolic三角函数，\(\sinh\), \(\cosh\), 和 \(\tanh\), 也可以用熟悉的定义为矩阵定义：
- en: \begin{eqnarray*} \sinh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}-e^{-\mathbf{A}}}{2}\\
    \cosh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}+e^{-\mathbf{A}}}{2}\\
    \tanh\left(\mathbf{A}\right) & = & \left[\cosh\left(\mathbf{A}\right)\right]^{-1}\sinh\left(\mathbf{A}\right).\end{eqnarray*}
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \sinh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}-e^{-\mathbf{A}}}{2}\\
    \cosh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}+e^{-\mathbf{A}}}{2}\\
    \tanh\left(\mathbf{A}\right) & = & \left[\cosh\left(\mathbf{A}\right)\right]^{-1}\sinh\left(\mathbf{A}\right).\end{eqnarray*}
- en: These matrix functions can be found using [`linalg.sinhm`](../reference/generated/scipy.linalg.sinhm.html#scipy.linalg.sinhm
    "scipy.linalg.sinhm"), [`linalg.coshm`](../reference/generated/scipy.linalg.coshm.html#scipy.linalg.coshm
    "scipy.linalg.coshm"), and [`linalg.tanhm`](../reference/generated/scipy.linalg.tanhm.html#scipy.linalg.tanhm
    "scipy.linalg.tanhm").
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些矩阵函数可以在 [`linalg.sinhm`](../reference/generated/scipy.linalg.sinhm.html#scipy.linalg.sinhm
    "scipy.linalg.sinhm"), [`linalg.coshm`](../reference/generated/scipy.linalg.coshm.html#scipy.linalg.coshm
    "scipy.linalg.coshm"), 和 [`linalg.tanhm`](../reference/generated/scipy.linalg.tanhm.html#scipy.linalg.tanhm
    "scipy.linalg.tanhm") 中找到。
- en: Arbitrary function
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意函数
- en: Finally, any arbitrary function that takes one complex number and returns a
    complex number can be called as a matrix function using the command [`linalg.funm`](../reference/generated/scipy.linalg.funm.html#scipy.linalg.funm
    "scipy.linalg.funm"). This command takes the matrix and an arbitrary Python function.
    It then implements an algorithm from Golub and Van Loan’s book “Matrix Computations”
    to compute the function applied to the matrix using a Schur decomposition. Note
    that *the function needs to accept complex numbers* as input in order to work
    with this algorithm. For example, the following code computes the zeroth-order
    Bessel function applied to a matrix.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任意接受一个复数并返回一个复数的函数可以被称为矩阵函数，使用命令 [`linalg.funm`](../reference/generated/scipy.linalg.funm.html#scipy.linalg.funm
    "scipy.linalg.funm")。此命令接受矩阵和任意的Python函数。然后，它使用Golub和Van Loan的书“Matrix Computations”中的算法，使用Schur分解计算应用于矩阵的函数。请注意*函数需要接受复数*作为输入才能使用此算法。例如，以下代码计算应用于矩阵的零阶贝塞尔函数。
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note how, by virtue of how matrix analytic functions are defined, the Bessel
    function has acted on the matrix eigenvalues.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于矩阵解析函数的定义方式，贝塞尔函数已经作用于矩阵的特征值。
- en: Special matrices
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊矩阵
- en: SciPy and NumPy provide several functions for creating special matrices that
    are frequently used in engineering and science.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 和 NumPy 提供了几个用于创建在工程和科学中经常使用的特殊矩阵的函数。
- en: '| Type | Function | Description |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| block diagonal | [`scipy.linalg.block_diag`](../reference/generated/scipy.linalg.block_diag.html#scipy.linalg.block_diag
    "scipy.linalg.block_diag") | Create a block diagonal matrix from the provided
    arrays. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 块对角 | [`scipy.linalg.block_diag`](../reference/generated/scipy.linalg.block_diag.html#scipy.linalg.block_diag
    "scipy.linalg.block_diag") | 从提供的数组创建一个块对角矩阵。 |'
- en: '| circulant | [`scipy.linalg.circulant`](../reference/generated/scipy.linalg.circulant.html#scipy.linalg.circulant
    "scipy.linalg.circulant") | Create a circulant matrix. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 循环 | [`scipy.linalg.circulant`](../reference/generated/scipy.linalg.circulant.html#scipy.linalg.circulant
    "scipy.linalg.circulant") | 创建一个循环矩阵。 |'
- en: '| companion | [`scipy.linalg.companion`](../reference/generated/scipy.linalg.companion.html#scipy.linalg.companion
    "scipy.linalg.companion") | Create a companion matrix. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 伴随 | [`scipy.linalg.companion`](../reference/generated/scipy.linalg.companion.html#scipy.linalg.companion
    "scipy.linalg.companion") | 创建一个伴随矩阵。 |'
- en: '| convolution | [`scipy.linalg.convolution_matrix`](../reference/generated/scipy.linalg.convolution_matrix.html#scipy.linalg.convolution_matrix
    "scipy.linalg.convolution_matrix") | Create a convolution matrix. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 卷积 | [`scipy.linalg.convolution_matrix`](../reference/generated/scipy.linalg.convolution_matrix.html#scipy.linalg.convolution_matrix
    "scipy.linalg.convolution_matrix") | 创建一个卷积矩阵。 |'
- en: '| Discrete Fourier | [`scipy.linalg.dft`](../reference/generated/scipy.linalg.dft.html#scipy.linalg.dft
    "scipy.linalg.dft") | Create a discrete Fourier transform matrix. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 离散傅立叶 | [`scipy.linalg.dft`](../reference/generated/scipy.linalg.dft.html#scipy.linalg.dft
    "scipy.linalg.dft") | 创建一个离散傅立叶变换矩阵。 |'
- en: '| Fiedler | [`scipy.linalg.fiedler`](../reference/generated/scipy.linalg.fiedler.html#scipy.linalg.fiedler
    "scipy.linalg.fiedler") | Create a symmetric Fiedler matrix. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 菲德勒 | [`scipy.linalg.fiedler`](../reference/generated/scipy.linalg.fiedler.html#scipy.linalg.fiedler
    "scipy.linalg.fiedler") | 创建一个对称的菲德勒矩阵。 |'
- en: '| Fiedler Companion | [`scipy.linalg.fiedler_companion`](../reference/generated/scipy.linalg.fiedler_companion.html#scipy.linalg.fiedler_companion
    "scipy.linalg.fiedler_companion") | Create a Fiedler companion matrix. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 菲德勒伴随 | [`scipy.linalg.fiedler_companion`](../reference/generated/scipy.linalg.fiedler_companion.html#scipy.linalg.fiedler_companion
    "scipy.linalg.fiedler_companion") | 创建一个菲德勒伴随矩阵。 |'
- en: '| Hadamard | [`scipy.linalg.hadamard`](../reference/generated/scipy.linalg.hadamard.html#scipy.linalg.hadamard
    "scipy.linalg.hadamard") | Create an Hadamard matrix. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 哈达玛德 | [`scipy.linalg.hadamard`](../reference/generated/scipy.linalg.hadamard.html#scipy.linalg.hadamard
    "scipy.linalg.hadamard") | 创建一个哈达玛德矩阵。 |'
- en: '| Hankel | [`scipy.linalg.hankel`](../reference/generated/scipy.linalg.hankel.html#scipy.linalg.hankel
    "scipy.linalg.hankel") | Create a Hankel matrix. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 汉克尔 | [`scipy.linalg.hankel`](../reference/generated/scipy.linalg.hankel.html#scipy.linalg.hankel
    "scipy.linalg.hankel") | 创建一个汉克尔矩阵。 |'
- en: '| Helmert | [`scipy.linalg.helmert`](../reference/generated/scipy.linalg.helmert.html#scipy.linalg.helmert
    "scipy.linalg.helmert") | Create a Helmert matrix. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 赫尔默特 | [`scipy.linalg.helmert`](../reference/generated/scipy.linalg.helmert.html#scipy.linalg.helmert
    "scipy.linalg.helmert") | 创建一个赫尔默特矩阵。 |'
- en: '| Hilbert | [`scipy.linalg.hilbert`](../reference/generated/scipy.linalg.hilbert.html#scipy.linalg.hilbert
    "scipy.linalg.hilbert") | Create a Hilbert matrix. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 希尔伯特 | [`scipy.linalg.hilbert`](../reference/generated/scipy.linalg.hilbert.html#scipy.linalg.hilbert
    "scipy.linalg.hilbert") | 创建一个希尔伯特矩阵。 |'
- en: '| Inverse Hilbert | [`scipy.linalg.invhilbert`](../reference/generated/scipy.linalg.invhilbert.html#scipy.linalg.invhilbert
    "scipy.linalg.invhilbert") | Create the inverse of a Hilbert matrix. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 逆希尔伯特 | [`scipy.linalg.invhilbert`](../reference/generated/scipy.linalg.invhilbert.html#scipy.linalg.invhilbert
    "scipy.linalg.invhilbert") | 创建希尔伯特矩阵的逆矩阵。 |'
- en: '| Leslie | [`scipy.linalg.leslie`](../reference/generated/scipy.linalg.leslie.html#scipy.linalg.leslie
    "scipy.linalg.leslie") | Create a Leslie matrix. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 莱斯利 | [`scipy.linalg.leslie`](../reference/generated/scipy.linalg.leslie.html#scipy.linalg.leslie
    "scipy.linalg.leslie") | 创建一个莱斯利矩阵。 |'
- en: '| Pascal | [`scipy.linalg.pascal`](../reference/generated/scipy.linalg.pascal.html#scipy.linalg.pascal
    "scipy.linalg.pascal") | Create a Pascal matrix. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 帕斯卡 | [`scipy.linalg.pascal`](../reference/generated/scipy.linalg.pascal.html#scipy.linalg.pascal
    "scipy.linalg.pascal") | 创建一个帕斯卡矩阵。 |'
- en: '| Inverse Pascal | [`scipy.linalg.invpascal`](../reference/generated/scipy.linalg.invpascal.html#scipy.linalg.invpascal
    "scipy.linalg.invpascal") | Create the inverse of a Pascal matrix. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 逆帕斯卡 | [`scipy.linalg.invpascal`](../reference/generated/scipy.linalg.invpascal.html#scipy.linalg.invpascal
    "scipy.linalg.invpascal") | 创建帕斯卡矩阵的逆矩阵。 |'
- en: '| Toeplitz | [`scipy.linalg.toeplitz`](../reference/generated/scipy.linalg.toeplitz.html#scipy.linalg.toeplitz
    "scipy.linalg.toeplitz") | Create a Toeplitz matrix. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 托普利茨 | [`scipy.linalg.toeplitz`](../reference/generated/scipy.linalg.toeplitz.html#scipy.linalg.toeplitz
    "scipy.linalg.toeplitz") | 创建一个托普利茨矩阵。 |'
- en: '| Van der Monde | [`numpy.vander`](https://numpy.org/devdocs/reference/generated/numpy.vander.html#numpy.vander
    "(in NumPy v2.0.dev0)") | Create a Van der Monde matrix. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 范德蒙德 | [`numpy.vander`](https://numpy.org/devdocs/reference/generated/numpy.vander.html#numpy.vander
    "(in NumPy v2.0.dev0)") | 创建一个范德蒙德矩阵。 |'
- en: For examples of the use of these functions, see their respective docstrings.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用这些函数的示例，请参阅它们各自的文档字符串。
