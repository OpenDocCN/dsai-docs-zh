["```py\n>>> import sympy as sm\n>>> import sympy.physics.mechanics as me\n>>> import sympy.physics.biomechanics as bm \n```", "```py\n>>> q1, q2, q3, q4 = me.dynamicsymbols('q1, q2, q3, q4', real=True)\n>>> u1, u2, u3, u4 = me.dynamicsymbols('u1, u2, u3, u4', real=True) \n```", "```py\n>>> dx, dy, dz = sm.symbols('dx, dy, dz', real=True, nonnegative=True)\n>>> lA, lC, lD = sm.symbols('lA, lC, lD', real=True, positive=True)\n>>> mA, mC, mD = sm.symbols('mA, mC, mD', real=True, positive=True)\n>>> g, k, c, r = sm.symbols('g, k, c, r', real=True, positive=True) \n```", "```py\n>>> N, A, B, C, D = sm.symbols('N, A, B, C, D', cls=me.ReferenceFrame)\n>>> O, P1, P2, P3, P4 = sm.symbols('O, P1, P2, P3, P4 ', cls=me.Point)\n>>> Ao, Co, Cm, Dm, Do = sm.symbols('Ao, Co, Cm, Dm, Do', cls=me.Point) \n```", "```py\n>>> A.orient_axis(N, q1, N.z)\n>>> B.orient_axis(N, q2, N.y)\n>>> C.orient_axis(B, q3, B.z)\n>>> D.orient_axis(C, q4, C.y)\n>>> A.set_ang_vel(N, u1*N.z)\n>>> B.set_ang_vel(N, u2*N.y)\n>>> C.set_ang_vel(B, u3*B.z)\n>>> D.set_ang_vel(C, u4*C.y) \n```", "```py\n>>> Ao.set_pos(O, dx*N.x)\n>>> P1.set_pos(Ao, lA*A.y)\n>>> P2.set_pos(O, dy*N.y + dz*N.z)\n>>> Co.set_pos(P2, lC/2*C.z)\n>>> Cm.set_pos(P2, 1*lC/3*C.z)\n>>> P3.set_pos(P2, lC*C.z)\n>>> Dm.set_pos(P3, 1*lD/3*D.z)\n>>> Do.set_pos(P3, lD/2*D.z)\n>>> P4.set_pos(P3, lD*D.z) \n```", "```py\n>>> O.set_vel(N, 0)\n>>> Ao.set_vel(N, 0)\n>>> P1.v2pt_theory(Ao, N, A)\n- lA*u1(t)*A.x\n>>> P2.set_vel(N, 0)\n>>> Co.v2pt_theory(P2, N, C)\nlC*u2(t)*cos(q3(t))/2*C.x - lC*u2(t)*sin(q3(t))/2*C.y\n>>> Cm.v2pt_theory(P2, N, C)\nlC*u2(t)*cos(q3(t))/3*C.x - lC*u2(t)*sin(q3(t))/3*C.y\n>>> P3.v2pt_theory(P2, N, C)\nlC*u2(t)*cos(q3(t))*C.x - lC*u2(t)*sin(q3(t))*C.y\n>>> Dm.v2pt_theory(P3, N, D)\nlC*u2(t)*cos(q3(t))*C.x - lC*u2(t)*sin(q3(t))*C.y + lD*(u2(t)*cos(q3(t)) + u4(t))/3*D.x - lD*(u2(t)*sin(q3(t))*cos(q4(t)) - u3(t)*sin(q4(t)))/3*D.y\n>>> Do.v2pt_theory(P3, N, D)\nlC*u2(t)*cos(q3(t))*C.x - lC*u2(t)*sin(q3(t))*C.y + lD*(u2(t)*cos(q3(t)) + u4(t))/2*D.x - lD*(u2(t)*sin(q3(t))*cos(q4(t)) - u3(t)*sin(q4(t)))/2*D.y\n>>> P4.v2pt_theory(P3, N, D)\nlC*u2(t)*cos(q3(t))*C.x - lC*u2(t)*sin(q3(t))*C.y + lD*(u2(t)*cos(q3(t)) + u4(t))*D.x - lD*(u2(t)*sin(q3(t))*cos(q4(t)) - u3(t)*sin(q4(t)))*D.y \n```", "```py\n>>> holonomic = (P4.pos_from(O) - P1.pos_from(O)).to_matrix(N) \n```", "```py\n>>> IA = me.Inertia(me.inertia(A, mA/12*lA**2, mA/2*lA**2, mA/12*lA**2), Ao)\n>>> IC = me.Inertia(me.inertia(C, mC/12*lC**2, mC/12*lC**2, mC/2*lC**2), Co)\n>>> ID = me.Inertia(me.inertia(D, mD/12*lD**2, mD/12*lD**2, mD/2*lD**2), Do) \n```", "```py\n>>> lever = me.RigidBody('lever', masscenter=Ao, frame=A, mass=mA, inertia=IA)\n>>> u_arm = me.RigidBody('upper arm', masscenter=Co, frame=C, mass=mC, inertia=IC)\n>>> l_arm = me.RigidBody('lower arm', masscenter=Do, frame=D, mass=mD, inertia=ID) \n```", "```py\n>>> gravC = me.Force(u_arm, mC*g*N.z)\n>>> gravD = me.Force(l_arm, mD*g*N.z) \n```", "```py\n>>> lever_resistance = me.Torque(A, (-k*q1 - c*u1)*N.z) \n```", "```py\n>>> biceps_pathway = me.LinearPathway(Cm, Dm) \n```", "```py\n>>> biceps_activation = bm.FirstOrderActivationDeGroote2016.with_defaults('biceps') \n```", "```py\n>>> biceps = bm.MusculotendonDeGroote2016.with_defaults('biceps', biceps_pathway, biceps_activation) \n```", "```py\n>>> class ExtensorPathway(me.PathwayBase):\n...\n...     def __init__(self, origin, insertion, axis_point, axis, parent_axis,\n...                  child_axis, radius, coordinate):\n...  \"\"\"A custom pathway that wraps a circular arc around a pin joint.\n...\n...         This is intended to be used for extensor muscles. For example, a\n...         triceps wrapping around the elbow joint to extend the upper arm at\n...         the elbow.\n...\n...         Parameters\n...         ==========\n...         origin : Point\n...             Muscle origin point fixed on the parent body (A).\n...         insertion : Point\n...             Muscle insertion point fixed on the child body (B).\n...         axis_point : Point\n...             Pin joint location fixed in both the parent and child.\n...         axis : Vector\n...             Pin joint rotation axis.\n...         parent_axis : Vector\n...             Axis fixed in the parent frame (A) that is directed from the pin\n...             joint point to the muscle origin point.\n...         child_axis : Vector\n...             Axis fixed in the child frame (B) that is directed from the pin\n...             joint point to the muscle insertion point.\n...         radius : sympyfiable\n...             Radius of the arc that the muscle wraps around.\n...         coordinate : sympfiable function of time\n...             Joint angle, zero when parent and child frames align. Positive\n...             rotation about the pin joint axis, B with respect to A.\n...\n...         Notes\n...         =====\n...\n...         Only valid for coordinate >= 0.\n...\n...         \"\"\"\n...         super().__init__(origin, insertion)\n...\n...         self.origin = origin\n...         self.insertion = insertion\n...         self.axis_point = axis_point\n...         self.axis = axis.normalize()\n...         self.parent_axis = parent_axis.normalize()\n...         self.child_axis = child_axis.normalize()\n...         self.radius = radius\n...         self.coordinate = coordinate\n...\n...         self.origin_distance = axis_point.pos_from(origin).magnitude()\n...         self.insertion_distance = axis_point.pos_from(insertion).magnitude()\n...         self.origin_angle = sm.asin(self.radius/self.origin_distance)\n...         self.insertion_angle = sm.asin(self.radius/self.insertion_distance)\n...\n...     @property\n...     def length(self):\n...  \"\"\"Length of the pathway.\n...\n...         Length of two fixed length line segments and a changing arc length\n...         of a circle.\n...\n...         \"\"\"\n...\n...         angle = self.origin_angle + self.coordinate + self.insertion_angle\n...         arc_length = self.radius*angle\n...\n...         origin_segment_length = self.origin_distance*sm.cos(self.origin_angle)\n...         insertion_segment_length = self.insertion_distance*sm.cos(self.insertion_angle)\n...\n...         return origin_segment_length + arc_length + insertion_segment_length\n...\n...     @property\n...     def extension_velocity(self):\n...  \"\"\"Extension velocity of the pathway.\n...\n...         Arc length of circle is the only thing that changes when the elbow\n...         flexes and extends.\n...\n...         \"\"\"\n...         return self.radius*self.coordinate.diff(me.dynamicsymbols._t)\n...\n...     def to_loads(self, force_magnitude):\n...  \"\"\"Loads in the correct format to be supplied to `KanesMethod`.\n...\n...         Forces applied to origin, insertion, and P from the muscle wrapped\n...         over circular arc of radius r.\n...\n...         \"\"\"\n...\n...         parent_tangency_point = me.Point('Aw')  # fixed in parent\n...         child_tangency_point = me.Point('Bw')  # fixed in child\n...\n...         parent_tangency_point.set_pos(\n...             self.axis_point,\n...             -self.radius*sm.cos(self.origin_angle)*self.parent_axis.cross(self.axis)\n...             + self.radius*sm.sin(self.origin_angle)*self.parent_axis,\n...         )\n...         child_tangency_point.set_pos(\n...             self.axis_point,\n...             self.radius*sm.cos(self.insertion_angle)*self.child_axis.cross(self.axis)\n...             + self.radius*sm.sin(self.insertion_angle)*self.child_axis),\n...\n...         parent_force_direction_vector = self.origin.pos_from(parent_tangency_point)\n...         child_force_direction_vector = self.insertion.pos_from(child_tangency_point)\n...         force_on_parent = force_magnitude*parent_force_direction_vector.normalize()\n...         force_on_child = force_magnitude*child_force_direction_vector.normalize()\n...         loads = [\n...             me.Force(self.origin, force_on_parent),\n...             me.Force(self.axis_point, -(force_on_parent + force_on_child)),\n...             me.Force(self.insertion, force_on_child),\n...         ]\n...         return loads\n... \n```", "```py\n>>> triceps_pathway = ExtensorPathway(Cm, Dm, P3, B.y, -C.z, D.z, r, q4)\n>>> triceps_activation = bm.FirstOrderActivationDeGroote2016.with_defaults('triceps')\n>>> triceps = bm.MusculotendonDeGroote2016.with_defaults('triceps', triceps_pathway, triceps_activation) \n```", "```py\n>>> loads = biceps.to_loads() + triceps.to_loads() + [lever_resistance, gravC, gravD] \n```", "```py\n>>> kane = me.KanesMethod(\n...     N,\n...     (q1,),\n...     (u1,),\n...     kd_eqs=(\n...         u1 - q1.diff(),\n...         u2 - q2.diff(),\n...         u3 - q3.diff(),\n...         u4 - q4.diff(),\n...     ),\n...     q_dependent=(q2, q3, q4),\n...     configuration_constraints=holonomic,\n...     velocity_constraints=holonomic.diff(me.dynamicsymbols._t),\n...     u_dependent=(u2, u3, u4),\n... )\n...\n>>> Fr, Frs = kane.kanes_equations((lever, u_arm, l_arm), loads) \n```", "```py\n>>> me.find_dynamicsymbols(kane.forcing)\n{a_biceps(t), a_triceps(t), q1(t), q2(t), q3(t), q4(t), u1(t), u2(t), u3(t), u4(t)} \n```", "```py\n>>> kane.forcing.free_symbols\n{F_M_max_biceps, F_M_max_triceps, c, g, k, lA, lC, lD, l_M_opt_biceps, l_M_opt_triceps, l_T_slack_biceps, l_T_slack_triceps, mC, mD, r, t} \n```", "```py\n>>> biceps.rhs()\nMatrix([[((1/2 - tanh(10.0*a_biceps(t) - 10.0*e_biceps(t))/2)/(0.0225*a_biceps(t) + 0.0075) + 16.6666666666667*(3*a_biceps(t)/2 + 1/2)*(tanh(10.0*a_biceps(t) - 10.0*e_biceps(t))/2 + 1/2))*(-a_biceps(t) + e_biceps(t))]]) \n```", "```py\n>>> triceps.rhs()\nMatrix([[((1/2 - tanh(10.0*a_triceps(t) - 10.0*e_triceps(t))/2)/(0.0225*a_triceps(t) + 0.0075) + 16.6666666666667*(3*a_triceps(t)/2 + 1/2)*(tanh(10.0*a_triceps(t) - 10.0*e_triceps(t))/2 + 1/2))*(-a_triceps(t) + e_triceps(t))]]) \n```", "```py\n>>> dadt = biceps.rhs().col_join(triceps.rhs()) \n```", "```py\n>>> q, u = kane.q, kane.u\n>>> a = biceps.x.col_join(triceps.x)\n>>> x = q.col_join(u).col_join(a)\n>>> x\nMatrix([\n[       q1(t)],\n[       q2(t)],\n[       q3(t)],\n[       q4(t)],\n[       u1(t)],\n[       u2(t)],\n[       u3(t)],\n[       u4(t)],\n[ a_biceps(t)],\n[a_triceps(t)]]) \n```", "```py\n>>> e = biceps.r.col_join(triceps.r)\n>>> e\nMatrix([\n[ e_biceps(t)],\n[e_triceps(t)]]) \n```", "```py\n>>> p = sm.Matrix([\n...     dx,\n...     dy,\n...     dz,\n...     lA,\n...     lC,\n...     lD,\n...     mA,\n...     mC,\n...     mD,\n...     g,\n...     k,\n...     c,\n...     r,\n...     biceps.F_M_max,\n...     biceps.l_M_opt,\n...     biceps.l_T_slack,\n...     triceps.F_M_max,\n...     triceps.l_M_opt,\n...     triceps.l_T_slack,\n... ])\n...\n>>> p\nMatrix([\n[               dx],\n[               dy],\n[               dz],\n[               lA],\n[               lC],\n[               lD],\n[               mA],\n[               mC],\n[               mD],\n[                g],\n[                k],\n[                c],\n[                r],\n[   F_M_max_biceps],\n[   l_M_opt_biceps],\n[ l_T_slack_biceps],\n[  F_M_max_triceps],\n[  l_M_opt_triceps],\n[l_T_slack_triceps]]) \n```", "```py\n>>> eval_diffeq = sm.lambdify((q, u, a, e, p),\n...                           (kane.mass_matrix, kane.forcing, dadt), cse=True)\n>>> eval_holonomic = sm.lambdify((q, p), holonomic, cse=True) \n```", "```py\n>>> import numpy as np \n```", "```py\n>>> p_vals = np.array([\n...     0.31,  # dx [m]\n...     0.15,  # dy [m]\n...     -0.31,  # dz [m]\n...     0.2,   # lA [m]\n...     0.3,  # lC [m]\n...     0.3,  # lD [m]\n...     1.0,  # mA [kg]\n...     2.3,  # mC [kg]\n...     1.7,  # mD [kg]\n...     9.81,  # g [m/s/s]\n...     5.0,  # k [Nm/rad]\n...     0.5,  # c [Nms/rad]\n...     0.03,  # r [m]\n...     500.0,  # biceps F_M_max [?]\n...     0.6*0.3,  # biceps l_M_opt [?]\n...     0.55*0.3,  # biceps l_T_slack [?]\n...     500.0,  # triceps F_M_max [?]\n...     0.6*0.3,  # triceps l_M_opt [?]\n...     0.65*0.3,  # triceps l_T_slack [?]\n... ])\n... \n```", "```py\n>>> from scipy.optimize import fsolve \n```", "```py\n>>> q_vals = np.array([\n...     np.deg2rad(5.0),  # q1 [rad]\n...     np.deg2rad(-10.0),  # q2 [rad]\n...     np.deg2rad(0.0),  # q3 [rad]\n...     np.deg2rad(75.0),  # q4 [rad]\n... ])\n... \n```", "```py\n>>> def eval_holo_fsolve(x):\n...     q1 = q_vals[0]  # specified\n...     q2, q3, q4 = x\n...     return eval_holonomic((q1, q2, q3, q4), p_vals).squeeze()\n... \n```", "```py\n>>> q_vals[1:] = fsolve(eval_holo_fsolve, q_vals[1:]) \n```", "```py\n>>> np.rad2deg(q_vals)\n[ 5\\.         -0.60986636  9.44918589 88.68812842] \n```", "```py\n>>> u_vals = np.array([\n...     0.0,  # u1, [rad/s]\n...     0.0,  # u2, [rad/s]\n...     0.0,  # u3, [rad/s]\n...     0.0,  # u4, [rad/s]\n... ])\n... \n```", "```py\n>>> a_vals = np.array([\n...     0.0,  # a_bicep, nondimensional\n...     0.0,  # a_tricep, nondimensional\n... ]) \n```", "```py\n>>> e_vals = np.array([\n...     0.0,\n...     0.0,\n... ]) \n```", "```py\n>>> eval_diffeq(q_vals, u_vals, a_vals, e_vals, p_vals)\n([[ 0.00333333 -0.15174161 -0.00109772 -0.00152436]\n [ 0.19923894  0.31       -0.04923615  0.00996712]\n [ 0.01743115  0\\.          0.29585191  0.0011276 ]\n [ 0\\.         -0.29256885 -0.0005241  -0.29983226]], [[-0.9121071]\n [ 0\\.       ]\n [-0\\.       ]\n [ 0\\.       ]], [[0.]\n [0.]]) \n```", "```py\n>>> def eval_r(t):\n...  \"\"\"Returns the muscles' excitation as a function of time.\"\"\"\n...     e = np.array([0.0, 0.0])\n...     return e\n...\n>>> def eval_rhs(t, x, r, p):\n...  \"\"\"Returns the time derivative of the state.\n...\n...     Parameters\n...     ==========\n...     t : float\n...         Time in seconds.\n...     x : array_like, shape(10,)\n...         State vector.\n...     r : function\n...         Function f(t) that evaluates e.\n...     p : array_like, shape(?, )\n...         Parameter vector.\n...\n...     Returns\n...     =======\n...     dxdt : ndarray, shape(10,)\n...       Time derivative of the state.\n...\n...     \"\"\"\n...\n...     q = x[0:4]\n...     u = x[4:8]\n...     a = x[8:10]\n...\n...     e = r(t)\n...\n...     qd = u\n...     m, f, ad = eval_diffeq(q, u, a, e, p)\n...     ud = np.linalg.solve(m, f).squeeze()\n...\n...     return np.hstack((qd, ud, ad.squeeze()))\n... \n```", "```py\n>>> from scipy.integrate import solve_ivp \n```", "```py\n>>> t0, tf = 0.0, 3.0\n>>> ts = np.linspace(t0, tf, num=301)\n>>> x0 = np.hstack((q_vals, u_vals, a_vals))\n>>> sol = solve_ivp(lambda t, x: eval_rhs(t, x, eval_r, p_vals),\n...                 (t0, tf), x0, t_eval=ts) \n```", "```py\n>>> import matplotlib.pyplot as plt \n```", "```py\n>>> def plot_traj(t, x, syms):\n...  \"\"\"Simple plot of state trajectories.\n...\n...     Parameters\n...     ==========\n...     t : array_like, shape(n,)\n...         Time values.\n...     x : array_like, shape(n, m)\n...         State values at each time value.\n...     syms : sequence of Symbol, len(m)\n...         SymPy symbols associated with state.\n...\n...     \"\"\"\n...\n...     fig, axes = plt.subplots(5, 2, sharex=True)\n...\n...     for ax, traj, sym in zip(axes.T.flatten(), x.T, syms):\n...         if not sym.name.startswith('a'):\n...             traj = np.rad2deg(traj)\n...         ax.plot(t, traj)\n...         ax.set_ylabel(sm.latex(sym, mode='inline'))\n...\n...     for ax in axes[-1, :]:\n...         ax.set_xlabel('Time [s]')\n...\n...     fig.tight_layout()\n...\n...     return axes\n... \n```", "```py\n>>> plot_traj(ts, sol.y.T, x)\n[[<Axes: ylabel='$q_{1}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{2}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{2}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{3}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{3}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{4}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{4}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$a_{biceps}{\\\\left(t \\\\right)}$'>]\n [<Axes: xlabel='Time [s]', ylabel='$u_{1}{\\\\left(t \\\\right)}$'>\n <Axes: xlabel='Time [s]', ylabel='$a_{triceps}{\\\\left(t \\\\right)}$'>]] \n```", "```py\n>>> def eval_r(t):\n...     if t < 0.5 or t > 1.5:\n...         e = np.array([0.0, 0.0])\n...     else:\n...         e = np.array([0.8, 0.0])\n...     return e\n... \n```", "```py\n>>> sol = solve_ivp(lambda t, x: eval_rhs(t, x, eval_r, p_vals), (t0, tf), x0, t_eval=ts) \n```", "```py\n>>> plot_traj(ts, sol.y.T, x)\n[[<Axes: ylabel='$q_{1}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{2}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{2}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{3}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{3}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$u_{4}{\\\\left(t \\\\right)}$'>]\n [<Axes: ylabel='$q_{4}{\\\\left(t \\\\right)}$'>\n <Axes: ylabel='$a_{biceps}{\\\\left(t \\\\right)}$'>]\n [<Axes: xlabel='Time [s]', ylabel='$u_{1}{\\\\left(t \\\\right)}$'>\n <Axes: xlabel='Time [s]', ylabel='$a_{triceps}{\\\\left(t \\\\right)}$'>]] \n```"]