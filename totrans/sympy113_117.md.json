["```py\n>>> from sympy import MatrixSymbol, Matrix\n>>> X = MatrixSymbol('X', 3, 3)\n>>> Y = MatrixSymbol('Y', 3, 3)\n>>> (X.T*X).I*Y\nX**(-1)*X.T**(-1)*Y \n```", "```py\n>>> Matrix(X)\nMatrix([\n[X[0, 0], X[0, 1], X[0, 2]],\n[X[1, 0], X[1, 1], X[1, 2]],\n[X[2, 0], X[2, 1], X[2, 2]]]) \n```", "```py\n>>> (X*Y)[1, 2]\nX[1, 0]*Y[0, 2] + X[1, 1]*Y[1, 2] + X[1, 2]*Y[2, 2] \n```", "```py\n>>> a = MatrixSymbol(\"a\", 3, 1)\n>>> b = MatrixSymbol(\"b\", 3, 1)\n>>> (a.T*X**2*b).diff(X)\na*b.T*X.T + X.T*a*b.T \n```", "```py\n>>> X.diff(X)\nPermuteDims(ArrayTensorProduct(I, I), (3)(1 2)) \n```", "```py\nclass sympy.matrices.expressions.MatrixExpr(*args, **kwargs)\n```", "```py\n>>> from sympy import MatrixSymbol\n>>> A = MatrixSymbol('A', 3, 3)\n>>> y = MatrixSymbol('y', 3, 1)\n>>> x = (A.T*A).I * A * y \n```", "```py\nproperty T\n```", "```py\nas_coeff_Mul(rational=False)\n```", "```py\nas_explicit()\n```", "```py\n>>> from sympy import Identity\n>>> I = Identity(3)\n>>> I\nI\n>>> I.as_explicit()\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]]) \n```", "```py\nas_mutable()\n```", "```py\n>>> from sympy import Identity\n>>> I = Identity(3)\n>>> I\nI\n>>> I.shape\n(3, 3)\n>>> I.as_mutable()\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]]) \n```", "```py\nequals(other)\n```", "```py\n>>> from sympy import Identity, eye\n>>> Identity(3).equals(eye(3))\nTrue \n```", "```py\nstatic from_index_summation(expr, first_index=None, last_index=None, dimensions=None)\n```", "```py\n>>> from sympy import MatrixSymbol, MatrixExpr, Sum\n>>> from sympy.abc import i, j, k, l, N\n>>> A = MatrixSymbol(\"A\", N, N)\n>>> B = MatrixSymbol(\"B\", N, N)\n>>> expr = Sum(A[i, j]*B[j, k], (j, 0, N-1))\n>>> MatrixExpr.from_index_summation(expr)\nA*B \n```", "```py\n>>> expr = Sum(A[j, i]*B[j, k], (j, 0, N-1))\n>>> MatrixExpr.from_index_summation(expr)\nA.T*B \n```", "```py\n>>> expr = Sum(A[i, i], (i, 0, N-1))\n>>> MatrixExpr.from_index_summation(expr)\nTrace(A) \n```", "```py\n>>> expr = Sum(A[i, j]*B[k, j]*A[l, k], (j, 0, N-1), (k, 0, N-1))\n>>> MatrixExpr.from_index_summation(expr)\nA*B.T*A.T \n```", "```py\nclass sympy.matrices.expressions.MatrixSymbol(name, n, m)\n```", "```py\n>>> from sympy import MatrixSymbol, Identity\n>>> A = MatrixSymbol('A', 3, 4) # A 3 by 4 Matrix\n>>> B = MatrixSymbol('B', 4, 3) # A 4 by 3 Matrix\n>>> A.shape\n(3, 4)\n>>> 2*A*B + Identity(3)\nI + 2*A*B \n```", "```py\nclass sympy.matrices.expressions.MatAdd(*args, evaluate=False, check=None, _sympify=True)\n```", "```py\n>>> from sympy import MatAdd, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> C = MatrixSymbol('C', 5, 5)\n>>> MatAdd(A, B, C)\nA + B + C \n```", "```py\nclass sympy.matrices.expressions.MatMul(*args, evaluate=False, check=None, _sympify=True)\n```", "```py\n>>> from sympy import MatMul, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 4)\n>>> B = MatrixSymbol('B', 4, 3)\n>>> C = MatrixSymbol('C', 3, 6)\n>>> MatMul(A, B, C)\nA*B*C \n```", "```py\nclass sympy.matrices.expressions.MatPow(base, exp, evaluate=False, **options)\n```", "```py\nsympy.matrices.expressions.hadamard_product(*matrices)\n```", "```py\n>>> from sympy import hadamard_product, MatrixSymbol\n>>> A = MatrixSymbol('A', 2, 3)\n>>> B = MatrixSymbol('B', 2, 3)\n>>> hadamard_product(A)\nA\n>>> hadamard_product(A, B)\nHadamardProduct(A, B)\n>>> hadamard_product(A, B)[0, 1]\nA[0, 1]*B[0, 1] \n```", "```py\nclass sympy.matrices.expressions.HadamardProduct(*args, evaluate=False, check=None)\n```", "```py\n>>> from sympy import hadamard_product, HadamardProduct, MatrixSymbol\n>>> A = MatrixSymbol('A', 5, 5)\n>>> B = MatrixSymbol('B', 5, 5)\n>>> isinstance(hadamard_product(A, B), HadamardProduct)\nTrue \n```", "```py\nclass sympy.matrices.expressions.HadamardPower(base, exp)\n```", "```py\nclass sympy.matrices.expressions.Inverse(mat, exp=-1)\n```", "```py\n>>> from sympy import MatrixSymbol, Inverse\n>>> A = MatrixSymbol('A', 3, 3)\n>>> B = MatrixSymbol('B', 3, 3)\n>>> Inverse(A)\nA**(-1)\n>>> A.inverse() == Inverse(A)\nTrue\n>>> (A*B).inverse()\nB**(-1)*A**(-1)\n>>> Inverse(A*B)\n(A*B)**(-1) \n```", "```py\nclass sympy.matrices.expressions.Transpose(*args, **kwargs)\n```", "```py\n>>> from sympy import MatrixSymbol, Transpose, transpose\n>>> A = MatrixSymbol('A', 3, 5)\n>>> B = MatrixSymbol('B', 5, 3)\n>>> Transpose(A)\nA.T\n>>> A.T == transpose(A) == Transpose(A)\nTrue\n>>> Transpose(A*B)\n(A*B).T\n>>> transpose(A*B)\nB.T*A.T \n```", "```py\nclass sympy.matrices.expressions.Trace(mat)\n```", "```py\n>>> from sympy import MatrixSymbol, Trace, eye\n>>> A = MatrixSymbol('A', 3, 3)\n>>> Trace(A)\nTrace(A)\n>>> Trace(eye(3))\nTrace(Matrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]]))\n>>> Trace(eye(3)).simplify()\n3 \n```", "```py\nclass sympy.matrices.expressions.FunctionMatrix(rows, cols, lamda)\n```", "```py\n>>> from sympy import FunctionMatrix, symbols, Lambda, MatPow\n>>> i, j, n, m = symbols('i,j,n,m')\n>>> FunctionMatrix(n, m, Lambda((i, j), i + j))\nFunctionMatrix(n, m, Lambda((i, j), i + j)) \n```", "```py\n>>> from sympy import KroneckerDelta\n>>> X = FunctionMatrix(3, 3, KroneckerDelta)\n>>> X.as_explicit()\nMatrix([\n[1, 0, 0],\n[0, 1, 0],\n[0, 0, 1]]) \n```", "```py\n>>> from sympy import Function\n>>> f = Function('f')\n>>> X = FunctionMatrix(3, 3, f)\n>>> X.as_explicit()\nMatrix([\n[f(0, 0), f(0, 1), f(0, 2)],\n[f(1, 0), f(1, 1), f(1, 2)],\n[f(2, 0), f(2, 1), f(2, 2)]]) \n```", "```py\n>>> FunctionMatrix(n, m, 'lambda i, j: i + j')\nFunctionMatrix(n, m, Lambda((i, j), i + j)) \n```", "```py\n>>> Y = FunctionMatrix(1000, 1000, Lambda((i, j), i + j))\n>>> isinstance(Y*Y, MatPow) # this is an expression object\nTrue\n>>> (Y**2)[10,10] # So this is evaluated lazily\n342923500 \n```", "```py\nclass sympy.matrices.expressions.PermutationMatrix(perm)\n```", "```py\n>>> from sympy import Matrix, PermutationMatrix\n>>> from sympy.combinatorics import Permutation \n```", "```py\n>>> p = Permutation(1, 2, 0)\n>>> P = PermutationMatrix(p)\n>>> P = P.as_explicit()\n>>> P\nMatrix([\n[0, 1, 0],\n[0, 0, 1],\n[1, 0, 0]]) \n```", "```py\n>>> M = Matrix([0, 1, 2])\n>>> Matrix(P*M)\nMatrix([\n[1],\n[2],\n[0]]) \n```", "```py\n>>> Matrix(M.T*P)\nMatrix([[2, 0, 1]]) \n```", "```py\nclass sympy.matrices.expressions.MatrixPermute(mat, perm, axis=0)\n```", "```py\n>>> from sympy import Matrix, MatrixPermute\n>>> from sympy.combinatorics import Permutation \n```", "```py\n>>> p = Permutation(1, 2, 0)\n>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n>>> B = MatrixPermute(A, p, axis=0)\n>>> B.as_explicit()\nMatrix([\n[4, 5, 6],\n[7, 8, 9],\n[1, 2, 3]]) \n```", "```py\n>>> B = MatrixPermute(A, p, axis=1)\n>>> B.as_explicit()\nMatrix([\n[2, 3, 1],\n[5, 6, 4],\n[8, 9, 7]]) \n```", "```py\nclass sympy.matrices.expressions.Identity(n)\n```", "```py\n>>> from sympy import Identity, MatrixSymbol\n>>> A = MatrixSymbol('A', 3, 5)\n>>> I = Identity(3)\n>>> I*A\nA \n```", "```py\nclass sympy.matrices.expressions.ZeroMatrix(m, n)\n```", "```py\n>>> from sympy import MatrixSymbol, ZeroMatrix\n>>> A = MatrixSymbol('A', 3, 5)\n>>> Z = ZeroMatrix(3, 5)\n>>> A + Z\nA\n>>> Z*A.T\n0 \n```", "```py\nclass sympy.matrices.expressions.CompanionMatrix(poly)\n```", "```py\n>>> from sympy import Poly, Symbol, symbols\n>>> from sympy.matrices.expressions import CompanionMatrix\n>>> x = Symbol('x')\n>>> c0, c1, c2, c3, c4 = symbols('c0:5')\n>>> p = Poly(c0 + c1*x + c2*x**2 + c3*x**3 + c4*x**4 + x**5, x)\n>>> CompanionMatrix(p)\nCompanionMatrix(Poly(x**5 + c4*x**4 + c3*x**3 + c2*x**2 + c1*x + c0,\nx, domain='ZZ[c0,c1,c2,c3,c4]')) \n```", "```py\nclass sympy.matrices.expressions.MatrixSet(n, m, set)\n```", "```py\n>>> from sympy.matrices import MatrixSet\n>>> from sympy import S, I, Matrix\n>>> M = MatrixSet(2, 2, set=S.Reals)\n>>> X = Matrix([[1, 2], [3, 4]])\n>>> X in M\nTrue\n>>> X = Matrix([[1, 2], [I, 4]])\n>>> X in M\nFalse \n```", "```py\nclass sympy.matrices.expressions.blockmatrix.BlockMatrix(*args, **kwargs)\n```", "```py\n>>> from sympy import (MatrixSymbol, BlockMatrix, symbols,\n...     Identity, ZeroMatrix, block_collapse)\n>>> n,m,l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> Z = MatrixSymbol('Z', n, m)\n>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n>>> print(B)\nMatrix([\n[X, Z],\n[0, Y]]) \n```", "```py\n>>> C = BlockMatrix([[Identity(n), Z]])\n>>> print(C)\nMatrix([[I, Z]]) \n```", "```py\n>>> print(block_collapse(C*B))\nMatrix([[X, Z + Z*Y]]) \n```", "```py\n>>> from sympy import ones, Matrix\n>>> dat = [\n... [ones(3,2), ones(3,3)*2],\n... [ones(2,3)*3, ones(2,2)*4]]\n...\n>>> BlockMatrix(dat)\nTraceback (most recent call last):\n...\nValueError:\nAlthough this matrix is comprised of blocks, the blocks do not fill\nthe matrix in a size-symmetric fashion. To create a full matrix from\nthese arguments, pass them directly to Matrix.\n>>> Matrix(dat)\nMatrix([\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[1, 1, 2, 2, 2],\n[3, 3, 3, 4, 4],\n[3, 3, 3, 4, 4]]) \n```", "```py\nLDUdecomposition()\n```", "```py\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, D, U = X.LDUdecomposition()\n>>> block_collapse(L*D*U)\nMatrix([\n[A, B],\n[C, D]]) \n```", "```py\nLUdecomposition()\n```", "```py\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> L, U = X.LUdecomposition()\n>>> block_collapse(L*U)\nMatrix([\n[A, B],\n[C, D]]) \n```", "```py\nUDLdecomposition()\n```", "```py\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix, block_collapse\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]])\n>>> U, D, L = X.UDLdecomposition()\n>>> block_collapse(U*D*L)\nMatrix([\n[A, B],\n[C, D]]) \n```", "```py\nschur(mat='A', generalized=False)\n```", "```py\n>>> from sympy import symbols, MatrixSymbol, BlockMatrix\n>>> m, n = symbols('m n')\n>>> A = MatrixSymbol('A', n, n)\n>>> B = MatrixSymbol('B', n, m)\n>>> C = MatrixSymbol('C', m, n)\n>>> D = MatrixSymbol('D', m, m)\n>>> X = BlockMatrix([[A, B], [C, D]]) \n```", "```py\n>>> X.schur()\n-C*A**(-1)*B + D\n>>> X.schur('D')\nA - B*D**(-1)*C \n```", "```py\n>>> X.schur('B', generalized=True)\nC - D*(B.T*B)**(-1)*B.T*A\n>>> X.schur('C', generalized=True)\n-A*(C.T*C)**(-1)*C.T*D + B \n```", "```py\ntranspose()\n```", "```py\n>>> from sympy import MatrixSymbol, BlockMatrix, ZeroMatrix\n>>> from sympy.abc import m, n\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> Z = MatrixSymbol('Z', n, m)\n>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])\n>>> B.transpose()\nMatrix([\n[X.T,  0],\n[Z.T, Y.T]])\n>>> _.transpose()\nMatrix([\n[X, Z],\n[0, Y]]) \n```", "```py\nclass sympy.matrices.expressions.blockmatrix.BlockDiagMatrix(*mats)\n```", "```py\n>>> from sympy import MatrixSymbol, BlockDiagMatrix, symbols\n>>> n, m, l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> BlockDiagMatrix(X, Y)\nMatrix([\n[X, 0],\n[0, Y]]) \n```", "```py\nget_diag_blocks()\n```", "```py\n>>> from sympy import BlockDiagMatrix, Matrix \n```", "```py\n>>> A = Matrix([[1, 2], [3, 4]])\n>>> B = Matrix([[5, 6], [7, 8]])\n>>> M = BlockDiagMatrix(A, B) \n```", "```py\n>>> diag_blocks = M.get_diag_blocks()\n>>> diag_blocks[0]\nMatrix([\n[1, 2],\n[3, 4]])\n>>> diag_blocks[1]\nMatrix([\n[5, 6],\n[7, 8]]) \n```", "```py\nsympy.matrices.expressions.blockmatrix.block_collapse(expr)\n```", "```py\n>>> from sympy import MatrixSymbol, BlockMatrix, symbols, Identity, ZeroMatrix, block_collapse\n>>> n,m,l = symbols('n m l')\n>>> X = MatrixSymbol('X', n, n)\n>>> Y = MatrixSymbol('Y', m, m)\n>>> Z = MatrixSymbol('Z', n, m)\n>>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])\n>>> print(B)\nMatrix([\n[X, Z],\n[0, Y]]) \n```", "```py\n>>> C = BlockMatrix([[Identity(n), Z]])\n>>> print(C)\nMatrix([[I, Z]]) \n```", "```py\n>>> print(block_collapse(C*B))\nMatrix([[X, Z + Z*Y]]) \n```"]