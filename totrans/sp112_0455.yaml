- en: scipy.optimize.brenth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.brenth.html#scipy.optimize.brenth](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.brenth.html#scipy.optimize.brenth)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of a function in a bracketing interval using Brent’s method with
    hyperbolic extrapolation.
  prefs: []
  type: TYPE_NORMAL
- en: A variation on the classic Brent routine to find a root of the function f between
    the arguments a and b that uses hyperbolic extrapolation instead of inverse quadratic
    extrapolation. Bus & Dekker (1975) guarantee convergence for this method, claiming
    that the upper bound of function evaluations here is 4 or 5 times that of bisection.
    f(a) and f(b) cannot have the same signs. Generally, on a par with the brent routine,
    but not as heavily tested. It is a safe version of the secant method that uses
    hyperbolic extrapolation. The version here is by Chuck Harris, and implements
    Algorithm M of [[BusAndDekker1975]](#r044260d935ec-busanddekker1975), where further
    details (convergence properties, additional remarks and such) can be found
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f**function'
  prefs: []
  type: TYPE_NORMAL
- en: Python function returning a number. f must be continuous, and f(a) and f(b)
    must have opposite signs.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**scalar'
  prefs: []
  type: TYPE_NORMAL
- en: One end of the bracketing interval [a,b].
  prefs: []
  type: TYPE_NORMAL
- en: '**b**scalar'
  prefs: []
  type: TYPE_NORMAL
- en: The other end of the bracketing interval [a,b].
  prefs: []
  type: TYPE_NORMAL
- en: '**xtol**number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root. The parameter must be positive. As with [`brentq`](scipy.optimize.brentq.html#scipy.optimize.brentq
    "scipy.optimize.brentq"), for nice functions the method will often satisfy the
    above condition with `xtol/2` and `rtol/2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol**number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root. The parameter cannot be smaller than its default
    value of `4*np.finfo(float).eps`. As with [`brentq`](scipy.optimize.brentq.html#scipy.optimize.brentq
    "scipy.optimize.brentq"), for nice functions the method will often satisfy the
    above condition with `xtol/2` and `rtol/2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If convergence is not achieved in *maxiter* iterations, an error is raised.
    Must be >= 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Containing extra arguments for the function *f*. *f* is called by `apply(f,
    (x)+args)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *full_output* is False, the root is returned. If *full_output* is True, the
    return value is `(x, r)`, where *x* is the root, and *r* is a [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, raise RuntimeError if the algorithm didn’t converge. Otherwise, the
    convergence status is recorded in any [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") return object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**root**float'
  prefs: []
  type: TYPE_NORMAL
- en: Root of *f* between *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") (present if `full_output = True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Object containing information about the convergence. In particular, `r.converged`
    is True if the routine converged.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fmin`](scipy.optimize.fmin.html#scipy.optimize.fmin "scipy.optimize.fmin"),
    [`fmin_powell`](scipy.optimize.fmin_powell.html#scipy.optimize.fmin_powell "scipy.optimize.fmin_powell"),
    [`fmin_cg`](scipy.optimize.fmin_cg.html#scipy.optimize.fmin_cg "scipy.optimize.fmin_cg"),
    [`fmin_bfgs`](scipy.optimize.fmin_bfgs.html#scipy.optimize.fmin_bfgs "scipy.optimize.fmin_bfgs"),
    [`fmin_ncg`](scipy.optimize.fmin_ncg.html#scipy.optimize.fmin_ncg "scipy.optimize.fmin_ncg")'
  prefs: []
  type: TYPE_NORMAL
- en: multivariate local optimizers
  prefs: []
  type: TYPE_NORMAL
- en: '[`leastsq`](scipy.optimize.leastsq.html#scipy.optimize.leastsq "scipy.optimize.leastsq")'
  prefs: []
  type: TYPE_NORMAL
- en: nonlinear least squares minimizer
  prefs: []
  type: TYPE_NORMAL
- en: '[`fmin_l_bfgs_b`](scipy.optimize.fmin_l_bfgs_b.html#scipy.optimize.fmin_l_bfgs_b
    "scipy.optimize.fmin_l_bfgs_b"), [`fmin_tnc`](scipy.optimize.fmin_tnc.html#scipy.optimize.fmin_tnc
    "scipy.optimize.fmin_tnc"), [`fmin_cobyla`](scipy.optimize.fmin_cobyla.html#scipy.optimize.fmin_cobyla
    "scipy.optimize.fmin_cobyla")'
  prefs: []
  type: TYPE_NORMAL
- en: constrained multivariate optimizers
  prefs: []
  type: TYPE_NORMAL
- en: '[`basinhopping`](scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping"), [`differential_evolution`](scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution
    "scipy.optimize.differential_evolution"), [`brute`](scipy.optimize.brute.html#scipy.optimize.brute
    "scipy.optimize.brute")'
  prefs: []
  type: TYPE_NORMAL
- en: global optimizers
  prefs: []
  type: TYPE_NORMAL
- en: '[`fminbound`](scipy.optimize.fminbound.html#scipy.optimize.fminbound "scipy.optimize.fminbound"),
    [`brent`](scipy.optimize.brent.html#scipy.optimize.brent "scipy.optimize.brent"),
    [`golden`](scipy.optimize.golden.html#scipy.optimize.golden "scipy.optimize.golden"),
    [`bracket`](scipy.optimize.bracket.html#scipy.optimize.bracket "scipy.optimize.bracket")'
  prefs: []
  type: TYPE_NORMAL
- en: local scalar minimizers
  prefs: []
  type: TYPE_NORMAL
- en: '[`fsolve`](scipy.optimize.fsolve.html#scipy.optimize.fsolve "scipy.optimize.fsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: N-D root-finding
  prefs: []
  type: TYPE_NORMAL
- en: '[`brentq`](scipy.optimize.brentq.html#scipy.optimize.brentq "scipy.optimize.brentq"),
    [`brenth`](#scipy.optimize.brenth "scipy.optimize.brenth"), [`ridder`](scipy.optimize.ridder.html#scipy.optimize.ridder
    "scipy.optimize.ridder"), [`bisect`](scipy.optimize.bisect.html#scipy.optimize.bisect
    "scipy.optimize.bisect"), [`newton`](scipy.optimize.newton.html#scipy.optimize.newton
    "scipy.optimize.newton")'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D root-finding
  prefs: []
  type: TYPE_NORMAL
- en: '[`fixed_point`](scipy.optimize.fixed_point.html#scipy.optimize.fixed_point
    "scipy.optimize.fixed_point")'
  prefs: []
  type: TYPE_NORMAL
- en: scalar fixed-point finder
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[BusAndDekker1975](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bus, J. C. P., Dekker, T. J., “Two Efficient Algorithms with Guaranteed Convergence
    for Finding a Zero of a Function”, ACM Transactions on Mathematical Software,
    Vol. 1, Issue 4, Dec. 1975, pp. 330-345\. Section 3: “Algorithm M”. [DOI:10.1145/355656.355659](https://doi.org/10.1145/355656.355659)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
