- en: scipy.optimize.fmin_tnc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_tnc.html#scipy.optimize.fmin_tnc](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_tnc.html#scipy.optimize.fmin_tnc)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Minimize a function with variables subject to bounds, using gradient information
    in a truncated Newton algorithm. This method wraps a C implementation of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable `func(x, *args)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function to minimize. Must do one of:'
  prefs: []
  type: TYPE_NORMAL
- en: Return f and g, where f is the value of the function and g its gradient (a list
    of floats).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the function value but supply gradient function separately as *fprime*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the function value and set `approx_grad=True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the function returns None, the minimization is aborted.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Initial estimate of minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '**fprime**callable `fprime(x, *args)`, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Gradient of *func*. If None, then either *func* must return the function value
    and the gradient (`f,g = func(x, *args)`) or *approx_grad* must be True.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments to pass to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**approx_grad**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If true, approximate the gradient numerically.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**list, optional'
  prefs: []
  type: TYPE_NORMAL
- en: (min, max) pairs for each element in x0, defining the bounds on that parameter.
    Use None or +/-inf for one of min or max when there is no bound in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: '**epsilon**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Used if approx_grad is True. The stepsize in a finite difference approximation
    for fprime.
  prefs: []
  type: TYPE_NORMAL
- en: '**scale**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling factors to apply to each variable. If None, the factors are up-low for
    interval bounded variables and 1+|x| for the others. Defaults to None.
  prefs: []
  type: TYPE_NORMAL
- en: '**offset**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Value to subtract from each variable. If None, the offsets are (up+low)/2 for
    interval bounded variables and x for the others.
  prefs: []
  type: TYPE_NORMAL
- en: '**messages**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Bit mask used to select messages display during minimization values defined
    in the MSGS dict. Defaults to MGS_ALL.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Integer interface to messages. 0 = no message, 5 = all messages
  prefs: []
  type: TYPE_NORMAL
- en: '**maxCGit**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of hessian*vector evaluations per main iteration. If maxCGit
    == 0, the direction chosen is -gradient if maxCGit < 0, maxCGit is set to max(1,min(50,n/2)).
    Defaults to -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxfun**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of function evaluation. If None, maxfun is set to max(100, 10*len(x0)).
    Defaults to None. Note that this function may violate the limit because of evaluating
    gradients by numerical differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: '**eta**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Severity of the line search. If < 0 or > 1, set to 0.25. Defaults to -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**stepmx**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum step for the line search. May be increased during call. If too small,
    it will be set to 10.0\. Defaults to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**accuracy**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative precision for finite difference calculations. If <= machine_precision,
    set to sqrt(machine_precision). Defaults to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**fmin**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum function value estimate. Defaults to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**ftol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Precision goal for the value of f in the stopping criterion. If ftol < 0.0,
    ftol is set to 0.0 defaults to -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**xtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Precision goal for the value of x in the stopping criterion (after applying
    x scaling factors). If xtol < 0.0, xtol is set to sqrt(machine_precision). Defaults
    to -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**pgtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Precision goal for the value of the projected gradient in the stopping criterion
    (after applying x scaling factors). If pgtol < 0.0, pgtol is set to 1e-2 * sqrt(accuracy).
    Setting it to 0.0 is not recommended. Defaults to -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**rescale**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling factor (in log10) used to trigger f value rescaling. If 0, rescale at
    each iteration. If a large value, never rescale. If < 0, rescale is set to 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Called after each iteration, as callback(xk), where xk is the current parameter
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**nfeval**int'
  prefs: []
  type: TYPE_NORMAL
- en: The number of function evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '**rc**int'
  prefs: []
  type: TYPE_NORMAL
- en: Return code, see below
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")'
  prefs: []
  type: TYPE_NORMAL
- en: Interface to minimization algorithms for multivariate functions. See the ‘TNC’
    *method* in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The underlying algorithm is truncated Newton, also called Newton Conjugate-Gradient.
    This method differs from scipy.optimize.fmin_ncg in that
  prefs: []
  type: TYPE_NORMAL
- en: it wraps a C implementation of the algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it allows each variable to be given an upper and lower bound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm incorporates the bound constraints by determining the descent
    direction as in an unconstrained truncated Newton, but never taking a step-size
    large enough to leave the space of feasible x’s. The algorithm keeps track of
    a set of currently active constraints, and ignores them when computing the minimum
    allowable step size. (The x’s associated with the active constraint are kept fixed.)
    If the maximum allowable step size is zero then a new constraint is added. At
    the end of each iteration one of the constraints may be deemed no longer active
    and removed. A constraint is considered no longer active is if it is currently
    active but the gradient for that variable points inward from the constraint. The
    specific constraint removed is the one associated with the variable of largest
    index whose constraint is no longer active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return codes are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Wright S., Nocedal J. (2006), ‘Numerical Optimization’
  prefs: []
  type: TYPE_NORMAL
- en: Nash S.G. (1984), “Newton-Type Minimization Via the Lanczos Method”, SIAM Journal
    of Numerical Analysis 21, pp. 770-778
  prefs: []
  type: TYPE_NORMAL
