["```py\ndouble rms(double* seq, int n); \n```", "```py\ndef rms(seq):\n  \"\"\"\n rms: return the root mean square of a sequence\n rms(numpy.ndarray) -> double\n rms(list) -> double\n rms(tuple) -> double\n \"\"\" \n```", "```py\n%{\n#define SWIG_FILE_WITH_INIT\n#include \"rms.h\"\n%}\n\n%include \"numpy.i\"\n\n%init %{\nimport_array();\n%}\n\n%apply (double* IN_ARRAY1, int DIM1) {(double* seq, int n)};\n%include \"rms.h\" \n```", "```py\n 1 PyObject *_wrap_rms(PyObject *args) {\n 2   PyObject *resultobj = 0;\n 3   double *arg1 = (double *) 0 ;\n 4   int arg2 ;\n 5   double result;\n 6   PyArrayObject *array1 = NULL ;\n 7   int is_new_object1 = 0 ;\n 8   PyObject * obj0 = 0 ;\n 9\n10   if (!PyArg_ParseTuple(args,(char *)\"O:rms\",&obj0)) SWIG_fail;\n11   {\n12     array1 = obj_to_array_contiguous_allow_conversion(\n13                  obj0, NPY_DOUBLE, &is_new_object1);\n14     npy_intp size[1] = {\n15       -1\n16     };\n17     if (!array1 || !require_dimensions(array1, 1) ||\n18         !require_size(array1, size, 1)) SWIG_fail;\n19     arg1 = (double*) array1->data;\n20     arg2 = (int) array1->dimensions[0];\n21   }\n22   result = (double)rms(arg1,arg2);\n23   resultobj = SWIG_From_double((double)(result));\n24   {\n25     if (is_new_object1 && array1) Py_DECREF(array1);\n26   }\n27   return resultobj;\n28 fail:\n29   {\n30     if (is_new_object1 && array1) Py_DECREF(array1);\n31   }\n32   return NULL;\n33 } \n```", "```py\ndouble rms(int n, double* seq); \n```", "```py\n%apply (int DIM1, double* IN_ARRAY1) {(int n, double* seq)}; \n```", "```py\n%{\n#define SWIG_FILE_WITH_INIT\n%}\n%include \"numpy.i\"\n%init %{\nimport_array();\n%} \n```", "```py\n%numpy_typemaps(DATA_TYPE, DATA_TYPECODE, DIM_TYPE) \n```", "```py\n%numpy_typemaps(double, NPY_DOUBLE, int)\n%numpy_typemaps(int,    NPY_INT   , int) \n```", "```py\ndouble[3] newVector(double x, double y, double z); \n```", "```py\n%typemap(out) (TYPE[ANY]); \n```", "```py\n%numpy_typemaps(bool, NPY_BOOL, int) \n```", "```py\n%numpy_typemaps(bool, NPY_UINT, int) \n```", "```py\n/* Python */\ntypedef struct {double real; double imag;} Py_complex;\n\n/* NumPy */\ntypedef struct {float  real, imag;} npy_cfloat;\ntypedef struct {double real, imag;} npy_cdouble; \n```", "```py\n%numpy_typemaps(Py_complex , NPY_CDOUBLE, int)\n%numpy_typemaps(npy_cfloat , NPY_CFLOAT , int)\n%numpy_typemaps(npy_cdouble, NPY_CDOUBLE, int) \n```", "```py\nTypeError: in method 'MyClass_MyMethod', argument 2 of type 'int' \n```", "```py\npyfragments.swg \n```", "```py\n%fragment(\"NumPy_Fragments\"); \n```", "```py\ndouble dot(int len, double* vec1, double* vec2); \n```", "```py\ndef dot(vec1, vec2):\n  \"\"\"\n dot(PyObject,PyObject) -> double\n \"\"\" \n```", "```py\n%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1),\n                                      (int len2, double* vec2)}\n%rename (dot) my_dot;\n%exception my_dot {\n    $action\n    if (PyErr_Occurred()) SWIG_fail;\n}\n%inline %{\ndouble my_dot(int len1, double* vec1, int len2, double* vec2) {\n    if (len1 != len2) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Arrays of lengths (%d,%d) given\",\n                     len1, len2);\n        return 0.0;\n    }\n    return dot(len1, vec1, vec2);\n}\n%} \n```", "```py\n>     %numpy_typemaps(double, NPY_DOUBLE, long) \n>     ```", "```py\n%apply (double* IN_ARRAY1, int DIM1) {(double* vector, int length)}\n%include \"my_header.h\"\n%clear (double* vector, int length); \n```", "```py\ndouble rms(double* seq, int n); \n```", "```py\ndef rms(seq):\n  \"\"\"\n rms: return the root mean square of a sequence\n rms(numpy.ndarray) -> double\n rms(list) -> double\n rms(tuple) -> double\n \"\"\" \n```", "```py\n%{\n#define SWIG_FILE_WITH_INIT\n#include \"rms.h\"\n%}\n\n%include \"numpy.i\"\n\n%init %{\nimport_array();\n%}\n\n%apply (double* IN_ARRAY1, int DIM1) {(double* seq, int n)};\n%include \"rms.h\" \n```", "```py\n 1 PyObject *_wrap_rms(PyObject *args) {\n 2   PyObject *resultobj = 0;\n 3   double *arg1 = (double *) 0 ;\n 4   int arg2 ;\n 5   double result;\n 6   PyArrayObject *array1 = NULL ;\n 7   int is_new_object1 = 0 ;\n 8   PyObject * obj0 = 0 ;\n 9\n10   if (!PyArg_ParseTuple(args,(char *)\"O:rms\",&obj0)) SWIG_fail;\n11   {\n12     array1 = obj_to_array_contiguous_allow_conversion(\n13                  obj0, NPY_DOUBLE, &is_new_object1);\n14     npy_intp size[1] = {\n15       -1\n16     };\n17     if (!array1 || !require_dimensions(array1, 1) ||\n18         !require_size(array1, size, 1)) SWIG_fail;\n19     arg1 = (double*) array1->data;\n20     arg2 = (int) array1->dimensions[0];\n21   }\n22   result = (double)rms(arg1,arg2);\n23   resultobj = SWIG_From_double((double)(result));\n24   {\n25     if (is_new_object1 && array1) Py_DECREF(array1);\n26   }\n27   return resultobj;\n28 fail:\n29   {\n30     if (is_new_object1 && array1) Py_DECREF(array1);\n31   }\n32   return NULL;\n33 } \n```", "```py\ndouble rms(int n, double* seq); \n```", "```py\n%apply (int DIM1, double* IN_ARRAY1) {(int n, double* seq)}; \n```", "```py\n%{\n#define SWIG_FILE_WITH_INIT\n%}\n%include \"numpy.i\"\n%init %{\nimport_array();\n%} \n```", "```py\n%numpy_typemaps(DATA_TYPE, DATA_TYPECODE, DIM_TYPE) \n```", "```py\n%numpy_typemaps(double, NPY_DOUBLE, int)\n%numpy_typemaps(int,    NPY_INT   , int) \n```", "```py\ndouble[3] newVector(double x, double y, double z); \n```", "```py\n%typemap(out) (TYPE[ANY]); \n```", "```py\n%numpy_typemaps(bool, NPY_BOOL, int) \n```", "```py\n%numpy_typemaps(bool, NPY_UINT, int) \n```", "```py\n/* Python */\ntypedef struct {double real; double imag;} Py_complex;\n\n/* NumPy */\ntypedef struct {float  real, imag;} npy_cfloat;\ntypedef struct {double real, imag;} npy_cdouble; \n```", "```py\n%numpy_typemaps(Py_complex , NPY_CDOUBLE, int)\n%numpy_typemaps(npy_cfloat , NPY_CFLOAT , int)\n%numpy_typemaps(npy_cdouble, NPY_CDOUBLE, int) \n```", "```py\ndouble[3] newVector(double x, double y, double z); \n```", "```py\n%typemap(out) (TYPE[ANY]); \n```", "```py\n%numpy_typemaps(bool, NPY_BOOL, int) \n```", "```py\n%numpy_typemaps(bool, NPY_UINT, int) \n```", "```py\n/* Python */\ntypedef struct {double real; double imag;} Py_complex;\n\n/* NumPy */\ntypedef struct {float  real, imag;} npy_cfloat;\ntypedef struct {double real, imag;} npy_cdouble; \n```", "```py\n%numpy_typemaps(Py_complex , NPY_CDOUBLE, int)\n%numpy_typemaps(npy_cfloat , NPY_CFLOAT , int)\n%numpy_typemaps(npy_cdouble, NPY_CDOUBLE, int) \n```", "```py\nTypeError: in method 'MyClass_MyMethod', argument 2 of type 'int' \n```", "```py\npyfragments.swg \n```", "```py\n%fragment(\"NumPy_Fragments\"); \n```", "```py\ndouble dot(int len, double* vec1, double* vec2); \n```", "```py\ndef dot(vec1, vec2):\n  \"\"\"\n dot(PyObject,PyObject) -> double\n \"\"\" \n```", "```py\n%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1),\n                                      (int len2, double* vec2)}\n%rename (dot) my_dot;\n%exception my_dot {\n    $action\n    if (PyErr_Occurred()) SWIG_fail;\n}\n%inline %{\ndouble my_dot(int len1, double* vec1, int len2, double* vec2) {\n    if (len1 != len2) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Arrays of lengths (%d,%d) given\",\n                     len1, len2);\n        return 0.0;\n    }\n    return dot(len1, vec1, vec2);\n}\n%} \n```", "```py\n>     %numpy_typemaps(double, NPY_DOUBLE, long) \n>     ```", "```py\n%apply (double* IN_ARRAY1, int DIM1) {(double* vector, int length)}\n%include \"my_header.h\"\n%clear (double* vector, int length); \n```", "```py\ndouble dot(int len, double* vec1, double* vec2); \n```", "```py\ndef dot(vec1, vec2):\n  \"\"\"\n dot(PyObject,PyObject) -> double\n \"\"\" \n```", "```py\n%apply (int DIM1, double* IN_ARRAY1) {(int len1, double* vec1),\n                                      (int len2, double* vec2)}\n%rename (dot) my_dot;\n%exception my_dot {\n    $action\n    if (PyErr_Occurred()) SWIG_fail;\n}\n%inline %{\ndouble my_dot(int len1, double* vec1, int len2, double* vec2) {\n    if (len1 != len2) {\n        PyErr_Format(PyExc_ValueError,\n                     \"Arrays of lengths (%d,%d) given\",\n                     len1, len2);\n        return 0.0;\n    }\n    return dot(len1, vec1, vec2);\n}\n%} \n```", "```py\n>     %numpy_typemaps(double, NPY_DOUBLE, long) \n>     ```", "```py\n%apply (double* IN_ARRAY1, int DIM1) {(double* vector, int length)}\n%include \"my_header.h\"\n%clear (double* vector, int length); \n```"]