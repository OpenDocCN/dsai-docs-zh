- en: Frequently Asked Questions (FAQ)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/gotchas.html](https://pandas.pydata.org/docs/user_guide/gotchas.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## DataFrame memory usage'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The memory usage of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (including the index) is shown when calling the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"). A configuration option, `display.memory_usage` (see
    [the list of options](options.html#options-available)), specifies if the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") memory usage will be displayed when invoking the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info") method.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the memory usage of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") below is shown when calling [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `+` symbol indicates that the true memory usage could be higher, because
    pandas does not count the memory used by values in columns with `dtype=object`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Passing `memory_usage='deep'` will enable a more accurate memory usage report,
    accounting for the full usage of the contained objects. This is optional as it
    can be expensive to do this deeper introspection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default the display option is set to `True` but can be explicitly overridden
    by passing the `memory_usage` argument when invoking [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory usage of each column can be found by calling the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method. This returns a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") with an index represented by column names and memory usage of
    each column shown in bytes. For the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") above, the memory usage of each column and the total memory
    usage can be found with the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By default the memory usage of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") index is shown in the returned [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), the memory usage of the index can be suppressed by passing the
    `index=False` argument:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The memory usage displayed by the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info") method utilizes the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method to determine the memory usage of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") while also formatting the output in human-readable units (base-2
    representation; i.e. 1KB = 1024 bytes).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'See also [Categorical Memory Usage](categorical.html#categorical-memory).  ##
    Using if/truth statements with pandas'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas follows the NumPy convention of raising an error when you try to convert
    something to a `bool`. This happens in an `if`-statement or when using the boolean
    operations: `and`, `or`, and `not`. It is not clear what the result of the following
    code should be:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Should it be `True` because it’s not zero-length, or `False` because there
    are `False` values? It is unclear, so instead, pandas raises a `ValueError`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You need to explicitly choose what you want to do with the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), e.g. use [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all") or [`empty()`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"). Alternatively, you might want to compare if the pandas
    object is `None`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Below is how to check if any of the values are `True`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bitwise boolean
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitwise boolean operators like `==` and `!=` return a boolean [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") which performs an element-wise comparison when compared to a
    scalar.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See [boolean comparisons](basics.html#basics-compare) for more examples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Using the `in` operator
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the Python `in` operator on a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") tests for membership in the **index**, not membership among the
    values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If this behavior is surprising, keep in mind that using `in` on a Python dictionary
    tests keys, not values, and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") are dict-like. To test for membership in the values, use the
    method [`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin"):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"),
    likewise, `in` applies to the column axis, testing for membership in the list
    of column names.  ## Mutating with User Defined Function (UDF) methods'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: This section applies to pandas methods that take a UDF. In particular, the methods
    [`DataFrame.apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), [`DataFrame.transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform"), and [`DataFrame.filter()`](../reference/api/pandas.DataFrame.filter.html#pandas.DataFrame.filter
    "pandas.DataFrame.filter").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a general rule in programming that one should not mutate a container
    while it is being iterated over. Mutation will invalidate the iterator, causing
    unexpected behavior. Consider the example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One probably would have expected that the result would be `[1, 3, 5]`. When
    using a pandas method that takes a UDF, internally pandas is often iterating over
    the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    or other pandas object. Therefore, if the UDF mutates (changes) the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), unexpected behavior can arise.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a similar example with [`DataFrame.apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To resolve this issue, one can make a copy so that the mutation does not apply
    to the container being iterated over.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Missing value representation for NumPy types
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.nan` as the `NA` representation for NumPy types'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For lack of `NA` (missing) support from the ground up in NumPy and Python in
    general, `NA` could have been represented with:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'A *masked array* solution: an array of data and an array of boolean values
    indicating whether a value is there or is missing.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a special sentinel value, bit pattern, or set of sentinel values to denote
    `NA` across the dtypes.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special value `np.nan` (Not-A-Number) was chosen as the `NA` value for NumPy
    types, and there are API functions like [`DataFrame.isna()`](../reference/api/pandas.DataFrame.isna.html#pandas.DataFrame.isna
    "pandas.DataFrame.isna") and [`DataFrame.notna()`](../reference/api/pandas.DataFrame.notna.html#pandas.DataFrame.notna
    "pandas.DataFrame.notna") which can be used across the dtypes to detect NA values.
    However, this choice has a downside of coercing missing integer data as float
    types as shown in [Support for integer NA](#gotchas-intna).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`NA` type promotions for NumPy types'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When introducing NAs into an existing [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") via [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") or some other means, boolean and integer types will be
    promoted to a different dtype in order to store the NAs. The promotions are summarized
    in this table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex")或其他方式向现有的[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")或[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")引入NA时，布尔和整数类型将被提升为不同的dtype以存储NA。这些提升总结在这个表中：
- en: '| Typeclass | Promotion dtype for storing NAs |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 用于存储NA的提升dtype |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `floating` | no change |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `floating` | 无变化 |'
- en: '| `object` | no change |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 无变化 |'
- en: '| `integer` | cast to `float64` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | 转换为`float64` |'
- en: '| `boolean` | cast to `object` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | 转换为`object` |'
- en: '### Support for integer `NA`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持整数`NA`'
- en: 'In the absence of high performance `NA` support being built into NumPy from
    the ground up, the primary casualty is the ability to represent NAs in integer
    arrays. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy中没有从头开始构建高性能`NA`支持的情况下，主要的牺牲品是无法在整数数组中表示NA。例如：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This trade-off is made largely for memory and performance reasons, and also
    so that the resulting [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") continues to be “numeric”.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种权衡主要是出于内存和性能原因，以及确保生成的[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")继续是“数值型”的原因。
- en: If you need to represent integers with possibly missing values, use one of the
    nullable-integer extension dtypes provided by pandas or pyarrow
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要表示可能缺失值的整数，请使用pandas或pyarrow提供的可空整数扩展dtypes之一
- en: '[`Int8Dtype`](../reference/api/pandas.Int8Dtype.html#pandas.Int8Dtype "pandas.Int8Dtype")'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Int8Dtype`](../reference/api/pandas.Int8Dtype.html#pandas.Int8Dtype "pandas.Int8Dtype")'
- en: '[`Int16Dtype`](../reference/api/pandas.Int16Dtype.html#pandas.Int16Dtype "pandas.Int16Dtype")'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Int16Dtype`](../reference/api/pandas.Int16Dtype.html#pandas.Int16Dtype "pandas.Int16Dtype")'
- en: '[`Int32Dtype`](../reference/api/pandas.Int32Dtype.html#pandas.Int32Dtype "pandas.Int32Dtype")'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Int32Dtype`](../reference/api/pandas.Int32Dtype.html#pandas.Int32Dtype "pandas.Int32Dtype")'
- en: '[`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")'
- en: '[`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype "pandas.ArrowDtype")'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype "pandas.ArrowDtype")'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See [Nullable integer data type](integer_na.html#integer-na) and [PyArrow Functionality](pyarrow.html#pyarrow)
    for more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[可空整数数据类型](integer_na.html#integer-na)和[PyArrow功能](pyarrow.html#pyarrow)以获取更多信息。
- en: Why not make NumPy like R?
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么不让NumPy像R一样呢？
- en: 'Many people have suggested that NumPy should simply emulate the `NA` support
    present in the more domain-specific statistical programming language [R](https://www.r-project.org/).
    Part of the reason is the NumPy type hierarchy:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人建议NumPy应该简单地模仿更多领域特定的统计编程语言[R](https://www.r-project.org/)中存在的`NA`支持。部分原因是NumPy类型层次结构：
- en: '| Typeclass | Dtypes |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | Dtypes |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `numpy.floating` | `float16, float32, float64, float128` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.floating` | `float16, float32, float64, float128` |'
- en: '| `numpy.integer` | `int8, int16, int32, int64` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.integer` | `int8, int16, int32, int64` |'
- en: '| `numpy.unsignedinteger` | `uint8, uint16, uint32, uint64` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.unsignedinteger` | `uint8, uint16, uint32, uint64` |'
- en: '| `numpy.object_` | `object_` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.object_` | `object_` |'
- en: '| `numpy.bool_` | `bool_` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.bool_` | `bool_` |'
- en: '| `numpy.character` | `bytes_, str_` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `numpy.character` | `bytes_, str_` |'
- en: 'The R language, by contrast, only has a handful of built-in data types: `integer`,
    `numeric` (floating-point), `character`, and `boolean`. `NA` types are implemented
    by reserving special bit patterns for each type to be used as the missing value.
    While doing this with the full NumPy type hierarchy would be possible, it would
    be a more substantial trade-off (especially for the 8- and 16-bit data types)
    and implementation undertaking.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，R语言只有少数几种内置数据类型：`integer`、`numeric`（浮点数）、`character`和`boolean`。`NA`类型是通过为每种类型保留特殊的位模式来实现的，用作缺失值。虽然在整个NumPy类型层次结构中执行此操作是可能的，但这将是一个更重大的权衡（特别是对于8位和16位数据类型），并且需要更多的实现工作。
- en: However, R `NA` semantics are now available by using masked NumPy types such
    as [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")
    or PyArrow types ([`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype
    "pandas.ArrowDtype")).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Differences with NumPy
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    objects, [`var()`](../reference/api/pandas.DataFrame.var.html#pandas.DataFrame.var
    "pandas.DataFrame.var") normalizes by `N-1` to produce [unbiased estimates of
    the population variance](https://en.wikipedia.org/wiki/Bias_of_an_estimator),
    while NumPy’s `numpy.var()` normalizes by N, which measures the variance of the
    sample. Note that [`cov()`](../reference/api/pandas.DataFrame.cov.html#pandas.DataFrame.cov
    "pandas.DataFrame.cov") normalizes by `N-1` in both pandas and NumPy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '## Thread-safety'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: pandas is not 100% thread safe. The known issues relate to the [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method. If you are doing a lot of copying of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects shared among threads, we recommend holding locks inside
    the threads where the data copying occurs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: See [this link](https://stackoverflow.com/questions/13592618/python-pandas-dataframe-thread-safe)
    for more information.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Byte-ordering issues
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally you may have to deal with data that were created on a machine
    with a different byte order than the one on which you are running Python. A common
    symptom of this issue is an error like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To deal with this issue you should convert the underlying NumPy array to the
    native system byte order *before* passing it to [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructors using something similar to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See [the NumPy documentation on byte order](https://numpy.org/doc/stable/user/basics.byteswapping.html)
    for more details.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '## DataFrame memory usage'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The memory usage of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (including the index) is shown when calling the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"). A configuration option, `display.memory_usage` (see
    [the list of options](options.html#options-available)), specifies if the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") memory usage will be displayed when invoking the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info") method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the memory usage of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") below is shown when calling [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `+` symbol indicates that the true memory usage could be higher, because
    pandas does not count the memory used by values in columns with `dtype=object`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Passing `memory_usage='deep'` will enable a more accurate memory usage report,
    accounting for the full usage of the contained objects. This is optional as it
    can be expensive to do this deeper introspection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default the display option is set to `True` but can be explicitly overridden
    by passing the `memory_usage` argument when invoking [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory usage of each column can be found by calling the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method. This returns a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") with an index represented by column names and memory usage of
    each column shown in bytes. For the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") above, the memory usage of each column and the total memory
    usage can be found with the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By default the memory usage of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") index is shown in the returned [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), the memory usage of the index can be suppressed by passing the
    `index=False` argument:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The memory usage displayed by the [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info") method utilizes the [`memory_usage()`](../reference/api/pandas.DataFrame.memory_usage.html#pandas.DataFrame.memory_usage
    "pandas.DataFrame.memory_usage") method to determine the memory usage of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") while also formatting the output in human-readable units (base-2
    representation; i.e. 1KB = 1024 bytes).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: See also [Categorical Memory Usage](categorical.html#categorical-memory).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '## Using if/truth statements with pandas'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas follows the NumPy convention of raising an error when you try to convert
    something to a `bool`. This happens in an `if`-statement or when using the boolean
    operations: `and`, `or`, and `not`. It is not clear what the result of the following
    code should be:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Should it be `True` because it’s not zero-length, or `False` because there
    are `False` values? It is unclear, so instead, pandas raises a `ValueError`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You need to explicitly choose what you want to do with the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), e.g. use [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all") or [`empty()`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"). Alternatively, you might want to compare if the pandas
    object is `None`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Below is how to check if any of the values are `True`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Bitwise boolean
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitwise boolean operators like `==` and `!=` return a boolean [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") which performs an element-wise comparison when compared to a
    scalar.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See [boolean comparisons](basics.html#basics-compare) for more examples.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Using the `in` operator
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the Python `in` operator on a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") tests for membership in the **index**, not membership among the
    values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If this behavior is surprising, keep in mind that using `in` on a Python dictionary
    tests keys, not values, and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") are dict-like. To test for membership in the values, use the
    method [`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin"):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"),
    likewise, `in` applies to the column axis, testing for membership in the list
    of column names.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise boolean
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitwise boolean operators like `==` and `!=` return a boolean [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") which performs an element-wise comparison when compared to a
    scalar.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See [boolean comparisons](basics.html#basics-compare) for more examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Using the `in` operator
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the Python `in` operator on a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") tests for membership in the **index**, not membership among the
    values.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If this behavior is surprising, keep in mind that using `in` on a Python dictionary
    tests keys, not values, and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") are dict-like. To test for membership in the values, use the
    method [`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin"):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"),
    likewise, `in` applies to the column axis, testing for membership in the list
    of column names.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '## Mutating with User Defined Function (UDF) methods'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: This section applies to pandas methods that take a UDF. In particular, the methods
    [`DataFrame.apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), [`DataFrame.transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform"), and [`DataFrame.filter()`](../reference/api/pandas.DataFrame.filter.html#pandas.DataFrame.filter
    "pandas.DataFrame.filter").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a general rule in programming that one should not mutate a container
    while it is being iterated over. Mutation will invalidate the iterator, causing
    unexpected behavior. Consider the example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: One probably would have expected that the result would be `[1, 3, 5]`. When
    using a pandas method that takes a UDF, internally pandas is often iterating over
    the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    or other pandas object. Therefore, if the UDF mutates (changes) the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), unexpected behavior can arise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a similar example with [`DataFrame.apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To resolve this issue, one can make a copy so that the mutation does not apply
    to the container being iterated over.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Missing value representation for NumPy types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.nan` as the `NA` representation for NumPy types'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For lack of `NA` (missing) support from the ground up in NumPy and Python in
    general, `NA` could have been represented with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'A *masked array* solution: an array of data and an array of boolean values
    indicating whether a value is there or is missing.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a special sentinel value, bit pattern, or set of sentinel values to denote
    `NA` across the dtypes.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special value `np.nan` (Not-A-Number) was chosen as the `NA` value for NumPy
    types, and there are API functions like [`DataFrame.isna()`](../reference/api/pandas.DataFrame.isna.html#pandas.DataFrame.isna
    "pandas.DataFrame.isna") and [`DataFrame.notna()`](../reference/api/pandas.DataFrame.notna.html#pandas.DataFrame.notna
    "pandas.DataFrame.notna") which can be used across the dtypes to detect NA values.
    However, this choice has a downside of coercing missing integer data as float
    types as shown in [Support for integer NA](#gotchas-intna).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '`NA` type promotions for NumPy types'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When introducing NAs into an existing [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") via [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") or some other means, boolean and integer types will be
    promoted to a different dtype in order to store the NAs. The promotions are summarized
    in this table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '| Typeclass | Promotion dtype for storing NAs |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `floating` | no change |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| `object` | no change |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `integer` | cast to `float64` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | cast to `object` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '### Support for integer `NA`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'In the absence of high performance `NA` support being built into NumPy from
    the ground up, the primary casualty is the ability to represent NAs in integer
    arrays. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This trade-off is made largely for memory and performance reasons, and also
    so that the resulting [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") continues to be “numeric”.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If you need to represent integers with possibly missing values, use one of the
    nullable-integer extension dtypes provided by pandas or pyarrow
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[`Int8Dtype`](../reference/api/pandas.Int8Dtype.html#pandas.Int8Dtype "pandas.Int8Dtype")'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int16Dtype`](../reference/api/pandas.Int16Dtype.html#pandas.Int16Dtype "pandas.Int16Dtype")'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int32Dtype`](../reference/api/pandas.Int32Dtype.html#pandas.Int32Dtype "pandas.Int32Dtype")'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype "pandas.ArrowDtype")'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See [Nullable integer data type](integer_na.html#integer-na) and [PyArrow Functionality](pyarrow.html#pyarrow)
    for more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Why not make NumPy like R?
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many people have suggested that NumPy should simply emulate the `NA` support
    present in the more domain-specific statistical programming language [R](https://www.r-project.org/).
    Part of the reason is the NumPy type hierarchy:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '| Typeclass | Dtypes |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `numpy.floating` | `float16, float32, float64, float128` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `numpy.integer` | `int8, int16, int32, int64` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `numpy.unsignedinteger` | `uint8, uint16, uint32, uint64` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `numpy.object_` | `object_` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `numpy.bool_` | `bool_` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `numpy.character` | `bytes_, str_` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: 'The R language, by contrast, only has a handful of built-in data types: `integer`,
    `numeric` (floating-point), `character`, and `boolean`. `NA` types are implemented
    by reserving special bit patterns for each type to be used as the missing value.
    While doing this with the full NumPy type hierarchy would be possible, it would
    be a more substantial trade-off (especially for the 8- and 16-bit data types)
    and implementation undertaking.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: However, R `NA` semantics are now available by using masked NumPy types such
    as [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")
    or PyArrow types ([`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype
    "pandas.ArrowDtype")).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`np.nan` as the `NA` representation for NumPy types'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For lack of `NA` (missing) support from the ground up in NumPy and Python in
    general, `NA` could have been represented with:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'A *masked array* solution: an array of data and an array of boolean values
    indicating whether a value is there or is missing.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a special sentinel value, bit pattern, or set of sentinel values to denote
    `NA` across the dtypes.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special value `np.nan` (Not-A-Number) was chosen as the `NA` value for NumPy
    types, and there are API functions like [`DataFrame.isna()`](../reference/api/pandas.DataFrame.isna.html#pandas.DataFrame.isna
    "pandas.DataFrame.isna") and [`DataFrame.notna()`](../reference/api/pandas.DataFrame.notna.html#pandas.DataFrame.notna
    "pandas.DataFrame.notna") which can be used across the dtypes to detect NA values.
    However, this choice has a downside of coercing missing integer data as float
    types as shown in [Support for integer NA](#gotchas-intna).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '`NA` type promotions for NumPy types'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When introducing NAs into an existing [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") via [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") or some other means, boolean and integer types will be
    promoted to a different dtype in order to store the NAs. The promotions are summarized
    in this table:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '| Typeclass | Promotion dtype for storing NAs |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| `floating` | no change |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: '| `object` | no change |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
- en: '| `integer` | cast to `float64` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | cast to `object` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '### Support for integer `NA`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In the absence of high performance `NA` support being built into NumPy from
    the ground up, the primary casualty is the ability to represent NAs in integer
    arrays. For example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This trade-off is made largely for memory and performance reasons, and also
    so that the resulting [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") continues to be “numeric”.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: If you need to represent integers with possibly missing values, use one of the
    nullable-integer extension dtypes provided by pandas or pyarrow
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[`Int8Dtype`](../reference/api/pandas.Int8Dtype.html#pandas.Int8Dtype "pandas.Int8Dtype")'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int16Dtype`](../reference/api/pandas.Int16Dtype.html#pandas.Int16Dtype "pandas.Int16Dtype")'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int32Dtype`](../reference/api/pandas.Int32Dtype.html#pandas.Int32Dtype "pandas.Int32Dtype")'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype "pandas.ArrowDtype")'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See [Nullable integer data type](integer_na.html#integer-na) and [PyArrow Functionality](pyarrow.html#pyarrow)
    for more.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Why not make NumPy like R?
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many people have suggested that NumPy should simply emulate the `NA` support
    present in the more domain-specific statistical programming language [R](https://www.r-project.org/).
    Part of the reason is the NumPy type hierarchy:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '| Typeclass | Dtypes |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `numpy.floating` | `float16, float32, float64, float128` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `numpy.integer` | `int8, int16, int32, int64` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `numpy.unsignedinteger` | `uint8, uint16, uint32, uint64` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `numpy.object_` | `object_` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `numpy.bool_` | `bool_` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `numpy.character` | `bytes_, str_` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: 'The R language, by contrast, only has a handful of built-in data types: `integer`,
    `numeric` (floating-point), `character`, and `boolean`. `NA` types are implemented
    by reserving special bit patterns for each type to be used as the missing value.
    While doing this with the full NumPy type hierarchy would be possible, it would
    be a more substantial trade-off (especially for the 8- and 16-bit data types)
    and implementation undertaking.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: However, R `NA` semantics are now available by using masked NumPy types such
    as [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype "pandas.Int64Dtype")
    or PyArrow types ([`ArrowDtype`](../reference/api/pandas.ArrowDtype.html#pandas.ArrowDtype
    "pandas.ArrowDtype")).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Differences with NumPy
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    objects, [`var()`](../reference/api/pandas.DataFrame.var.html#pandas.DataFrame.var
    "pandas.DataFrame.var") normalizes by `N-1` to produce [unbiased estimates of
    the population variance](https://en.wikipedia.org/wiki/Bias_of_an_estimator),
    while NumPy’s `numpy.var()` normalizes by N, which measures the variance of the
    sample. Note that [`cov()`](../reference/api/pandas.DataFrame.cov.html#pandas.DataFrame.cov
    "pandas.DataFrame.cov") normalizes by `N-1` in both pandas and NumPy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '## Thread-safety'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: pandas is not 100% thread safe. The known issues relate to the [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method. If you are doing a lot of copying of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects shared among threads, we recommend holding locks inside
    the threads where the data copying occurs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: See [this link](https://stackoverflow.com/questions/13592618/python-pandas-dataframe-thread-safe)
    for more information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Byte-ordering issues
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally you may have to deal with data that were created on a machine
    with a different byte order than the one on which you are running Python. A common
    symptom of this issue is an error like:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To deal with this issue you should convert the underlying NumPy array to the
    native system byte order *before* passing it to [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructors using something similar to the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See [the NumPy documentation on byte order](https://numpy.org/doc/stable/user/basics.byteswapping.html)
    for more details.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
