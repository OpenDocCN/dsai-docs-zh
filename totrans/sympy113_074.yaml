- en: Combinatorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/functions/combinatorial.html](https://docs.sympy.org/latest/modules/functions/combinatorial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This module implements various combinatorial functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Bell numbers / Bell polynomials
  prefs: []
  type: TYPE_NORMAL
- en: The Bell numbers satisfy \(B_0 = 1\) and
  prefs: []
  type: TYPE_NORMAL
- en: \[B_n = \sum_{k=0}^{n-1} \binom{n-1}{k} B_k.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[B_n = \frac{1}{e} \sum_{k=0}^{\infty} \frac{k^n}{k!}.\]
  prefs: []
  type: TYPE_NORMAL
- en: The Bell polynomials are given by \(B_0(x) = 1\) and
  prefs: []
  type: TYPE_NORMAL
- en: \[B_n(x) = x \sum_{k=1}^{n-1} \binom{n-1}{k-1} B_{k-1}(x).\]
  prefs: []
  type: TYPE_NORMAL
- en: The second kind of Bell polynomials (are sometimes called “partial” Bell polynomials
    or incomplete Bell polynomials) are defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[B_{n,k}(x_1, x_2,\dotsc x_{n-k+1}) = \sum_{j_1+j_2+j_2+\dotsb=k \atop j_1+2j_2+3j_2+\dotsb=n}
    \frac{n!}{j_1!j_2!\dotsb j_{n-k+1}!} \left(\frac{x_1}{1!} \right)^{j_1} \left(\frac{x_2}{2!}
    \right)^{j_2} \dotsb \left(\frac{x_{n-k+1}}{(n-k+1)!} \right) ^{j_{n-k+1}}.\]
  prefs: []
  type: TYPE_NORMAL
- en: '`bell(n)` gives the \(n^{th}\) Bell number, \(B_n\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bell(n, x)` gives the \(n^{th}\) Bell polynomial, \(B_n(x)\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bell(n, k, (x1, x2, ...))` gives Bell polynomials of the second kind, \(B_{n,k}(x_1,
    x_2, \dotsc, x_{n-k+1})\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Not to be confused with Bernoulli numbers and Bernoulli polynomials, which use
    the same notation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R207](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bell_number](https://en.wikipedia.org/wiki/Bell_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R208](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/BellNumber.html](https://mathworld.wolfram.com/BellNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R209](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/BellPolynomial.html](https://mathworld.wolfram.com/BellPolynomial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Bernoulli numbers / Bernoulli polynomials / Bernoulli function
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bernoulli numbers are a sequence of rational numbers defined by \(B_0 =
    1\) and the recursive relation (\(n > 0\)):'
  prefs: []
  type: TYPE_NORMAL
- en: \[n+1 = \sum_{k=0}^n \binom{n+1}{k} B_k\]
  prefs: []
  type: TYPE_NORMAL
- en: They are also commonly defined by their exponential generating function, which
    is \(\frac{x}{1 - e^{-x}}\). For odd indices > 1, the Bernoulli numbers are zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bernoulli polynomials satisfy the analogous formula:'
  prefs: []
  type: TYPE_NORMAL
- en: \[B_n(x) = \sum_{k=0}^n (-1)^k \binom{n}{k} B_k x^{n-k}\]
  prefs: []
  type: TYPE_NORMAL
- en: Bernoulli numbers and Bernoulli polynomials are related as \(B_n(1) = B_n\).
  prefs: []
  type: TYPE_NORMAL
- en: The generalized Bernoulli function \(\operatorname{B}(s, a)\) is defined for
    any complex \(s\) and \(a\), except where \(a\) is a nonpositive integer and \(s\)
    is not a nonnegative integer. It is an entire function of \(s\) for fixed \(a\),
    related to the Hurwitz zeta function by
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\operatorname{B}(s, a) = \begin{cases} -s \zeta(1-s, a) & s \ne
    0 \\ 1 & s = 0 \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(s\) is a nonnegative integer this function reduces to the Bernoulli
    polynomials: \(\operatorname{B}(n, x) = B_n(x)\). When \(a\) is omitted it is
    assumed to be 1, yielding the (ordinary) Bernoulli function which interpolates
    the Bernoulli numbers and is related to the Riemann zeta function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We compute Bernoulli numbers using Ramanujan’s formula:'
  prefs: []
  type: TYPE_NORMAL
- en: \[B_n = \frac{A(n) - S(n)}{\binom{n+3}{n}}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}A(n) = \begin{cases} \frac{n+3}{3} & n \equiv 0\ \text{or}\ 2
    \pmod{6} \\ -\frac{n+3}{6} & n \equiv 4 \pmod{6} \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: \[S(n) = \sum_{k=1}^{[n/6]} \binom{n+3}{n-6k} B_{n-6k}\]
  prefs: []
  type: TYPE_NORMAL
- en: This formula is similar to the sum given in the definition, but cuts \(\frac{2}{3}\)
    of the terms. For Bernoulli polynomials, we use Appell sequences.
  prefs: []
  type: TYPE_NORMAL
- en: For \(n\) a nonnegative integer and \(s\), \(a\), \(x\) arbitrary complex numbers,
  prefs: []
  type: TYPE_NORMAL
- en: '`bernoulli(n)` gives the nth Bernoulli number, \(B_n\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bernoulli(s)` gives the Bernoulli function \(\operatorname{B}(s)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bernoulli(n, x)` gives the nth Bernoulli polynomial in \(x\), \(B_n(x)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bernoulli(s, a)` gives the generalized Bernoulli function \(\operatorname{B}(s,
    a)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 1.12: `bernoulli(1)` gives \(+\frac{1}{2}\) instead of \(-\frac{1}{2}\).
    This choice of value confers several theoretical advantages [[R214]](#r214), including
    the extension to complex parameters described above which this function now implements.
    The previous behavior, defined only for nonnegative integers \(n\), can be obtained
    with `(-1)**n*bernoulli(n)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`andre`](#sympy.functions.combinatorial.numbers.andre "sympy.functions.combinatorial.numbers.andre"),
    [`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci"),
    [`sympy.polys.appellseqs.bernoulli_poly`](../polys/reference.html#sympy.polys.appellseqs.bernoulli_poly
    "sympy.polys.appellseqs.bernoulli_poly")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R210](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bernoulli_number](https://en.wikipedia.org/wiki/Bernoulli_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R211](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bernoulli_polynomial](https://en.wikipedia.org/wiki/Bernoulli_polynomial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R212](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/BernoulliNumber.html](https://mathworld.wolfram.com/BernoulliNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R213](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/BernoulliPolynomial.html](https://mathworld.wolfram.com/BernoulliPolynomial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R214] ([1](#id4),[2](#id9))'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Luschny, “The Bernoulli Manifesto”, [https://luschny.de/math/zeta/The-Bernoulli-Manifesto.html](https://luschny.de/math/zeta/The-Bernoulli-Manifesto.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R215](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Luschny, “An introduction to the Bernoulli function”, [https://arxiv.org/abs/2009.06743](https://arxiv.org/abs/2009.06743)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementation of the binomial coefficient. It can be defined in two ways depending
    on its desired interpretation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\binom{n}{k} = \frac{n!}{k!(n-k)!}\ \text{or}\ \binom{n}{k} = \frac{(n)_k}{k!}\]
  prefs: []
  type: TYPE_NORMAL
- en: First, in a strict combinatorial sense it defines the number of ways we can
    choose \(k\) elements from a set of \(n\) elements. In this case both arguments
    are nonnegative integers and binomial is computed using an efficient algorithm
    based on prime factorization.
  prefs: []
  type: TYPE_NORMAL
- en: The other definition is generalization for arbitrary \(n\), however \(k\) must
    also be nonnegative. This case is very useful when evaluating summations.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of convenience, for negative integer \(k\) this function will return
    zero no matter the other argument.
  prefs: []
  type: TYPE_NORMAL
- en: To expand the binomial when \(n\) is a symbol, use either `expand_func()` or
    `expand(func=True)`. The former will keep the polynomial in factored form while
    the latter will expand the polynomial itself. See examples for details.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Rows of Pascal’s triangle can be generated with the binomial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As can a given diagonal, e.g. the 4th diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, we can also compute binomial coefficients modulo a prime p quickly
    using Lucas’ Theorem [[R217]](#r217), though we need to include \(evaluate=False\)
    to postpone evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a generalisation of Lucas’s Theorem given by Granville [[R218]](#r218),
    we can extend this to arbitrary n:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R216](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.johndcook.com/blog/binomial_coefficients/](https://www.johndcook.com/blog/binomial_coefficients/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R217] ([1](#id11),[2](#id14))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lucas%27s_theorem](https://en.wikipedia.org/wiki/Lucas%27s_theorem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R218] ([1](#id12),[2](#id15))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binomial coefficients modulo prime powers, Andrew Granville, Available: [https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Catalan numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'The \(n^{th}\) catalan number is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[C_n = \frac{1}{n+1} \binom{2n}{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: '`catalan(n)` gives the \(n^{th}\) Catalan number, \(C_n\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Catalan numbers can be transformed into several other, identical expressions
    involving other mathematical functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For some non-integer values of n we can get closed form expressions by rewriting
    in terms of gamma functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can differentiate the Catalan numbers C(n) interpreted as a continuous real
    function in n:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As a more advanced example consider the following ratio between consecutive
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The Catalan numbers can be generalized to complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'and evaluated with arbitrary precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`andre`](#sympy.functions.combinatorial.numbers.andre "sympy.functions.combinatorial.numbers.andre"),
    [`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci"),
    [`sympy.functions.combinatorial.factorials.binomial`](#sympy.functions.combinatorial.factorials.binomial
    "sympy.functions.combinatorial.factorials.binomial")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R219](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Catalan_number](https://en.wikipedia.org/wiki/Catalan_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R220](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/CatalanNumber.html](https://mathworld.wolfram.com/CatalanNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R221](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://functions.wolfram.com/GammaBetaErf/CatalanNumber/](https://functions.wolfram.com/GammaBetaErf/CatalanNumber/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R222](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://geometer.org/mathcircles/catalan.pdf](http://geometer.org/mathcircles/catalan.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Euler numbers / Euler polynomials / Euler function
  prefs: []
  type: TYPE_NORMAL
- en: 'The Euler numbers are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[E_{2n} = I \sum_{k=1}^{2n+1} \sum_{j=0}^k \binom{k}{j} \frac{(-1)^j (k-2j)^{2n+1}}{2^k
    I^k k}\]\[E_{2n+1} = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: Euler numbers and Euler polynomials are related by
  prefs: []
  type: TYPE_NORMAL
- en: \[E_n = 2^n E_n\left(\frac{1}{2}\right).\]
  prefs: []
  type: TYPE_NORMAL
- en: We compute symbolic Euler polynomials using Appell sequences, but numerical
    evaluation of the Euler polynomial is computed more efficiently (and more accurately)
    using the mpmath library.
  prefs: []
  type: TYPE_NORMAL
- en: The Euler polynomials are special cases of the generalized Euler function, related
    to the Genocchi function as
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{E}(s, a) = -\frac{\operatorname{G}(s+1, a)}{s+1}\]
  prefs: []
  type: TYPE_NORMAL
- en: with the limit of \(\psi\left(\frac{a+1}{2}\right) - \psi\left(\frac{a}{2}\right)\)
    being taken when \(s = -1\). The (ordinary) Euler function interpolating the Euler
    numbers is then obtained as \(\operatorname{E}(s) = 2^s \operatorname{E}\left(s,
    \frac{1}{2}\right)\).
  prefs: []
  type: TYPE_NORMAL
- en: '`euler(n)` gives the nth Euler number \(E_n\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`euler(s)` gives the Euler function \(\operatorname{E}(s)\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`euler(n, x)` gives the nth Euler polynomial \(E_n(x)\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`euler(s, a)` gives the generalized Euler function \(\operatorname{E}(s, a)\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`andre`](#sympy.functions.combinatorial.numbers.andre "sympy.functions.combinatorial.numbers.andre"),
    [`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci"),
    [`sympy.polys.appellseqs.euler_poly`](../polys/reference.html#sympy.polys.appellseqs.euler_poly
    "sympy.polys.appellseqs.euler_poly")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R223](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler_numbers](https://en.wikipedia.org/wiki/Euler_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R224](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/EulerNumber.html](https://mathworld.wolfram.com/EulerNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R225](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Alternating_permutation](https://en.wikipedia.org/wiki/Alternating_permutation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R226](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/AlternatingPermutation.html](https://mathworld.wolfram.com/AlternatingPermutation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Implementation of factorial function over nonnegative integers. By convention
    (consistent with the gamma function and the binomial coefficients), factorial
    of a negative integer is complex infinity.
  prefs: []
  type: TYPE_NORMAL
- en: The factorial is very important in combinatorics where it gives the number of
    ways in which \(n\) objects can be permuted. It also arises in calculus, probability,
    number theory, etc.
  prefs: []
  type: TYPE_NORMAL
- en: There is strict relation of factorial with gamma function. In fact \(n! = gamma(n+1)\)
    for nonnegative integers. Rewrite of this kind is very useful in case of combinatorial
    simplification.
  prefs: []
  type: TYPE_NORMAL
- en: Computation of the factorial is done using two algorithms. For small arguments
    a precomputed look up table is used. However for bigger input algorithm Prime-Swing
    is used. It is the fastest algorithm known and computes \(n!\) via prime factorization
    of special class of numbers, called here the ‘Swing Numbers’.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorial2`](#sympy.functions.combinatorial.factorials.factorial2 "sympy.functions.combinatorial.factorials.factorial2"),
    [`RisingFactorial`](#sympy.functions.combinatorial.factorials.RisingFactorial
    "sympy.functions.combinatorial.factorials.RisingFactorial"), [`FallingFactorial`](#sympy.functions.combinatorial.factorials.FallingFactorial
    "sympy.functions.combinatorial.factorials.FallingFactorial")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The subfactorial counts the derangements of \(n\) items and is defined for
    non-negative integers as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}!n = \begin{cases} 1 & n = 0 \\ 0 & n = 1 \\ (n-1)(!(n-1) + !(n-2))
    & n > 1 \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: It can also be written as `int(round(n!/exp(1)))` but the recursive definition
    with caching is implemented for this function.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting analytic expression is the following [[R228]](#r228)
  prefs: []
  type: TYPE_NORMAL
- en: \[!x = \Gamma(x + 1, -1)/e\]
  prefs: []
  type: TYPE_NORMAL
- en: which is valid for non-negative integers \(x\). The above formula is not very
    useful in case of non-integers. \(\Gamma(x + 1, -1)\) is single-valued only for
    integral arguments \(x\), elsewhere on the positive real axis it has an infinite
    number of branches none of which are real.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorial`](#sympy.functions.combinatorial.factorials.factorial "sympy.functions.combinatorial.factorials.factorial"),
    [`uppergamma`](special.html#sympy.functions.special.gamma_functions.uppergamma
    "sympy.functions.special.gamma_functions.uppergamma"), [`sympy.utilities.iterables.generate_derangements`](../utilities/iterables.html#sympy.utilities.iterables.generate_derangements
    "sympy.utilities.iterables.generate_derangements")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R227](#id25)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Subfactorial](https://en.wikipedia.org/wiki/Subfactorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R228] ([1](#id24),[2](#id26))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/Subfactorial.html](https://mathworld.wolfram.com/Subfactorial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The double factorial \(n!!\), not to be confused with \((n!)!\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The double factorial is defined for nonnegative integers and for odd negative
    integers as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}n!! = \begin{cases} 1 & n = 0 \\ n(n-2)(n-4) \cdots 1 & n\ \text{positive
    odd} \\ n(n-2)(n-4) \cdots 2 & n\ \text{positive even} \\ (n+2)!!/(n+2) & n\ \text{negative
    odd} \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorial`](#sympy.functions.combinatorial.factorials.factorial "sympy.functions.combinatorial.factorials.factorial"),
    [`RisingFactorial`](#sympy.functions.combinatorial.factorials.RisingFactorial
    "sympy.functions.combinatorial.factorials.RisingFactorial"), [`FallingFactorial`](#sympy.functions.combinatorial.factorials.FallingFactorial
    "sympy.functions.combinatorial.factorials.FallingFactorial")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R229](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Double_factorial](https://en.wikipedia.org/wiki/Double_factorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Falling factorial (related to rising factorial) is a double valued function
    arising in concrete mathematics, hypergeometric functions and series expansions.
    It is defined by
  prefs: []
  type: TYPE_NORMAL
- en: \[\texttt{ff(x, k)} = (x)_k = x \cdot (x-1) \cdots (x-k+1)\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(x\) can be arbitrary expression and \(k\) is an integer. For more information
    check “Concrete mathematics” by Graham, pp. 66 or [[R230]](#r230).
  prefs: []
  type: TYPE_NORMAL
- en: When \(x\) is a \(~.Poly\) instance of degree \(\ge 1\) with single variable,
    \((x)_k = x(y) \cdot x(y-1) \cdots x(y-k+1)\), where \(y\) is the variable of
    \(x\). This is as described in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting is complicated unless the relationship between the arguments is known,
    but falling factorial can be rewritten in terms of gamma, factorial and binomial
    and rising factorial.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorial`](#sympy.functions.combinatorial.factorials.factorial "sympy.functions.combinatorial.factorials.factorial"),
    [`factorial2`](#sympy.functions.combinatorial.factorials.factorial2 "sympy.functions.combinatorial.factorials.factorial2"),
    [`RisingFactorial`](#sympy.functions.combinatorial.factorials.RisingFactorial
    "sympy.functions.combinatorial.factorials.RisingFactorial")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R230] ([1](#id28),[2](#id29))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/FallingFactorial.html](https://mathworld.wolfram.com/FallingFactorial.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R231](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Paule, “Greatest Factorial Factorization and Symbolic Summation”, Journal
    of Symbolic Computation, vol. 20, pp. 235-268, 1995.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Fibonacci numbers / Fibonacci polynomials
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci numbers are the integer sequence defined by the initial terms
    \(F_0 = 0\), \(F_1 = 1\) and the two-term recurrence relation \(F_n = F_{n-1}
    + F_{n-2}\). This definition extended to arbitrary real and complex arguments
    using the formula
  prefs: []
  type: TYPE_NORMAL
- en: \[F_z = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt 5}\]
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci polynomials are defined by \(F_1(x) = 1\), \(F_2(x) = x\), and
    \(F_n(x) = x*F_{n-1}(x) + F_{n-2}(x)\) for \(n > 2\). For all positive integers
    \(n\), \(F_n(1) = F_n\).
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacci(n)` gives the \(n^{th}\) Fibonacci number, \(F_n\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fibonacci(n, x)` gives the \(n^{th}\) Fibonacci polynomial in \(x\), \(F_n(x)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R233](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R234](#id32)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/FibonacciNumber.html](https://mathworld.wolfram.com/FibonacciNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tribonacci numbers / Tribonacci polynomials
  prefs: []
  type: TYPE_NORMAL
- en: The Tribonacci numbers are the integer sequence defined by the initial terms
    \(T_0 = 0\), \(T_1 = 1\), \(T_2 = 1\) and the three-term recurrence relation \(T_n
    = T_{n-1} + T_{n-2} + T_{n-3}\).
  prefs: []
  type: TYPE_NORMAL
- en: The Tribonacci polynomials are defined by \(T_0(x) = 0\), \(T_1(x) = 1\), \(T_2(x)
    = x^2\), and \(T_n(x) = x^2 T_{n-1}(x) + x T_{n-2}(x) + T_{n-3}(x)\) for \(n >
    2\). For all positive integers \(n\), \(T_n(1) = T_n\).
  prefs: []
  type: TYPE_NORMAL
- en: '`tribonacci(n)` gives the \(n^{th}\) Tribonacci number, \(T_n\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tribonacci(n, x)` gives the \(n^{th}\) Tribonacci polynomial in \(x\), \(T_n(x)\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R235](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers](https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R236](#id34)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/TribonacciNumber.html](https://mathworld.wolfram.com/TribonacciNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R237](#id35)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A000073](https://oeis.org/A000073)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Harmonic numbers
  prefs: []
  type: TYPE_NORMAL
- en: The nth harmonic number is given by \(\operatorname{H}_{n} = 1 + \frac{1}{2}
    + \frac{1}{3} + \ldots + \frac{1}{n}\).
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{H}_{n,m} = \sum_{k=1}^{n} \frac{1}{k^m}\]
  prefs: []
  type: TYPE_NORMAL
- en: As \(n \rightarrow \infty\), \(\operatorname{H}_{n,m} \rightarrow \zeta(m)\),
    the Riemann zeta function.
  prefs: []
  type: TYPE_NORMAL
- en: '`harmonic(n)` gives the nth harmonic number, \(\operatorname{H}_n\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harmonic(n, m)` gives the nth generalized harmonic number of order \(m\),
    \(\operatorname{H}_{n,m}\), where `harmonic(n) == harmonic(n, 1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function can be extended to complex \(n\) and \(m\) where \(n\) is not
    a negative integer or \(m\) is a nonpositive integer as
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\operatorname{H}_{n,m} = \begin{cases} \zeta(m) - \zeta(m, n+1)
    & m \ne 1 \\ \psi(n+1) + \gamma & m = 1 \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can evaluate harmonic numbers for all integral and positive rational arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite harmonic numbers in terms of polygamma functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Integer offsets in the argument can be pulled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Some limits can be computed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'For \(m > 1\), \(H_{n,m}\) tends to \(\zeta(m)\) in the limit of infinite \(n\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R238](#id36)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Harmonic_number](https://en.wikipedia.org/wiki/Harmonic_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R239](#id37)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://functions.wolfram.com/GammaBetaErf/HarmonicNumber/](https://functions.wolfram.com/GammaBetaErf/HarmonicNumber/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R240](#id38)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/](https://functions.wolfram.com/GammaBetaErf/HarmonicNumber2/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Lucas numbers
  prefs: []
  type: TYPE_NORMAL
- en: Lucas numbers satisfy a recurrence relation similar to that of the Fibonacci
    sequence, in which each term is the sum of the preceding two. They are generated
    by choosing the initial values \(L_0 = 2\) and \(L_1 = 1\).
  prefs: []
  type: TYPE_NORMAL
- en: '`lucas(n)` gives the \(n^{th}\) Lucas number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R241](#id39)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lucas_number](https://en.wikipedia.org/wiki/Lucas_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R242](#id40)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/LucasNumber.html](https://mathworld.wolfram.com/LucasNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Genocchi numbers / Genocchi polynomials / Genocchi function
  prefs: []
  type: TYPE_NORMAL
- en: 'The Genocchi numbers are a sequence of integers \(G_n\) that satisfy the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{-2t}{1 + e^{-t}} = \sum_{n=0}^\infty \frac{G_n t^n}{n!}\]
  prefs: []
  type: TYPE_NORMAL
- en: They are related to the Bernoulli numbers by
  prefs: []
  type: TYPE_NORMAL
- en: \[G_n = 2 (1 - 2^n) B_n\]
  prefs: []
  type: TYPE_NORMAL
- en: and generalize like the Bernoulli numbers to the Genocchi polynomials and function
    as
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{G}(s, a) = 2 \left(\operatorname{B}(s, a) - 2^s \operatorname{B}\left(s,
    \frac{a+1}{2}\right)\right)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.12: `genocchi(1)` gives \(-1\) instead of \(1\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`partition`](#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci"),
    [`sympy.polys.appellseqs.genocchi_poly`](../polys/reference.html#sympy.polys.appellseqs.genocchi_poly
    "sympy.polys.appellseqs.genocchi_poly")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R243](#id41)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Genocchi_number](https://en.wikipedia.org/wiki/Genocchi_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R244](#id42)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/GenocchiNumber.html](https://mathworld.wolfram.com/GenocchiNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R245](#id43)]'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Luschny, “An introduction to the Bernoulli function”, [https://arxiv.org/abs/2009.06743](https://arxiv.org/abs/2009.06743)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Andre numbers / Andre function
  prefs: []
  type: TYPE_NORMAL
- en: The Andre number \(\mathcal{A}_n\) is Luschny’s name for half the number of
    *alternating permutations* on \(n\) elements, where a permutation is alternating
    if adjacent elements alternately compare “greater” and “smaller” going from left
    to right. For example, \(2 < 3 > 1 < 4\) is an alternating permutation.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence is A000111 in the OEIS, which assigns the names *up/down numbers*
    and *Euler zigzag numbers*. It satisfies a recurrence relation similar to that
    for the Catalan numbers, with \(\mathcal{A}_0 = 1\) and
  prefs: []
  type: TYPE_NORMAL
- en: \[2 \mathcal{A}_{n+1} = \sum_{k=0}^n \binom{n}{k} \mathcal{A}_k \mathcal{A}_{n-k}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The Bernoulli and Euler numbers are signed transformations of the odd- and
    even-indexed elements of this sequence respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{B}_{2k} = \frac{2k \mathcal{A}_{2k-1}}{(-4)^k - (-16)^k}\]\[\operatorname{E}_{2k}
    = (-1)^k \mathcal{A}_{2k}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the Bernoulli and Euler numbers, the Andre numbers are interpolated by
    the entire Andre function:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathcal{A}(s) = (-i)^{s+1} \operatorname{Li}_{-s}(i) + i^{s+1}
    \operatorname{Li}_{-s}(-i) = \\ \frac{2 \Gamma(s+1)}{(2\pi)^{s+1}} (\zeta(s+1,
    1/4) - \zeta(s+1, 3/4) \cos{\pi s})\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`sympy.polys.appellseqs.andre_poly`](../polys/reference.html#sympy.polys.appellseqs.andre_poly
    "sympy.polys.appellseqs.andre_poly")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R246](#id44)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Alternating_permutation](https://en.wikipedia.org/wiki/Alternating_permutation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R247](#id45)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/EulerZigzagNumber.html](https://mathworld.wolfram.com/EulerZigzagNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R248](#id46)]'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Luschny, “An introduction to the Bernoulli function”, [https://arxiv.org/abs/2009.06743](https://arxiv.org/abs/2009.06743)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Partition numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'The Partition numbers are a sequence of integers \(p_n\) that represent the
    number of distinct ways of representing \(n\) as a sum of natural numbers (with
    order irrelevant). The generating function for \(p_n\) is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{n=0}^\infty p_n x^n = \prod_{k=1}^\infty (1 - x^k)^{-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bell`](#sympy.functions.combinatorial.numbers.bell "sympy.functions.combinatorial.numbers.bell"),
    [`bernoulli`](#sympy.functions.combinatorial.numbers.bernoulli "sympy.functions.combinatorial.numbers.bernoulli"),
    [`catalan`](#sympy.functions.combinatorial.numbers.catalan "sympy.functions.combinatorial.numbers.catalan"),
    [`euler`](#sympy.functions.combinatorial.numbers.euler "sympy.functions.combinatorial.numbers.euler"),
    [`fibonacci`](#sympy.functions.combinatorial.numbers.fibonacci "sympy.functions.combinatorial.numbers.fibonacci"),
    [`harmonic`](#sympy.functions.combinatorial.numbers.harmonic "sympy.functions.combinatorial.numbers.harmonic"),
    [`lucas`](#sympy.functions.combinatorial.numbers.lucas "sympy.functions.combinatorial.numbers.lucas"),
    [`genocchi`](#sympy.functions.combinatorial.numbers.genocchi "sympy.functions.combinatorial.numbers.genocchi"),
    [`tribonacci`](#sympy.functions.combinatorial.numbers.tribonacci "sympy.functions.combinatorial.numbers.tribonacci")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R249](#id47)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Partition_(number_theory%29](https://en.wikipedia.org/wiki/Partition_(number_theory%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R250](#id48)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Pentagonal_number_theorem](https://en.wikipedia.org/wiki/Pentagonal_number_theorem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the divisor function \(\sigma_k(n)\) for positive integer n
  prefs: []
  type: TYPE_NORMAL
- en: '`divisor_sigma(n, k)` is equal to `sum([x**k for x in divisors(n)])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[\sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots + p_i^{m_ik}).\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.divisor_count`](../ntheory.html#sympy.ntheory.factor_.divisor_count
    "sympy.ntheory.factor_.divisor_count"), [`totient`](#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient"), [`sympy.ntheory.factor_.divisors`](../ntheory.html#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`sympy.ntheory.factor_.factorint`](../ntheory.html#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R251](#id49)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Divisor_function](https://en.wikipedia.org/wiki/Divisor_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the unitary divisor function \(\sigma_k^*(n)\) for positive integer
    n
  prefs: []
  type: TYPE_NORMAL
- en: '`udivisor_sigma(n, k)` is equal to `sum([x**k for x in udivisors(n)])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[\sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : power of divisors in the sum'
  prefs: []
  type: TYPE_NORMAL
- en: 'for k = 0, 1: `udivisor_sigma(n, 0)` is equal to `udivisor_count(n)` `udivisor_sigma(n,
    1)` is equal to `sum(udivisors(n))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for k is 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.divisor_count`](../ntheory.html#sympy.ntheory.factor_.divisor_count
    "sympy.ntheory.factor_.divisor_count"), [`totient`](#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient"), [`sympy.ntheory.factor_.divisors`](../ntheory.html#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`sympy.ntheory.factor_.udivisors`](../ntheory.html#sympy.ntheory.factor_.udivisors
    "sympy.ntheory.factor_.udivisors"), [`sympy.ntheory.factor_.udivisor_count`](../ntheory.html#sympy.ntheory.factor_.udivisor_count
    "sympy.ntheory.factor_.udivisor_count"), [`divisor_sigma`](#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma"), [`sympy.ntheory.factor_.factorint`](../ntheory.html#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R252](#id50)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Legendre symbol \((a / p)\).
  prefs: []
  type: TYPE_NORMAL
- en: For an integer `a` and an odd prime `p`, the Legendre symbol is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\genfrac(){}{}{a}{p} = \begin{cases} 0 & \text{if } p \text{
    divides } a\\ 1 & \text{if } a \text{ is a quadratic residue modulo } p\\ -1 &
    \text{if } a \text{ is a quadratic nonresidue modulo } p \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.residue_ntheory.is_quad_residue`](../ntheory.html#sympy.ntheory.residue_ntheory.is_quad_residue
    "sympy.ntheory.residue_ntheory.is_quad_residue"), [`jacobi_symbol`](#sympy.functions.combinatorial.numbers.jacobi_symbol
    "sympy.functions.combinatorial.numbers.jacobi_symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Jacobi symbol \((m / n)\).
  prefs: []
  type: TYPE_NORMAL
- en: 'For any integer `m` and any positive odd integer `n` the Jacobi symbol is defined
    as the product of the Legendre symbols corresponding to the prime factors of `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\genfrac(){}{}{m}{n} = \genfrac(){}{}{m}{p^{1}}^{\alpha_1} \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
    ... \genfrac(){}{}{m}{p^{k}}^{\alpha_k} \text{ where } n = p_1^{\alpha_1} p_2^{\alpha_2}
    ... p_k^{\alpha_k}\]
  prefs: []
  type: TYPE_NORMAL
- en: Like the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n} = -1\)
    then `m` is a quadratic nonresidue modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: But, unlike the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n}
    = 1\) then `m` may or may not be a quadratic residue modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationship between the `jacobi_symbol` and `legendre_symbol` can be demonstrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.residue_ntheory.is_quad_residue`](../ntheory.html#sympy.ntheory.residue_ntheory.is_quad_residue
    "sympy.ntheory.residue_ntheory.is_quad_residue"), [`legendre_symbol`](#sympy.functions.combinatorial.numbers.legendre_symbol
    "sympy.functions.combinatorial.numbers.legendre_symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Kronecker symbol \((a / n)\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`jacobi_symbol`](#sympy.functions.combinatorial.numbers.jacobi_symbol "sympy.functions.combinatorial.numbers.jacobi_symbol"),
    [`legendre_symbol`](#sympy.functions.combinatorial.numbers.legendre_symbol "sympy.functions.combinatorial.numbers.legendre_symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R253](#id51)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Kronecker_symbol](https://en.wikipedia.org/wiki/Kronecker_symbol)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Mobius function maps natural number to {-1, 0, 1}
  prefs: []
  type: TYPE_NORMAL
- en: 'It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \(1\) if \(n = 1\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(0\) if \(n\) has a squared prime factor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \((-1)^k\) if \(n\) is a square-free positive integer with \(k\) number of prime
    factors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an important multiplicative function in number theory and combinatorics.
    It has applications in mathematical series, algebraic number theory and also physics
    (Fermion operator has very concrete realization with Mobius Function model).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Even in the case of a symbol, if it clearly contains a squared prime factor,
    it will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R254](#id52)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/M%C3%B6bius_function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R255](#id53)]'
  prefs: []
  type: TYPE_NORMAL
- en: Thomas Koshy “Elementary Number Theory with Applications”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R256](#id54)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A008683](https://oeis.org/A008683)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the number of distinct prime factors for a positive integer n.
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: 'then `primenu(n)` or \(\nu(n)\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\nu(n) = k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.factorint`](../ntheory.html#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R257](#id55)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R258](#id56)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A001221](https://oeis.org/A001221)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the number of prime factors counting multiplicities for a positive
    integer n.
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: 'then `primeomega(n)` or \(\Omega(n)\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\Omega(n) = \sum_{i=1}^k m_i.\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.factorint`](../ntheory.html#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R259](#id57)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R260](#id58)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A001222](https://oeis.org/A001222)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the Euler totient function phi(n)
  prefs: []
  type: TYPE_NORMAL
- en: '`totient(n)` or \(\phi(n)\) is the number of positive integers \(\leq\) n that
    are relatively prime to n.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.divisor_count`](../ntheory.html#sympy.ntheory.factor_.divisor_count
    "sympy.ntheory.factor_.divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R261](#id59)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler%27s_totient_function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R262](#id60)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/TotientFunction.html](https://mathworld.wolfram.com/TotientFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R263](#id61)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A000010](https://oeis.org/A000010)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the Carmichael reduced totient function lambda(n)
  prefs: []
  type: TYPE_NORMAL
- en: '`reduced_totient(n)` or \(\lambda(n)\) is the smallest m > 0 such that \(k^m
    \equiv 1 \mod n\) for all k relatively prime to n.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`totient`](#sympy.functions.combinatorial.numbers.totient "sympy.functions.combinatorial.numbers.totient")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R264](#id62)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Carmichael_function](https://en.wikipedia.org/wiki/Carmichael_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R265](#id63)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/CarmichaelFunction.html](https://mathworld.wolfram.com/CarmichaelFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R266](#id64)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A002322](https://oeis.org/A002322)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Represents the prime counting function pi(n) = the number of prime numbers less
    than or equal to n.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: So there are 9 primes less than or equal to 25\. Is 25 prime?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not. So the first prime less than 25 must be the 9th prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.isprime`](../ntheory.html#sympy.ntheory.primetest.isprime
    "sympy.ntheory.primetest.isprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Test if n is prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.generate.primerange`](../ntheory.html#sympy.ntheory.generate.primerange
    "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.generate.prime`](../ntheory.html#sympy.ntheory.generate.prime
    "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R267](#id65)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A000720](https://oeis.org/A000720)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Rising factorial (also called Pochhammer symbol [[R268]](#r268)) is a double
    valued function arising in concrete mathematics, hypergeometric functions and
    series expansions. It is defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\texttt{rf(y, k)} = (x)^k = x \cdot (x+1) \cdots (x+k-1)\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(x\) can be arbitrary expression and \(k\) is an integer. For more information
    check “Concrete mathematics” by Graham, pp. 66 or visit [https://mathworld.wolfram.com/RisingFactorial.html](https://mathworld.wolfram.com/RisingFactorial.html)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: When \(x\) is a \(~.Poly\) instance of degree \(\ge 1\) with a single variable,
    \((x)^k = x(y) \cdot x(y+1) \cdots x(y+k-1)\), where \(y\) is the variable of
    \(x\). This is as described in [[R269]](#r269).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting is complicated unless the relationship between the arguments is known,
    but rising factorial can be rewritten in terms of gamma, factorial, binomial,
    and falling factorial.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorial`](#sympy.functions.combinatorial.factorials.factorial "sympy.functions.combinatorial.factorials.factorial"),
    [`factorial2`](#sympy.functions.combinatorial.factorials.factorial2 "sympy.functions.combinatorial.factorials.factorial2"),
    [`FallingFactorial`](#sympy.functions.combinatorial.factorials.FallingFactorial
    "sympy.functions.combinatorial.factorials.FallingFactorial")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R268] ([1](#id66),[2](#id68))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Pochhammer_symbol](https://en.wikipedia.org/wiki/Pochhammer_symbol)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R269] ([1](#id67),[2](#id69))'
  prefs: []
  type: TYPE_NORMAL
- en: Peter Paule, “Greatest Factorial Factorization and Symbolic Summation”, Journal
    of Symbolic Computation, vol. 20, pp. 235-268, 1995.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Return Stirling number \(S(n, k)\) of the first or second (default) kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sum of all Stirling numbers of the second kind for \(k = 1\) through \(n\)
    is `bell(n)`. The recurrence relationship for these numbers is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[{0 \brace 0} = 1; {n \brace 0} = {0 \brace k} = 0;\]\[{{n+1} \brace k} = j
    {n \brace k} + {n \brace {k-1}}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'where \(j\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: \(n\) for Stirling numbers of the first kind, \(-n\) for signed Stirling numbers
    of the first kind, \(k\) for Stirling numbers of the second kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first kind of Stirling number counts the number of permutations of `n`
    distinct items that have `k` cycles; the second kind counts the ways in which
    `n` distinct items can be partitioned into `k` parts. If `d` is given, the “reduced
    Stirling number of the second kind” is returned: \(S^{d}(n, k) = S(n - d + 1,
    k - d + 1)\) with \(n \ge k \ge d\). (This counts the ways to partition \(n\)
    consecutive integers into \(k\) groups with no pairwise difference less than \(d\).
    See example below.)'
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the signed Stirling numbers of the first kind, use keyword `signed=True`.
    Using this keyword automatically sets `kind` to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'First kind (unsigned by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'First kind (signed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Second kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Reduced second kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.multiset_partitions`](../utilities/iterables.html#sympy.utilities.iterables.multiset_partitions
    "sympy.utilities.iterables.multiset_partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R270](#id70)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_first_kind)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R271](#id71)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind](https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind)'
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three functions are available. Each of them attempts to efficiently compute
    a given combinatorial quantity for a given set or multiset which can be entered
    as an integer, sequence or multiset (dictionary with elements as keys and multiplicities
    as values). The `k` parameter indicates the number of elements to pick (or the
    number of partitions to make). When `k` is None, the sum of the enumeration for
    all `k` (from 0 through the number of items represented by `n`) is returned. A
    `replacement` parameter is recognized for combinations and permutations; this
    indicates that any item may appear with multiplicity as high as the number of
    items in the original set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of combinations of `n` items taken `k` at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible values for `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: integer - set of length `n`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sequence - converted to a multiset internally
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'multiset - {element: multiplicity}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `k` is None then the total of all combinations of length 0 through the number
    of items represented in `n` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If `replacement` is True then a given item can appear more than once in the
    `k` items. (For example, for ‘ab’ sets of 2 would include ‘aa’, ‘ab’, and ‘bb’.)
    The multiplicity of elements in `n` is ignored when `replacement` is True but
    the total number of elements is considered since no element can appear more times
    than the number of elements in `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'When `replacement` is True, each item can have multiplicity equal to the length
    represented by `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are `k` items with multiplicities `m_1, m_2, ..., m_k` then the total
    of all combinations of length 0 through `k` is the product, `(m_1 + 1)*(m_2 +
    1)*...*(m_k + 1)`. When the multiplicity of each item is 1 (i.e., k unique items)
    then there are 2**k combinations. For example, if there are 4 unique items, the
    total number of combinations is 16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.multiset_combinations`](../utilities/iterables.html#sympy.utilities.iterables.multiset_combinations
    "sympy.utilities.iterables.multiset_combinations")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R272](#id72)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Combination](https://en.wikipedia.org/wiki/Combination)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R273](#id73)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tinyurl.com/cep849r](https://tinyurl.com/cep849r)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of permutations of `n` items taken `k` at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible values for `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: integer - set of length `n`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sequence - converted to a multiset internally
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'multiset - {element: multiplicity}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `k` is None then the total of all permutations of length 0 through the number
    of items represented by `n` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If `replacement` is True then a given item can appear more than once in the
    `k` items. (For example, for ‘ab’ permutations of 2 would include ‘aa’, ‘ab’,
    ‘ba’ and ‘bb’.) The multiplicity of elements in `n` is ignored when `replacement`
    is True but the total number of elements is considered since no element can appear
    more times than the number of elements in `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'When `replacement` is True, each item can have multiplicity equal to the length
    represented by `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.multiset_permutations`](../utilities/iterables.html#sympy.utilities.iterables.multiset_permutations
    "sympy.utilities.iterables.multiset_permutations")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R274](#id74)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Permutation](https://en.wikipedia.org/wiki/Permutation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of `k`-sized partitions of `n` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible values for `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: integer - `n` identical items
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sequence - converted to a multiset internally
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'multiset - {element: multiplicity}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note: the convention for `nT` is different than that of `nC` and `nP` in that
    here an integer indicates `n` *identical* items instead of a set of length `n`;
    this is in keeping with the `partitions` function which treats its integer-`n`
    input like a list of `n` 1s. One can use `range(n)` for `n` to indicate `n` distinct
    items.'
  prefs: []
  type: TYPE_NORMAL
- en: If `k` is None then the total number of ways to partition the elements represented
    in `n` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Partitions of the given multiset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Partitions when all items are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'When all items are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Partitions of an integer expressed as a sum of positive integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.partitions`](../utilities/iterables.html#sympy.utilities.iterables.partitions
    "sympy.utilities.iterables.partitions"), [`sympy.utilities.iterables.multiset_partitions`](../utilities/iterables.html#sympy.utilities.iterables.multiset_partitions
    "sympy.utilities.iterables.multiset_partitions"), [`sympy.functions.combinatorial.numbers.partition`](#sympy.functions.combinatorial.numbers.partition
    "sympy.functions.combinatorial.numbers.partition")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R275](#id75)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20210507012732/https://teaching.csse.uwa.edu.au/units/CITS7209/partition.pdf](https://web.archive.org/web/20210507012732/https://teaching.csse.uwa.edu.au/units/CITS7209/partition.pdf)'
  prefs: []
  type: TYPE_NORMAL
