# 代码生成

> 原始文档：[https://docs.sympy.org/latest/modules/codegen.html](https://docs.sympy.org/latest/modules/codegen.html)

SymPy 的多个子模块允许直接从 SymPy 表达式生成可直接编译和执行的代码，支持多种不同的编程语言。此外，还有一些函数生成 Python 可导入的对象，能够高效地评估 SymPy 表达式。

我们将从简要介绍构成 SymPy 代码生成功能的组件开始。

## 介绍

有四个主要的抽象层次：

```py
expression
   |
code printers
   |
code generators
   |
autowrap 
```

[`sympy.utilities.autowrap`](https://docs.sympy.org/latest/modules/utilities/autowrap.html#module-sympy.utilities.autowrap "sympy.utilities.autowrap") 使用了 codegen，而 codegen 又使用了代码打印机。[`sympy.utilities.autowrap`](https://docs.sympy.org/latest/modules/utilities/autowrap.html#module-sympy.utilities.autowrap "sympy.utilities.autowrap") 实现了一步到位：在同一个 Python 进程中，它让您能够从 SymPy 表达式转换为数值函数。 Codegen 是实际的代码生成，即编译和以后使用，或者包含在某个更大的项目中。

代码打印机将 SymPy 对象翻译成实际的代码，如 `abs(x) -> fabs(x)`（用于 C）。

在许多情况下，代码打印机并不输出最优的代码。例如，在 C 中，幂运算 `x**2` 输出为 `pow(x, 2)` 而不是 `x*x`。其他优化（如数学简化）应该在代码打印机之前进行。

目前，在此链中自动应用 [`sympy.simplify.cse_main.cse()`](https://docs.sympy.org/latest/modules/simplify/simplify.html#sympy.simplify.cse_main.cse "sympy.simplify.cse_main.cse") 尚未发生。理想情况下，它应该在代码生成级别或其上某处发生。

我们将逐级介绍以下内容。

以下三行将用于设置每个示例：

```py
>>> from sympy import *
>>> init_printing(use_unicode=True)
>>> from sympy.abc import a, e, k, n, r, t, x, y, z, T, Z
>>> from sympy.abc import beta, omega, tau
>>> f, g = symbols('f, g', cls=Function) 
```

## 代码打印机（sympy.printing）

这里是代码生成的核心；SymPy 的翻译实际上更像是 Python 的轻量级代码生成版本，而 Python ([`sympy.printing.pycode.pycode()`](https://docs.sympy.org/latest/modules/printing.html#sympy.printing.pycode.pycode)) 和 [`sympy.printing.lambdarepr.lambdarepr()`](https://docs.sympy.org/latest/modules/printing.html#sympy.printing.lambdarepr.lambdarepr)，支持许多库（如 NumPy），以及 Aesara ([`sympy.printing.aesaracode.aesara_function()`](https://docs.sympy.org/latest/modules/printing.html#sympy.printing.aesaracode.aesara_function "sympy.printing.aesaracode.aesara_function"))。代码打印机是 SymPy 中其他打印机（如字符串打印机、美观打印机等）的特殊情况。

一个重要的区别是，代码打印机必须处理赋值（使用 [`sympy.codegen.ast.Assignment`](https://docs.sympy.org/latest/modules/codegen.html#sympy.codegen.ast.Assignment "sympy.codegen.ast.Assignment") 对象）。这作为代码打印机及其 `codegen` 模块的构建块。以下是在 C 代码中使用 `Assignment` 的示例：

```py
>>> from sympy.codegen.ast import Assignment
>>> print(ccode(Assignment(x, y + 1)))
x = y + 1; 
```

这里是另一个打印 SymPy 表达式 C 版本的简单示例：

```py
>>> expr = (Rational(-1, 2) * Z * k * (e**2) / r)
>>> expr
 2
-Z⋅e ⋅k
────────
 2⋅r
>>> ccode(expr)
-1.0/2.0*Z*pow(e, 2)*k/r
>>> from sympy.codegen.ast import real, float80
>>> ccode(expr, assign_to="E", type_aliases={real: float80})
E = -1.0L/2.0L*Z*powl(e, 2)*k/r; 
```

要生成使用例如C99标准提供的一些数学函数的代码，我们需要从[`sympy.codegen.cfunctions`](https://example.org/module-sympy.codegen.cfunctions)导入函数：

```py
>>> from sympy.codegen.cfunctions import expm1
>>> ccode(expm1(x), standard='C99')
expm1(x) 
```

`Piecewise`表达式将转换为条件语句。如果提供了`assign_to`变量，则创建一个if语句，否则使用三元运算符。请注意，如果`Piecewise`缺少由`(expr, True)`表示的默认项，则会引发错误。这是为了防止生成一个可能不会评估为任何内容的表达式。一个`Piecewise`的用例：

```py
>>> expr = Piecewise((x + 1, x > 0), (x, True))
>>> print(fcode(expr, tau))
 if (x > 0) then
 tau = x + 1
 else
 tau = x
 end if 
```

各种打印机通常也很好地支持`Indexed`对象。使用`contract=True`这些表达式将被转换为循环，而`contract=False`则只会打印应该循环的赋值表达式：

```py
>>> len_y = 5
>>> mat_1 = IndexedBase('mat_1', shape=(len_y,))
>>> mat_2 = IndexedBase('mat_2', shape=(len_y,))
>>> Dy = IndexedBase('Dy', shape=(len_y-1,))
>>> i = Idx('i', len_y-1)
>>> eq = Eq(Dy[i], (mat_1[i+1] - mat_1[i]) / (mat_2[i+1] - mat_2[i]))
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))
Dy[i] = (mat_1[i + 1] - mat_1[i])/(mat_2[i + 1] - mat_2[i]);
>>> Res = IndexedBase('Res', shape=(len_y,))
>>> j = Idx('j', len_y)
>>> eq = Eq(Res[j], mat_1[j]*mat_2[j])
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=True))
for (var j=0; j<5; j++){
 Res[j] = 0;
}
for (var j=0; j<5; j++){
 for (var j=0; j<5; j++){
 Res[j] = Res[j] + mat_1[j]*mat_2[j];
 }
}
>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))
Res[j] = mat_1[j]*mat_2[j]; 
```

可以通过将“type”：“function”字典传递给`user_functions`关键字来为某些类型定义自定义打印。或者，字典值可以是元组列表，即`[(argument_test, cfunction_string)]`。这可以用于调用自定义Octave函数：

```py
>>> custom_functions = {
...   "f": "existing_octave_fcn",
...   "g": [(lambda x: x.is_Matrix, "my_mat_fcn"),
...         (lambda x: not x.is_Matrix, "my_fcn")]
... }
>>> mat = Matrix([[1, x]])
>>> octave_code(f(x) + g(x) + g(mat), user_functions=custom_functions)
existing_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x]) 
```

Mathematica代码打印机示例：

```py
>>> x_ = Function('x')
>>> expr = x_(n*T) * sin((t - n*T) / T)
>>> expr = expr / ((-T*n + t) / T)
>>> expr
 ⎛-T⋅n + t⎞
T⋅x(T⋅n)⋅sin⎜────────⎟
 ⎝   T    ⎠
──────────────────────
 -T⋅n + t

>>> expr = summation(expr, (n, -1, 1))
>>> mathematica_code(expr)
T*(x[-T]*Sin[(T + t)/T]/(T + t) + x[T]*Sin[(-T + t)/T]/(-T + t) + x[0]*Sin[t/T]/t) 
```

我们可以通过我们支持的不同语言中的常见表达式并看看它是如何工作的：

```py
>>> k, g1, g2, r, I, S = symbols("k, gamma_1, gamma_2, r, I, S")
>>> expr = k * g1 * g2 / (r**3)
>>> expr = expr * 2 * I * S * (3 * (cos(beta))**2 - 1) / 2
>>> expr
 ⎛     2       ⎞
I⋅S⋅γ₁⋅γ₂⋅k⋅⎝3⋅cos (β) - 1⎠
───────────────────────────
 3
 r
>>> print(jscode(expr, assign_to="H_is"))
H_is = I*S*gamma_1*gamma_2*k*(3*Math.pow(Math.cos(beta), 2) - 1)/Math.pow(r, 3);
>>> print(ccode(expr, assign_to="H_is", standard='C89'))
H_is = I*S*gamma_1*gamma_2*k*(3*pow(cos(beta), 2) - 1)/pow(r, 3);
>>> print(fcode(expr, assign_to="H_is"))
 H_is = I*S*gamma_1*gamma_2*k*(3*cos(beta)**2 - 1)/r**3
>>> print(julia_code(expr, assign_to="H_is"))
H_is = I .* S .* gamma_1 .* gamma_2 .* k .* (3 * cos(beta) .^ 2 - 1) ./ r .^ 3
>>> print(octave_code(expr, assign_to="H_is"))
H_is = I.*S.*gamma_1.*gamma_2.*k.*(3*cos(beta).^2 - 1)./r.^3;
>>> print(rust_code(expr, assign_to="H_is"))
H_is = I*S*gamma_1*gamma_2*k*(3*beta.cos().powi(2) - 1)/r.powi(3);
>>> print(mathematica_code(expr))
I*S*gamma_1*gamma_2*k*(3*Cos[beta]^2 - 1)/r^3 
```

## Codegen（sympy.utilities.codegen）

此模块处理从SymPy表达式创建可编译代码。这比autowrap更低级，因为它实际上不尝试编译代码，但比打印机更高级，因为它生成可编译的文件（包括头文件），而不仅仅是代码片段。

在这里友好的函数是`codegen`和`make_routine`。`codegen`接受`(variable, expression)`对的列表和语言（支持C、F95和Octave/Matlab）。它返回一个代码文件和一个头文件的字符串，对应于相关语言。这些变量被创建为返回表达式值的函数输出。

注意

可调用的`codegen`不会自动存在于sympy命名空间中，要使用它，必须首先从`sympy.utilities.codegen`导入`codegen`。

例如：

```py
>>> from sympy.utilities.codegen import codegen
>>> length, breadth, height = symbols('length, breadth, height')
>>> [(c_name, c_code), (h_name, c_header)] = \
... codegen(('volume', length*breadth*height), "C99", "test",
...         header=False, empty=False)
>>> print(c_name)
test.c
>>> print(c_code)
#include "test.h"
#include <math.h>
double volume(double breadth, double height, double length) {
 double volume_result;
 volume_result = breadth*height*length;
 return volume_result;
}
>>> print(h_name)
test.h
>>> print(c_header)
#ifndef PROJECT__TEST__H
#define PROJECT__TEST__H
double volume(double breadth, double height, double length);
#endif 
```

各种标志可以让您修改`codegen`中的事物。使用`project`可以变化项目名称以用于预处理指令。在`global_vars`参数中列出的全局变量将不会显示为函数参数。

`language`是一个不区分大小写的字符串，表示源代码语言。目前支持`C`、`F95`和`Octave`。`Octave`生成与Octave和Matlab兼容的代码。

当`header`为True时，在每个源文件的顶部会写入一个头部。当`empty`为True时，使用空行来结构化代码。使用`argument_sequence`可以定义首选顺序的例程参数序列。

`prefix`定义了包含源代码的文件名称的前缀。如果省略，则使用第一个`name_expr`元组的名称。

当`to_files`为True时，代码将被写入一个或多个带有给定前缀的文件。

这里是一个示例：

```py
>>> [(f_name, f_code), header] = codegen(("volume", length*breadth*height),
...     "F95", header=False, empty=False, argument_sequence=(breadth, length),
...     global_vars=(height,))
>>> print(f_code)
REAL*8 function volume(breadth, length)
implicit none
REAL*8, intent(in) :: breadth
REAL*8, intent(in) :: length
volume = breadth*height*length
end function 
```

方法`make_routine`创建一个`Routine`对象，表示一组表达式的评估例程。这仅适用于CodeGen对象内部使用，作为从SymPy表达式到生成代码的中间表示。不建议自己创建`Routine`对象。您应该使用`make_routine`方法。`make_routine`反过来调用CodeGen对象的`routine`方法，具体取决于所选语言。这样创建表示赋值等的内部对象，并使用它们创建`Routine`类。

各种codegen对象，如`Routine`和`Variable`并非SymPy对象（它们不从Basic子类化）。

例如：

```py
>>> from sympy.utilities.codegen import make_routine
>>> from sympy.physics.hydrogen import R_nl
>>> expr = R_nl(3, y, x, 6)
>>> routine = make_routine('my_routine', expr)
>>> [arg.result_var for arg in routine.results]   
[result₅₁₄₂₃₄₁₆₈₁₃₉₇₇₁₉₄₂₈]
>>> [arg.expr for arg in routine.results]
⎡                __________                                          ⎤
⎢          y    ╱ (2 - y)!   -2⋅x                                    ⎥
⎢4⋅√6⋅(4⋅x) ⋅  ╱  ──────── ⋅ℯ    ⋅assoc_laguerre(2 - y, 2⋅y + 1, 4⋅x)⎥
⎢            ╲╱   (y + 3)!                                           ⎥
⎢────────────────────────────────────────────────────────────────────⎥
⎣                                 3                                  ⎦
>>> [arg.name for arg in routine.arguments]
[x, y] 
```

另一个更复杂的示例，混合指定和自动分配的名称。还有矩阵输出：

```py
>>> routine = make_routine('fcn', [x*y, Eq(a, 1), Eq(r, x + r), Matrix([[x, 2]])])
>>> [arg.result_var for arg in routine.results]   
[result_5397460570204848505]
>>> [arg.expr for arg in routine.results]
[x⋅y]
>>> [arg.name for arg in routine.arguments]   
[x, y, a, r, out_8598435338387848786] 
```

我们可以更仔细地检查各种参数：

```py
>>> from sympy.utilities.codegen import (InputArgument, OutputArgument,
...                                      InOutArgument)
>>> [a.name for a in routine.arguments if isinstance(a, InputArgument)]
[x, y]

>>> [a.name for a in routine.arguments if isinstance(a, OutputArgument)]  
[a, out_8598435338387848786]
>>> [a.expr for a in routine.arguments if isinstance(a, OutputArgument)]
[1, [x  2]]

>>> [a.name for a in routine.arguments if isinstance(a, InOutArgument)]
[r]
>>> [a.expr for a in routine.arguments if isinstance(a, InOutArgument)]
[r + x] 
```

完整的API参考可以在[这里](utilities/codegen.html#codegen-api)查看。

## Autowrap

Autowrap自动生成代码，将其写入磁盘，编译它并导入到当前会话中。本模块的主要功能是`autowrap`，`binary_function`和`ufuncify`。

它还会自动将包含`Indexed`对象的表达式转换为求和。类IndexedBase、Indexed和Idx表示矩阵元素M[i, j]。有关更多信息，请参见[Tensor](tensor/index.html#tensor-module)。

`autowrap`使用f2py或Cython创建包装器并创建数值函数。

注意

可调用的`autowrap`不会自动放置在sympy命名空间中，要使用它，您必须先从`sympy.utilities.autowrap`导入`autowrap`。

`autowrap`返回的可调用函数是一个二进制的Python函数，而不是SymPy对象。例如：

```py
>>> from sympy.utilities.autowrap import autowrap
>>> expr = ((x - y + z)**(13)).expand()
>>> binary_func = autowrap(expr)    
>>> binary_func(1, 4, 2)    
-1.0 
```

autowrap()提供的各种标志有助于修改方法提供的服务。参数`tempdir`告诉autowrap在特定目录中编译代码，并在完成后保留文件。例如：

```py
>>> from sympy.utilities.autowrap import autowrap
>>> from sympy.physics.qho_1d import psi_n
>>> x_ = IndexedBase('x')
>>> y_ = IndexedBase('y')
>>> m = symbols('m', integer=True)
>>> i = Idx('i', m)
>>> qho = autowrap(Eq(y_[i], psi_n(0, x_[i], m, omega)), tempdir='/tmp') 
```

检查指定目录中的Fortran源代码揭示了这一点：

```py
subroutine autofunc(m, omega, x, y)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(in), dimension(1:m) :: x
REAL*8, intent(out), dimension(1:m) :: y
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine 
```

使用参数`args`与其一起改变参数序列：

```py
>>> eq = Eq(y_[i], psi_n(0, x_[i], m, omega))
>>> qho = autowrap(eq, tempdir='/tmp', args=[y, x, m, omega]) 
```

产生：

```py
subroutine autofunc(y, x, m, omega)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(out), dimension(1:m) :: y
REAL*8, intent(in), dimension(1:m) :: x
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine 
```

参数`verbose`是布尔值，可选，如果为True，则autowrap不会使命令行后端静音。这对调试非常有帮助。

参数`language`和`backend`用于将默认值从`Fortran`和`f2py`更改为`C`和`Cython`。参数helpers用于定义主表达式所需的辅助表达式。如果主表达式需要调用特殊函数，则应将其放入helpers可迭代对象中。Autowrap将确保编译的主表达式可以链接到帮助程序例程。项目应该是带有（<function_name>，<sympy_expression>，<arguments>）的元组。必须为辅助例程提供参数序列。

在 `autowrap` 层面可用的另一种方法是 `binary_function`。它返回一个 sympy 函数。其优势在于，与 SymPy 速度相比，我们可以得到非常快速的函数。这是因为我们将使用带有 SymPy 属性和方法的编译函数。一个例子：

```py
>>> from sympy.utilities.autowrap import binary_function
>>> from sympy.physics.hydrogen import R_nl
>>> psi_nl = R_nl(1, 0, a, r)
>>> f = binary_function('f', psi_nl)    
>>> f(a, r).evalf(3, subs={a: 1, r: 2})  
0.766 
```

虽然 NumPy 操作对于矢量化数据非常高效，但在连锁操作时有时会产生不必要的成本。考虑以下操作

```py
>>> x = get_numpy_array(...) 
>>> y = sin(x) / x 
```

`sin` 和 `/` 运算符调用执行紧密循环的 `C` 例程。得到的计算看起来像这样

```py
for(int  i  =  0;  i  <  n;  i++)
{
  temp[i]  =  sin(x[i]);
}
for(int  i  =  i;  i  <  n;  i++)
{
  y[i]  =  temp[i]  /  x[i];
} 
```

这略微不够优化，因为

1.  我们分配了额外的 `temp` 数组

1.  当一次就足够时，我们对 `x` 内存进行了两次遍历

更好的解决方案将两个逐元素操作融合为单个循环

```py
for(int  i  =  i;  i  <  n;  i++)
{
  y[i]  =  sin(x[i])  /  x[i];
} 
```

像 NumPy 这样的静态编译项目无法利用这些优化。幸运的是，SymPy 能够生成高效的低级别 C 或 Fortran 代码。然后，它可以依赖于像 `Cython` 或 `f2py` 这样的项目来编译并重新连接该代码回到 Python。幸运的是，这个过程是自动化的，希望利用这些代码生成的 SymPy 用户应该调用 `ufuncify` 函数。

`ufuncify` 是 Aurowrap 模块的第三种可用方法。它基本上暗示了‘通用函数’，并遵循了 NumPy 设定的理念。与 autowrap 相比，ufuncify 的主要优点是允许数组作为参数，并且可以逐元素地进行操作。按照 NumPy 的数组广播规则逐元素进行的核心操作。查看 [此](https://numpy.org/doc/stable/reference/ufuncs.html) 了解更多信息。

```py
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x 
```

```py
>>> from sympy.utilities.autowrap import ufuncify
>>> f = ufuncify([x], expr) 
```

此函数 `f` 消耗并返回一个 NumPy 数组。通常情况下，`ufuncify` 的性能至少与 `lambdify` 相当。如果表达式复杂，则 `ufuncify` 通常明显优于 NumPy 支持的解决方案。Jensen 在这个主题上有一篇很好的 [博文](https://ojensen.wordpress.com/2010/08/10/fast-ufunc-ish-hydrogen-solutions/)。

让我们看一个进行一些数量分析的示例：

```py
>>> from sympy.physics.hydrogen import R_nl
>>> expr = R_nl(3, 1, x, 6)
>>> expr
 -2⋅x
8⋅x⋅(4 - 4⋅x)⋅ℯ
───────────────────
 3 
```

`lambdify` 函数将 SymPy 表达式转换为 Python 函数，利用各种数值库。默认情况下，`lambdify` 依赖于 `math` 标准库中的实现。自然地，原始的 Python 比 SymPy 更快。但它也支持 `mpmath` 和最显著的是 `numpy`。使用 NumPy 库使生成的函数能够访问由编译的 C 代码支持的强大的矢量化 ufuncs。

让我们比较速度：

```py
>>> from sympy.utilities.autowrap import ufuncify
>>> from sympy.utilities.lambdify import lambdify
>>> fn_numpy = lambdify(x, expr, 'numpy')   
>>> fn_fortran = ufuncify([x], expr, backend='f2py')    
>>> from numpy import linspace  
>>> xx = linspace(0, 1, 5)  
>>> fn_numpy(xx)    
[ 0\.          1.21306132  0.98101184  0.44626032  0\.        ]
>>> fn_fortran(xx)  
[ 0\.          1.21306132  0.98101184  0.44626032  0\.        ]
>>> import timeit
>>> timeit.timeit('fn_numpy(xx)', 'from __main__ import fn_numpy, xx', number=10000)    
0.18891601900395472
>>> timeit.timeit('fn_fortran(xx)', 'from __main__ import fn_fortran, xx', number=10000)    
0.004707066000264604 
```

与 `autowrap` 可用的选项基本相同。

SymPy 还有其他有效的数值计算工具可用。参见 [此](numeric-computation.html#numeric-computation) 页面进行比较。

## 重写表达式的类和函数（sympy.codegen.rewriting）

有助于重写表达式以进行优化代码生成的类和函数。某些语言（或其标准），如C99，提供了专门的数学函数以获得更好的性能和/或精度。

使用此模块中的`optimize`函数以及一系列规则（表示为`Optimization`实例），可以为此目的重写表达式：

```py
>>> from sympy import Symbol, exp, log
>>> from sympy.codegen.rewriting import optimize, optims_c99
>>> x = Symbol('x')
>>> optimize(3*exp(2*x) - 3, optims_c99)
3*expm1(2*x)
>>> optimize(exp(2*x) - 1 - exp(-33), optims_c99)
expm1(2*x) - exp(-33)
>>> optimize(log(3*x + 3), optims_c99)
log1p(x) + log(3)
>>> optimize(log(2*x + 3), optims_c99)
log(2*x + 3) 
```

上面导入的`optims_c99`是包含以下实例的元组（可以从`sympy.codegen.rewriting`导入）：

+   `expm1_opt`

+   `log1p_opt`

+   `exp2_opt`

+   `log2_opt`

+   `log2const_opt`

```py
class sympy.codegen.rewriting.FuncMinusOneOptim(func, func_m_1, opportunistic=True)
```

专门用于计算“f(x) - 1”的ReplaceOptim特化函数。

参数：

**函数：**

> 减一的函数。

**func_m_1：**

> 专门用于评估`func(x) - 1`的函数。

**机会主义**：布尔值

> 当为`True`时，只要剩余数字项的数量减少，则应用转换。当为`False`时，仅当完全消除数字项时才应用转换。

解释

当x趋近于零时，以向一处收敛的数值函数通常最好通过专门的函数实现，以避免灾难性的取消。一个典型的例子是C标准库中的`expm1(x)`，它计算的是`exp(x) - 1`。这种函数在其参数远小于一时能保留更多有效位数，相比之下，后续减一则无法保留这些位数。

示例

```py
>>> from sympy import symbols, exp
>>> from sympy.codegen.rewriting import FuncMinusOneOptim
>>> from sympy.codegen.cfunctions import expm1
>>> x, y = symbols('x y')
>>> expm1_opt = FuncMinusOneOptim(exp, expm1)
>>> expm1_opt(exp(x) + 2*exp(5*y) - 3)
expm1(x) + 2*expm1(5*y) 
```

```py
replace_in_Add(e)
```

作为第二个参数传递给Basic.replace(…)

```py
class sympy.codegen.rewriting.Optimization(cost_function=None, priority=1)
```

重写优化的抽象基类。

子类应实现`__call__`，接受一个表达式作为参数。

参数：

**成本函数**：返回数字的可调用对象

**优先级**：数字

```py
class sympy.codegen.rewriting.ReplaceOptim(query, value, **kwargs)
```

在表达式上调用replace进行重写优化。

参数：

**查询：**

> 替换时传递的第一个参数。

**值：**

> 替换的第二个传递参数。

解释

可以将该实例用作函数，适用于表达式，它将应用于`replace`方法（参见[`sympy.core.basic.Basic.replace()`](core.html#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")）。

示例

```py
>>> from sympy import Symbol
>>> from sympy.codegen.rewriting import ReplaceOptim
>>> from sympy.codegen.cfunctions import exp2
>>> x = Symbol('x')
>>> exp2_opt = ReplaceOptim(lambda p: p.is_Pow and p.base == 2,
...     lambda p: exp2(p.exp))
>>> exp2_opt(2**x)
exp2(x) 
```

```py
sympy.codegen.rewriting.create_expand_pow_optimization(limit, *, base_req=<function <lambda>>)
```

为`Pow`展开创建一个[`ReplaceOptim`](#sympy.codegen.rewriting.ReplaceOptim "sympy.codegen.rewriting.ReplaceOptim")实例。

参数：

**限制**：整数

> 展开为乘法的最高幂次。

**base_req**：返回布尔值的函数

> 展开发生的基本要求，默认返回基数的`is_symbol`属性。

解释

展开的要求是基数必须是一个符号，并且指数必须是一个整数（且小于或等于`limit`）。

示例

```py
>>> from sympy import Symbol, sin
>>> from sympy.codegen.rewriting import create_expand_pow_optimization
>>> x = Symbol('x')
>>> expand_opt = create_expand_pow_optimization(3)
>>> expand_opt(x**5 + x**3)
x**5 + x*x*x
>>> expand_opt(x**5 + x**3 + sin(x)**3)
x**5 + sin(x)**3 + x*x*x
>>> opt2 = create_expand_pow_optimization(3, base_req=lambda b: not b.is_Function)
>>> opt2((x+1)**2 + sin(x)**2)
sin(x)**2 + (x + 1)*(x + 1) 
```

```py
sympy.codegen.rewriting.optimize(expr, optimizations)
```

对表达式应用优化。

参数：

**表达式**：表达式

**优化**：`Optimization`实例的可迭代对象

> 优化将根据`priority`（最高优先级在前）排序。

示例

```py
>>> from sympy import log, Symbol
>>> from sympy.codegen.rewriting import optims_c99, optimize
>>> x = Symbol('x')
>>> optimize(log(x+3)/log(2) + log(x**2 + 1), optims_c99)
log1p(x**2) + log2(x + 3) 
```

用于矩阵操作的额外AST节点。此模块中的节点旨在表示无法通过SymPy表达式表示的代码生成目标语言中的矩阵表达式的优化。

例如，我们可以使用[`sympy.codegen.rewriting.optimize()`](#sympy.codegen.rewriting.optimize "sympy.codegen.rewriting.optimize")和[`sympy.codegen.rewriting`](#module-sympy.codegen.rewriting "sympy.codegen.rewriting")提供的`matin_opt`优化来在特定假设下转换矩阵乘法：

```py
>>> from sympy import symbols, MatrixSymbol
>>> n = symbols('n', integer=True)
>>> A = MatrixSymbol('A', n, n)
>>> x = MatrixSymbol('x', n, 1)
>>> expr = A**(-1) * x
>>> from sympy import assuming, Q
>>> from sympy.codegen.rewriting import matinv_opt, optimize
>>> with assuming(Q.fullrank(A)):
...     optimize(expr, [matinv_opt])
MatrixSolve(A, vector=x) 
```

```py
class sympy.codegen.matrix_nodes.MatrixSolve(*args, **kwargs)
```

代表一个解线性矩阵方程的操作。

参数：

**matrix** : MatrixSymbol

> 表示线性方程中变量系数的矩阵。该矩阵必须是方阵且满秩（即所有列必须线性独立），才能进行有效的求解操作。

**vector** : MatrixSymbol

> 表示在`matrix`中表示的方程的解的单列矩阵。

示例

```py
>>> from sympy import symbols, MatrixSymbol
>>> from sympy.codegen.matrix_nodes import MatrixSolve
>>> n = symbols('n', integer=True)
>>> A = MatrixSymbol('A', n, n)
>>> x = MatrixSymbol('x', n, 1)
>>> from sympy.printing.numpy import NumPyPrinter
>>> NumPyPrinter().doprint(MatrixSolve(A, x))
'numpy.linalg.solve(A, x)'
>>> from sympy import octave_code
>>> octave_code(MatrixSolve(A, x))
'A \\ x' 
```  ## 使用近似简化表达式的工具（sympy.codegen.approximations）

```py
class sympy.codegen.approximations.SeriesApprox(bounds, reltol, max_order=4, n_point_checks=4, **kwargs)
```

通过将它们展开为级数来近似函数。

参数：

**bounds** : dict

> 将表达式映射到长度为2的边界元组（低，高）。

**reltol** : number

> 相对于所有边界中的最大下界时要忽略术语。 

**max_order** : int

> 包括在级数展开中的最大阶数

**n_point_checks** : int（偶数）

> 在离散点（线性间隔在变量的边界上）上检查展开的有效性（相对于reltol）。在此数值检查中使用的点数由此数字给出。

示例

```py
>>> from sympy import sin, pi
>>> from sympy.abc import x, y
>>> from sympy.codegen.rewriting import optimize
>>> from sympy.codegen.approximations import SeriesApprox
>>> bounds = {x: (-.1, .1), y: (pi-1, pi+1)}
>>> series_approx2 = SeriesApprox(bounds, reltol=1e-2)
>>> series_approx3 = SeriesApprox(bounds, reltol=1e-3)
>>> series_approx8 = SeriesApprox(bounds, reltol=1e-8)
>>> expr = sin(x)*sin(y)
>>> optimize(expr, [series_approx2])
x*(-y + (y - pi)**3/6 + pi)
>>> optimize(expr, [series_approx3])
(-x**3/6 + x)*sin(y)
>>> optimize(expr, [series_approx8])
sin(x)*sin(y) 
```

```py
class sympy.codegen.approximations.SumApprox(bounds, reltol, **kwargs)
```

通过忽略小术语来近似和。

参数：

**bounds** : dict

> 将表达式映射到长度为2的边界元组（低，高）。

**reltol** : number

> 相对于所有边界中的最大下界时要忽略术语。 

解释

如果术语是可以确定为单调的表达式，则将这些表达式的边界添加进去。

示例

```py
>>> from sympy import exp
>>> from sympy.abc import x, y, z
>>> from sympy.codegen.rewriting import optimize
>>> from sympy.codegen.approximations import SumApprox
>>> bounds = {x: (-1, 1), y: (1000, 2000), z: (-10, 3)}
>>> sum_approx3 = SumApprox(bounds, reltol=1e-3)
>>> sum_approx2 = SumApprox(bounds, reltol=1e-2)
>>> sum_approx1 = SumApprox(bounds, reltol=1e-1)
>>> expr = 3*(x + y + exp(z))
>>> optimize(expr, [sum_approx3])
3*(x + y + exp(z))
>>> optimize(expr, [sum_approx2])
3*y + 3*exp(z)
>>> optimize(expr, [sum_approx1])
3*y 
```  ## 抽象语法树类（sympy.codegen.ast）

用于表示完整函数/模块的AST类型。

大多数类型都很小，仅用作AST中的标记。下面的树形图说明了AST类型之间的关系。

### AST类型树

```py
*Basic*
     |
     |
 CodegenAST
     |
     |--->AssignmentBase
     |             |--->Assignment
     |             |--->AugmentedAssignment
     |                                    |--->AddAugmentedAssignment
     |                                    |--->SubAugmentedAssignment
     |                                    |--->MulAugmentedAssignment
     |                                    |--->DivAugmentedAssignment
     |                                    |--->ModAugmentedAssignment
     |
     |--->CodeBlock
     |
     |
     |--->Token
              |--->Attribute
              |--->For
              |--->String
              |       |--->QuotedString
              |       |--->Comment
              |--->Type
              |       |--->IntBaseType
              |       |              |--->_SizedIntType
              |       |                               |--->SignedIntType
              |       |                               |--->UnsignedIntType
              |       |--->FloatBaseType
              |                        |--->FloatType
              |                        |--->ComplexBaseType
              |                                           |--->ComplexType
              |--->Node
              |       |--->Variable
              |       |           |---> Pointer
              |       |--->FunctionPrototype
              |                            |--->FunctionDefinition
              |--->Element
              |--->Declaration
              |--->While
              |--->Scope
              |--->Stream
              |--->Print
              |--->FunctionCall
              |--->BreakToken
              |--->ContinueToken
              |--->NoneToken
              |--->Return 
```

### 预定义类型

`sympy.codegen.ast`模块提供了多种`Type`实例供方便使用。也许最常见的两种用于代码生成（数值代码）的是`float32`和`float64`（分别称为单精度和双精度）。此外，还有精确的通用类型版本（在打印时选择底层数据类型）：`real`、`integer`、`complex_`、`bool_`。

其他定义的`Type`实例为：

+   `intc`：C中使用的整数类型。

+   `intp`：C中使用的无符号整数类型。

+   `int8`、`int16`、`int32`、`int64`：n位整数。

+   `uint8`、`uint16`、`uint32`、`uint64`：n 位无符号整数。

+   `float80`：在现代 x86/amd64 硬件上称为“扩展精度”。

+   `complex64`：由两个 `float32` 数字表示的复数。

+   `complex128`：由两个 `float64` 数字表示的复数

### 使用节点

可以使用 AST 节点构造简单的算法。让我们构造一个应用牛顿法的循环：

```py
>>> from sympy import symbols, cos
>>> from sympy.codegen.ast import While, Assignment, aug_assign, Print, QuotedString
>>> t, dx, x = symbols('tol delta val')
>>> expr = cos(x) - x**3
>>> whl = While(abs(dx) > t, [
...     Assignment(dx, -expr/expr.diff(x)),
...     aug_assign(x, '+', dx),
...     Print([x])
... ])
>>> from sympy import pycode
>>> py_str = pycode(whl)
>>> print(py_str)
while (abs(delta) > tol):
 delta = (val**3 - math.cos(val))/(-3*val**2 - math.sin(val))
 val += delta
 print(val)
>>> import math
>>> tol, val, delta = 1e-5, 0.5, float('inf')
>>> exec(py_str)
1.1121416371
0.909672693737
0.867263818209
0.865477135298
0.865474033111
>>> print('%3.1g' % (math.cos(val) - val**3))
-3e-11 
```

如果我们想要为相同的 while 循环生成 Fortran 代码，我们只需调用 `fcode`：

```py
>>> from sympy import fcode
>>> print(fcode(whl, standard=2003, source_format='free'))
do while (abs(delta) > tol)
 delta = (val**3 - cos(val))/(-3*val**2 - sin(val))
 val = val + delta
 print *, val
end do 
```

有一个函数在 [`sympy.codegen.algorithms`](#module-sympy.codegen.algorithms "sympy.codegen.algorithms") 中构造循环（或完整函数）。

```py
class sympy.codegen.ast.Assignment(lhs, rhs)
```

代表用于代码生成的变量赋值。

参数：

**lhs**：Expr

> SymPy 对象，表示表达式的左手边。这些应该是单一的对象，例如在编写代码时使用的对象。显著的类型包括 Symbol、MatrixSymbol、MatrixElement 和 Indexed。支持这些类型的子类也是支持的。

**rhs**：Expr

> SymPy 对象，表示表达式的右手边。可以是任何类型，只要其形状与左手边相对应。例如，Matrix 类型可以分配给 MatrixSymbol，但不能分配给 Symbol，因为维度不会对齐。

示例

```py
>>> from sympy import symbols, MatrixSymbol, Matrix
>>> from sympy.codegen.ast import Assignment
>>> x, y, z = symbols('x, y, z')
>>> Assignment(x, y)
Assignment(x, y)
>>> Assignment(x, 0)
Assignment(x, 0)
>>> A = MatrixSymbol('A', 1, 3)
>>> mat = Matrix([x, y, z]).T
>>> Assignment(A, mat)
Assignment(A, Matrix([[x, y, z]]))
>>> Assignment(A[0, 1], x)
Assignment(A[0, 1], x) 
```

```py
class sympy.codegen.ast.AssignmentBase(lhs, rhs)
```

赋值和增强赋值的抽象基类。

属性：

opstr

用于赋值操作符的符号，例如“=”，“+=”等。

```py
class sympy.codegen.ast.Attribute(possibly parametrized)
```

用于 [`sympy.codegen.ast.Node`](#sympy.codegen.ast.Node "sympy.codegen.ast.Node") 的实例（它将 `attrs` 作为 `Attribute` 的实例）。

参数：

**name**：str

**parameters**：Tuple

示例

```py
>>> from sympy.codegen.ast import Attribute
>>> volatile = Attribute('volatile')
>>> volatile
volatile
>>> print(repr(volatile))
Attribute(String('volatile'))
>>> a = Attribute('foo', [1, 2, 3])
>>> a
foo(1, 2, 3)
>>> a.parameters == (1, 2, 3)
True 
```

```py
class sympy.codegen.ast.AugmentedAssignment(lhs, rhs)
```

增强赋值的基类。

属性：

binopstr

用于赋值操作中应用的二元操作符的符号，例如“+”，“*”等。

```py
class sympy.codegen.ast.BreakToken(*args, **kwargs)
```

表示 C/Python 中的 ‘break’（Fortran 中的 ‘exit’）。

使用预定义的实例 `break_` 或手动实例化。

示例

```py
>>> from sympy import ccode, fcode
>>> from sympy.codegen.ast import break_
>>> ccode(break_)
'break'
>>> fcode(break_, source_format='free')
'exit' 
```

```py
class sympy.codegen.ast.CodeBlock(*args)
```

代表代码块。

解释

目前仅支持赋值。这个限制将来会解除。

此对象的有用属性包括：

`left_hand_sides`：

按顺序的赋值的左手边的元组。

`left_hand_sides`：

按顺序的右手边的赋值的元组。

`free_symbols`：右侧表达式的自由符号

在赋值的左手边未出现的符号。

此对象的有用方法包括：

`topological_sort`：

类方法。返回一个按照变量被赋值前使用的顺序排序的代码块。

`cse`：

返回一个新的代码块，消除常见子表达式并将其作为赋值语句提取出来。

示例

```py
>>> from sympy import symbols, ccode
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y = symbols('x y')
>>> c = CodeBlock(Assignment(x, 1), Assignment(y, x + 1))
>>> print(ccode(c))
x = 1;
y = x + 1; 
```

```py
cse(symbols=None, optimizations=None, postprocess=None, order='canonical')
```

返回一个新的代码块，消除常见的子表达式。

解释

查看 [`sympy.simplify.cse_main.cse()`](simplify/simplify.html#sympy.simplify.cse_main.cse "sympy.simplify.cse_main.cse") 的文档字符串获取更多信息。

示例

```py
>>> from sympy import symbols, sin
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y, z = symbols('x y z') 
```

```py
>>> c = CodeBlock(
...     Assignment(x, 1),
...     Assignment(y, sin(x) + 1),
...     Assignment(z, sin(x) - 1),
... )
...
>>> c.cse()
CodeBlock(
 Assignment(x, 1),
 Assignment(x0, sin(x)),
 Assignment(y, x0 + 1),
 Assignment(z, x0 - 1)
) 
```

```py
classmethod topological_sort(assignments)
```

返回一个按拓扑顺序排序的代码块，以便变量在使用之前被赋值。

示例

尽可能保持现有的赋值顺序。

此函数假设变量只被分配一次。

这是一个类构造函数，因此当变量在分配之前被使用时，默认构造函数可以报错。

```py
>>> from sympy import symbols
>>> from sympy.codegen.ast import CodeBlock, Assignment
>>> x, y, z = symbols('x y z') 
```

```py
>>> assignments = [
...     Assignment(x, y + z),
...     Assignment(y, z + 1),
...     Assignment(z, 2),
... ]
>>> CodeBlock.topological_sort(assignments)
CodeBlock(
 Assignment(z, 2),
 Assignment(y, z + 1),
 Assignment(x, y + z)
) 
```

```py
class sympy.codegen.ast.Comment(*args, **kwargs)
```

表示一个注释。

```py
class sympy.codegen.ast.ComplexType(*args, **kwargs)
```

表示复杂的浮点数。

```py
class sympy.codegen.ast.ContinueToken(*args, **kwargs)
```

在C/Python中表示‘continue’（在Fortran中表示‘cycle’）

使用预制实例`continue_`或手动实例化。

示例

```py
>>> from sympy import ccode, fcode
>>> from sympy.codegen.ast import continue_
>>> ccode(continue_)
'continue'
>>> fcode(continue_, source_format='free')
'cycle' 
```

```py
class sympy.codegen.ast.Declaration(*args, **kwargs)
```

表示变量声明

参数：

**variable** : 变量

示例

```py
>>> from sympy.codegen.ast import Declaration, NoneToken, untyped
>>> z = Declaration('z')
>>> z.variable.type == untyped
True
>>> # value is special NoneToken() which must be tested with == operator
>>> z.variable.value is None  # won't work
False
>>> z.variable.value == None  # not PEP-8 compliant
True
>>> z.variable.value == NoneToken()  # OK
True 
```

```py
class sympy.codegen.ast.Element(*args, **kwargs)
```

数组中的元素（可能是N维）。

示例

```py
>>> from sympy.codegen.ast import Element
>>> elem = Element('x', 'ijk')
>>> elem.symbol.name == 'x'
True
>>> elem.indices
(i, j, k)
>>> from sympy import ccode
>>> ccode(elem)
'x[i][j][k]'
>>> ccode(Element('x', 'ijk', strides='lmn', offset='o'))
'x[i*l + j*m + k*n + o]' 
```

```py
class sympy.codegen.ast.FloatBaseType(*args, **kwargs)
```

表示浮点数类型。

```py
cast_nocheck
```

别名为[`Float`](core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")的浮点类型

```py
class sympy.codegen.ast.FloatType(*args, **kwargs)
```

表示具有固定位宽的浮点类型。

基数2和一个符号位是默认的。

参数：

**name** : 字符串

> 类型的名称。

**nbits** : 整数

> 用于表示的位数（存储）。

**nmant** : 整数

> 用于表示尾数的位数。

**nexp** : 整数

> 用于表示尾数的位数。

示例

```py
>>> from sympy import S
>>> from sympy.codegen.ast import FloatType
>>> half_precision = FloatType('f16', nbits=16, nmant=10, nexp=5)
>>> half_precision.max
65504
>>> half_precision.tiny == S(2)**-14
True
>>> half_precision.eps == S(2)**-10
True
>>> half_precision.dig == 3
True
>>> half_precision.decimal_dig == 5
True
>>> half_precision.cast_check(1.0)
1.0
>>> half_precision.cast_check(1e5)  
Traceback (most recent call last):
  ...
ValueError: Maximum value for data type smaller than new value. 
```

```py
cast_nocheck(value)
```

强制转换，而不检查是否超出范围或子正常。

```py
property decimal_dig
```

需要存储和加载而不会丢失的位数。

解释

需要保证两个连续的转换（浮点数 -> 文本 -> 浮点数）是幂等的十进制数字的数量。这在存储浮点值作为文本时，由于四舍五入误差而不想丢失精度时非常有用。

```py
property dig
```

保证在文本中保留的十进制数字的数量。

当转换文本 -> 浮点数 -> 文本时，可以保证至少保留`dig`位数，以便于舍入或溢出。

```py
property eps
```

1.0与下一个可表示值之间的差异。

```py
property max
```

可表示的最大值。

```py
property max_exponent
```

最大的正数n，使得2 ** (n - 1)是可表示的有限值。

```py
property min_exponent
```

最小的负数n，使得2 ** (n - 1)是有效的正规化数。

```py
property tiny
```

最小的正规化值。

```py
class sympy.codegen.ast.For(*args, **kwargs)
```

在代码中表示‘for-loop’。

> 表达式的形式：
> 
> “for target in iter:
> 
> body…”

参数：

**target** : 符号

> iter : 可迭代体 body : CodeBlock 或可迭代

**！当传入一个可迭代对象时，它用于实例化CodeBlock。**

示例

```py
>>> from sympy import symbols, Range
>>> from sympy.codegen.ast import aug_assign, For
>>> x, i, j, k = symbols('x i j k')
>>> for_i = For(i, Range(10), [aug_assign(x, '+', i*j*k)])
>>> for_i  
For(i, iterable=Range(0, 10, 1), body=CodeBlock(
 AddAugmentedAssignment(x, i*j*k)
))
>>> for_ji = For(j, Range(7), [for_i])
>>> for_ji  
For(j, iterable=Range(0, 7, 1), body=CodeBlock(
 For(i, iterable=Range(0, 10, 1), body=CodeBlock(
 AddAugmentedAssignment(x, i*j*k)
 ))
))
>>> for_kji =For(k, Range(5), [for_ji])
>>> for_kji  
For(k, iterable=Range(0, 5, 1), body=CodeBlock(
 For(j, iterable=Range(0, 7, 1), body=CodeBlock(
 For(i, iterable=Range(0, 10, 1), body=CodeBlock(
 AddAugmentedAssignment(x, i*j*k)
 ))
 ))
)) 
```

```py
class sympy.codegen.ast.FunctionCall(*args, **kwargs)
```

表示调用代码中的函数。

参数：

**name** : 字符串

**function_args** : 元组

示例

```py
>>> from sympy.codegen.ast import FunctionCall
>>> from sympy import pycode
>>> fcall = FunctionCall('foo', 'bar baz'.split())
>>> print(pycode(fcall))
foo(bar, baz) 
```

```py
class sympy.codegen.ast.FunctionDefinition(*args, **kwargs)
```

表示代码中的函数定义。

参数：

**return_type** : 类型

**name** : 字符串

**parameters: 变量实例的可迭代对象**

**body** : CodeBlock 或可迭代

**attrs** : 属性实例的可迭代对象

示例

```py
>>> from sympy import ccode, symbols
>>> from sympy.codegen.ast import real, FunctionPrototype
>>> x, y = symbols('x y', real=True)
>>> fp = FunctionPrototype(real, 'foo', [x, y])
>>> ccode(fp)
'double foo(double x, double y)'
>>> from sympy.codegen.ast import FunctionDefinition, Return
>>> body = [Return(x*y)]
>>> fd = FunctionDefinition.from_FunctionPrototype(fp, body)
>>> print(ccode(fd))
double foo(double x, double y){
 return x*y;
} 
```

```py
class sympy.codegen.ast.FunctionPrototype(*args, **kwargs)
```

表示函数原型

允许用户生成例如C/C++中的前向声明。

参数：

**return_type** : 类型

**name** : 字符串

**parameters: 变量实例的可迭代对象**

**attrs** : 属性实例的可迭代对象

示例

```py
>>> from sympy import ccode, symbols
>>> from sympy.codegen.ast import real, FunctionPrototype
>>> x, y = symbols('x y', real=True)
>>> fp = FunctionPrototype(real, 'foo', [x, y])
>>> ccode(fp)
'double foo(double x, double y)' 
```

```py
class sympy.codegen.ast.IntBaseType(*args, **kwargs)
```

整数基本类型，不包含大小信息。

```py
class sympy.codegen.ast.Node(*args, **kwargs)
```

Token的子类，携带属性‘attrs’（元组）

示例

```py
>>> from sympy.codegen.ast import Node, value_const, pointer_const
>>> n1 = Node([value_const])
>>> n1.attr_params('value_const')  # get the parameters of attribute (by name)
()
>>> from sympy.codegen.fnodes import dimension
>>> n2 = Node([value_const, dimension(5, 3)])
>>> n2.attr_params(value_const)  # get the parameters of attribute (by Attribute instance)
()
>>> n2.attr_params('dimension')  # get the parameters of attribute (by name)
(5, 3)
>>> n2.attr_params(pointer_const) is None
True 
```

```py
attr_params(looking_for)
```

返回self.attrs中名为`looking_for`的属性的参数。

```py
class sympy.codegen.ast.NoneToken(*args, **kwargs)
```

Python的NoneType的AST等价物

Python中对应的`None`的实例是`none`。

示例

```py
>>> from sympy.codegen.ast import none, Variable
>>> from sympy import pycode
>>> print(pycode(Variable('x').as_Declaration(value=none)))
x = None 
```

```py
class sympy.codegen.ast.Pointer(*args, **kwargs)
```

表示指针。参见 `Variable`。

示例

可以创建 `Element` 的实例：

```py
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Pointer
>>> i = Symbol('i', integer=True)
>>> p = Pointer('x')
>>> p[i+1]
Element(x, indices=(i + 1,)) 
```

```py
class sympy.codegen.ast.Print(*args, **kwargs)
```

表示代码中的打印命令。

参数：

**formatstring** : 字符串

***args** : Basic 实例（或通过 sympify 转换为这样的实例）

示例

```py
>>> from sympy.codegen.ast import Print
>>> from sympy import pycode
>>> print(pycode(Print('x y'.split(), "coordinate: %12.5g  %12.5g\\n")))
print("coordinate: %12.5g %12.5g\n" % (x, y), end="") 
```

```py
class sympy.codegen.ast.QuotedString(*args, **kwargs)
```

表示应使用引号打印的字符串。

```py
class sympy.codegen.ast.Raise(*args, **kwargs)
```

在 Python 中打印为 ‘raise …’，在 C++ 中为 ‘throw …’。

```py
class sympy.codegen.ast.Return(*args, **kwargs)
```

表示代码中的返回命令。

参数：

**return** : Basic

示例

```py
>>> from sympy.codegen.ast import Return
>>> from sympy.printing.pycode import pycode
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> print(pycode(Return(x)))
return x 
```

```py
class sympy.codegen.ast.RuntimeError_(*args, **kwargs)
```

在 C++ 中表示 ‘std::runtime_error’，在 Python 中表示 ‘RuntimeError’。

注意后者不常见，你可能想使用例如 ValueError。

```py
class sympy.codegen.ast.Scope(*args, **kwargs)
```

表示代码中的作用域。

参数：

**body** : CodeBlock 或可迭代对象

> 当传递一个可迭代对象时，它用于实例化一个 CodeBlock。

```py
class sympy.codegen.ast.SignedIntType(*args, **kwargs)
```

表示有符号整数类型。

```py
class sympy.codegen.ast.Stream(*args, **kwargs)
```

表示流。

有两个预定义的 Stream 实例 `stdout` 和 `stderr`。

参数：

**name** : str

示例

```py
>>> from sympy import pycode, Symbol
>>> from sympy.codegen.ast import Print, stderr, QuotedString
>>> print(pycode(Print(['x'], file=stderr)))
print(x, file=sys.stderr)
>>> x = Symbol('x')
>>> print(pycode(Print([QuotedString('x')], file=stderr)))  # print literally "x"
print("x", file=sys.stderr) 
```

```py
class sympy.codegen.ast.String(*args, **kwargs)
```

表示字符串的 SymPy 对象。

不是表达式的原子对象（与 Symbol 相反）。

参数：

**text** : 字符串

示例

```py
>>> from sympy.codegen.ast import String
>>> f = String('foo')
>>> f
foo
>>> str(f)
'foo'
>>> f.text
'foo'
>>> print(repr(f))
String('foo') 
```

```py
class sympy.codegen.ast.Token(*args, **kwargs)
```

AST 类型的基类。

解释

在 `_fields` 中设置定义字段。属性（在 _fields 中定义）只允许包含 Basic 的实例（除非是原子的，见 `String`）。`__new__()` 的参数与按 ```py_fields`. The ``defaults``` 类属性中定义顺序的属性相对应的顺序一致，是一个将属性名称映射到其默认值的字典的类属性。

子类不应需要覆盖 `__new__()` 方法。它们可以为传递给 `__new__()` 的每个属性定义名为 `_construct_<attr>` 的类或静态方法，以处理传递给 [`Basic`](core.html#sympy.core.basic.Basic "sympy.core.basic.Basic") 的值。列在类属性 `not_in_args` 中的属性不会传递给。

```py
kwargs(exclude=(), apply=None)
```

将实例的属性作为关键字参数的字典获取。

参数：

**exclude** : 字符串集合

> 要排除的关键字集合。

**apply** : 可调用对象，可选

> 应用于所有值的函数。

```py
class sympy.codegen.ast.Type(*args, **kwargs)
```

表示类型。

参数：

**name** : 字符串

> 类型的名称，例如 `object`，`int16`，`float16`（后两者将分别使用 `Type` 子类 `IntType` 和 `FloatType`）。如果给定 `Type` 实例，则返回该实例。

解释

命名是 NumPy 命名的超集。Type 类具有类方法 `from_expr`，用于提供类型推导。它还具有 `cast_check` 方法，用于将参数强制转换为其类型，如果舍入误差不在容差范围内或者值无法由底层数据类型表示（例如无符号整数），可能会引发异常。

示例

```py
>>> from sympy.codegen.ast import Type
>>> t = Type.from_expr(42)
>>> t
integer
>>> print(repr(t))
IntBaseType(String('integer'))
>>> from sympy.codegen.ast import uint8
>>> uint8.cast_check(-1)   
Traceback (most recent call last):
  ...
ValueError: Minimum value for data type bigger than new value.
>>> from sympy.codegen.ast import float32
>>> v6 = 0.123456
>>> float32.cast_check(v6)
0.123456
>>> v10 = 12345.67894
>>> float32.cast_check(v10)  
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> boost_mp50 = Type('boost::multiprecision::cpp_dec_float_50')
>>> from sympy import cxxcode
>>> from sympy.codegen.ast import Declaration, Variable
>>> cxxcode(Declaration(Variable('x', type=boost_mp50)))
'boost::multiprecision::cpp_dec_float_50 x' 
```

引用

[[R39](#id2)]

[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)

```py
cast_check(value, rtol=None, atol=0, precision_targets=None)
```

将值转换为实例的数据类型。

参数：

**value** : 数字

**rtol** : 浮点数

> 相对容差。（如果未给出则将推导）

**atol** : 浮点数

> 绝对容差（除了 `rtol`）。

**type_aliases** : dict

> 用于类型映射的替换，例如 {integer: int64, real: float32}

示例

```py
>>> from sympy.codegen.ast import integer, float32, int8
>>> integer.cast_check(3.0) == 3
True
>>> float32.cast_check(1e-40)  
Traceback (most recent call last):
  ...
ValueError: Minimum value for data type bigger than new value.
>>> int8.cast_check(256)  
Traceback (most recent call last):
  ...
ValueError: Maximum value for data type smaller than new value.
>>> v10 = 12345.67894
>>> float32.cast_check(v10)  
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> from sympy.codegen.ast import float64
>>> float64.cast_check(v10)
12345.67894
>>> from sympy import Float
>>> v18 = Float('0.123456789012345646')
>>> float64.cast_check(v18)
Traceback (most recent call last):
  ...
ValueError: Casting gives a significantly different value.
>>> from sympy.codegen.ast import float80
>>> float80.cast_check(v18)
0.123456789012345649 
```

```py
classmethod from_expr(expr)
```

从表达式或`Symbol`推断类型。

参数：

**expr** : 数字或SymPy对象

> 类型将从类型或属性推断。

引发：

**类型推断失败时引发ValueError。**

示例

```py
>>> from sympy.codegen.ast import Type, integer, complex_
>>> Type.from_expr(2) == integer
True
>>> from sympy import Symbol
>>> Type.from_expr(Symbol('z', complex=True)) == complex_
True
>>> Type.from_expr(sum)  
Traceback (most recent call last):
  ...
ValueError: Could not deduce type from expr. 
```

```py
class sympy.codegen.ast.UnsignedIntType(*args, **kwargs)
```

表示一个无符号整数类型。

```py
class sympy.codegen.ast.Variable(*args, **kwargs)
```

表示一个变量。

参数：

**symbol** : Symbol

**type** : Type（可选）

> 变量的类型。

**attrs** : 可迭代的Attribute实例

> 将被存储为元组。

示例

```py
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Variable, float32, integer
>>> x = Symbol('x')
>>> v = Variable(x, type=float32)
>>> v.attrs
()
>>> v == Variable('x')
False
>>> v == Variable('x', type=float32)
True
>>> v
Variable(x, type=float32) 
```

也可以通过对符号的假设推断出的类型使用`deduced`类方法构造`Variable`实例：

```py
>>> i = Symbol('i', integer=True)
>>> v = Variable.deduced(i)
>>> v.type == integer
True
>>> v == Variable('i')
False
>>> from sympy.codegen.ast import value_const
>>> value_const in v.attrs
False
>>> w = Variable('w', attrs=[value_const])
>>> w
Variable(w, attrs=(value_const,))
>>> value_const in w.attrs
True
>>> w.as_Declaration(value=42)
Declaration(Variable(w, value=42, attrs=(value_const,))) 
```

```py
as_Declaration(**kwargs)
```

创建Declaration实例的便利方法。

解释

如果声明的变量需要包装一个修改后的变量关键字参数（例如覆盖变量实例的`value`），可以传递。

示例

```py
>>> from sympy.codegen.ast import Variable, NoneToken
>>> x = Variable('x')
>>> decl1 = x.as_Declaration()
>>> # value is special NoneToken() which must be tested with == operator
>>> decl1.variable.value is None  # won't work
False
>>> decl1.variable.value == None  # not PEP-8 compliant
True
>>> decl1.variable.value == NoneToken()  # OK
True
>>> decl2 = x.as_Declaration(value=42.0)
>>> decl2.variable.value == 42.0
True 
```

```py
classmethod deduced(symbol, value=None, attrs=(), cast_check=True)
```

从`Type.from_expr`推断类型的替代构造函数。

主要从`symbol`推断类型，次要从`value`推断。

参数：

**symbol** : Symbol

**value** : expr

> （可选）变量的值。

**attrs** : 可迭代的Attribute实例

**cast_check** : bool

> 是否在`value`上应用`Type.cast_check`。

示例

```py
>>> from sympy import Symbol
>>> from sympy.codegen.ast import Variable, complex_
>>> n = Symbol('n', integer=True)
>>> str(Variable.deduced(n).type)
'integer'
>>> x = Symbol('x', real=True)
>>> v = Variable.deduced(x)
>>> v.type
real
>>> z = Symbol('z', complex=True)
>>> Variable.deduced(z).type == complex_
True 
```

```py
class sympy.codegen.ast.While(*args, **kwargs)
```

表示代码中的‘for-loop’。

表达式的形式为：

“while condition:

body…”

参数：

**condition** : 可转换为布尔值的表达式

**body** : CodeBlock或可迭代对象

> 当传递一个可迭代对象时，用于实例化`CodeBlock`。

示例

```py
>>> from sympy import symbols, Gt, Abs
>>> from sympy.codegen import aug_assign, Assignment, While
>>> x, dx = symbols('x dx')
>>> expr = 1 - x**2
>>> whl = While(Gt(Abs(dx), 1e-9), [
...     Assignment(dx, -expr/expr.diff(x)),
...     aug_assign(x, '+', dx)
... ]) 
```

```py
sympy.codegen.ast.aug_assign(lhs, op, rhs)
```

创建‘lhs op= rhs’。

参数：

**lhs** : Expr

> 表示表达式左手边的SymPy对象。这些应该是单数对象，如编写代码时所用。显著的类型包括`Symbol`、`MatrixSymbol`、`MatrixElement`和`Indexed`。支持这些类型的子类也被支持。

**op** : str

> 运算符（+、-、/、*、%）。

**rhs** : Expr

> 表示表达式右手边的SymPy对象。这可以是任何类型，只要其形状与左手边对应即可。例如，Matrix类型可以分配给MatrixSymbol，但不能分配给Symbol，因为维度不会对齐。

解释

表示用于代码生成的增强变量赋值。这是一个便利函数。你也可以直接使用增强赋值类，比如`AddAugmentedAssignment(x, y)`。

示例

```py
>>> from sympy import symbols
>>> from sympy.codegen.ast import aug_assign
>>> x, y = symbols('x, y')
>>> aug_assign(x, '+', y)
AddAugmentedAssignment(x, y) 
```  ## 特殊的C数学函数（sympy.codegen.cfunctions）

此模块包含SymPy函数，与C标准库中的特殊数学函数相对应（自C99起，也可在C++11中使用）。

该模块中定义的函数允许用户将`expm1`之类的函数表达为SymPy函数，以进行符号操作。

```py
class sympy.codegen.cfunctions.Cbrt(*args)
```

表示立方根函数。

解释

选择`Cbrt(x)`而不是`cbrt(x)`的原因是后者在内部表示为`Pow(x, Rational(1, 3))`，这在进行代码生成时可能不是想要的结果。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import Cbrt
>>> Cbrt(x)
Cbrt(x)
>>> Cbrt(x).diff(x)
1/(3*x**(2/3)) 
```

另请参阅

[`Sqrt`](#sympy.codegen.cfunctions.Sqrt "sympy.codegen.cfunctions.Sqrt")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.Sqrt(*args)
```

表示平方根函数。

解释

为什么应该使用`Sqrt(x)`而不是`sqrt(x)`的原因是，后者在内部表示为`Pow(x, S.Half)`，这可能不符合代码生成时的期望。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import Sqrt
>>> Sqrt(x)
Sqrt(x)
>>> Sqrt(x).diff(x)
1/(2*sqrt(x)) 
```

另请参见

[`Cbrt`](#sympy.codegen.cfunctions.Cbrt "sympy.codegen.cfunctions.Cbrt")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.exp2(arg)
```

代表以二为基数的指数函数。

解释

使用`exp2(x)`而不是`2**x`的好处在于，在有限精度算术下，后者效率不高。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import exp2
>>> exp2(2).evalf() == 4.0
True
>>> exp2(x).diff(x)
log(2)*exp2(x) 
```

另请参见

[`log2`](#sympy.codegen.cfunctions.log2 "sympy.codegen.cfunctions.log2")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.expm1(arg)
```

代表以自然指数减一的指数函数。

解释

使用`expm1(x)`而不是`exp(x) - 1`的好处在于，后者在x接近零时容易出现取消精度问题。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import expm1
>>> '%.0e' % expm1(1e-99).evalf()
'1e-99'
>>> from math import exp
>>> exp(1e-99) - 1
0.0
>>> expm1(x).diff(x)
exp(x) 
```

另请参见

[`log1p`](#sympy.codegen.cfunctions.log1p "sympy.codegen.cfunctions.log1p")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.fma(*args)
```

代表“融合乘加”。

解释

使用`fma(x, y, z)`而不是`x*y + z`的好处在于，在有限精度算术下，前者受某些CPU的特殊指令支持。

示例

```py
>>> from sympy.abc import x, y, z
>>> from sympy.codegen.cfunctions import fma
>>> fma(x, y, z).diff(x)
y 
```

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.hypot(*args)
```

代表求直角三角形斜边长度的函数。

解释

例如，在进行代码生成时，由C99标准的数学库提供直角三角形函数，因此可能希望在符号化表示函数时使用该函数。

示例

```py
>>> from sympy.abc import x, y
>>> from sympy.codegen.cfunctions import hypot
>>> hypot(3, 4).evalf() == 5.0
True
>>> hypot(x, y)
hypot(x, y)
>>> hypot(x, y).diff(x)
x/hypot(x, y) 
```

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.log10(arg)
```

代表以十为底数的对数函数。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log10
>>> log10(100).evalf() == 2.0
True
>>> log10(x).diff(x)
1/(x*log(10)) 
```

另请参见

[`log2`](#sympy.codegen.cfunctions.log2 "sympy.codegen.cfunctions.log2")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.log1p(arg)
```

代表对数加一的自然对数。

解释

使用`log1p(x)`而不是`log(x + 1)`的好处在于，后者在x接近零时容易出现取消精度问题。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log1p
>>> from sympy import expand_log
>>> '%.0e' % expand_log(log1p(1e-99)).evalf()
'1e-99'
>>> from math import log
>>> log(1 + 1e-99)
0.0
>>> log1p(x).diff(x)
1/(x + 1) 
```

另请参见

[`expm1`](#sympy.codegen.cfunctions.expm1 "sympy.codegen.cfunctions.expm1")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。

```py
class sympy.codegen.cfunctions.log2(arg)
```

代表以二为底数的对数函数。

解释

使用`log2(x)`而不是`log(x)/log(2)`的好处在于，在有限精度算术下，后者效率不高。

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cfunctions import log2
>>> log2(4).evalf() == 2.0
True
>>> log2(x).diff(x)
1/(x*log(2)) 
```

另请参见

[`exp2`](#sympy.codegen.cfunctions.exp2 "sympy.codegen.cfunctions.exp2"), [`log10`](#sympy.codegen.cfunctions.log10 "sympy.codegen.cfunctions.log10")

```py
fdiff(argindex=1)
```

返回此函数的一阶导数。  ## C特定AST节点（sympy.codegen.cnodes）

适用于C系语言特定的AST节点

```py
class sympy.codegen.cnodes.CommaOperator(*args)
```

代表C语言中的逗号运算符

```py
class sympy.codegen.cnodes.Label(*args, **kwargs)
```

用于例如goto语句的标签。

示例

```py
>>> from sympy import ccode, Symbol
>>> from sympy.codegen.cnodes import Label, PreIncrement
>>> print(ccode(Label('foo')))
foo:
>>> print(ccode(Label('bar', [PreIncrement(Symbol('a'))])))
bar:
++(a); 
```

```py
class sympy.codegen.cnodes.PostDecrement(*args)
```

代表后自减运算符

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PostDecrement
>>> from sympy import ccode
>>> ccode(PostDecrement(x))
'(x)--' 
```

```py
class sympy.codegen.cnodes.PostIncrement(*args)
```

代表后自增运算符

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PostIncrement
>>> from sympy import ccode
>>> ccode(PostIncrement(x))
'(x)++' 
```

```py
class sympy.codegen.cnodes.PreDecrement(*args)
```

代表前自减运算符

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PreDecrement
>>> from sympy import ccode
>>> ccode(PreDecrement(x))
'--(x)' 
```

```py
class sympy.codegen.cnodes.PreIncrement(*args)
```

代表前自增运算符

示例

```py
>>> from sympy.abc import x
>>> from sympy.codegen.cnodes import PreIncrement
>>> from sympy import ccode
>>> ccode(PreIncrement(x))
'++(x)' 
```

```py
sympy.codegen.cnodes.alignof(arg)
```

生成调用‘alignof’的FunctionCall实例

```py
class sympy.codegen.cnodes.goto(*args, **kwargs)
```

代表C语言中的goto

```py
sympy.codegen.cnodes.sizeof(arg)
```

生成调用‘sizeof’的FunctionCall实例

示例

```py
>>> from sympy.codegen.ast import real
>>> from sympy.codegen.cnodes import sizeof
>>> from sympy import ccode
>>> ccode(sizeof(real))
'sizeof(double)' 
```

```py
class sympy.codegen.cnodes.struct(*args, **kwargs)
```

表示C中的结构

```py
class sympy.codegen.cnodes.union(*args, **kwargs)
```

表示C中的联合  ## C++特定的AST节点（sympy.codegen.cxxnodes）

专用于C++的AST节点。

```py
class sympy.codegen.cxxnodes.using(*args, **kwargs)
```

表示C++中的‘using’语句  ## Fortran特定的AST节点（sympy.codegen.fnodes）

专用于Fortran的AST节点。

该模块中定义的函数允许用户将诸如`dsign`之类的函数表达为SymPy函数以进行符号操作。

```py
class sympy.codegen.fnodes.ArrayConstructor(*args, **kwargs)
```

表示一个数组构造器。

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import ArrayConstructor
>>> ac = ArrayConstructor([1, 2, 3])
>>> fcode(ac, standard=95, source_format='free')
'(/1, 2, 3/)'
>>> fcode(ac, standard=2003, source_format='free')
'[1, 2, 3]' 
```

```py
class sympy.codegen.fnodes.Do(*args, **kwargs)
```

表示Fortran中的Do循环。

示例

```py
>>> from sympy import fcode, symbols
>>> from sympy.codegen.ast import aug_assign, Print
>>> from sympy.codegen.fnodes import Do
>>> i, n = symbols('i n', integer=True)
>>> r = symbols('r', real=True)
>>> body = [aug_assign(r, '+', 1/i), Print([i, r])]
>>> do1 = Do(body, i, 1, n)
>>> print(fcode(do1, source_format='free'))
do i = 1, n
 r = r + 1d0/i
 print *, i, r
end do
>>> do2 = Do(body, i, 1, n, 2)
>>> print(fcode(do2, source_format='free'))
do i = 1, n, 2
 r = r + 1d0/i
 print *, i, r
end do 
```

```py
class sympy.codegen.fnodes.Extent(*args)
```

表示一个维度范围。

示例

```py
>>> from sympy.codegen.fnodes import Extent
>>> e = Extent(-3, 3)  # -3, -2, -1, 0, 1, 2, 3
>>> from sympy import fcode
>>> fcode(e, source_format='free')
'-3:3'
>>> from sympy.codegen.ast import Variable, real
>>> from sympy.codegen.fnodes import dimension, intent_out
>>> dim = dimension(e, e)
>>> arr = Variable('x', real, attrs=[dim, intent_out])
>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)
'real*8, dimension(-3:3, -3:3), intent(out) :: x' 
```

```py
class sympy.codegen.fnodes.FortranReturn(*args, **kwargs)
```

明确映射到Fortran“return”的AST节点。

说明

因为Fortran中的返回语句与C中的不同，并且为了帮助重用我们的代码生成AST，普通的`.codegen.ast.Return`被解释为对函数的结果变量的赋值。如果由于某种原因需要生成一个Fortran RETURN语句，应使用此节点。

示例

```py
>>> from sympy.codegen.fnodes import FortranReturn
>>> from sympy import fcode
>>> fcode(FortranReturn('x'))
'       return x' 
```

```py
class sympy.codegen.fnodes.GoTo(*args, **kwargs)
```

表示Fortran中的goto语句

示例

```py
>>> from sympy.codegen.fnodes import GoTo
>>> go = GoTo([10, 20, 30], 'i')
>>> from sympy import fcode
>>> fcode(go, source_format='free')
'go to (10, 20, 30), i' 
```

```py
class sympy.codegen.fnodes.ImpliedDoLoop(*args, **kwargs)
```

表示Fortran中的隐含do循环。

示例

```py
>>> from sympy import Symbol, fcode
>>> from sympy.codegen.fnodes import ImpliedDoLoop, ArrayConstructor
>>> i = Symbol('i', integer=True)
>>> idl = ImpliedDoLoop(i**3, i, -3, 3, 2)  # -27, -1, 1, 27
>>> ac = ArrayConstructor([-28, idl, 28]) # -28, -27, -1, 1, 27, 28
>>> fcode(ac, standard=2003, source_format='free')
'[-28, (i**3, i = -3, 3, 2), 28]' 
```

```py
class sympy.codegen.fnodes.Module(*args, **kwargs)
```

表示Fortran中的模块。

示例

```py
>>> from sympy.codegen.fnodes import Module
>>> from sympy import fcode
>>> print(fcode(Module('signallib', ['implicit none'], []), source_format='free'))
module signallib
implicit none

contains

end module 
```

```py
class sympy.codegen.fnodes.Program(*args, **kwargs)
```

表示Fortran中的‘program’块。

示例

```py
>>> from sympy.codegen.ast import Print
>>> from sympy.codegen.fnodes import Program
>>> prog = Program('myprogram', [Print([42])])
>>> from sympy import fcode
>>> print(fcode(prog, source_format='free'))
program myprogram
 print *, 42
end program 
```

```py
class sympy.codegen.fnodes.Subroutine(*args, **kwargs)
```

表示Fortran中的子程序。

示例

```py
>>> from sympy import fcode, symbols
>>> from sympy.codegen.ast import Print
>>> from sympy.codegen.fnodes import Subroutine
>>> x, y = symbols('x y', real=True)
>>> sub = Subroutine('mysub', [x, y], [Print([x**2 + y**2, x*y])])
>>> print(fcode(sub, source_format='free', standard=2003))
subroutine mysub(x, y)
real*8 :: x
real*8 :: y
print *, x**2 + y**2, x*y
end subroutine 
```

```py
class sympy.codegen.fnodes.SubroutineCall(*args, **kwargs)
```

表示Fortran中的子程序调用。

示例

```py
>>> from sympy.codegen.fnodes import SubroutineCall
>>> from sympy import fcode
>>> fcode(SubroutineCall('mysub', 'x y'.split()))
'       call mysub(x, y)' 
```

```py
sympy.codegen.fnodes.allocated(array)
```

为Fortran的“allocated(…)”创建一个函数调用的AST节点。

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import allocated
>>> alloc = allocated('x')
>>> fcode(alloc, source_format='free')
'allocated(x)' 
```

```py
sympy.codegen.fnodes.array(symbol, dim, intent=None, *, attrs=(), value=None, type=None)
```

用于为Fortran数组创建一个变量实例的便利函数。

参数：

**symbol**：符号

**dim**：属性或可迭代对象

> 如果dim是一个`Attribute`，它需要具有名称‘dimension’。如果它不是一个`Attribute`，那么它将作为`*dim`传递给[`dimension()`](#sympy.codegen.fnodes.dimension "sympy.codegen.fnodes.dimension")

**intent**：str

> 其中之一：‘in’、‘out’、‘inout’或无

****kwargs:**

> `Variable`的关键字参数（‘type’和‘value’）

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.ast import integer, real
>>> from sympy.codegen.fnodes import array
>>> arr = array('a', '*', 'in', type=integer)
>>> print(fcode(arr.as_Declaration(), source_format='free', standard=2003))
integer*4, dimension(*), intent(in) :: a
>>> x = array('x', [3, ':', ':'], intent='out', type=real)
>>> print(fcode(x.as_Declaration(value=1), source_format='free', standard=2003))
real*8, dimension(3, :, :), intent(out) :: x = 1 
```

```py
sympy.codegen.fnodes.bind_C(name=None)
```

创建一个带有名称的属性`bind_C`。

参数：

**name**：str

示例

```py
>>> from sympy import fcode, Symbol
>>> from sympy.codegen.ast import FunctionDefinition, real, Return
>>> from sympy.codegen.fnodes import array, sum_, bind_C
>>> a = Symbol('a', real=True)
>>> s = Symbol('s', integer=True)
>>> arr = array(a, dim=[s], intent='in')
>>> body = [Return((sum_(a**2)/s)**.5)]
>>> fd = FunctionDefinition(real, 'rms', [arr, s], body, attrs=[bind_C('rms')])
>>> print(fcode(fd, source_format='free', standard=2003))
real*8 function rms(a, s) bind(C, name="rms")
real*8, dimension(s), intent(in) :: a
integer*4 :: s
rms = sqrt(sum(a**2)/s)
end function 
```

```py
class sympy.codegen.fnodes.cmplx(*args)
```

Fortran复数转换函数。

```py
sympy.codegen.fnodes.dimension(*args)
```

创建一个带有（最多7个）范围的‘dimension’属性。

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import dimension, intent_in
>>> dim = dimension('2', ':')  # 2 rows, runtime determined number of columns
>>> from sympy.codegen.ast import Variable, integer
>>> arr = Variable('a', integer, attrs=[dim, intent_in])
>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)
'integer*4, dimension(2, :), intent(in) :: a' 
```

```py
class sympy.codegen.fnodes.dsign(*args)
```

用于双精度参数的Fortran符号内置函数。

```py
class sympy.codegen.fnodes.isign(*args)
```

用于整数参数的Fortran符号内置函数。

```py
class sympy.codegen.fnodes.kind(*args)
```

Fortran kind函数。

```py
sympy.codegen.fnodes.lbound(array, dim=None, kind=None)
```

为Fortran的“lbound(…)”创建一个函数调用的AST节点。

参数：

**array**：符号或字符串

**dim**：表达式

**kind**：表达式

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import lbound
>>> lb = lbound('arr', dim=2)
>>> fcode(lb, source_format='free')
'lbound(arr, 2)' 
```

```py
class sympy.codegen.fnodes.literal_dp(num, dps=None, precision=None)
```

Fortran双精度实数字面量

```py
class sympy.codegen.fnodes.literal_sp(num, dps=None, precision=None)
```

Fortran单精度实数字面量

```py
class sympy.codegen.fnodes.merge(*args)
```

Fortran合并函数

```py
sympy.codegen.fnodes.reshape(source, shape, pad=None, order=None)
```

为Fortran的“reshape(…)”创建一个函数调用的AST节点。

参数：

**source**：符号或字符串

**shape**：ArrayExpr

```py
sympy.codegen.fnodes.shape(source, kind=None)
```

为Fortran的“shape(…)”创建一个函数调用的AST节点。

参数：

**source**：符号或字符串

**kind**：表达式

示例

```py
>>> from sympy import fcode
>>> from sympy.codegen.fnodes import shape
>>> shp = shape('x')
>>> fcode(shp, source_format='free')
'shape(x)' 
```

```py
sympy.codegen.fnodes.size(array, dim=None, kind=None)
```

为Fortran的“size(…)”创建一个函数调用的AST节点。

示例

```py
>>> from sympy import fcode, Symbol
>>> from sympy.codegen.ast import FunctionDefinition, real, Return
>>> from sympy.codegen.fnodes import array, sum_, size
>>> a = Symbol('a', real=True)
>>> body = [Return((sum_(a**2)/size(a))**.5)]
>>> arr = array(a, dim=[':'], intent='in')
>>> fd = FunctionDefinition(real, 'rms', [arr], body)
>>> print(fcode(fd, source_format='free', standard=2003))
real*8 function rms(a)
real*8, dimension(:), intent(in) :: a
rms = sqrt(sum(a**2)*1d0/size(a))
end function 
```

```py
class sympy.codegen.fnodes.use(*args, **kwargs)
```

表示Fortran中的use语句。

示例

```py
>>> from sympy.codegen.fnodes import use
>>> from sympy import fcode
>>> fcode(use('signallib'), source_format='free')
'use signallib'
>>> fcode(use('signallib', [('metric', 'snr')]), source_format='free')
'use signallib, metric => snr'
>>> fcode(use('signallib', only=['snr', 'convolution2d']), source_format='free')
'use signallib, only: snr, convolution2d' 
```

```py
class sympy.codegen.fnodes.use_rename(*args, **kwargs)
```

表示Fortran中use语句中的重命名。

示例

```py
>>> from sympy.codegen.fnodes import use_rename, use
>>> from sympy import fcode
>>> ren = use_rename("thingy", "convolution2d")
>>> print(fcode(ren, source_format='free'))
thingy => convolution2d
>>> full = use('signallib', only=['snr', ren])
>>> print(fcode(full, source_format='free'))
use signallib, only: snr, thingy => convolution2d 
```  ## 算法（sympy.codegen.algorithms）

```py
sympy.codegen.algorithms.newtons_method(expr, wrt, atol=1e-12, delta=None, *, rtol=4e-16, debug=False, itermax=None, counter=None, delta_fn=<function <lambda>>, cse=False, handle_nan=None, bounds=None)
```

为Newton-Raphson方法（一种寻根算法）生成AST。

参数：

**expr**：表达式

**wrt**：符号

> 关于，即变量是什么。

**atol**：数字或表达式

> 绝对容差（停止准则）

**rtol** : 数字或表达式

> 相对容差（停止准则）

**delta** : 符号

> 如果为 `None`，将是一个 `Dummy`。

**debug** : 布尔值

> 是否在迭代过程中打印收敛信息

**itermax** : 数字或表达式

> 迭代的最大次数。

**counter** : 符号

> 如果为 `None`，将是一个 `Dummy`。

**delta_fn: Callable[[Expr, Symbol], Expr]**

> 计算步骤，默认为牛顿法。例如，对于 Halley 方法，使用 `delta_fn=lambda e, x: -2*e*e.diff(x)/(2*e.diff(x)**2 - e*e.diff(x, 2))`

**cse: 布尔值**

> 在 `delta` 表达式上执行常见子表达式消除

**handle_nan: 令牌**

> 如何处理非数值（NaN）的出现。

**bounds: Optional[tuple[Expr, Expr]]**

> 在界限内执行优化

解释

基于 `sympy.codegen.ast` 生成的牛顿法根查找的抽象语法树（AST）。

示例

```py
>>> from sympy import symbols, cos
>>> from sympy.codegen.ast import Assignment
>>> from sympy.codegen.algorithms import newtons_method
>>> x, dx, atol = symbols('x dx atol')
>>> expr = cos(x) - x**3
>>> algo = newtons_method(expr, x, atol=atol, delta=dx)
>>> algo.has(Assignment(dx, -expr/expr.diff(x)))
True 
```

参考

[[R40](#id3)]

[https://en.wikipedia.org/wiki/Newton%27s_method](https://en.wikipedia.org/wiki/Newton%27s_method)

```py
sympy.codegen.algorithms.newtons_method_function(expr, wrt, params=None, func_name='newton', attrs=(), *, delta=None, **kwargs)
```

生成实现牛顿-拉弗森方法的函数的 AST。

参数：

**expr** : 表达式

**wrt** : 符号

> 关于，即是变量是什么

**params** : 符号的可迭代对象

> 在表达式中出现且在迭代过程中被视为常数的符号（这些将被接受为生成函数的参数）。

**func_name** : 字符串

> 生成函数的名称。

**attrs** : 元组

> 传递给 `FunctionDefinition` 的 `attrs` 属性实例。

****kwargs :**

> 传递给 [`sympy.codegen.algorithms.newtons_method()`](#sympy.codegen.algorithms.newtons_method "sympy.codegen.algorithms.newtons_method") 的关键字参数。

示例

```py
>>> from sympy import symbols, cos
>>> from sympy.codegen.algorithms import newtons_method_function
>>> from sympy.codegen.pyutils import render_as_module
>>> x = symbols('x')
>>> expr = cos(x) - x**3
>>> func = newtons_method_function(expr, x)
>>> py_mod = render_as_module(func)  # source code as string
>>> namespace = {}
>>> exec(py_mod, namespace, namespace)
>>> res = eval('newton(0.5)', namespace)
>>> abs(res - 0.865474033102) < 1e-12
True 
```

参见

[`sympy.codegen.algorithms.newtons_method`](#sympy.codegen.algorithms.newtons_method "sympy.codegen.algorithms.newtons_method")  ## Python 实用工具（sympy.codegen.pyutils）

```py
sympy.codegen.pyutils.render_as_module(content, standard='python3')
```

将 Python 代码呈现为模块（带有必要的导入）。

参数：

**standard :**

> 查看 [`sympy.printing.pycode.pycode()`](printing.html#sympy.printing.pycode.pycode "sympy.printing.pycode.pycode") 中的参数`standard`  ## C 实用工具（sympy.codegen.cutils）

```py
sympy.codegen.cutils.render_as_source_file(content, Printer=<class 'sympy.printing.c.C99CodePrinter'>, settings=None)
```

渲染为 C 源文件（带有必要的 #include 语句）  ## Fortran 实用工具（sympy.codegen.futils）

```py
sympy.codegen.futils.render_as_module(definitions, name, declarations=(), printer_settings=None)
```

创建 `Module` 实例并将其呈现为字符串。

这将生成带有正确 `use` 语句的 Fortran 源代码模块。

参数：

**definitions** : 可迭代对象

> 传递给 [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module")。

**name** : 字符串

> 传递给 [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module")。

**declarations** : 可迭代对象

> 传递给 [`sympy.codegen.fnodes.Module`](#sympy.codegen.fnodes.Module "sympy.codegen.fnodes.Module")。它将通过 `definitions` 生成 `use` 语句、‘implicit none’ 和 public 列表扩展。

**printer_settings** : 字典

> 传递给 `FCodePrinter`（默认：`{'standard': 2003, 'source_format': 'free'}`）。
