["```py\nclass scipy.stats.gaussian_kde(dataset, bw_method=None, weights=None)\n```", "```py\nn**(-1./(d+4)), \n```", "```py\nneff**(-1./(d+4)), \n```", "```py\n(n * (d + 2) / 4.)**(-1. / (d + 4)). \n```", "```py\n(neff * (d + 2) / 4.)**(-1. / (d + 4)). \n```", "```py\nneff = sum(weights)^2 / sum(weights^2) \n```", "```py\n>>> import numpy as np\n>>> from scipy import stats\n>>> def measure(n):\n...     \"Measurement model, return two coupled measurements.\"\n...     m1 = np.random.normal(size=n)\n...     m2 = np.random.normal(scale=0.5, size=n)\n...     return m1+m2, m1-m2 \n```", "```py\n>>> m1, m2 = measure(2000)\n>>> xmin = m1.min()\n>>> xmax = m1.max()\n>>> ymin = m2.min()\n>>> ymax = m2.max() \n```", "```py\n>>> X, Y = np.mgrid[xmin:xmax:100j, ymin:ymax:100j]\n>>> positions = np.vstack([X.ravel(), Y.ravel()])\n>>> values = np.vstack([m1, m2])\n>>> kernel = stats.gaussian_kde(values)\n>>> Z = np.reshape(kernel(positions).T, X.shape) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> fig, ax = plt.subplots()\n>>> ax.imshow(np.rot90(Z), cmap=plt.cm.gist_earth_r,\n...           extent=[xmin, xmax, ymin, ymax])\n>>> ax.plot(m1, m2, 'k.', markersize=2)\n>>> ax.set_xlim([xmin, xmax])\n>>> ax.set_ylim([ymin, ymax])\n>>> plt.show() \n```"]