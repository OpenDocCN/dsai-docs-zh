["```py\nIn [1]: dtypes = [\n ...:    \"int64\",\n ...:    \"float64\",\n ...:    \"datetime64[ns]\",\n ...:    \"timedelta64[ns]\",\n ...:    \"complex128\",\n ...:    \"object\",\n ...:    \"bool\",\n ...: ]\n ...: \n\nIn [2]: n = 5000\n\nIn [3]: data = {t: np.random.randint(100, size=n).astype(t) for t in dtypes}\n\nIn [4]: df = pd.DataFrame(data)\n\nIn [5]: df[\"categorical\"] = df[\"object\"].astype(\"category\")\n\nIn [6]: df.info()\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5000 entries, 0 to 4999\nData columns (total 8 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   int64            5000 non-null   int64 \n 1   float64          5000 non-null   float64 \n 2   datetime64[ns]   5000 non-null   datetime64[ns] \n 3   timedelta64[ns]  5000 non-null   timedelta64[ns]\n 4   complex128       5000 non-null   complex128 \n 5   object           5000 non-null   object \n 6   bool             5000 non-null   bool \n 7   categorical      5000 non-null   category \ndtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)\nmemory usage: 288.2+ KB \n```", "```py\nIn [7]: df.info(memory_usage=\"deep\")\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5000 entries, 0 to 4999\nData columns (total 8 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   int64            5000 non-null   int64 \n 1   float64          5000 non-null   float64 \n 2   datetime64[ns]   5000 non-null   datetime64[ns] \n 3   timedelta64[ns]  5000 non-null   timedelta64[ns]\n 4   complex128       5000 non-null   complex128 \n 5   object           5000 non-null   object \n 6   bool             5000 non-null   bool \n 7   categorical      5000 non-null   category \ndtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)\nmemory usage: 424.7 KB \n```", "```py\nIn [8]: df.memory_usage()\nOut[8]: \nIndex                128\nint64              40000\nfloat64            40000\ndatetime64[ns]     40000\ntimedelta64[ns]    40000\ncomplex128         80000\nobject             40000\nbool                5000\ncategorical         9968\ndtype: int64\n\n# total memory usage of dataframe\nIn [9]: df.memory_usage().sum()\nOut[9]: 295096 \n```", "```py\nIn [10]: df.memory_usage(index=False)\nOut[10]: \nint64              40000\nfloat64            40000\ndatetime64[ns]     40000\ntimedelta64[ns]    40000\ncomplex128         80000\nobject             40000\nbool                5000\ncategorical         9968\ndtype: int64 \n```", "```py\n>>> if pd.Series([False, True, False]):\n...     pass \n```", "```py\nIn [11]: if pd.Series([False, True, False]):\n ....:    print(\"I was true\")\n ....: \n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\n<ipython-input-11-5c782b38cd2f> in ?()\n----> 1 if pd.Series([False, True, False]):\n  2     print(\"I was true\")\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self)\n  1575     @final\n  1576     def __nonzero__(self) -> NoReturn:\n-> 1577         raise ValueError(\n  1578             f\"The truth value of a {type(self).__name__} is ambiguous. \"\n  1579             \"Use a.empty, a.bool(), a.item(), a.any() or a.all().\"\n  1580         )\n\nValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). \n```", "```py\nIn [12]: if pd.Series([False, True, False]) is not None:\n ....:    print(\"I was not None\")\n ....: \nI was not None \n```", "```py\nIn [13]: if pd.Series([False, True, False]).any():\n ....:    print(\"I am any\")\n ....: \nI am any \n```", "```py\nIn [14]: s = pd.Series(range(5))\n\nIn [15]: s == 4\nOut[15]: \n0    False\n1    False\n2    False\n3    False\n4     True\ndtype: bool \n```", "```py\nIn [16]: s = pd.Series(range(5), index=list(\"abcde\"))\n\nIn [17]: 2 in s\nOut[17]: False\n\nIn [18]: 'b' in s\nOut[18]: True \n```", "```py\nIn [19]: s.isin([2])\nOut[19]: \na    False\nb    False\nc     True\nd    False\ne    False\ndtype: bool\n\nIn [20]: s.isin([2]).any()\nOut[20]: True \n```", "```py\nIn [21]: values = [0, 1, 2, 3, 4, 5]\n\nIn [22]: n_removed = 0\n\nIn [23]: for k, value in enumerate(values):\n ....:    idx = k - n_removed\n ....:    if value % 2 == 1:\n ....:        del values[idx]\n ....:        n_removed += 1\n ....:    else:\n ....:        values[idx] = value + 1\n ....: \n\nIn [24]: values\nOut[24]: [1, 4, 5] \n```", "```py\nIn [25]: def f(s):\n ....:    s.pop(\"a\")\n ....:    return s\n ....: \n\nIn [26]: df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n\nIn [27]: df.apply(f, axis=\"columns\")\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n  3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n  3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'a'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[27], line 1\n----> 1 df.apply(f, axis=\"columns\")\n\nFile ~/work/pandas/pandas/pandas/core/frame.py:10374, in DataFrame.apply(self, func, axis, raw, result_type, args, by_row, engine, engine_kwargs, **kwargs)\n  10360 from pandas.core.apply import frame_apply\n  10362 op = frame_apply(\n  10363     self,\n  10364     func=func,\n   (...)\n  10372     kwargs=kwargs,\n  10373 )\n> 10374 return op.apply().__finalize__(self, method=\"apply\")\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:916, in FrameApply.apply(self)\n  913 elif self.raw:\n  914     return self.apply_raw(engine=self.engine, engine_kwargs=self.engine_kwargs)\n--> 916 return self.apply_standard()\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:1063, in FrameApply.apply_standard(self)\n  1061 def apply_standard(self):\n  1062     if self.engine == \"python\":\n-> 1063         results, res_index = self.apply_series_generator()\n  1064     else:\n  1065         results, res_index = self.apply_series_numba()\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:1081, in FrameApply.apply_series_generator(self)\n  1078 with option_context(\"mode.chained_assignment\", None):\n  1079     for i, v in enumerate(series_gen):\n  1080         # ignore SettingWithCopy here in case the user mutates\n-> 1081         results[i] = self.func(v, *self.args, **self.kwargs)\n  1082         if isinstance(results[i], ABCSeries):\n  1083             # If we have a view on v, we need to make a copy because\n  1084             #  series_generator will swap out the underlying data\n  1085             results[i] = results[i].copy(deep=False)\n\nCell In[25], line 2, in f(s)\n  1 def f(s):\n----> 2     s.pop(\"a\")\n  3     return s\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5391, in Series.pop(self, item)\n  5366 def pop(self, item: Hashable) -> Any:\n  5367  \"\"\"\n  5368 Return item and drops from series. Raise KeyError if not found.\n  5369  \n (...)\n  5389 dtype: int64\n  5390 \"\"\"\n-> 5391     return super().pop(item=item)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:947, in NDFrame.pop(self, item)\n  946 def pop(self, item: Hashable) -> Series | Any:\n--> 947     result = self[item]\n  948     del self[item]\n  950     return result\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)\n  1118     return self._values[key]\n  1120 elif key_is_scalar:\n-> 1121     return self._get_value(key)\n  1123 # Convert generator to list before going through hashable part\n  1124 # (We will iterate through the generator there to check for slices)\n  1125 if is_iterator(key):\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)\n  1234     return self._values[label]\n  1236 # Similar to Index.get_value, but we do not fall back to positional\n-> 1237 loc = self.index.get_loc(label)\n  1239 if is_integer(loc):\n  1240     return self._values[loc]\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n  3807     if isinstance(casted_key, slice) or (\n  3808         isinstance(casted_key, abc.Iterable)\n  3809         and any(isinstance(x, slice) for x in casted_key)\n  3810     ):\n  3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n  3813 except TypeError:\n  3814     # If we have a listlike key, _check_indexing_error will raise\n  3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n  3816     #  the TypeError.\n  3817     self._check_indexing_error(key)\n\nKeyError: 'a' \n```", "```py\nIn [28]: values = [0, 1, 2, 3, 4, 5]\n\nIn [29]: n_removed = 0\n\nIn [30]: for k, value in enumerate(values.copy()):\n ....:    idx = k - n_removed\n ....:    if value % 2 == 1:\n ....:        del values[idx]\n ....:        n_removed += 1\n ....:    else:\n ....:        values[idx] = value + 1\n ....: \n\nIn [31]: values\nOut[31]: [1, 3, 5] \n```", "```py\nIn [32]: def f(s):\n ....:    s = s.copy()\n ....:    s.pop(\"a\")\n ....:    return s\n ....: \n\nIn [33]: df = pd.DataFrame({\"a\": [1, 2, 3], 'b': [4, 5, 6]})\n\nIn [34]: df.apply(f, axis=\"columns\")\nOut[34]: \n b\n0  4\n1  5\n2  6 \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"))\n\nIn [36]: s\nOut[36]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n\nIn [37]: s.dtype\nOut[37]: dtype('int64')\n\nIn [38]: s2 = s.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [39]: s2\nOut[39]: \na    1.0\nb    2.0\nc    3.0\nf    NaN\nu    NaN\ndtype: float64\n\nIn [40]: s2.dtype\nOut[40]: dtype('float64') \n```", "```py\nIn [41]: s_int = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"), dtype=pd.Int64Dtype())\n\nIn [42]: s_int\nOut[42]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: Int64\n\nIn [43]: s_int.dtype\nOut[43]: Int64Dtype()\n\nIn [44]: s2_int = s_int.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [45]: s2_int\nOut[45]: \na       1\nb       2\nc       3\nf    <NA>\nu    <NA>\ndtype: Int64\n\nIn [46]: s2_int.dtype\nOut[46]: Int64Dtype()\n\nIn [47]: s_int_pa = pd.Series([1, 2, None], dtype=\"int64[pyarrow]\")\n\nIn [48]: s_int_pa\nOut[48]: \n0       1\n1       2\n2    <NA>\ndtype: int64[pyarrow] \n```", "```py\nTraceback\n    ...\nValueError: Big-endian buffer not supported on little-endian compiler \n```", "```py\nIn [49]: x = np.array(list(range(10)), \">i4\")  # big endian\n\nIn [50]: newx = x.byteswap().view(x.dtype.newbyteorder())  # force native byteorder\n\nIn [51]: s = pd.Series(newx) \n```", "```py\nIn [1]: dtypes = [\n ...:    \"int64\",\n ...:    \"float64\",\n ...:    \"datetime64[ns]\",\n ...:    \"timedelta64[ns]\",\n ...:    \"complex128\",\n ...:    \"object\",\n ...:    \"bool\",\n ...: ]\n ...: \n\nIn [2]: n = 5000\n\nIn [3]: data = {t: np.random.randint(100, size=n).astype(t) for t in dtypes}\n\nIn [4]: df = pd.DataFrame(data)\n\nIn [5]: df[\"categorical\"] = df[\"object\"].astype(\"category\")\n\nIn [6]: df.info()\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5000 entries, 0 to 4999\nData columns (total 8 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   int64            5000 non-null   int64 \n 1   float64          5000 non-null   float64 \n 2   datetime64[ns]   5000 non-null   datetime64[ns] \n 3   timedelta64[ns]  5000 non-null   timedelta64[ns]\n 4   complex128       5000 non-null   complex128 \n 5   object           5000 non-null   object \n 6   bool             5000 non-null   bool \n 7   categorical      5000 non-null   category \ndtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)\nmemory usage: 288.2+ KB \n```", "```py\nIn [7]: df.info(memory_usage=\"deep\")\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5000 entries, 0 to 4999\nData columns (total 8 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   int64            5000 non-null   int64 \n 1   float64          5000 non-null   float64 \n 2   datetime64[ns]   5000 non-null   datetime64[ns] \n 3   timedelta64[ns]  5000 non-null   timedelta64[ns]\n 4   complex128       5000 non-null   complex128 \n 5   object           5000 non-null   object \n 6   bool             5000 non-null   bool \n 7   categorical      5000 non-null   category \ndtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)\nmemory usage: 424.7 KB \n```", "```py\nIn [8]: df.memory_usage()\nOut[8]: \nIndex                128\nint64              40000\nfloat64            40000\ndatetime64[ns]     40000\ntimedelta64[ns]    40000\ncomplex128         80000\nobject             40000\nbool                5000\ncategorical         9968\ndtype: int64\n\n# total memory usage of dataframe\nIn [9]: df.memory_usage().sum()\nOut[9]: 295096 \n```", "```py\nIn [10]: df.memory_usage(index=False)\nOut[10]: \nint64              40000\nfloat64            40000\ndatetime64[ns]     40000\ntimedelta64[ns]    40000\ncomplex128         80000\nobject             40000\nbool                5000\ncategorical         9968\ndtype: int64 \n```", "```py\n>>> if pd.Series([False, True, False]):\n...     pass \n```", "```py\nIn [11]: if pd.Series([False, True, False]):\n ....:    print(\"I was true\")\n ....: \n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\n<ipython-input-11-5c782b38cd2f> in ?()\n----> 1 if pd.Series([False, True, False]):\n  2     print(\"I was true\")\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self)\n  1575     @final\n  1576     def __nonzero__(self) -> NoReturn:\n-> 1577         raise ValueError(\n  1578             f\"The truth value of a {type(self).__name__} is ambiguous. \"\n  1579             \"Use a.empty, a.bool(), a.item(), a.any() or a.all().\"\n  1580         )\n\nValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). \n```", "```py\nIn [12]: if pd.Series([False, True, False]) is not None:\n ....:    print(\"I was not None\")\n ....: \nI was not None \n```", "```py\nIn [13]: if pd.Series([False, True, False]).any():\n ....:    print(\"I am any\")\n ....: \nI am any \n```", "```py\nIn [14]: s = pd.Series(range(5))\n\nIn [15]: s == 4\nOut[15]: \n0    False\n1    False\n2    False\n3    False\n4     True\ndtype: bool \n```", "```py\nIn [16]: s = pd.Series(range(5), index=list(\"abcde\"))\n\nIn [17]: 2 in s\nOut[17]: False\n\nIn [18]: 'b' in s\nOut[18]: True \n```", "```py\nIn [19]: s.isin([2])\nOut[19]: \na    False\nb    False\nc     True\nd    False\ne    False\ndtype: bool\n\nIn [20]: s.isin([2]).any()\nOut[20]: True \n```", "```py\nIn [14]: s = pd.Series(range(5))\n\nIn [15]: s == 4\nOut[15]: \n0    False\n1    False\n2    False\n3    False\n4     True\ndtype: bool \n```", "```py\nIn [16]: s = pd.Series(range(5), index=list(\"abcde\"))\n\nIn [17]: 2 in s\nOut[17]: False\n\nIn [18]: 'b' in s\nOut[18]: True \n```", "```py\nIn [19]: s.isin([2])\nOut[19]: \na    False\nb    False\nc     True\nd    False\ne    False\ndtype: bool\n\nIn [20]: s.isin([2]).any()\nOut[20]: True \n```", "```py\nIn [21]: values = [0, 1, 2, 3, 4, 5]\n\nIn [22]: n_removed = 0\n\nIn [23]: for k, value in enumerate(values):\n ....:    idx = k - n_removed\n ....:    if value % 2 == 1:\n ....:        del values[idx]\n ....:        n_removed += 1\n ....:    else:\n ....:        values[idx] = value + 1\n ....: \n\nIn [24]: values\nOut[24]: [1, 4, 5] \n```", "```py\nIn [25]: def f(s):\n ....:    s.pop(\"a\")\n ....:    return s\n ....: \n\nIn [26]: df = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n\nIn [27]: df.apply(f, axis=\"columns\")\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n  3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n  3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'a'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[27], line 1\n----> 1 df.apply(f, axis=\"columns\")\n\nFile ~/work/pandas/pandas/pandas/core/frame.py:10374, in DataFrame.apply(self, func, axis, raw, result_type, args, by_row, engine, engine_kwargs, **kwargs)\n  10360 from pandas.core.apply import frame_apply\n  10362 op = frame_apply(\n  10363     self,\n  10364     func=func,\n   (...)\n  10372     kwargs=kwargs,\n  10373 )\n> 10374 return op.apply().__finalize__(self, method=\"apply\")\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:916, in FrameApply.apply(self)\n  913 elif self.raw:\n  914     return self.apply_raw(engine=self.engine, engine_kwargs=self.engine_kwargs)\n--> 916 return self.apply_standard()\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:1063, in FrameApply.apply_standard(self)\n  1061 def apply_standard(self):\n  1062     if self.engine == \"python\":\n-> 1063         results, res_index = self.apply_series_generator()\n  1064     else:\n  1065         results, res_index = self.apply_series_numba()\n\nFile ~/work/pandas/pandas/pandas/core/apply.py:1081, in FrameApply.apply_series_generator(self)\n  1078 with option_context(\"mode.chained_assignment\", None):\n  1079     for i, v in enumerate(series_gen):\n  1080         # ignore SettingWithCopy here in case the user mutates\n-> 1081         results[i] = self.func(v, *self.args, **self.kwargs)\n  1082         if isinstance(results[i], ABCSeries):\n  1083             # If we have a view on v, we need to make a copy because\n  1084             #  series_generator will swap out the underlying data\n  1085             results[i] = results[i].copy(deep=False)\n\nCell In[25], line 2, in f(s)\n  1 def f(s):\n----> 2     s.pop(\"a\")\n  3     return s\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5391, in Series.pop(self, item)\n  5366 def pop(self, item: Hashable) -> Any:\n  5367  \"\"\"\n  5368 Return item and drops from series. Raise KeyError if not found.\n  5369  \n (...)\n  5389 dtype: int64\n  5390 \"\"\"\n-> 5391     return super().pop(item=item)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:947, in NDFrame.pop(self, item)\n  946 def pop(self, item: Hashable) -> Series | Any:\n--> 947     result = self[item]\n  948     del self[item]\n  950     return result\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)\n  1118     return self._values[key]\n  1120 elif key_is_scalar:\n-> 1121     return self._get_value(key)\n  1123 # Convert generator to list before going through hashable part\n  1124 # (We will iterate through the generator there to check for slices)\n  1125 if is_iterator(key):\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)\n  1234     return self._values[label]\n  1236 # Similar to Index.get_value, but we do not fall back to positional\n-> 1237 loc = self.index.get_loc(label)\n  1239 if is_integer(loc):\n  1240     return self._values[loc]\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n  3807     if isinstance(casted_key, slice) or (\n  3808         isinstance(casted_key, abc.Iterable)\n  3809         and any(isinstance(x, slice) for x in casted_key)\n  3810     ):\n  3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n  3813 except TypeError:\n  3814     # If we have a listlike key, _check_indexing_error will raise\n  3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n  3816     #  the TypeError.\n  3817     self._check_indexing_error(key)\n\nKeyError: 'a' \n```", "```py\nIn [28]: values = [0, 1, 2, 3, 4, 5]\n\nIn [29]: n_removed = 0\n\nIn [30]: for k, value in enumerate(values.copy()):\n ....:    idx = k - n_removed\n ....:    if value % 2 == 1:\n ....:        del values[idx]\n ....:        n_removed += 1\n ....:    else:\n ....:        values[idx] = value + 1\n ....: \n\nIn [31]: values\nOut[31]: [1, 3, 5] \n```", "```py\nIn [32]: def f(s):\n ....:    s = s.copy()\n ....:    s.pop(\"a\")\n ....:    return s\n ....: \n\nIn [33]: df = pd.DataFrame({\"a\": [1, 2, 3], 'b': [4, 5, 6]})\n\nIn [34]: df.apply(f, axis=\"columns\")\nOut[34]: \n b\n0  4\n1  5\n2  6 \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"))\n\nIn [36]: s\nOut[36]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n\nIn [37]: s.dtype\nOut[37]: dtype('int64')\n\nIn [38]: s2 = s.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [39]: s2\nOut[39]: \na    1.0\nb    2.0\nc    3.0\nf    NaN\nu    NaN\ndtype: float64\n\nIn [40]: s2.dtype\nOut[40]: dtype('float64') \n```", "```py\nIn [41]: s_int = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"), dtype=pd.Int64Dtype())\n\nIn [42]: s_int\nOut[42]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: Int64\n\nIn [43]: s_int.dtype\nOut[43]: Int64Dtype()\n\nIn [44]: s2_int = s_int.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [45]: s2_int\nOut[45]: \na       1\nb       2\nc       3\nf    <NA>\nu    <NA>\ndtype: Int64\n\nIn [46]: s2_int.dtype\nOut[46]: Int64Dtype()\n\nIn [47]: s_int_pa = pd.Series([1, 2, None], dtype=\"int64[pyarrow]\")\n\nIn [48]: s_int_pa\nOut[48]: \n0       1\n1       2\n2    <NA>\ndtype: int64[pyarrow] \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"))\n\nIn [36]: s\nOut[36]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\n\nIn [37]: s.dtype\nOut[37]: dtype('int64')\n\nIn [38]: s2 = s.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [39]: s2\nOut[39]: \na    1.0\nb    2.0\nc    3.0\nf    NaN\nu    NaN\ndtype: float64\n\nIn [40]: s2.dtype\nOut[40]: dtype('float64') \n```", "```py\nIn [41]: s_int = pd.Series([1, 2, 3, 4, 5], index=list(\"abcde\"), dtype=pd.Int64Dtype())\n\nIn [42]: s_int\nOut[42]: \na    1\nb    2\nc    3\nd    4\ne    5\ndtype: Int64\n\nIn [43]: s_int.dtype\nOut[43]: Int64Dtype()\n\nIn [44]: s2_int = s_int.reindex([\"a\", \"b\", \"c\", \"f\", \"u\"])\n\nIn [45]: s2_int\nOut[45]: \na       1\nb       2\nc       3\nf    <NA>\nu    <NA>\ndtype: Int64\n\nIn [46]: s2_int.dtype\nOut[46]: Int64Dtype()\n\nIn [47]: s_int_pa = pd.Series([1, 2, None], dtype=\"int64[pyarrow]\")\n\nIn [48]: s_int_pa\nOut[48]: \n0       1\n1       2\n2    <NA>\ndtype: int64[pyarrow] \n```", "```py\nTraceback\n    ...\nValueError: Big-endian buffer not supported on little-endian compiler \n```", "```py\nIn [49]: x = np.array(list(range(10)), \">i4\")  # big endian\n\nIn [50]: newx = x.byteswap().view(x.dtype.newbyteorder())  # force native byteorder\n\nIn [51]: s = pd.Series(newx) \n```"]