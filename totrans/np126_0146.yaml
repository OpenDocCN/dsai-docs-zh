- en: Scalars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/arrays.scalars.html](https://numpy.org/doc/1.26/reference/arrays.scalars.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python defines only one type of a particular data class (there is only one integer
    type, one floating-point type, etc.). This can be convenient in applications that
    don’t need to be concerned with all the ways data can be represented in a computer.
    For scientific computing, however, more control is often needed.
  prefs: []
  type: TYPE_NORMAL
- en: In NumPy, there are 24 new fundamental Python types to describe different types
    of scalars. These type descriptors are mostly based on the types available in
    the C language that CPython is written in, with several additional types compatible
    with Python’s types.
  prefs: []
  type: TYPE_NORMAL
- en: Array scalars have the same attributes and methods as [`ndarrays`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"). [[1]](#id2) This allows one to treat items of an array partly
    on the same footing as arrays, smoothing out rough edges that result when mixing
    scalar and array operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Array scalars live in a hierarchy (see the Figure below) of data types. They
    can be detected using the hierarchy: For example, `isinstance(val, np.generic)`
    will return [`True`](https://docs.python.org/3/library/constants.html#True "(in
    Python v3.11)") if *val* is an array scalar object. Alternatively, what kind of
    array scalar is present can be determined using other members of the data type
    hierarchy. Thus, for example `isinstance(val, np.complexfloating)` will return
    [`True`](https://docs.python.org/3/library/constants.html#True "(in Python v3.11)")
    if *val* is a complex valued type, while `isinstance(val, np.flexible)` will return
    true if *val* is one of the flexible itemsize array types ([`str_`](#numpy.str_
    "numpy.str_"), [`bytes_`](#numpy.bytes_ "numpy.bytes_"), [`void`](#numpy.void
    "numpy.void")).'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/dtype-hierarchy.png](../Images/7c6cf11ea6e16cb6d111ce6f854872c4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure:** Hierarchy of type objects representing the array data types. Not
    shown are the two integer types [`intp`](#numpy.intp "numpy.intp") and [`uintp`](#numpy.uintp
    "numpy.uintp") which just point to the integer type that holds a pointer for the
    platform. All the number types can be obtained using bit-width names as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Built-in scalar types'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in scalar types are shown below. The C-like names are associated with
    character codes, which are shown in their descriptions. Use of the character codes,
    however, is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the scalar types are essentially equivalent to fundamental Python types
    and therefore inherit from them as well as from the generic array scalar type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Array scalar type | Related Python type | Inherits? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`int_`](#numpy.int_ "numpy.int_") | [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") | Python 2 only |'
  prefs: []
  type: TYPE_TB
- en: '| [`float_`](#numpy.float_ "numpy.float_") | [`float`](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`complex_`](#numpy.complex_ "numpy.complex_") | [`complex`](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`bytes_`](#numpy.bytes_ "numpy.bytes_") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`str_`](#numpy.str_ "numpy.str_") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`bool_`](#numpy.bool_ "numpy.bool_") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: '| [`datetime64`](#numpy.datetime64 "numpy.datetime64") | [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: '| [`timedelta64`](#numpy.timedelta64 "numpy.timedelta64") | [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: The [`bool_`](#numpy.bool_ "numpy.bool_") data type is very similar to the Python
    [`bool`](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
    but does not inherit from it because Python’s [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") does not allow itself to be inherited from, and on the C-level
    the size of the actual bool data is not the same as a Python Boolean scalar.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`int_`](#numpy.int_ "numpy.int_") type does **not** inherit from the [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") built-in under Python 3, because type [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") is no longer a fixed-width integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The default data type in NumPy is [`float_`](#numpy.float_ "numpy.float_").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Base class for numpy scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Class from which most (all?) numpy scalar types are derived. For consistency,
    exposes the same API as [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), despite many consequent attributes being either “get-only,”
    or completely irrelevant. This is the class from which it is strongly suggested
    users should derive custom scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all numeric scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The numpy integer types mirror the behavior of C integers, and can therefore
    be subject to [Overflow Errors](../user/basics.types.html#overflow-errors).
  prefs: []
  type: TYPE_NORMAL
- en: Signed integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all signed integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''b''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int8`](#numpy.int8 "numpy.int8"): 8-bit signed integer (`-128` to `127`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''h''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int16`](#numpy.int16 "numpy.int16"): 16-bit signed integer (`-32_768`
    to `32_767`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''i''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int32`](#numpy.int32 "numpy.int32"): 32-bit signed integer (`-2_147_483_648`
    to `2_147_483_647`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with Python *int* and C `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''l''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int64`](#numpy.int64 "numpy.int64"): 64-bit signed integer (`-9_223_372_036_854_775_808`
    to `9_223_372_036_854_775_807`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.intp`](#numpy.intp "numpy.intp"): Signed integer large enough to fit
    pointer, compatible with C `intptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all unsigned integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''B''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint8`](#numpy.uint8 "numpy.uint8"): 8-bit unsigned integer (`0` to
    `255`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''H''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint16`](#numpy.uint16 "numpy.uint16"): 16-bit unsigned integer (`0`
    to `65_535`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''I''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint32`](#numpy.uint32 "numpy.uint32"): 32-bit unsigned integer (`0`
    to `4_294_967_295`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''L''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint64`](#numpy.uint64 "numpy.uint64"): 64-bit unsigned integer (`0`
    to `18_446_744_073_709_551_615`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uintp`](#numpy.uintp "numpy.uintp"): Unsigned integer large enough
    to fit pointer, compatible with C `uintptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `unsigned long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''Q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Inexact types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all numeric scalar types with a (potentially) inexact
    representation of the values in its range, such as floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inexact scalars are printed using the fewest decimal digits needed to distinguish
    their value from other values of the same datatype, by judicious rounding. See
    the `unique` parameter of [`format_float_positional`](generated/numpy.format_float_positional.html#numpy.format_float_positional
    "numpy.format_float_positional") and [`format_float_scientific`](generated/numpy.format_float_scientific.html#numpy.format_float_scientific
    "numpy.format_float_scientific").
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that variables with equal binary values but whose datatypes are
    of different precisions may display differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that none of these floats hold the exact value \(\frac{1}{10}\); `f16`
    prints as `0.1` because it is as close to that value as possible, whereas the
    other types do not as they have more precision and therefore have closer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, floating-point scalars of different precisions which approximate
    the same decimal value may compare unequal despite printing identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all floating-point scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision floating-point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''e''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float16`](#numpy.float16 "numpy.float16"): 16-bit-precision floating-point
    number type: sign bit, 5 bits exponent, 10 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Single-precision floating-point number type, compatible with C `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''f''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float32`](#numpy.float32 "numpy.float32"): 32-bit-precision floating-point
    number type: sign bit, 8 bits exponent, 23 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Double-precision floating-point number type, compatible with Python *float*
    and C `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''d''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float_`](#numpy.float_ "numpy.float_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float64`](#numpy.float64 "numpy.float64"): 64-bit precision floating-point
    number type: sign bit, 11 bits exponent, 52 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Extended-precision floating-point number type, compatible with C `long double`
    but not necessarily with IEEE 754 quadruple-precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''g''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longfloat`](#numpy.longfloat "numpy.longfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float128`](#numpy.float128 "numpy.float128"): 128-bit extended-precision
    floating-point number type.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all complex number scalar types that are made up of floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two single-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''F''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.singlecomplex`](#numpy.singlecomplex "numpy.singlecomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex64`](#numpy.complex64 "numpy.complex64"): Complex number type
    composed of 2 32-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two double-precision floating-point numbers,
    compatible with Python *complex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''D''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.cfloat`](#numpy.cfloat "numpy.cfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex_`](#numpy.complex_ "numpy.complex_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex128`](#numpy.complex128 "numpy.complex128"): Complex number
    type composed of 2 64-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two extended-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''G''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.clongfloat`](#numpy.clongfloat "numpy.clongfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longcomplex`](#numpy.longcomplex "numpy.longcomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex256`](#numpy.complex256 "numpy.complex256"): Complex number
    type composed of 2 128-bit extended-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Other types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Boolean type (True or False), stored as a byte.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`bool_`](#numpy.bool_ "numpy.bool_") type is not a subclass of the [`int_`](#numpy.int_
    "numpy.int_") type (the [`bool_`](#numpy.bool_ "numpy.bool_") is not even a number
    type). This is different than Python’s default implementation of [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") as a sub-class of [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''?''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If created from a 64-bit integer, it represents an offset from `1970-01-01T00:00:00`.
    If created from string, the string can be in ISO 8601 date or datetime format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''M''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A timedelta stored as a 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''m''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''O''`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The data actually stored in object arrays (*i.e.*, arrays having dtype [`object_`](#numpy.object_
    "numpy.object_")) are references to Python objects, not the objects themselves.
    Hence, object arrays behave more like usual Python [`lists`](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.11)"), in the sense that their contents need not be of the same
    Python type.
  prefs: []
  type: TYPE_NORMAL
- en: The object type is also special because an array containing [`object_`](#numpy.object_
    "numpy.object_") items does not return an [`object_`](#numpy.object_ "numpy.object_")
    object on item access, but instead returns the actual object that the array item
    refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following data types are **flexible**: they have no predefined size and
    the data they describe can be of different length in different arrays. (In the
    character codes `#` is an integer denoting how many elements the data type consists
    of.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all scalar types without predefined length. The actual
    size of these types depends on the specific *np.dtype* instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all character string scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A byte string.
  prefs: []
  type: TYPE_NORMAL
- en: When used in arrays, this type strips trailing null bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''S''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.string_`](#numpy.string_ "numpy.string_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A unicode string.
  prefs: []
  type: TYPE_NORMAL
- en: This type strips trailing null codepoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the builtin *str*, this supports the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html#bufferobjects
    "(in Python v3.11)"), exposing its contents as UCS4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''U''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.unicode_`](#numpy.unicode_ "numpy.unicode_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create a new structured or unstructured void scalar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length_or_data**int, array-like, bytes-like, object'
  prefs: []
  type: TYPE_NORMAL
- en: One of multiple meanings (see notes). The length or bytes data of an unstructured
    void. Or alternatively, the data to be stored in the new scalar when [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") is provided. This can be an array-like, in which case an array
    may be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**dtype, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided the dtype of the new scalar. This dtype must be “void” dtype (i.e.
    a structured or unstructured void, see also [Structured Datatypes](../user/basics.rec.html#defining-structured-types)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '..versionadded:: 1.24'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'For historical reasons and because void scalars can represent both arbitrary
    byte data and structured dtypes, the void constructor has three calling conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.void(5)` creates a `dtype="V5"` scalar filled with five `\0` bytes. The
    5 can be a Python or NumPy integer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`np.void(b"bytes-like")` creates a void scalar from the byte string. The dtype
    itemsize will match the byte string length, here `"V10"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a `dtype=` is passed the call is roughly the same as an array creation.
    However, a void scalar rather than array is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see the examples which show all three different conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''V''`'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: See [Note on string types](arrays.dtypes.html#string-dtype-note).
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric Compatibility: If you used old typecode characters in your Numeric
    code (which was never recommended), you will need to change some of them to the
    new characters. In particular, the needed changes are `c -> S1`, `b -> B`, `1
    -> b`, `s -> h`, `w -> H`, and `u -> I`. These changes make the type character
    convention more consistent with other Python modules such as the [`struct`](https://docs.python.org/3/library/struct.html#module-struct
    "(in Python v3.11)") module.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Sized aliases'
  prefs: []
  type: TYPE_NORMAL
- en: Along with their (mostly) C-derived names, the integer, float, and complex data-types
    are also available using a bit-width convention so that an array of the right
    size can always be ensured. Two aliases ([`numpy.intp`](#numpy.intp "numpy.intp")
    and [`numpy.uintp`](#numpy.uintp "numpy.uintp")) pointing to the integer type
    that is sufficiently large to hold a C pointer are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Aliases for the signed integer types (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and [`numpy.longlong`](#numpy.longlong
    "numpy.longlong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `int8_t`, `int16_t`, `int32_t`, and `int64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer types (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and [`numpy.ulonglong`](#numpy.ulonglong
    "numpy.ulonglong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `uint8_t`, `uint16_t`, `uint32_t`, and `uint64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the signed integer type (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and *np.longlong*) that is the same size
    as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `intptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''p''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer type (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and *np.ulonglong*) that is the same
    size as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `uintptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''P''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`half`](#numpy.half "numpy.half")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`single`](#numpy.single "numpy.single")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.longdouble`](#numpy.longdouble "numpy.longdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.clongdouble`](#numpy.clongdouble "numpy.clongdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Other aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first two of these are conveniences which resemble the names of the builtin
    types, in the same style as [`bool_`](#numpy.bool_ "numpy.bool_"), [`int_`](#numpy.int_
    "numpy.int_"), [`str_`](#numpy.str_ "numpy.str_"), [`bytes_`](#numpy.bytes_ "numpy.bytes_"),
    and [`object_`](#numpy.object_ "numpy.object_"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more use alternate naming conventions for extended-precision floats and
    complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`longdouble`](#numpy.longdouble "numpy.longdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: The following aliases originate from Python 2, and it is recommended that they
    not be used in new code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`bytes_`](#numpy.bytes_ "numpy.bytes_")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`str_`](#numpy.str_ "numpy.str_")
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The array scalar objects have an [`array priority`](arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") of [`NPY_SCALAR_PRIORITY`](c-api/array.html#c.NPY_SCALAR_PRIORITY
    "NPY_SCALAR_PRIORITY") (-1,000,000.0). They also do not (yet) have a [`ctypes`](generated/numpy.ndarray.ctypes.html#numpy.ndarray.ctypes
    "numpy.ndarray.ctypes") attribute. Otherwise, they share the same attributes as
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`generic.flags`](generated/numpy.generic.flags.html#numpy.generic.flags
    "numpy.generic.flags") | The integer value of flags. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.shape`](generated/numpy.generic.shape.html#numpy.generic.shape
    "numpy.generic.shape") | Tuple of array dimensions. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.strides`](generated/numpy.generic.strides.html#numpy.generic.strides
    "numpy.generic.strides") | Tuple of bytes steps in each dimension. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.ndim`](generated/numpy.generic.ndim.html#numpy.generic.ndim "numpy.generic.ndim")
    | The number of array dimensions. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.data`](generated/numpy.generic.data.html#numpy.generic.data "numpy.generic.data")
    | Pointer to start of data. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.size`](generated/numpy.generic.size.html#numpy.generic.size "numpy.generic.size")
    | The number of elements in the gentype. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.itemsize`](generated/numpy.generic.itemsize.html#numpy.generic.itemsize
    "numpy.generic.itemsize") | The length of one element in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.base`](generated/numpy.generic.base.html#numpy.generic.base "numpy.generic.base")
    | Scalar attribute identical to the corresponding array attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.dtype`](generated/numpy.generic.dtype.html#numpy.generic.dtype
    "numpy.generic.dtype") | Get array data-descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.real`](generated/numpy.generic.real.html#numpy.generic.real "numpy.generic.real")
    | The real part of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.imag`](generated/numpy.generic.imag.html#numpy.generic.imag "numpy.generic.imag")
    | The imaginary part of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.flat`](generated/numpy.generic.flat.html#numpy.generic.flat "numpy.generic.flat")
    | A 1-D view of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.T`](generated/numpy.generic.T.html#numpy.generic.T "numpy.generic.T")
    | Scalar attribute identical to the corresponding array attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_interface__`](generated/numpy.generic.__array_interface__.html#numpy.generic.__array_interface__
    "numpy.generic.__array_interface__") | Array protocol: Python side |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_struct__`](generated/numpy.generic.__array_struct__.html#numpy.generic.__array_struct__
    "numpy.generic.__array_struct__") | Array protocol: struct |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_priority__`](generated/numpy.generic.__array_priority__.html#numpy.generic.__array_priority__
    "numpy.generic.__array_priority__") | Array priority. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_wrap__`](generated/numpy.generic.__array_wrap__.html#numpy.generic.__array_wrap__
    "numpy.generic.__array_wrap__") | sc.__array_wrap__(obj) return scalar from array
    |'
  prefs: []
  type: TYPE_TB
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexing routines](arrays.indexing.html#arrays-indexing), [Data type objects
    (dtype)](arrays.dtypes.html#arrays-dtypes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array scalars can be indexed like 0-dimensional arrays: if *x* is an array
    scalar,'
  prefs: []
  type: TYPE_NORMAL
- en: '`x[()]` returns a copy of array scalar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x[...]` returns a 0-dimensional [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x[''field-name'']` returns the array scalar in the field *field-name*. (*x*
    can have fields, for example, when it corresponds to a structured data type.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array scalars have exactly the same methods as arrays. The default behavior
    of these methods is to internally convert the scalar to an equivalent 0-dimensional
    array and to call the corresponding array method. In addition, math operations
    on array scalars are defined so that the same hardware flags are set and used
    to interpret the results as for [ufunc](ufuncs.html#ufuncs), so that the error
    state used for ufuncs also carries over to the math on array scalars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exceptions to the above rules are given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`generic.__array__`](generated/numpy.generic.__array__.html#numpy.generic.__array__
    "numpy.generic.__array__") | sc.__array__(dtype) return 0-dim array from scalar
    with specified dtype |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_wrap__`](generated/numpy.generic.__array_wrap__.html#numpy.generic.__array_wrap__
    "numpy.generic.__array_wrap__") | sc.__array_wrap__(obj) return scalar from array
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.squeeze`](generated/numpy.generic.squeeze.html#numpy.generic.squeeze
    "numpy.generic.squeeze") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.byteswap`](generated/numpy.generic.byteswap.html#numpy.generic.byteswap
    "numpy.generic.byteswap") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__reduce__`](generated/numpy.generic.__reduce__.html#numpy.generic.__reduce__
    "numpy.generic.__reduce__") | Helper for pickle. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__setstate__`](generated/numpy.generic.__setstate__.html#numpy.generic.__setstate__
    "numpy.generic.__setstate__") |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.setflags`](generated/numpy.generic.setflags.html#numpy.generic.setflags
    "numpy.generic.setflags") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: 'Utility method for typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`number.__class_getitem__`](generated/numpy.number.__class_getitem__.html#numpy.number.__class_getitem__
    "numpy.number.__class_getitem__")(item, /) | Return a parametrized wrapper around
    the [`number`](#numpy.number "numpy.number") type. |'
  prefs: []
  type: TYPE_TB
- en: Defining new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to effectively define a new array scalar type (apart from
    composing structured types [dtypes](arrays.dtypes.html#arrays-dtypes) from the
    built-in scalar types): One way is to simply subclass the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and overwrite the methods of interest. This will work to a degree,
    but internally certain behaviors are fixed by the data type of the array. To fully
    customize the data type of an array you need to define a new data-type, and register
    it with NumPy. Such new types can only be defined in C, using the [NumPy C-API](c-api/index.html#c-api).'
  prefs: []
  type: TYPE_NORMAL
- en: '## Built-in scalar types'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in scalar types are shown below. The C-like names are associated with
    character codes, which are shown in their descriptions. Use of the character codes,
    however, is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the scalar types are essentially equivalent to fundamental Python types
    and therefore inherit from them as well as from the generic array scalar type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Array scalar type | Related Python type | Inherits? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`int_`](#numpy.int_ "numpy.int_") | [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") | Python 2 only |'
  prefs: []
  type: TYPE_TB
- en: '| [`float_`](#numpy.float_ "numpy.float_") | [`float`](https://docs.python.org/3/library/functions.html#float
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`complex_`](#numpy.complex_ "numpy.complex_") | [`complex`](https://docs.python.org/3/library/functions.html#complex
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`bytes_`](#numpy.bytes_ "numpy.bytes_") | [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`str_`](#numpy.str_ "numpy.str_") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)") | yes |'
  prefs: []
  type: TYPE_TB
- en: '| [`bool_`](#numpy.bool_ "numpy.bool_") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: '| [`datetime64`](#numpy.datetime64 "numpy.datetime64") | [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: '| [`timedelta64`](#numpy.timedelta64 "numpy.timedelta64") | [`datetime.timedelta`](https://docs.python.org/3/library/datetime.html#datetime.timedelta
    "(in Python v3.11)") | no |'
  prefs: []
  type: TYPE_TB
- en: The [`bool_`](#numpy.bool_ "numpy.bool_") data type is very similar to the Python
    [`bool`](https://docs.python.org/3/library/functions.html#bool "(in Python v3.11)")
    but does not inherit from it because Python’s [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") does not allow itself to be inherited from, and on the C-level
    the size of the actual bool data is not the same as a Python Boolean scalar.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`int_`](#numpy.int_ "numpy.int_") type does **not** inherit from the [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") built-in under Python 3, because type [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)") is no longer a fixed-width integer type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The default data type in NumPy is [`float_`](#numpy.float_ "numpy.float_").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Base class for numpy scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Class from which most (all?) numpy scalar types are derived. For consistency,
    exposes the same API as [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), despite many consequent attributes being either “get-only,”
    or completely irrelevant. This is the class from which it is strongly suggested
    users should derive custom scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all numeric scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The numpy integer types mirror the behavior of C integers, and can therefore
    be subject to [Overflow Errors](../user/basics.types.html#overflow-errors).
  prefs: []
  type: TYPE_NORMAL
- en: Signed integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all signed integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''b''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int8`](#numpy.int8 "numpy.int8"): 8-bit signed integer (`-128` to `127`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''h''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int16`](#numpy.int16 "numpy.int16"): 16-bit signed integer (`-32_768`
    to `32_767`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''i''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int32`](#numpy.int32 "numpy.int32"): 32-bit signed integer (`-2_147_483_648`
    to `2_147_483_647`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with Python *int* and C `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''l''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int64`](#numpy.int64 "numpy.int64"): 64-bit signed integer (`-9_223_372_036_854_775_808`
    to `9_223_372_036_854_775_807`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.intp`](#numpy.intp "numpy.intp"): Signed integer large enough to fit
    pointer, compatible with C `intptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all unsigned integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''B''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint8`](#numpy.uint8 "numpy.uint8"): 8-bit unsigned integer (`0` to
    `255`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''H''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint16`](#numpy.uint16 "numpy.uint16"): 16-bit unsigned integer (`0`
    to `65_535`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''I''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint32`](#numpy.uint32 "numpy.uint32"): 32-bit unsigned integer (`0`
    to `4_294_967_295`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''L''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint64`](#numpy.uint64 "numpy.uint64"): 64-bit unsigned integer (`0`
    to `18_446_744_073_709_551_615`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uintp`](#numpy.uintp "numpy.uintp"): Unsigned integer large enough
    to fit pointer, compatible with C `uintptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `unsigned long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''Q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Inexact types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all numeric scalar types with a (potentially) inexact
    representation of the values in its range, such as floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inexact scalars are printed using the fewest decimal digits needed to distinguish
    their value from other values of the same datatype, by judicious rounding. See
    the `unique` parameter of [`format_float_positional`](generated/numpy.format_float_positional.html#numpy.format_float_positional
    "numpy.format_float_positional") and [`format_float_scientific`](generated/numpy.format_float_scientific.html#numpy.format_float_scientific
    "numpy.format_float_scientific").
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that variables with equal binary values but whose datatypes are
    of different precisions may display differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that none of these floats hold the exact value \(\frac{1}{10}\); `f16`
    prints as `0.1` because it is as close to that value as possible, whereas the
    other types do not as they have more precision and therefore have closer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, floating-point scalars of different precisions which approximate
    the same decimal value may compare unequal despite printing identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all floating-point scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision floating-point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''e''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float16`](#numpy.float16 "numpy.float16"): 16-bit-precision floating-point
    number type: sign bit, 5 bits exponent, 10 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Single-precision floating-point number type, compatible with C `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''f''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float32`](#numpy.float32 "numpy.float32"): 32-bit-precision floating-point
    number type: sign bit, 8 bits exponent, 23 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Double-precision floating-point number type, compatible with Python *float*
    and C `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''d''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float_`](#numpy.float_ "numpy.float_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float64`](#numpy.float64 "numpy.float64"): 64-bit precision floating-point
    number type: sign bit, 11 bits exponent, 52 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Extended-precision floating-point number type, compatible with C `long double`
    but not necessarily with IEEE 754 quadruple-precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''g''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longfloat`](#numpy.longfloat "numpy.longfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float128`](#numpy.float128 "numpy.float128"): 128-bit extended-precision
    floating-point number type.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all complex number scalar types that are made up of floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two single-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''F''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.singlecomplex`](#numpy.singlecomplex "numpy.singlecomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex64`](#numpy.complex64 "numpy.complex64"): Complex number type
    composed of 2 32-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two double-precision floating-point numbers,
    compatible with Python *complex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''D''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.cfloat`](#numpy.cfloat "numpy.cfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex_`](#numpy.complex_ "numpy.complex_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex128`](#numpy.complex128 "numpy.complex128"): Complex number
    type composed of 2 64-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two extended-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''G''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.clongfloat`](#numpy.clongfloat "numpy.clongfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longcomplex`](#numpy.longcomplex "numpy.longcomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex256`](#numpy.complex256 "numpy.complex256"): Complex number
    type composed of 2 128-bit extended-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Other types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Boolean type (True or False), stored as a byte.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`bool_`](#numpy.bool_ "numpy.bool_") type is not a subclass of the [`int_`](#numpy.int_
    "numpy.int_") type (the [`bool_`](#numpy.bool_ "numpy.bool_") is not even a number
    type). This is different than Python’s default implementation of [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") as a sub-class of [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''?''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: If created from a 64-bit integer, it represents an offset from `1970-01-01T00:00:00`.
    If created from string, the string can be in ISO 8601 date or datetime format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''M''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: A timedelta stored as a 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''m''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''O''`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The data actually stored in object arrays (*i.e.*, arrays having dtype [`object_`](#numpy.object_
    "numpy.object_")) are references to Python objects, not the objects themselves.
    Hence, object arrays behave more like usual Python [`lists`](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.11)"), in the sense that their contents need not be of the same
    Python type.
  prefs: []
  type: TYPE_NORMAL
- en: The object type is also special because an array containing [`object_`](#numpy.object_
    "numpy.object_") items does not return an [`object_`](#numpy.object_ "numpy.object_")
    object on item access, but instead returns the actual object that the array item
    refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following data types are **flexible**: they have no predefined size and
    the data they describe can be of different length in different arrays. (In the
    character codes `#` is an integer denoting how many elements the data type consists
    of.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all scalar types without predefined length. The actual
    size of these types depends on the specific *np.dtype* instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all character string scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: A byte string.
  prefs: []
  type: TYPE_NORMAL
- en: When used in arrays, this type strips trailing null bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''S''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.string_`](#numpy.string_ "numpy.string_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: A unicode string.
  prefs: []
  type: TYPE_NORMAL
- en: This type strips trailing null codepoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the builtin *str*, this supports the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html#bufferobjects
    "(in Python v3.11)"), exposing its contents as UCS4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''U''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.unicode_`](#numpy.unicode_ "numpy.unicode_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Create a new structured or unstructured void scalar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length_or_data**int, array-like, bytes-like, object'
  prefs: []
  type: TYPE_NORMAL
- en: One of multiple meanings (see notes). The length or bytes data of an unstructured
    void. Or alternatively, the data to be stored in the new scalar when [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") is provided. This can be an array-like, in which case an array
    may be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**dtype, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided the dtype of the new scalar. This dtype must be “void” dtype (i.e.
    a structured or unstructured void, see also [Structured Datatypes](../user/basics.rec.html#defining-structured-types)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '..versionadded:: 1.24'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'For historical reasons and because void scalars can represent both arbitrary
    byte data and structured dtypes, the void constructor has three calling conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.void(5)` creates a `dtype="V5"` scalar filled with five `\0` bytes. The
    5 can be a Python or NumPy integer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`np.void(b"bytes-like")` creates a void scalar from the byte string. The dtype
    itemsize will match the byte string length, here `"V10"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a `dtype=` is passed the call is roughly the same as an array creation.
    However, a void scalar rather than array is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see the examples which show all three different conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''V''`'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: See [Note on string types](arrays.dtypes.html#string-dtype-note).
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric Compatibility: If you used old typecode characters in your Numeric
    code (which was never recommended), you will need to change some of them to the
    new characters. In particular, the needed changes are `c -> S1`, `b -> B`, `1
    -> b`, `s -> h`, `w -> H`, and `u -> I`. These changes make the type character
    convention more consistent with other Python modules such as the [`struct`](https://docs.python.org/3/library/struct.html#module-struct
    "(in Python v3.11)") module.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Sized aliases'
  prefs: []
  type: TYPE_NORMAL
- en: Along with their (mostly) C-derived names, the integer, float, and complex data-types
    are also available using a bit-width convention so that an array of the right
    size can always be ensured. Two aliases ([`numpy.intp`](#numpy.intp "numpy.intp")
    and [`numpy.uintp`](#numpy.uintp "numpy.uintp")) pointing to the integer type
    that is sufficiently large to hold a C pointer are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Aliases for the signed integer types (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and [`numpy.longlong`](#numpy.longlong
    "numpy.longlong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `int8_t`, `int16_t`, `int32_t`, and `int64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer types (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and [`numpy.ulonglong`](#numpy.ulonglong
    "numpy.ulonglong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `uint8_t`, `uint16_t`, `uint32_t`, and `uint64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the signed integer type (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and *np.longlong*) that is the same size
    as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `intptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''p''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer type (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and *np.ulonglong*) that is the same
    size as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `uintptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''P''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`half`](#numpy.half "numpy.half")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`single`](#numpy.single "numpy.single")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.longdouble`](#numpy.longdouble "numpy.longdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.clongdouble`](#numpy.clongdouble "numpy.clongdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Other aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first two of these are conveniences which resemble the names of the builtin
    types, in the same style as [`bool_`](#numpy.bool_ "numpy.bool_"), [`int_`](#numpy.int_
    "numpy.int_"), [`str_`](#numpy.str_ "numpy.str_"), [`bytes_`](#numpy.bytes_ "numpy.bytes_"),
    and [`object_`](#numpy.object_ "numpy.object_"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more use alternate naming conventions for extended-precision floats and
    complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`longdouble`](#numpy.longdouble "numpy.longdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: The following aliases originate from Python 2, and it is recommended that they
    not be used in new code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`bytes_`](#numpy.bytes_ "numpy.bytes_")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`str_`](#numpy.str_ "numpy.str_")
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The numpy integer types mirror the behavior of C integers, and can therefore
    be subject to [Overflow Errors](../user/basics.types.html#overflow-errors).
  prefs: []
  type: TYPE_NORMAL
- en: Signed integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all signed integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''b''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int8`](#numpy.int8 "numpy.int8"): 8-bit signed integer (`-128` to `127`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''h''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int16`](#numpy.int16 "numpy.int16"): 16-bit signed integer (`-32_768`
    to `32_767`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''i''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int32`](#numpy.int32 "numpy.int32"): 32-bit signed integer (`-2_147_483_648`
    to `2_147_483_647`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with Python *int* and C `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''l''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int64`](#numpy.int64 "numpy.int64"): 64-bit signed integer (`-9_223_372_036_854_775_808`
    to `9_223_372_036_854_775_807`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.intp`](#numpy.intp "numpy.intp"): Signed integer large enough to fit
    pointer, compatible with C `intptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all unsigned integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''B''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint8`](#numpy.uint8 "numpy.uint8"): 8-bit unsigned integer (`0` to
    `255`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''H''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint16`](#numpy.uint16 "numpy.uint16"): 16-bit unsigned integer (`0`
    to `65_535`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''I''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint32`](#numpy.uint32 "numpy.uint32"): 32-bit unsigned integer (`0`
    to `4_294_967_295`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''L''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint64`](#numpy.uint64 "numpy.uint64"): 64-bit unsigned integer (`0`
    to `18_446_744_073_709_551_615`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uintp`](#numpy.uintp "numpy.uintp"): Unsigned integer large enough
    to fit pointer, compatible with C `uintptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `unsigned long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''Q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Signed integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all signed integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''b''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int8`](#numpy.int8 "numpy.int8"): 8-bit signed integer (`-128` to `127`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''h''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int16`](#numpy.int16 "numpy.int16"): 16-bit signed integer (`-32_768`
    to `32_767`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''i''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int32`](#numpy.int32 "numpy.int32"): 32-bit signed integer (`-2_147_483_648`
    to `2_147_483_647`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with Python *int* and C `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''l''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.int64`](#numpy.int64 "numpy.int64"): 64-bit signed integer (`-9_223_372_036_854_775_808`
    to `9_223_372_036_854_775_807`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.intp`](#numpy.intp "numpy.intp"): Signed integer large enough to fit
    pointer, compatible with C `intptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all unsigned integer scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''B''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint8`](#numpy.uint8 "numpy.uint8"): 8-bit unsigned integer (`0` to
    `255`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned short`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''H''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint16`](#numpy.uint16 "numpy.uint16"): 16-bit unsigned integer (`0`
    to `65_535`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''I''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint32`](#numpy.uint32 "numpy.uint32"): 32-bit unsigned integer (`0`
    to `4_294_967_295`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Unsigned integer type, compatible with C `unsigned long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''L''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uint64`](#numpy.uint64 "numpy.uint64"): 64-bit unsigned integer (`0`
    to `18_446_744_073_709_551_615`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.uintp`](#numpy.uintp "numpy.uintp"): Unsigned integer large enough
    to fit pointer, compatible with C `uintptr_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Signed integer type, compatible with C `unsigned long long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''Q''`'
  prefs: []
  type: TYPE_NORMAL
- en: Inexact types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all numeric scalar types with a (potentially) inexact
    representation of the values in its range, such as floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inexact scalars are printed using the fewest decimal digits needed to distinguish
    their value from other values of the same datatype, by judicious rounding. See
    the `unique` parameter of [`format_float_positional`](generated/numpy.format_float_positional.html#numpy.format_float_positional
    "numpy.format_float_positional") and [`format_float_scientific`](generated/numpy.format_float_scientific.html#numpy.format_float_scientific
    "numpy.format_float_scientific").
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that variables with equal binary values but whose datatypes are
    of different precisions may display differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Note that none of these floats hold the exact value \(\frac{1}{10}\); `f16`
    prints as `0.1` because it is as close to that value as possible, whereas the
    other types do not as they have more precision and therefore have closer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, floating-point scalars of different precisions which approximate
    the same decimal value may compare unequal despite printing identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all floating-point scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision floating-point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''e''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float16`](#numpy.float16 "numpy.float16"): 16-bit-precision floating-point
    number type: sign bit, 5 bits exponent, 10 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Single-precision floating-point number type, compatible with C `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''f''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float32`](#numpy.float32 "numpy.float32"): 32-bit-precision floating-point
    number type: sign bit, 8 bits exponent, 23 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Double-precision floating-point number type, compatible with Python *float*
    and C `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''d''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float_`](#numpy.float_ "numpy.float_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float64`](#numpy.float64 "numpy.float64"): 64-bit precision floating-point
    number type: sign bit, 11 bits exponent, 52 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Extended-precision floating-point number type, compatible with C `long double`
    but not necessarily with IEEE 754 quadruple-precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''g''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longfloat`](#numpy.longfloat "numpy.longfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float128`](#numpy.float128 "numpy.float128"): 128-bit extended-precision
    floating-point number type.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all complex number scalar types that are made up of floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two single-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''F''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.singlecomplex`](#numpy.singlecomplex "numpy.singlecomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex64`](#numpy.complex64 "numpy.complex64"): Complex number type
    composed of 2 32-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two double-precision floating-point numbers,
    compatible with Python *complex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''D''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.cfloat`](#numpy.cfloat "numpy.cfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex_`](#numpy.complex_ "numpy.complex_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex128`](#numpy.complex128 "numpy.complex128"): Complex number
    type composed of 2 64-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two extended-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''G''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.clongfloat`](#numpy.clongfloat "numpy.clongfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longcomplex`](#numpy.longcomplex "numpy.longcomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex256`](#numpy.complex256 "numpy.complex256"): Complex number
    type composed of 2 128-bit extended-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all floating-point scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Half-precision floating-point number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''e''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float16`](#numpy.float16 "numpy.float16"): 16-bit-precision floating-point
    number type: sign bit, 5 bits exponent, 10 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Single-precision floating-point number type, compatible with C `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''f''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float32`](#numpy.float32 "numpy.float32"): 32-bit-precision floating-point
    number type: sign bit, 8 bits exponent, 23 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Double-precision floating-point number type, compatible with Python *float*
    and C `double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''d''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float_`](#numpy.float_ "numpy.float_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float64`](#numpy.float64 "numpy.float64"): 64-bit precision floating-point
    number type: sign bit, 11 bits exponent, 52 bits mantissa.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Extended-precision floating-point number type, compatible with C `long double`
    but not necessarily with IEEE 754 quadruple-precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''g''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longfloat`](#numpy.longfloat "numpy.longfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.float128`](#numpy.float128 "numpy.float128"): 128-bit extended-precision
    floating-point number type.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex floating-point types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all complex number scalar types that are made up of floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two single-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''F''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.singlecomplex`](#numpy.singlecomplex "numpy.singlecomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex64`](#numpy.complex64 "numpy.complex64"): Complex number type
    composed of 2 32-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two double-precision floating-point numbers,
    compatible with Python *complex*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''D''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.cfloat`](#numpy.cfloat "numpy.cfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex_`](#numpy.complex_ "numpy.complex_")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex128`](#numpy.complex128 "numpy.complex128"): Complex number
    type composed of 2 64-bit-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Complex number type composed of two extended-precision floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''G''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.clongfloat`](#numpy.clongfloat "numpy.clongfloat")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.longcomplex`](#numpy.longcomplex "numpy.longcomplex")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias on this platform (Linux x86_64):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.complex256`](#numpy.complex256 "numpy.complex256"): Complex number
    type composed of 2 128-bit extended-precision floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Other types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Boolean type (True or False), stored as a byte.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`bool_`](#numpy.bool_ "numpy.bool_") type is not a subclass of the [`int_`](#numpy.int_
    "numpy.int_") type (the [`bool_`](#numpy.bool_ "numpy.bool_") is not even a number
    type). This is different than Python’s default implementation of [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.11)") as a sub-class of [`int`](https://docs.python.org/3/library/functions.html#int
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''?''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: If created from a 64-bit integer, it represents an offset from `1970-01-01T00:00:00`.
    If created from string, the string can be in ISO 8601 date or datetime format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''M''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: A timedelta stored as a 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: See [Datetimes and Timedeltas](arrays.datetime.html#arrays-datetime) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''m''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''O''`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The data actually stored in object arrays (*i.e.*, arrays having dtype [`object_`](#numpy.object_
    "numpy.object_")) are references to Python objects, not the objects themselves.
    Hence, object arrays behave more like usual Python [`lists`](https://docs.python.org/3/library/stdtypes.html#list
    "(in Python v3.11)"), in the sense that their contents need not be of the same
    Python type.
  prefs: []
  type: TYPE_NORMAL
- en: The object type is also special because an array containing [`object_`](#numpy.object_
    "numpy.object_") items does not return an [`object_`](#numpy.object_ "numpy.object_")
    object on item access, but instead returns the actual object that the array item
    refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following data types are **flexible**: they have no predefined size and
    the data they describe can be of different length in different arrays. (In the
    character codes `#` is an integer denoting how many elements the data type consists
    of.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all scalar types without predefined length. The actual
    size of these types depends on the specific *np.dtype* instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class of all character string scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: A byte string.
  prefs: []
  type: TYPE_NORMAL
- en: When used in arrays, this type strips trailing null bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''S''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.string_`](#numpy.string_ "numpy.string_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: A unicode string.
  prefs: []
  type: TYPE_NORMAL
- en: This type strips trailing null codepoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the builtin *str*, this supports the [Buffer Protocol](https://docs.python.org/3/c-api/buffer.html#bufferobjects
    "(in Python v3.11)"), exposing its contents as UCS4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''U''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.unicode_`](#numpy.unicode_ "numpy.unicode_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Create a new structured or unstructured void scalar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length_or_data**int, array-like, bytes-like, object'
  prefs: []
  type: TYPE_NORMAL
- en: One of multiple meanings (see notes). The length or bytes data of an unstructured
    void. Or alternatively, the data to be stored in the new scalar when [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") is provided. This can be an array-like, in which case an array
    may be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**dtype, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided the dtype of the new scalar. This dtype must be “void” dtype (i.e.
    a structured or unstructured void, see also [Structured Datatypes](../user/basics.rec.html#defining-structured-types)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '..versionadded:: 1.24'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'For historical reasons and because void scalars can represent both arbitrary
    byte data and structured dtypes, the void constructor has three calling conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.void(5)` creates a `dtype="V5"` scalar filled with five `\0` bytes. The
    5 can be a Python or NumPy integer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`np.void(b"bytes-like")` creates a void scalar from the byte string. The dtype
    itemsize will match the byte string length, here `"V10"`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a `dtype=` is passed the call is roughly the same as an array creation.
    However, a void scalar rather than array is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see the examples which show all three different conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''V''`'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: See [Note on string types](arrays.dtypes.html#string-dtype-note).
  prefs: []
  type: TYPE_NORMAL
- en: 'Numeric Compatibility: If you used old typecode characters in your Numeric
    code (which was never recommended), you will need to change some of them to the
    new characters. In particular, the needed changes are `c -> S1`, `b -> B`, `1
    -> b`, `s -> h`, `w -> H`, and `u -> I`. These changes make the type character
    convention more consistent with other Python modules such as the [`struct`](https://docs.python.org/3/library/struct.html#module-struct
    "(in Python v3.11)") module.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Sized aliases'
  prefs: []
  type: TYPE_NORMAL
- en: Along with their (mostly) C-derived names, the integer, float, and complex data-types
    are also available using a bit-width convention so that an array of the right
    size can always be ensured. Two aliases ([`numpy.intp`](#numpy.intp "numpy.intp")
    and [`numpy.uintp`](#numpy.uintp "numpy.uintp")) pointing to the integer type
    that is sufficiently large to hold a C pointer are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Aliases for the signed integer types (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and [`numpy.longlong`](#numpy.longlong
    "numpy.longlong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `int8_t`, `int16_t`, `int32_t`, and `int64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer types (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and [`numpy.ulonglong`](#numpy.ulonglong
    "numpy.ulonglong")) with the specified number of bits.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C99 `uint8_t`, `uint16_t`, `uint32_t`, and `uint64_t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the signed integer type (one of [`numpy.byte`](#numpy.byte "numpy.byte"),
    [`numpy.short`](#numpy.short "numpy.short"), [`numpy.intc`](#numpy.intc "numpy.intc"),
    [`numpy.int_`](#numpy.int_ "numpy.int_") and *np.longlong*) that is the same size
    as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `intptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''p''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Alias for the unsigned integer type (one of [`numpy.ubyte`](#numpy.ubyte "numpy.ubyte"),
    [`numpy.ushort`](#numpy.ushort "numpy.ushort"), [`numpy.uintc`](#numpy.uintc "numpy.uintc"),
    [`numpy.uint`](#numpy.uint "numpy.uint") and *np.ulonglong*) that is the same
    size as a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible with the C `uintptr_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Character code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''P''`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`half`](#numpy.half "numpy.half")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`single`](#numpy.single "numpy.single")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.longdouble`](#numpy.longdouble "numpy.longdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Alias for [`numpy.clongdouble`](#numpy.clongdouble "numpy.clongdouble"), named
    after its size in bits. The existence of these aliases depends on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Other aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first two of these are conveniences which resemble the names of the builtin
    types, in the same style as [`bool_`](#numpy.bool_ "numpy.bool_"), [`int_`](#numpy.int_
    "numpy.int_"), [`str_`](#numpy.str_ "numpy.str_"), [`bytes_`](#numpy.bytes_ "numpy.bytes_"),
    and [`object_`](#numpy.object_ "numpy.object_"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`double`](#numpy.double "numpy.double")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more use alternate naming conventions for extended-precision floats and
    complex numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`longdouble`](#numpy.longdouble "numpy.longdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`csingle`](#numpy.csingle "numpy.csingle")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`cdouble`](#numpy.cdouble "numpy.cdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`clongdouble`](#numpy.clongdouble "numpy.clongdouble")
  prefs: []
  type: TYPE_NORMAL
- en: The following aliases originate from Python 2, and it is recommended that they
    not be used in new code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`bytes_`](#numpy.bytes_ "numpy.bytes_")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`str_`](#numpy.str_ "numpy.str_")
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The array scalar objects have an [`array priority`](arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") of [`NPY_SCALAR_PRIORITY`](c-api/array.html#c.NPY_SCALAR_PRIORITY
    "NPY_SCALAR_PRIORITY") (-1,000,000.0). They also do not (yet) have a [`ctypes`](generated/numpy.ndarray.ctypes.html#numpy.ndarray.ctypes
    "numpy.ndarray.ctypes") attribute. Otherwise, they share the same attributes as
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`generic.flags`](generated/numpy.generic.flags.html#numpy.generic.flags
    "numpy.generic.flags") | The integer value of flags. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.shape`](generated/numpy.generic.shape.html#numpy.generic.shape
    "numpy.generic.shape") | Tuple of array dimensions. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.strides`](generated/numpy.generic.strides.html#numpy.generic.strides
    "numpy.generic.strides") | Tuple of bytes steps in each dimension. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.ndim`](generated/numpy.generic.ndim.html#numpy.generic.ndim "numpy.generic.ndim")
    | The number of array dimensions. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.data`](generated/numpy.generic.data.html#numpy.generic.data "numpy.generic.data")
    | Pointer to start of data. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.size`](generated/numpy.generic.size.html#numpy.generic.size "numpy.generic.size")
    | The number of elements in the gentype. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.itemsize`](generated/numpy.generic.itemsize.html#numpy.generic.itemsize
    "numpy.generic.itemsize") | The length of one element in bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.base`](generated/numpy.generic.base.html#numpy.generic.base "numpy.generic.base")
    | Scalar attribute identical to the corresponding array attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.dtype`](generated/numpy.generic.dtype.html#numpy.generic.dtype
    "numpy.generic.dtype") | Get array data-descriptor. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.real`](generated/numpy.generic.real.html#numpy.generic.real "numpy.generic.real")
    | The real part of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.imag`](generated/numpy.generic.imag.html#numpy.generic.imag "numpy.generic.imag")
    | The imaginary part of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.flat`](generated/numpy.generic.flat.html#numpy.generic.flat "numpy.generic.flat")
    | A 1-D view of the scalar. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.T`](generated/numpy.generic.T.html#numpy.generic.T "numpy.generic.T")
    | Scalar attribute identical to the corresponding array attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_interface__`](generated/numpy.generic.__array_interface__.html#numpy.generic.__array_interface__
    "numpy.generic.__array_interface__") | Array protocol: Python side |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_struct__`](generated/numpy.generic.__array_struct__.html#numpy.generic.__array_struct__
    "numpy.generic.__array_struct__") | Array protocol: struct |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_priority__`](generated/numpy.generic.__array_priority__.html#numpy.generic.__array_priority__
    "numpy.generic.__array_priority__") | Array priority. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_wrap__`](generated/numpy.generic.__array_wrap__.html#numpy.generic.__array_wrap__
    "numpy.generic.__array_wrap__") | sc.__array_wrap__(obj) return scalar from array
    |'
  prefs: []
  type: TYPE_TB
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexing routines](arrays.indexing.html#arrays-indexing), [Data type objects
    (dtype)](arrays.dtypes.html#arrays-dtypes)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array scalars can be indexed like 0-dimensional arrays: if *x* is an array
    scalar,'
  prefs: []
  type: TYPE_NORMAL
- en: '`x[()]` returns a copy of array scalar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x[...]` returns a 0-dimensional [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x[''field-name'']` returns the array scalar in the field *field-name*. (*x*
    can have fields, for example, when it corresponds to a structured data type.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array scalars have exactly the same methods as arrays. The default behavior
    of these methods is to internally convert the scalar to an equivalent 0-dimensional
    array and to call the corresponding array method. In addition, math operations
    on array scalars are defined so that the same hardware flags are set and used
    to interpret the results as for [ufunc](ufuncs.html#ufuncs), so that the error
    state used for ufuncs also carries over to the math on array scalars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exceptions to the above rules are given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`generic.__array__`](generated/numpy.generic.__array__.html#numpy.generic.__array__
    "numpy.generic.__array__") | sc.__array__(dtype) return 0-dim array from scalar
    with specified dtype |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__array_wrap__`](generated/numpy.generic.__array_wrap__.html#numpy.generic.__array_wrap__
    "numpy.generic.__array_wrap__") | sc.__array_wrap__(obj) return scalar from array
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.squeeze`](generated/numpy.generic.squeeze.html#numpy.generic.squeeze
    "numpy.generic.squeeze") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.byteswap`](generated/numpy.generic.byteswap.html#numpy.generic.byteswap
    "numpy.generic.byteswap") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__reduce__`](generated/numpy.generic.__reduce__.html#numpy.generic.__reduce__
    "numpy.generic.__reduce__") | Helper for pickle. |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.__setstate__`](generated/numpy.generic.__setstate__.html#numpy.generic.__setstate__
    "numpy.generic.__setstate__") |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`generic.setflags`](generated/numpy.generic.setflags.html#numpy.generic.setflags
    "numpy.generic.setflags") | Scalar method identical to the corresponding array
    attribute. |'
  prefs: []
  type: TYPE_TB
- en: 'Utility method for typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`number.__class_getitem__`](generated/numpy.number.__class_getitem__.html#numpy.number.__class_getitem__
    "numpy.number.__class_getitem__")(item, /) | Return a parametrized wrapper around
    the [`number`](#numpy.number "numpy.number") type. |'
  prefs: []
  type: TYPE_TB
- en: Defining new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to effectively define a new array scalar type (apart from
    composing structured types [dtypes](arrays.dtypes.html#arrays-dtypes) from the
    built-in scalar types): One way is to simply subclass the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and overwrite the methods of interest. This will work to a degree,
    but internally certain behaviors are fixed by the data type of the array. To fully
    customize the data type of an array you need to define a new data-type, and register
    it with NumPy. Such new types can only be defined in C, using the [NumPy C-API](c-api/index.html#c-api).'
  prefs: []
  type: TYPE_NORMAL
