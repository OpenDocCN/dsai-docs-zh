
<h1><span class="yiyi-st" id="yiyi-59">Array API</span></h1>
        <blockquote>
        <p>原文：<a href="https://docs.scipy.org/doc/numpy/reference/c-api.array.html">https://docs.scipy.org/doc/numpy/reference/c-api.array.html</a></p>
        <p>译者：<a href="https://github.com/wizardforcel">飞龙</a> <a href="http://usyiyi.cn/">UsyiyiCN</a></p>
        <p>校对：（虚位以待）</p>
        </blockquote>
    
<div class="line-block">
<div class="line"><span class="yiyi-st" id="yiyi-60">一级智力的测试是持有两个能力的能力</span></div>
<div class="line"><span class="yiyi-st" id="yiyi-61">反对思想在同一时间，仍然保留</span></div>
<div class="line"><span class="yiyi-st" id="yiyi-62">功能的能力。</span></div>
<div class="line"><span class="yiyi-st" id="yiyi-63">— <em>F. Scott Fitzgerald</em></span></div>
</div>
<div class="line-block">
<div class="line"><span class="yiyi-st" id="yiyi-64">对于成功的技术，现实必须优先于公众</span></div>
<div class="line"><span class="yiyi-st" id="yiyi-65">关系，对于自然不能被愚弄。</span></div>
<div class="line"><span class="yiyi-st" id="yiyi-66"> -  <em>Richard P. Feynman</em></span></div>
</div>
<div class="section" id="array-structure-and-data-access">
<span id="index-0"></span><h2><span class="yiyi-st" id="yiyi-67">Array structure and data access</span></h2>
<p><span class="yiyi-st" id="yiyi-68">这些宏都可以访问<a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code class="xref c c-type docutils literal"><span class="pre">PyArrayObject</span></code></a>结构成员。</span><span class="yiyi-st" id="yiyi-69">The input argument, arr, can be any <code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code> that is directly interpretable as a <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code class="xref c c-type docutils literal"><span class="pre">PyArrayObject</span> <span class="pre">*</span></code></a> (any instance of the <code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code> and its sub-types).</span></p>
<dl class="function">
<dt id="c.PyArray_NDIM"><span class="yiyi-st" id="yiyi-70"> int <code class="descname">PyArray_NDIM</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-71">数组中的维数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DIMS"><span class="yiyi-st" id="yiyi-72"> npy_intp *<code class="descname">PyArray_DIMS</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-73">返回指向数组的尺寸/形状的指针。</span><span class="yiyi-st" id="yiyi-74">元素的数量与数组的维数相匹配。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SHAPE"><span class="yiyi-st" id="yiyi-75"> npy_intp *<code class="descname">PyArray_SHAPE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-76"><span class="versionmodified">版本1.7中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-77">PyArray_DIMS的同义词，命名为与Python中的&apos;shape&apos;用法一致。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DATA"><span class="yiyi-st" id="yiyi-78"> void *<code class="descname">PyArray_DATA</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_BYTES"><span class="yiyi-st" id="yiyi-79"> char *<code class="descname">PyArray_BYTES</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-80">这两个宏是相似的，并获得指向数组的数据缓冲区的指针。</span><span class="yiyi-st" id="yiyi-81">第一个宏可以（并且应该）被分配给特定指针，其中第二个宏用于通用处理。</span><span class="yiyi-st" id="yiyi-82">如果你不能保证一个连续和/或对齐的数组，那么请确保你理解如何访问数组中的数据，以避免内存和/或对齐问题。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_STRIDES"><span class="yiyi-st" id="yiyi-83"> npy_intp *<code class="descname">PyArray_STRIDES</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-84">返回指向数组的步长的指针。</span><span class="yiyi-st" id="yiyi-85">元素的数量与数组的维数相匹配。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DIM"><span class="yiyi-st" id="yiyi-86"> npy_intp <code class="descname">PyArray_DIM</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-87">返回<em>n</em> <img alt="^{\textrm{th}}" class="math" src="../_images/math/c7201dfb8acbb9adb5fc06d19acb1604d16472f5.png" style="vertical-align: 6px">维中的形状。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_STRIDE"><span class="yiyi-st" id="yiyi-88"> npy_intp <code class="descname">PyArray_STRIDE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-89">返回<em>n</em> <img alt="^{\textrm{th}}" class="math" src="../_images/math/c7201dfb8acbb9adb5fc06d19acb1604d16472f5.png" style="vertical-align: 6px">维度中的步幅。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_BASE"><span class="yiyi-st" id="yiyi-90"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_BASE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-91">这将返回数组的基础对象。</span><span class="yiyi-st" id="yiyi-92">在大多数情况下，这意味着拥有数组正在指向的内存的对象。</span></p>
<p><span class="yiyi-st" id="yiyi-93">如果你正在使用C API构造一个数组，并指定你自己的内存，你应该使用函数<a class="reference internal" href="#c.PyArray_SetBaseObject" title="PyArray_SetBaseObject"><code class="xref c c-func docutils literal"><span class="pre">PyArray_SetBaseObject</span></code></a>将基址设置为拥有内存的对象。</span></p>
<p><span class="yiyi-st" id="yiyi-94">如果设置了<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>标志，则它具有不同的含义，即base是在销毁时将当前数组复制到其中的数组。</span><span class="yiyi-st" id="yiyi-95">这两个函数的基本属性的重载可能在未来版本的NumPy中改变。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DESCR"><span class="yiyi-st" id="yiyi-96"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a> *<code class="descname">PyArray_DESCR</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-97">返回对数组的dtype属性的借用引用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DTYPE"><span class="yiyi-st" id="yiyi-98"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a> *<code class="descname">PyArray_DTYPE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-99"><span class="versionmodified">版本1.7中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-100">PyArray_DESCR的同义词，命名为与Python中的&apos;dtype&apos;用法一致。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ENABLEFLAGS"><span class="yiyi-st" id="yiyi-101"> void <code class="descname">PyArray_ENABLEFLAGS</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> flags</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-102"><span class="versionmodified">版本1.7中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-103">启用指定的数组标志。</span><span class="yiyi-st" id="yiyi-104">这个函数没有验证，并假设你知道你在做什么。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CLEARFLAGS"><span class="yiyi-st" id="yiyi-105"> void <code class="descname">PyArray_CLEARFLAGS</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> flags</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-106"><span class="versionmodified">版本1.7中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-107">清除指定的数组标志。</span><span class="yiyi-st" id="yiyi-108">这个函数没有验证，并假设你知道你在做什么。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FLAGS"><span class="yiyi-st" id="yiyi-109"> int <code class="descname">PyArray_FLAGS</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ITEMSIZE"><span class="yiyi-st" id="yiyi-110"> npy_intp <code class="descname">PyArray_ITEMSIZE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-111">返回此数组元素的itemsize。</span></p>
<p><span class="yiyi-st" id="yiyi-112">请注意，在旧版本1.7中已弃用的API中，此函数的返回类型为<code class="docutils literal"><span class="pre">int</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_TYPE"><span class="yiyi-st" id="yiyi-113"> int <code class="descname">PyArray_TYPE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-114">返回此数组元素的（builtin）类型号。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GETITEM"><span class="yiyi-st" id="yiyi-115"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_GETITEM</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, void*<em> itemptr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-116">从ndarray中获取一个Python对象，<em>arr</em>，在itemptr指向的位置。</span><span class="yiyi-st" id="yiyi-117">失败时返回<code class="docutils literal"><span class="pre">NULL</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SETITEM"><span class="yiyi-st" id="yiyi-118"> int <code class="descname">PyArray_SETITEM</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, void*<em> itemptr</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-119">转换obj并将其放在ndarray中，<em>arr</em>，在itemptr指向的地方。</span><span class="yiyi-st" id="yiyi-120">如果发生错误，返回-1，否则返回0。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SIZE"><span class="yiyi-st" id="yiyi-121"> npy_intp <code class="descname">PyArray_SIZE</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-122">返回数组的总大小（以元素数表示）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Size"><span class="yiyi-st" id="yiyi-123"> npy_intp <code class="descname">PyArray_Size</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-124">如果<em>obj</em>不是bigndarray的子​​类，则返回0。</span><span class="yiyi-st" id="yiyi-125">否则，返回数组中元素的总数。</span><span class="yiyi-st" id="yiyi-126"><a class="reference internal" href="#c.PyArray_SIZE" title="PyArray_SIZE"><code class="xref c c-func docutils literal"><span class="pre">PyArray_SIZE</span></code></a>（<em>obj</em>）的安全版本。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_NBYTES"><span class="yiyi-st" id="yiyi-127"> npy_intp <code class="descname">PyArray_NBYTES</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-128">返回数组使用的总字节数。</span></p>
</dd></dl>
<div class="section" id="data-access">
<h3><span class="yiyi-st" id="yiyi-129">Data access</span></h3>
<p><span class="yiyi-st" id="yiyi-130">这些函数和宏提供容易访问ndarray的元素从C。这些工作对所有数组。</span><span class="yiyi-st" id="yiyi-131">你可能需要在访问数组中的数据时注意，但是，如果它不是机器字节顺序，未对齐或不可写。</span><span class="yiyi-st" id="yiyi-132">换句话说，一定要尊重标志的状态，除非你知道你在做什么，或者以前保证一个数组是可写，对齐的，并且使用<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>以机器字节顺序。</span><span class="yiyi-st" id="yiyi-133">如果你希望处理所有类型的数组，每种类型的copyswap函数对于处理不当数组是有用的。</span><span class="yiyi-st" id="yiyi-134">一些平台（例如Solaris）不喜欢错位的数据，如果你解引用一个未对齐的指针，会崩溃。</span><span class="yiyi-st" id="yiyi-135">其他平台（例如x86 Linux）只会在未对齐数据时工作速度较慢。</span></p>
<dl class="function">
<dt id="c.PyArray_GetPtr"><span class="yiyi-st" id="yiyi-136"> void* <code class="descname">PyArray_GetPtr</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> aobj</em>, npy_intp*<em> ind</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-137">在由c阵列<em>ind</em>给出的N维索引处返回指向ndarray的数据的指针<em>aobj</em>（其必须至少<em>aobj-nd大小）。</em></span><span class="yiyi-st" id="yiyi-138">你可能希望将返回的指针类型转换为ndarray的数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GETPTR1"><span class="yiyi-st" id="yiyi-139"> void* <code class="descname">PyArray_GETPTR1</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> obj</em>, npy_intp<em> i</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_GETPTR2"><span class="yiyi-st" id="yiyi-140"> void* <code class="descname">PyArray_GETPTR2</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> obj</em>, npy_intp<em> i</em>, npy_intp<em> j</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_GETPTR3"><span class="yiyi-st" id="yiyi-141"> void* <code class="descname">PyArray_GETPTR3</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> obj</em>, npy_intp<em> i</em>, npy_intp<em> j</em>, npy_intp<em> k</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_GETPTR4"><span class="yiyi-st" id="yiyi-142"> void* <code class="descname">PyArray_GETPTR4</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> obj</em>, npy_intp<em> i</em>, npy_intp<em> j</em>, npy_intp<em> k</em>, npy_intp<em> l</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-143">快速，内联访问在ndarray中给定坐标（<em>obj</em>）的元素，它必须分别具有1,2,3或4维（这不被选中）。</span><span class="yiyi-st" id="yiyi-144">对应的<em>i</em>，<em>j</em>，<em>k</em>和<em>l</em>可以是任何整数，但将被解释为<code class="docutils literal"><span class="pre">npy_intp</span></code>。</span><span class="yiyi-st" id="yiyi-145">你可能希望将返回的指针类型转换为ndarray的数据类型。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="creating-arrays">
<h2><span class="yiyi-st" id="yiyi-146">Creating arrays</span></h2>
<div class="section" id="from-scratch">
<h3><span class="yiyi-st" id="yiyi-147">From scratch</span></h3>
<dl class="function">
<dt id="c.PyArray_NewFromDescr"><span class="yiyi-st" id="yiyi-148"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_NewFromDescr</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/type.html#c.PyTypeObject" title="(in Python v3.7)">PyTypeObject</a>*<em> subtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em>, int<em> nd</em>, npy_intp*<em> dims</em>, npy_intp*<em> strides</em>, void*<em> data</em>, int<em> flags</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-149">此函数窃取对<em>descr</em>的引用。</span></p>
<p><span class="yiyi-st" id="yiyi-150">这是主要的数组创建功能。</span><span class="yiyi-st" id="yiyi-151">最新的数组是用这个灵活的函数创建的。</span></p>
<p><span class="yiyi-st" id="yiyi-152">返回的对象是Python类型<em>子类型</em>的对象，它必须是<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>的子类型。</span><span class="yiyi-st" id="yiyi-153">数组具有<em>nd</em>维度，由<em>dims</em>描述。</span><span class="yiyi-st" id="yiyi-154">新数组的数据类型描述符为<em>descr</em>。</span></p>
<p><span class="yiyi-st" id="yiyi-155">如果<em>子类型</em>是数组子类而不是基本<code class="xref c c-data docutils literal"><span class="pre">&amp;PyArray_Type</span></code>，则<em>obj</em>是要传递到<code class="xref py py-obj docutils literal"><span class="pre">__array_finalize__</span></code></span></p>
<p><span class="yiyi-st" id="yiyi-156">如果<em>data</em>为<code class="docutils literal"><span class="pre">NULL</span></code>，则将分配新的内存，并且<em>标志</em>可以为非零，以指示Fortran风格的连续数组。</span><span class="yiyi-st" id="yiyi-157">如果<em>数据</em>不是<code class="docutils literal"><span class="pre">NULL</span></code>，则假定指向要用于数组的存储器，并且使用<em>标志</em>参数作为数组的新标志（除了新数组的<code class="xref c c-data docutils literal"><span class="pre">NPY_OWNDATA</span></code>和<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>标志的状态将被复位）。</span></p>
<p><span class="yiyi-st" id="yiyi-158">另外，如果<em>数据</em>是非NULL，则也可以提供<em>步幅</em>。</span><span class="yiyi-st" id="yiyi-159">If <em>strides</em> is <code class="docutils literal"><span class="pre">NULL</span></code>, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (<em>flags</em> is nonzero for <em>data</em> = <code class="docutils literal"><span class="pre">NULL</span></code> or <em>flags</em> &amp; <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> is nonzero non-NULL <em>data</em>). </span><span class="yiyi-st" id="yiyi-160">任何提供的<em>dims</em>和<em>strides</em>都会复制到新分配的维度中，并且新建数组的数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_NewLikeArray"><span class="yiyi-st" id="yiyi-161"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_NewLikeArray</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> prototype</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em>, int<em> subok</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-162"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-163">如果它不为NULL，此函数将窃取对<em>descr</em>的引用。</span></p>
<p><span class="yiyi-st" id="yiyi-164">此数组创建例程允许方便地创建与现有数组的形状和存储器布局匹配的新数组，可能改变布局和/或数据类型。</span></p>
<p><span class="yiyi-st" id="yiyi-165">当<em>订单</em>是<a class="reference internal" href="#c.NPY_ANYORDER" title="NPY_ANYORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_ANYORDER</span></code></a>时，结果顺序为<a class="reference internal" href="#c.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_FORTRANORDER</span></code></a> if if <em>prototype</em> is fortran数组，<a class="reference internal" href="#c.NPY_CORDER" title="NPY_CORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_CORDER</span></code></a></span><span class="yiyi-st" id="yiyi-166">当<em>命令</em>为<a class="reference internal" href="#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_KEEPORDER</span></code></a>时，结果顺序与<em>原型</em>匹配，即使<em>原型</em>在C或Fortran顺序。</span></p>
<p><span class="yiyi-st" id="yiyi-167">如果<em>descr</em>为NULL，则使用<em>原型</em>的数据类型。</span></p>
<p><span class="yiyi-st" id="yiyi-168">如果<em>subok</em>为1，则新创建的数组将使用<em>原型</em>的子类型创建新数组，否则将创建基类数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_New"><span class="yiyi-st" id="yiyi-169"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_New</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/type.html#c.PyTypeObject" title="(in Python v3.7)">PyTypeObject</a>*<em> subtype</em>, int<em> nd</em>, npy_intp*<em> dims</em>, int<em> type_num</em>, npy_intp*<em> strides</em>, void*<em> data</em>, int<em> itemsize</em>, int<em> flags</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-170">这类似于<a class="reference internal" href="#c.PyArray_DescrNew" title="PyArray_DescrNew"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrNew</span></code></a>（...），除非你用<em>type_num</em>和<em>itemsize</em>指定数据类型描述符，其中<em>type_num 对应于内置（或用户定义）类型。</em></span><span class="yiyi-st" id="yiyi-171">如果类型总是具有相同的字节数，则忽略itemsize。</span><span class="yiyi-st" id="yiyi-172">否则，itemsize指定此数组的特定大小。</span></p>
</dd></dl>
<div class="admonition warning">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-173">警告</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-174">如果数据传递到<a class="reference internal" href="#c.PyArray_NewFromDescr" title="PyArray_NewFromDescr"><code class="xref c c-func docutils literal"><span class="pre">PyArray_NewFromDescr</span></code></a>或<a class="reference internal" href="#c.PyArray_New" title="PyArray_New"><code class="xref c c-func docutils literal"><span class="pre">PyArray_New</span></code></a>，则在删除新数组之前，不得重新分配此内存。</span><span class="yiyi-st" id="yiyi-175">如果此数据来自另一个Python对象，则可以使用该对象上的<a class="reference external" href="https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">Py_INCREF</span></code></a>来完成此操作，并将新数组的基本成员设置为指向该对象。</span><span class="yiyi-st" id="yiyi-176">如果传递步幅，它们必须与尺寸，项目大小和数组的数据一致。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_SimpleNew"><span class="yiyi-st" id="yiyi-177"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_SimpleNew</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-178">创建类型为<em>typenum</em>的新未初始化数组，其每个<em>和</em>维中的大小由整数数组<em>dims</em>给出。</span><span class="yiyi-st" id="yiyi-179">此函数不能用于创建一个灵活类型的数组（没有给定itemize）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SimpleNewFromData"><span class="yiyi-st" id="yiyi-180"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_SimpleNewFromData</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, int<em> typenum</em>, void*<em> data</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-181">在给定指针指向的<em>数据</em>周围创建一个数组包装。</span><span class="yiyi-st" id="yiyi-182">数组标志将具有默认值，即数据区域运行良好并且C型连续。</span><span class="yiyi-st" id="yiyi-183">数组的形状由长度<em>nd</em>的<em>dims</em> c-数组给出。</span><span class="yiyi-st" id="yiyi-184">数组的数据类型由<em>typenum</em>指示。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SimpleNewFromDescr"><span class="yiyi-st" id="yiyi-185"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_SimpleNewFromDescr</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-186">如果它不为NULL，此函数将窃取对<em>descr</em>的引用。</span></p>
<p><span class="yiyi-st" id="yiyi-187">使用提供的数据类型描述符<em>descr</em>创建由<em>nd</em>和<em>dims</em>确定的形状的新数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FILLWBYTE"><span class="yiyi-st" id="yiyi-188"> <code class="descname">PyArray_FILLWBYTE</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> val</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-189">填充由<em>obj</em>指向的数组 - 它必须是bigndarray的子​​类，其中<em>val</em>（作为字节计算）。</span><span class="yiyi-st" id="yiyi-190">这个宏调用memset，所以obj必须是连续的。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Zeros"><span class="yiyi-st" id="yiyi-191"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Zeros</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-192">使用由<em>dims</em>给出的形状和由<em>dtype</em>给出的数据类型构造新的<em>nd</em> -dimensional数组。</span><span class="yiyi-st" id="yiyi-193">如果<em>fortran</em>不为零，则创建Fortran顺序数组，否则创建C顺序数组。</span><span class="yiyi-st" id="yiyi-194">用零填充存储器（如果<em>dtype</em>对应于<a class="reference internal" href="c-api.dtype.html#c.NPY_OBJECT" title="NPY_OBJECT"><code class="xref c c-type docutils literal"><span class="pre">NPY_OBJECT</span></code></a>，则为0对象）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ZEROS"><span class="yiyi-st" id="yiyi-195"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ZEROS</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, int<em> type_num</em>, int<em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-196"><a class="reference internal" href="#c.PyArray_Zeros" title="PyArray_Zeros"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Zeros</span></code></a>的宏形式，它采用类型号而不是数据类型对象。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Empty"><span class="yiyi-st" id="yiyi-197"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Empty</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-198">使用由<em>dims</em>给出的形状和由<em>dtype</em>给出的数据类型构造新的<em>nd</em> -dimensional数组。</span><span class="yiyi-st" id="yiyi-199">如果<em>fortran</em>不为零，则创建Fortran顺序数组，否则创建C顺序数组。</span><span class="yiyi-st" id="yiyi-200">数组未初始化，除非数据类型对应于<a class="reference internal" href="c-api.dtype.html#c.NPY_OBJECT" title="NPY_OBJECT"><code class="xref c c-type docutils literal"><span class="pre">NPY_OBJECT</span></code></a>，在这种情况下数组用<a class="reference external" href="https://docs.python.org/dev/c-api/none.html#c.Py_None" title="(in Python v3.7)"><code class="xref c c-data docutils literal"><span class="pre">Py_None</span></code></a>填充。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EMPTY"><span class="yiyi-st" id="yiyi-201"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_EMPTY</code><span class="sig-paren">(</span>int<em> nd</em>, npy_intp*<em> dims</em>, int<em> typenum</em>, int<em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-202"><a class="reference internal" href="#c.PyArray_Empty" title="PyArray_Empty"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Empty</span></code></a>的宏形式，它采用类型号，<em>typenum</em>而不是数据类型对象。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Arange"><span class="yiyi-st" id="yiyi-203"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Arange</code><span class="sig-paren">(</span>double<em> start</em>, double<em> stop</em>, double<em> step</em>, int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-204">Construct a new 1-dimensional array of data-type, <em>typenum</em>, that ranges from <em>start</em> to <em>stop</em> (exclusive) in increments of <em>step</em> . </span><span class="yiyi-st" id="yiyi-205">等同于<strong>arange</strong>（<em>开始</em>，<em>停止</em>，<em>步骤</em>，dtype）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ArangeObj"><span class="yiyi-st" id="yiyi-206"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ArangeObj</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> start</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> stop</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> step</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-207">构建由<code class="docutils literal"><span class="pre">descr</span></code>确定的数据类型的新的1维数组，范围从<code class="docutils literal"><span class="pre">start</span></code>到<code class="docutils literal"><span class="pre">stop</span></code>（排除），增量为<code class="docutils literal"><span class="pre">step</span></code>。</span><span class="yiyi-st" id="yiyi-208">等于arange（<code class="docutils literal"><span class="pre">start</span></code>，<code class="docutils literal"><span class="pre">stop</span></code>，<code class="docutils literal"><span class="pre">step</span></code>，<code class="docutils literal"><span class="pre">typenum</span></code>）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SetBaseObject"><span class="yiyi-st" id="yiyi-209"> int <code class="descname">PyArray_SetBaseObject</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-210"><span class="versionmodified">版本1.7中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-211">此函数<strong>将引用</strong>挪到<code class="docutils literal"><span class="pre">obj</span></code>，并将其设置为<code class="docutils literal"><span class="pre">arr</span></code>的基本属性。</span></p>
<p><span class="yiyi-st" id="yiyi-212">如果你通过传入你自己的内存缓冲区作为参数来构造一个数组，你需要设置数组的<em class="xref py py-obj">base</em>属性，以确保内存缓冲区的生命周期是合适的。</span></p>
<p><span class="yiyi-st" id="yiyi-213">成功返回值为0，失败时返回-1。</span></p>
<p><span class="yiyi-st" id="yiyi-214">如果提供的对象是数组，则此函数遍历<em class="xref py py-obj">base</em>指针链，以使每个数组直接指向内存所有者。</span><span class="yiyi-st" id="yiyi-215">一旦基本设置，它可能不会更改为另一个值。</span></p>
</dd></dl>
</div>
<div class="section" id="from-other-objects">
<h3><span class="yiyi-st" id="yiyi-216">From other objects</span></h3>
<dl class="function">
<dt id="c.PyArray_FromAny"><span class="yiyi-st" id="yiyi-217"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromAny</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> min_depth</em>, int<em> max_depth</em>, int<em> requirements</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> context</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-218">这是用于从任何嵌套序列或暴露数组接口<em>op</em>的对象获取数组的主函数。</span><span class="yiyi-st" id="yiyi-219">The parameters allow specification of the required <em>dtype</em>, the minimum (<em>min_depth</em>) and maximum (<em>max_depth</em>) number of dimensions acceptable, and other <em>requirements</em> for the array. </span><span class="yiyi-st" id="yiyi-220"><em>dtype</em>参数需要是指示所需数据类型（包括所需的字节序）的<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span></code></a>结构。</span><span class="yiyi-st" id="yiyi-221"><em>dtype</em>参数可以为NULL，表示任​​何数据类型（和字节序）都是可以接受的。</span><span class="yiyi-st" id="yiyi-222">除非<code class="docutils literal"><span class="pre">flags</span></code>中存在<code class="docutils literal"><span class="pre">FORCECAST</span></code>，如果无法从对象安全获取数据类型，则此调用将生成错误。</span><span class="yiyi-st" id="yiyi-223">如果你想对<em>dtype</em>使用<code class="docutils literal"><span class="pre">NULL</span></code>，并确保数组没有被切换，请使用<a class="reference internal" href="#c.PyArray_CheckFromAny" title="PyArray_CheckFromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CheckFromAny</span></code></a>。</span><span class="yiyi-st" id="yiyi-224">任何深度参数的值为0将导致该参数被忽略。</span><span class="yiyi-st" id="yiyi-225">可以添加以下任何数组标志（<em>例如</em>使用|）以获取<em>需求</em>参数。</span><span class="yiyi-st" id="yiyi-226">如果您的代码可以处理一般（<em>例如</em> stride，字节交换或未对齐的数组），则<em>要求</em>可能为0。</span><span class="yiyi-st" id="yiyi-227">此外，如果<em>op</em>不是数组（或不公开数组接口），则将创建一个新数组（并使用序列协议从<em>op</em>填充） 。</span><span class="yiyi-st" id="yiyi-228">新数组将具有<code class="xref c c-data docutils literal"><span class="pre">NPY_DEFAULT</span></code>作为其标志成员。</span><span class="yiyi-st" id="yiyi-229"><em>上下文</em>参数被传递给<em>op</em>的<code class="xref py py-obj docutils literal"><span class="pre">__array__</span></code>方法，并且仅当数组以这种方式构造时才使用。</span><span class="yiyi-st" id="yiyi-230">几乎总是此参数为<code class="docutils literal"><span class="pre">NULL</span></code>。</span></p>
<p><span class="yiyi-st" id="yiyi-231">在NumPy的1.6版本和更早版本中，以下标志中没有_ARRAY_宏命名空间。</span><span class="yiyi-st" id="yiyi-232">这种形式的常量名在1.7中已被弃用。</span></p>
<dl class="var">
<dt id="c.NPY_ARRAY_C_CONTIGUOUS"><span class="yiyi-st" id="yiyi-233"> <code class="descname">NPY_ARRAY_C_CONTIGUOUS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-234">确保返回的数组是C样式连续的</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_F_CONTIGUOUS"><span class="yiyi-st" id="yiyi-235"> <code class="descname">NPY_ARRAY_F_CONTIGUOUS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-236"></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_ALIGNED"><span class="yiyi-st" id="yiyi-237"> <code class="descname">NPY_ARRAY_ALIGNED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-238">确保返回的数组在其数据类型的正确边界上对齐。</span><span class="yiyi-st" id="yiyi-239">对齐数组具有数据指针和每个步幅因子作为数据类型描述符的对准因子的倍数。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_WRITEABLE"><span class="yiyi-st" id="yiyi-240"> <code class="descname">NPY_ARRAY_WRITEABLE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-241">确保返回的数组可以写入。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_ENSURECOPY"><span class="yiyi-st" id="yiyi-242"> <code class="descname">NPY_ARRAY_ENSURECOPY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-243">确保副本由<em>op</em>组成。</span><span class="yiyi-st" id="yiyi-244">如果此标志不存在，则如果可以避免，则不复制数据。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_ENSUREARRAY"><span class="yiyi-st" id="yiyi-245"> <code class="descname">NPY_ARRAY_ENSUREARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-246">确保结果是基类ndarray或bigndarray。</span><span class="yiyi-st" id="yiyi-247">默认情况下，如果<em>op</em>是bigndarray的子​​类的实例，则返回相同子类的实例。</span><span class="yiyi-st" id="yiyi-248">如果设置了此标志，将返回一个ndarray对象。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_FORCECAST"><span class="yiyi-st" id="yiyi-249"> <code class="descname">NPY_ARRAY_FORCECAST</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-250">强制转换为输出类型，即使它不能安全地完成。</span><span class="yiyi-st" id="yiyi-251">没有这个标志，只有当它可以安全地进行时，才会发生数据转换，否则会引发错误。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_UPDATEIFCOPY"><span class="yiyi-st" id="yiyi-252"> <code class="descname">NPY_ARRAY_UPDATEIFCOPY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-253">如果<em>op</em>已经是一个数组，但不满足要求，那么将进行一个副本（这将满足要求）。</span><span class="yiyi-st" id="yiyi-254">如果此标志存在并且必须创建一个（已经是数组的对象的）副本，则在返回的副本中设置相应的<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>标志，并且<em>op</em>为设为只读。</span><span class="yiyi-st" id="yiyi-255">当返回的副本被删除时（可能是在计算完成后），其内容将被复制回<em>op</em>，并且<em>op</em>数组将再次可写。</span><span class="yiyi-st" id="yiyi-256">如果<em>op</em>无法写入，则会引发错误。</span><span class="yiyi-st" id="yiyi-257">如果<em>op</em>不是数组，则此标志无效。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_BEHAVED"><span class="yiyi-st" id="yiyi-258"> <code class="descname">NPY_ARRAY_BEHAVED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-259"><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_CARRAY"><span class="yiyi-st" id="yiyi-260"> <code class="descname">NPY_ARRAY_CARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-261"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_BEHAVED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_CARRAY_RO"><span class="yiyi-st" id="yiyi-262"> <code class="descname">NPY_ARRAY_CARRAY_RO</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-263"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_FARRAY"><span class="yiyi-st" id="yiyi-264"> <code class="descname">NPY_ARRAY_FARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-265"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_BEHAVED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_FARRAY_RO"><span class="yiyi-st" id="yiyi-266"> <code class="descname">NPY_ARRAY_FARRAY_RO</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-267"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_DEFAULT"><span class="yiyi-st" id="yiyi-268"> <code class="descname">NPY_ARRAY_DEFAULT</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-269"><a class="reference internal" href="#c.NPY_ARRAY_CARRAY" title="NPY_ARRAY_CARRAY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_CARRAY</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_IN_ARRAY"><span class="yiyi-st" id="yiyi-270"> <code class="descname">NPY_ARRAY_IN_ARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-271"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_IN_FARRAY"><span class="yiyi-st" id="yiyi-272"> <code class="descname">NPY_ARRAY_IN_FARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-273"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_OUT_ARRAY"><span class="yiyi-st" id="yiyi-274"> <code class="descname">NPY_OUT_ARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-275"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_OUT_FARRAY"><span class="yiyi-st" id="yiyi-276"> <code class="descname">NPY_ARRAY_OUT_FARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-277"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_INOUT_ARRAY"><span class="yiyi-st" id="yiyi-278"> <code class="descname">NPY_ARRAY_INOUT_ARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-279"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_INOUT_FARRAY"><span class="yiyi-st" id="yiyi-280"> <code class="descname">NPY_ARRAY_INOUT_FARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-281"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a></span></p>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GetArrayParamsFromObject"><span class="yiyi-st" id="yiyi-282"> int <code class="descname">PyArray_GetArrayParamsFromObject</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> requested_dtype</em>, <a class="reference internal" href="c-api.dtype.html#c.npy_bool" title="npy_bool">npy_bool</a><em> writeable</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> out_dtype</em>, int*<em> out_ndim</em>, npy_intp*<em> out_dims</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> out_arr</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> context</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-283"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-284">检索用于查看/将任意PyObject *转换为NumPy数组的数组参数。</span><span class="yiyi-st" id="yiyi-285">这允许发现Python列表列表的“先天类型和形状”，而无需实际转换为数组。</span><span class="yiyi-st" id="yiyi-286">PyArray_FromAny调用此函数来分析其输入。</span></p>
<p><span class="yiyi-st" id="yiyi-287">在某些情况下，例如结构化数组和__array__接口，需要使用数据类型来理解对象。</span><span class="yiyi-st" id="yiyi-288">当需要时，为&apos;requested_dtype&apos;提供一个Descr，否则提供NULL。</span><span class="yiyi-st" id="yiyi-289">此引用不会被窃取。</span><span class="yiyi-st" id="yiyi-290">此外，如果请求的dtype不修改输入的解释，out_dtype仍将获得对象的“先天”dtype，而不是在&apos;requested_dtype&apos;中传递的dtype。</span></p>
<p><span class="yiyi-st" id="yiyi-291">如果需要写入“op”中的值，请将布尔值“writeable”设置为1。</span><span class="yiyi-st" id="yiyi-292">当&apos;op&apos;是标量，列表列表或其他不可写入的&apos;op&apos;时，会出现错误。</span><span class="yiyi-st" id="yiyi-293">这不同于将NPY_ARRAY_WRITEABLE传递到PyArray_FromAny，其中可写数组可以是输入的副本。</span></p>
<p><span class="yiyi-st" id="yiyi-294">当返回成功（返回值为0）时，out_arr将填充一个非空的PyArrayObject，其余的参数保持不变，或out_arr填充为NULL，其余的参数将被填充。</span></p>
<p><span class="yiyi-st" id="yiyi-295">典型用途：</span></p>
<div class="highlight-c"><div class="highlight"><pre><span></span>PyArrayObject *arr = NULL;
PyArray_Descr *dtype = NULL;
int ndim = 0;
npy_intp dims[NPY_MAXDIMS];

if (PyArray_GetArrayParamsFromObject(op, NULL, 1, &amp;dtype,
                                    &amp;ndim, &amp;dims, &amp;arr, NULL) &lt; 0) {
    return NULL;
}
if (arr == NULL) {
    ... validate/change dtype, validate flags, ndim, etc ...
    // Could make custom strides here too
    arr = PyArray_NewFromDescr(&amp;PyArray_Type, dtype, ndim,
                                dims, NULL,
                                fortran ? NPY_ARRAY_F_CONTIGUOUS : 0,
                                NULL);
    if (arr == NULL) {
        return NULL;
    }
    if (PyArray_CopyObject(arr, op) &lt; 0) {
        Py_DECREF(arr);
        return NULL;
    }
}
else {
    ... in this case the other parameters weren&apos;t filled, just
        validate and possibly copy arr itself ...
}
... use arr ...
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CheckFromAny"><span class="yiyi-st" id="yiyi-296"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_CheckFromAny</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> min_depth</em>, int<em> max_depth</em>, int<em> requirements</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> context</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-297">几乎与<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>（...）除了<em>要求</em>可以包含<a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_NOTSWAPPED</span></code></a>（覆盖<em>dtype</em> ）和<a class="reference internal" href="#c.NPY_ARRAY_ELEMENTSTRIDES" title="NPY_ARRAY_ELEMENTSTRIDES"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ELEMENTSTRIDES</span></code></a>，表示数组应该对齐，因为步长是元素大小的倍数。</span></p>
<p><span class="yiyi-st" id="yiyi-298">在NumPy的1.6版本和更早版本中，以下标志中没有_ARRAY_宏命名空间。</span><span class="yiyi-st" id="yiyi-299">这种形式的常量名在1.7中已被弃用。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_NOTSWAPPED"><span class="yiyi-st" id="yiyi-300"> <code class="descname">NPY_ARRAY_NOTSWAPPED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-301">确保返回的数组具有按机器字节顺序的数据类型描述符，超越了<em>dtype</em>参数中的任何规范。</span><span class="yiyi-st" id="yiyi-302">通常，字节顺序要求由<em>dtype</em>参数决定。</span><span class="yiyi-st" id="yiyi-303">如果这个标志被设置，并且dtype参数不指示机器字节顺序描述符（或者是NULL，并且该对象已经是具有不是机器字节顺序的数据类型描述符的数组），则新的数据 - 类型描述符被创建并使用，其字节顺序字段设置为native。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_BEHAVED_NS"><span class="yiyi-st" id="yiyi-304"> <code class="descname">NPY_ARRAY_BEHAVED_NS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-305"><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_NOTSWAPPED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_ELEMENTSTRIDES"><span class="yiyi-st" id="yiyi-306"> <code class="descname">NPY_ARRAY_ELEMENTSTRIDES</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-307">确保返回的数组具有元素大小的倍数的步长。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromArray"><span class="yiyi-st" id="yiyi-308"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromArray</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> newtype</em>, int<em> requirements</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-309">Special case of <a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a> for when <em>op</em> is already an array but it needs to be of a specific <em>newtype</em> (including byte-order) or has certain <em>requirements</em>.</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromStructInterface"><span class="yiyi-st" id="yiyi-310"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromStructInterface</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-311">从公开了<code class="xref py py-obj docutils literal"><span class="pre">__array_struct__</span></code>属性并遵循数组接口协议的Python对象返回一个ndarray对象。</span><span class="yiyi-st" id="yiyi-312">如果对象不包含此属性，则返回对<a class="reference external" href="https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.7)"><code class="xref c c-data docutils literal"><span class="pre">Py_NotImplemented</span></code></a>的借用引用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromInterface"><span class="yiyi-st" id="yiyi-313"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromInterface</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-314">从暴露数组接口协议后的<a class="reference internal" href="arrays.interface.html#__array_interface__" title="__array_interface__"><code class="xref py py-obj docutils literal"><span class="pre">__array_interface__</span></code></a>属性的Python对象返回一个ndarray对象。</span><span class="yiyi-st" id="yiyi-315">如果对象不包含此属性，则返回对<a class="reference external" href="https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.7)"><code class="xref c c-data docutils literal"><span class="pre">Py_NotImplemented</span></code></a>的借用引用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromArrayAttr"><span class="yiyi-st" id="yiyi-316"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromArrayAttr</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> context</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-317">从暴露了<code class="xref py py-obj docutils literal"><span class="pre">__array__</span></code>方法的Python对象返回一个ndarray对象。</span><span class="yiyi-st" id="yiyi-318"><code class="xref py py-obj docutils literal"><span class="pre">__array__</span></code>方法可以取0,1或2个参数（[dtype，context]），其中<em>上下文</em>用于传递有关<code class="xref py py-obj docutils literal"><span class="pre">__array__</span></code></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ContiguousFromAny"><span class="yiyi-st" id="yiyi-319"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ContiguousFromAny</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, int<em> typenum</em>, int<em> min_depth</em>, int<em> max_depth</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-320">此函数从枚举的<em>typenum指定的（非灵活）类型的任何嵌套序列或数组接口导出对象<em>op</em>返回（C样式） t1&gt;，最小深度<em>min_depth</em>和最大深度<em>max_depth</em>。</em></span><span class="yiyi-st" id="yiyi-321">等效于对<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>的调用，其要求设置为<code class="xref c c-data docutils literal"><span class="pre">NPY_DEFAULT</span></code>，类型参数的type_num成员设置为<em>typenum</em>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromObject"><span class="yiyi-st" id="yiyi-322"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_FromObject</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a><em> *op</em>, int<em> typenum</em>, int<em> min_depth</em>, int<em> max_depth</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-323">从枚举类型给定的类型的任何嵌套序列或数组接口导出对象op返回对齐的和本地字节序数组。</span><span class="yiyi-st" id="yiyi-324">数组可以具有的最小维数由min_depth给出，而最大值为max_depth。</span><span class="yiyi-st" id="yiyi-325">这等同于对需求设置为BEHAVED的<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>的调用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EnsureArray"><span class="yiyi-st" id="yiyi-326"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_EnsureArray</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-327">此函数<strong>将引用</strong>挪到<code class="docutils literal"><span class="pre">op</span></code>，并确保<code class="docutils literal"><span class="pre">op</span></code>是基类的ndarray。</span><span class="yiyi-st" id="yiyi-328">它是特殊情况的数组标量，但是否则调用<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>（<code class="docutils literal"><span class="pre">op</span></code>，NULL，0，0，<a class="reference internal" href="../user/c-info.how-to-extend.html#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ENSUREARRAY</span></code></a>）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromString"><span class="yiyi-st" id="yiyi-329"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromString</code><span class="sig-paren">(</span>char*<em> string</em>, npy_intp<em> slen</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, npy_intp<em> num</em>, char*<em> sep</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-330">从长度为<code class="docutils literal"><span class="pre">slen</span></code>的二进制或（ASCII）文本<code class="docutils literal"><span class="pre">string</span></code>构造单一类型的一维数组。</span><span class="yiyi-st" id="yiyi-331">要创建的数组的数据类型由<code class="docutils literal"><span class="pre">dtype</span></code>给出。</span><span class="yiyi-st" id="yiyi-332">如果num是-1，则<strong>复制</strong>整个字符串并返回一个适当大小的数组，否则<code class="docutils literal"><span class="pre">num</span></code>是要<strong>复制</strong>字符串。</span><span class="yiyi-st" id="yiyi-333">If <code class="docutils literal"><span class="pre">sep</span></code> is NULL (or “”), then interpret the string as bytes of binary data, otherwise convert the sub-strings separated by <code class="docutils literal"><span class="pre">sep</span></code> to items of data-type <code class="docutils literal"><span class="pre">dtype</span></code>. </span><span class="yiyi-st" id="yiyi-334">某些数据类型在文本模式下可能无法读取，如果发生错误，则会出现错误。</span><span class="yiyi-st" id="yiyi-335">所有错误返回NULL。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromFile"><span class="yiyi-st" id="yiyi-336"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromFile</code><span class="sig-paren">(</span>FILE*<em> fp</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, npy_intp<em> num</em>, char*<em> sep</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-337">从二进制或文本文件构造单个类型的一维数组。</span><span class="yiyi-st" id="yiyi-338">打开的文件指针为<code class="docutils literal"><span class="pre">fp</span></code>，要创建的数组的数据类型由<code class="docutils literal"><span class="pre">dtype</span></code>给出。</span><span class="yiyi-st" id="yiyi-339">这必须与文件中的数据匹配。</span><span class="yiyi-st" id="yiyi-340">如果<code class="docutils literal"><span class="pre">num</span></code>为-1，则读取直到文件结束并返回适当大小的数组，否则<code class="docutils literal"><span class="pre">num</span></code>是要读取的项目数。</span><span class="yiyi-st" id="yiyi-341">如果<code class="docutils literal"><span class="pre">sep</span></code>为NULL（或“”），则以二进制模式从文件读取，否则从文本模式中使用<code class="docutils literal"><span class="pre">sep</span></code>提供项目分隔符。</span><span class="yiyi-st" id="yiyi-342">某些数组类型无法在文本模式下读取，在这种情况下会出现错误。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromBuffer"><span class="yiyi-st" id="yiyi-343"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromBuffer</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> buf</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, npy_intp<em> count</em>, npy_intp<em> offset</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-344">从导出（单段）缓冲区协议（或具有返回导出缓冲区协议的对象的__buffer__属性）的对象<code class="docutils literal"><span class="pre">buf</span></code>构造单个类型的一维数组。</span><span class="yiyi-st" id="yiyi-345">首先尝试可写缓冲区，然后尝试只读缓冲区。</span><span class="yiyi-st" id="yiyi-346">返回的数组的<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>标志将反映哪个成功。</span><span class="yiyi-st" id="yiyi-347">The data is assumed to start at <code class="docutils literal"><span class="pre">offset</span></code> bytes from the start of the memory location for the object. </span><span class="yiyi-st" id="yiyi-348">缓冲区中的数据类型将根据数据类型描述符<code class="docutils literal"><span class="pre">dtype.</span></code></span><span class="yiyi-st" id="yiyi-349">如果<code class="docutils literal"><span class="pre">count</span></code>为负，那么将根据缓冲区的大小和所请求的itemsize来确定，否则<code class="docutils literal"><span class="pre">count</span></code>表示应该从缓冲区转换多少个元素。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CopyInto"><span class="yiyi-st" id="yiyi-350"> int <code class="descname">PyArray_CopyInto</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> dest</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> src</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-351">从源数组<code class="docutils literal"><span class="pre">src</span></code>复制到目标数组<code class="docutils literal"><span class="pre">dest</span></code>，如有必要，执行数据类型转换。</span><span class="yiyi-st" id="yiyi-352">如果发生错误返回-1（否则为0）。</span><span class="yiyi-st" id="yiyi-353"><code class="docutils literal"><span class="pre">src</span></code>的形状必须可以广播到<code class="docutils literal"><span class="pre">dest</span></code>的形状。</span><span class="yiyi-st" id="yiyi-354">dest和src的数据区不能重叠。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MoveInto"><span class="yiyi-st" id="yiyi-355"> int <code class="descname">PyArray_MoveInto</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> dest</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> src</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-356">将数据从源数组<code class="docutils literal"><span class="pre">src</span></code>移入目标数组<code class="docutils literal"><span class="pre">dest</span></code>，如有必要，执行数据类型转换。</span><span class="yiyi-st" id="yiyi-357">如果发生错误返回-1（否则为0）。</span><span class="yiyi-st" id="yiyi-358"><code class="docutils literal"><span class="pre">src</span></code>的形状必须可以广播到<code class="docutils literal"><span class="pre">dest</span></code>的形状。</span><span class="yiyi-st" id="yiyi-359">dest和src的数据区可能重叠。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GETCONTIGUOUS"><span class="yiyi-st" id="yiyi-360"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>* <code class="descname">PyArray_GETCONTIGUOUS</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-361">如果<code class="docutils literal"><span class="pre">op</span></code>已经是（C风格）连续和良好行为，那么只是返回一个引用，否则返回一个（连续和良好行为）的数组副本。</span><span class="yiyi-st" id="yiyi-362">参数op必须是（ndarray的子​​类），并且不进行检查。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FROM_O"><span class="yiyi-st" id="yiyi-363"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FROM_O</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-364">将<code class="docutils literal"><span class="pre">obj</span></code>转换为ndarray。</span><span class="yiyi-st" id="yiyi-365">参数可以是导出数组接口的任何嵌套序列或对象。</span><span class="yiyi-st" id="yiyi-366">这是<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>的宏形式，使用<code class="docutils literal"><span class="pre">NULL</span></code>，0,0,0作为其他参数。</span><span class="yiyi-st" id="yiyi-367">您的代码必须能够处理任何数据类型描述符和任何data-flags的组合，以使用此宏。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FROM_OF"><span class="yiyi-st" id="yiyi-368"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FROM_OF</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> requirements</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-369">类似于<a class="reference internal" href="#c.PyArray_FROM_O" title="PyArray_FROM_O"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FROM_O</span></code></a>，但它可以接受<em>要求</em>的参数，指示生成的数组必须具有的属性。</span><span class="yiyi-st" id="yiyi-370">Available requirements that can be enforced are <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_NOTSWAPPED</span></code></a>, <a class="reference internal" href="../user/c-info.how-to-extend.html#c.NPY_ARRAY_ENSURECOPY" title="NPY_ARRAY_ENSURECOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ENSURECOPY</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>, <a class="reference internal" href="../user/c-info.how-to-extend.html#c.NPY_ARRAY_FORCECAST" title="NPY_ARRAY_FORCECAST"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_FORCECAST</span></code></a>, and <a class="reference internal" href="../user/c-info.how-to-extend.html#c.NPY_ARRAY_ENSUREARRAY" title="NPY_ARRAY_ENSUREARRAY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ENSUREARRAY</span></code></a>. </span><span class="yiyi-st" id="yiyi-371">还可以使用标志的标准组合：</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FROM_OT"><span class="yiyi-st" id="yiyi-372"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FROM_OT</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-373">类似于<a class="reference internal" href="#c.PyArray_FROM_O" title="PyArray_FROM_O"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FROM_O</span></code></a>，除了它可以接受<em>typenum</em>的参数，指定返回的数组的类型号。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FROM_OTF"><span class="yiyi-st" id="yiyi-374"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FROM_OTF</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> typenum</em>, int<em> requirements</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-375">组合<a class="reference internal" href="#c.PyArray_FROM_OF" title="PyArray_FROM_OF"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FROM_OF</span></code></a>和<a class="reference internal" href="#c.PyArray_FROM_OT" title="PyArray_FROM_OT"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FROM_OT</span></code></a>，允许提供<em>typenum</em>和<em>标志</em>参数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FROMANY"><span class="yiyi-st" id="yiyi-376"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FROMANY</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> typenum</em>, int<em> min</em>, int<em> max</em>, int<em> requirements</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-377">类似于<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>，除了使用类型号指定数据类型。</span><span class="yiyi-st" id="yiyi-378"><a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrFromType</span></code></a>（<em>typenum</em>）直接传递到<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>。</span><span class="yiyi-st" id="yiyi-379">如果<a class="reference internal" href="../user/c-info.how-to-extend.html#c.NPY_ARRAY_ENSURECOPY" title="NPY_ARRAY_ENSURECOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ENSURECOPY</span></code></a>作为需求传递，此宏还将<code class="xref c c-data docutils literal"><span class="pre">NPY_DEFAULT</span></code>添加到要求中。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CheckAxis"><span class="yiyi-st" id="yiyi-380"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_CheckAxis</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int*<em> axis</em>, int<em> requirements</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-381">封装具有axis =关键字的函数和方法的功能，并且以None作为轴参数正常工作。</span><span class="yiyi-st" id="yiyi-382">输入数组是<code class="docutils literal"><span class="pre">obj</span></code>，而<code class="docutils literal"><span class="pre">*axis</span></code>是一个转换的整数（因此&gt; = MAXDIMS是None值），<code class="docutils literal"><span class="pre">requirements</span></code>需要的属性<code class="docutils literal"><span class="pre">obj</span></code>。</span><span class="yiyi-st" id="yiyi-383">输出是输入的转换版本，以满足要求，并且如果需要，发生平坦化。</span><span class="yiyi-st" id="yiyi-384">对<code class="docutils literal"><span class="pre">*axis</span></code>的输出负值进行转换，并检查新值以确保与<code class="docutils literal"><span class="pre">obj</span></code>的形状一致。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="dealing-with-types">
<h2><span class="yiyi-st" id="yiyi-385">Dealing with types</span></h2>
<div class="section" id="general-check-of-python-type">
<h3><span class="yiyi-st" id="yiyi-386">General check of Python Type</span></h3>
<dl class="function">
<dt id="c.PyArray_Check"><span class="yiyi-st" id="yiyi-387"> <code class="descname">PyArray_Check</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-388">如果<em>op</em>是类型为<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>的子类型的Python对象，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CheckExact"><span class="yiyi-st" id="yiyi-389"> <code class="descname">PyArray_CheckExact</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-390">如果<em>op</em>是类型为<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>的Python对象，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_HasArrayInterface"><span class="yiyi-st" id="yiyi-391"> <code class="descname">PyArray_HasArrayInterface</code><span class="sig-paren">(</span>op, out<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-392">如果<code class="docutils literal"><span class="pre">op</span></code>实现数组接口的任何部分，则<code class="docutils literal"><span class="pre">out</span></code>将包含对使用接口或<code class="docutils literal"><span class="pre">out</span></code> <code class="docutils literal"><span class="pre">NULL</span></code>如果在转换期间发生错误。</span><span class="yiyi-st" id="yiyi-393">否则，out将包含对<a class="reference external" href="https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented" title="(in Python v3.7)"><code class="xref c c-data docutils literal"><span class="pre">Py_NotImplemented</span></code></a>的借用引用，并且未设置错误条件。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_HasArrayInterfaceType"><span class="yiyi-st" id="yiyi-394"> <code class="descname">PyArray_HasArrayInterfaceType</code><span class="sig-paren">(</span>op, type, context, out<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-395">如果<code class="docutils literal"><span class="pre">op</span></code>实现数组接口的任何部分，则<code class="docutils literal"><span class="pre">out</span></code>将包含对使用接口或<code class="docutils literal"><span class="pre">out</span></code> <code class="docutils literal"><span class="pre">NULL</span></code>如果在转换期间发生错误。</span><span class="yiyi-st" id="yiyi-396">否则，out将包含对Py_NotImplemented的借用引用，并且不设置错误条件。</span><span class="yiyi-st" id="yiyi-397">此版本允许在查找<code class="xref py py-obj docutils literal"><span class="pre">__array__</span></code>属性的数组接口部分中设置类型和上下文。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IsZeroDim"><span class="yiyi-st" id="yiyi-398"> <code class="descname">PyArray_IsZeroDim</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-399">如果<em>op</em>是<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>（的子类）的实例并且具有0个维度，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IsScalar"><span class="yiyi-st" id="yiyi-400"> <code class="descname">PyArray_IsScalar</code><span class="sig-paren">(</span>op, cls<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-401">如果<em>op</em>是<code class="xref c c-data docutils literal"><span class="pre">Py{cls}ArrType_Type</span></code>的实例，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CheckScalar"><span class="yiyi-st" id="yiyi-402"> <code class="descname">PyArray_CheckScalar</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-403">如果<em>op</em>是数组标量（<code class="xref c c-data docutils literal"><span class="pre">PyGenericArr_Type</span></code>的子类型的实例）或<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IsPythonNumber"><span class="yiyi-st" id="yiyi-404"> <code class="descname">PyArray_IsPythonNumber</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-405">如果<em>op</em>是内置数值类型的实例（int，float，complex，long，bool）</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IsPythonScalar"><span class="yiyi-st" id="yiyi-406"> <code class="descname">PyArray_IsPythonScalar</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-407">如果<em>op</em>是内置的Python标量对象（int，float，complex，str，unicode，long，bool），则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IsAnyScalar"><span class="yiyi-st" id="yiyi-408"> <code class="descname">PyArray_IsAnyScalar</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-409">如果<em>op</em>是Python标量对象（请参阅<a class="reference internal" href="#c.PyArray_IsPythonScalar" title="PyArray_IsPythonScalar"><code class="xref c c-func docutils literal"><span class="pre">PyArray_IsPythonScalar</span></code></a>）或数组标量（<code class="xref c c-data docutils literal"><span class="pre">PyGenericArr_Type</span></code>的子类型的实例） 。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CheckAnyScalar"><span class="yiyi-st" id="yiyi-410"> <code class="descname">PyArray_CheckAnyScalar</code><span class="sig-paren">(</span>op<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-411">如果<em>op</em>是Python标量对象（参见<a class="reference internal" href="#c.PyArray_IsPythonScalar" title="PyArray_IsPythonScalar"><code class="xref c c-func docutils literal"><span class="pre">PyArray_IsPythonScalar</span></code></a>），即数组标量（<code class="xref c c-data docutils literal"><span class="pre">PyGenericArr_Type</span></code>的子类型的实例），其维度为0的<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>的子类型的实例。</span></p>
</dd></dl>
</div>
<div class="section" id="data-type-checking">
<h3><span class="yiyi-st" id="yiyi-412">Data-type checking</span></h3>
<p><span class="yiyi-st" id="yiyi-413">对于typenum宏，参数是表示枚举的数组数据类型的整数。</span><span class="yiyi-st" id="yiyi-414">对于数组类型检查宏，参数必须是<code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span></code>，可以直接解释为<a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code class="xref c c-type docutils literal"><span class="pre">PyArrayObject</span> <span class="pre">*</span></code></a>。</span></p>
<dl class="function">
<dt id="c.PyTypeNum_ISUNSIGNED"><span class="yiyi-st" id="yiyi-415"> <code class="descname">PyTypeNum_ISUNSIGNED</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISUNSIGNED"><span class="yiyi-st" id="yiyi-416"> <code class="descname">PyDataType_ISUNSIGNED</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISUNSIGNED"><span class="yiyi-st" id="yiyi-417"> <code class="descname">PyArray_ISUNSIGNED</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-418">类型表示无符号整数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISSIGNED"><span class="yiyi-st" id="yiyi-419"> <code class="descname">PyTypeNum_ISSIGNED</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISSIGNED"><span class="yiyi-st" id="yiyi-420"> <code class="descname">PyDataType_ISSIGNED</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISSIGNED"><span class="yiyi-st" id="yiyi-421"> <code class="descname">PyArray_ISSIGNED</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-422">类型表示有符号整数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISINTEGER"><span class="yiyi-st" id="yiyi-423"> <code class="descname">PyTypeNum_ISINTEGER</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISINTEGER"><span class="yiyi-st" id="yiyi-424"> <code class="descname">PyDataType_ISINTEGER</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISINTEGER"><span class="yiyi-st" id="yiyi-425"> <code class="descname">PyArray_ISINTEGER</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-426">类型表示任何整数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISFLOAT"><span class="yiyi-st" id="yiyi-427"> <code class="descname">PyTypeNum_ISFLOAT</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISFLOAT"><span class="yiyi-st" id="yiyi-428"> <code class="descname">PyDataType_ISFLOAT</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISFLOAT"><span class="yiyi-st" id="yiyi-429"> <code class="descname">PyArray_ISFLOAT</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-430">类型表示任何浮点数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISCOMPLEX"><span class="yiyi-st" id="yiyi-431"> <code class="descname">PyTypeNum_ISCOMPLEX</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISCOMPLEX"><span class="yiyi-st" id="yiyi-432"> <code class="descname">PyDataType_ISCOMPLEX</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISCOMPLEX"><span class="yiyi-st" id="yiyi-433"> <code class="descname">PyArray_ISCOMPLEX</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-434">类型表示任何复杂浮点数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISNUMBER"><span class="yiyi-st" id="yiyi-435"> <code class="descname">PyTypeNum_ISNUMBER</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISNUMBER"><span class="yiyi-st" id="yiyi-436"> <code class="descname">PyDataType_ISNUMBER</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISNUMBER"><span class="yiyi-st" id="yiyi-437"> <code class="descname">PyArray_ISNUMBER</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-438">类型表示任何整数，浮点数或复数浮点数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISSTRING"><span class="yiyi-st" id="yiyi-439"> <code class="descname">PyTypeNum_ISSTRING</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISSTRING"><span class="yiyi-st" id="yiyi-440"> <code class="descname">PyDataType_ISSTRING</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISSTRING"><span class="yiyi-st" id="yiyi-441"> <code class="descname">PyArray_ISSTRING</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-442">Type表示字符串数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISPYTHON"><span class="yiyi-st" id="yiyi-443"> <code class="descname">PyTypeNum_ISPYTHON</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISPYTHON"><span class="yiyi-st" id="yiyi-444"> <code class="descname">PyDataType_ISPYTHON</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISPYTHON"><span class="yiyi-st" id="yiyi-445"> <code class="descname">PyArray_ISPYTHON</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-446">类型表示对应于标准Python标量（bool，int，float或complex）之一的枚举类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISFLEXIBLE"><span class="yiyi-st" id="yiyi-447"> <code class="descname">PyTypeNum_ISFLEXIBLE</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISFLEXIBLE"><span class="yiyi-st" id="yiyi-448"> <code class="descname">PyDataType_ISFLEXIBLE</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISFLEXIBLE"><span class="yiyi-st" id="yiyi-449"> <code class="descname">PyArray_ISFLEXIBLE</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-450">类型表示灵活数组类型之一（<a class="reference internal" href="c-api.dtype.html#c.NPY_STRING" title="NPY_STRING"><code class="xref c c-data docutils literal"><span class="pre">NPY_STRING</span></code></a>，<a class="reference internal" href="c-api.dtype.html#c.NPY_UNICODE" title="NPY_UNICODE"><code class="xref c c-data docutils literal"><span class="pre">NPY_UNICODE</span></code></a>或<a class="reference internal" href="c-api.dtype.html#c.NPY_VOID" title="NPY_VOID"><code class="xref c c-data docutils literal"><span class="pre">NPY_VOID</span></code></a>）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISUSERDEF"><span class="yiyi-st" id="yiyi-451"> <code class="descname">PyTypeNum_ISUSERDEF</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISUSERDEF"><span class="yiyi-st" id="yiyi-452"> <code class="descname">PyDataType_ISUSERDEF</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISUSERDEF"><span class="yiyi-st" id="yiyi-453"> <code class="descname">PyArray_ISUSERDEF</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-454">类型表示用户定义的类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISEXTENDED"><span class="yiyi-st" id="yiyi-455"> <code class="descname">PyTypeNum_ISEXTENDED</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISEXTENDED"><span class="yiyi-st" id="yiyi-456"> <code class="descname">PyDataType_ISEXTENDED</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISEXTENDED"><span class="yiyi-st" id="yiyi-457"> <code class="descname">PyArray_ISEXTENDED</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-458">类型是灵活的或用户定义的。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISOBJECT"><span class="yiyi-st" id="yiyi-459"> <code class="descname">PyTypeNum_ISOBJECT</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISOBJECT"><span class="yiyi-st" id="yiyi-460"> <code class="descname">PyDataType_ISOBJECT</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISOBJECT"><span class="yiyi-st" id="yiyi-461"> <code class="descname">PyArray_ISOBJECT</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-462">类型表示对象数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyTypeNum_ISBOOL"><span class="yiyi-st" id="yiyi-463"> <code class="descname">PyTypeNum_ISBOOL</code><span class="sig-paren">(</span>num<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataType_ISBOOL"><span class="yiyi-st" id="yiyi-464"> <code class="descname">PyDataType_ISBOOL</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_ISBOOL"><span class="yiyi-st" id="yiyi-465"> <code class="descname">PyArray_ISBOOL</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-466">类型表示布尔数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyDataType_HASFIELDS"><span class="yiyi-st" id="yiyi-467"> <code class="descname">PyDataType_HASFIELDS</code><span class="sig-paren">(</span>descr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_HASFIELDS"><span class="yiyi-st" id="yiyi-468"> <code class="descname">PyArray_HASFIELDS</code><span class="sig-paren">(</span>obj<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-469">类型具有与其相关联的字段。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISNOTSWAPPED"><span class="yiyi-st" id="yiyi-470"> <code class="descname">PyArray_ISNOTSWAPPED</code><span class="sig-paren">(</span>m<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-471">根据数组的数据类型描述符，如果ndarray <em>m</em>的数据区域是机器字节顺序，则评估为真。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISBYTESWAPPED"><span class="yiyi-st" id="yiyi-472"> <code class="descname">PyArray_ISBYTESWAPPED</code><span class="sig-paren">(</span>m<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-473">根据数组的数据类型描述符，如果机器字节顺序中ndarray <em>m</em>的数据区不是<strong></strong>，则判断为真。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EquivTypes"><span class="yiyi-st" id="yiyi-474"> Bool <code class="descname">PyArray_EquivTypes</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> type1</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> type2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-475">返回<a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code class="xref c c-data docutils literal"><span class="pre">NPY_TRUE</span></code></a>如果<em>type1</em>和<em>type2</em>实际上代表此平台的等效类型（每个类型的fortran成员被忽略）。</span><span class="yiyi-st" id="yiyi-476">例如，在32位平台上，<a class="reference internal" href="c-api.dtype.html#c.NPY_LONG" title="NPY_LONG"><code class="xref c c-data docutils literal"><span class="pre">NPY_LONG</span></code></a>和<a class="reference internal" href="c-api.dtype.html#c.NPY_INT" title="NPY_INT"><code class="xref c c-data docutils literal"><span class="pre">NPY_INT</span></code></a>是等效的。</span><span class="yiyi-st" id="yiyi-477">否则返回<a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code class="xref c c-data docutils literal"><span class="pre">NPY_FALSE</span></code></a>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EquivArrTypes"><span class="yiyi-st" id="yiyi-478"> Bool <code class="descname">PyArray_EquivArrTypes</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> a1</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a> *<em> a2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-479">如果<em>a1</em>和<em>a2</em>是具有此平台的等效类型的数组，则返回<a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code class="xref c c-data docutils literal"><span class="pre">NPY_TRUE</span></code></a>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EquivTypenums"><span class="yiyi-st" id="yiyi-480"> Bool <code class="descname">PyArray_EquivTypenums</code><span class="sig-paren">(</span>int<em> typenum1</em>, int<em> typenum2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-481"><a class="reference internal" href="#c.PyArray_EquivTypes" title="PyArray_EquivTypes"><code class="xref c c-func docutils literal"><span class="pre">PyArray_EquivTypes</span></code></a>（...）的特殊情况，它不接受灵活的数据类型，但可能更容易调用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EquivByteorders"><span class="yiyi-st" id="yiyi-482"> int <code class="descname">PyArray_EquivByteorders</code><span class="sig-paren">(</span>{byteorder}<em> b1</em>, {byteorder}<em> b2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-483">如果字节顺序字符（<code class="xref c c-data docutils literal"><span class="pre">NPY_LITTLE</span></code>，<code class="xref c c-data docutils literal"><span class="pre">NPY_BIG</span></code>，<code class="xref c c-data docutils literal"><span class="pre">NPY_NATIVE</span></code>，<code class="xref c c-data docutils literal"><span class="pre">NPY_IGNORE</span></code>）等于或等于其规格的本地字节顺序。</span><span class="yiyi-st" id="yiyi-484">因此，对于小端机器，<code class="xref c c-data docutils literal"><span class="pre">NPY_LITTLE</span></code>和<code class="xref c c-data docutils literal"><span class="pre">NPY_NATIVE</span></code>是等效的，它们在大端机器上不等效。</span></p>
</dd></dl>
</div>
<div class="section" id="converting-data-types">
<h3><span class="yiyi-st" id="yiyi-485">Converting data types</span></h3>
<dl class="function">
<dt id="c.PyArray_Cast"><span class="yiyi-st" id="yiyi-486"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Cast</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-487">主要用于向后兼容数字C-API，以及用于简单转换为非灵活类型。</span><span class="yiyi-st" id="yiyi-488">返回一个具有<em>arr</em>元素的新数组对象转换为数据类型<em>typenum</em>，它必须是枚举类型之一，而不是灵活类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CastToType"><span class="yiyi-st" id="yiyi-489"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_CastToType</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> type</em>, int<em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-490">返回指定的<em>类型</em>的新数组，适当地投射<em>arr</em>的元素。</span><span class="yiyi-st" id="yiyi-491">fortran参数指定输出数组的顺序。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CastTo"><span class="yiyi-st" id="yiyi-492"> int <code class="descname">PyArray_CastTo</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> in</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-493">从1.6开始，该函数只调用<a class="reference internal" href="#c.PyArray_CopyInto" title="PyArray_CopyInto"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CopyInto</span></code></a>，它处理转换。</span></p>
<p><span class="yiyi-st" id="yiyi-494">将中数组<em>的元素转换为数组<em>out</em>。</em></span><span class="yiyi-st" id="yiyi-495">输出数组应该是可写的，具有输入数组中的元素数目的整数倍（多个副本可以放入输出），并且具有作为内置类型之一的数据类型。</span><span class="yiyi-st" id="yiyi-496">成功返回0，如果发生错误则返回-1。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GetCastFunc"><span class="yiyi-st" id="yiyi-497"> PyArray_VectorUnaryFunc* <code class="descname">PyArray_GetCastFunc</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> from</em>, int<em> totype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-498">返回低级别转换函数，从给定描述符转换为内置类型数。</span><span class="yiyi-st" id="yiyi-499">如果没有转换函数存在，返回<code class="docutils literal"><span class="pre">NULL</span></code>并设置错误。</span><span class="yiyi-st" id="yiyi-500">使用此函数而不是直接访问<em>从</em>  - &gt; f-&gt; cast将允许支持添加到描述符转换字典中的任何用户定义的浇筑函数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CanCastSafely"><span class="yiyi-st" id="yiyi-501"> int <code class="descname">PyArray_CanCastSafely</code><span class="sig-paren">(</span>int<em> fromtype</em>, int<em> totype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-502">如果数据类型<em>fromtype</em>的数组可以转换为数据类型<em>totype</em>的数组，而不会丢失信息，则返回非零。</span><span class="yiyi-st" id="yiyi-503">一个例外是64位整数允许转换为64位浮点值，即使这样可能会丢失大整数的精度，以便在没有展开请求的情况下不增加使用长双精度。</span><span class="yiyi-st" id="yiyi-504">使用此功能，不会根据其长度检查灵活的数组类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CanCastTo"><span class="yiyi-st" id="yiyi-505"> int <code class="descname">PyArray_CanCastTo</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> fromtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> totype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-506"><a class="reference internal" href="#c.PyArray_CanCastTypeTo" title="PyArray_CanCastTypeTo"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CanCastTypeTo</span></code></a>在NumPy 1.6及更高版本中取代此函数。</span></p>
<p><span class="yiyi-st" id="yiyi-507">相当于PyArray_CanCastTypeTo（fromtype，totype，NPY_SAFE_CASTING）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CanCastTypeTo"><span class="yiyi-st" id="yiyi-508"> int <code class="descname">PyArray_CanCastTypeTo</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> fromtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> totype</em>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-509"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-510">如果数据类型<em>fromtype</em>（可以包括灵活类型）的数组可以安全地转换到数据类型<em>totype</em>（可以包括灵活类型）的数组，则返回非零，根据铸造规则<em>铸造</em>。</span><span class="yiyi-st" id="yiyi-511">对于<a class="reference internal" href="#c.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_SAFE_CASTING</span></code></a>的简单类型，这基本上是<a class="reference internal" href="#c.PyArray_CanCastSafely" title="PyArray_CanCastSafely"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CanCastSafely</span></code></a>的包装，但对于诸如字符串或unicode的灵活类型，它会根据其大小生成结果。</span><span class="yiyi-st" id="yiyi-512">如果字符串或unicode类型大到足以容纳从中转换的整数/浮点类型的最大值，那么整数和浮点类型只能使用<a class="reference internal" href="#c.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_SAFE_CASTING</span></code></a>转换为字符串或unicode类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CanCastArrayTo"><span class="yiyi-st" id="yiyi-513"> int <code class="descname">PyArray_CanCastArrayTo</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> totype</em>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-514"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-515">如果<em>arr</em>可以根据<em>投射</em>中给出的投射规则投射到<em>totype</em>，则返回非零值。</span><span class="yiyi-st" id="yiyi-516">如果<em>arr</em>是数组标量，则会考虑其值，并且当值不会溢出或在转换为较小类型时被截断为整数时，也会返回非零。</span></p>
<p><span class="yiyi-st" id="yiyi-517">这几乎与PyArray_CanCastTypeTo（PyArray_MinScalarType（arr），totype，casting）的结果相同，但它也处理一个特殊情况，因为对于具有相同数量的类型，uint值的集合不是int值的子集位。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MinScalarType"><span class="yiyi-st" id="yiyi-518"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_MinScalarType</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-519"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-520">如果<em>arr</em>是数组，则返回其数据类型描述符，但如果<em>arr</em>是数组标量（具有0个维度），则它会找到最小大小的数据类型值可以转换为不溢出或截断为整数。</span></p>
<p><span class="yiyi-st" id="yiyi-521">此函数不会将复数浮点型或任何布尔型降级为布尔型，但当标量值为正时将将有符号整数降级为无符号整数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_PromoteTypes"><span class="yiyi-st" id="yiyi-522"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_PromoteTypes</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> type1</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> type2</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-523"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-524">查找<em>type1</em>和<em>type2</em>可以安全转换的最小尺寸和种类的数据类型。</span><span class="yiyi-st" id="yiyi-525">此函数是对称和关联的。</span><span class="yiyi-st" id="yiyi-526">字符串或unicode结果将是存储转换为字符串或unicode的输入类型的最大值的正确大小。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ResultType"><span class="yiyi-st" id="yiyi-527"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_ResultType</code><span class="sig-paren">(</span>npy_intp<em> narrs</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**arrs, npy_intp<em> ndtypes</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**dtypes<span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-528"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-529">这将类型提升应用于所有输入，使用用于组合标量和数组的NumPy规则来确定一组操作数的输出类型。</span><span class="yiyi-st" id="yiyi-530">这与ufuncs产生的结果类型相同。</span><span class="yiyi-st" id="yiyi-531">使用的具体算法如下。</span></p>
<p><span class="yiyi-st" id="yiyi-532">通过首先检查布尔值，整数（int / uint）或浮点（float / complex）中所有数组和标量的最大种类来确定类别。</span></p>
<p><span class="yiyi-st" id="yiyi-533">如果只有标量或标量的最大类别高于数组的最大类别，则数据类型与<a class="reference internal" href="#c.PyArray_PromoteTypes" title="PyArray_PromoteTypes"><code class="xref c c-func docutils literal"><span class="pre">PyArray_PromoteTypes</span></code></a>组合以生成返回值。</span></p>
<p><span class="yiyi-st" id="yiyi-534">否则，对每个数组调用PyArray_MinScalarType，并将生成的数据类型与<a class="reference internal" href="#c.PyArray_PromoteTypes" title="PyArray_PromoteTypes"><code class="xref c c-func docutils literal"><span class="pre">PyArray_PromoteTypes</span></code></a>组合以生成返回值。</span></p>
<p><span class="yiyi-st" id="yiyi-535">对于具有相同位数的类型，int值集合不是uint值的子集，而是在<a class="reference internal" href="#c.PyArray_MinScalarType" title="PyArray_MinScalarType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_MinScalarType</span></code></a>中没有反映出来，但在PyArray_ResultType中作为特殊情况处理。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ObjectType"><span class="yiyi-st" id="yiyi-536"> int <code class="descname">PyArray_ObjectType</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, int<em> mintype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-537">此函数由<a class="reference internal" href="#c.PyArray_MinScalarType" title="PyArray_MinScalarType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_MinScalarType</span></code></a>和/或<a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ResultType</span></code></a>替代。</span></p>
<p><span class="yiyi-st" id="yiyi-538">此函数用于确定两个或多个数组可以转换为的公共类型。</span><span class="yiyi-st" id="yiyi-539">它只适用于非灵活数组类型，因为没有传递项目信息。</span><span class="yiyi-st" id="yiyi-540"><em>mintype</em>参数表示可接受的最小类型，<em>op</em>表示将转换为数组的对象。</span><span class="yiyi-st" id="yiyi-541">返回值是表示<em>op</em>应该具有的数据类型的枚举类型号。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ArrayType"><span class="yiyi-st" id="yiyi-542"> void <code class="descname">PyArray_ArrayType</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> mintype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> outtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-543">此函数由<a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ResultType</span></code></a>替代。</span></p>
<p><span class="yiyi-st" id="yiyi-544">此函数与<a class="reference internal" href="#c.PyArray_ObjectType" title="PyArray_ObjectType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ObjectType</span></code></a>（...）类似，除了它处理灵活数组。</span><span class="yiyi-st" id="yiyi-545"><em>mintype</em>参数可以有一个itemize成员，并且<em>outtype</em>参数将有一个itemsize成员至少与对象<em>op</em> 。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ConvertToCommonType"><span class="yiyi-st" id="yiyi-546"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>** <code class="descname">PyArray_ConvertToCommonType</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, int*<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-547">它提供的功能在很大程度上被1.6中引入的迭代器<a class="reference internal" href="c-api.iterator.html#c.NpyIter" title="NpyIter"><code class="xref c c-type docutils literal"><span class="pre">NpyIter</span></code></a>所替代，标记为<a class="reference internal" href="c-api.iterator.html#c.NPY_ITER_COMMON_DTYPE" title="NPY_ITER_COMMON_DTYPE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ITER_COMMON_DTYPE</span></code></a>，或者对所有操作数使用相同的dtype参数。</span></p>
<p><span class="yiyi-st" id="yiyi-548">将<em>op</em>中包含的Python对象序列转换为每个都具有相同数据类型的ndarrays的数组。</span><span class="yiyi-st" id="yiyi-549">基于类型号（在较小的类型号上选择较大的类型号）选择类型，忽略只是标量的对象。</span><span class="yiyi-st" id="yiyi-550">序列的长度在<em>n</em>中返回，<a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code class="xref c c-type docutils literal"><span class="pre">PyArrayObject</span></code></a>指针的<em>n</em>长度数组是返回值（或<code class="docutils literal"><span class="pre">NULL</span></code>如果发生错误）。</span><span class="yiyi-st" id="yiyi-551">返回的数组必须由此例程的调用者（使用<a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code class="xref c c-func docutils literal"><span class="pre">PyDataMem_FREE</span></code></a>）和其中的所有数组对象（<code class="docutils literal"><span class="pre">DECREF</span></code>&apos;d）释放，否则将发生内存泄漏。</span><span class="yiyi-st" id="yiyi-552">下面的示例模板代码显示了一个典型的用法：</span></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mps</span> <span class="o">=</span> <span class="n">PyArray_ConvertToCommonType</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mps</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">{</span><span class="n">code</span><span class="p">}</span>
<span class="o">&lt;</span><span class="n">before</span> <span class="k">return</span><span class="o">&gt;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">mps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="n">PyDataMem_FREE</span><span class="p">(</span><span class="n">mps</span><span class="p">);</span>
<span class="p">{</span><span class="k">return</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Zero"><span class="yiyi-st" id="yiyi-553"> char* <code class="descname">PyArray_Zero</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-554">指向大小为<em>arr</em>  - &gt; itemsize的新创建的内存的指针，它保存该类型的表示形式。</span><span class="yiyi-st" id="yiyi-555">当不再需要时，使用<a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code class="xref c c-func docutils literal"><span class="pre">PyDataMem_FREE</span></code></a>（ret）必须释放返回的指针<em>ret</em>，<strong></strong></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_One"><span class="yiyi-st" id="yiyi-556"> char* <code class="descname">PyArray_One</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-557">指向大小为<em>arr</em>  - &gt; itemsize的新创建的内存的指针，它保存该类型的表示形式。</span><span class="yiyi-st" id="yiyi-558">当不再需要时，使用<a class="reference internal" href="#c.PyDataMem_FREE" title="PyDataMem_FREE"><code class="xref c c-func docutils literal"><span class="pre">PyDataMem_FREE</span></code></a>（ret）必须释放返回的指针<em>ret</em>，<strong></strong></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ValidType"><span class="yiyi-st" id="yiyi-559"> int <code class="descname">PyArray_ValidType</code><span class="sig-paren">(</span>int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-560">如果<em>typenum</em>表示有效的类型号（内置或用户定义或字符代码），则返回<a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code class="xref c c-data docutils literal"><span class="pre">NPY_TRUE</span></code></a>。</span><span class="yiyi-st" id="yiyi-561">否则，此函数返回<a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code class="xref c c-data docutils literal"><span class="pre">NPY_FALSE</span></code></a>。</span></p>
</dd></dl>
</div>
<div class="section" id="new-data-types">
<h3><span class="yiyi-st" id="yiyi-562">New data types</span></h3>
<dl class="function">
<dt id="c.PyArray_InitArrFuncs"><span class="yiyi-st" id="yiyi-563"> void <code class="descname">PyArray_InitArrFuncs</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_ArrFuncs" title="PyArray_ArrFuncs">PyArray_ArrFuncs</a>*<em> f</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-564">将所有函数指针和成员初始化为<code class="docutils literal"><span class="pre">NULL</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_RegisterDataType"><span class="yiyi-st" id="yiyi-565"> int <code class="descname">PyArray_RegisterDataType</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-566">将数据类型注册为数组的新用户定义数据类型。</span><span class="yiyi-st" id="yiyi-567">类型必须填充大多数条目。</span><span class="yiyi-st" id="yiyi-568">这不总是被检查，错误可以产生segfaults。</span><span class="yiyi-st" id="yiyi-569">特别地，<code class="docutils literal"><span class="pre">dtype</span></code>结构的typeobj成员必须用具有对应于<em>dtype</em>的elsize成员的固定大小的元素大小的Python类型填充。</span><span class="yiyi-st" id="yiyi-570">此外，<code class="docutils literal"><span class="pre">f</span></code>成员必须具有必需的函数：非零，copyswap，copyswapn，getitem，setitem和cast（如果不需要支持，某些转换函数可以是<code class="docutils literal"><span class="pre">NULL</span></code> ）。</span><span class="yiyi-st" id="yiyi-571">为了避免混淆，你应该选择一个唯一的字符类型，但这不是强制的，不是内部依赖。</span></p>
<p><span class="yiyi-st" id="yiyi-572">返回唯一标识类型的用户定义类型编号。</span><span class="yiyi-st" id="yiyi-573">然后可以使用返回的类型号从<a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrFromType</span></code></a>获取指向新结构的指针。</span><span class="yiyi-st" id="yiyi-574">如果发生错误，则返回-1。</span><span class="yiyi-st" id="yiyi-575">如果此<em>dtype</em>已经注册（仅由指针的地址检查），则返回先前分配的类型号。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_RegisterCastFunc"><span class="yiyi-st" id="yiyi-576"> int <code class="descname">PyArray_RegisterCastFunc</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em>, int<em> totype</em>, PyArray_VectorUnaryFunc*<em> castfunc</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-577">注册低级别转换函数<em>castfunc</em>，将数据类型<em>descr</em>转换为给定的数据类型编号<em>totype</em> 。</span><span class="yiyi-st" id="yiyi-578">任何旧的铸造功能都被覆盖。</span><span class="yiyi-st" id="yiyi-579">成功时返回<code class="docutils literal"><span class="pre">0</span></code>或失败时返回<code class="docutils literal"><span class="pre">-1</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_RegisterCanCast"><span class="yiyi-st" id="yiyi-580"> int <code class="descname">PyArray_RegisterCanCast</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> descr</em>, int<em> totype</em>, <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND">NPY_SCALARKIND</a><em> scalar</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-581">从给定的<em>标量</em>类型的数据类型对象<em>descr</em>注册数据类型号<em>totype</em></span><span class="yiyi-st" id="yiyi-582">使用<em>标量</em> = <code class="xref c c-data docutils literal"><span class="pre">NPY_NOSCALAR</span></code>注册数据类型<em>descr</em>的数组可以安全地转换为type_number为<em>totype</em>。</span></p>
</dd></dl>
</div>
<div class="section" id="special-functions-for-npy-object">
<h3><span class="yiyi-st" id="yiyi-583">Special functions for NPY_OBJECT</span></h3>
<dl class="function">
<dt id="c.PyArray_INCREF"><span class="yiyi-st" id="yiyi-584"> int <code class="descname">PyArray_INCREF</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-585">用于包含任何Python对象的数组<em>op</em>。</span><span class="yiyi-st" id="yiyi-586">它根据<em>op</em>的数据类型增加数组中每个对象的引用计数。</span><span class="yiyi-st" id="yiyi-587">如果发生错误，则返回-1，否则返回0。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Item_INCREF"><span class="yiyi-st" id="yiyi-588"> void <code class="descname">PyArray_Item_INCREF</code><span class="sig-paren">(</span>char*<em> ptr</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-589">根据数据类型<em>dtype</em>，在位置<em>ptr</em>处对所有对象进行INCREF的函数。</span><span class="yiyi-st" id="yiyi-590">如果<em>ptr</em>是具有任何偏移量的对象的结构化类型的开始，则这将（递归地）增加结构化类型中所有类似对象的项的引用计数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_XDECREF"><span class="yiyi-st" id="yiyi-591"> int <code class="descname">PyArray_XDECREF</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-592">用于包含任何Python对象的数组<em>op</em>。</span><span class="yiyi-st" id="yiyi-593">它根据<em>op</em>的数据类型减少数组中每个对象的引用计数。</span><span class="yiyi-st" id="yiyi-594">正常返回值为0。</span><span class="yiyi-st" id="yiyi-595">如果发生错误，则返回-1。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Item_XDECREF"><span class="yiyi-st" id="yiyi-596"> void <code class="descname">PyArray_Item_XDECREF</code><span class="sig-paren">(</span>char*<em> ptr</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-597">XDECREF函数用于记录数据类型<em>dtype</em>中位置<em>ptr</em>的所有类似对象的项目。</span><span class="yiyi-st" id="yiyi-598">这样递归地工作，以便如果<code class="docutils literal"><span class="pre">dtype</span></code>本身具有包含类似对象的项的数据类型的字段，则所有类似于对象的字段将是XDECREF <code class="docutils literal"><span class="pre">&apos;d</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FillObjectArray"><span class="yiyi-st" id="yiyi-599"> void <code class="descname">PyArray_FillObjectArray</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-600">使用对象数据类型在结构中的所有位置使用单个值obj填充新创建的数组。</span><span class="yiyi-st" id="yiyi-601">不执行检查，但<em>arr</em>必须是数据类型<a class="reference internal" href="c-api.dtype.html#c.NPY_OBJECT" title="NPY_OBJECT"><code class="xref c c-type docutils literal"><span class="pre">NPY_OBJECT</span></code></a>，并且是单段和未初始化的（位置中没有上一个对象）。</span><span class="yiyi-st" id="yiyi-602">如果您需要在调用此函数之前减少对象数组中的所有项目，请使用<code class="xref c c-func docutils literal"><span class="pre">PyArray_DECREF</span></code>（<em>arr</em>）。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="array-flags">
<h2><span class="yiyi-st" id="yiyi-603">Array flags</span></h2>
<p><span class="yiyi-st" id="yiyi-604"><code class="docutils literal"><span class="pre">PyArrayObject</span></code>结构的<code class="docutils literal"><span class="pre">flags</span></code>属性包含数组（由数据成员指向）使用的内存的重要信息。此标志信息必须保持准确或奇怪的结果，甚至可能导致硒缺陷。</span></p>
<p><span class="yiyi-st" id="yiyi-605">有6个（二进制）标志，描述数据缓冲区使用的存储区。</span><span class="yiyi-st" id="yiyi-606">这些常数在<code class="docutils literal"><span class="pre">arrayobject.h</span></code>中定义，并确定标志的位位置。</span><span class="yiyi-st" id="yiyi-607">Python公开了一个很好的基于属性的接口以及一个类似字典的接口，用于获取（和，如果适当的话）这些标志。</span></p>
<p><span class="yiyi-st" id="yiyi-608">所有种类的存储器区域可以由ndarray指向，需要这些标志。</span><span class="yiyi-st" id="yiyi-609">如果你在C代码中得到一个任意的<code class="docutils literal"><span class="pre">PyArrayObject</span></code>，你需要知道设置的标志。</span><span class="yiyi-st" id="yiyi-610">如果你需要保证某种数组（如<a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a>和<a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_BEHAVED</span></code></a>），那么将这些需求传递到PyArray_FromAny函数中。</span></p>
<div class="section" id="basic-array-flags">
<h3><span class="yiyi-st" id="yiyi-611">Basic Array Flags</span></h3>
<p><span class="yiyi-st" id="yiyi-612">一个ndarray可以有一个数据段，不是一个简单的连续块的良好的记忆你可以操纵。</span><span class="yiyi-st" id="yiyi-613">它可能不与字边界对齐（在某些平台上非常重要）。</span><span class="yiyi-st" id="yiyi-614">它可能具有不同于机器识别的字节顺序的数据。</span><span class="yiyi-st" id="yiyi-615">它可能不可写。</span><span class="yiyi-st" id="yiyi-616">它可能是Fortan连续的顺序。</span><span class="yiyi-st" id="yiyi-617">数组标志用于指示关于与数组相关联的数据的内容。</span></p>
<p><span class="yiyi-st" id="yiyi-618">在NumPy的1.6版本和更早版本中，以下标志中没有_ARRAY_宏命名空间。</span><span class="yiyi-st" id="yiyi-619">这种形式的常量名在1.7中已被弃用。</span></p>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-620"><code class="descname">NPY_ARRAY_C_CONTIGUOUS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-621">数据区以C样式连续顺序（最后索引变化最快）。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-622"><code class="descname">NPY_ARRAY_F_CONTIGUOUS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-623">数据区域是Fortran风格的连续顺序（第一个索引变化最快）。</span></p>
</dd></dl>
<div class="admonition note">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-624">注意</span></p>
<p><span class="yiyi-st" id="yiyi-625">数组可以同时是C风格和Fortran风格的。</span><span class="yiyi-st" id="yiyi-626">这对于1维数组是清楚的，但对于更高维数组也是如此。</span></p>
<p><span class="yiyi-st" id="yiyi-627">Even for contiguous arrays a stride for a given dimension <code class="docutils literal"><span class="pre">arr.strides[dim]</span></code> may be <em>arbitrary</em> if <code class="docutils literal"><span class="pre">arr.shape[dim]</span> <span class="pre">==</span> <span class="pre">1</span></code> or the array has no elements. </span><span class="yiyi-st" id="yiyi-628"><em>不</em>一般认为<code class="docutils literal"><span class="pre">self.strides [-1]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span> / t1&gt;用于C型连续数组或<code class="docutils literal"><span class="pre">self.strides [0]</span> <span class="pre">==</span> <span class="pre">self.itemsize</span>  Fortran风格的连续数组是真的。</code></code></span><span class="yiyi-st" id="yiyi-629">从C API访问数组的<code class="docutils literal"><span class="pre">itemsize</span></code>的正确方法是<code class="docutils literal"><span class="pre">PyArray_ITEMSIZE(arr)</span></code>。</span></p>
<div class="last admonition seealso">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-630">也可以看看</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-631"><a class="reference internal" href="arrays.ndarray.html#arrays-ndarray"><span class="std std-ref">Internal memory layout of an ndarray</span></a></span></p>
</div>
</div>
<dl class="var">
<dt id="c.NPY_ARRAY_OWNDATA"><span class="yiyi-st" id="yiyi-632"> <code class="descname">NPY_ARRAY_OWNDATA</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-633">数据区由此数组所有。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-634"><code class="descname">NPY_ARRAY_ALIGNED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-635">数据区和所有数组元素都对齐。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-636"><code class="descname">NPY_ARRAY_WRITEABLE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-637">数据区可以写入。</span></p>
<p><span class="yiyi-st" id="yiyi-638">注意，上面的3个标志是定义的，所以一个新的，行为良好的数组有这些标志被定义为真。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-639"><code class="descname">NPY_ARRAY_UPDATEIFCOPY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-640">数据区表示一个（行为良好的）副本，当删除此数组时，该副本的信息应该被传回原始。</span></p>
<p><span class="yiyi-st" id="yiyi-641">这是一个特殊的标志，如果这个数组代表一个拷贝，因为用户需要在<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>中的某些标志，并且一个副本必须由其他数组组成（并且用户要求这个标志在这种情况下设置）。</span><span class="yiyi-st" id="yiyi-642">base属性然后指向“misbehaved”数组（设置为read_only）。</span><span class="yiyi-st" id="yiyi-643">当具有此标志集的数组被解除分配时，它将其内容复制回“错误的”数组（如果必要的话），并将“错误的”数组重置为<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>。</span><span class="yiyi-st" id="yiyi-644">如果“misbehaved”数组不是<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>开始，则<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>将返回错误，因为不能使用<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>。</span></p>
</dd></dl>
<p><span class="yiyi-st" id="yiyi-645"><a class="reference internal" href="#c.PyArray_UpdateFlags" title="PyArray_UpdateFlags"><code class="xref c c-func docutils literal"><span class="pre">PyArray_UpdateFlags</span></code></a> (obj, flags) will update the <code class="docutils literal"><span class="pre">obj-&gt;flags</span></code> for <code class="docutils literal"><span class="pre">flags</span></code> which can be any of <a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a>, <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a>, or <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>.</span></p>
</div>
<div class="section" id="combinations-of-array-flags">
<h3><span class="yiyi-st" id="yiyi-646">Combinations of array flags</span></h3>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-647"><code class="descname">NPY_ARRAY_BEHAVED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-648"><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-649"><code class="descname">NPY_ARRAY_CARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-650"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_BEHAVED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-651"><code class="descname">NPY_ARRAY_CARRAY_RO</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-652"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-653"><code class="descname">NPY_ARRAY_FARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-654"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_BEHAVED" title="NPY_ARRAY_BEHAVED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_BEHAVED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-655"><code class="descname">NPY_ARRAY_FARRAY_RO</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-656"><a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-657"><code class="descname">NPY_ARRAY_DEFAULT</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-658"><a class="reference internal" href="#c.NPY_ARRAY_CARRAY" title="NPY_ARRAY_CARRAY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_CARRAY</span></code></a></span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_ARRAY_UPDATE_ALL"><span class="yiyi-st" id="yiyi-659"> <code class="descname">NPY_ARRAY_UPDATE_ALL</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-660"><a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a></span></p>
</dd></dl>
</div>
<div class="section" id="flag-like-constants">
<h3><span class="yiyi-st" id="yiyi-661">Flag-like constants</span></h3>
<p><span class="yiyi-st" id="yiyi-662">这些常量在<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>（及其宏形式）中用于指定新数组的所需属性。</span></p>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-663"><code class="descname">NPY_ARRAY_FORCECAST</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-664">投射到所需类型，即使它不能在不丢失信息的情况下完成。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-665"><code class="descname">NPY_ARRAY_ENSURECOPY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-666">确保生成的数组是原始数据的副本。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-667"><code class="descname">NPY_ARRAY_ENSUREARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-668">确保生成的对象是实际的ndarray（或bigndarray），而不是子类。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-669"><code class="descname">NPY_ARRAY_NOTSWAPPED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-670">仅在<a class="reference internal" href="#c.PyArray_CheckFromAny" title="PyArray_CheckFromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CheckFromAny</span></code></a>中用于覆盖传入的数据类型对象的字节顺序。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-671"><code class="descname">NPY_ARRAY_BEHAVED_NS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-672"><a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a> | <a class="reference internal" href="#c.NPY_ARRAY_NOTSWAPPED" title="NPY_ARRAY_NOTSWAPPED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_NOTSWAPPED</span></code></a></span></p>
</dd></dl>
</div>
<div class="section" id="flag-checking">
<h3><span class="yiyi-st" id="yiyi-673">Flag checking</span></h3>
<p><span class="yiyi-st" id="yiyi-674">对于所有这些宏<em>arr</em>必须是<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>（的子类）的实例，但不进行检查。</span></p>
<dl class="function">
<dt id="c.PyArray_CHKFLAGS"><span class="yiyi-st" id="yiyi-675"> <code class="descname">PyArray_CHKFLAGS</code><span class="sig-paren">(</span>arr, flags<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-676">第一个参数arr必须是一个ndarray或子类。</span><span class="yiyi-st" id="yiyi-677">参数<em>flags</em>应为包含数组可能具有的标志的按位组合的整数：<a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_OWNDATA" title="NPY_ARRAY_OWNDATA"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_OWNDATA</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IS_C_CONTIGUOUS"><span class="yiyi-st" id="yiyi-678"> <code class="descname">PyArray_IS_C_CONTIGUOUS</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-679">如果<em>arr</em>是C样式连续，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IS_F_CONTIGUOUS"><span class="yiyi-st" id="yiyi-680"> <code class="descname">PyArray_IS_F_CONTIGUOUS</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-681">如果<em>arr</em>是Fortran风格连续，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISFORTRAN"><span class="yiyi-st" id="yiyi-682"> <code class="descname">PyArray_ISFORTRAN</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-683">如果<em>arr</em>是Fortran风格连续且<em>不是</em> C风格连续，则评估为true。</span><span class="yiyi-st" id="yiyi-684"><a class="reference internal" href="#c.PyArray_IS_F_CONTIGUOUS" title="PyArray_IS_F_CONTIGUOUS"><code class="xref c c-func docutils literal"><span class="pre">PyArray_IS_F_CONTIGUOUS</span></code></a>是测试Fortran风格邻接的正确方法。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISWRITEABLE"><span class="yiyi-st" id="yiyi-685"> <code class="descname">PyArray_ISWRITEABLE</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-686">如果<em>arr</em>的数据区可以写入，则评估为true</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISALIGNED"><span class="yiyi-st" id="yiyi-687"> <code class="descname">PyArray_ISALIGNED</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-688">如果<em>arr</em>的数据区在机器上正确对齐，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISBEHAVED"><span class="yiyi-st" id="yiyi-689"> <code class="descname">PyArray_ISBEHAVED</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-690">如果<em>arr</em>的数据区域根据其描述符对齐和可写，并按机器字节顺序，则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISBEHAVED_RO"><span class="yiyi-st" id="yiyi-691"> <code class="descname">PyArray_ISBEHAVED_RO</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-692">如果<em>arr</em>的数据区域以机器字节顺序对齐，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISCARRAY"><span class="yiyi-st" id="yiyi-693"> <code class="descname">PyArray_ISCARRAY</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-694">如果<em>arr</em>的数据区域是C样式连续的，并且<a class="reference internal" href="#c.PyArray_ISBEHAVED" title="PyArray_ISBEHAVED"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ISBEHAVED</span></code></a>（<em>arr</em>）为真，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISFARRAY"><span class="yiyi-st" id="yiyi-695"> <code class="descname">PyArray_ISFARRAY</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-696">如果<em>arr</em>的数据区域是Fortran式连续且<a class="reference internal" href="#c.PyArray_ISBEHAVED" title="PyArray_ISBEHAVED"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ISBEHAVED</span></code></a>（<em>arr</em>）为真，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISCARRAY_RO"><span class="yiyi-st" id="yiyi-697"> <code class="descname">PyArray_ISCARRAY_RO</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-698">如果<em>arr</em>的数据区是C样式连续，对齐和以机器字节顺序，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISFARRAY_RO"><span class="yiyi-st" id="yiyi-699"> <code class="descname">PyArray_ISFARRAY_RO</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-700">如果<em>arr</em>的数据区域是Fortran风格的连续，对齐，并且在机器字节顺序<strong>中，则评估为真。</strong></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ISONESEGMENT"><span class="yiyi-st" id="yiyi-701"> <code class="descname">PyArray_ISONESEGMENT</code><span class="sig-paren">(</span>arr<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-702">如果<em>arr</em>的数据区域由单个（C风格或Fortran风格）连续段组成，则评估为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_UpdateFlags"><span class="yiyi-st" id="yiyi-703"> void <code class="descname">PyArray_UpdateFlags</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, int<em> flagmask</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-704">可以从数组对象本身“计算”<a class="reference internal" href="#c.NPY_ARRAY_C_CONTIGUOUS" title="NPY_ARRAY_C_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_C_CONTIGUOUS</span></code></a>，<a class="reference internal" href="#c.NPY_ARRAY_ALIGNED" title="NPY_ARRAY_ALIGNED"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_ALIGNED</span></code></a>和<a class="reference internal" href="#c.NPY_ARRAY_F_CONTIGUOUS" title="NPY_ARRAY_F_CONTIGUOUS"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_F_CONTIGUOUS</span></code></a>数组标志。</span><span class="yiyi-st" id="yiyi-705">此例程通过执行所需的计算，更新<em>flagmask</em>中指定的<em>arr</em>的一个或多个标志。</span></p>
</dd></dl>
<div class="admonition warning">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-706">警告</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-707">每当使用数组进行可能导致它们更改的操作时，保持标记更新（使用<a class="reference internal" href="#c.PyArray_UpdateFlags" title="PyArray_UpdateFlags"><code class="xref c c-func docutils literal"><span class="pre">PyArray_UpdateFlags</span></code></a>可以帮助）是非常重要的。</span><span class="yiyi-st" id="yiyi-708">后来在NumPy中依赖这些标志的状态的计算不重复计算来更新它们。</span></p>
</div>
</div>
</div>
<div class="section" id="array-method-alternative-api">
<h2><span class="yiyi-st" id="yiyi-709">Array method alternative API</span></h2>
<div class="section" id="conversion">
<h3><span class="yiyi-st" id="yiyi-710">Conversion</span></h3>
<dl class="function">
<dt id="c.PyArray_GetField"><span class="yiyi-st" id="yiyi-711"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_GetField</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> offset</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-712">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.getfield</span></code>（<em>self</em>，<em>dtype</em>，<em>offset</em>）。</span><span class="yiyi-st" id="yiyi-713">使用当前数组中指定的<em>偏移量</em>中的数据（以字节为单位）返回给定<em>dtype</em>的新数组。</span><span class="yiyi-st" id="yiyi-714"><em>偏移</em>加上新数组类型的itemsize必须小于<em>self</em>  - &gt; descr-&gt; elsize或出现错误。</span><span class="yiyi-st" id="yiyi-715">使用与原数组相同的形状和步幅。</span><span class="yiyi-st" id="yiyi-716">因此，此函数具有从结构化数组返回字段的效果。</span><span class="yiyi-st" id="yiyi-717">但是，它也可以用于从任何数组类型中选择特定字节或字节组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SetField"><span class="yiyi-st" id="yiyi-718"> int <code class="descname">PyArray_SetField</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, int<em> offset</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> val</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-719">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.setfield</span></code>（<em>self</em>，<em>val</em>，<em>dtype</em>，<em>offset</em>）。</span><span class="yiyi-st" id="yiyi-720">Set the field starting at <em>offset</em> in bytes and of the given <em>dtype</em> to <em>val</em>. </span><span class="yiyi-st" id="yiyi-721"><em>偏移</em>加上<em>dtype</em>  - &gt; elsize必须小于<em>self</em>  - &gt; descr-&gt; elsize或出现错误。</span><span class="yiyi-st" id="yiyi-722">否则，<em>val</em>参数将转换为数组并复制到指向的字段中。</span><span class="yiyi-st" id="yiyi-723">如果需要，重复<em>val</em>的元素以填充目标数组。但是，目标中的元素数必须是<em>val</em>中元素数的整数倍数。 。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Byteswap"><span class="yiyi-st" id="yiyi-724"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Byteswap</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, Bool<em> inplace</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-725">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.byteswap</span></code>（<em>self</em>，<em>inplace</em>）。</span><span class="yiyi-st" id="yiyi-726">返回其数据区域已进行字节交换的数组。</span><span class="yiyi-st" id="yiyi-727">如果<em>inplace</em>为非零，则执行byteswap inplace并返回对self的引用。</span><span class="yiyi-st" id="yiyi-728">否则，创建字节交换副本并保持不变。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_NewCopy"><span class="yiyi-st" id="yiyi-729"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_NewCopy</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> old</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-730">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.copy</span></code>（<em>self</em>，<em>fortran</em>）。</span><span class="yiyi-st" id="yiyi-731">制作<em>旧</em>数组的副本。</span><span class="yiyi-st" id="yiyi-732">返回的数组总是对齐和可写的，数据解释与旧数组相同。</span><span class="yiyi-st" id="yiyi-733">如果<em>order</em>是<a class="reference internal" href="#c.NPY_CORDER" title="NPY_CORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_CORDER</span></code></a>，则返回C风格的连续数组。</span><span class="yiyi-st" id="yiyi-734">如果<em>order</em>是<a class="reference internal" href="#c.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_FORTRANORDER</span></code></a>，则返回Fortran风格的连续数组。</span><span class="yiyi-st" id="yiyi-735">如果<em>顺序是</em> <a class="reference internal" href="#c.NPY_ANYORDER" title="NPY_ANYORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_ANYORDER</span></code></a>，则返回的数组是Fortran风格的连续的，如果旧的；否则，它是C型连续的。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ToList"><span class="yiyi-st" id="yiyi-736"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ToList</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-737">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.tolist</span></code>（<em>self</em>）。</span><span class="yiyi-st" id="yiyi-738">从<em>self</em>返回嵌套的Python列表。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ToString"><span class="yiyi-st" id="yiyi-739"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ToString</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-740">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.tobytes</span></code>（<em>self</em>，<em>order</em>）。</span><span class="yiyi-st" id="yiyi-741">在Python字符串中返回此数组的字节。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ToFile"><span class="yiyi-st" id="yiyi-742"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ToFile</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, FILE*<em> fp</em>, char*<em> sep</em>, char*<em> format</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-743">以C样式连续方式将<em>self</em>的内容写入文件指针<em>fp</em>。</span><span class="yiyi-st" id="yiyi-744">如果<em>sep</em>是字符串“”或<code class="docutils literal"><span class="pre">NULL</span></code>，则将数据写为二进制字节。</span><span class="yiyi-st" id="yiyi-745">否则，使用<em>sep</em>字符串作为项目分隔符，将<em>self</em>的内容作为文本写入。</span><span class="yiyi-st" id="yiyi-746">每个项目将打印到文件。</span><span class="yiyi-st" id="yiyi-747">如果<em>格式</em>字符串不是<code class="docutils literal"><span class="pre">NULL</span></code>或“”，那么它是一个Python打印语句格式字符串，显示如何写入项目。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Dump"><span class="yiyi-st" id="yiyi-748"> int <code class="descname">PyArray_Dump</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> file</em>, int<em> protocol</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-749">将<em>self</em>中的对象拣到给定的<em>文件</em>（字符串或Python文件对象）。</span><span class="yiyi-st" id="yiyi-750">如果<em>文件</em>是Python字符串，它被认为是一个文件的名称，然后以二进制模式打开。</span><span class="yiyi-st" id="yiyi-751">使用给定的<em>协议</em>（如果<em>协议</em>为负值，或使用最高可用值）。</span><span class="yiyi-st" id="yiyi-752">这是cPickle.dump（<em>self</em>，<em>文件</em>，<em>协议</em>）的简单包装器。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Dumps"><span class="yiyi-st" id="yiyi-753"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Dumps</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> self</em>, int<em> protocol</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-754">将<em>self</em>中的对象转换为Python字符串并返回。</span><span class="yiyi-st" id="yiyi-755">使用提供的Pickle <em>协议</em>（如果<em>协议</em>为负值，则为最高可用）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FillWithScalar"><span class="yiyi-st" id="yiyi-756"> int <code class="descname">PyArray_FillWithScalar</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-757">使用给定的标量对象<em>obj</em>填充数组<em>arr</em>。</span><span class="yiyi-st" id="yiyi-758">首先将对象转换为<em>arr</em>的数据类型，然后复制到每个位置。</span><span class="yiyi-st" id="yiyi-759">如果发生错误，则返回-1，否则返回0。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_View"><span class="yiyi-st" id="yiyi-760"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_View</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/type.html#c.PyTypeObject" title="(in Python v3.7)">PyTypeObject</a><em> *ptype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-761">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.view</span></code>（<em>self</em>，<em>dtype</em>）。</span><span class="yiyi-st" id="yiyi-762">返回数组<em>self</em>的新视图可能是不同的数据类型，<em>dtype</em>和不同的数组子类<em>ptype</em>。</span></p>
<p><span class="yiyi-st" id="yiyi-763">如果<em>dtype</em>是<code class="docutils literal"><span class="pre">NULL</span></code>，则返回的数组将具有与<em>self</em>相同的数据类型。</span><span class="yiyi-st" id="yiyi-764">新数据类型必须与<em>self</em>的大小一致。</span><span class="yiyi-st" id="yiyi-765">要么项目必须相同，要么<em>self</em>必须是单段，并且字节总数必须相同。</span><span class="yiyi-st" id="yiyi-766">在后一种情况下，返回的数组的维度将在最后一个（或第一个为Fortran风格的连续数组）维度中更改。</span><span class="yiyi-st" id="yiyi-767">返回的数组和self的数据区完全相同。</span></p>
</dd></dl>
</div>
<div class="section" id="shape-manipulation">
<h3><span class="yiyi-st" id="yiyi-768">Shape Manipulation</span></h3>
<dl class="function">
<dt id="c.PyArray_Newshape"><span class="yiyi-st" id="yiyi-769"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Newshape</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims">PyArray_Dims</a>*<em> newshape</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-770">结果将是一个新的数组（如果可能，指向与<em>self</em>相同的内存位置），但具有由<em>newshape</em>给出的形状。</span><span class="yiyi-st" id="yiyi-771">如果新形状与<em>self</em>的步幅不兼容，则将返回具有新指定形状的数组的副本。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Reshape"><span class="yiyi-st" id="yiyi-772"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Reshape</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> shape</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-773">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.reshape</span></code>（<em>self</em>，<em>shape</em>）其中<em>shape</em>是一个序列。</span><span class="yiyi-st" id="yiyi-774">将<em>形状</em>转换为<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Dims</span></code></a>结构，并在内部调用<a class="reference internal" href="#c.PyArray_Newshape" title="PyArray_Newshape"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Newshape</span></code></a>。</span><span class="yiyi-st" id="yiyi-775">对于向后兼容性 - 不推荐</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Squeeze"><span class="yiyi-st" id="yiyi-776"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Squeeze</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-777">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.squeeze</span></code>（<em>self</em>）。</span><span class="yiyi-st" id="yiyi-778">返回<em>self</em>的新视图，其中从形状中删除所有长度为1的维度。</span></p>
</dd></dl>
<div class="admonition warning">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-779">警告</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-780">矩阵对象总是2维的。</span><span class="yiyi-st" id="yiyi-781">因此，<a class="reference internal" href="#c.PyArray_Squeeze" title="PyArray_Squeeze"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Squeeze</span></code></a>对矩阵子类的数组没有影响。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_SwapAxes"><span class="yiyi-st" id="yiyi-782"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_SwapAxes</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> a1</em>, int<em> a2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-783">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.swapaxes</span></code>（<em>self</em>，<em>a1</em>，<em>a2</em>）。</span><span class="yiyi-st" id="yiyi-784">返回的数组是<em>self</em>中的数据的新视图，其中给定轴，<em>a1</em>和<em>a2</em>，已交换。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Resize"><span class="yiyi-st" id="yiyi-785"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Resize</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims">PyArray_Dims</a>*<em> newshape</em>, int<em> refcheck</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> fortran</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-786">等于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.resize</span></code>（<em>self</em>，<em>newshape</em>，refcheck <code class="docutils literal"><span class="pre">=</span></code> <em>refcheck</em> = fortran）。</span><span class="yiyi-st" id="yiyi-787">此功能仅适用于单段数组。</span><span class="yiyi-st" id="yiyi-788">它会改变<em>self</em>的形状，并且如果<em>newshape</em>具有与旧形状不同的元素总数，则会重新分配<em>self</em>的内存。</span><span class="yiyi-st" id="yiyi-789">If reallocation is necessary, then <em>self</em> must own its data, have <em>self</em> - <code class="docutils literal"><span class="pre">&gt;base==NULL</span></code>, have <em>self</em> - <code class="docutils literal"><span class="pre">&gt;weakrefs==NULL</span></code>, and (unless refcheck is 0) not be referenced by any other array. </span><span class="yiyi-st" id="yiyi-790">fortran参数可以是<a class="reference internal" href="#c.NPY_ANYORDER" title="NPY_ANYORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_ANYORDER</span></code></a>，<a class="reference internal" href="#c.NPY_CORDER" title="NPY_CORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_CORDER</span></code></a>或<a class="reference internal" href="#c.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_FORTRANORDER</span></code></a>。</span><span class="yiyi-st" id="yiyi-791">它目前没有效果。</span><span class="yiyi-st" id="yiyi-792">最终，它可以用于确定在构造不同维度的数组时，调整大小操作应如何查看数据。</span><span class="yiyi-st" id="yiyi-793">成功时返回None，出错时返回NULL。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Transpose"><span class="yiyi-st" id="yiyi-794"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Transpose</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims">PyArray_Dims</a>*<em> permute</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-795">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.transpose</span></code>（<em>self</em>，<em>permute</em>）。</span><span class="yiyi-st" id="yiyi-796">根据数据结构<em>permute</em>，允许ndarray对象的轴<em>self</em>并返回结果。</span><span class="yiyi-st" id="yiyi-797">如果<em>permute</em>是<code class="docutils literal"><span class="pre">NULL</span></code>，则结果数组的轴反转。</span><span class="yiyi-st" id="yiyi-798">例如，如果<em>self</em>具有形状<img alt="10\times20\times30" class="math" src="../_images/math/0162b807852e8b7e3e771ef196f4827496a5a16a.png" style="vertical-align: -1px">，并且<em>permute</em> <code class="docutils literal"><span class="pre">.ptr</span></code>为（0,2,1），则结果的形状<img alt="10\times30\times20." class="math" src="../_images/math/208c05105f46b94766ebfea27a8b027de4e9b515.png" style="vertical-align: -1px">如果<em>permute</em>为<code class="docutils literal"><span class="pre">NULL</span></code>，则结果的形状为</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Flatten"><span class="yiyi-st" id="yiyi-799"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Flatten</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-800">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.flatten</span></code>（<em>self</em>，<em>order</em>）。</span><span class="yiyi-st" id="yiyi-801">返回数组的1-d副本。</span><span class="yiyi-st" id="yiyi-802">如果<em>order</em>是<a class="reference internal" href="#c.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_FORTRANORDER</span></code></a>，则以Fortran顺序扫描元素（第一维度的变化最快）。</span><span class="yiyi-st" id="yiyi-803">如果<em>order</em>是<a class="reference internal" href="#c.NPY_CORDER" title="NPY_CORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_CORDER</span></code></a>，则以C顺序扫描<code class="docutils literal"><span class="pre">self</span></code>的元素（最后一个维度变化最快）。</span><span class="yiyi-st" id="yiyi-804">如果<em>order</em> <a class="reference internal" href="#c.NPY_ANYORDER" title="NPY_ANYORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_ANYORDER</span></code></a>，则<a class="reference internal" href="#c.PyArray_ISFORTRAN" title="PyArray_ISFORTRAN"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ISFORTRAN</span></code></a>（<em>self</em>）的结果用于确定要展平的顺序。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Ravel"><span class="yiyi-st" id="yiyi-805"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Ravel</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-806">等同于<em>self</em> .ravel（<em>order</em>）。</span><span class="yiyi-st" id="yiyi-807">除了<em>order</em>为0和<em>self之外，与<a class="reference internal" href="#c.PyArray_Flatten" title="PyArray_Flatten"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Flatten</span></code></a>（<em>self</em>，<em>order</em> t6&gt;是C型连续，形状改变，但不执行复制。</em></span></p>
</dd></dl>
</div>
<div class="section" id="item-selection-and-manipulation">
<h3><span class="yiyi-st" id="yiyi-808">Item selection and manipulation</span></h3>
<dl class="function">
<dt id="c.PyArray_TakeFrom"><span class="yiyi-st" id="yiyi-809"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_TakeFrom</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> indices</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> ret</em>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE">NPY_CLIPMODE</a><em> clipmode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-810">等于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.take</span></code>（<em>self</em>，<em>索引</em>，<em>轴</em>，<em>ret</em>通过在C中设置<em>axis</em> = <a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code class="xref c c-data docutils literal"><span class="pre">NPY_MAXDIMS</span></code></a>可以获得<em>axis</em> = None中的<em>沿着给定的<em>轴的整数值<em>索引</em>表示。</em></em></span><span class="yiyi-st" id="yiyi-811">clipmode参数可以是<a class="reference internal" href="#c.NPY_RAISE" title="NPY_RAISE"><code class="xref c c-data docutils literal"><span class="pre">NPY_RAISE</span></code></a>，<a class="reference internal" href="#c.NPY_WRAP" title="NPY_WRAP"><code class="xref c c-data docutils literal"><span class="pre">NPY_WRAP</span></code></a>或<a class="reference internal" href="#c.NPY_CLIP" title="NPY_CLIP"><code class="xref c c-data docutils literal"><span class="pre">NPY_CLIP</span></code></a>以指示如何处理超出索引。</span><span class="yiyi-st" id="yiyi-812"><em>ret</em>参数可以指定输出数组，而不是在内部创建。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_PutTo"><span class="yiyi-st" id="yiyi-813"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_PutTo</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> values</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> indices</em>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE">NPY_CLIPMODE</a><em> clipmode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-814">等效于<em>self</em> .put（<em>值</em>，<em>索引</em>，<em>clipmode</em>）。</span><span class="yiyi-st" id="yiyi-815">将<em>值</em>置入<em>self</em>中相应的（扁平）<em>索引</em>。</span><span class="yiyi-st" id="yiyi-816">如果<em>值</em>太小，则会根据需要重复。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_PutMask"><span class="yiyi-st" id="yiyi-817"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_PutMask</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> values</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> mask</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-818">在<em>掩码</em>中的对应位置（使用展平的上下文）为真时，将<em>值</em>置于<em>自</em>中。</span><span class="yiyi-st" id="yiyi-819"><em>掩码</em>和<em>自身</em>数组必须具有相同的元素总数。</span><span class="yiyi-st" id="yiyi-820">如果<em>值</em>太小，则将根据需要重复。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Repeat"><span class="yiyi-st" id="yiyi-821"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Repeat</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, int<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-822">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.repeat</span></code>（<em>self</em>，<em>op</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-823">沿给定的<em>轴</em>复制<em>self</em>，<em>op</em>的元素。</span><span class="yiyi-st" id="yiyi-824"><em>op</em>是标量整数或长度<em>self</em>  - &gt; dimension [<em>axis</em>]的序列，表示沿轴重复每个项目的次数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Choose"><span class="yiyi-st" id="yiyi-825"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Choose</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> ret</em>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE">NPY_CLIPMODE</a><em> clipmode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-826">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.choose</span></code>（<em>self</em>，<em>op</em>，<em>ret</em>，<em>clipmode</em>）。</span><span class="yiyi-st" id="yiyi-827">基于<em>self</em>中的整数值，从<em>op</em>中的数组序列中选择元素，创建一个新的数组。</span><span class="yiyi-st" id="yiyi-828">数组必须都可以广播到相同的形状，<em>self</em>中的条目应该在0和len之间（<em>op</em>）。</span><span class="yiyi-st" id="yiyi-829">输出位于<em>ret</em>中，除非<code class="docutils literal"><span class="pre">NULL</span></code>，在这种情况下会创建新的输出。</span><span class="yiyi-st" id="yiyi-830"><em>clipmode</em>参数确定<em>self</em>中的条目不在0和len（<em>op</em>）之间的行为。</span></p>
<dl class="var">
<dt id="c.NPY_RAISE"><span class="yiyi-st" id="yiyi-831"> <code class="descname">NPY_RAISE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-832">提高ValueError；</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_WRAP"><span class="yiyi-st" id="yiyi-833"> <code class="descname">NPY_WRAP</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-834">wrap values &lt; 0 by adding len(<em>op</em>) and values &gt;=len(<em>op</em>) by subtracting len(<em>op</em>) until they are in range;</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_CLIP"><span class="yiyi-st" id="yiyi-835"> <code class="descname">NPY_CLIP</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-836">所有值都剪裁到区域[0，len（<em>op</em>））。</span></p>
</dd></dl>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Sort"><span class="yiyi-st" id="yiyi-837"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Sort</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-838">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.sort</span></code>（<em>self</em>，<em>轴</em>）。</span><span class="yiyi-st" id="yiyi-839">返回具有沿<em>轴</em>排序的<em>self</em>项目的数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ArgSort"><span class="yiyi-st" id="yiyi-840"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ArgSort</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-841">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.argsort</span></code>（<em>自身</em>，<em>轴</em>）。</span><span class="yiyi-st" id="yiyi-842">返回一个索引数组，沿着给定的<code class="docutils literal"><span class="pre">axis</span></code>选择这些索引将返回<em>self</em>的排序版本。</span><span class="yiyi-st" id="yiyi-843">如果<em>self</em>  - &gt; descr是定义了字段的数据类型，则使用自 - &gt; descr-&gt;名称来确定排序顺序。</span><span class="yiyi-st" id="yiyi-844">第一个字段相等的比较将使用第二个字段，以此类推。</span><span class="yiyi-st" id="yiyi-845">要更改结构化数组的排序顺序，请创建具有不同名称顺序的新数据类型，并使用该新数据类型构建数组的视图。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_LexSort"><span class="yiyi-st" id="yiyi-846"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_LexSort</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> sort_keys</em>, int<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-847">给定一个相同形状的数组（<em>sort_keys</em>）序列，返回一个数组的索引（类似于<a class="reference internal" href="#c.PyArray_ArgSort" title="PyArray_ArgSort"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ArgSort</span></code></a>（...）），它将按数组排序数组。</span><span class="yiyi-st" id="yiyi-848">词典式排序指定当发现两个键相等时，顺序基于随后的键的比较。</span><span class="yiyi-st" id="yiyi-849">需要为类型定义合并排序（保留相等的条目未移动）。</span><span class="yiyi-st" id="yiyi-850">通过使用第一个<em>sort_key</em>首先对索引排序，然后使用第二个<em>sort_key</em>等来完成排序。</span><span class="yiyi-st" id="yiyi-851">这相当于lexsort（<em>sort_keys</em>，<em>axis</em>）Python命令。</span><span class="yiyi-st" id="yiyi-852">由于合并排序的工作方式，请务必理解<em>sort_keys</em>必须在的顺序（与比较两个元素时使用的顺序相反）。</span></p>
<p><span class="yiyi-st" id="yiyi-853">如果这些数组都在结构化数组中收集，则<a class="reference internal" href="#c.PyArray_Sort" title="PyArray_Sort"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Sort</span></code></a>（...）也可以用于直接对数组进行排序。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SearchSorted"><span class="yiyi-st" id="yiyi-854"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_SearchSorted</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> values</em>, NPY_SEARCHSIDE<em> side</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> perm</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-855">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.searchsorted</span></code>（<em>self</em>，<em>值</em>，<em>侧</em>，<em>perm</em>）。</span><span class="yiyi-st" id="yiyi-856">假设<em>self</em>是以升序排列的1-d数组，则输出是与<em>值</em>相同形状的索引的数组，使得如果<em>值</em>插入索引之前，将保留<em>self</em>的顺序。</span><span class="yiyi-st" id="yiyi-857">没有检查自我是否是升序。</span></p>
<p><span class="yiyi-st" id="yiyi-858"><em>侧</em>参数指示返回的索引是否应为第一个合适位置（如果<code class="xref c c-data docutils literal"><span class="pre">NPY_SEARCHLEFT</span></code>）或最后一个（if <code class="xref c c-data docutils literal"><span class="pre">NPY_SEARCHRIGHT</span></code>）的索引。</span></p>
<p><span class="yiyi-st" id="yiyi-859"><em>分类器</em>参数，如果不是<code class="docutils literal"><span class="pre">NULL</span></code>，必须是与<em>self</em>长度相同的整数索引的1D数组，将其按升序排序。</span><span class="yiyi-st" id="yiyi-860">这通常是调用<a class="reference internal" href="#c.PyArray_ArgSort" title="PyArray_ArgSort"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ArgSort</span></code></a>（...）的结果。二进制搜索用于查找所需的插入点。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Partition"><span class="yiyi-st" id="yiyi-861"> int <code class="descname">PyArray_Partition</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *self</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a> *<em> ktharray</em>, int<em> axis</em>, NPY_SELECTKIND<em> which</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-862">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.partition</span></code>（<em>self</em>，<em>ktharray</em>，<em>axis</em>，<em>kind</em>）。</span><span class="yiyi-st" id="yiyi-863">对数组进行分区，使得<em>ktharray</em>索引的元素的值位于数组完全排序的位置，并且所有元素小于第k个之前，所有元素等于或大于第k个元素。</span><span class="yiyi-st" id="yiyi-864">分区内所有元素的排序未定义。</span><span class="yiyi-st" id="yiyi-865">如果<em>self</em>  - &gt; descr是定义了字段的数据类型，则使用自 - &gt; descr-&gt;名称来确定排序顺序。</span><span class="yiyi-st" id="yiyi-866">第一个字段相等的比较将使用第二个字段，以此类推。</span><span class="yiyi-st" id="yiyi-867">要更改结构化数组的排序顺序，请创建具有不同名称顺序的新数据类型，并使用该新数据类型构建数组的视图。</span><span class="yiyi-st" id="yiyi-868">成功时返回零，失败时返回-1。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ArgPartition"><span class="yiyi-st" id="yiyi-869"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ArgPartition</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a><em> *op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a> *<em> ktharray</em>, int<em> axis</em>, NPY_SELECTKIND<em> which</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-870">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.argpartition</span></code>（<em>self</em>，<em>ktharray</em>，<em>axis</em>，<em>kind</em>）。</span><span class="yiyi-st" id="yiyi-871">返回一个索引数组，沿着给定的<code class="docutils literal"><span class="pre">axis</span></code>选择这些索引将返回<em>self</em>的分区版本。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Diagonal"><span class="yiyi-st" id="yiyi-872"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Diagonal</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> offset</em>, int<em> axis1</em>, int<em> axis2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-873">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.diagonal</span></code>（<em>self</em>，<em>offset</em>，<em>axis1</em>，<em>axis2</em>）。</span><span class="yiyi-st" id="yiyi-874">返回由<em>axis1</em>和<em>axis2</em>定义的2-d数组的<em>偏移</em>对角线。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CountNonzero"><span class="yiyi-st" id="yiyi-875"> npy_intp <code class="descname">PyArray_CountNonzero</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-876"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-877">计数数组对象<em>self</em>中非零元素的数量。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Nonzero"><span class="yiyi-st" id="yiyi-878"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Nonzero</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-879">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.nonzero</span></code>（<em>self</em>）。</span><span class="yiyi-st" id="yiyi-880">返回索引数组的元组，该元组选择非零的<em>self</em>元素。</span><span class="yiyi-st" id="yiyi-881">如果（nd = <a class="reference internal" href="#c.PyArray_NDIM" title="PyArray_NDIM"><code class="xref c c-func docutils literal"><span class="pre">PyArray_NDIM</span></code></a>（<code class="docutils literal"><span class="pre">self</span></code>））== 1，则返回单个索引数组。</span><span class="yiyi-st" id="yiyi-882">索引数组具有数据类型<a class="reference internal" href="c-api.dtype.html#c.NPY_INTP" title="NPY_INTP"><code class="xref c c-data docutils literal"><span class="pre">NPY_INTP</span></code></a>。</span><span class="yiyi-st" id="yiyi-883">如果返回一个元组（nd <img alt="\neq" class="math" src="../_images/math/c3b8b3b6c1acc9da5c8e6e79430e60de668b064e.png" style="vertical-align: -4px"> 1），则其长度为nd。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Compress"><span class="yiyi-st" id="yiyi-884"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Compress</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> condition</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-885">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.compress</span></code>（<em>self</em>，<em>条件</em>，<em>轴</em>）。</span><span class="yiyi-st" id="yiyi-886">返回<em>轴</em>中对应于<em>条件</em>的元素为真的元素。</span></p>
</dd></dl>
</div>
<div class="section" id="calculation">
<h3><span class="yiyi-st" id="yiyi-887">Calculation</span></h3>
<div class="admonition tip">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-888">小费</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-889">在<a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code class="xref c c-data docutils literal"><span class="pre">NPY_MAXDIMS</span></code></a>中传递轴以获得通过在Python中传递<em>轴</em> = <code class="xref py py-const docutils literal"><span class="pre">None</span></code> 1-d数组）。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_ArgMax"><span class="yiyi-st" id="yiyi-890"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ArgMax</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-891">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.argmax</span></code>（<em>self</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-892">返回<em>self</em>沿<em>轴</em>的最大元素的索引。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ArgMin"><span class="yiyi-st" id="yiyi-893"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ArgMin</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-894">Equivalent to <code class="xref py py-meth docutils literal"><span class="pre">ndarray.argmin</span></code> (<em>self</em>, <em>axis</em>). </span><span class="yiyi-st" id="yiyi-895">返回<em>self</em>沿<em>轴</em>的最小元素的索引。</span></p>
</dd></dl>
<div class="admonition note">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-896">注意</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-897">out参数指定在何处放置结果。</span><span class="yiyi-st" id="yiyi-898">如果out为NULL，则创建输出数组，否则输出放在输出中，其必须是正确的大小和类型。</span><span class="yiyi-st" id="yiyi-899">即使out不为NULL，也始终返回对输出数组的新引用。</span><span class="yiyi-st" id="yiyi-900">例程的调用者有责任<code class="docutils literal"><span class="pre">DECREF</span></code>，如果不为NULL或发生内存泄漏。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_Max"><span class="yiyi-st" id="yiyi-901"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Max</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-902">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.max</span></code>（<em>self</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-903">沿着给定的<em>轴</em>返回<em>self</em>的最大元素。</span><span class="yiyi-st" id="yiyi-904">当结果是单个元素时，返回numpy标量而不是ndarray。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Min"><span class="yiyi-st" id="yiyi-905"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Min</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-906">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.min</span></code>（<em>self</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-907">沿给定的<em>轴</em>返回<em>self</em>的最小元素。</span><span class="yiyi-st" id="yiyi-908">当结果是单个元素时，返回numpy标量而不是ndarray。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Ptp"><span class="yiyi-st" id="yiyi-909"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Ptp</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-910">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.ptp</span></code>（<em>self</em>，<em>轴</em>）。</span><span class="yiyi-st" id="yiyi-911">返回沿<em>轴</em>的<em>self</em>的最大元素与沿<em>轴</em>的<em>self</em>的最小元素之间的差值。</span><span class="yiyi-st" id="yiyi-912">当结果是单个元素时，返回numpy标量而不是ndarray。</span></p>
</dd></dl>
<div class="admonition note">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-913">注意</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-914">rtype参数指定要进行减少的数据类型。</span><span class="yiyi-st" id="yiyi-915">如果数组的数据类型不足以处理输出，这是很重要的。</span><span class="yiyi-st" id="yiyi-916">默认情况下，对于“add”和“multiply”ufuncs（构成mean，sum，cumsum，prod和cumprod函数的基础），所有整数数据类型至少与<a class="reference internal" href="c-api.dtype.html#c.NPY_LONG" title="NPY_LONG"><code class="xref c c-data docutils literal"><span class="pre">NPY_LONG</span></code></a> ）。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_Mean"><span class="yiyi-st" id="yiyi-917"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Mean</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-918">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.mean</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-919">返回沿给定<em>轴</em>的元素的平均值，使用枚举类型<em>rtype</em>作为求和的数据类型。</span><span class="yiyi-st" id="yiyi-920">对于<em>rtype</em>，使用<a class="reference internal" href="c-api.dtype.html#c.NPY_NOTYPE" title="NPY_NOTYPE"><code class="xref c c-data docutils literal"><span class="pre">NPY_NOTYPE</span></code></a>获取默认总和行为。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Trace"><span class="yiyi-st" id="yiyi-921"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Trace</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> offset</em>, int<em> axis1</em>, int<em> axis2</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-922">Equivalent to <code class="xref py py-meth docutils literal"><span class="pre">ndarray.trace</span></code> (<em>self</em>, <em>offset</em>, <em>axis1</em>, <em>axis2</em>, <em>rtype</em>). </span><span class="yiyi-st" id="yiyi-923">Return the sum (using <em>rtype</em> as the data type of summation) over the <em>offset</em> diagonal elements of the 2-d arrays defined by <em>axis1</em> and <em>axis2</em> variables. </span><span class="yiyi-st" id="yiyi-924">正偏移选择主对角线上方的对角线。</span><span class="yiyi-st" id="yiyi-925">负偏移选择主对角线下方的对角线。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Clip"><span class="yiyi-st" id="yiyi-926"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Clip</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> min</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> max</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-927">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.clip</span></code>（<em>self</em>，<em>min</em>，<em>max</em>）。</span><span class="yiyi-st" id="yiyi-928">剪辑数组<em>self</em>，以使大于<em>max</em>的值固定为<em>max</em>，小于<em>min</em>的值为固定为<em>min</em>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Conjugate"><span class="yiyi-st" id="yiyi-929"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Conjugate</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-930">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.conjugate</span></code>（<em>self</em>）。</span><span class="yiyi-st" id="yiyi-931">返回<em>self</em>的复共轭。</span><span class="yiyi-st" id="yiyi-932">如果<em>self</em>不是复杂数据类型，则返回<em>self</em>和引用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Round"><span class="yiyi-st" id="yiyi-933"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Round</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> decimals</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-934">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.round</span></code>（<em>self</em>，<em>小数</em>，<em>out</em>）。</span><span class="yiyi-st" id="yiyi-935">返回具有四舍五入到最接近的小数位的元素的数组。</span><span class="yiyi-st" id="yiyi-936">小数位被定义为<img alt="10^{-\textrm{decimals}}" class="math" src="../_images/math/2793e58732c8a479713fc0b5fc913cb6b1c08b2b.png" style="vertical-align: -1px">数字，使得负的<em>小数</em>导致四舍五入到最接近的10，100等。</span><span class="yiyi-st" id="yiyi-937">如果out是<code class="docutils literal"><span class="pre">NULL</span></code>，则创建输出数组，否则输出放置在<em>out</em>中，它必须是正确的大小和类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Std"><span class="yiyi-st" id="yiyi-938"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Std</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-939">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.std</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-940">使用沿<em>轴</em>的数据返回标准偏差，转换为数据类型<em>rtype</em>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Sum"><span class="yiyi-st" id="yiyi-941"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Sum</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-942">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.sum</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-943">返回沿<em>轴</em>的<em>self</em>中的元素的1-d向量和。</span><span class="yiyi-st" id="yiyi-944">在将数据转换为数据类型<em>rtype</em>之后执行求和。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CumSum"><span class="yiyi-st" id="yiyi-945"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_CumSum</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-946">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.cumsum</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-947">返回沿<em>轴</em>的<em>self</em>中的元素的累积1-d总和。</span><span class="yiyi-st" id="yiyi-948">在将数据转换为数据类型<em>rtype</em>之后执行求和。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Prod"><span class="yiyi-st" id="yiyi-949"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Prod</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-950">等同于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.prod</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-951">沿<em>轴</em>返回<em>self</em>中的元素的1-d乘积。</span><span class="yiyi-st" id="yiyi-952">将数据转换为数据类型<em>rtype</em>后执行产品。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CumProd"><span class="yiyi-st" id="yiyi-953"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_CumProd</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, int<em> rtype</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-954">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.cumprod</span></code>（<em>self</em>，<em>axis</em>，<em>rtype</em>）。</span><span class="yiyi-st" id="yiyi-955">沿<code class="docutils literal"><span class="pre">axis</span></code>返回<code class="docutils literal"><span class="pre">self</span></code>中元素的1-d累积积。</span><span class="yiyi-st" id="yiyi-956">将数据转换为数据类型<code class="docutils literal"><span class="pre">rtype</span></code>后执行产品。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_All"><span class="yiyi-st" id="yiyi-957"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_All</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-958">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.all</span></code>（<em>self</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-959">对于由<code class="docutils literal"><span class="pre">axis</span></code>定义的<code class="docutils literal"><span class="pre">self</span></code>的每个1-d子数组，返回一个具有True元素的数组，其中所有元素都为True。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Any"><span class="yiyi-st" id="yiyi-960"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Any</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> self</em>, int<em> axis</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-961">等效于<code class="xref py py-meth docutils literal"><span class="pre">ndarray.any</span></code>（<em>self</em>，<em>axis</em>）。</span><span class="yiyi-st" id="yiyi-962">对于由<em>轴</em>定义的<em>self</em>的每个1-d子数组，返回一个具有True元素的数组，其中任何元素都为True。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="functions">
<h2><span class="yiyi-st" id="yiyi-963">Functions</span></h2>
<div class="section" id="array-functions">
<h3><span class="yiyi-st" id="yiyi-964">Array Functions</span></h3>
<dl class="function">
<dt id="c.PyArray_AsCArray"><span class="yiyi-st" id="yiyi-965"> int <code class="descname">PyArray_AsCArray</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>**<em> op</em>, void*<em> ptr</em>, npy_intp*<em> dims</em>, int<em> nd</em>, int<em> typenum</em>, int<em> itemsize</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-966">有时，访问作为C风格多维数组的多维数组是有用的，使得可以使用C的a [i] [j] [k]语法来实现算法。</span><span class="yiyi-st" id="yiyi-967">这个例程返回一个指针，<em>ptr</em>，它模拟这种C风格的数组，用于1，2和3-d ndarrays。</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name">
<col class="field-body">
<tbody valign="top">
<tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-968">参数：</span></th><td class="field-body"><ul class="first last simple">
<li><span class="yiyi-st" id="yiyi-969"><strong>op</strong>  - 任何Python对象的地址。</span><span class="yiyi-st" id="yiyi-970">这个Python对象将被替换为由最后两个参数指定的给定数据类型的等效行为，C样式连续的ndarray。</span><span class="yiyi-st" id="yiyi-971">确保以这种方式将引用挪到输入对象是合理的。</span></li>
<li><span class="yiyi-st" id="yiyi-972"><strong>ptr</strong>  - 指向（c-type *为1-d，ctype **为2-d或ctype ***为3-d）变量的地址，其中ctype是数据的等效C类型类型。</span><span class="yiyi-st" id="yiyi-973">返回时，<em>ptr</em>将可寻址为1-d，2-d或3-d数组。</span></li>
<li><span class="yiyi-st" id="yiyi-974"><strong>dims</strong>  - 包含数组对象形状的输出数组。</span><span class="yiyi-st" id="yiyi-975">这个数组给出了将要发生的任何循环的边界。</span></li>
<li><span class="yiyi-st" id="yiyi-976"><strong>nd</strong>  - 数组的维数（1,2或3）。</span></li>
<li><span class="yiyi-st" id="yiyi-977"><strong>typenum</strong>  - 数组的预期数据类型。</span></li>
<li><span class="yiyi-st" id="yiyi-978"><strong>itemsize</strong>  - 仅当<em>typenum</em>表示灵活数组时，才需要此参数。</span><span class="yiyi-st" id="yiyi-979">否则应为0。</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<div class="admonition note">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-980">注意</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-981">对于2-d和3-d数组，C风格数组的模拟是不完整的。</span><span class="yiyi-st" id="yiyi-982">例如，模拟的指针数组不能传递到期望特定的，静态定义的2-d和3-d数组的子程序。</span><span class="yiyi-st" id="yiyi-983">要传递到需要这些输入的函数，您必须静态定义所需的数组并复制数据。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_Free"><span class="yiyi-st" id="yiyi-984"> int <code class="descname">PyArray_Free</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, void*<em> ptr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-985">必须使用从<a class="reference internal" href="#c.PyArray_AsCArray" title="PyArray_AsCArray"><code class="xref c c-func docutils literal"><span class="pre">PyArray_AsCArray</span></code></a>（...）返回的相同对象和内存位置进行调用。</span><span class="yiyi-st" id="yiyi-986">这个函数清理内存，否则会泄露。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Concatenate"><span class="yiyi-st" id="yiyi-987"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Concatenate</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, int<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-988">沿<em>轴</em>将<em>obj</em>中的对象序列合并到单个数组中。</span><span class="yiyi-st" id="yiyi-989">如果尺寸或类型不兼容，则会出现错误。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_InnerProduct"><span class="yiyi-st" id="yiyi-990"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_InnerProduct</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj1</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj2</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-991">计算<em>obj1</em>和<em>obj2</em>的最后一个维度的乘积和。</span><span class="yiyi-st" id="yiyi-992">数组都未共轭。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MatrixProduct"><span class="yiyi-st" id="yiyi-993"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_MatrixProduct</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj1</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-994">计算<em>obj1</em>的最后一个维度和<em>obj2</em>的第二个到最后一个维度的乘积和。</span><span class="yiyi-st" id="yiyi-995">对于2-d数组，这是一个矩阵积。</span><span class="yiyi-st" id="yiyi-996">数组都未共轭。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MatrixProduct2"><span class="yiyi-st" id="yiyi-997"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_MatrixProduct2</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj1</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-998"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-999">与PyArray_MatrixProduct相同，但将结果存储在<em>out</em>中。</span><span class="yiyi-st" id="yiyi-1000"></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_EinsteinSum"><span class="yiyi-st" id="yiyi-1001"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_EinsteinSum</code><span class="sig-paren">(</span>char*<em> subscripts</em>, npy_intp<em> nop</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> op_in</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> out</em><span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-1002"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-1003">将爱因斯坦求和约定应用于提供的数组操作数，返回一个新数组或将结果放在<em>out</em>中。</span><span class="yiyi-st" id="yiyi-1004"><em>下标</em>中的字符串是以逗号分隔的索引字母列表。</span><span class="yiyi-st" id="yiyi-1005">操作数的数目在<em>nop</em>中，而<em>op_in</em>是包含这些操作数的数组。</span><span class="yiyi-st" id="yiyi-1006">The data type of the output can be forced with <em>dtype</em>, the output order can be forced with <em>order</em> (<a class="reference internal" href="#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_KEEPORDER</span></code></a> is recommended), and when <em>dtype</em> is specified, <em>casting</em> indicates how permissive the data conversion should be.</span></p>
<p><span class="yiyi-st" id="yiyi-1007">有关详细信息，请参阅<code class="xref py py-func docutils literal"><span class="pre">einsum</span></code>功能。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CopyAndTranspose"><span class="yiyi-st" id="yiyi-1008"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_CopyAndTranspose</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1009">仅适用于2-d数组的专用复制和转置函数。</span><span class="yiyi-st" id="yiyi-1010">返回的数组是<em>op</em>的转置副本。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Correlate"><span class="yiyi-st" id="yiyi-1011"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Correlate</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op1</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op2</em>, int<em> mode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1012">计算1-d数组<em>op1</em>和<em>op2</em>的1-d相关性。</span><span class="yiyi-st" id="yiyi-1013">通过将<em>op1</em>乘以<em>op2</em>的移位版本并对结果求和，在每个输出点计算相关性。</span><span class="yiyi-st" id="yiyi-1014">作为移位的结果，在<em>op1</em>和<em>op2</em>的定义范围之外的所需值被解释为零。</span><span class="yiyi-st" id="yiyi-1015">The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as <em>op1</em>, 2 - return all possible shifts (any overlap at all is accepted).</span></p>
<p class="rubric"><span class="yiyi-st" id="yiyi-1016">笔记</span></p>
<p><span class="yiyi-st" id="yiyi-1017">这不计算通常的相关性：如果op2大于op1，则参数被交换，并且从不采用复数数组的共轭。</span><span class="yiyi-st" id="yiyi-1018">对于通常的信号处理相关性，参见PyArray_Correlate2。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Correlate2"><span class="yiyi-st" id="yiyi-1019"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Correlate2</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op1</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op2</em>, int<em> mode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1020">PyArray_Correlate的更新版本，它使用1d数组的相关性的通常定义。</span><span class="yiyi-st" id="yiyi-1021">通过将<em>op1</em>乘以<em>op2</em>的移位版本并对结果求和，在每个输出点计算相关性。</span><span class="yiyi-st" id="yiyi-1022">作为移位的结果，在<em>op1</em>和<em>op2</em>的定义范围之外的所需值被解释为零。</span><span class="yiyi-st" id="yiyi-1023">模式决定了转移到返回：0  - 只返回并不需要承担零值的变化； 1  - 返回一个对象，它是大小<em> OP1  T0&gt;，2个相同 - 返回所有可能发生的变化（在所有的任何重叠被接受）。</em></span></p>
<p class="rubric"><span class="yiyi-st" id="yiyi-1024">笔记</span></p>
<p><span class="yiyi-st" id="yiyi-1025">计算z如下：</span></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_n</span> <span class="n">op1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">conj</span><span class="p">(</span><span class="n">op2</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">k</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Where"><span class="yiyi-st" id="yiyi-1026"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Where</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> condition</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> x</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> y</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1027">如果<code class="docutils literal"><span class="pre">x</span></code>和<code class="docutils literal"><span class="pre">y</span></code>都是<code class="docutils literal"><span class="pre">NULL</span></code>，则返回<a class="reference internal" href="#c.PyArray_Nonzero" title="PyArray_Nonzero"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Nonzero</span></code></a>（<em>condition</em>）。</span><span class="yiyi-st" id="yiyi-1028">否则，必须给出<em>x</em>和<em>y</em>，并且返回的对象的形状类似于<em>条件</em>，并且元素为<em>x</em>和<em>y</em>其中<em>条件</em>分别为True或False。</span></p>
</dd></dl>
</div>
<div class="section" id="other-functions">
<h3><span class="yiyi-st" id="yiyi-1029">Other functions</span></h3>
<dl class="function">
<dt id="c.PyArray_CheckStrides"><span class="yiyi-st" id="yiyi-1030"> Bool <code class="descname">PyArray_CheckStrides</code><span class="sig-paren">(</span>int<em> elsize</em>, int<em> nd</em>, npy_intp<em> numbytes</em>, npy_intp*<em> dims</em>, npy_intp*<em> newstrides</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1031">Determine if <em>newstrides</em> is a strides array consistent with the memory of an <em>nd</em> -dimensional array with shape <code class="docutils literal"><span class="pre">dims</span></code> and element-size, <em>elsize</em>. </span><span class="yiyi-st" id="yiyi-1032">检查<em>newstrides</em>数组以查看在每个方向上跳过所提供的字节数是否意味着跳过多于<em>numbytes</em>，这是可用存储器段的假定大小。</span><span class="yiyi-st" id="yiyi-1033">If <em>numbytes</em> is 0, then an equivalent <em>numbytes</em> is computed assuming <em>nd</em>, <em>dims</em>, and <em>elsize</em> refer to a single-segment array. </span><span class="yiyi-st" id="yiyi-1034">如果<em>newstrides</em>是可接受的，则返回<a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code class="xref c c-data docutils literal"><span class="pre">NPY_TRUE</span></code></a>，否则返回<a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code class="xref c c-data docutils literal"><span class="pre">NPY_FALSE</span></code></a>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiplyList"><span class="yiyi-st" id="yiyi-1035"> npy_intp <code class="descname">PyArray_MultiplyList</code><span class="sig-paren">(</span>npy_intp*<em> seq</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiplyIntList"><span class="yiyi-st" id="yiyi-1036"> int <code class="descname">PyArray_MultiplyIntList</code><span class="sig-paren">(</span>int*<em> seq</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1037">这两个例程都乘以整数的<em>n</em>长度数组，<em>seq</em>，并返回结果。</span><span class="yiyi-st" id="yiyi-1038">不执行溢出检查。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CompareLists"><span class="yiyi-st" id="yiyi-1039"> int <code class="descname">PyArray_CompareLists</code><span class="sig-paren">(</span>npy_intp*<em> l1</em>, npy_intp*<em> l2</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1040">给定两个<em>n</em>长度的整数数组，<em>l1</em>和<em>l2</em>，如果列表相同，则返回1；否则，返回0。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="auxiliary-data-with-object-semantics">
<h2><span class="yiyi-st" id="yiyi-1041">Auxiliary Data With Object Semantics</span></h2>
<div class="versionadded">
<p><span class="yiyi-st" id="yiyi-1042"><span class="versionmodified">版本1.7.0中的新功能。</span></span></p>
</div>
<dl class="type">
<dt id="c.NpyAuxData"><span class="yiyi-st" id="yiyi-1043"> <code class="descname">NpyAuxData</code></span></dt>
<dd></dd></dl>
<p><span class="yiyi-st" id="yiyi-1044">当使用由其他类型（例如struct dtype）组成的更复杂的dtypes时，创建操作dtypes的内循环需要继承附加数据。</span><span class="yiyi-st" id="yiyi-1045">NumPy通过struct <a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><code class="xref c c-type docutils literal"><span class="pre">NpyAuxData</span></code></a>支持这个想法，强制使用一些约定，以便可以这样做。</span></p>
<p><span class="yiyi-st" id="yiyi-1046">定义<a class="reference internal" href="#c.NpyAuxData" title="NpyAuxData"><code class="xref c c-type docutils literal"><span class="pre">NpyAuxData</span></code></a>类似于在C ++中定义类，但是对象语义必须手动跟踪，因为API在C中。这里是一个函数的示例，它使用元素复印机函数作为原语。</span><span class="yiyi-st" id="yiyi-1047">：</span></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">NpyAuxData</span> <span class="n">base</span><span class="p">;</span>
    <span class="n">ElementCopier_Func</span> <span class="o">*</span><span class="n">func</span><span class="p">;</span>
    <span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">funcdata</span><span class="p">;</span>
<span class="p">}</span> <span class="n">eldoubler_aux_data</span><span class="p">;</span>

<span class="n">void</span> <span class="n">free_element_doubler_aux_data</span><span class="p">(</span><span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">eldoubler_aux_data</span> <span class="o">*</span><span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">eldoubler_aux_data</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
    <span class="o">/*</span> <span class="n">Free</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">owned</span> <span class="n">by</span> <span class="n">this</span> <span class="n">auxadata</span> <span class="o">*/</span>
    <span class="n">NPY_AUXDATA_FREE</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">funcdata</span><span class="p">);</span>
    <span class="n">PyArray_free</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">clone_element_doubler_aux_data</span><span class="p">(</span><span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">eldoubler_aux_data</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">PyArray_malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">eldoubler_aux_data</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">/*</span> <span class="n">Raw</span> <span class="n">copy</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">data</span> <span class="o">*/</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">eldoubler_aux_data</span><span class="p">));</span>

    <span class="o">/*</span> <span class="n">Fix</span> <span class="n">up</span> <span class="n">the</span> <span class="n">owned</span> <span class="n">auxdata</span> <span class="n">so</span> <span class="n">we</span> <span class="n">have</span> <span class="n">our</span> <span class="n">own</span> <span class="n">copy</span> <span class="o">*/</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">funcdata</span> <span class="o">=</span> <span class="n">NPY_AUXDATA_CLONE</span><span class="p">(</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">funcdata</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">funcdata</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyArray_free</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">NpyAuxData</span> <span class="o">*</span><span class="p">)</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">create_element_doubler_aux_data</span><span class="p">(</span>
                            <span class="n">ElementCopier_Func</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span>
                            <span class="n">NpyAuxData</span> <span class="o">*</span><span class="n">funcdata</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">eldoubler_aux_data</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">PyArray_malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">eldoubler_aux_data</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_NoMemory</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">eldoubler_aux_data</span><span class="p">));</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">free_element_doubler_aux_data</span><span class="p">;</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">clone</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">clone_element_doubler_aux_data</span><span class="p">;</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
    <span class="n">ret</span><span class="o">-&gt;</span><span class="n">funcdata</span> <span class="o">=</span> <span class="n">funcdata</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">NpyAuxData</span> <span class="o">*</span><span class="p">)</span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="type">
<dt id="c.NpyAuxData_FreeFunc"><span class="yiyi-st" id="yiyi-1048"> <code class="descname">NpyAuxData_FreeFunc</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1049">NpyAuxData的函数指针类型自由函数。</span></p>
</dd></dl>
<dl class="type">
<dt id="c.NpyAuxData_CloneFunc"><span class="yiyi-st" id="yiyi-1050"> <code class="descname">NpyAuxData_CloneFunc</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1051">NpyAuxData克隆函数的函数指针类型。</span><span class="yiyi-st" id="yiyi-1052">这些函数不应该设置Python异常错误，因为它们可能从多线程上下文中调用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.NPY_AUXDATA_FREE"><span class="yiyi-st" id="yiyi-1053"> <code class="descname">NPY_AUXDATA_FREE</code><span class="sig-paren">(</span>auxdata<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1054">一个宏适当地调用auxdata的自由函数，如果auxdata为NULL，则不执行任何操作。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.NPY_AUXDATA_CLONE"><span class="yiyi-st" id="yiyi-1055"> <code class="descname">NPY_AUXDATA_CLONE</code><span class="sig-paren">(</span>auxdata<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1056">一个宏，适当地调用auxdata的克隆函数，返回辅助数据的深拷贝。</span></p>
</dd></dl>
</div>
<div class="section" id="array-iterators">
<h2><span class="yiyi-st" id="yiyi-1057">Array Iterators</span></h2>
<p><span class="yiyi-st" id="yiyi-1058">从NumPy 1.6.0开始，这些数组迭代器被新的数组迭代器<a class="reference internal" href="c-api.iterator.html#c.NpyIter" title="NpyIter"><code class="xref c c-type docutils literal"><span class="pre">NpyIter</span></code></a>所取代。</span></p>
<p><span class="yiyi-st" id="yiyi-1059">数组迭代器是一种快速有效地访问N维数组元素的简单方法。</span><span class="yiyi-st" id="yiyi-1060">部分<a class="reference external" href="#sec-array-iterator">2</a>提供了有关循环数组的有用方法的更多描述和示例。</span></p>
<dl class="function">
<dt id="c.PyArray_IterNew"><span class="yiyi-st" id="yiyi-1061"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_IterNew</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1062">从数组<em>arr</em>返回一个数组迭代器对象。</span><span class="yiyi-st" id="yiyi-1063">这相当于<em>arr</em>。</span><span class="yiyi-st" id="yiyi-1064"><strong>flat</strong>。</span><span class="yiyi-st" id="yiyi-1065">数组迭代器对象使得以C样式连续方式循环N维非连续数组变得容易。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IterAllButAxis"><span class="yiyi-st" id="yiyi-1066"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_IterAllButAxis</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> arr</em>, int<em> *axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1067">返回一个数组迭代器，它将遍历所有轴，但在<em>* axis</em>中提供。</span><span class="yiyi-st" id="yiyi-1068">返回的迭代器不能与<a class="reference internal" href="#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ITER_GOTO1D</span></code></a>一起使用。</span><span class="yiyi-st" id="yiyi-1069">这个迭代器可以用来写一些类似于ufuncs的东西，其中最大轴上的循环由单独的子例程完成。</span><span class="yiyi-st" id="yiyi-1070">如果<em>* axis</em>为负，那么<em>* axis</em>将设置为具有最小步幅的轴，并且将使用该轴。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_BroadcastToShape"><span class="yiyi-st" id="yiyi-1071"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_BroadcastToShape</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> arr</em>, npy_intp<em> *dimensions</em>, int<em> nd</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1072">返回一个数组迭代器，该迭代器广播以作为由<em>维</em>和<em>nd</em>提供的形状的数组进行迭代。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArrayIter_Check"><span class="yiyi-st" id="yiyi-1073"> int <code class="descname">PyArrayIter_Check</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1074">如果<em>op</em>是数组迭代器（或数组迭代器类型的子类的实例），则计算true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_RESET"><span class="yiyi-st" id="yiyi-1075"> void <code class="descname">PyArray_ITER_RESET</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1076">将<em>迭代器</em>重置为数组的开头。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_NEXT"><span class="yiyi-st" id="yiyi-1077"> void <code class="descname">PyArray_ITER_NEXT</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1078">使<em>迭代器</em>的索引和dataptr成员偏向以指向数组的下一个元素。</span><span class="yiyi-st" id="yiyi-1079">如果数组不是（C风格）连续的，也增加N维坐标数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_DATA"><span class="yiyi-st" id="yiyi-1080"> void *<code class="descname">PyArray_ITER_DATA</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1081">指向数组的当前元素的指针。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_GOTO"><span class="yiyi-st" id="yiyi-1082"> void <code class="descname">PyArray_ITER_GOTO</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em>, npy_intp*<em> destination</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1083">设置<em>迭代器</em> index，dataptr并将成员坐标指向由N维c阵列<em>目标</em>指示的数组中的位置，其大小必须至少<em> iterator</em>  - &gt; nd_m1 + 1。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_GOTO1D"><span class="yiyi-st" id="yiyi-1084"> <code class="descname">PyArray_ITER_GOTO1D</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em>, npy_intp<em> index</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1085">将<em>iterator</em>索引和dataptr设置为数组中由整数<em>index</em>指示的位置，该位置指向C样式扁平数组中的元素。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ITER_NOTDONE"><span class="yiyi-st" id="yiyi-1086"> int <code class="descname">PyArray_ITER_NOTDONE</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> iterator</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1087">只要迭代器没有循环遍历所有元素，则求值为TRUE，否则求值为FALSE。</span></p>
</dd></dl>
</div>
<div class="section" id="broadcasting-multi-iterators">
<h2><span class="yiyi-st" id="yiyi-1088">Broadcasting (multi-iterators)</span></h2>
<dl class="function">
<dt id="c.PyArray_MultiIterNew"><span class="yiyi-st" id="yiyi-1089"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_MultiIterNew</code><span class="sig-paren">(</span>int<em> num</em>, ...<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1090">广播的简化接口。</span><span class="yiyi-st" id="yiyi-1091">此函数接受要广播的数组的数目，然后是<em>num</em> extra（<code class="xref c c-type docutils literal"><span class="pre">PyObject</span> <span class="pre">*</span> </code></span><span class="yiyi-st" id="yiyi-1092">这些参数被转换为数组，并创建迭代器。</span><span class="yiyi-st" id="yiyi-1093"><a class="reference internal" href="#c.PyArray_Broadcast" title="PyArray_Broadcast"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Broadcast</span></code></a>。</span><span class="yiyi-st" id="yiyi-1094">然后返回所得到的广播的多迭代器对象。</span><span class="yiyi-st" id="yiyi-1095">然后可以使用单个循环并使用<a class="reference internal" href="#c.PyArray_MultiIter_NEXT" title="PyArray_MultiIter_NEXT"><code class="xref c c-func docutils literal"><span class="pre">PyArray_MultiIter_NEXT</span></code></a>（..）执行广播操作</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_RESET"><span class="yiyi-st" id="yiyi-1096"> void <code class="descname">PyArray_MultiIter_RESET</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1097">将所有迭代器重置为多重迭代器对象<em>multi</em>中的开头。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_NEXT"><span class="yiyi-st" id="yiyi-1098"> void <code class="descname">PyArray_MultiIter_NEXT</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1099">将多迭代器对象中的每个迭代器<em>多</em>前进到其下一个（广播的）元素。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_DATA"><span class="yiyi-st" id="yiyi-1100"> void *<code class="descname">PyArray_MultiIter_DATA</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em>, int<em> i</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1101">返回多迭代器对象中<em>i</em> <img alt="^{\textrm{th}}" class="math" src="../_images/math/c7201dfb8acbb9adb5fc06d19acb1604d16472f5.png" style="vertical-align: 6px">迭代器的数据指针。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_NEXTi"><span class="yiyi-st" id="yiyi-1102"> void <code class="descname">PyArray_MultiIter_NEXTi</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em>, int<em> i</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1103">只推进<em>i</em> <img alt="^{\textrm{th}}" class="math" src="../_images/math/c7201dfb8acbb9adb5fc06d19acb1604d16472f5.png" style="vertical-align: 6px">迭代器的指针。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_GOTO"><span class="yiyi-st" id="yiyi-1104"> void <code class="descname">PyArray_MultiIter_GOTO</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em>, npy_intp*<em> destination</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1105">将多迭代器对象中的每个迭代器<em>多</em>推进到给定的<img alt="N" class="math" src="../_images/math/10f77f12438cb385098c4d2344aaa427d0a462a8.png" style="vertical-align: 0px">二维<em>目标</em>，其中<img alt="N" class="math" src="../_images/math/10f77f12438cb385098c4d2344aaa427d0a462a8.png" style="vertical-align: 0px">是广播数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_GOTO1D"><span class="yiyi-st" id="yiyi-1106"> void <code class="descname">PyArray_MultiIter_GOTO1D</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em>, npy_intp<em> index</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1107">将多重迭代器对象<em>多</em>中的每个迭代器推进到<em>索引</em>的对应位置到展平的广播数组中。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MultiIter_NOTDONE"><span class="yiyi-st" id="yiyi-1108"> int <code class="descname">PyArray_MultiIter_NOTDONE</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> multi</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1109">只要多迭代器未遍历（广播结果的）所有元素，则评估为TRUE，否则评估为FALSE。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Broadcast"><span class="yiyi-st" id="yiyi-1110"> int <code class="descname">PyArray_Broadcast</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject">PyArrayMultiIterObject</a>*<em> mit</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1111">此功能封装了广播规则。</span><span class="yiyi-st" id="yiyi-1112"><em>mit</em>容器应该已经包含需要广播的所有数组的迭代器。</span><span class="yiyi-st" id="yiyi-1113">在返回时，这些迭代器将被调整，使得每个迭代将同时完成广播。</span><span class="yiyi-st" id="yiyi-1114">如果发生错误，则返回负数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_RemoveSmallest"><span class="yiyi-st" id="yiyi-1115"> int <code class="descname">PyArray_RemoveSmallest</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayMultiIterObject" title="PyArrayMultiIterObject">PyArrayMultiIterObject</a>*<em> mit</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1116">此函数接受先前已“广播”的多迭代器对象，在广播结果中找到具有最小“和步长”的维度，并适配所有迭代器，以便不迭代该维度（通过有效地使它们长度-1）。</span><span class="yiyi-st" id="yiyi-1117">返回相应的维度，除非<em>mit</em>  - &gt; nd为0，则返回-1。</span><span class="yiyi-st" id="yiyi-1118">该函数对于构造类似于广播其输入的类似ufunc的例程很有用，然后调用该例程的1-d版本作为内循环。</span><span class="yiyi-st" id="yiyi-1119">这个1-d版本通常针对速度进行优化，因此，应该在不需要大步幅跳跃的轴上执行循环。</span></p>
</dd></dl>
</div>
<div class="section" id="neighborhood-iterator">
<h2><span class="yiyi-st" id="yiyi-1120">Neighborhood iterator</span></h2>
<div class="versionadded">
<p><span class="yiyi-st" id="yiyi-1121"><span class="versionmodified">版本1.4.0中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-1122">邻域迭代器是迭代器对象的子类，可以用于遍历点的邻域。</span><span class="yiyi-st" id="yiyi-1123">例如，您可能想要在3D图像的每个体素上迭代，并且对于每个这样的体素，在超立方体上迭代。</span><span class="yiyi-st" id="yiyi-1124">邻域迭代器自动处理边界，从而使这种代码比手动边界处理更容易编写，代价是轻微的开销。</span></p>
<dl class="function">
<dt id="c.PyArray_NeighborhoodIterNew"><span class="yiyi-st" id="yiyi-1125"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_NeighborhoodIterNew</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayIterObject" title="PyArrayIterObject">PyArrayIterObject</a>*<em> iter</em>, npy_intp<em> bounds</em>, int<em> mode</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> fill_value</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1126">此函数从现有的迭代器创建一个新的邻域迭代器。</span><span class="yiyi-st" id="yiyi-1127">邻域将相对于由<em>iter</em>当前指向的位置计算，边界定义邻域迭代器的形状，模式参数定义边界处理模式。</span></p>
<p><span class="yiyi-st" id="yiyi-1128"><em>bounds</em>参数预期为（2 * iter-&gt; ao-&gt; nd）数组，例如范围bound [2 * i]  - &gt; bounds [2 * i + 1]范围，对于维度i（两个边界都包括在行走坐标中）。</span><span class="yiyi-st" id="yiyi-1129">边界应该为每个维度排序（bounds [2 * i]</span></p>
<p><span class="yiyi-st" id="yiyi-1130">模式应为以下之一：</span></p>
<ul class="simple">
<li><span class="yiyi-st" id="yiyi-1131">NPY_NEIGHBORHOOD_ITER_ZERO_PADDING：零填充。</span><span class="yiyi-st" id="yiyi-1132">外边界值将为0。</span></li>
<li><span class="yiyi-st" id="yiyi-1133">NPY_NEIGHBORHOOD_ITER_ONE_PADDING：一个填充，外边界值将为1。</span></li>
<li><span class="yiyi-st" id="yiyi-1134">NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING：常量填充。</span><span class="yiyi-st" id="yiyi-1135">外部边界值将与fill_value中的第一个项目相同。</span></li>
<li><span class="yiyi-st" id="yiyi-1136">NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING：镜像填充。</span><span class="yiyi-st" id="yiyi-1137">外部边界值将像数组项目被镜像一样。</span><span class="yiyi-st" id="yiyi-1138">例如，对于数组[1,2,3,4]，x [-2]为2，x [-2]为1，x [4]为4，x [等等...</span></li>
<li><span class="yiyi-st" id="yiyi-1139">NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING：圆形填充。</span><span class="yiyi-st" id="yiyi-1140">外部边界值将像数组被重复一样。</span><span class="yiyi-st" id="yiyi-1141">例如，对于数组[1,2,3,4]，x [-2]为3，x [-2]为4，x [4]为1，x [5]等等...</span></li>
</ul>
<p><span class="yiyi-st" id="yiyi-1142">如果模式是常量填充（NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING），fill_value应指向一个保存填充值的数组对象（如果数组包含多个项目，则第一个项目将是填充值）。</span><span class="yiyi-st" id="yiyi-1143">对于其他情况，fill_value可以为NULL。</span></p>
<ul class="simple">
<li><span class="yiyi-st" id="yiyi-1144">迭代器持有对iter的引用</span></li>
<li><span class="yiyi-st" id="yiyi-1145">在失败时返回NULL（在这种情况下，iter的引用计数不更改）</span></li>
<li><span class="yiyi-st" id="yiyi-1146">iter本身可以是一个Neighborhood迭代器：这可以用于.e.g自动边界处理</span></li>
<li><span class="yiyi-st" id="yiyi-1147">该函数返回的对象应该安全地用作正常的迭代器</span></li>
<li><span class="yiyi-st" id="yiyi-1148">如果iter的位置改变，对PyArrayNeighborhoodIter_Next的任何后续调用是未定义的行为，并且必须调用PyArrayNeighborhoodIter_Reset。</span></li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span></span>PyArrayIterObject \*iter;
PyArrayNeighborhoodIterObject \*neigh_iter;
iter = PyArray_IterNew(x);

//For a 3x3 kernel
bounds = {-1, 1, -1, 1};
neigh_iter = (PyArrayNeighborhoodIterObject*)PyArrayNeighborhoodIter_New(
     iter, bounds, NPY_NEIGHBORHOOD_ITER_ZERO_PADDING, NULL);

for(i = 0; i &lt; iter-&gt;size; ++i) {
     for (j = 0; j &lt; neigh_iter-&gt;size; ++j) {
             // Walk around the item currently pointed by iter-&gt;dataptr
             PyArrayNeighborhoodIter_Next(neigh_iter);
     }

     // Move to the next point of iter
     PyArrayIter_Next(iter);
     PyArrayNeighborhoodIter_Reset(neigh_iter);
}
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="c.PyArrayNeighborhoodIter_Reset"><span class="yiyi-st" id="yiyi-1149"> int <code class="descname">PyArrayNeighborhoodIter_Reset</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayNeighborhoodIterObject" title="PyArrayNeighborhoodIterObject">PyArrayNeighborhoodIterObject</a>*<em> iter</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1150">将迭代器位置重置为邻域的第一个点。</span><span class="yiyi-st" id="yiyi-1151">这应该在每当PyArray_NeighborhoodIterObject给出的iter参数被改变时被调用（见例子）</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArrayNeighborhoodIter_Next"><span class="yiyi-st" id="yiyi-1152"> int <code class="descname">PyArrayNeighborhoodIter_Next</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayNeighborhoodIterObject" title="PyArrayNeighborhoodIterObject">PyArrayNeighborhoodIterObject</a>*<em> iter</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1153">调用后，iter-&gt; dataptr指向邻域的下一个点。</span><span class="yiyi-st" id="yiyi-1154">在访问邻域的每个点之后调用此函数是未定义的。</span></p>
</dd></dl>
</div>
<div class="section" id="array-scalars">
<h2><span class="yiyi-st" id="yiyi-1155">Array Scalars</span></h2>
<dl class="function">
<dt id="c.PyArray_Return"><span class="yiyi-st" id="yiyi-1156"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Return</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1157">此函数窃取对<em>arr</em>的引用。</span></p>
<p><span class="yiyi-st" id="yiyi-1158">此函数检查<em>arr</em>是否为0维数组，如果是，返回相应的数组标量。</span><span class="yiyi-st" id="yiyi-1159">当0维数组可以返回到Python时，应该使用它。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_Scalar"><span class="yiyi-st" id="yiyi-1160"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_Scalar</code><span class="sig-paren">(</span>void*<em> data</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> itemsize</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1161">通过<strong>从<em>数据</em>所指向的内存中复制</strong>返回给定枚举<em>typenum</em>和<em>itemsize</em>的数组标量对象。</span><span class="yiyi-st" id="yiyi-1162">如果<em>swap</em>为非零，则此函数将字节交换数据（如果适用于数据类型），因为数组标量总是以正确的机器字节顺序。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ToScalar"><span class="yiyi-st" id="yiyi-1163"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_ToScalar</code><span class="sig-paren">(</span>void*<em> data</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1164">返回从由<em>数据</em>指向的内存复制的数组对象<em>arr</em>指示的类型和项目大小的数组标量对象，如果<em>arr 不是机器字节顺序。</em></span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FromScalar"><span class="yiyi-st" id="yiyi-1165"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_FromScalar</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> scalar</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> outcode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1166">从<em>标量</em>返回由<em>outcode</em>确定的类型的0维数组，它应该是数组标量对象。</span><span class="yiyi-st" id="yiyi-1167">如果<em>outcode</em>为NULL，则从<em>标量</em>确定类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ScalarAsCtype"><span class="yiyi-st" id="yiyi-1168"> void <code class="descname">PyArray_ScalarAsCtype</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> scalar</em>, void*<em> ctypeptr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1169">在<em>ctypeptr</em>中返回一个指向数组标量中实际值的指针。</span><span class="yiyi-st" id="yiyi-1170">没有错误检查，因此<em>标量</em>必须是数组标量对象，ctypeptr必须有足够的空间来保存正确的类型。</span><span class="yiyi-st" id="yiyi-1171">对于灵活大小的类型，将数据的指针复制到<em>ctypeptr</em>的内存中，对于所有其他类型，实际数据将复制到<em>ctypeptr</em> 。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CastScalarToCtype"><span class="yiyi-st" id="yiyi-1172"> void <code class="descname">PyArray_CastScalarToCtype</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> scalar</em>, void*<em> ctypeptr</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> outcode</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1173">将数组标量<em>标量</em>中的数据（转换为<em>outcode</em>指示的数据类型）返回到<em>ctypeptr</em>其必须足够大以处理传入的存储器）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_TypeObjectFromType"><span class="yiyi-st" id="yiyi-1174"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_TypeObjectFromType</code><span class="sig-paren">(</span>int<em> type</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1175">从类型号<em>类型</em>返回标量类型对象。</span><span class="yiyi-st" id="yiyi-1176">相当于<a class="reference internal" href="#c.PyArray_DescrFromType" title="PyArray_DescrFromType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrFromType</span></code></a>（<em>type</em>） - &gt; typeobj，除了引用计数和错误检查。</span><span class="yiyi-st" id="yiyi-1177">在成功时返回对typeObject的新引用，或在失败时返回<code class="docutils literal"><span class="pre">NULL</span></code>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ScalarKind"><span class="yiyi-st" id="yiyi-1178"> <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND">NPY_SCALARKIND</a> <code class="descname">PyArray_ScalarKind</code><span class="sig-paren">(</span>int<em> typenum</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> arr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1179">有关NumPy 1.6.0中引入的替代机制，请参阅函数<a class="reference internal" href="#c.PyArray_MinScalarType" title="PyArray_MinScalarType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_MinScalarType</span></code></a>。</span></p>
<p><span class="yiyi-st" id="yiyi-1180">返回由<em>typenum</em>表示的标量和<em>* arr</em>中的数组（如果<em>arr</em>不是<code class="docutils literal"><span class="pre">NULL</span></code>）。</span><span class="yiyi-st" id="yiyi-1181">数组假定为秩0，并且仅当<em>typenum</em>表示有符号整数时使用。</span><span class="yiyi-st" id="yiyi-1182">If <em>arr</em> is not <code class="docutils literal"><span class="pre">NULL</span></code> and the first element is negative then <code class="xref c c-data docutils literal"><span class="pre">NPY_INTNEG_SCALAR</span></code> is returned, otherwise <code class="xref c c-data docutils literal"><span class="pre">NPY_INTPOS_SCALAR</span></code> is returned. </span><span class="yiyi-st" id="yiyi-1183">可能的返回值为<code class="xref c c-data docutils literal"><span class="pre">NPY_{kind}_SCALAR</span></code>其中<code class="docutils literal"><span class="pre">{kind}</span></code>可以是<strong>INTPOS</strong>，<strong>INTNEG</strong>，<strong> FLOAT</strong>，<strong>COMPLEX</strong>，<strong>BOOL</strong>或<strong>OBJECT</strong>。</span><span class="yiyi-st" id="yiyi-1184"><code class="xref c c-data docutils literal"><span class="pre">NPY_NOSCALAR</span></code>也是枚举值<a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND"><code class="xref c c-type docutils literal"><span class="pre">NPY_SCALARKIND</span></code></a>变量可以承担。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CanCoerceScalar"><span class="yiyi-st" id="yiyi-1185"> int <code class="descname">PyArray_CanCoerceScalar</code><span class="sig-paren">(</span>char<em> thistype</em>, char<em> neededtype</em>, <a class="reference internal" href="#c.NPY_SCALARKIND" title="NPY_SCALARKIND">NPY_SCALARKIND</a><em> scalar</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1186">有关NumPy类型升级的详细信息，请参阅函数<a class="reference internal" href="#c.PyArray_ResultType" title="PyArray_ResultType"><code class="xref c c-func docutils literal"><span class="pre">PyArray_ResultType</span></code></a>，在NumPy 1.6.0中更新。</span></p>
<p><span class="yiyi-st" id="yiyi-1187">实现标量强制的规则。</span><span class="yiyi-st" id="yiyi-1188">如果此函数返回非零，则标量只会从thistype静默强制转换为requiredtype。</span><span class="yiyi-st" id="yiyi-1189">如果标量为<code class="xref c c-data docutils literal"><span class="pre">NPY_NOSCALAR</span></code>，则此函数等效于<a class="reference internal" href="#c.PyArray_CanCastSafely" title="PyArray_CanCastSafely"><code class="xref c c-func docutils literal"><span class="pre">PyArray_CanCastSafely</span></code></a>。</span><span class="yiyi-st" id="yiyi-1190">规则是相同KIND的标量可以被强制转换为相同KIND的数组。</span><span class="yiyi-st" id="yiyi-1191">这个规则意味着高精度标量永远不会导致相同KIND的低精度数组被upcast。</span></p>
</dd></dl>
</div>
<div class="section" id="data-type-descriptors">
<h2><span class="yiyi-st" id="yiyi-1192">Data-type descriptors</span></h2>
<div class="admonition warning">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-1193">警告</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-1194">数据类型对象必须引用计数，以便了解对不同C-API调用的数据类型引用的操作。</span><span class="yiyi-st" id="yiyi-1195">标准规则是，当返回一个数据类型对象时，它是一个新的引用。</span><span class="yiyi-st" id="yiyi-1196">除非另有说明，采用<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span> <span class="pre">*</span></code></a>对象并返回数组类型的数组类型的函数。</span><span class="yiyi-st" id="yiyi-1197">因此，您必须拥有对用作此类函数的输入的任何数据类型对象的引用。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_DescrCheck"><span class="yiyi-st" id="yiyi-1198"> int <code class="descname">PyArray_DescrCheck</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1199">如果<em>obj</em>是数据类型对象（<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span> <span class="pre">*</span></code></a>），则计算为true。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrNew"><span class="yiyi-st" id="yiyi-1200"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrNew</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1201">返回从<em>obj</em>复制的新数据类型对象（字段引用刚刚更新，以便新对象指向同一字段字典，如果有）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrNewFromType"><span class="yiyi-st" id="yiyi-1202"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrNewFromType</code><span class="sig-paren">(</span>int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1203">从<em>typenum</em>指示的内置（或用户注册的）数据类型创建一个新的数据类型对象。</span><span class="yiyi-st" id="yiyi-1204">所有内置类型不应该更改任何字段。</span><span class="yiyi-st" id="yiyi-1205">这将创建<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span></code></a>结构的新副本，以便您可以根据需要填充它。</span><span class="yiyi-st" id="yiyi-1206">对于需要具有新elsize成员的灵活数据类型，为了在数组构造中有意义，该功能尤其需要。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrNewByteorder"><span class="yiyi-st" id="yiyi-1207"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrNewByteorder</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> obj</em>, char<em> newendian</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1208">创建一个新的数据类型对象，其字节顺序根据<em>newendian</em>设置。</span><span class="yiyi-st" id="yiyi-1209">所有引用的数据类型对象（在数据类型对象的subdescr和fields成员中）也被更改（递归）。</span><span class="yiyi-st" id="yiyi-1210">如果遇到<code class="xref c c-data docutils literal"><span class="pre">NPY_IGNORE</span></code>的字节顺序，它将被单独保留。</span><span class="yiyi-st" id="yiyi-1211">如果newendian为<code class="xref c c-data docutils literal"><span class="pre">NPY_SWAP</span></code>，则交换所有字节顺序。</span><span class="yiyi-st" id="yiyi-1212">其他有效的newendian值是<code class="xref c c-data docutils literal"><span class="pre">NPY_NATIVE</span></code>，<code class="xref c c-data docutils literal"><span class="pre">NPY_LITTLE</span></code>和<code class="xref c c-data docutils literal"><span class="pre">NPY_BIG</span></code>，它们都导致返回的数据类型描述符（及其所有引用的数据类型描述符）具有相应的字节顺序。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrFromObject"><span class="yiyi-st" id="yiyi-1213"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrFromObject</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> mintype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1214">从对象<em>op</em>（应为“嵌套”序列对象）和最小数据类型描述符mintype（可以为<code class="docutils literal"><span class="pre">NULL</span></code>）确定适当的数据类型对象。</span><span class="yiyi-st" id="yiyi-1215">类似于数组（<em>op</em>）。dtype。</span><span class="yiyi-st" id="yiyi-1216">不要将此函数与<a class="reference internal" href="#c.PyArray_DescrConverter" title="PyArray_DescrConverter"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrConverter</span></code></a>混淆。</span><span class="yiyi-st" id="yiyi-1217">此函数基本上查看（嵌套）序列中的所有对象，并根据找到的元素确定数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrFromScalar"><span class="yiyi-st" id="yiyi-1218"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrFromScalar</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> scalar</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1219">从数组标量对象返回数据类型对象。</span><span class="yiyi-st" id="yiyi-1220">不进行检查以确保<em>标量</em>是数组标量。</span><span class="yiyi-st" id="yiyi-1221">如果不能确定合适的数据类型，则默认返回<a class="reference internal" href="c-api.dtype.html#c.NPY_OBJECT" title="NPY_OBJECT"><code class="xref c c-data docutils literal"><span class="pre">NPY_OBJECT</span></code></a>的数据类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrFromType"><span class="yiyi-st" id="yiyi-1222"> <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>* <code class="descname">PyArray_DescrFromType</code><span class="sig-paren">(</span>int<em> typenum</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1223">返回与<em>typenum</em>对应的数据类型对象。</span><span class="yiyi-st" id="yiyi-1224"><em>typenum</em>可以是枚举类型之一，枚举类型之一的字符代码或用户定义类型。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrConverter"><span class="yiyi-st" id="yiyi-1225"> int <code class="descname">PyArray_DescrConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1226">将任何兼容的Python对象<em>obj</em>转换为<em>dtype</em>中的数据类型对象。</span><span class="yiyi-st" id="yiyi-1227">大量的Python对象可以转换为数据类型对象。</span><span class="yiyi-st" id="yiyi-1228">有关完整的说明，请参阅<a class="reference internal" href="arrays.dtypes.html#arrays-dtypes"><span class="std std-ref">Data type objects (dtype)</span></a>。</span><span class="yiyi-st" id="yiyi-1229">此版本的转换器将无对象转换为<a class="reference internal" href="c-api.dtype.html#c.NPY_DEFAULT_TYPE" title="NPY_DEFAULT_TYPE"><code class="xref c c-data docutils literal"><span class="pre">NPY_DEFAULT_TYPE</span></code></a>数据类型对象。</span><span class="yiyi-st" id="yiyi-1230">此函数可与<a class="reference external" href="https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple</span></code></a>处理中的“O＆”字符代码一起使用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_DescrConverter2"><span class="yiyi-st" id="yiyi-1231"> int <code class="descname">PyArray_DescrConverter2</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1232">将任何兼容的Python对象<em>obj</em>转换为<em>dtype</em>中的数据类型对象。</span><span class="yiyi-st" id="yiyi-1233">此版本的转换器转换无对象，以使返回的数据类型为<code class="docutils literal"><span class="pre">NULL</span></code>。</span><span class="yiyi-st" id="yiyi-1234">此函数也可以与PyArg_ParseTuple处理中的“O＆”字符一起使用。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.Pyarray_DescrAlignConverter"><span class="yiyi-st" id="yiyi-1235"> int <code class="descname">Pyarray_DescrAlignConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1236">像<a class="reference internal" href="#c.PyArray_DescrConverter" title="PyArray_DescrConverter"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrConverter</span></code></a>，除了它像编译器那样在字边界上对齐C语言结构对象。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.Pyarray_DescrAlignConverter2"><span class="yiyi-st" id="yiyi-1237"> int <code class="descname">Pyarray_DescrAlignConverter2</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1238">像<a class="reference internal" href="#c.PyArray_DescrConverter2" title="PyArray_DescrConverter2"><code class="xref c c-func docutils literal"><span class="pre">PyArray_DescrConverter2</span></code></a>除了它像字体边界上的C语言结构对象作为编译器。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_FieldNames"><span class="yiyi-st" id="yiyi-1239"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<code class="descname">PyArray_FieldNames</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> dict</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1240">取字段字典<em>dict</em>，例如附加到数据类型对象的字典字典，并构造字段名称的有序列表，例如存储在<a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Descr</span></code></a></span></p>
</dd></dl>
</div>
<div class="section" id="conversion-utilities">
<h2><span class="yiyi-st" id="yiyi-1241">Conversion Utilities</span></h2>
<div class="section" id="for-use-with-pyarg-parsetuple">
<h3><span class="yiyi-st" id="yiyi-1242">For use with <a class="reference external" href="https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple</span></code></a></span></h3>
<p><span class="yiyi-st" id="yiyi-1243">所有这些函数都可以在<a class="reference external" href="https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple</span></code></a>（...）中使用“O＆”格式说明符自动将任何Python对象转换为所需的C对象。</span><span class="yiyi-st" id="yiyi-1244">如果成功，所有这些函数返回<a class="reference internal" href="#c.NPY_SUCCEED" title="NPY_SUCCEED"><code class="xref c c-data docutils literal"><span class="pre">NPY_SUCCEED</span></code></a>，如果不成功，返回<a class="reference internal" href="#c.NPY_FAIL" title="NPY_FAIL"><code class="xref c c-data docutils literal"><span class="pre">NPY_FAIL</span></code></a>。</span><span class="yiyi-st" id="yiyi-1245">所有这些函数的第一个参数是一个Python对象。</span><span class="yiyi-st" id="yiyi-1246">第二个参数是要将Python对象转换为的C类型的<strong>地址</strong>。</span></p>
<div class="admonition warning">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-1247">警告</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-1248">一定要理解在使用这些转换函数时你应该采取什么步骤来管理内存。</span><span class="yiyi-st" id="yiyi-1249">这些功能可能需要释放内存，和/或根据您的使用更改特定对象的引用计数。</span></p>
</div>
<dl class="function">
<dt id="c.PyArray_Converter"><span class="yiyi-st" id="yiyi-1250"> int <code class="descname">PyArray_Converter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>**<em> address</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1251">将任何Python对象转换为<a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject"><code class="xref c c-type docutils literal"><span class="pre">PyArrayObject</span></code></a>。</span><span class="yiyi-st" id="yiyi-1252">如果<a class="reference internal" href="#c.PyArray_Check" title="PyArray_Check"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Check</span></code></a>（<em>obj</em>）为TRUE，则其引用计数增加，并且引用放置在<em>地址</em>中。</span><span class="yiyi-st" id="yiyi-1253">如果<em>obj</em>不是数组，则使用<a class="reference internal" href="#c.PyArray_FromAny" title="PyArray_FromAny"><code class="xref c c-func docutils literal"><span class="pre">PyArray_FromAny</span></code></a>将其转换为数组。</span><span class="yiyi-st" id="yiyi-1254">不管返回什么，当你完成后，你必须在<em>address</em>中DECREF这个例程返回的对象。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_OutputConverter"><span class="yiyi-st" id="yiyi-1255"> int <code class="descname">PyArray_OutputConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> address</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1256">这是一个给函数的输出数组的默认转换器。</span><span class="yiyi-st" id="yiyi-1257">如果<em>obj</em>为<a class="reference external" href="https://docs.python.org/dev/c-api/none.html#c.Py_None" title="(in Python v3.7)"><code class="xref c c-data docutils literal"><span class="pre">Py_None</span></code></a>或<code class="docutils literal"><span class="pre">NULL</span></code>，则<em>* address</em>将为<code class="docutils literal"><span class="pre">NULL</span></code>调用就会成功。</span><span class="yiyi-st" id="yiyi-1258">如果<a class="reference internal" href="#c.PyArray_Check" title="PyArray_Check"><code class="xref c c-func docutils literal"><span class="pre">PyArray_Check</span></code></a>（<em>obj</em>）为TRUE，则在<em>* address</em>中返回，而不增加其引用计数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IntpConverter"><span class="yiyi-st" id="yiyi-1259"> int <code class="descname">PyArray_IntpConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Dims" title="PyArray_Dims">PyArray_Dims</a>*<em> seq</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1260">将小于<a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code class="xref c c-data docutils literal"><span class="pre">NPY_MAXDIMS</span></code></a>的任何Python序列<em>obj</em>转换为<code class="xref c c-type docutils literal"><span class="pre">npy_intp</span></code>的C数组。</span><span class="yiyi-st" id="yiyi-1261">Python对象也可以是单个数字。</span><span class="yiyi-st" id="yiyi-1262"><em>seq</em>变量​​是指向具有成员ptr和len的结构的指针。</span><span class="yiyi-st" id="yiyi-1263">成功返回后，<em>seq</em>  - &gt; ptr包含指向必须释放的内存的指针，以避免内存泄漏。</span><span class="yiyi-st" id="yiyi-1264">对存储器大小的限制允许该转换器方便地用于旨在被解释为数组形状的序列。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_BufferConverter"><span class="yiyi-st" id="yiyi-1265"> int <code class="descname">PyArray_BufferConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Chunk" title="PyArray_Chunk">PyArray_Chunk</a>*<em> buf</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1266">使用（单段）缓冲区接口将任何Python对象<em>obj</em>转换为具有详细描述对象使用其内存块的成员的变量。</span><span class="yiyi-st" id="yiyi-1267"><em>buf</em>变量​​是指向具有base，ptr，len和flags成员的结构的指针。</span><span class="yiyi-st" id="yiyi-1268"><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Chunk" title="PyArray_Chunk"><code class="xref c c-type docutils literal"><span class="pre">PyArray_Chunk</span></code></a>结构与Python的缓冲区对象是二进制兼容的（通过32位平台上的len成员和64位平台上的ptr成员或Python 2.5）。</span><span class="yiyi-st" id="yiyi-1269">返回时，基本成员设置为<em>obj</em>（或者如果<em>obj</em>已经是指向另一个对象的缓冲对象，则其基本成员）。</span><span class="yiyi-st" id="yiyi-1270">如果你需要保持内存，一定要INCREF基本成员。</span><span class="yiyi-st" id="yiyi-1271">内存块由<em>buf</em>  - &gt; ptr member指向，并且长度为<em>buf</em>  - &gt; len。</span><span class="yiyi-st" id="yiyi-1272">如果<em>obj</em>具有可写缓冲区接口，则<em>buf</em>的标志成员为<code class="xref c c-data docutils literal"><span class="pre">NPY_BEHAVED_RO</span></code>，并设置<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>标志。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_AxisConverter"><span class="yiyi-st" id="yiyi-1273"> int <code class="descname">PyArray_AxisConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a> *<em> obj</em>, int*<em> axis</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1274">转换一个Python对象<em>obj</em>，将一个轴参数表示为适当的值，以传递给接受整数轴的函数。</span><span class="yiyi-st" id="yiyi-1275">具体来说，如果<em>obj</em>为无，则<em>轴</em>设置为<a class="reference internal" href="#c.NPY_MAXDIMS" title="NPY_MAXDIMS"><code class="xref c c-data docutils literal"><span class="pre">NPY_MAXDIMS</span></code></a>，它由采用轴参数的C-API函数正确解释。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_BoolConverter"><span class="yiyi-st" id="yiyi-1276"> int <code class="descname">PyArray_BoolConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, Bool*<em> value</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1277">将任何Python对象<em>obj</em>转换为<a class="reference internal" href="#c.NPY_TRUE" title="NPY_TRUE"><code class="xref c c-data docutils literal"><span class="pre">NPY_TRUE</span></code></a>或<a class="reference internal" href="#c.NPY_FALSE" title="NPY_FALSE"><code class="xref c c-data docutils literal"><span class="pre">NPY_FALSE</span></code></a>，并将结果放在<em>值</em>中。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ByteorderConverter"><span class="yiyi-st" id="yiyi-1278"> int <code class="descname">PyArray_ByteorderConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, char*<em> endian</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1279">将Python字符串转换为相应的字节顺序字符：&apos;&gt;&apos;，</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SortkindConverter"><span class="yiyi-st" id="yiyi-1280"> int <code class="descname">PyArray_SortkindConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="#c.NPY_SORTKIND" title="NPY_SORTKIND">NPY_SORTKIND</a>*<em> sort</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1281">将Python字符串转换为<code class="xref c c-data docutils literal"><span class="pre">NPY_QUICKSORT</span></code>（以“q”或“Q”开头），<code class="xref c c-data docutils literal"><span class="pre">NPY_HEAPSORT</span></code>（以“h”或“H”开头）或<code class="xref c c-data docutils literal"><span class="pre">NPY_MERGESORT</span></code>（以“m”或“M”开头）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SearchsideConverter"><span class="yiyi-st" id="yiyi-1282"> int <code class="descname">PyArray_SearchsideConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, NPY_SEARCHSIDE*<em> side</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1283">将Python字符串转换为<code class="xref c c-data docutils literal"><span class="pre">NPY_SEARCHLEFT</span></code>（以“l”或“L”开头）或<code class="xref c c-data docutils literal"><span class="pre">NPY_SEARCHRIGHT</span></code>（以“r”或“R”开头）之一。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_OrderConverter"><span class="yiyi-st" id="yiyi-1284"> int <code class="descname">PyArray_OrderConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a>*<em> order</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1285">Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the <a class="reference internal" href="#c.NPY_ORDER" title="NPY_ORDER"><code class="xref c c-type docutils literal"><span class="pre">NPY_ORDER</span></code></a> enumeration <a class="reference internal" href="#c.NPY_CORDER" title="NPY_CORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_CORDER</span></code></a>, <a class="reference internal" href="#c.NPY_FORTRANORDER" title="NPY_FORTRANORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_FORTRANORDER</span></code></a>, <a class="reference internal" href="#c.NPY_ANYORDER" title="NPY_ANYORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_ANYORDER</span></code></a>, and <a class="reference internal" href="#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal"><span class="pre">NPY_KEEPORDER</span></code></a>.</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CastingConverter"><span class="yiyi-st" id="yiyi-1286"> int <code class="descname">PyArray_CastingConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a>*<em> casting</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1287">Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’ into the <a class="reference internal" href="#c.NPY_CASTING" title="NPY_CASTING"><code class="xref c c-type docutils literal"><span class="pre">NPY_CASTING</span></code></a> enumeration <a class="reference internal" href="#c.NPY_NO_CASTING" title="NPY_NO_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_NO_CASTING</span></code></a>, <a class="reference internal" href="#c.NPY_EQUIV_CASTING" title="NPY_EQUIV_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_EQUIV_CASTING</span></code></a>, <a class="reference internal" href="#c.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_SAFE_CASTING</span></code></a>, <a class="reference internal" href="#c.NPY_SAME_KIND_CASTING" title="NPY_SAME_KIND_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_SAME_KIND_CASTING</span></code></a>, and <a class="reference internal" href="#c.NPY_UNSAFE_CASTING" title="NPY_UNSAFE_CASTING"><code class="xref c c-data docutils literal"><span class="pre">NPY_UNSAFE_CASTING</span></code></a>.</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ClipmodeConverter"><span class="yiyi-st" id="yiyi-1288"> int <code class="descname">PyArray_ClipmodeConverter</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> object</em>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE">NPY_CLIPMODE</a>*<em> val</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1289">将Python字符串的“clip”，“wrap”和“raise”转换为<a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><code class="xref c c-type docutils literal"><span class="pre">NPY_CLIPMODE</span></code></a>枚举<a class="reference internal" href="#c.NPY_CLIP" title="NPY_CLIP"><code class="xref c c-data docutils literal"><span class="pre">NPY_CLIP</span></code></a>，<a class="reference internal" href="#c.NPY_WRAP" title="NPY_WRAP"><code class="xref c c-data docutils literal"><span class="pre">NPY_WRAP</span></code></a>和<a class="reference internal" href="#c.NPY_RAISE" title="NPY_RAISE"><code class="xref c c-data docutils literal"><span class="pre">NPY_RAISE</span></code></a>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_ConvertClipmodeSequence"><span class="yiyi-st" id="yiyi-1290"> int <code class="descname">PyArray_ConvertClipmodeSequence</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> object</em>, <a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE">NPY_CLIPMODE</a>*<em> modes</em>, int<em> n</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1291">将剪辑模式序列或单个剪辑模式转换为<a class="reference internal" href="#c.NPY_CLIPMODE" title="NPY_CLIPMODE"><code class="xref c c-type docutils literal"><span class="pre">NPY_CLIPMODE</span></code></a>值的C数组。</span><span class="yiyi-st" id="yiyi-1292">在调用此函数之前，必须知道剪辑模式的数量<em>n</em>。</span><span class="yiyi-st" id="yiyi-1293">提供此函数以帮助功能允许每个维度使用不同的剪辑模式。</span></p>
</dd></dl>
</div>
<div class="section" id="other-conversions">
<h3><span class="yiyi-st" id="yiyi-1294">Other conversions</span></h3>
<dl class="function">
<dt id="c.PyArray_PyIntAsInt"><span class="yiyi-st" id="yiyi-1295"> int <code class="descname">PyArray_PyIntAsInt</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1296">将各种类型的Python对象（包括数组和数组标量）转换为标准整数。</span><span class="yiyi-st" id="yiyi-1297">出错时，返回-1并设置异常。</span><span class="yiyi-st" id="yiyi-1298">你可能会发现有用的宏：</span></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define error_converting(x) (((x) == -1) &amp;&amp; PyErr_Occurred()</span>
</pre></div>
</div>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_PyIntAsIntp"><span class="yiyi-st" id="yiyi-1299"> npy_intp <code class="descname">PyArray_PyIntAsIntp</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1300">将各种Python对象（包括数组和数组标量）转换为（平台指针大小）整数。</span><span class="yiyi-st" id="yiyi-1301">出错时，返回-1并设置异常。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_IntpFromSequence"><span class="yiyi-st" id="yiyi-1302"> int <code class="descname">PyArray_IntpFromSequence</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> seq</em>, npy_intp*<em> vals</em>, int<em> maxvals</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1303">将以<em>seq</em>传递的任何Python序列（或单个Python号）转换为（最多）<em>maxvals</em>个指针大小的整数，并将它们放在<em>vals  t2 &gt;数组。</em></span><span class="yiyi-st" id="yiyi-1304">当返回转换对象的数量时，该序列可以小于<em>maxvals</em>。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_TypestrConvert"><span class="yiyi-st" id="yiyi-1305"> int <code class="descname">PyArray_TypestrConvert</code><span class="sig-paren">(</span>int<em> itemsize</em>, int<em> gentype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1306">将打字字符（<em>itemize</em>）转换为基本枚举数据类型。</span><span class="yiyi-st" id="yiyi-1307">对应于有符号和无符号整数，浮点数和复数浮点数的typestring字符被识别和转换。</span><span class="yiyi-st" id="yiyi-1308">返回gentype的其他值。</span><span class="yiyi-st" id="yiyi-1309">此函数可用于将字符串&apos;f4&apos;转换为<a class="reference internal" href="c-api.dtype.html#c.NPY_FLOAT32" title="NPY_FLOAT32"><code class="xref c c-data docutils literal"><span class="pre">NPY_FLOAT32</span></code></a>。</span></p>
</dd></dl>
</div>
</div>
<div class="section" id="miscellaneous">
<h2><span class="yiyi-st" id="yiyi-1310">Miscellaneous</span></h2>
<div class="section" id="importing-the-api">
<h3><span class="yiyi-st" id="yiyi-1311">Importing the API</span></h3>
<p><span class="yiyi-st" id="yiyi-1312">为了使用来自另一个扩展模块的C-API，必须使用<code class="docutils literal"><span class="pre">import_array</span></code>()命令。</span><span class="yiyi-st" id="yiyi-1313">如果扩展模块是自包含在一个单一的.c文件，那就是所有需要做的。</span><span class="yiyi-st" id="yiyi-1314">然而，如果扩展模块涉及需要C-API的多个文件，则必须采取一些额外的步骤。</span></p>
<dl class="function">
<dt id="c.import_array"><span class="yiyi-st" id="yiyi-1315"> void <code class="descname">import_array</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1316">此函数必须在将使用C-API的模块的初始化部分中调用。</span><span class="yiyi-st" id="yiyi-1317">它导入存储函数指针表的模块，并将正确的变量指向它。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.PY_ARRAY_UNIQUE_SYMBOL"><span class="yiyi-st" id="yiyi-1318"> <code class="descname">PY_ARRAY_UNIQUE_SYMBOL</code></span></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.NO_IMPORT_ARRAY"><span class="yiyi-st" id="yiyi-1319"> <code class="descname">NO_IMPORT_ARRAY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1320">使用这些#defines你可以在单个扩展模块的多个文件中使用C-API。</span><span class="yiyi-st" id="yiyi-1321">在每个文件中，您必须将<a class="reference internal" href="#c.PY_ARRAY_UNIQUE_SYMBOL" title="PY_ARRAY_UNIQUE_SYMBOL"><code class="xref c c-macro docutils literal"><span class="pre">PY_ARRAY_UNIQUE_SYMBOL</span></code></a>定义为将保存C-API的某个名称（<em>，例如</em> myextension_ARRAY_API）。</span><span class="yiyi-st" id="yiyi-1322">这必须在之前完成<strong>，包括numpy / arrayobject.h文件。</strong></span><span class="yiyi-st" id="yiyi-1323">在模块初始化例程中，调用<code class="docutils literal"><span class="pre">import_array</span></code>()。</span><span class="yiyi-st" id="yiyi-1324">此外，在没有模块初始化的文件中，sub_routine在包含numpy / arrayobject.h之前定义<a class="reference internal" href="#c.NO_IMPORT_ARRAY" title="NO_IMPORT_ARRAY"><code class="xref c c-macro docutils literal"><span class="pre">NO_IMPORT_ARRAY</span></code></a>。</span></p>
<p><span class="yiyi-st" id="yiyi-1325">假设我有两个文件coolmodule.c和coolhelper.c，需要编译和链接到一个单一的扩展模块。</span><span class="yiyi-st" id="yiyi-1326">假设coolmodule.c包含所需的initcool模块初始化函数（调用import_array()函数）。</span><span class="yiyi-st" id="yiyi-1327">然后，coolmodule.c将在顶部：</span></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API</span>
<span class="cp">#include</span> <span class="cpf">numpy/arrayobject.h</span><span class="cp"></span>
</pre></div>
</div>
<p><span class="yiyi-st" id="yiyi-1328">另一方面，coolhelper.c将包含在顶部：</span></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define NO_IMPORT_ARRAY</span>
<span class="cp">#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API</span>
<span class="cp">#include</span> <span class="cpf">numpy/arrayobject.h</span><span class="cp"></span>
</pre></div>
</div>
<p><span class="yiyi-st" id="yiyi-1329">你也可以把普通的最后两行放入一个扩展本地头文件，只要你确保NO_IMPORT_ARRAY #define之前#include该文件。</span></p>
</dd></dl>
</div>
<div class="section" id="checking-the-api-version">
<h3><span class="yiyi-st" id="yiyi-1330">Checking the API Version</span></h3>
<p><span class="yiyi-st" id="yiyi-1331">因为在大多数平台上，python扩展不像通常的库一样使用，所以在构建时或运行时不能自动检测到某些错误。</span><span class="yiyi-st" id="yiyi-1332">例如，如果你使用只对numpy&gt; = 1.3.0可用的函数构建一个扩展，并且以后用numpy 1.2导入扩展，你将不会得到一个导入错误（但是在调用该函数时几乎肯定会出现分段错误） 。</span><span class="yiyi-st" id="yiyi-1333">这就是为什么提供几个函数来检查numpy版本。</span><span class="yiyi-st" id="yiyi-1334">宏<a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code class="xref c c-data docutils literal"><span class="pre">NPY_VERSION</span></code></a>和<code class="xref c c-data docutils literal"><span class="pre">NPY_FEATURE_VERSION</span></code>对应于用于构建扩展的numpy版本，而函数PyArray_GetNDArrayCVersion和PyArray_GetNDArrayCFeatureVersion返回的版本对应于运行时numpy的版本。</span></p>
<p><span class="yiyi-st" id="yiyi-1335">ABI和API兼容性的规则可以总结如下：</span></p>
<blockquote>
<div><ul class="simple">
<li><span class="yiyi-st" id="yiyi-1336">每当<a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code class="xref c c-data docutils literal"><span class="pre">NPY_VERSION</span></code></a>！= PyArray_GetNDArrayCVersion时，扩展必须重新编译（ABI不兼容）。</span></li>
<li><span class="yiyi-st" id="yiyi-1337"><a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code class="xref c c-data docutils literal"><span class="pre">NPY_VERSION</span></code></a> == PyArray_GetNDArrayCVersion和<code class="xref c c-data docutils literal"><span class="pre">NPY_FEATURE_VERSION</span></code></span></li>
</ul>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-1338">在每个numpy的版本中自动检测ABI不兼容性。</span><span class="yiyi-st" id="yiyi-1339">在numpy 1.4.0中添加了API不兼容性检测。</span><span class="yiyi-st" id="yiyi-1340">如果你想支持许多不同的numpy版本与一个扩展二进制，你必须建立你的扩展与最低的NPY_FEATURE_VERSION尽可能。</span></p>
<dl class="function">
<dt id="c.PyArray_GetNDArrayCVersion"><span class="yiyi-st" id="yiyi-1341"> unsigned int <code class="descname">PyArray_GetNDArrayCVersion</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1342">这只是返回值<a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code class="xref c c-data docutils literal"><span class="pre">NPY_VERSION</span></code></a>。</span><span class="yiyi-st" id="yiyi-1343">每当ABI级别发生向后不兼容更改时，<a class="reference internal" href="#c.NPY_VERSION" title="NPY_VERSION"><code class="xref c c-data docutils literal"><span class="pre">NPY_VERSION</span></code></a>会更改。</span><span class="yiyi-st" id="yiyi-1344">因为它在C-API中，然而，从当前标题中定义的值比较该函数的输出提供了一种方式来测试C-API是否已经改变，因此需要重新编译使用C-API的扩展模块-API。</span><span class="yiyi-st" id="yiyi-1345">这将在函数import_array中自动检查。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GetNDArrayCFeatureVersion"><span class="yiyi-st" id="yiyi-1346"> unsigned int <code class="descname">PyArray_GetNDArrayCFeatureVersion</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-1347"><span class="versionmodified">版本1.4.0中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-1348">这只是返回值<code class="xref c c-data docutils literal"><span class="pre">NPY_FEATURE_VERSION</span></code>。</span><span class="yiyi-st" id="yiyi-1349">每当API更改（例如添加一个函数）时，<code class="xref c c-data docutils literal"><span class="pre">NPY_FEATURE_VERSION</span></code>都会更改。</span><span class="yiyi-st" id="yiyi-1350">更改的值并不总是需要重新编译。</span></p>
</dd></dl>
</div>
<div class="section" id="internal-flexibility">
<h3><span class="yiyi-st" id="yiyi-1351">Internal Flexibility</span></h3>
<dl class="function">
<dt id="c.PyArray_SetNumericOps"><span class="yiyi-st" id="yiyi-1352"> int <code class="descname">PyArray_SetNumericOps</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> dict</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1353">NumPy存储Python可调用对象的内部表，用于实现数组的算术运算以及某些数组计算方法。</span><span class="yiyi-st" id="yiyi-1354">此函数允许用户使用自己的版本替换任何或所有这些Python对象。</span><span class="yiyi-st" id="yiyi-1355">字典的键（<em>dict</em>）是要替换的命名函数，配对值是要使用的Python可调用对象。</span><span class="yiyi-st" id="yiyi-1356">应注意，用于替换内部数组操作的函数本身不会回调到该内部数组操作（除非您已经设计了处理该操作的函数），否则可能导致未检查的无限递归（可能导致程序崩溃）。</span><span class="yiyi-st" id="yiyi-1357">表示可以替换的操作的键名称是：</span></p>
<blockquote>
<div><span class="yiyi-st" id="yiyi-1358"><strong>add</strong>, <strong>subtract</strong>, <strong>multiply</strong>, <strong>divide</strong>, <strong>remainder</strong>, <strong>power</strong>, <strong>square</strong>, <strong>reciprocal</strong>, <strong>ones_like</strong>, <strong>sqrt</strong>, <strong>negative</strong>, <strong>absolute</strong>, <strong>invert</strong>, <strong>left_shift</strong>, <strong>right_shift</strong>, <strong>bitwise_and</strong>, <strong>bitwise_xor</strong>, <strong>bitwise_or</strong>, <strong>less</strong>, <strong>less_equal</strong>, <strong>equal</strong>, <strong>not_equal</strong>, <strong>greater</strong>, <strong>greater_equal</strong>, <strong>floor_divide</strong>, <strong>true_divide</strong>, <strong>logical_or</strong>, <strong>logical_and</strong>, <strong>floor</strong>, <strong>ceil</strong>, <strong>maximum</strong>, <strong>minimum</strong>, <strong>rint</strong>.</span></div></blockquote>
<p><span class="yiyi-st" id="yiyi-1359">这些函数包含在这里，因为它们在数组对象的方法中至少使用一次。</span><span class="yiyi-st" id="yiyi-1360">如果被分配的对象之一不可调用，函数返回-1（不设置Python错误）。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GetNumericOps"><span class="yiyi-st" id="yiyi-1361"> <a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>* <code class="descname">PyArray_GetNumericOps</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1362">返回一个包含存储在内部算术运算表中的可调用Python对象的Python字典。</span><span class="yiyi-st" id="yiyi-1363">此字典的键在<a class="reference internal" href="#c.PyArray_SetNumericOps" title="PyArray_SetNumericOps"><code class="xref c c-func docutils literal"><span class="pre">PyArray_SetNumericOps</span></code></a>的说明中给出。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_SetStringFunction"><span class="yiyi-st" id="yiyi-1364"> void <code class="descname">PyArray_SetStringFunction</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em>, int<em> repr</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1365">此函数允许您将数组对象的tp_str和tp_repr方法更改为任何Python函数。</span><span class="yiyi-st" id="yiyi-1366">因此，当str（arr）或repr（arr）从Python调用时，你可以改变对所有数组的发生。</span><span class="yiyi-st" id="yiyi-1367">要调用的函数以<em>op</em>传入。</span><span class="yiyi-st" id="yiyi-1368">如果<em>repr</em>不为零，则将响应repr（arr）调用此函数，否则将响应str（arr）调用函数。</span><span class="yiyi-st" id="yiyi-1369">不执行是否可调用<em>op</em>的检查。</span><span class="yiyi-st" id="yiyi-1370">传递给<em>op</em>的可调用应该有一个数组参数，并应返回要打印的字符串。</span></p>
</dd></dl>
</div>
<div class="section" id="memory-management">
<h3><span class="yiyi-st" id="yiyi-1371">Memory management</span></h3>
<dl class="function">
<dt id="c.PyDataMem_NEW"><span class="yiyi-st" id="yiyi-1372"> char* <code class="descname">PyDataMem_NEW</code><span class="sig-paren">(</span>size_t<em> nbytes</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataMem_FREE"><span class="yiyi-st" id="yiyi-1373"> <code class="descname">PyDataMem_FREE</code><span class="sig-paren">(</span>char*<em> ptr</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDataMem_RENEW"><span class="yiyi-st" id="yiyi-1374"> char* <code class="descname">PyDataMem_RENEW</code><span class="sig-paren">(</span>void *<em> ptr</em>, size_t<em> newbytes</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1375">宏分配，释放和重新分配内存。</span><span class="yiyi-st" id="yiyi-1376">这些宏在内部用于创建数组。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyDimMem_NEW"><span class="yiyi-st" id="yiyi-1377"> npy_intp* <code class="descname">PyDimMem_NEW</code><span class="sig-paren">(</span>nd<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDimMem_FREE"><span class="yiyi-st" id="yiyi-1378"> <code class="descname">PyDimMem_FREE</code><span class="sig-paren">(</span>npy_intp*<em> ptr</em><span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyDimMem_RENEW"><span class="yiyi-st" id="yiyi-1379"> npy_intp* <code class="descname">PyDimMem_RENEW</code><span class="sig-paren">(</span>npy_intp*<em> ptr</em>, npy_intp<em> newnd</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1380">宏分配，释放和重新分配维度和跨越内存。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_malloc"><span class="yiyi-st" id="yiyi-1381"> <code class="descname">PyArray_malloc</code><span class="sig-paren">(</span>nbytes<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_free"><span class="yiyi-st" id="yiyi-1382"> <code class="descname">PyArray_free</code><span class="sig-paren">(</span>ptr<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_realloc"><span class="yiyi-st" id="yiyi-1383"> <code class="descname">PyArray_realloc</code><span class="sig-paren">(</span>ptr, nbytes<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1384">这些宏使用不同的内存分配器，具体取决于常量<code class="xref c c-data docutils literal"><span class="pre">NPY_USE_PYMEM</span></code>。</span><span class="yiyi-st" id="yiyi-1385">当<code class="xref c c-data docutils literal"><span class="pre">NPY_USE_PYMEM</span></code>为0时，如果<code class="xref c c-data docutils literal"><span class="pre">NPY_USE_PYMEM</span></code>为1，则使用系统malloc，然后使用Python内存分配器。</span></p>
</dd></dl>
</div>
<div class="section" id="threading-support">
<h3><span class="yiyi-st" id="yiyi-1386">Threading support</span></h3>
<p><span class="yiyi-st" id="yiyi-1387">这些宏仅在<code class="xref c c-data docutils literal"><span class="pre">NPY_ALLOW_THREADS</span></code>在编译扩展模块期间求值为True时才有意义。</span><span class="yiyi-st" id="yiyi-1388">否则，这些宏等同于空格。</span><span class="yiyi-st" id="yiyi-1389">Python为每个Python进程使用单个全局解释器锁（GIL），因此一次只能执行一个线程（即使在多CPU系统上）。</span><span class="yiyi-st" id="yiyi-1390">当调用可能需要时间来计算（并且对于其他线程，如更新​​的全局变量）没有副作用的编译函数时，GIL应该被释放，以便其他Python线程可以运行，同时执行耗时的计算。</span><span class="yiyi-st" id="yiyi-1391">这可以使用两组宏来实现。</span><span class="yiyi-st" id="yiyi-1392">通常，如果在代码块中使用组中的一个宏，则所有这些宏必须在相同的代码块中使用。</span><span class="yiyi-st" id="yiyi-1393">Currently, <code class="xref c c-data docutils literal"><span class="pre">NPY_ALLOW_THREADS</span></code> is defined to the python-defined <code class="xref c c-data docutils literal"><span class="pre">WITH_THREADS</span></code> constant unless the environment variable <code class="xref c c-data docutils literal"><span class="pre">NPY_NOSMP</span></code> is set in which case <code class="xref c c-data docutils literal"><span class="pre">NPY_ALLOW_THREADS</span></code> is defined to be 0.</span></p>
<div class="section" id="group-1">
<h4><span class="yiyi-st" id="yiyi-1394">Group 1</span></h4>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-1395">此组用于调用可能需要一些时间但不使用任何Python C-API调用的代码。</span><span class="yiyi-st" id="yiyi-1396">因此，GIL应在其计算期间释放。</span></p>
<dl class="macro">
<dt id="c.NPY_BEGIN_ALLOW_THREADS"><span class="yiyi-st" id="yiyi-1397"> <code class="descname">NPY_BEGIN_ALLOW_THREADS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1398">等效于<a class="reference external" href="https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS" title="(in Python v3.7)"><code class="xref c c-macro docutils literal"><span class="pre">Py_BEGIN_ALLOW_THREADS</span></code></a>，除非它使用<code class="xref c c-data docutils literal"><span class="pre">NPY_ALLOW_THREADS</span></code>来确定宏是否被替换为空格。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_END_ALLOW_THREADS"><span class="yiyi-st" id="yiyi-1399"> <code class="descname">NPY_END_ALLOW_THREADS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1400">等同于<a class="reference external" href="https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS" title="(in Python v3.7)"><code class="xref c c-macro docutils literal"><span class="pre">Py_END_ALLOW_THREADS</span></code></a>，除非它使用<code class="xref c c-data docutils literal"><span class="pre">NPY_ALLOW_THREADS</span></code>来确定宏是否被替换为空格。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_BEGIN_THREADS_DEF"><span class="yiyi-st" id="yiyi-1401"> <code class="descname">NPY_BEGIN_THREADS_DEF</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1402">放在变量声明区。</span><span class="yiyi-st" id="yiyi-1403">这个宏设置存储Python状态所需的变量。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_BEGIN_THREADS"><span class="yiyi-st" id="yiyi-1404"> <code class="descname">NPY_BEGIN_THREADS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1405">放在不需要Python解释器的代码之前（没有Python C-API调用）。</span><span class="yiyi-st" id="yiyi-1406">此宏保存Python状态并释放GIL。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_END_THREADS"><span class="yiyi-st" id="yiyi-1407"> <code class="descname">NPY_END_THREADS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1408">放置在不需要Python解释器的代码后面。</span><span class="yiyi-st" id="yiyi-1409">此宏获取GIL并从保存的变量恢复Python状态。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.NPY_BEGIN_THREADS_DESCR"><span class="yiyi-st" id="yiyi-1410"> <code class="descname">NPY_BEGIN_THREADS_DESCR</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a><em> *dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1411">只有在<em>dtype</em>不包含任何可能需要Python解释器的Python对象时，才有助于释放GIL。</span><span class="yiyi-st" id="yiyi-1412">相当于</span></p>
</dd></dl>
<dl class="function">
<dt id="c.NPY_END_THREADS_DESCR"><span class="yiyi-st" id="yiyi-1413"> <code class="descname">NPY_END_THREADS_DESCR</code><span class="sig-paren">(</span><a class="reference internal" href="c-api.types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a><em> *dtype</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1414">用于在使用此宏的BEGIN形式释放GIL的情况下重新获得GIL。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.NPY_BEGIN_THREADS_THRESHOLDED"><span class="yiyi-st" id="yiyi-1415"> <code class="descname">NPY_BEGIN_THREADS_THRESHOLDED</code><span class="sig-paren">(</span>int<em> loop_size</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1416">仅在<em>loop_size</em>超过最小阈值（当前设置为500）时用于释放GIL。</span><span class="yiyi-st" id="yiyi-1417">应该与.. c：macro :: <em class="xref py py-obj">NPY_END_THREADS</em>匹配，以重新获得GIL。</span></p>
</dd></dl>
</div></blockquote>
</div>
<div class="section" id="group-2">
<h4><span class="yiyi-st" id="yiyi-1418">Group 2</span></h4>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-1419">这个组用于在Python GIL发布后重新获取它。</span><span class="yiyi-st" id="yiyi-1420">例如，假设GIL已经释放（使用以前的调用），然后代码中的某个路径（可能在不同的子例程中）需要使用Python C-API，那么这些宏可用于获取GIL。</span><span class="yiyi-st" id="yiyi-1421">这些宏基本上完成了前面三个（获取LOCK保存它的状态）的反向，然后重新释放它与保存的状态。</span></p>
<dl class="macro">
<dt id="c.NPY_ALLOW_C_API_DEF"><span class="yiyi-st" id="yiyi-1422"> <code class="descname">NPY_ALLOW_C_API_DEF</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1423">在变量声明区域中设置必要的变量。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_ALLOW_C_API"><span class="yiyi-st" id="yiyi-1424"> <code class="descname">NPY_ALLOW_C_API</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1425">放在需要调用Python C-API的代码之前（当知道GIL已经被释放时）。</span></p>
</dd></dl>
<dl class="macro">
<dt id="c.NPY_DISABLE_C_API"><span class="yiyi-st" id="yiyi-1426"> <code class="descname">NPY_DISABLE_C_API</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1427">放在需要调用Python C-API的代码之后（重新释放GIL）。</span></p>
</dd></dl>
</div></blockquote>
<div class="admonition tip">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-1428">小费</span></p>
<p class="last"><span class="yiyi-st" id="yiyi-1429">在线程支持宏后不要使用分号。</span></p>
</div>
</div>
</div>
<div class="section" id="priority">
<h3><span class="yiyi-st" id="yiyi-1430">Priority</span></h3>
<dl class="var">
<dt id="c.NPY_PRIORITY"><span class="yiyi-st" id="yiyi-1431"> <code class="descname">NPY_PRIORITY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1432">数组的默认优先级。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_SUBTYPE_PRIORITY"><span class="yiyi-st" id="yiyi-1433"> <code class="descname">NPY_SUBTYPE_PRIORITY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1434">默认子类型优先级。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_SCALAR_PRIORITY"><span class="yiyi-st" id="yiyi-1435"> <code class="descname">NPY_SCALAR_PRIORITY</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1436">默认标量优先级（非常小）</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_GetPriority"><span class="yiyi-st" id="yiyi-1437"> double <code class="descname">PyArray_GetPriority</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> obj</em>, double<em> def</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1438">如果该名称的属性不存在，则返回<em>obj</em>或<em>def</em>的<code class="xref py py-obj docutils literal"><span class="pre">__array_priority__</span></code>属性（转换为double）。</span><span class="yiyi-st" id="yiyi-1439">避免属性查找的快速返回是为<code class="xref c c-data docutils literal"><span class="pre">PyArray_Type</span></code>类型的对象提供的。</span></p>
</dd></dl>
</div>
<div class="section" id="default-buffers">
<h3><span class="yiyi-st" id="yiyi-1440">Default buffers</span></h3>
<dl class="var">
<dt id="c.NPY_BUFSIZE"><span class="yiyi-st" id="yiyi-1441"> <code class="descname">NPY_BUFSIZE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1442">用户可设置的内部缓冲区的默认大小。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_MIN_BUFSIZE"><span class="yiyi-st" id="yiyi-1443"> <code class="descname">NPY_MIN_BUFSIZE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1444">最小尺寸的用户可设置内部缓冲区。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_MAX_BUFSIZE"><span class="yiyi-st" id="yiyi-1445"> <code class="descname">NPY_MAX_BUFSIZE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1446">用户可设置缓冲区允许的最大大小。</span></p>
</dd></dl>
</div>
<div class="section" id="other-constants">
<h3><span class="yiyi-st" id="yiyi-1447">Other constants</span></h3>
<dl class="var">
<dt id="c.NPY_NUM_FLOATTYPE"><span class="yiyi-st" id="yiyi-1448"> <code class="descname">NPY_NUM_FLOATTYPE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1449">浮点类型的数量</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_MAXDIMS"><span class="yiyi-st" id="yiyi-1450"> <code class="descname">NPY_MAXDIMS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1451">数组中允许的最大维数。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_VERSION"><span class="yiyi-st" id="yiyi-1452"> <code class="descname">NPY_VERSION</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1453">ndarray对象的当前版本（检查这个变量是否被定义以保证numpy / arrayobject.h头被使用）。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_FALSE"><span class="yiyi-st" id="yiyi-1454"> <code class="descname">NPY_FALSE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1455">定义为0，与Bool一起使用。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_TRUE"><span class="yiyi-st" id="yiyi-1456"> <code class="descname">NPY_TRUE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1457">定义为1与Bool一起使用。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_FAIL"><span class="yiyi-st" id="yiyi-1458"> <code class="descname">NPY_FAIL</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1459">使用<a class="reference external" href="https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple</span></code></a>类函数中的“O＆”语法调用的失败转换器函数的返回值。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_SUCCEED"><span class="yiyi-st" id="yiyi-1460"> <code class="descname">NPY_SUCCEED</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1461">使用<a class="reference external" href="https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple" title="(in Python v3.7)"><code class="xref c c-func docutils literal"><span class="pre">PyArg_ParseTuple</span></code></a>类函数中的“O＆”语法调用的成功转换器函数的返回值。</span></p>
</dd></dl>
</div>
<div class="section" id="miscellaneous-macros">
<h3><span class="yiyi-st" id="yiyi-1462">Miscellaneous Macros</span></h3>
<dl class="function">
<dt id="c.PyArray_SAMESHAPE"><span class="yiyi-st" id="yiyi-1463"> <code class="descname">PyArray_SAMESHAPE</code><span class="sig-paren">(</span>a1, a2<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1464">如果数组<em>a1</em>和<em>a2</em>具有相同的形状，则计算为True。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MAX"><span class="yiyi-st" id="yiyi-1465"> <code class="descname">PyArray_MAX</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1466">返回<em>a</em>和<em>b</em>的最大值。</span><span class="yiyi-st" id="yiyi-1467">如果（<em>a</em>）或（<em>b</em>）是表达式，它们将被求值两次。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_MIN"><span class="yiyi-st" id="yiyi-1468"> <code class="descname">PyArray_MIN</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1469">返回<em>a</em>和<em>b</em>的最小值。</span><span class="yiyi-st" id="yiyi-1470">如果（<em>a</em>）或（<em>b</em>）是表达式，它们将被求值两次。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_CLT"><span class="yiyi-st" id="yiyi-1471"> <code class="descname">PyArray_CLT</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_CGT"><span class="yiyi-st" id="yiyi-1472"> <code class="descname">PyArray_CGT</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_CLE"><span class="yiyi-st" id="yiyi-1473"> <code class="descname">PyArray_CLE</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_CGE"><span class="yiyi-st" id="yiyi-1474"> <code class="descname">PyArray_CGE</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_CEQ"><span class="yiyi-st" id="yiyi-1475"> <code class="descname">PyArray_CEQ</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd></dd></dl>
<dl class="function">
<dt id="c.PyArray_CNE"><span class="yiyi-st" id="yiyi-1476"> <code class="descname">PyArray_CNE</code><span class="sig-paren">(</span>a, b<span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1477">使用NumPy对词典顺序的定义，实现两个复数（具有实数和imag成员的结构）之间的复杂比较：首先比较实部，然后如果实部相等，则比较复数部分。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_REFCOUNT"><span class="yiyi-st" id="yiyi-1478"> <code class="descname">PyArray_REFCOUNT</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a>*<em> op</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1479">返回任何Python对象的引用计数。</span></p>
</dd></dl>
<dl class="function">
<dt id="c.PyArray_XDECREF_ERR"><span class="yiyi-st" id="yiyi-1480"> <code class="descname">PyArray_XDECREF_ERR</code><span class="sig-paren">(</span><a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.7)">PyObject</a><em> *obj</em><span class="sig-paren">)</span></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1481">DECREF的数组对象可以设置<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>标志，而不会将内容复制回原始数组。</span><span class="yiyi-st" id="yiyi-1482">重置基础对象上的<a class="reference internal" href="#c.NPY_ARRAY_WRITEABLE" title="NPY_ARRAY_WRITEABLE"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_WRITEABLE</span></code></a>标志。</span><span class="yiyi-st" id="yiyi-1483">当使用<a class="reference internal" href="#c.NPY_ARRAY_UPDATEIFCOPY" title="NPY_ARRAY_UPDATEIFCOPY"><code class="xref c c-data docutils literal"><span class="pre">NPY_ARRAY_UPDATEIFCOPY</span></code></a>时，这对于从错误状态恢复非常有用。</span></p>
</dd></dl>
</div>
<div class="section" id="enumerated-types">
<h3><span class="yiyi-st" id="yiyi-1484">Enumerated Types</span></h3>
<dl class="type">
<dt id="c.NPY_SORTKIND"><span class="yiyi-st" id="yiyi-1485"> <code class="descname">NPY_SORTKIND</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1486">可以取值<code class="xref c c-data docutils literal"><span class="pre">NPY_{KIND}</span></code>的特殊变量类型，其中<code class="docutils literal"><span class="pre">{KIND}</span></code>是</span></p>
<blockquote>
<div><span class="yiyi-st" id="yiyi-1487"><strong>QUICKSORT</strong>，<strong>HEAPSORT</strong>，<strong>MERGESORT</strong></span></div></blockquote>
<dl class="var">
<dt id="c.NPY_NSORTS"><span class="yiyi-st" id="yiyi-1488"> <code class="descname">NPY_NSORTS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1489">定义为排序的数量。</span></p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="c.NPY_SCALARKIND"><span class="yiyi-st" id="yiyi-1490"> <code class="descname">NPY_SCALARKIND</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1491">指示在确定标量强制规则中区分的标量的“种类”的数量的特殊变量类型。</span><span class="yiyi-st" id="yiyi-1492">此变量可以取值<code class="xref c c-data docutils literal"><span class="pre">NPY_{KIND}</span></code>，其中<code class="docutils literal"><span class="pre">{KIND}</span></code>可以是</span></p>
<blockquote>
<div><span class="yiyi-st" id="yiyi-1493"><strong>NOSCALAR</strong>，<strong>BOOL_SCALAR</strong>，<strong>INTPOS_SCALAR</strong>，<strong>INTNEG_SCALAR</strong>，<strong>FLOAT_SCALAR</strong>，<strong>COMPLEX_SCALAR ，<strong>OBJECT_SCALAR</strong></strong></span></div></blockquote>
<dl class="var">
<dt id="c.NPY_NSCALARKINDS"><span class="yiyi-st" id="yiyi-1494"> <code class="descname">NPY_NSCALARKINDS</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1495">定义为标量类型的数量（不包括<code class="xref c c-data docutils literal"><span class="pre">NPY_NOSCALAR</span></code>）。</span></p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="c.NPY_ORDER"><span class="yiyi-st" id="yiyi-1496"> <code class="descname">NPY_ORDER</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1497">枚举类型，指示数组应解释的元素顺序。</span><span class="yiyi-st" id="yiyi-1498">创建全新数组时，通常只使用<strong>NPY_CORDER</strong>和<strong>NPY_FORTRANORDER</strong>，而在提供一个或多个输入时，顺序可以基于它们。</span></p>
<dl class="var">
<dt id="c.NPY_ANYORDER"><span class="yiyi-st" id="yiyi-1499"> <code class="descname">NPY_ANYORDER</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1500">Fortran的顺序如果所有的输入都是Fortran，否则C。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_CORDER"><span class="yiyi-st" id="yiyi-1501"> <code class="descname">NPY_CORDER</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1502">C命令。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_FORTRANORDER"><span class="yiyi-st" id="yiyi-1503"> <code class="descname">NPY_FORTRANORDER</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1504">Fortran顺序。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_KEEPORDER"><span class="yiyi-st" id="yiyi-1505"> <code class="descname">NPY_KEEPORDER</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1506">尽可能接近输入的顺序，即使输入既不是C也不是Fortran顺序。</span></p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="c.NPY_CLIPMODE"><span class="yiyi-st" id="yiyi-1507"> <code class="descname">NPY_CLIPMODE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1508">指示应在某些功能中应用的剪辑类型的变量类型。</span></p>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-1509"><code class="descname">NPY_RAISE</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1510">大多数操作的默认值，如果索引超出边界则引发异常。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-1511"><code class="descname">NPY_CLIP</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1512">如果索引超出范围，则将其限制为有效范围。</span></p>
</dd></dl>
<dl class="var">
<dt><span class="yiyi-st" id="yiyi-1513"><code class="descname">NPY_WRAP</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1514">如果索引超出范围，则将索引包装到有效范围。</span></p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="c.NPY_CASTING"><span class="yiyi-st" id="yiyi-1515"> <code class="descname">NPY_CASTING</code></span></dt>
<dd><div class="versionadded">
<p><span class="yiyi-st" id="yiyi-1516"><span class="versionmodified">版本1.6中的新功能。</span></span></p>
</div>
<p><span class="yiyi-st" id="yiyi-1517">一种枚举类型，指示应该如何进行许可数据转换。</span><span class="yiyi-st" id="yiyi-1518">这是由NumPy 1.6中添加的迭代器使用的，并且旨在在未来版本中更广泛地使用。</span></p>
<dl class="var">
<dt id="c.NPY_NO_CASTING"><span class="yiyi-st" id="yiyi-1519"> <code class="descname">NPY_NO_CASTING</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1520">只允许相同类型。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_EQUIV_CASTING"><span class="yiyi-st" id="yiyi-1521"> <code class="descname">NPY_EQUIV_CASTING</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1522">允许相同的转换，涉及字节交换。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_SAFE_CASTING"><span class="yiyi-st" id="yiyi-1523"> <code class="descname">NPY_SAFE_CASTING</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1524">仅允许不会导致值被舍入，截断或以其他方式更改的转换。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_SAME_KIND_CASTING"><span class="yiyi-st" id="yiyi-1525"> <code class="descname">NPY_SAME_KIND_CASTING</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1526">允许任何安全投射，并在同种类型之间投射。</span><span class="yiyi-st" id="yiyi-1527">例如，此规则允许使用float64  - &gt; float32。</span></p>
</dd></dl>
<dl class="var">
<dt id="c.NPY_UNSAFE_CASTING"><span class="yiyi-st" id="yiyi-1528"> <code class="descname">NPY_UNSAFE_CASTING</code></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-1529">允许任何投放，无论可能发生什么类型的数据丢失。</span></p>
</dd></dl>
</dd></dl>
<span class="target" id="index-1"></span></div>
</div>
