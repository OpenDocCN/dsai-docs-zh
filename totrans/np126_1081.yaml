- en: How does the CPU dispatcher work?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU调度器是如何工作的？
- en: 原文：[https://numpy.org/doc/1.26/reference/simd/how-it-works.html](https://numpy.org/doc/1.26/reference/simd/how-it-works.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/simd/how-it-works.html](https://numpy.org/doc/1.26/reference/simd/how-it-works.html)
- en: NumPy dispatcher is based on multi-source compiling, which means taking a certain
    source and compiling it multiple times with different compiler flags and also
    with different **C** definitions that affect the code paths. This enables certain
    instruction-sets for each compiled object depending on the required optimizations
    and ends with linking the returned objects together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 调度器基于多源编译，这意味着采用一定的源代码，并使用不同的编译器标志以及不同的**C**定义来多次进行编译，这些定义影响代码路径。这使得每个编译后的对象可以根据所需的优化启用某些指令集，并最终链接返回的对象在一起。
- en: '![../../_images/opt-infra.png](../Images/f17831baf7d16b32813ea2f514d72c2d.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/opt-infra.png](../Images/f17831baf7d16b32813ea2f514d72c2d.png)'
- en: This mechanism should support all compilers and it doesn’t require any compiler-specific
    extension, but at the same time it adds a few steps to normal compilation that
    are explained as follows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制应该支持所有编译器，并且不需要任何特定于编译器的扩展，但与此同时，它会对正常编译增加一些步骤，下面将对此进行解释。
- en: 1- Configuration
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1- 配置
- en: 'Configuring the required optimization by the user before starting to build
    the source files via the two command arguments as explained above:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建源文件之前，用户通过上述两个命令行参数配置所需的优化：
- en: '`--cpu-baseline`: minimal set of required optimizations.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-baseline`：所需优化的最小集合。'
- en: '`--cpu-dispatch`: dispatched set of additional optimizations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-dispatch`：附加优化的调度集合。'
- en: 2- Discovering the environment
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2- 发现环境
- en: In this part, we check the compiler and platform architecture and cache some
    of the intermediary results to speed up rebuilding.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们检查编译器和平台架构，并缓存一些中间结果以加快重新构建的速度。
- en: 3- Validating the requested optimizations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3- 验证所请求的优化
- en: By testing them against the compiler, and seeing what the compiler can support
    according to the requested optimizations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过针对编译器进行测试，以及查看编译器根据请求的优化所支持的内容。
- en: 4- Generating the main configuration header
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4- 生成主配置头文件
- en: The generated header `_cpu_dispatch.h` contains all the definitions and headers
    of instruction-sets for the required optimizations that have been validated during
    the previous step.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的头文件 `_cpu_dispatch.h` 包含了在前一步验证过的所需优化的指令集的所有定义和头文件。
- en: It also contains extra C definitions that are used for defining NumPy’s Python-level
    module attributes `__cpu_baseline__` and `__cpu_dispatch__`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含了额外的 C 定义，用于定义 NumPy 的 Python 模块属性 `__cpu_baseline__` 和 `__cpu_dispatch__`。
- en: '**What is in this header?**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个头文件中有什么内容？**'
- en: The example header was dynamically generated by gcc on an X86 machine. The compiler
    supports `--cpu-baseline="sse sse2 sse3"` and `--cpu-dispatch="ssse3 sse41"`,
    and the result is below.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例头文件是在X86机器上由gcc动态生成的。编译器支持`--cpu-baseline="sse sse2 sse3"`和`--cpu-dispatch="ssse3
    sse41"`，结果如下。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Baseline features** are the minimal set of required optimizations configured
    via `--cpu-baseline`. They have no preprocessor guards and they’re always on,
    which means they can be used in any source.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**基线特性**是通过`--cpu-baseline`配置的所需优化的最小集合。它们没有预处理保护，并且始终开启，这意味着它们可以在任何源代码中使用。'
- en: Does this mean NumPy’s infrastructure passes the compiler’s flags of baseline
    features to all sources?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着 NumPy 的基础设施将基线特性的编译器标志传递给所有源代码？
- en: Definitely, yes. But the [dispatch-able sources](#dispatchable-sources) are
    treated differently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以。但是[可分发的源代码](#dispatchable-sources)会被不同对待。
- en: What if the user specifies certain **baseline features** during the build but
    at runtime the machine doesn’t support even these features? Will the compiled
    code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized
    certain piece of code based on the provided command line compiler flags?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在构建过程中指定了特定的**基线特性**，但在运行时机器甚至不支持这些特性，会怎么样？编译后的代码是否会通过这些定义之一被调用，或者也许编译器本身基于提供的命令行编译器标志自动生成/矢量化某些代码片段？
- en: During the loading of the NumPy module, there’s a validation step which detects
    this behavior. It will raise a Python runtime error to inform the user. This is
    to prevent the CPU reaching an illegal instruction error causing a segfault.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载NumPy模块时，有一个验证步骤来检测这种行为。它会引发Python运行时错误以通知用户。这是为了防止CPU达到非法指令错误，导致段错误。
- en: '**Dispatch-able features** are our dispatched set of additional optimizations
    that were configured via `--cpu-dispatch`. They are not activated by default and
    are always guarded by other C definitions prefixed with `NPY__CPU_TARGET_`. C
    definitions `NPY__CPU_TARGET_` are only enabled within **dispatch-able sources**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**可调度特性** 是我们通过 `--cpu-dispatch` 配置的一组附加优化。它们不会默认激活，并且始终由其他以 `NPY__CPU_TARGET_`
    为前缀的 C 定义保护。C 定义 `NPY__CPU_TARGET_` 仅在 **可调度源** 内启用。'
- en: '## 5- Dispatch-able sources and configuration statements'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5- 可调度源和配置语句'
- en: Dispatch-able sources are special **C** files that can be compiled multiple
    times with different compiler flags and also with different **C** definitions.
    These affect code paths to enable certain instruction-sets for each compiled object
    according to “**the configuration statements**” that must be declared between
    a **C** comment`(/**/)` and start with a special mark **@targets** at the top
    of each dispatch-able source. At the same time, dispatch-able sources will be
    treated as normal **C** sources if the optimization was disabled by the command
    argument `--disable-optimization` .
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可调度源是特殊的 **C** 文件，可以使用不同的编译器标志和不同的 **C** 定义进行多次编译。这些会影响代码路径，以便根据每个编译对象顶部必须声明的“**配置语句**”来启用某些指令集。同时，如果通过命令参数
    `--disable-optimization` 禁用了优化，则可调度源将被视为普通的 **C** 源。
- en: '**What are configuration statements?**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是配置语句？**'
- en: Configuration statements are sort of keywords combined together to determine
    the required optimization for the dispatch-able source.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 配置语句是一种组合在一起以确定可调度源所需优化的关键字。
- en: 'Example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The keywords mainly represent the additional optimizations configured through
    `--cpu-dispatch`, but it can also represent other options such as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键词主要代表了通过 `--cpu-dispatch` 配置的附加优化，但也可以代表其他选项，例如：
- en: 'Target groups: pre-configured configuration statements used for managing the
    required optimizations from outside the dispatch-able source.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标组：用于管理可调度源文件外部所需优化的预配置配置语句。
- en: 'Policies: collections of options used for changing the default behaviors or
    forcing the compilers to perform certain things.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略：一组选项，用于更改默认行为或强制编译器执行某些操作。
- en: '“baseline”: a unique keyword represents the minimal optimizations that configured
    through `--cpu-baseline`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “baseline”：一个唯一的关键字，表示通过 `--cpu-baseline` 配置的最小优化。
- en: '**Numpy’s infrastructure handles dispatch-able sources in four steps**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numpy 的基础设施处理可调度源有四个步骤**：'
- en: '**(A) Recognition**: Just like source templates and F2PY, the dispatch-able
    sources requires a special extension `*.dispatch.c` to mark C dispatch-able source
    files, and for C++ `*.dispatch.cpp` or `*.dispatch.cxx` **NOTE**: C++ not supported
    yet.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(A) 认知**：就像源模板和 F2PY 一样，可调度的源文件需要一个特殊的扩展名 `*.dispatch.c` 来标记 C 可调度的源文件，而对于
    C++ 则是 `*.dispatch.cpp` 或 `*.dispatch.cxx` **注意**：目前不支持 C++。'
- en: '**(B) Parsing and validating**: In this step, the dispatch-able sources that
    had been filtered by the previous step are parsed and validated by the configuration
    statements for each one of them one by one in order to determine the required
    optimizations.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(B) 解析和验证**：在此步骤中，先前通过上一步筛选的可调度源逐个解析和验证其配置语句，以确定所需的优化。'
- en: '**(C) Wrapping**: This is the approach taken by NumPy’s infrastructure, which
    has proved to be sufficiently flexible in order to compile a single source multiple
    times with different **C** definitions and flags that affect the code paths. The
    process is achieved by creating a temporary **C** source for each required optimization
    that related to the additional optimization, which contains the declarations of
    the **C** definitions and includes the involved source via the **C** directive
    **#include**. For more clarification take a look at the following code for AVX512F
    :'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(C) 封装**：这是 NumPy 基础设施采取的方法，已被证明足够灵活，可以使用不同的 **C** 定义和标志多次编译单个源，从而影响代码路径。该过程通过为与附加优化相关的每个所需优化创建临时
    **C** 源来实现，其中包含 **C** 定义的声明，并通过 **C** 指令 **#include** 包含相关源。要了解更多细节，请查看以下 AVX512F
    代码：'
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**(D) Dispatch-able configuration header**: The infrastructure generates a
    config header for each dispatch-able source, this header mainly contains two abstract
    **C** macros used for identifying the generated objects, so they can be used for
    runtime dispatching certain symbols from the generated objects by any **C** source.
    It is also used for forward declarations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**（D）可调度配置头文件**：基础设施为每个可调度源代码生成一个配置头文件，该头文件主要包含两个抽象的**C**宏，用于通过任何**C**源代码从生成的对象中调度特定的符号。它还用于前向声明。'
- en: 'The generated header takes the name of the dispatch-able source after excluding
    the extension and replace it with `.h`, for example assume we have a dispatch-able
    source called `hello.dispatch.c` and contains the following:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成头文件以可调度源的名称命名，排除扩展名并替换为`.h`，例如假设我们有一个名为`hello.dispatch.c`的可调度源代码，其内容如下：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now assume you attached **hello.dispatch.c** to the source tree, then the infrastructure
    should generate a temporary config header called **hello.dispatch.h** that can
    be reached by any source in the source tree, and it should contain the following
    code :'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在假设您将**hello.dispatch.c**附加到源代码树上，那么基础设施应该生成一个名为**hello.dispatch.h**的临时配置头文件，任何源代码都可以访问它，它应该包含以下代码：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'An example of using the config header in light of the above:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据上述内容使用配置头文件的示例：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 1- Configuration
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1- 配置
- en: 'Configuring the required optimization by the user before starting to build
    the source files via the two command arguments as explained above:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始构建源文件之前，通过上述两个命令参数配置所需的优化：
- en: '`--cpu-baseline`: minimal set of required optimizations.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-baseline`: 最小集合的必需优化。'
- en: '`--cpu-dispatch`: dispatched set of additional optimizations.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-dispatch`: 分派的一组额外优化。'
- en: 2- Discovering the environment
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2- 发现环境
- en: In this part, we check the compiler and platform architecture and cache some
    of the intermediary results to speed up rebuilding.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在此部分，我们检查编译器和平台架构，并缓存一些中间结果以加快重建速度。
- en: 3- Validating the requested optimizations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3- 验证所请求的优化
- en: By testing them against the compiler, and seeing what the compiler can support
    according to the requested optimizations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对它们进行编译器测试，并根据所请求的优化查看编译器可以支持的内容。
- en: 4- Generating the main configuration header
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4- 生成主配置头文件
- en: The generated header `_cpu_dispatch.h` contains all the definitions and headers
    of instruction-sets for the required optimizations that have been validated during
    the previous step.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的头文件`_cpu_dispatch.h`包含在上一步中验证的所需优化的所有定义和指令集的标头。
- en: It also contains extra C definitions that are used for defining NumPy’s Python-level
    module attributes `__cpu_baseline__` and `__cpu_dispatch__`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包含用于定义NumPy的Python级模块属性`__cpu_baseline__`和`__cpu_dispatch__`的额外C定义。
- en: '**What is in this header?**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**此标题中包含什么？**'
- en: The example header was dynamically generated by gcc on an X86 machine. The compiler
    supports `--cpu-baseline="sse sse2 sse3"` and `--cpu-dispatch="ssse3 sse41"`,
    and the result is below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例标题在一个X86机器上由gcc动态生成。编译器支持`--cpu-baseline="sse sse2 sse3"`和`--cpu-dispatch="ssse3
    sse41"`，结果如下。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Baseline features** are the minimal set of required optimizations configured
    via `--cpu-baseline`. They have no preprocessor guards and they’re always on,
    which means they can be used in any source.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**基线特性**是通过`--cpu-baseline`配置的最小集合的所需优化。它们没有预处理器保护，并且始终启用，这意味着它们可以在任何源代码中使用。'
- en: Does this mean NumPy’s infrastructure passes the compiler’s flags of baseline
    features to all sources?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着NumPy的基础设施将编译器的基线特性标志传递给所有源代码？
- en: Definitely, yes. But the [dispatch-able sources](#dispatchable-sources) are
    treated differently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，是的。但是[可调度源代码](#dispatchable-sources)会被另外处理。
- en: What if the user specifies certain **baseline features** during the build but
    at runtime the machine doesn’t support even these features? Will the compiled
    code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized
    certain piece of code based on the provided command line compiler flags?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在构建过程中指定了某些**基线特性**，但在运行时机器甚至不支持这些特性怎么办？编译后的代码是否会通过这些定义之一调用，或者编译器是否会根据提供的命令行编译器标志自动生成/矢量化某段代码？
- en: During the loading of the NumPy module, there’s a validation step which detects
    this behavior. It will raise a Python runtime error to inform the user. This is
    to prevent the CPU reaching an illegal instruction error causing a segfault.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载NumPy模块期间，会发现这种行为的验证步骤。它会引发Python运行时错误通知用户。这是为了防止CPU达到非法指令错误而导致段错误。
- en: '**Dispatch-able features** are our dispatched set of additional optimizations
    that were configured via `--cpu-dispatch`. They are not activated by default and
    are always guarded by other C definitions prefixed with `NPY__CPU_TARGET_`. C
    definitions `NPY__CPU_TARGET_` are only enabled within **dispatch-able sources**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**分发功能**是我们通过`--cpu-dispatch`配置的分发的一组额外优化。它们不会默认激活，并始终由以`NPY__CPU_TARGET_`为前缀的其他C定义保护。C定义`NPY__CPU_TARGET_`仅在**分发源内**启用。'
- en: '## 5- Dispatch-able sources and configuration statements'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '## 5- 分发源和配置语句'
- en: Dispatch-able sources are special **C** files that can be compiled multiple
    times with different compiler flags and also with different **C** definitions.
    These affect code paths to enable certain instruction-sets for each compiled object
    according to “**the configuration statements**” that must be declared between
    a **C** comment`(/**/)` and start with a special mark **@targets** at the top
    of each dispatch-able source. At the same time, dispatch-able sources will be
    treated as normal **C** sources if the optimization was disabled by the command
    argument `--disable-optimization` .
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 分发源是特殊的**C**文件，可以使用不同的编译器标志和不同的**C**定义多次编译。这些影响代码路径，根据“**配置语句**”启用每个编译对象的某些指令集，这些语句必须在**C**注释`(/**/)`中声明，并在每个分发源顶部以特殊标记**@targets**开头。同时，如果通过命令参数`--disable-optimization`禁用优化，则将分发源视为正常的**C**源。
- en: '**What are configuration statements?**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是配置语句？**'
- en: Configuration statements are sort of keywords combined together to determine
    the required optimization for the dispatch-able source.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配置语句是一种关键字的组合，用于确定分发源所需的优化。
- en: 'Example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The keywords mainly represent the additional optimizations configured through
    `--cpu-dispatch`, but it can also represent other options such as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字主要代表通过`--cpu-dispatch`配置的额外优化，但也可以代表其他选项，如：
- en: 'Target groups: pre-configured configuration statements used for managing the
    required optimizations from outside the dispatch-able source.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标组：用于管理分发源外部所需优化的预配置配置语句。
- en: 'Policies: collections of options used for changing the default behaviors or
    forcing the compilers to perform certain things.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略：用于改变默认行为或强制编译器执行某些操作的选项集合。
- en: '“baseline”: a unique keyword represents the minimal optimizations that configured
    through `--cpu-baseline`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “baseline”：一个独特的关键字，代表通过`--cpu-baseline`配置的最小优化
- en: '**Numpy’s infrastructure handles dispatch-able sources in four steps**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**NumPy的基础结构处理分发源需要经过四个步骤**：'
- en: '**(A) Recognition**: Just like source templates and F2PY, the dispatch-able
    sources requires a special extension `*.dispatch.c` to mark C dispatch-able source
    files, and for C++ `*.dispatch.cpp` or `*.dispatch.cxx` **NOTE**: C++ not supported
    yet.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(A) 识别**：就像源模板和F2PY一样，分发源文件需要一个特殊的扩展名`*.dispatch.c`来标记C分发源文件，对于C++为`*.dispatch.cpp`或`*.dispatch.cxx`
    **注意**：C++目前不受支持。'
- en: '**(B) Parsing and validating**: In this step, the dispatch-able sources that
    had been filtered by the previous step are parsed and validated by the configuration
    statements for each one of them one by one in order to determine the required
    optimizations.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(B) 解析和验证**：在这个步骤中，通过上一步筛选的分发源将按顺序分别由配置语句解析和验证，以确定所需的优化。'
- en: '**(C) Wrapping**: This is the approach taken by NumPy’s infrastructure, which
    has proved to be sufficiently flexible in order to compile a single source multiple
    times with different **C** definitions and flags that affect the code paths. The
    process is achieved by creating a temporary **C** source for each required optimization
    that related to the additional optimization, which contains the declarations of
    the **C** definitions and includes the involved source via the **C** directive
    **#include**. For more clarification take a look at the following code for AVX512F
    :'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(C) 封装**：这是 NumPy 基础设施采用的方法，已经证明足够灵活，可以编译多次相同的源文件，但使用不同的 **C** 定义和影响代码路径的标志。该过程通过为与额外优化相关的每个必需的优化创建临时
    **C** 源文件来实现，其中包含 **C** 定义的声明，并通过 **C** 指令 **#include** 包含相关源文件。为了更好地说明，请看下面的
    AVX512F 代码：'
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**(D) Dispatch-able configuration header**: The infrastructure generates a
    config header for each dispatch-able source, this header mainly contains two abstract
    **C** macros used for identifying the generated objects, so they can be used for
    runtime dispatching certain symbols from the generated objects by any **C** source.
    It is also used for forward declarations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(D) 可调度配置头文件**：基础设施为每个可调度源生成一个配置头文件，该头文件主要包含两个抽象的 **C** 宏，用于标识生成的对象，以便可以在运行时通过任何
    **C** 源代码调度从生成的对象中的某些符号。它也用于前向声明。'
- en: 'The generated header takes the name of the dispatch-able source after excluding
    the extension and replace it with `.h`, for example assume we have a dispatch-able
    source called `hello.dispatch.c` and contains the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成的头文件采用可调度源的名称，排除扩展名，并替换为`.h`，例如假设我们有一个名为 `hello.dispatch.c` 的可调度源，并包含以下内容：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now assume you attached **hello.dispatch.c** to the source tree, then the infrastructure
    should generate a temporary config header called **hello.dispatch.h** that can
    be reached by any source in the source tree, and it should contain the following
    code :'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设你已经将 **hello.dispatch.c** 附加到源树中，那么基础设施应该生成一个临时的配置头文件，名为 **hello.dispatch.h**，可以被源树中的任何源文件访问，并且应包含以下代码：
- en: '[PRE10]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An example of using the config header in light of the above:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据上述示例使用配置头文件的示例：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
