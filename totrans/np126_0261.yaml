- en: The numpy.ma module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/maskedarray.generic.html](https://numpy.org/doc/1.26/reference/maskedarray.generic.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rationale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Masked arrays are arrays that may have missing or invalid entries. The [`numpy.ma`](#module-numpy.ma
    "numpy.ma") module provides a nearly work-alike replacement for numpy that supports
    data arrays with masks.
  prefs: []
  type: TYPE_NORMAL
- en: What is a masked array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many circumstances, datasets can be incomplete or tainted by the presence
    of invalid data. For example, a sensor may have failed to record a data, or recorded
    an invalid value. The [`numpy.ma`](#module-numpy.ma "numpy.ma") module provides
    a convenient way to address this issue, by introducing masked arrays.
  prefs: []
  type: TYPE_NORMAL
- en: A masked array is the combination of a standard [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and a mask. A mask is either [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask"), indicating that no value of the associated array is invalid,
    or an array of booleans that determines for each element of the associated array
    whether the value is valid or not. When an element of the mask is `False`, the
    corresponding element of the associated array is valid and is said to be unmasked.
    When an element of the mask is `True`, the corresponding element of the associated
    array is said to be masked (invalid).
  prefs: []
  type: TYPE_NORMAL
- en: The package ensures that masked entries are not used in computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, let’s consider the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to mark the fourth entry as invalid. The easiest is to create a masked
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compute the mean of the dataset, without taking the invalid data
    into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The [`numpy.ma`](#module-numpy.ma "numpy.ma") module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main feature of the [`numpy.ma`](#module-numpy.ma "numpy.ma") module is
    the [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray "numpy.ma.MaskedArray")
    class, which is a subclass of [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"). The class, its attributes and methods are described in more
    details in the [MaskedArray class](maskedarray.baseclass.html#maskedarray-baseclass)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`numpy.ma`](#module-numpy.ma "numpy.ma") module can be used as an addition
    to [`numpy`](index.html#module-numpy "numpy"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an array with the second element invalid, we would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a masked array where all values close to 1.e20 are invalid, we would
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For a complete discussion of creation methods for masked arrays please see section
    [Constructing masked arrays](#maskedarray-generic-constructing).
  prefs: []
  type: TYPE_NORMAL
- en: Rationale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Masked arrays are arrays that may have missing or invalid entries. The [`numpy.ma`](#module-numpy.ma
    "numpy.ma") module provides a nearly work-alike replacement for numpy that supports
    data arrays with masks.
  prefs: []
  type: TYPE_NORMAL
- en: What is a masked array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many circumstances, datasets can be incomplete or tainted by the presence
    of invalid data. For example, a sensor may have failed to record a data, or recorded
    an invalid value. The [`numpy.ma`](#module-numpy.ma "numpy.ma") module provides
    a convenient way to address this issue, by introducing masked arrays.
  prefs: []
  type: TYPE_NORMAL
- en: A masked array is the combination of a standard [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and a mask. A mask is either [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask"), indicating that no value of the associated array is invalid,
    or an array of booleans that determines for each element of the associated array
    whether the value is valid or not. When an element of the mask is `False`, the
    corresponding element of the associated array is valid and is said to be unmasked.
    When an element of the mask is `True`, the corresponding element of the associated
    array is said to be masked (invalid).
  prefs: []
  type: TYPE_NORMAL
- en: The package ensures that masked entries are not used in computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, let’s consider the following dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to mark the fourth entry as invalid. The easiest is to create a masked
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compute the mean of the dataset, without taking the invalid data
    into account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The [`numpy.ma`](#module-numpy.ma "numpy.ma") module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main feature of the [`numpy.ma`](#module-numpy.ma "numpy.ma") module is
    the [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray "numpy.ma.MaskedArray")
    class, which is a subclass of [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"). The class, its attributes and methods are described in more
    details in the [MaskedArray class](maskedarray.baseclass.html#maskedarray-baseclass)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`numpy.ma`](#module-numpy.ma "numpy.ma") module can be used as an addition
    to [`numpy`](index.html#module-numpy "numpy"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an array with the second element invalid, we would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a masked array where all values close to 1.e20 are invalid, we would
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For a complete discussion of creation methods for masked arrays please see section
    [Constructing masked arrays](#maskedarray-generic-constructing).
  prefs: []
  type: TYPE_NORMAL
- en: Using numpy.ma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '## Constructing masked arrays'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to construct a masked array.
  prefs: []
  type: TYPE_NORMAL
- en: A first possibility is to directly invoke the [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray
    "numpy.ma.MaskedArray") class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second possibility is to use the two masked array constructors, [`array`](generated/numpy.ma.array.html#numpy.ma.array
    "numpy.ma.array") and [`masked_array`](generated/numpy.ma.masked_array.html#numpy.ma.masked_array
    "numpy.ma.masked_array").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`array`](generated/numpy.ma.array.html#numpy.ma.array "numpy.ma.array")(data[, dtype, copy, order, mask, ...])
    | An array class with possibly masked values. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_array`](generated/numpy.ma.masked_array.html#numpy.ma.masked_array
    "numpy.ma.masked_array") | alias of `MaskedArray` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: A third option is to take the view of an existing array. In that case, the mask
    of the view is set to [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    if the array has no named fields, or an array of boolean with the same structure
    as the array otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Yet another possibility is to use any of the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`asarray`](generated/numpy.ma.asarray.html#numpy.ma.asarray "numpy.ma.asarray")(a[, dtype, order])
    | Convert the input to a masked array of the given data-type. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`asanyarray`](generated/numpy.ma.asanyarray.html#numpy.ma.asanyarray "numpy.ma.asanyarray")(a[, dtype])
    | Convert the input to a masked array, conserving subclasses. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`fix_invalid`](generated/numpy.ma.fix_invalid.html#numpy.ma.fix_invalid
    "numpy.ma.fix_invalid")(a[, mask, copy, fill_value]) | Return input with invalid
    data masked and replaced by a fill value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_equal`](generated/numpy.ma.masked_equal.html#numpy.ma.masked_equal
    "numpy.ma.masked_equal")(x, value[, copy]) | Mask an array where equal to a given
    value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_greater`](generated/numpy.ma.masked_greater.html#numpy.ma.masked_greater
    "numpy.ma.masked_greater")(x, value[, copy]) | Mask an array where greater than
    a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_greater_equal`](generated/numpy.ma.masked_greater_equal.html#numpy.ma.masked_greater_equal
    "numpy.ma.masked_greater_equal")(x, value[, copy]) | Mask an array where greater
    than or equal to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_inside`](generated/numpy.ma.masked_inside.html#numpy.ma.masked_inside
    "numpy.ma.masked_inside")(x, v1, v2[, copy]) | Mask an array inside a given interval.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_invalid`](generated/numpy.ma.masked_invalid.html#numpy.ma.masked_invalid
    "numpy.ma.masked_invalid")(a[, copy]) | Mask an array where invalid values occur
    (NaNs or infs). |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_less`](generated/numpy.ma.masked_less.html#numpy.ma.masked_less
    "numpy.ma.masked_less")(x, value[, copy]) | Mask an array where less than a given
    value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_less_equal`](generated/numpy.ma.masked_less_equal.html#numpy.ma.masked_less_equal
    "numpy.ma.masked_less_equal")(x, value[, copy]) | Mask an array where less than
    or equal to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_not_equal`](generated/numpy.ma.masked_not_equal.html#numpy.ma.masked_not_equal
    "numpy.ma.masked_not_equal")(x, value[, copy]) | Mask an array where *not* equal
    to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_object`](generated/numpy.ma.masked_object.html#numpy.ma.masked_object
    "numpy.ma.masked_object")(x, value[, copy, shrink]) | Mask the array *x* where
    the data are exactly equal to value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_outside`](generated/numpy.ma.masked_outside.html#numpy.ma.masked_outside
    "numpy.ma.masked_outside")(x, v1, v2[, copy]) | Mask an array outside a given
    interval. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_values`](generated/numpy.ma.masked_values.html#numpy.ma.masked_values
    "numpy.ma.masked_values")(x, value[, rtol, atol, copy, ...]) | Mask using floating
    point equality. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_where`](generated/numpy.ma.masked_where.html#numpy.ma.masked_where
    "numpy.ma.masked_where")(condition, a[, copy]) | Mask an array where a condition
    is met. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Accessing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The underlying data of a masked array can be accessed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: through the [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data "numpy.ma.MaskedArray.data")
    attribute. The output is a view of the array as a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") or one of its subclasses, depending on the type of the underlying
    data at the masked array creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: through the [`__array__`](generated/numpy.ma.MaskedArray.__array__.html#numpy.ma.MaskedArray.__array__
    "numpy.ma.MaskedArray.__array__") method. The output is then a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: by directly taking a view of the masked array as a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") or one of its subclass (which is actually what using the [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") attribute does).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: by using the [`getdata`](generated/numpy.ma.getdata.html#numpy.ma.getdata "numpy.ma.getdata")
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these methods is completely satisfactory if some entries have been marked
    as invalid. As a general rule, where a representation of the array is required
    without any masked entries, it is recommended to fill the array with the [`filled`](generated/numpy.ma.filled.html#numpy.ma.filled
    "numpy.ma.filled") method.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the mask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mask of a masked array is accessible through its [`mask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") attribute. We must keep in mind that a `True` entry
    in the mask indicates an *invalid* data.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to use the [`getmask`](generated/numpy.ma.getmask.html#numpy.ma.getmask
    "numpy.ma.getmask") and [`getmaskarray`](generated/numpy.ma.getmaskarray.html#numpy.ma.getmaskarray
    "numpy.ma.getmaskarray") functions. `getmask(x)` outputs the mask of `x` if `x`
    is a masked array, and the special value [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask") otherwise. `getmaskarray(x)` outputs the mask of `x` if `x`
    is a masked array. If `x` has no invalid entry or is not a masked array, the function
    outputs a boolean array of `False` with as many elements as `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing only the valid entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve only the valid entries, we can use the inverse of the mask as an
    index. The inverse of the mask can be calculated with the [`numpy.logical_not`](generated/numpy.logical_not.html#numpy.logical_not
    "numpy.logical_not") function or simply with the `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to retrieve the valid data is to use the [`compressed`](generated/numpy.ma.compressed.html#numpy.ma.compressed
    "numpy.ma.compressed") method, which returns a one-dimensional [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") (or one of its subclasses, depending on the value of the [`baseclass`](maskedarray.baseclass.html#numpy.ma.MaskedArray.baseclass
    "numpy.ma.MaskedArray.baseclass") attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output of [`compressed`](generated/numpy.ma.compressed.html#numpy.ma.compressed
    "numpy.ma.compressed") is always 1D.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the mask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Masking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recommended way to mark one or several specific entries of a masked array
    as invalid is to assign the special value [`masked`](maskedarray.baseclass.html#numpy.ma.masked
    "numpy.ma.masked") to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A second possibility is to modify the [`mask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") directly, but this usage is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new masked array with a simple, non-structured datatype, the
    mask is initially set to the special value [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask"), that corresponds roughly to the boolean `False`. Trying to
    set an element of [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    will fail with a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") exception, as a boolean does not support item assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the entries of an array can be masked at once by assigning `True` to the
    mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, specific entries can be masked and/or unmasked by assigning to the
    mask a sequence of booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unmasking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To unmask one or several specific entries, we can just assign one or several
    new valid values to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Unmasking an entry by direct assignment will silently fail if the masked array
    has a *hard* mask, as shown by the [`hardmask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.hardmask
    "numpy.ma.MaskedArray.hardmask") attribute. This feature was introduced to prevent
    overwriting the mask. To force the unmasking of an entry where the array has a
    hard mask, the mask must first to be softened using the [`soften_mask`](generated/numpy.ma.soften_mask.html#numpy.ma.soften_mask
    "numpy.ma.soften_mask") method before the allocation. It can be re-hardened with
    [`harden_mask`](generated/numpy.ma.harden_mask.html#numpy.ma.harden_mask "numpy.ma.harden_mask"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To unmask all masked entries of a masked array (provided the mask isn’t a hard
    mask), the simplest solution is to assign the constant [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask") to the mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray "numpy.ma.MaskedArray")
    is a subclass of [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), it inherits its mechanisms for indexing and slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When accessing a single entry of a masked array with no named fields, the output
    is either a scalar (if the corresponding entry of the mask is `False`) or the
    special value [`masked`](maskedarray.baseclass.html#numpy.ma.masked "numpy.ma.masked")
    (if the corresponding entry of the mask is `True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the masked array has named fields, accessing a single entry returns a [`numpy.void`](arrays.scalars.html#numpy.void
    "numpy.void") object if none of the fields are masked, or a 0d masked array with
    the same dtype as the initial array if at least one of the fields is masked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When accessing a slice, the output is a masked array whose [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") attribute is a view of the original data, and whose
    mask is either [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    (if there was no invalid entries in the original array) or a view of the corresponding
    slice of the original mask. The view is required to ensure propagation of any
    modification of the mask to the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a field of a masked array with structured datatype returns a [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray
    "numpy.ma.MaskedArray").
  prefs: []
  type: TYPE_NORMAL
- en: Operations on masked arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic and comparison operations are supported by masked arrays. As much
    as possible, invalid entries of a masked array are not processed, meaning that
    the corresponding [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") entries *should* be the same before and after the
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: We need to stress that this behavior may not be systematic, that masked data
    may be affected by the operation in some cases and therefore users should not
    rely on this data remaining unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`numpy.ma`](#module-numpy.ma "numpy.ma") module comes with a specific
    implementation of most ufuncs. Unary and binary functions that have a validity
    domain (such as [`log`](generated/numpy.log.html#numpy.log "numpy.log") or [`divide`](generated/numpy.divide.html#numpy.divide
    "numpy.divide")) return the [`masked`](maskedarray.baseclass.html#numpy.ma.masked
    "numpy.ma.masked") constant whenever the input is masked or falls outside the
    validity domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Masked arrays also support standard numpy ufuncs. The output is then a masked
    array. The result of a unary ufunc is masked wherever the input is masked. The
    result of a binary ufunc is masked wherever any of the input is masked. If the
    ufunc also returns the optional context output (a 3-element tuple containing the
    name of the ufunc, its arguments and its domain), the context is processed and
    entries of the output masked array are masked wherever the corresponding input
    fall outside the validity domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '## Constructing masked arrays'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to construct a masked array.
  prefs: []
  type: TYPE_NORMAL
- en: A first possibility is to directly invoke the [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray
    "numpy.ma.MaskedArray") class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second possibility is to use the two masked array constructors, [`array`](generated/numpy.ma.array.html#numpy.ma.array
    "numpy.ma.array") and [`masked_array`](generated/numpy.ma.masked_array.html#numpy.ma.masked_array
    "numpy.ma.masked_array").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`array`](generated/numpy.ma.array.html#numpy.ma.array "numpy.ma.array")(data[, dtype, copy, order, mask, ...])
    | An array class with possibly masked values. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_array`](generated/numpy.ma.masked_array.html#numpy.ma.masked_array
    "numpy.ma.masked_array") | alias of `MaskedArray` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: A third option is to take the view of an existing array. In that case, the mask
    of the view is set to [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    if the array has no named fields, or an array of boolean with the same structure
    as the array otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Yet another possibility is to use any of the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`asarray`](generated/numpy.ma.asarray.html#numpy.ma.asarray "numpy.ma.asarray")(a[, dtype, order])
    | Convert the input to a masked array of the given data-type. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`asanyarray`](generated/numpy.ma.asanyarray.html#numpy.ma.asanyarray "numpy.ma.asanyarray")(a[, dtype])
    | Convert the input to a masked array, conserving subclasses. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`fix_invalid`](generated/numpy.ma.fix_invalid.html#numpy.ma.fix_invalid
    "numpy.ma.fix_invalid")(a[, mask, copy, fill_value]) | Return input with invalid
    data masked and replaced by a fill value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_equal`](generated/numpy.ma.masked_equal.html#numpy.ma.masked_equal
    "numpy.ma.masked_equal")(x, value[, copy]) | Mask an array where equal to a given
    value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_greater`](generated/numpy.ma.masked_greater.html#numpy.ma.masked_greater
    "numpy.ma.masked_greater")(x, value[, copy]) | Mask an array where greater than
    a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_greater_equal`](generated/numpy.ma.masked_greater_equal.html#numpy.ma.masked_greater_equal
    "numpy.ma.masked_greater_equal")(x, value[, copy]) | Mask an array where greater
    than or equal to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_inside`](generated/numpy.ma.masked_inside.html#numpy.ma.masked_inside
    "numpy.ma.masked_inside")(x, v1, v2[, copy]) | Mask an array inside a given interval.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_invalid`](generated/numpy.ma.masked_invalid.html#numpy.ma.masked_invalid
    "numpy.ma.masked_invalid")(a[, copy]) | Mask an array where invalid values occur
    (NaNs or infs). |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_less`](generated/numpy.ma.masked_less.html#numpy.ma.masked_less
    "numpy.ma.masked_less")(x, value[, copy]) | Mask an array where less than a given
    value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_less_equal`](generated/numpy.ma.masked_less_equal.html#numpy.ma.masked_less_equal
    "numpy.ma.masked_less_equal")(x, value[, copy]) | Mask an array where less than
    or equal to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_not_equal`](generated/numpy.ma.masked_not_equal.html#numpy.ma.masked_not_equal
    "numpy.ma.masked_not_equal")(x, value[, copy]) | Mask an array where *not* equal
    to a given value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_object`](generated/numpy.ma.masked_object.html#numpy.ma.masked_object
    "numpy.ma.masked_object")(x, value[, copy, shrink]) | Mask the array *x* where
    the data are exactly equal to value. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_outside`](generated/numpy.ma.masked_outside.html#numpy.ma.masked_outside
    "numpy.ma.masked_outside")(x, v1, v2[, copy]) | Mask an array outside a given
    interval. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_values`](generated/numpy.ma.masked_values.html#numpy.ma.masked_values
    "numpy.ma.masked_values")(x, value[, rtol, atol, copy, ...]) | Mask using floating
    point equality. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| [`masked_where`](generated/numpy.ma.masked_where.html#numpy.ma.masked_where
    "numpy.ma.masked_where")(condition, a[, copy]) | Mask an array where a condition
    is met. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Accessing the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The underlying data of a masked array can be accessed in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: through the [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data "numpy.ma.MaskedArray.data")
    attribute. The output is a view of the array as a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") or one of its subclasses, depending on the type of the underlying
    data at the masked array creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: through the [`__array__`](generated/numpy.ma.MaskedArray.__array__.html#numpy.ma.MaskedArray.__array__
    "numpy.ma.MaskedArray.__array__") method. The output is then a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: by directly taking a view of the masked array as a [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") or one of its subclass (which is actually what using the [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") attribute does).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: by using the [`getdata`](generated/numpy.ma.getdata.html#numpy.ma.getdata "numpy.ma.getdata")
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these methods is completely satisfactory if some entries have been marked
    as invalid. As a general rule, where a representation of the array is required
    without any masked entries, it is recommended to fill the array with the [`filled`](generated/numpy.ma.filled.html#numpy.ma.filled
    "numpy.ma.filled") method.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the mask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mask of a masked array is accessible through its [`mask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") attribute. We must keep in mind that a `True` entry
    in the mask indicates an *invalid* data.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to use the [`getmask`](generated/numpy.ma.getmask.html#numpy.ma.getmask
    "numpy.ma.getmask") and [`getmaskarray`](generated/numpy.ma.getmaskarray.html#numpy.ma.getmaskarray
    "numpy.ma.getmaskarray") functions. `getmask(x)` outputs the mask of `x` if `x`
    is a masked array, and the special value [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask") otherwise. `getmaskarray(x)` outputs the mask of `x` if `x`
    is a masked array. If `x` has no invalid entry or is not a masked array, the function
    outputs a boolean array of `False` with as many elements as `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing only the valid entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve only the valid entries, we can use the inverse of the mask as an
    index. The inverse of the mask can be calculated with the [`numpy.logical_not`](generated/numpy.logical_not.html#numpy.logical_not
    "numpy.logical_not") function or simply with the `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to retrieve the valid data is to use the [`compressed`](generated/numpy.ma.compressed.html#numpy.ma.compressed
    "numpy.ma.compressed") method, which returns a one-dimensional [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") (or one of its subclasses, depending on the value of the [`baseclass`](maskedarray.baseclass.html#numpy.ma.MaskedArray.baseclass
    "numpy.ma.MaskedArray.baseclass") attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output of [`compressed`](generated/numpy.ma.compressed.html#numpy.ma.compressed
    "numpy.ma.compressed") is always 1D.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the mask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Masking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recommended way to mark one or several specific entries of a masked array
    as invalid is to assign the special value [`masked`](maskedarray.baseclass.html#numpy.ma.masked
    "numpy.ma.masked") to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A second possibility is to modify the [`mask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") directly, but this usage is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new masked array with a simple, non-structured datatype, the
    mask is initially set to the special value [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask"), that corresponds roughly to the boolean `False`. Trying to
    set an element of [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    will fail with a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") exception, as a boolean does not support item assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the entries of an array can be masked at once by assigning `True` to the
    mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, specific entries can be masked and/or unmasked by assigning to the
    mask a sequence of booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unmasking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To unmask one or several specific entries, we can just assign one or several
    new valid values to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Unmasking an entry by direct assignment will silently fail if the masked array
    has a *hard* mask, as shown by the [`hardmask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.hardmask
    "numpy.ma.MaskedArray.hardmask") attribute. This feature was introduced to prevent
    overwriting the mask. To force the unmasking of an entry where the array has a
    hard mask, the mask must first to be softened using the [`soften_mask`](generated/numpy.ma.soften_mask.html#numpy.ma.soften_mask
    "numpy.ma.soften_mask") method before the allocation. It can be re-hardened with
    [`harden_mask`](generated/numpy.ma.harden_mask.html#numpy.ma.harden_mask "numpy.ma.harden_mask"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To unmask all masked entries of a masked array (provided the mask isn’t a hard
    mask), the simplest solution is to assign the constant [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask") to the mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Masking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The recommended way to mark one or several specific entries of a masked array
    as invalid is to assign the special value [`masked`](maskedarray.baseclass.html#numpy.ma.masked
    "numpy.ma.masked") to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A second possibility is to modify the [`mask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") directly, but this usage is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When creating a new masked array with a simple, non-structured datatype, the
    mask is initially set to the special value [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask"), that corresponds roughly to the boolean `False`. Trying to
    set an element of [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    will fail with a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") exception, as a boolean does not support item assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the entries of an array can be masked at once by assigning `True` to the
    mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, specific entries can be masked and/or unmasked by assigning to the
    mask a sequence of booleans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Unmasking an entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To unmask one or several specific entries, we can just assign one or several
    new valid values to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Unmasking an entry by direct assignment will silently fail if the masked array
    has a *hard* mask, as shown by the [`hardmask`](maskedarray.baseclass.html#numpy.ma.MaskedArray.hardmask
    "numpy.ma.MaskedArray.hardmask") attribute. This feature was introduced to prevent
    overwriting the mask. To force the unmasking of an entry where the array has a
    hard mask, the mask must first to be softened using the [`soften_mask`](generated/numpy.ma.soften_mask.html#numpy.ma.soften_mask
    "numpy.ma.soften_mask") method before the allocation. It can be re-hardened with
    [`harden_mask`](generated/numpy.ma.harden_mask.html#numpy.ma.harden_mask "numpy.ma.harden_mask"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To unmask all masked entries of a masked array (provided the mask isn’t a hard
    mask), the simplest solution is to assign the constant [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask
    "numpy.ma.nomask") to the mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray "numpy.ma.MaskedArray")
    is a subclass of [`numpy.ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), it inherits its mechanisms for indexing and slicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When accessing a single entry of a masked array with no named fields, the output
    is either a scalar (if the corresponding entry of the mask is `False`) or the
    special value [`masked`](maskedarray.baseclass.html#numpy.ma.masked "numpy.ma.masked")
    (if the corresponding entry of the mask is `True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the masked array has named fields, accessing a single entry returns a [`numpy.void`](arrays.scalars.html#numpy.void
    "numpy.void") object if none of the fields are masked, or a 0d masked array with
    the same dtype as the initial array if at least one of the fields is masked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When accessing a slice, the output is a masked array whose [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") attribute is a view of the original data, and whose
    mask is either [`nomask`](maskedarray.baseclass.html#numpy.ma.nomask "numpy.ma.nomask")
    (if there was no invalid entries in the original array) or a view of the corresponding
    slice of the original mask. The view is required to ensure propagation of any
    modification of the mask to the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a field of a masked array with structured datatype returns a [`MaskedArray`](maskedarray.baseclass.html#numpy.ma.MaskedArray
    "numpy.ma.MaskedArray").
  prefs: []
  type: TYPE_NORMAL
- en: Operations on masked arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic and comparison operations are supported by masked arrays. As much
    as possible, invalid entries of a masked array are not processed, meaning that
    the corresponding [`data`](maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") entries *should* be the same before and after the
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: We need to stress that this behavior may not be systematic, that masked data
    may be affected by the operation in some cases and therefore users should not
    rely on this data remaining unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`numpy.ma`](#module-numpy.ma "numpy.ma") module comes with a specific
    implementation of most ufuncs. Unary and binary functions that have a validity
    domain (such as [`log`](generated/numpy.log.html#numpy.log "numpy.log") or [`divide`](generated/numpy.divide.html#numpy.divide
    "numpy.divide")) return the [`masked`](maskedarray.baseclass.html#numpy.ma.masked
    "numpy.ma.masked") constant whenever the input is masked or falls outside the
    validity domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Masked arrays also support standard numpy ufuncs. The output is then a masked
    array. The result of a unary ufunc is masked wherever the input is masked. The
    result of a binary ufunc is masked wherever any of the input is masked. If the
    ufunc also returns the optional context output (a 3-element tuple containing the
    name of the ufunc, its arguments and its domain), the context is processed and
    entries of the output masked array are masked wherever the corresponding input
    fall outside the validity domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data with a given value representing missing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider a list of elements, `x`, where values of -9999\. represent missing
    data. We wish to compute the average value of the data and the vector of anomalies
    (deviations from the average):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Filling in the missing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose now that we wish to print that same data, but with the missing values
    replaced by the average value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Numerical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numerical operations can be easily performed without worrying about missing
    values, dividing by zero, square roots of negative numbers, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Four values of the output are invalid: the first one comes from taking the
    square root of a negative number, the second from the division by zero, and the
    last two where the inputs were masked.'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring extreme values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider an array `d` of floats between 0 and 1\. We wish to compute
    the average of the values of `d` while ignoring any data outside the range `[0.2,
    0.9]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Data with a given value representing missing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider a list of elements, `x`, where values of -9999\. represent missing
    data. We wish to compute the average value of the data and the vector of anomalies
    (deviations from the average):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Filling in the missing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose now that we wish to print that same data, but with the missing values
    replaced by the average value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Numerical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numerical operations can be easily performed without worrying about missing
    values, dividing by zero, square roots of negative numbers, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Four values of the output are invalid: the first one comes from taking the
    square root of a negative number, the second from the division by zero, and the
    last two where the inputs were masked.'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring extreme values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider an array `d` of floats between 0 and 1\. We wish to compute
    the average of the values of `d` while ignoring any data outside the range `[0.2,
    0.9]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
