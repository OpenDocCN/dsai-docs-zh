["```py\n>>> from sympy import sqrt\n>>> sqrt(2**2)\n2\n>>> sqrt((-2)**2)\n2\n>>> x = 2\n>>> sqrt(x**2)\n2\n>>> sqrt(x**2) == x\nTrue\n>>> y = -2\n>>> sqrt(y**2) == y\nFalse\n>>> sqrt(y**2) == -y\nTrue \n```", "```py\n>>> from sympy import Symbol, simplify\n>>> x = Symbol('x')\n>>> sqrt(x**2)\nsqrt(x**2) \n```", "```py\n>>> simplify(sqrt(x**2))\nsqrt(x**2) \n```", "```py\n>>> y = Symbol('y', positive=True)\n>>> sqrt(y**2)\ny \n```", "```py\n>>> x = Symbol('x', positive=True)\n>>> x.is_positive\nTrue \n```", "```py\n>>> x = Symbol('x', positive=True)\n>>> expr = 1 + x**2\n>>> expr\nx**2 + 1\n>>> expr.is_positive\nTrue\n>>> expr.is_negative\nFalse \n```", "```py\n>>> x = Symbol('x')\n>>> y = Symbol('y', positive=True)\n>>> z = Symbol('z', negative=True)\n>>> print(x.is_positive)\nNone\n>>> print(y.is_positive)\nTrue\n>>> print(z.is_positive)\nFalse \n```", "```py\n>>> from sympy import symbols\n>>> x, y = symbols('x, y', positive=True)\n>>> expr = x + y\n>>> expr\nx + y\n>>> expr.is_positive\nTrue \n```", "```py\n>>> x = Symbol('x', real=True)\n>>> expr = 1 + (x - 2)**2\n>>> expr\n(x - 2)**2 + 1\n>>> expr.is_positive\nTrue\n>>> expr2 = expr.expand()\n>>> expr2\nx**2 - 4*x + 5\n>>> print(expr2.is_positive)\nNone \n```", "```py\n>>> from sympy import S\n>>> x = 2\n>>> x.is_positive\nTraceback (most recent call last):\n...\nAttributeError: 'int' object has no attribute 'is_positive'\n>>> x = S(2)\n>>> type(x)\n<class 'sympy.core.numbers.Integer'>\n>>> x.is_positive\nTrue \n```", "```py\n>>> x1 = Symbol('x')\n>>> x2 = Symbol('x')\n>>> x1\nx\n>>> x2\nx\n>>> x1 == x2\nTrue \n```", "```py\n>>> x1 = Symbol('x', positive=True)\n>>> x2 = Symbol('x')\n>>> x1\nx\n>>> x2\nx\n>>> x1 == x2\nFalse \n```", "```py\n>>> from sympy import posify, exp\n>>> x = Symbol('x')\n>>> expr = exp(sqrt(x**2))\n>>> expr\nexp(sqrt(x**2))\n>>> posify(expr)\n(exp(_x), {_x: x})\n>>> expr2, rep = posify(expr)\n>>> expr2\nexp(_x) \n```", "```py\n>>> expr2\nexp(_x)\n>>> expr2 == exp(x)\nFalse\n>>> expr2.subs(rep)\nexp(x)\n>>> expr2.subs(rep) == exp(x)\nTrue \n```", "```py\n>>> from sympy import solve\n>>> solve('x**2 - 1')\n[-1, 1] \n```", "```py\n>>> x = Symbol('x', positive=True)\n>>> solve(x**2 - 1)\n[1] \n```", "```py\n>>> from sympy import parse_expr\n>>> parse_expr('x**2 - 1')\nx**2 - 1\n>>> eq = parse_expr('x**2 - 1', {'x':Symbol('x', positive=True)})\n>>> solve(eq)\n[1] \n```", "```py\n>>> x = Symbol('x', positive=True, integer=True)\n>>> x.is_positive\nTrue\n>>> x.is_integer\nTrue \n```", "```py\n>>> x.assumptions0\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'integer': True,\n 'irrational': False,\n 'negative': False,\n 'noninteger': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False} \n```", "```py\n>>> x = Symbol('x', real=True, negative=False, zero=False)\n>>> x.is_positive\nTrue \n```", "```py\n>>> x1 = Symbol('x1', positive=True, real=True)\n>>> x2 = Symbol('x2', positive=True)\n>>> x1.is_real\nTrue\n>>> x2.is_real\nTrue\n>>> x1.assumptions0 == x2.assumptions0\nTrue \n```", "```py\n>>> x = Symbol('x', commutative=False, real=True)\nTraceback (most recent call last):\n...\nInconsistentAssumptions: {\n algebraic: False,\n commutative: False,\n complex: False,\n composite: False,\n even: False,\n extended_negative: False,\n extended_nonnegative: False,\n extended_nonpositive: False,\n extended_nonzero: False,\n extended_positive: False,\n extended_real: False,\n imaginary: False,\n integer: False,\n irrational: False,\n negative: False,\n noninteger: False,\n nonnegative: False,\n nonpositive: False,\n nonzero: False,\n odd: False,\n positive: False,\n prime: False,\n rational: False,\n real: False,\n transcendental: False,\n zero: False}, real=True \n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[0, 0], [0, 0]])\n>>> M.is_zero\nFalse\n>>> M.is_zero_matrix\nTrue \n```", "```py\ninteger  ->  rational  ->  real  ->  complex \n```", "```py\n>>> x = Symbol('x')\n>>> x.assumptions0\n{'commutative': True}\n>>> print(x.is_commutative)\nTrue\n>>> print(x.is_rational)\nNone\n>>> print(x.is_complex)\nNone\n>>> print(x.is_real)\nNone\n>>> print(x.is_integer)\nNone\n>>> print(x.is_finite)\nNone \n```", "```py\n>>> n = Symbol('n', integer=True)\n>>> n.assumptions0\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'integer': True,\n 'irrational': False,\n 'noninteger': False,\n 'rational': True,\n 'real': True,\n 'transcendental': False} \n```", "```py\n>>> from sympy import sin, pi\n>>> n1 = Symbol('n1')\n>>> n2 = Symbol('n2', integer=True)\n>>> sin(n1 * pi)\nsin(pi*n1)\n>>> sin(n2 * pi)\n0 \n```", "```py\n>>> x = Symbol('x', negative=False)\n>>> print(x.is_negative)\nFalse\n>>> print(x.is_nonnegative)\nNone\n>>> print(x.is_real)\nNone\n>>> print(x.is_complex)\nNone\n>>> print(x.is_finite)\nNone \n```", "```py\n>>> x = Symbol('x', real=True, negative=False)\n>>> print(x.is_negative)\nFalse\n>>> print(x.is_nonnegative)\nTrue\n>>> print(x.is_real)\nTrue\n>>> print(x.is_complex)\nTrue\n>>> print(x.is_finite)\nTrue \n```", "```py\n>>> x, y = symbols('x, y', commutative=False)\n>>> z = Symbol('z')  # defaults to commutative=True\n>>> x*y + y*x\nx*y + y*x\n>>> x*z + z*x\n2*z*x \n```", "```py\n>>> from sympy import FiniteSet, Intersection\n>>> S1 = FiniteSet(1, 2)\n>>> S1\n{1, 2}\n>>> print(S1.is_empty)\nFalse\n>>> S2 = Intersection(FiniteSet(1), FiniteSet(Symbol('x')))\n>>> S2\nIntersection({1}, {x})\n>>> print(S2.is_empty)\nNone \n```", "```py\n>>> from sympy import Number, Rational\n>>> x = Rational(1, 2)\n>>> isinstance(x, Number)\nTrue\n>>> x.is_Number\nTrue\n>>> y = Symbol('y', rational=True)\n>>> isinstance(y, Number)\nFalse\n>>> y.is_Number\nFalse \n```", "```py\n>>> from sympy import I\n>>> expr1 = I + sqrt(2)\n>>> expr1\nsqrt(2) + I\n>>> expr1.is_number\nTrue\n>>> expr1.evalf()\n1.4142135623731 + 1.0*I\n>>> x = Symbol('x')\n>>> expr2 = 1 + x\n>>> expr2\nx + 1\n>>> expr2.is_number\nFalse\n>>> expr2.evalf()\nx + 1.0 \n```", "```py\n>>> from sympy import Function\n>>> from sympy.core.logic import fuzzy_and, fuzzy_or\n>>>\n>>> class expreal(Function):\n...  \"\"\"exponential function E**x restricted to the extended reals\"\"\"\n...\n...     is_extended_nonnegative = True\n...\n...     @classmethod\n...     def eval(cls, x):\n...         # Validate the argument\n...         if x.is_extended_real is False:\n...             raise ValueError(\"non-real argument to expreal\")\n...         # Evaluate for special values\n...         if x.is_zero:\n...             return S.One\n...         elif x.is_infinite:\n...             if x.is_extended_negative:\n...                 return S.Zero\n...             elif x.is_extended_positive:\n...                 return S.Infinity\n...\n...     @property\n...     def x(self):\n...         return self.args[0]\n...\n...     def _eval_is_finite(self):\n...         return fuzzy_or([self.x.is_real, self.x.is_extended_nonpositive])\n...\n...     def _eval_is_algebraic(self):\n...         if fuzzy_and([self.x.is_rational, self.x.is_nonzero]):\n...             return False\n...\n...     def _eval_is_integer(self):\n...         if self.x.is_zero:\n...             return True\n...\n...     def _eval_is_zero(self):\n...         return fuzzy_and([self.x.is_infinite, self.x.is_extended_negative]) \n```", "```py\n>>> from sympy import oo\n>>> expreal(1)\nexpreal(1)\n>>> expreal(0)\n1\n>>> expreal(-oo)\n0\n>>> expreal(oo)\noo \n```", "```py\n>>> x = Symbol('x', extended_negative=True, infinite=True)\n>>> x\nx\n>>> expreal(x)\n0 \n```", "```py\n>>> expreal(I)\nTraceback (most recent call last):\n...\nValueError: non-real argument to expreal \n```", "```py\n>>> x = Symbol('x')\n>>> print(x.is_extended_real)\nNone\n>>> expreal(x)\nexpreal(x)\n>>> expr = (1 + I)/sqrt(2) + (1 - I)/sqrt(2)\n>>> print(expr.is_extended_real)\nNone\n>>> expr.expand()\nsqrt(2)\n>>> expr.expand().is_extended_real\nTrue\n>>> expreal(expr)\nexpreal(sqrt(2)*(1 - I)/2 + sqrt(2)*(1 + I)/2) \n```", "```py\n>>> expreal(I, evaluate=False)\nexpreal(I) \n```", "```py\n>>> expreal(2)\nexpreal(2)\n>>> expreal(2).is_finite\nTrue\n>>> expreal(2).is_integer\nFalse\n>>> expreal(2).is_rational\nFalse\n>>> expreal(2).is_algebraic\nFalse\n>>> z = expreal(-oo, evaluate=False)\n>>> z\nexpreal(-oo)\n>>> z.is_integer\nTrue\n>>> x = Symbol('x', real=True)\n>>> expreal(x)\nexpreal(x)\n>>> expreal(x).is_nonnegative\nTrue \n```", "```py\n>>> from sympy.core.assumptions import _assume_rules\n>>> _assume_rules.defined_facts   \n{'algebraic',\n 'antihermitian',\n 'commutative',\n 'complex',\n 'composite',\n 'even',\n ...\n>>> _assume_rules.full_implications   \ndefaultdict(set,\n {('extended_positive', False): {('composite', False),\n ('positive', False),\n ('prime', False)},\n ('finite', False): {('algebraic', False),\n ('complex', False),\n ('composite', False),\n ... \n```", "```py\n>>> from sympy import Expr\n...\n>>> class A(Expr):\n...     is_positive = True\n...\n...     def _eval_is_rational(self):\n...         # Let's print something to see when this method is called...\n...         print('!!! calling _eval_is_rational')\n...         return True\n...\n>>> A.is_positive\nTrue\n>>> A.is_real  # inferred from is_positive\nTrue \n```", "```py\n>>> type(A.default_assumptions)\n<class 'sympy.core.assumptions.StdFactKB'>\n>>> A.default_assumptions\n{'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'real': True,\n 'zero': False} \n```", "```py\n>>> a = A()\n>>> a._assumptions is A.default_assumptions\nTrue\n>>> a.is_rational\n!!! calling _eval_is_rational\nTrue\n>>> a._assumptions is A.default_assumptions\nFalse\n>>> a._assumptions   # rational now shows as True\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'irrational': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False} \n```", "```py\n>>> b = A()\n>>> b.is_algebraic    # called _eval_is_rational indirectly\n!!! calling _eval_is_rational\nTrue\n>>> c = A()\n>>> print(c.is_prime)   # called _eval_is_rational indirectly\n!!! calling _eval_is_rational\nNone\n>>> c._assumptions   # prime now shows as None\n{'algebraic': True,\n 'commutative': True,\n 'complex': True,\n 'extended_negative': False,\n 'extended_nonnegative': True,\n 'extended_nonpositive': False,\n 'extended_nonzero': True,\n 'extended_positive': True,\n 'extended_real': True,\n 'finite': True,\n 'hermitian': True,\n 'imaginary': False,\n 'infinite': False,\n 'irrational': False,\n 'negative': False,\n 'nonnegative': True,\n 'nonpositive': False,\n 'nonzero': True,\n 'positive': True,\n 'prime': None,\n 'rational': True,\n 'real': True,\n 'transcendental': False,\n 'zero': False} \n```", "```py\n>>> x = Symbol('x', integer=True, positive=True)\n>>> x.is_positive\nTrue\n>>> x.is_integer\nTrue \n```", "```py\n>>> fuzzy_and([x.is_positive, x.is_integer])\nTrue\n>>> x.is_positive and x.is_integer\nTrue \n```", "```py\n>>> fuzzy_or([x.is_positive, x.is_integer])\nTrue \n```", "```py\n>>> fuzzy_or([None, None]) \n```"]