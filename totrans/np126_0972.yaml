- en: numpy.isin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.isin.html](https://numpy.org/doc/1.26/reference/generated/numpy.isin.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Calculates `element in test_elements`, broadcasting over *element* only. Returns
    a boolean array of the same shape as *element* that is True where an element of
    *element* is in *test_elements* and False otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**element**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input array.
  prefs: []
  type: TYPE_NORMAL
- en: '**test_elements**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The values against which to test each value of *element*. This argument is flattened
    if it is an array or array_like. See notes for behavior with non-array-like parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**assume_unique**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the input arrays are both assumed to be unique, which can speed up
    the calculation. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: '**invert**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the values in the returned array are inverted, as if calculating *element
    not in test_elements*. Default is False. `np.isin(a, b, invert=True)` is equivalent
    to (but faster than) `np.invert(np.isin(a, b))`.
  prefs: []
  type: TYPE_NORMAL
- en: '**kind**{None, ‘sort’, ‘table’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm to use. This will not affect the final result, but will affect
    the speed and memory use. The default, None, will select automatically based on
    memory considerations.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘sort’, will use a mergesort-based approach. This will have a memory usage
    of roughly 6 times the sum of the sizes of *ar1* and *ar2*, not accounting for
    size of dtypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If ‘table’, will use a lookup table approach similar to a counting sort. This
    is only available for boolean and integer arrays. This will have a memory usage
    of the size of *ar1* plus the max-min value of *ar2*. *assume_unique* has no effect
    when the ‘table’ option is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If None, will automatically choose ‘table’ if the required memory allocation
    is less than or equal to 6 times the sum of the sizes of *ar1* and *ar2*, otherwise
    will use ‘sort’. This is done to not use a large amount of memory by default,
    even though ‘table’ may be faster in most cases. If ‘table’ is chosen, *assume_unique*
    will have no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isin**ndarray, bool'
  prefs: []
  type: TYPE_NORMAL
- en: Has the same shape as *element*. The values *element[isin]* are in *test_elements*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`in1d`](numpy.in1d.html#numpy.in1d "numpy.in1d")'
  prefs: []
  type: TYPE_NORMAL
- en: Flattened version of this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.lib.arraysetops`](numpy.lib.arraysetops.html#module-numpy.lib.arraysetops
    "numpy.lib.arraysetops")'
  prefs: []
  type: TYPE_NORMAL
- en: Module with a number of other functions for performing set operations on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '[`isin`](#numpy.isin "numpy.isin") is an element-wise function version of the
    python keyword *in*. `isin(a, b)` is roughly equivalent to `np.array([item in
    b for item in a])` if *a* and *b* are 1-D sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: '*element* and *test_elements* are converted to arrays if they are not already.
    If *test_elements* is a set (or other non-sequence collection) it will be converted
    to an object array with one element, rather than an array of the values contained
    in *test_elements*. This is a consequence of the [`array`](numpy.array.html#numpy.array
    "numpy.array") constructor’s way of handling non-sequence collections. Converting
    the set to a list usually gives the desired behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `kind=''table''` tends to be faster than *kind=’sort’* if the following
    relationship is true: `log10(len(ar2)) > (log10(max(ar2)-min(ar2)) - 2.27) / 0.927`,
    but may use greater memory. The default value for *kind* will be automatically
    selected based only on memory usage, so one may manually set `kind=''table''`
    if memory constraints can be relaxed.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.13.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The indices of the matched values can be obtained with [`nonzero`](numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The test can also be inverted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of how [`array`](numpy.array.html#numpy.array "numpy.array") handles
    sets, the following does not work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Casting the set to a list gives the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
