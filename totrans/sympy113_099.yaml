- en: Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心
- en: Original text：[https://docs.sympy.org/latest/modules/core.html](https://docs.sympy.org/latest/modules/core.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/modules/core.html](https://docs.sympy.org/latest/modules/core.html)
- en: '## sympify'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## sympify'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Converts an arbitrary expression to a type that can be used inside SymPy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将任意表达式转换为可以在SymPy内部使用的类型。
- en: 'Parameters:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**a :**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**a：**'
- en: any object defined in SymPy
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy中定义的任何对象
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'standard numeric Python types: `int`, `long`, `float`, `Decimal`'
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的数字Python类型：`int`、`long`、`float`、`Decimal`
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: strings (like `"0.09"`, `"2e-19"` or `'sin(x)'`)
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（如`"0.09"`、`"2e-19"`或`'sin(x)'`）
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans, including `None` (will leave `None` unchanged)
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值，包括`None`（将`None`保持不变）
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: dicts, lists, sets or tuples containing any of the above
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含上述任何内容的字典、列表、集合或元组
- en: '**convert_xor** : bool, optional'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**convert_xor**：布尔型，可选'
- en: If true, treats `^` as exponentiation. If False, treats `^` as XOR itself. Used
    only when input is a string.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为真，则将`^`视为指数运算。如果为假，则将`^`视为XOR本身。仅在输入为字符串时使用。
- en: '**locals** : any object defined in SymPy, optional'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**locals**：SymPy中定义的任何对象，可选'
- en: In order to have strings be recognized it can be imported into a namespace dictionary
    and passed as locals.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使字符串被识别，可以导入到命名空间字典中并作为本地传递。
- en: '**strict** : bool, optional'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**strict**：布尔型，可选'
- en: If the option strict is set to `True`, only the types for which an explicit
    conversion has been defined are converted. In the other cases, a SympifyError
    is raised.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果严格选项设置为`True`，则仅对已定义显式转换的类型进行转换。在其他情况下，将引发`SympifyError`。
- en: '**rational** : bool, optional'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**rational**：布尔型，可选'
- en: If `True`, converts floats into [`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational").
    If `False`, it lets floats remain as it is. Used only when input is a string.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为`True`，则将浮点数转换为[`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational")。如果为`False`，则让浮点数保持原样。仅在输入为字符串时使用。
- en: '**evaluate** : bool, optional'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**evaluate**：布尔型，可选'
- en: If False, then arithmetic and operators will be converted into their SymPy equivalents.
    If True the expression will be evaluated and the result will be returned.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为False，则算术和运算符将转换为它们的SymPy等效项。如果为True，则将评估表达式并返回结果。
- en: Explanation
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: It will convert Python ints into instances of [`Integer`](#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), floats into instances of [`Float`](#sympy.core.numbers.Float
    "sympy.core.numbers.Float"), etc. It is also able to coerce symbolic expressions
    which inherit from [`Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic").
    This can be useful in cooperation with SAGE.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它将Python整数转换为[`Integer`](#sympy.core.numbers.Integer "sympy.core.numbers.Integer")的实例，浮点数转换为[`Float`](#sympy.core.numbers.Float
    "sympy.core.numbers.Float")的实例等。它还能够强制转换从[`Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic")继承的符号表达式。这在与SAGE合作时非常有用。
- en: Warning
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Note that this function uses `eval`, and thus shouldn’t be used on unsanitized
    input.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数使用`eval`，因此不应用于未经过滤的输入。
- en: If the argument is already a type that SymPy understands, it will do nothing
    but return that value. This can be used at the beginning of a function to ensure
    you are working with the correct type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数已经是SymPy理解的类型，则不会执行任何操作，只会返回该值。这可以用于函数开始时确保使用正确的类型。
- en: Examples
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the expression could not be converted, a SympifyError is raised.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法转换表达式，则会引发`SympifyError`。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When attempting to parse non-Python syntax using `sympify`, it raises a `SympifyError`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用`sympify`解析非Python语法时，会引发`SympifyError`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To parse non-Python syntax, use `parse_expr` from `sympy.parsing.sympy_parser`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析非Python语法，请使用`sympy.parsing.sympy_parser`中的`parse_expr`。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For more details about `transformations`: see [`parse_expr()`](parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`transformations`的更多详细信息，请参见[`parse_expr()`](parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")
- en: Locals
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本地
- en: 'The sympification happens with access to everything that is loaded by `from
    sympy import *`; anything used in a string that is not defined by that import
    will be converted to a symbol. In the following, the `bitcount` function is treated
    as a symbol and the `O` is interpreted as the [`Order`](series/series.html#sympy.series.order.Order
    "sympy.series.order.Order") object (used with series) and it raises an error when
    used improperly:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: sympify发生时可以访问通过`from sympy import *`加载的所有内容；在字符串中使用的任何未由该导入定义的内容都将转换为符号。在以下示例中，`bitcount`函数被视为符号，`O`被解释为[`Order`](series/series.html#sympy.series.order.Order
    "sympy.series.order.Order")对象（与级数一起使用），在错误使用时将引发错误：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to have `bitcount` be recognized it can be imported into a namespace
    dictionary and passed as locals:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`bitcount`被识别，可以将其导入到命名空间字典中，并作为局部变量传递：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to have the `O` interpreted as a Symbol, identify it as such in the
    namespace dictionary. This can be done in a variety of ways; all three of the
    following are possibilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`O`解释为符号，在命名空间字典中将其标识为符号。有多种方法可以做到这一点；以下三种都是可能的方式：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want *all* single-letter and Greek-letter variables to be symbols then
    you can use the clashing-symbols dictionaries that have been defined there as
    private variables: `_clash1` (single-letter variables), `_clash2` (the multi-letter
    Greek names) or `_clash` (both single and multi-letter names that are defined
    in `abc`).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望*所有*单字母和希腊字母变量都是符号，那么可以使用那里定义的冲突符号字典作为私有变量： `_clash1`（单字母变量）， `_clash2`（多字母希腊名称）或
    `_clash`（在`abc`中定义的单字母和多字母名称）。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Strict
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 严格
- en: If the option `strict` is set to `True`, only the types for which an explicit
    conversion has been defined are converted. In the other cases, a SympifyError
    is raised.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选项`strict`设置为`True`，则仅转换已定义显式转换的类型。在其他情况下，将引发SympifyError。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Deprecated since version 1.6: `sympify(obj)` automatically falls back to `str(obj)`
    when all other conversion methods fail, but this is deprecated. `strict=True`
    will disable this deprecated behavior. See [The string fallback in sympify()](../explanation/active-deprecations.html#deprecated-sympify-string-fallback).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.6起弃用：当所有其他转换方法失败时，`sympify(obj)`自动退回到`str(obj)`，但这已被弃用。`strict=True`将禁用此弃用行为。请参阅[在sympify()中的字符串回退](../explanation/active-deprecations.html#deprecated-sympify-string-fallback)。
- en: Evaluation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: If the option `evaluate` is set to `False`, then arithmetic and operators will
    be converted into their SymPy equivalents and the `evaluate=False` option will
    be added. Nested `Add` or `Mul` will be denested first. This is done via an AST
    transformation that replaces operators with their SymPy equivalents, so if an
    operand redefines any of those operations, the redefined operators will not be
    used. If argument a is not a string, the mathematical expression is evaluated
    before being passed to sympify, so adding `evaluate=False` will still return the
    evaluated result of expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选项`evaluate`设置为`False`，则算术和运算符将转换为它们的SymPy等效项，并添加`evaluate=False`选项。嵌套的`Add`或`Mul`将首先解嵌套。这通过AST转换完成，替换运算符为它们的SymPy等效项，因此如果操作数重新定义任何这些操作，则不会使用重新定义的运算符。如果参数a不是字符串，则在传递给sympify之前对数学表达式进行评估，因此添加`evaluate=False`仍将返回表达式的评估结果。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Extending
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展
- en: To extend `sympify` to convert custom objects (not derived from `Basic`), just
    define a `_sympy_` method to your class. You can do that even to classes that
    you do not own by subclassing or adding the method at runtime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`sympify`扩展为转换自定义对象（不是从`Basic`派生），只需为您的类定义一个`_sympy_`方法。即使是对您不拥有的类也可以通过子类化或在运行时添加该方法来完成。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you do not have control over the class definition you could also use the
    `converter` global dictionary. The key is the class and the value is a function
    that takes a single argument and returns the desired SymPy object, e.g. `converter[MyList]
    = lambda x: Matrix(x)`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您无法控制类定义，也可以使用全局字典`converter`。键是类，值是一个接受单个参数并返回所需SymPy对象的函数，例如`converter[MyList]
    = lambda x: Matrix(x)`。'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notes
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The keywords `rational` and `convert_xor` are only used when the input is a
    string.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入为字符串时，关键字`rational`和`convert_xor`仅在使用时使用。
- en: Convert_xor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Convert_xor
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Rational
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sometimes autosimplification during sympification results in expressions that
    are very different in structure than what was entered. Until such autosimplification
    is no longer done, the `kernS` function might be of some use. In the example below
    you can see how an expression reduces to \(-1\) by autosimplification, but does
    not do so when `kernS` is used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在sympification期间的自动简化会导致表达式在结构上与输入时大不相同。直到不再进行此类自动简化为止，`kernS`函数可能有些用处。在下面的示例中，您可以看到如何通过使用`kernS`来将表达式简化为\(-1\)，而在自动简化时则不会这样做。
- en: '[PRE17]  ## assumptions'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]  ## 假设'
- en: This module contains the machinery handling assumptions. Do also consider the
    guide [Assumptions](../guides/assumptions.html#assumptions-guide).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块包含处理假设的机制。还请考虑指南[假设](../guides/assumptions.html#assumptions-guide)。
- en: All symbolic objects have assumption attributes that can be accessed via `.is_<assumption
    name>` attribute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有符号对象都有假设属性，可以通过`.is_<assumption name>`属性访问。
- en: 'Assumptions determine certain properties of symbolic objects and can have 3
    possible values: `True`, `False`, `None`. `True` is returned if the object has
    the property and `False` is returned if it does not or cannot (i.e. does not make
    sense):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设确定符号对象的某些属性，并且可能有3个可能的值：`True`、`False`、`None`。如果对象具有该属性，则返回 `True`，如果不具有或不能确定（即不合适），则返回
    `False`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the property cannot be determined (or when a method is not implemented)
    `None` will be returned. For example, a generic symbol, `x`, may or may not be
    positive so a value of `None` is returned for `x.is_positive`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性无法确定（或者方法未实现）时，将返回 `None`。例如，一个通用符号 `x` 可能是正数也可能不是，因此对于 `x.is_positive` 返回
    `None`。
- en: By default, all symbolic values are in the largest set in the given context
    without specifying the property. For example, a symbol that has a property being
    integer, is also real, complex, etc.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有符号值都属于给定上下文中最大的集合，而不指定属性。例如，具有整数属性的符号也是实数、复数等。
- en: 'Here follows a list of possible assumption names:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的假设名称列表：
- en: commutative
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可交换的
- en: object commutes with any other object with respect to multiplication operation.
    See [[12]](#id16).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在乘法操作中与任何其他对象都是可交换的。参见 [[12]](#id16)。
- en: complex
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: complex
- en: object can have only values from the set of complex numbers. See [[13]](#id17).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取复数集合中的值。参见 [[13]](#id17)。
- en: imaginary
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虚数
- en: 'object value is a number that can be written as a real number multiplied by
    the imaginary unit `I`. See [[R112]](#r112). Please note that `0` is not considered
    to be an imaginary number, see [issue #7649](https://github.com/sympy/sympy/issues/7649).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '对象的值是可以写成实数乘以虚数单位 `I` 的数。参见 [[R112]](#r112)。请注意，`0` 不被视为虚数，请参见 [issue #7649](https://github.com/sympy/sympy/issues/7649)。'
- en: real
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实数
- en: object can have only values from the set of real numbers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取实数集合中的值。
- en: extended_real
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: extended_real
- en: object can have only values from the set of real numbers, `oo` and `-oo`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取实数、`oo` 和 `-oo` 集合中的值。
- en: integer
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: object can have only values from the set of integers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取整数集合中的值。
- en: odd
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数
- en: even
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 偶数
- en: object can have only values from the set of odd (even) integers [[R111]](#r111).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取奇（偶）整数集合中的值 [[R111]](#r111)。
- en: prime
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 质数
- en: object is a natural number greater than 1 that has no positive divisors other
    than 1 and itself. See [[R115]](#r115).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一个大于1且没有除了1和自身以外正除数的自然数。参见 [[R115]](#r115)。
- en: composite
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 复合数
- en: object is a positive integer that has at least one positive divisor other than
    1 or the number itself. See [[R113]](#r113).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一个正整数，至少有一个除了1或该数本身以外的正除数。参见 [[R113]](#r113)。
- en: zero
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: zero
- en: object has the value of 0.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的值为0。
- en: nonzero
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 非零
- en: object is a real number that is not zero.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一个非零的实数。
- en: rational
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数
- en: object can have only values from the set of rationals.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取有理数集合中的值。
- en: algebraic
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: algebraic
- en: object can have only values from the set of algebraic numbers [[11]](#id15).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取代数数集合中的值 [[11]](#id15)。
- en: transcendental
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 超越数
- en: object can have only values from the set of transcendental numbers [[10]](#id14).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取超越数集合中的值 [[10]](#id14)。
- en: irrational
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 无理数
- en: object value cannot be represented exactly by [`Rational`](#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational"), see [[R114]](#r114).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的值不能用 [`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational")
    精确表示，参见 [[R114]](#r114)。
- en: finite
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有限的
- en: infinite
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无穷大
- en: object absolute value is bounded (arbitrarily large). See [[R116]](#r116), [[R117]](#r117),
    [[R118]](#r118).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的绝对值是有界的（任意大）。参见 [[R116]](#r116)、[[R117]](#r117)、[[R118]](#r118)。
- en: negative
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 负数
- en: nonnegative
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 非负数
- en: object can have only negative (nonnegative) values [[R110]](#r110).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取负（非负）值 [[R110]](#r110)。
- en: positive
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正数
- en: nonpositive
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: nonpositive
- en: object can have only positive (nonpositive) values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对象只能取正（非正）值。
- en: extended_negative
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: extended_negative
- en: extended_nonnegative
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: extended_nonnegative
- en: extended_positive
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: extended_positive
- en: extended_nonpositive
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: extended_nonpositive
- en: extended_nonzero
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: extended_nonzero
- en: as without the extended part, but also including infinity with corresponding
    sign, e.g., extended_positive includes `oo`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与没有扩展部分相同，但也包括具有相应符号的无穷大，例如，extended_positive 包括 `oo`
- en: hermitian
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Hermite
- en: antihermitian
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 反埃尔米特
- en: object belongs to the field of Hermitian (antihermitian) operators.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属于埃尔米特（反埃尔米特）算子的领域。
- en: Examples
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See Also
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参见
- en: See also
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.numbers.ImaginaryUnit`](#sympy.core.numbers.ImaginaryUnit "sympy.core.numbers.ImaginaryUnit")
    [`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero "sympy.core.numbers.Zero")
    [`sympy.core.numbers.One`](#sympy.core.numbers.One "sympy.core.numbers.One") [`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity
    "sympy.core.numbers.Infinity") [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity
    "sympy.core.numbers.NegativeInfinity") [`sympy.core.numbers.ComplexInfinity`](#sympy.core.numbers.ComplexInfinity
    "sympy.core.numbers.ComplexInfinity")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.numbers.ImaginaryUnit`](#sympy.core.numbers.ImaginaryUnit "sympy.core.numbers.ImaginaryUnit")
    [`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero "sympy.core.numbers.Zero")
    [`sympy.core.numbers.One`](#sympy.core.numbers.One "sympy.core.numbers.One") [`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity
    "sympy.core.numbers.Infinity") [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity
    "sympy.core.numbers.NegativeInfinity") [`sympy.core.numbers.ComplexInfinity`](#sympy.core.numbers.ComplexInfinity
    "sympy.core.numbers.ComplexInfinity")'
- en: Notes
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'The fully-resolved assumptions for any SymPy expression can be obtained as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 任何SymPy表达式的完全解析假设可以按如下方式获取：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Developers Notes
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者注意事项
- en: The current (and possibly incomplete) values are stored in the `obj._assumptions
    dictionary`; queries to getter methods (with property decorators) or attributes
    of objects/classes will return values and update the dictionary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当前（可能是不完整的）值存储在`obj._assumptions dictionary`中；访问对象/类的属性或属性方法的查询将返回值并更新字典。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For a [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"), there
    are two locations for assumptions that may be of interest. The `assumptions0`
    attribute gives the full set of assumptions derived from a given set of initial
    assumptions. The latter assumptions are stored as `Symbol._assumptions_orig`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")，可能感兴趣的假设有两个位置。`assumptions0`属性给出从给定初始假设导出的完整假设集。后者的假设存储在`Symbol._assumptions_orig`中。
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `_assumptions_orig` are not necessarily canonical nor are they filtered
    in any way: they records the assumptions used to instantiate a Symbol and (for
    storage purposes) represent a more compact representation of the assumptions needed
    to recreate the full set in `Symbol.assumptions0`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`_assumptions_orig` 不一定是规范化的，也没有经过任何过滤：它记录了用于实例化符号的假设，并（为了存储目的）表示需要重建符号的全部假设的更紧凑表示形式。'
- en: References
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R110](#id13)]'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R110](#id13)]'
- en: '[https://en.wikipedia.org/wiki/Negative_number](https://en.wikipedia.org/wiki/Negative_number)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Negative_number](https://en.wikipedia.org/wiki/Negative_number)'
- en: '[[R111](#id4)]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R111](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Parity_%28mathematics%29](https://en.wikipedia.org/wiki/Parity_%28mathematics%29)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Parity_%28mathematics%29](https://en.wikipedia.org/wiki/Parity_%28mathematics%29)'
- en: '[[R112](#id3)]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R112](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Imaginary_number](https://en.wikipedia.org/wiki/Imaginary_number)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Imaginary_number](https://en.wikipedia.org/wiki/Imaginary_number)'
- en: '[[R113](#id6)]'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R113](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Composite_number](https://en.wikipedia.org/wiki/Composite_number)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Composite_number](https://en.wikipedia.org/wiki/Composite_number)'
- en: '[[R114](#id9)]'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R114](#id9)]'
- en: '[https://en.wikipedia.org/wiki/Irrational_number](https://en.wikipedia.org/wiki/Irrational_number)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Irrational_number](https://en.wikipedia.org/wiki/Irrational_number)'
- en: '[[R115](#id5)]'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R115](#id5)]'
- en: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
- en: '[[R116](#id10)]'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R116](#id10)]'
- en: '[https://en.wikipedia.org/wiki/Finite](https://en.wikipedia.org/wiki/Finite)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Finite](https://en.wikipedia.org/wiki/Finite)'
- en: '[[R117](#id11)]'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R117](#id11)]'
- en: '[https://docs.python.org/3/library/math.html#math.isfinite](https://docs.python.org/3/library/math.html#math.isfinite)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/math.html#math.isfinite](https://docs.python.org/3/library/math.html#math.isfinite)'
- en: '[[R118](#id12)]'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R118](#id12)]'
- en: '[https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html](https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html)  ##
    cache'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html](https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html)  ##
    缓存'
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: caching decorator.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存装饰器。
- en: 'important: the result of cached function must be *immutable*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：缓存函数的结果必须是*不可变的*
- en: Examples
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'to force cacheit to check returned results mutability and consistency, set
    environment variable SYMPY_USE_CACHE to ‘debug’  ## basic'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '要强制`cacheit`检查返回结果的可变性和一致性，请将环境变量`SYMPY_USE_CACHE`设置为‘debug’  ## 基本'
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Base class for all SymPy objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有SymPy对象的基类。
- en: Notes And Conventions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注释与约定
- en: 'Always use `.args`, when accessing parameters of some instance:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当访问某个实例的参数时，始终使用`.args`：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Never use internal methods or variables (the ones prefixed with `_`):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要使用内部方法或变量（以`_`为前缀的那些）：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By “SymPy object” we mean something that can be returned by `sympify`. But
    not all objects one encounters using SymPy are subclasses of Basic. For example,
    mutable objects are not:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过“SymPy 对象”，我们指的是可以由`sympify`返回的东西。但并非所有使用 SymPy 遇到的对象都是 Basic 的子类。例如，可变对象不是：
- en: '[PRE33]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Returns a tuple of arguments of ‘self’.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 返回‘self’的参数的元组。
- en: Examples
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notes
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Never use self._args, always use self.args. Only use _args in __new__ when creating
    a new function. Do not override .args() from Basic (so that it is easy to change
    the interface in the future if needed).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用 self._args，总是使用 self.args。只有在创建新函数时，在 __new__ 中使用 _args。不要覆盖 Basic 的
    .args()（以便在需要时容易更改接口）。
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A stub to allow Basic args (like Tuple) to be skipped when computing the content
    and primitive components of an expression.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存根，允许在计算表达式的内容和基本组成部分时跳过 Basic args（如 Tuple）。
- en: See also
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.expr.Expr.as_content_primitive`](#sympy.core.expr.Expr.as_content_primitive
    "sympy.core.expr.Expr.as_content_primitive")'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.expr.Expr.as_content_primitive`](#sympy.core.expr.Expr.as_content_primitive
    "sympy.core.expr.Expr.as_content_primitive")'
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Return the expression with any objects having structurally bound symbols replaced
    with unique, canonical symbols within the object in which they appear and having
    only the default assumption for commutativity being True. When applied to a symbol
    a new symbol having only the same commutativity will be returned.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表达式，其中具有结构绑定符号的任何对象都被替换为该对象中唯一的、规范的符号，并且仅具有默认的交换性假设为 True。当应用于符号时，将返回一个具有相同交换性的新符号。
- en: Examples
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notes
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: Any object that has structurally bound variables should have a property, \(bound_symbols\)
    that returns those symbols appearing in the object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有结构绑定变量的对象应该有一个属性，\(bound_symbols\)，返回出现在对象中的那些符号。
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Return object \(type\) assumptions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象 \(type\) 的假设。
- en: 'For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: Symbol(‘x’, real=True) Symbol(‘x’, integer=True)
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Symbol('x', real=True) Symbol('x', integer=True)
- en: are different objects. In other words, besides Python type (Symbol in this case),
    the initial assumptions are also forming their typeinfo.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 是不同的对象。换句话说，除了 Python 类型（本例中为 Symbol）之外，初始假设也形成它们的类型信息。
- en: Examples
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Returns the atoms that form the current object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 返回形成当前对象的原子。
- en: 'By default, only objects that are truly atomic and cannot be divided into smaller
    pieces are returned: symbols, numbers, and number symbols like I and pi. It is
    possible to request atoms of any type, however, as demonstrated below.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，仅返回真正原子且不能分解为更小部分的对象：符号、数字和诸如 I 和 pi 之类的数字符号。但是，可以请求任何类型的原子，如下所示。
- en: Examples
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If one or more types are given, the results will contain only those types of
    atoms.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出了一个或多个类型，则结果将仅包含那些类型的原子。
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that I (imaginary unit) and zoo (complex infinity) are special types of
    number symbols and are not part of the NumberSymbol class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，I（虚数单位）和 zoo（复杂无穷大）是特殊类型的数字符号，不属于 NumberSymbol 类。
- en: 'The type can be given implicitly, too:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以隐式地给出类型：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Be careful to check your assumptions when using the implicit option since `S(1).is_Integer
    = True` but `type(S(1))` is `One`, a special type of SymPy atom, while `type(S(2))`
    is type `Integer` and will find all integers in an expression:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐式选项时，请检查您的假设。例如，`S(1).is_Integer = True`，但`type(S(1))`是`One`，SymPy 原子的特殊类型，而`type(S(2))`是`Integer`类型，并将在表达式中找到所有整数：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, arguments to atoms() can select more than atomic atoms: any SymPy
    type (loaded in core/__init__.py) can be listed as an argument and those types
    of “atoms” as found in scanning the arguments of the expression recursively:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，atoms() 的参数可以选择超出原子的原子：可以列出任何 SymPy 类型（加载在 core/__init__.py 中），并且在递归扫描表达式参数时找到那些类型的“原子”：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Return a dictionary mapping any variable defined in `self.bound_symbols` to
    Symbols that do not clash with any free symbols in the expression.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个字典，将定义在 `self.bound_symbols` 中的任何变量映射到表达式中不与任何自由符号冲突的符号。
- en: Examples
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Nice order of classes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类的良好顺序。
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Return -1, 0, 1 if the object is less than, equal, or greater than other in
    a canonical sense. Non-Basic are always greater than Basic. If both names of the
    classes being compared appear in the \(ordering_of_classes\) then the ordering
    will depend on the appearance of the names there. If either does not appear in
    that list, then the comparison is based on the class name. If the names are the
    same then a comparison is made on the length of the hashable content. Items of
    the equal-lengthed contents are then successively compared using the same rules.
    If there is never a difference then 0 is returned.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象在规范意义上小于、等于或大于其他对象，则返回-1、0、1。非Basic总是大于Basic。如果比较的类名都出现在\(ordering_of_classes\)中，则比较将取决于它们在该列表中的出现顺序。如果其中任何一个不出现在该列表中，则基于类名进行比较。如果类名相同，则基于可散列内容的长度进行比较。相同长度的内容项目然后按照相同规则依次比较。如果从未有过差异，则返回0。
- en: Examples
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Count the number of matching subexpressions.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 统计匹配子表达式的数量。
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Wrapper for count_ops that returns the operation count.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: count_ops的包装器，返回操作计数。
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Evaluate objects that are not evaluated by default like limits, integrals, sums
    and products. All objects of this kind will be evaluated recursively, unless some
    species were excluded via ‘hints’ or unless the ‘deep’ hint was set to ‘False’.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 评估默认情况下不评估的对象，如限制、积分、求和和乘积。所有这类对象将被递归评估，除非通过'hints'排除了某些类型，或者除非设置了'deep'提示为'False'。
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Compare two expressions and handle dummy symbols.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个表达式并处理虚拟符号。
- en: Examples
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE70]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Find all subexpressions matching a query.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 找到所有与查询匹配的子表达式。
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Return from the atoms of self those which are free symbols.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 从self的原子中返回那些是自由符号。
- en: 'Not all free symbols are `Symbol`. Eg: IndexedBase(‘I’)[0].free_symbols'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的自由符号都是Symbol。例如：IndexedBase('I')[0].free_symbols
- en: For most expressions, all symbols are free symbols. For some classes this is
    not true. e.g. Integrals use Symbols for the dummy variables which are bound variables,
    so Integral has a method to return all symbols except those. Derivative keeps
    track of symbols with respect to which it will perform a derivative; those are
    bound variables, too, so it has its own free_symbols method.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数表达式，所有符号都是自由符号。对于某些类，情况并非如此。例如，积分使用作为绑定变量的符号，因此积分有一个方法可以返回除这些符号外的所有符号。导数还跟踪它将执行导数的符号；这些也是绑定变量，因此它有自己的free_symbols方法。
- en: Any other method that uses bound variables should implement a free_symbols method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用绑定变量的其他方法都应实现一个free_symbols方法。
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Create a new object from an iterable.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从可迭代对象创建一个新对象。
- en: This is a convenience function that allows one to create objects from any iterable,
    without having to convert to a list or tuple first.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个便利函数，允许从任何可迭代对象创建对象，而无需首先转换为列表或元组。
- en: Examples
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The top-level function in an expression.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的顶级函数。
- en: 'The following should hold for all objects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有对象，应该满足以下条件：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Examples
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE80]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Test whether any subexpression matches any of the patterns.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是否有任何子表达式与任何模式匹配。
- en: Examples
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE82]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Note `has` is a structural algorithm with no knowledge of mathematics. Consider
    the following half-open interval:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`has`是一个结构算法，不涉及数学知识。考虑以下半开区间：
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Instead, use `contains` to determine whether a number is in the interval or
    not:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用`contains`来确定一个数字是否在区间内：
- en: '[PRE84]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that `expr.has(*patterns)` is exactly equivalent to `any(expr.has(p) for
    p in patterns)`. In particular, `False` is returned when the list of patterns
    is empty.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`expr.has(*patterns)`与`any(expr.has(p) for p in patterns)`完全等效。特别是当模式列表为空时返回`False`。
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Return True if self has object(s) `x` as a free expression else False.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self作为自由表达式具有对象x，则返回True，否则返回False。
- en: Examples
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE87]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This works for subexpressions and types, too:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于子表达式和类型：
- en: '[PRE88]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Return True if self has any of the patterns in s as a free argument, else False.
    This is like \(Basic.has_free\) but this will only report exact argument matches.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self的任何模式作为自由参数存在，则返回True，否则返回False。这类似于\(Basic.has_free\)，但只会报告精确的参数匹配。
- en: Examples
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE90]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Return True if self can be computed to a real number (or already is a real number)
    with precision, else False.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self可以计算为实数（或已经是实数），则返回True，否则返回False。
- en: Examples
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE92]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'A False result does not mean that \(self\) cannot be rewritten into a form
    that would be comparable. For example, the difference computed below is zero but
    without simplification it does not evaluate to a zero with precision:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 结果错误并不意味着 \(self\) 不能重写成一个可比较的形式。例如，下面计算的差异为零，但在简化之前不能精确计算为零：
- en: '[PRE93]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Return True if a and b are structurally the same, else False. If \(approx\)
    is supplied, it will be used to test whether two numbers are the same or not.
    By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `approx` 被提供，则返回 True，如果 a 和 b 在结构上相同，否则返回 False。默认情况下，只有相同类型的数字才会比较相等，因此
    S.Half != Float(0.5)。
- en: Examples
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'In SymPy (unlike Python) two numbers do not compare the same if they are not
    of the same type:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中（不像 Python），如果两个数字的类型不同，则它们不会比较相同：
- en: '[PRE95]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: By supplying a function with which to compare two numbers, such differences
    can be ignored. e.g. \(equal_valued\) will return True for decimal numbers having
    a denominator that is a power of 2, regardless of precision.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个比较两个数字的函数，可以忽略这样的差异。例如，`equal_valued` 将为具有2的次幂分母的十进制数返回 True，而不考虑精度。
- en: '[PRE96]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: But decimals without a power of 2 denominator will compare as not being the
    same.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，没有2的次幂分母的十进制数将比较为不相同。
- en: '[PRE97]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'But arbitrary differences can be ignored by supplying a function to test the
    equivalence of two numbers:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但是可以通过提供一个函数来忽略任意差异，以测试两个数字的等价性：
- en: '[PRE98]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Other objects might compare the same even though types are not the same. This
    routine will only return True if two expressions are identical in terms of class
    types.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 即使类型不同，其他对象可能会比较相同。此例程仅在两个表达式在类类型上完全相同时返回 True。
- en: '[PRE99]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Pattern matching.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配。
- en: Wild symbols match all.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符匹配全部。
- en: 'Return `None` when expression (self) does not match with pattern. Otherwise
    return a dictionary such that:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式（self）与模式不匹配时返回 `None`。否则返回一个字典，如下所示：
- en: '[PRE101]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Examples
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE102]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Structurally bound symbols are ignored during matching:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结构绑定符号在匹配过程中被忽略：
- en: '[PRE103]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'But they can be identified if desired:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果需要的话，它们可以被识别出来：
- en: '[PRE104]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `old` flag will give the old-style pattern matching where expressions and
    patterns are essentially solved to give the match. Both of the following give
    None unless `old=True`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`old` 标志将提供旧式模式匹配，在这种匹配中，表达式和模式本质上是为了给出匹配而解决的。除非 `old=True`，否则以下两个都会返回 None：'
- en: '[PRE105]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Helper method for match() that looks for a match between Wild symbols in self
    and expressions in expr.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `self` 和 `expr` 中的通配符匹配的帮助方法。
- en: Examples
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE107]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Apply on the argument recursively through the expression tree.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地应用于表达式树中的参数。
- en: 'This method is used to simulate a common abuse of notation for operators. For
    instance, in SymPy the following will not work:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法用于模拟操作符的常见滥用符号。例如，在 SymPy 中，以下内容将无法工作：
- en: '`(x+Lambda(y, 2*y))(z) == x+2*z`,'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`(x+Lambda(y, 2*y))(z) == x+2*z`,'
- en: 'however, you can use:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以使用：
- en: '[PRE109]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See the refine function in sympy.assumptions
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见 sympy.assumptions 中的 refine 函数。
- en: '[PRE111]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Replace matching subexpressions of `self` with `value`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 用`value`替换`self`中匹配的子表达式。
- en: 'If `map = True` then also return the mapping {old: new} where `old` was a sub-expression
    found with query and `new` is the replacement value for it. If the expression
    itself does not match the query, then the returned value will be `self.xreplace(map)`
    otherwise it should be `self.subs(ordered(map.items()))`.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `map = True`，则还返回映射 {old: new}，其中 `old` 是通过查询找到的子表达式，`new` 是其替换值。如果表达式本身与查询不匹配，则返回的值将是
    `self.xreplace(map)`，否则应该是 `self.subs(ordered(map.items()))`。'
- en: Traverses an expression tree and performs replacement of matching subexpressions
    from the bottom to the top of the tree. The default approach is to do the replacement
    in a simultaneous fashion so changes made are targeted only once. If this is not
    desired or causes problems, `simultaneous` can be set to False.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历表达式树并从树底部到树顶部执行匹配子表达式的替换。默认方法是同时进行替换，因此所做的更改仅针对一次。如果不希望或引起问题，则可以将 `simultaneous`
    设置为 False。
- en: In addition, if an expression containing more than one Wild symbol is being
    used to match subexpressions and the `exact` flag is None it will be set to True
    so the match will only succeed if all non-zero values are received for each Wild
    that appears in the match pattern. Setting this to False accepts a match of 0;
    while setting it True accepts all matches that have a 0 in them. See example below
    for cautions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果使用包含多个通配符号的表达式来匹配子表达式，并且 `exact` 标志为 None，则将其设置为 True，因此仅当每个出现在匹配模式中的通配符都收到非零值时，匹配才会成功。将其设置为
    False 接受匹配 0；而设置为 True 则接受所有具有 0 的匹配。有关注意事项，请参见下面的示例。
- en: 'The list of possible combinations of queries and replacement values is listed
    below:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了查询和替换值的可能组合列表：
- en: Examples
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: Initial setup
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置
- en: '[PRE112]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 1.1\. type -> type
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1\. 类型 -> 类型
- en: obj.replace(type, newtype)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: obj.replace(type, newtype)
- en: When object of type `type` is found, replace it with the result of passing its
    argument(s) to `newtype`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到类型为 `type` 的对象时，用其参数传递给 `newtype` 的结果替换它。
- en: '[PRE113]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 1.2\. type -> func
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2\. 类型 -> 函数
- en: obj.replace(type, func)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: obj.replace(type, func)
- en: When object of type `type` is found, apply `func` to its argument(s). `func`
    must be written to handle the number of arguments of `type`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到类型为 `type` 的对象时，将 `func` 应用于其参数。 `func` 必须编写以处理 `type` 的参数数量。
- en: '[PRE114]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 2.1\. pattern -> expr
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1\. 模式 -> 表达式
- en: obj.replace(pattern(wild), expr(wild))
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: obj.replace(pattern(wild), expr(wild))
- en: Replace subexpressions matching `pattern` with the expression written in terms
    of the Wild symbols in `pattern`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有通配符号的 `pattern` 替换子表达式为表达式。
- en: '[PRE115]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Matching is exact by default when more than one Wild symbol is used: matching
    fails unless the match gives non-zero values for all Wild symbols:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当使用多个通配符号进行匹配时，匹配是精确的：除非匹配对所有通配符号都给出非零值，否则匹配失败：
- en: '[PRE116]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'When set to False, the results may be non-intuitive:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为 False 时，结果可能不直观：
- en: '[PRE117]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 2.2\. pattern -> func
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2\. 模式 -> 函数
- en: 'obj.replace(pattern(wild), lambda wild: expr(wild))'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'obj.replace(pattern(wild), lambda wild: expr(wild))'
- en: 'All behavior is the same as in 2.1 but now a function in terms of pattern variables
    is used rather than an expression:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 所有行为与 2.1 中相同，但现在使用的是基于模式变量的函数而不是表达式：
- en: '[PRE118]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 3.1\. func -> func
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1\. 函数 -> 函数
- en: obj.replace(filter, func)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: obj.replace(filter, func)
- en: Replace subexpression `e` with `func(e)` if `filter(e)` is True.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `filter(e)` 为真，则用 `func(e)` 替换子表达式 `e`。
- en: '[PRE119]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The expression itself is also targeted by the query but is done in such a fashion
    that changes are not made twice.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身也是目标表达式的目标，但是以不做两次更改的方式进行。
- en: '[PRE120]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'When matching a single symbol, \(exact\) will default to True, but this may
    or may not be the behavior that is desired:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配单个符号时，\(exact\) 默认为 True，但这可能或可能不是所需的行为：
- en: 'Here, we want \(exact=False\):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望 \(exact=False\)：
- en: '[PRE121]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'But here, the nature of matching makes selecting the right setting tricky:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，匹配的性质使得选择正确的设置变得棘手：
- en: '[PRE122]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'It is probably better to use a different form of the query that describes the
    target expression more precisely:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用描述目标表达式更精确的查询形式：
- en: '[PRE123]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: See also
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
- en: substitution of subexpressions as defined by the objects themselves.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 替换由对象本身定义的子表达式。
- en: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
- en: exact node replacement in expr tree; also capable of using matching rules
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达树中进行精确的节点替换；还能够使用匹配规则
- en: '[PRE124]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Rewrite *self* using a defined rule.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义的规则重写 *self*。
- en: Rewriting transforms an expression to another, which is mathematically equivalent
    but structurally different. For example you can rewrite trigonometric functions
    as complex exponentials or combinatorial functions as gamma function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 重写将一个表达式转换为另一个，在数学上是等效的但结构不同的表达式。例如，您可以将三角函数重写为复指数函数或将组合函数重写为伽马函数。
- en: This method takes a *pattern* and a *rule* as positional arguments. *pattern*
    is optional parameter which defines the types of expressions that will be transformed.
    If it is not passed, all possible expressions will be rewritten. *rule* defines
    how the expression will be rewritten.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法采用 *模式* 和 *规则* 作为位置参数。 *模式* 是可选参数，定义将进行转换的表达式类型。如果未传递，则将重新编写所有可能的表达式。 *规则*
    定义如何重新编写表达式。
- en: 'Parameters:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**args** : Expr'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**args** : 表达式'
- en: A *rule*, or *pattern* and *rule*. - *pattern* is a type or an iterable of types.
    - *rule* can be any object.
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 *规则* 或 *模式* 和 *规则*。 - *模式* 是一种类型或可迭代类型。 - *规则* 可以是任何对象。
- en: '**deep** : bool, optional'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**deep** : 布尔值，可选'
- en: If `True`, subexpressions are recursively transformed. Default is `True`.
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为`True`，则子表达式会递归转换。默认为`True`。
- en: Examples
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: If *pattern* is unspecified, all possible expressions are transformed.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定 *pattern*，则将转换所有可能的表达式。
- en: '[PRE125]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Pattern can be a type or an iterable of types.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以是类型或类型的可迭代对象。
- en: '[PRE126]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Rewriting behavior can be implemented by defining `_eval_rewrite()` method.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过定义 `_eval_rewrite()` 方法实现重写行为。
- en: '[PRE127]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Defining `_eval_rewrite_as_[...]()` method is supported for backwards compatibility
    reason. This may be removed in the future and using it is discouraged.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 支持为了向后兼容性原因定义 `_eval_rewrite_as_[...]()` 方法。这可能在将来会被移除，不推荐使用它。
- en: '[PRE128]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: See the simplify function in sympy.simplify
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 simplify 函数
- en: '[PRE130]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Return a sort key.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 返回排序关键字。
- en: Examples
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE131]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Substitutes old for new in an expression after sympifying args.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在 sympify args 之后，在表达式中用 new 替换 old。
- en: '\(args\) is either:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: \(args\) 可能是：
- en: two arguments, e.g. foo.subs(old, new)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个参数，例如 foo.subs(old, new)
- en: one iterable argument, e.g. foo.subs(iterable). The iterable may be
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可迭代的参数，例如 foo.subs(iterable)。可迭代对象可以是
- en: o an iterable container with (old, new) pairs. In this case the
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个可迭代的容器，包含 (old, new) 对。在这种情况下，
- en: replacements are processed in the order given with successive patterns possibly
    affecting replacements already made.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 替换按给定顺序处理，后续模式可能会影响已进行的替换。
- en: o a dict or set whose key/value items correspond to old/new pairs.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个字典或集合，其键/值项对应于旧/新对。
- en: In this case the old/new pairs will be sorted by op count and in case of a tie,
    by number of args and the default_sort_key. The resulting sorted list is then
    processed as an iterable container (see previous).
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，旧/新对将按 op 计数排序，并在平局时按参数数量和默认排序关键字排序。然后处理结果排序后的列表作为可迭代容器（见前述）。
- en: If the keyword `simultaneous` is True, the subexpressions will not be evaluated
    until all the substitutions have been made.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关键字 `simultaneous` 设置为 True，则子表达式将在所有替换完成后再进行评估。
- en: Examples
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE135]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'To replace only the x**2 but not the x**4, use xreplace:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 仅替换 x**2 而不替换 x**4，使用 xreplace：
- en: '[PRE137]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'To delay evaluation until all substitutions have been made, set the keyword
    `simultaneous` to True:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 若要延迟评估直到所有替换完成，请将关键字 `simultaneous` 设置为 True：
- en: '[PRE138]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This has the added feature of not allowing subsequent substitutions to affect
    those already made:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这还具有不允许后续替换影响已进行替换的额外功能：
- en: '[PRE139]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: In order to obtain a canonical result, unordered iterables are sorted by count_op
    length, number of arguments and by the default_sort_key to break any ties. All
    other iterables are left unsorted.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得规范结果，无序可迭代对象会按照长度、参数数量和默认排序关键字进行排序，以打破任何平局。所有其他可迭代对象保持不排序状态。
- en: '[PRE140]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The resulting expression represents a literal replacement of the old arguments
    with the new arguments. This may not reflect the limiting behavior of the expression:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表达式表示旧参数与新参数的字面替换。这可能不反映表达式的极限行为：
- en: '[PRE144]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: If the substitution will be followed by numerical evaluation, it is better to
    pass the substitution to evalf as
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果替换后将进行数值评估，则最好将替换传递给 evalf，如
- en: '[PRE146]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: rather than
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是
- en: '[PRE147]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: as the former will ensure that the desired level of precision is obtained.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前者将确保获得所需的精度水平。
- en: See also
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
- en: replacement capable of doing wildcard-like matching, parsing of match, and conditional
    replacements
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 能够进行类似通配符匹配、匹配解析和条件替换的替换功能
- en: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
- en: exact node replacement in expr tree; also capable of using matching rules
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式树中确切节点替换；还能够使用匹配规则
- en: '[`sympy.core.evalf.EvalfMixin.evalf`](#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.evalf.EvalfMixin.evalf`](#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")'
- en: calculates the given formula to a desired level of precision
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定公式到所需的精度水平
- en: '[PRE148]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Replace occurrences of objects within the expression.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式中替换对象的出现。
- en: 'Parameters:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**rule** : dict-like'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**rule**：类似字典'
- en: Expresses a replacement rule
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表示替换规则
- en: 'Returns:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**xreplace** : the result of the replacement'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**xreplace**：替换的结果'
- en: Examples
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE149]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Replacements occur only if an entire node in the expression tree is matched:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当在表达式树中匹配到整个节点时才进行替换：
- en: '[PRE150]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'xreplace does not differentiate between free and bound symbols. In the following,
    subs(x, y) would not change x since it is a bound symbol, but xreplace does:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: xreplace不区分自由符号和绑定符号。在以下情况下，subs(x, y)不会改变x，因为它是一个绑定符号，但xreplace会：
- en: '[PRE151]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Trying to replace x with an expression raises an error:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用一个表达式替换x会引发错误：
- en: '[PRE152]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: See also
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
- en: replacement capable of doing wildcard-like matching, parsing of match, and conditional
    replacements
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 替换能够进行类似通配符的匹配，匹配解析和条件替换
- en: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
- en: substitution of subexpressions as defined by the objects themselves.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象本身定义的子表达式的替换。
- en: '[PRE153]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: A parent class for atomic things. An atom is an expression with no subexpressions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一个原子事物的父类。原子是没有子表达式的表达式。
- en: Examples
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'Symbol, Number, Rational, Integer, … But not: Add, Mul, Pow, …  ## singleton'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '符号，数字，有理数，整数，...但不包括：Add，Mul，Pow，... ## 单例'
- en: '[PRE154]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The registry for the singleton classes (accessible as `S`).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类的注册表（可作为`S`访问）。
- en: Explanation
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This class serves as two separate things.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此类作为两个单独的事物。
- en: The first thing it is is the `SingletonRegistry`. Several classes in SymPy appear
    so often that they are singletonized, that is, using some metaprogramming they
    are made so that they can only be instantiated once (see the [`sympy.core.singleton.Singleton`](#sympy.core.singleton.Singleton
    "sympy.core.singleton.Singleton") class for details). For instance, every time
    you create `Integer(0)`, this will return the same instance, [`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero
    "sympy.core.numbers.Zero"). All singleton instances are attributes of the `S`
    object, so `Integer(0)` can also be accessed as `S.Zero`.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是`SingletonRegistry`。在SymPy中有几个类经常出现，它们被单例化，也就是说，通过一些元编程，它们被设计成只能实例化一次（详见[`sympy.core.singleton.Singleton`](#sympy.core.singleton.Singleton
    "sympy.core.singleton.Singleton")类的详细信息）。例如，每次创建`Integer(0)`时，都会返回相同的实例，[`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero
    "sympy.core.numbers.Zero")。所有单例实例都是`S`对象的属性，因此`Integer(0)`也可以作为`S.Zero`访问。
- en: 'Singletonization offers two advantages: it saves memory, and it allows fast
    comparison. It saves memory because no matter how many times the singletonized
    objects appear in expressions in memory, they all point to the same single instance
    in memory. The fast comparison comes from the fact that you can use `is` to compare
    exact instances in Python (usually, you need to use `==` to compare things). `is`
    compares objects by memory address, and is very fast.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 单例化提供了两个优点：它节省内存，并允许快速比较。它节省内存，因为无论单例化对象在内存中出现多少次，它们都指向内存中的同一个单一实例。快速比较来自于在Python中可以使用`is`来比较确切的实例（通常情况下，需要使用`==`来比较）。`is`通过内存地址比较对象，并且非常快速。
- en: Examples
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE155]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: For the most part, the fact that certain objects are singletonized is an implementation
    detail that users should not need to worry about. In SymPy library code, `is`
    comparison is often used for performance purposes The primary advantage of `S`
    for end users is the convenient access to certain instances that are otherwise
    difficult to type, like `S.Half` (instead of `Rational(1, 2)`).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，某些对象被设计为单例化是一个用户不需要担心的实现细节。在SymPy库代码中，通常使用`is`比较是为了性能目的。对于最终用户来说，`S`的主要优点是方便访问某些难以输入的实例，如`S.Half`（而不是`Rational(1,
    2)`）。
- en: When using `is` comparison, make sure the argument is sympified. For instance,
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`is`比较时，请确保参数已经过符号化。例如，
- en: '[PRE156]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This problem is not an issue when using `==`, which is recommended for most
    use-cases:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`==`时，这个问题并不是一个问题，这在大多数用例中是推荐的：
- en: '[PRE157]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The second thing `S` is is a shortcut for [`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify"). [`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") is the function that converts Python objects such
    as `int(1)` into SymPy objects such as `Integer(1)`. It also converts the string
    form of an expression into a SymPy expression, like `sympify("x**2")` -> `Symbol("x")**2`.
    `S(1)` is the same thing as `sympify(1)` (basically, `S.__call__` has been defined
    to call `sympify`).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事 `S` 是 [`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    的快捷方式。[`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    是将 Python 对象（如 `int(1)`）转换为 SymPy 对象（如 `Integer(1)`）的函数。它还将表达式的字符串形式转换为 SymPy
    表达式，例如 `sympify("x**2")` -> `Symbol("x")**2`。 `S(1)` 和 `sympify(1)` 是相同的（基本上，`S.__call__`
    被定义为调用 `sympify`）。
- en: 'This is for convenience, since `S` is a single letter. It’s mostly useful for
    defining rational numbers. Consider an expression like `x + 1/2`. If you enter
    this directly in Python, it will evaluate the `1/2` and give `0.5`, because both
    arguments are ints (see also [Two Final Notes: ^ and /](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)).
    However, in SymPy, you usually want the quotient of two integers to give an exact
    rational number. The way Python’s evaluation works, at least one side of an operator
    needs to be a SymPy object for the SymPy evaluation to take over. You could write
    this as `x + Rational(1, 2)`, but this is a lot more typing. A shorter version
    is `x + S(1)/2`. Since `S(1)` returns `Integer(1)`, the division will return a
    `Rational` type, since it will call `Integer.__truediv__`, which knows how to
    return a `Rational`.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了方便起见，因为 `S` 是一个单字母。这对定义有理数特别有用。考虑一个表达式 `x + 1/2`。如果你直接在 Python 中输入这个表达式，它会评估
    `1/2` 并给出 `0.5`，因为两个参数都是整数（另请参见 [两个终极注意事项：^ 和 /](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)）。然而，在
    SymPy 中，你通常希望两个整数的商能够精确地得到一个有理数。Python 评估的方式是，至少一侧的操作数需要是 SymPy 对象才能进行 SymPy 评估。你可以将这写成
    `x + Rational(1, 2)`，但这样键入的量比较多。一个更短的版本是 `x + S(1)/2`。由于 `S(1)` 返回 `Integer(1)`，除法将返回一个
    `Rational` 类型，因为它会调用 `Integer.__truediv__`，它知道如何返回一个 `Rational`。
- en: '[PRE158]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Metaclass for singleton classes.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类的元类。
- en: Explanation
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: A singleton class has only one instance which is returned every time the class
    is instantiated. Additionally, this instance can be accessed through the global
    registry object `S` as `S.<class_name>`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类只有一个实例，每次实例化类时都会返回这个实例。此外，可以通过全局注册对象 `S` 作为 `S.<class_name>` 来访问这个实例。
- en: Examples
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE159]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Notes
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Instance creation is delayed until the first time the value is accessed. (SymPy
    versions before 1.0 would create the instance during class creation time, which
    would be prone to import cycles.)  ## expr'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '实例的创建被延迟到第一次访问该值时。（SymPy 版本在 1.0 之前会在类创建时创建实例，这可能导致导入循环。）  ## 表达式'
- en: '[PRE160]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Base class for algebraic expressions.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 代数表达式的基类。
- en: Explanation
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Everything that requires arithmetic operations to be defined should subclass
    this class, instead of Basic (which should be used only for argument storage and
    expression manipulation, i.e. pattern matching, substitutions, etc).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 所有需要定义算术操作的内容应该继承这个类，而不是 `Basic`（`Basic` 应该仅用于参数存储和表达式操作，即模式匹配、替换等）。
- en: 'If you want to override the comparisons of expressions: Should use _eval_is_ge
    for inequality, or _eval_is_eq, with multiple dispatch. _eval_is_ge return true
    if x >= y, false if x < y, and None if the two types are not comparable or the
    comparison is indeterminate'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重写表达式的比较：应该使用 _eval_is_ge 进行不等式比较，或者使用多重分发的 _eval_is_eq。_eval_is_ge 如果
    x >= y 则返回 true，如果 x < y 则返回 false，如果两种类型不可比较或比较不确定则返回 None。
- en: See also
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.basic.Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic")'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.basic.Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic")'
- en: '[PRE161]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: See the apart function in sympy.polys
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.polys 中的 `apart` 函数。
- en: '[PRE162]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Return [commutative factors, non-commutative factors] of self.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self 的 [可交换因子，非可交换因子]。
- en: Explanation
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: self is treated as a Mul and the ordering of the factors is maintained. If `cset`
    is True the commutative factors will be returned in a set. If there were repeated
    factors (as may happen with an unevaluated Mul) then an error will be raised unless
    it is explicitly suppressed by setting `warn` to False.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: self 被视为一个乘积，并且保持因子的顺序。如果 `cset` 为 True，可交换因子将返回为一个集合。如果有重复因子（如可能发生在未评估的乘积中），则除非显式将
    `warn` 设置为 False，否则会引发错误。
- en: 'Note: -1 is always separated from a Number unless split_1 is False.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：-1 与数字始终分开，除非 split_1 为 False。
- en: Examples
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE163]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The arg is always treated as a Mul:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 参数始终被视为Mul：
- en: '[PRE164]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Efficiently extract the coefficient of a summation.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取求和的系数。
- en: '[PRE166]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Efficiently extract the coefficient of a product.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取乘积的系数。
- en: '[PRE167]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Return the tuple (c, args) where self is written as an Add, `a`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组(c, args)，其中self被写成Add，`a`。
- en: c should be a Rational added to any terms of the Add that are independent of
    deps.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: c应该是一个Rational，加到Add的任何独立于deps的项上。
- en: args should be a tuple of all other terms of `a`; args is empty if self is a
    Number or if self is independent of deps (when given).
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: args应该是`a`的所有其他项的元组；如果self是一个Number或者self独立于deps（当给定时），args为空。
- en: This should be used when you do not know if self is an Add or not but you want
    to treat self as an Add or if you want to process the individual arguments of
    the tail of self as an Add.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定self是否是Add，但你想要将self视为Add，或者你想要处理self尾部的各个参数作为Add时，应该使用这个方法。
- en: if you know self is an Add and want only the head, use self.args[0];
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道self是一个Add并且只想要头部，使用self.args[0]；
- en: if you do not want to process the arguments of the tail but need the tail then
    use self.as_two_terms() which gives the head and tail.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想处理尾部的参数但需要尾部，则使用self.as_two_terms()，它会给出头部和尾部。
- en: if you want to split self into an independent and dependent parts use `self.as_independent(*deps)`
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将self分成独立部分和依赖部分，请使用`self.as_independent(*deps)`
- en: '[PRE168]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '`c*x**e -> c,e` where x can be any symbolic expression.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`c*x**e -> c,e`，其中x可以是任何符号表达式。'
- en: '[PRE170]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Return the tuple (c, args) where self is written as a Mul, `m`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组(c, args)，其中self被写成Mul，`m`。
- en: c should be a Rational multiplied by any factors of the Mul that are independent
    of deps.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: c应该是一个Rational，乘以任何独立于deps的Mul的因子。
- en: args should be a tuple of all other factors of m; args is empty if self is a
    Number or if self is independent of deps (when given).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: args应该是m的所有其他因子的元组；如果self是一个Number或者self独立于deps（当给定时），args为空。
- en: This should be used when you do not know if self is a Mul or not but you want
    to treat self as a Mul or if you want to process the individual arguments of the
    tail of self as a Mul.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定self是否是Mul，但你想要将self视为Mul，或者你想要处理self尾部的各个参数作为Mul时，应该使用这个方法。
- en: if you know self is a Mul and want only the head, use self.args[0];
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道self是一个Mul并且只想要头部，使用self.args[0]；
- en: if you do not want to process the arguments of the tail but need the tail then
    use self.as_two_terms() which gives the head and tail;
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想处理尾部的参数但需要尾部，则使用self.as_two_terms()，它会给出头部和尾部；
- en: if you want to split self into an independent and dependent parts use `self.as_independent(*deps)`
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将self分成独立部分和依赖部分，请使用`self.as_independent(*deps)`
- en: '[PRE171]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Extracts symbolic coefficient at the given expression. In other words, this
    functions separates ‘self’ into the product of ‘expr’ and ‘expr’-free coefficient.
    If such separation is not possible it will return None.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定表达式中提取符号系数。换句话说，这个函数将‘self’分解为‘expr’和‘expr’-free系数的乘积。如果无法进行这种分解，它将返回None。
- en: Examples
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE173]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Two terms have E in them so a sum is returned. (If one were desiring the coefficient
    of the term exactly matching E then the constant from the returned expression
    could be selected. Or, for greater precision, a method of Poly can be used to
    indicate the desired term from which the coefficient is desired.)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 两个项中都有E，所以返回一个和。（如果希望得到与E完全匹配的项的系数，则可以选择返回表达式中的常数。或者，为了更高的精度，可以使用Poly的方法指示所需的项，从中获取系数。）
- en: '[PRE175]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Since the following cannot be written as a product containing E as a factor,
    None is returned. (If the coefficient `2*x` is desired then the `coeff` method
    should be used.)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下内容无法写成包含E作为因子的乘积，因此返回None。（如果需要系数`2*x`，则应该使用`coeff`方法。）
- en: '[PRE176]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: See also
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`coeff`](#sympy.core.expr.Expr.coeff "sympy.core.expr.Expr.coeff")'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[`coeff`](#sympy.core.expr.Expr.coeff "sympy.core.expr.Expr.coeff")'
- en: return sum of terms have a given factor
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有给定因子的项的和
- en: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
- en: separate the additive constant from an expression
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个表达式中的加法常数与表达式分开
- en: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
- en: separate the multiplicative constant from an expression
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个表达式中的乘法常数与表达式分开
- en: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
- en: separate x-dependent terms/factors from others
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 将依赖于x的项/因子与其他项分开
- en: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
- en: efficiently find the single coefficient of a monomial in Poly
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地找到Poly中单项式的单一系数。
- en: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
- en: like coeff_monomial but powers of monomial terms are used
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`coeff_monomial`，但使用了单项式项的幂。
- en: '[PRE179]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Return a dictionary mapping terms to their Rational coefficient. Since the dictionary
    is a defaultdict, inquiries about terms which were not present will return a coefficient
    of 0.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个将项映射到它们的有理系数的字典。由于字典是默认字典，对于不存在的项的查询将返回系数为0。
- en: If symbols `syms` are provided, any multiplicative terms independent of them
    will be considered a coefficient and a regular dictionary of syms-dependent generators
    as keys and their corresponding coefficients as values will be returned.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了符号`syms`，则独立于它们的任何乘法项将被视为系数，并将返回一个常规字典，其键为依赖于`syms`的生成器，值为它们对应的系数。
- en: Examples
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE180]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: This method should recursively remove a Rational from all arguments and return
    that (content) and the new self (primitive). The content should always be positive
    and `Mul(*foo.as_content_primitive()) == foo`. The primitive need not be in canonical
    form and should try to preserve the underlying structure if possible (i.e. expand_mul
    should not be applied to self).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应递归地从所有参数中移除有理数，并返回该（内容）和新的`self`（primitive）。内容应始终为正，并且`Mul(*foo.as_content_primitive())
    == foo`。如果可能，原始形式不需要处于规范形式，并且应尽量保留底层结构（即不应将`expand_mul`应用于`self`）。
- en: Examples
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE182]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The as_content_primitive function is recursive and retains structure:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_content_primitive`函数是递归的，并保留结构：'
- en: '[PRE184]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Integer powers will have Rationals extracted from the base:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 整数幂将从基数中提取有理数：
- en: '[PRE185]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Terms may end up joining once their as_content_primitives are added:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它们的`as_content_primitives`被添加，术语可能最终会合并：
- en: '[PRE186]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Radical content can also be factored out of the primitive:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的激进内容也可以从原始中分解出来：
- en: '[PRE187]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: If clear=False (default is True) then content will not be removed from an Add
    if it can be distributed to leave one or more terms with integer coefficients.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clear=False`（默认为True），则不会从加法中删除内容，如果可以分布以留下一个或多个具有整数系数的项。
- en: '[PRE188]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Convert a polynomial to a SymPy expression.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 将多项式转换为SymPy表达式。
- en: Examples
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE190]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'A mostly naive separation of a Mul or Add into arguments that are not are dependent
    on deps. To obtain as complete a separation of variables as possible, use a separation
    method first, e.g.:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 对乘积或加法进行大多数简单的分离，其参数不依赖于`deps`。要尽可能完整地分离变量，请首先使用分离方法，例如：
- en: separatevars() to change Mul, Add and Pow (including exp) into Mul
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`separatevars()`将乘法、加法和幂（包括指数）转换为乘法'
- en: .expand(mul=True) to change Add or Mul into Add
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.expand(mul=True)`将加法或乘法转换为加法'
- en: .expand(log=True) to change log expr into an Add
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.expand(log=True)` 将对数表达式转换为加法。'
- en: The only non-naive thing that is done here is to respect noncommutative ordering
    of variables and to always return (0, 0) for \(self\) of zero regardless of hints.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一非朴素的事情是尊重变量的非交换顺序，并且无论提示如何，对于零的`self`始终返回(0, 0)。
- en: 'For nonzero \(self\), the returned tuple (i, d) has the following interpretation:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非零的`self`，返回的元组（`i`，`d`）有以下解释：
- en: i will has no variable that appears in deps
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`将没有出现在`deps`中的变量。'
- en: d will either have terms that contain variables that are in deps, or be equal
    to 0 (when self is an Add) or 1 (when self is a Mul)
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`self`为加法时，`d`将包含包含在`deps`中的变量的项，或者等于0（当`self`为加法时）或1（当`self`为乘法时）。
- en: if self is an Add then self = i + d
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`self`是一个加法，则`self = i + d`。
- en: if self is a Mul then self = i*d
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`self`是一个乘法，则`self = i*d`
- en: otherwise (self, S.One) or (S.One, self) is returned.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则返回（`self`，`S.One`）或（`S.One`，`self`）。
- en: To force the expression to be treated as an Add, use the hint as_Add=True
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制表达式被视为加法，使用提示`as_Add=True`。
- en: Examples
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: – self is an Add
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: – `self`是一个加法
- en: '[PRE194]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: – self is a Mul
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: – `self` 是一个乘积。
- en: '[PRE196]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: non-commutative terms cannot always be separated out when self is a Mul
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当`self`为乘法时，非交换术语并非总是可以分离出来
- en: '[PRE197]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '– self is anything else:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: – `self`是其他任何东西：
- en: '[PRE198]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '– force self to be treated as an Add:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: – 强制`self`被视为加法：
- en: '[PRE199]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '– force self to be treated as a Mul:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: – 强制`self`被视为乘法：
- en: '[PRE200]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Note how the below differs from the above in making the constant on the dep
    term positive.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下与上面不同的地方在于使依赖项术语上的常数为正。
- en: '[PRE201]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: – use .as_independent() for true independence testing instead
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: – 对真独立性测试使用 .as_independent()
- en: of .has(). The former considers only symbols in the free symbols while the latter
    considers all symbols
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: .has() 的例子。前者仅考虑自由符号中的符号，而后者考虑所有符号
- en: '[PRE202]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Note: when trying to get independent terms, a separation method might need
    to be used first. In this case, it is important to keep track of what you send
    to this routine so you know how to interpret the returned values'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在尝试获取独立项时，可能需要先使用分离方法。在这种情况下，重要的是跟踪您发送到此例程的内容，以便知道如何解释返回的值
- en: '[PRE203]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: See also
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`separatevars`](simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars"), [`expand_log`](#sympy.core.function.expand_log
    "sympy.core.function.expand_log"), [`sympy.core.add.Add.as_two_terms`](#sympy.core.add.Add.as_two_terms
    "sympy.core.add.Add.as_two_terms"), [`sympy.core.mul.Mul.as_two_terms`](#sympy.core.mul.Mul.as_two_terms
    "sympy.core.mul.Mul.as_two_terms"), [`as_coeff_mul`](#sympy.core.expr.Expr.as_coeff_mul
    "sympy.core.expr.Expr.as_coeff_mul")'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '[`separatevars`](simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars"), [`expand_log`](#sympy.core.function.expand_log
    "sympy.core.function.expand_log"), [`sympy.core.add.Add.as_two_terms`](#sympy.core.add.Add.as_two_terms
    "sympy.core.add.Add.as_two_terms"), [`sympy.core.mul.Mul.as_two_terms`](#sympy.core.mul.Mul.as_two_terms
    "sympy.core.mul.Mul.as_two_terms"), [`as_coeff_mul`](#sympy.core.expr.Expr.as_coeff_mul
    "sympy.core.expr.Expr.as_coeff_mul")'
- en: '[PRE204]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Returns the leading (nonzero) term of the series expansion of self.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self 的主导（非零）系列展开项。
- en: The _eval_as_leading_term routines are used to do this, and they must always
    return a non-zero value.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: _eval_as_leading_term 例程用于此目的，并且它们必须始终返回非零值。
- en: Examples
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE205]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Return the numerator and the denominator of an expression.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表达式的分子和分母。
- en: expression -> a/b -> a, b
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 -> a/b -> a, b
- en: This is just a stub that should be defined by an object’s class methods to get
    anything else.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个存根，应由对象的类方法定义以获取任何其他内容。
- en: See also
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`normal`](#sympy.core.expr.Expr.normal "sympy.core.expr.Expr.normal")'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[`normal`](#sympy.core.expr.Expr.normal "sympy.core.expr.Expr.normal")'
- en: return `a/b` instead of `(a, b)`
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `a/b` 而不是 `(a, b)`
- en: '[PRE207]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Return list of ordered factors (if Mul) else [self].
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 返回有序因子列表（如果是 Mul），否则返回 [self]。
- en: '[PRE208]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Transform an expression to an ordered list of terms.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式转换为项的有序列表。
- en: Examples
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE209]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Converts `self` to a polynomial or returns `None`.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `self` 转换为多项式或返回 `None`。
- en: Explanation
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '[PRE212]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Return self as a dictionary of factors with each factor being treated as a power.
    The keys are the bases of the factors and the values, the corresponding exponents.
    The resulting dictionary should be used with caution if the expression is a Mul
    and contains non- commutative factors since the order that they appeared will
    be lost in the dictionary.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 将 self 作为因子的字典返回，其中每个因子都被视为一个幂。键是因子的基数，而值是相应的指数。如果表达式是 Mul 并包含非交换因子，则应谨慎使用结果字典，因为它们出现的顺序将在字典中丢失。
- en: See also
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`as_ordered_factors`](#sympy.core.expr.Expr.as_ordered_factors "sympy.core.expr.Expr.as_ordered_factors")'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_ordered_factors`](#sympy.core.expr.Expr.as_ordered_factors "sympy.core.expr.Expr.as_ordered_factors")'
- en: An alternative for noncommutative applications, returning an ordered list of
    factors.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 用于非交换应用的替代方法，返回因子的有序列表。
- en: '[`args_cnc`](#sympy.core.expr.Expr.args_cnc "sympy.core.expr.Expr.args_cnc")'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '[`args_cnc`](#sympy.core.expr.Expr.args_cnc "sympy.core.expr.Expr.args_cnc")'
- en: Similar to as_ordered_factors, but guarantees separation of commutative and
    noncommutative factors.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 as_ordered_factors，但保证将交换和非交换因子分开。
- en: '[PRE217]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Performs complex expansion on ‘self’ and returns a tuple containing collected
    both real and imaginary parts. This method cannot be confused with re() and im()
    functions, which does not perform complex expansion at evaluation.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `self` 执行复杂展开，并返回一个包含实部和虚部的元组。此方法不能与 re() 和 im() 函数混淆，后者在评估时不进行复杂展开。
- en: However it is possible to expand both re() and im() functions and get exactly
    the same results as with a single call to this function.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以展开 re() 和 im() 函数，并且与调用此函数一次获得完全相同的结果。
- en: '[PRE218]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Transform an expression to a list of terms.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式转换为项列表。
- en: '[PRE224]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Asymptotic Series expansion of self. This is equivalent to `self.series(x, oo,
    n)`.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 自我的渐近级数展开。这相当于 `self.series(x, oo, n)`。
- en: 'Parameters:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**self** : Expression'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**self** : 表达式'
- en: The expression whose series is to be expanded.
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要展开其级数的表达式。
- en: '**x** : Symbol'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**x** : 符号'
- en: It is the variable of the expression to be calculated.
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它是要计算的表达式的变量。
- en: '**n** : Value'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 值'
- en: The value used to represent the order in terms of `x**n`, up to which the series
    is to be expanded.
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于表示以`x**n`为单位的顺序的值，直到展开系列。
- en: '**hir** : Boolean'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '**hir**：布尔值'
- en: Set this parameter to be True to produce hierarchical series. It stops the recursion
    at an early level and may provide nicer and more useful results.
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将此参数设置为True以生成分层系列。它在早期阶段停止递归，并可能提供更漂亮和更有用的结果。
- en: '**bound** : Value, Integer'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**bound**：值，整数'
- en: Use the `bound` parameter to give limit on rewriting coefficients in its normalised
    form.
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`bound`参数来给出其规范形式中重写系数的限制。
- en: 'Returns:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: Expr
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式
- en: Asymptotic series expansion of the expression.
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式的渐近级数展开。
- en: Examples
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE225]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: For rational expressions this method may return original expression without
    the Order term. >>> (1/x).aseries(x, n=8) 1/x
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有理表达式，此方法可能返回原始表达式而不带有Order项。 >>> (1/x).aseries(x, n=8) 1/x
- en: Notes
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This algorithm is directly induced from the limit computational algorithm provided
    by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea
    of this algorithm is first to look for the most rapidly varying subexpression
    w of a given expression f and then expands f in a series in w. Then same thing
    is recursively done on the leading coefficient till we get constant coefficients.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法直接来源于Gruntz提供的限制计算算法，主要使用mrv和rewrite子例程。该算法的整体思想首先是查找给定表达式f的最快变化子表达式w，然后在w的系列中展开f。然后同样的事情递归地在主导系数上进行，直到获得常数系数。
- en: If the most rapidly varying subexpression of a given expression f is f itself,
    the algorithm tries to find a normalised representation of the mrv set and rewrites
    f using this normalised representation.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定表达式f的最快变化子表达式是f本身，则算法尝试找到mrv集的规范表示，并使用此规范表示重写f。
- en: If the expansion contains an order term, it will be either `O(x ** (-n))` or
    `O(w ** (-n))` where `w` belongs to the most rapidly varying expression of `self`.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 如果展开包含顺序项，则其将是`O(x ** (-n))`或`O(w ** (-n))`，其中`w`属于`self`的最快变化表达式。
- en: See also
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`Expr.aseries`](#sympy.core.expr.Expr.aseries "sympy.core.expr.Expr.aseries")'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Expr.aseries`](#sympy.core.expr.Expr.aseries "sympy.core.expr.Expr.aseries")'
- en: See the docstring of this function for complete details of this wrapper.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅此包装器的文档字符串以获取完整详细信息。
- en: References
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[R119](#id18)]'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R119](#id18)]'
- en: 'Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc.
    1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc.
    1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244.'
- en: '[[R120](#id19)]'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R120](#id19)]'
- en: Gruntz thesis - p90
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: Gruntz thesis - p90
- en: '[[R121](#id20)]'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R121](#id20)]'
- en: '[https://en.wikipedia.org/wiki/Asymptotic_expansion](https://en.wikipedia.org/wiki/Asymptotic_expansion)'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Asymptotic_expansion](https://en.wikipedia.org/wiki/Asymptotic_expansion)'
- en: '[PRE232]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: See the cancel function in sympy.polys
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅sympy.polys中的cancel函数
- en: '[PRE233]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Returns the coefficient from the term(s) containing `x**n`. If `n` is zero then
    all terms independent of `x` will be returned.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 返回包含`x**n`的术语中的系数。如果`n`为零，则将返回所有独立于`x`的术语。
- en: Explanation
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: When `x` is noncommutative, the coefficient to the left (default) or right of
    `x` can be returned. The keyword ‘right’ is ignored when `x` is commutative.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 当`x`是非交换时，可以返回`x`左侧（默认）或右侧的系数。当`x`是交换时，关键字‘right’被忽略。
- en: Examples
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE234]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'You can select terms that have an explicit negative in front of them:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择具有明确负数的项：
- en: '[PRE235]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'You can select terms with no Rational coefficient:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择没有有理系数的项：
- en: '[PRE236]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0]
    is returned (and 0 will be returned instead of None):'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将n=0使x独立选择项；在这种情况下，将返回expr.as_independent(x)[0]（而不是None将返回0）：
- en: '[PRE237]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'You can select terms that have a numerical term in front of them:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择具有数字项的项：
- en: '[PRE238]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The matching is exact:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是精确的：
- en: '[PRE239]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the
    following:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有进行因式分解，因此`1 + z*(1 + y)`不是从以下获得的：
- en: '[PRE240]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'If such factoring is desired, factor_terms can be used first:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进行此类因式分解，可以先使用factor_terms：
- en: '[PRE241]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'If there is more than one possible coefficient 0 is returned:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个可能的系数，则返回0：
- en: '[PRE243]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'If there is only one possible coefficient, it is returned:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个可能的系数，则返回它：
- en: '[PRE244]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: See also
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`as_coefficient`](#sympy.core.expr.Expr.as_coefficient "sympy.core.expr.Expr.as_coefficient")'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_coefficient`](#sympy.core.expr.Expr.as_coefficient "sympy.core.expr.Expr.as_coefficient")'
- en: separate the expression into a coefficient and factor
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式分解为系数和因子
- en: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
- en: separate the additive constant from an expression
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个表达式中的加法常数与其分开
- en: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
- en: separate the multiplicative constant from an expression
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 将乘法常数与表达式分开
- en: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
- en: separate x-dependent terms/factors from others
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 将x相关的项/因子与其他项分开
- en: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
- en: efficiently find the single coefficient of a monomial in Poly
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在Poly中高效地找到单项式的单一系数
- en: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
- en: like coeff_monomial but powers of monomial terms are used
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于coeff_monomial，但使用单项式项的幂
- en: '[PRE245]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: See the collect function in sympy.simplify
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 查看sympy.simplify中的collect函数
- en: '[PRE246]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: See the combsimp function in sympy.simplify
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 查看sympy.simplify中的combsimp函数
- en: '[PRE247]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Deprecated function to compute the leading term of a series.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 弃用的函数，用于计算系列的主导项。
- en: as_leading_term is only allowed for results of .series() This is a wrapper to
    compute a series first.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: as_leading_term仅允许用于.series()的结果，这是计算系列的包装器。
- en: '[PRE248]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Returns the complex conjugate of ‘self’.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 返回‘self’的复共轭。
- en: '[PRE249]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Return True if self has -1 as a leading factor or has more literal negative
    signs than positive signs in a sum, otherwise False.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自身具有-1作为主要因子或者在求和中负号的字面意义比正号多，则返回True，否则返回False。
- en: Examples
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE250]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Though the `y - x` is considered like `-(x - y)`, since it is in a product
    without a leading factor of -1, the result is false below:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`y - x`被视为`-(x - y)`，因为它在没有-1主要因子的情况下是一个乘积，所以下面的结果是错误的：
- en: '[PRE251]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'To put something in canonical form wrt to sign, use \(signsimp\):'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 要将某物放入与符号相关的规范形式，请使用\(signsimp\)：
- en: '[PRE252]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Return True if self == other, False if it does not, or None. If failing_expression
    is True then the expression which did not simplify to a 0 will be returned instead
    of None.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self == other，则返回True，如果不是，则返回False或None。如果failing_expression为True，则会返回未简化为0的表达式，而不是None。
- en: Explanation
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If `self` is a Number (or complex number) that is not zero, then the result
    is False.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是一个非零的数（或复数），则结果为False。
- en: If `self` is a number and has not evaluated to zero, evalf will be used to test
    whether the expression evaluates to zero. If it does so and the result has significance
    (i.e. the precision is either -1, for a Rational result, or is greater than 1)
    then the evalf value will be used to return True or False.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是一个数字且未评估为零，则将使用evalf来测试表达式是否评估为零。如果是这样，并且结果具有显著性（即精度为-1，用于有理数结果，或大于1），则将使用evalf值来返回True或False。
- en: '[PRE254]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Expand an expression using hints.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提示扩展表达式。
- en: See the docstring of the expand() function in sympy.core.function for more information.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 查看sympy.core.function中expand()函数的文档字符串以获取更多信息。
- en: '[PRE255]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Like `free_symbols`, but returns the free symbols only if they are contained
    in an expression node.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`free_symbols`，但仅在它们包含在表达式节点中时返回自由符号。
- en: Examples
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE256]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'If the expression is contained in a non-expression object, do not return the
    free symbols. Compare:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式包含在非表达式对象中，则不返回自由符号。比较：
- en: '[PRE257]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Return self - c if it’s possible to subtract c from self and make all matching
    coefficients move towards zero, else return None.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以从self中减去c并使所有匹配系数向零移动，则返回self - c，否则返回None。
- en: Examples
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE259]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: See also
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`extract_multiplicatively`](#sympy.core.expr.Expr.extract_multiplicatively
    "sympy.core.expr.Expr.extract_multiplicatively"), [`coeff`](#sympy.core.expr.Expr.coeff
    "sympy.core.expr.Expr.coeff"), [`as_coefficient`](#sympy.core.expr.Expr.as_coefficient
    "sympy.core.expr.Expr.as_coefficient")'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '[`extract_multiplicatively`](#sympy.core.expr.Expr.extract_multiplicatively
    "sympy.core.expr.Expr.extract_multiplicatively")，[`coeff`](#sympy.core.expr.Expr.coeff
    "sympy.core.expr.Expr.coeff")，[`as_coefficient`](#sympy.core.expr.Expr.as_coefficient
    "sympy.core.expr.Expr.as_coefficient")'
- en: '[PRE260]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Try to write self as `exp_polar(2*pi*I*n)*z` in a nice way. Return (z, n).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以良好的方式将self写成`exp_polar(2*pi*I*n)*z`。返回(z, n)。
- en: '[PRE261]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'If allow_half is True, also extract exp_polar(I*pi):'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 如果allow_half为True，则还提取exp_polar(I*pi)：
- en: '[PRE262]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Return None if it’s not possible to make self in the form c * something in a
    nice way, i.e. preserving the properties of arguments of self.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法以一种良好的方式使 self 成为 c * something 的形式（即保留 self 参数的性质），则返回 None。
- en: Examples
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE264]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: See the factor() function in sympy.polys.polytools
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.polys.polytools 中的 factor() 函数
- en: '[PRE272]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Compute fourier sine/cosine series of self.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 self 的 Fourier 正/余弦级数。
- en: See the docstring of the [`fourier_series()`](#sympy.core.expr.Expr.fourier_series
    "sympy.core.expr.Expr.fourier_series") in sympy.series.fourier for more information.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.series.fourier 中的 [`fourier_series()`](#sympy.core.expr.Expr.fourier_series
    "sympy.core.expr.Expr.fourier_series") 的文档字符串，详见。
- en: '[PRE273]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Compute formal power power series of self.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 self 的形式幂级数。
- en: See the docstring of the [`fps()`](#sympy.core.expr.Expr.fps "sympy.core.expr.Expr.fps")
    function in sympy.series.formal for more information.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 `fps()` 函数的文档字符串，详见 sympy.series.formal。
- en: '[PRE274]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: See the gammasimp function in sympy.simplify
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 gammasimp 函数
- en: '[PRE275]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Returns the additive O(..) symbol if there is one, else None.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在加法 O(..) 符号则返回，否则返回 None。
- en: '[PRE276]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Returns the order of the expression.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表达式的次序。
- en: Explanation
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: The order is determined either from the O(…) term. If there is no O(…) term,
    it returns None.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 次序由 O(…) 项决定。如果没有 O(…) 项，则返回 None。
- en: Examples
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE277]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: See the integrate function in sympy.integrals
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.integrals 中的 integrate 函数
- en: '[PRE279]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Return the multiplicative inverse of `self` mod `g` where `self` (and `g`) may
    be symbolic expressions).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `self` 对 `g` 的模乘逆，其中 `self`（和 `g`）可能是符号表达式。
- en: See also
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 参见也
- en: '[`sympy.core.intfunc.mod_inverse`](#sympy.core.intfunc.mod_inverse "sympy.core.intfunc.mod_inverse"),
    [`sympy.polys.polytools.invert`](polys/reference.html#sympy.polys.polytools.invert
    "sympy.polys.polytools.invert")'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.intfunc.mod_inverse`](#sympy.core.intfunc.mod_inverse "sympy.core.intfunc.mod_inverse"),
    [`sympy.polys.polytools.invert`](polys/reference.html#sympy.polys.polytools.invert
    "sympy.polys.polytools.invert")'
- en: '[PRE280]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: This tests whether a given expression is algebraic or not, in the given symbols,
    syms. When syms is not given, all free symbols will be used. The rational function
    does not have to be in expanded or in any kind of canonical form.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 测试给定表达式在给定符号 syms 中是否是代数的。当未给定 syms 时，将使用所有自由符号。有理函数不必以展开或任何规范形式出现。
- en: This function returns False for expressions that are “algebraic expressions”
    with symbolic exponents. This is a simple extension to the is_rational_function,
    including rational exponentiation.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有符号指数的“代数表达式”，此函数返回 False。这是对 is_rational_function 的简单扩展，包括有理数指数。
- en: Examples
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE281]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be an algebraic expression to become
    one.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不会尝试进行任何非平凡简化，这可能会导致一个看起来不是代数表达式的表达式变成代数表达式。
- en: '[PRE282]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: See also
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 参见也
- en: '[`is_rational_function`](#sympy.core.expr.Expr.is_rational_function "sympy.core.expr.Expr.is_rational_function")'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_rational_function`](#sympy.core.expr.Expr.is_rational_function "sympy.core.expr.Expr.is_rational_function")'
- en: References
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R122](#id21)]'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R122](#id21)]'
- en: '[https://en.wikipedia.org/wiki/Algebraic_expression](https://en.wikipedia.org/wiki/Algebraic_expression)'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Algebraic_expression](https://en.wikipedia.org/wiki/Algebraic_expression)'
- en: '[PRE283]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Return True if self is constant, False if not, or None if the constancy could
    not be determined conclusively.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 self 是常数则返回 True，如果不是则返回 False，如果无法确定是否常数则返回 None。
- en: Explanation
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: 'If an expression has no free symbols then it is a constant. If there are free
    symbols it is possible that the expression is a constant, perhaps (but not necessarily)
    zero. To test such expressions, a few strategies are tried:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式没有自由符号则它是一个常数。如果有自由符号则可能是一个常数，也许（但不一定）是零。为了测试这样的表达式，尝试了几种策略：
- en: 1) numerical evaluation at two random points. If two such evaluations give two
    different values and the values have a precision greater than 1 then self is not
    constant. If the evaluations agree or could not be obtained with any precision,
    no decision is made. The numerical testing is done only if `wrt` is different
    than the free symbols.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 1) 在两个随机点的数值评估。如果两个评估给出不同的值，并且这些值的精度大于1，则 self 不是常数。如果评估结果一致或无法获得任何精度，则不做决定。只有在
    `wrt` 与自由符号不同时才进行数值测试。
- en: 2) differentiation with respect to variables in ‘wrt’ (or all free symbols if
    omitted) to see if the expression is constant or not. This will not always lead
    to an expression that is zero even though an expression is constant (see added
    test in test_expr.py). If all derivatives are zero then self is constant with
    respect to the given symbols.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 2）相对于‘wrt’中的变量（或者如果省略，则相对于所有自由符号）的微分，以查看表达式是否恒定。即使表达式是恒定的（请参见test_expr.py中添加的测试），这也不总是导致一个表达式为零。如果所有导数都为零，则self相对于给定符号是常数。
- en: 3) finding out zeros of denominator expression with free_symbols. It will not
    be constant if there are zeros. It gives more negative answers for expression
    that are not constant.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 3）找出具有自由符号的分母表达式的零点。如果有零点，则它将不是常数。对于不是常数的表达式，它给出更多的负面答案。
- en: If neither evaluation nor differentiation can prove the expression is constant,
    None is returned unless two numerical values happened to be the same and the flag
    `failing_number` is True – in that case the numerical value will be returned.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果既不能评估也不能区分表达式是否恒定，则返回None，除非两个数值恰好相同且标志`failing_number`为True – 在这种情况下，将返回数值。
- en: If flag simplify=False is passed, self will not be simplified; the default is
    True since self should be simplified before testing.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了标志simplify=False，self将不会被简化；默认值为True，因为在测试之前应该简化self。
- en: Examples
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE284]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: This tests whether an expression is meromorphic as a function of the given symbol
    `x` at the point `a`.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试一个表达式在给定符号`x`在点`a`处作为函数是否是亚黎函数。
- en: This method is intended as a quick test that will return None if no decision
    can be made without simplification or more detailed analysis.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法旨在作为一个快速测试，如果没有简化或更详细的分析，将返回None。
- en: Examples
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE287]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Multivalued functions are considered meromorphic when their branches are meromorphic.
    Thus most functions are meromorphic everywhere except at essential singularities
    and branch points. In particular, they will be meromorphic also on branch cuts
    except at their endpoints.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 多值函数被认为是亚黎函数，当它们的分支是亚黎函数时。因此，大多数函数在除了基本奇异点和分支点以外的任何地方都是亚黎函数。特别是，在分支切线上也将是亚黎函数，除了在其端点处。
- en: '[PRE291]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Returns True if `self` has no free symbols and no undefined functions (AppliedUndef,
    to be precise). It will be faster than `if not self.free_symbols`, however, since
    `is_number` will fail as soon as it hits a free symbol or undefined function.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`没有自由符号和未定义函数（具体是AppliedUndef），则返回True。这将比`if not self.free_symbols`更快，因为一旦遇到自由符号或未定义函数，`is_number`将失败。
- en: Examples
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE293]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Not all numbers are Numbers in the SymPy sense:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的数字在SymPy的意义上都是数字：
- en: '[PRE295]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: If something is a number it should evaluate to a number with real and imaginary
    parts that are Numbers; the result may not be comparable, however, since the real
    and/or imaginary part of the result may not have precision.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个东西是一个数，它应该评估为一个具有实部和虚部的数；然而，结果可能不可比较，因为结果的实部和/或虚部可能没有精度。
- en: '[PRE296]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: See also
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.core.basic.Basic.is_comparable`](#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable")'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.basic.Basic.is_comparable`](#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable")'
- en: '[PRE298]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Return True if self is a polynomial in syms and False otherwise.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 如果self是syms中的一个多项式，则返回True，否则返回False。
- en: This checks if self is an exact polynomial in syms. This function returns False
    for expressions that are “polynomials” with symbolic exponents. Thus, you should
    be able to apply polynomial algorithms to expressions for which this returns True,
    and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns
    True. The polynomial does not have to be in expanded form. If no symbols are given,
    all free symbols in the expression will be used.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查self是否是syms中的一个精确多项式。对于具有符号指数的“多项式”表达式，此函数返回False。因此，你应该能够对返回True的表达式应用多项式算法，并且如果expr.is_polynomial(*syms)返回True，则Poly(expr,
    *syms)应该工作。多项式不必处于展开形式。如果没有给出符号，则表达式中的所有自由符号都将被使用。
- en: This is not part of the assumptions system. You cannot do Symbol(‘z’, polynomial=True).
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是假设系统的一部分。你不能做Symbol(‘z’, polynomial=True)。
- en: Examples
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE299]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be a polynomial to become one.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会尝试任何可能导致一个表达式成为多项式但看起来不是多项式的非平凡简化。
- en: '[PRE301]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: See also .is_rational_function()
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 .is_rational_function()
- en: '[PRE303]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Test whether function is a ratio of two polynomials in the given symbols, syms.
    When syms is not given, all free symbols will be used. The rational function does
    not have to be in expanded or in any kind of canonical form.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数是否为给定符号syms中的两个多项式的比率。当未给出syms时，将使用所有自由符号。有理函数不必处于扩展或任何规范形式中。
- en: This function returns False for expressions that are “rational functions” with
    symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply
    polynomial algorithms to the result for expressions for which this returns True.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有符号指数的“有理函数”表达式，此函数返回False。因此，您应该能够调用.as_numer_denom()并对结果应用多项式算法，以便对此返回True的表达式进行操作。
- en: This is not part of the assumptions system. You cannot do Symbol(‘z’, rational_function=True).
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是假设系统的一部分。您无法执行Symbol('z'，rational_function=True)。
- en: Examples
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE304]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be a rational function to become one.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不尝试对可能导致表达式不是有理函数的非平凡简化进行任何简化。
- en: '[PRE309]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: See also is_algebraic_expr().
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见`is_algebraic_expr()`。
- en: '[PRE310]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Returns the leading term a*x**b as a tuple (a, b).
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 返回作为元组`(a, b)`的主导项`a*x**b`。
- en: Examples
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE311]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: Compute limit x->xlim.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 计算极限x->xlim。
- en: '[PRE313]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Wrapper for series yielding an iterator of the terms of the series.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 系列的项的迭代器的系列的包装器。
- en: 'Note: an infinite series will yield an infinite iterator. The following, for
    exaxmple, will never terminate. It will just keep printing terms of the sin(x)
    series:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：无限系列将产生无限迭代器。例如，以下示例将永远不会终止。它将继续打印sin(x)系列的项：
- en: '[PRE314]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The advantage of lseries() over nseries() is that many times you are just interested
    in the next term in the series (i.e. the first term for example), but you do not
    know how many you should ask for in nseries() using the “n” parameter.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`lseries()`比`nseries()`的优点在于，很多时候你只是对系列中的下一个项感兴趣（即例如第一个项），但你不知道应该在`nseries()`中使用“n”参数询问多少个项。'
- en: See also nseries().
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见`nseries()`。
- en: '[PRE315]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Return the expression as a fraction.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表达式作为分数。
- en: expression -> a/b
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 -> a/b
- en: See also
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom "sympy.core.expr.Expr.as_numer_denom")'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '[`as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom "sympy.core.expr.Expr.as_numer_denom")'
- en: return `(a, b)` instead of `a/b`
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`(a, b)`而不是`a/b`
- en: '[PRE316]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Wrapper to _eval_nseries if assumptions allow, else to series.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果假设允许，则是到`_eval_nseries`的包装，否则到系列。
- en: If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is called.
    This calculates “n” terms in the innermost expressions and then builds up the
    final series just by “cross-multiplying” everything out.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定x，x0为0，dir='+'，并且self具有x，则调用_eval_nseries。这会在最内层表达式中计算“n”个项，然后通过“交叉乘法”构建最终系列。
- en: The optional `logx` parameter can be used to replace any log(x) in the returned
    series with a symbolic value to avoid evaluating log(x) at 0\. A symbol to use
    in place of log(x) should be provided.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`logx`参数可用于在返回的系列中替换任何log(x)为符号值，以避免在0处评估log(x)。应提供用于替代log(x)的符号。
- en: Advantage – it’s fast, because we do not have to determine how many terms we
    need to calculate in advance.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 优点 - 它很快，因为我们不必提前确定需要计算多少项。
- en: Disadvantage – you may end up with less terms than you may have expected, but
    the O(x**n) term appended will always be correct and so the result, though perhaps
    shorter, will also be correct.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点 - 您可能得到比预期更少的术语，但始终附加正确的O(x**n)项，因此结果，尽管可能更短，也将是正确的。
- en: If any of those assumptions is not met, this is treated like a wrapper to series
    which will try harder to return the correct number of terms.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些假设中的任何一个不符合，则此功能将被视为对series的包装器，后者将尝试更努力返回正确数量的项。
- en: See also lseries().
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见`lseries()`。
- en: Examples
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE317]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'Handling of the `logx` parameter — in the following example the expansion fails
    since `sin` does not have an asymptotic expansion at -oo (the limit of log(x)
    as x approaches 0):'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`logx`参数 - 在以下示例中，展开失败，因为`sin`在-oo处没有渐近展开（当log(x)作为x趋近于0的极限时）：
- en: '[PRE318]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'In the following example, the expansion works but only returns self unless
    the `logx` parameter is used:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，展开有效，但只有在使用`logx`参数时才返回自身：
- en: '[PRE319]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: See the nsimplify function in sympy.simplify
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅sympy.simplify中的nsimplify函数
- en: '[PRE321]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: See the powsimp function in sympy.simplify
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅sympy.simplify中的powsimp函数
- en: '[PRE322]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Return the positive Rational that can be extracted non-recursively from every
    term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul()
    method but primitive always extracts a positive Rational (never a negative or
    a Float).
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可以从每个项中非递归提取的正有理数（即，将 self 视为 Add）。这类似于 as_coeff_Mul() 方法，但 primitive 总是提取正有理数（不提取负数或浮点数）。
- en: Examples
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE323]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: See the radsimp function in sympy.simplify
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 radsimp 函数
- en: '[PRE325]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: See the ratsimp function in sympy.simplify
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 ratsimp 函数
- en: '[PRE326]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: Removes the additive O(..) symbol if there is one
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，移除加法 O(..) 符号
- en: '[PRE327]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: Return x rounded to the given decimal place.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到给定小数位数的 x 的四舍五入值。
- en: If a complex number would results, apply round to the real and imaginary components
    of the number.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是复数，则对该数的实部和虚部应用 round。
- en: Examples
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE328]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'The round method has a chopping effect:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: round 方法具有截断效应：
- en: '[PRE329]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: Notes
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: 'The Python `round` function uses the SymPy `round` method so it will always
    return a SymPy number (not a Python float or int):'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `round` 函数使用 SymPy 的 `round` 方法，因此它始终返回 SymPy 数字（而不是 Python 的浮点数或整数）：
- en: '[PRE330]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: See the separate function in sympy.simplify
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 separate 函数
- en: '[PRE332]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: Series expansion of “self” around `x = x0` yielding either terms of the series
    one by one (the lazy series given when n=None), else all the terms at once when
    n != None.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `x = x0` 的“自我”级数展开，要么按需逐个给出级数项（当 n=None 时是懒惰级数），要么在 n != None 时一次性给出所有项。
- en: Returns the series expansion of “self” around the point `x = x0` with respect
    to `x` up to `O((x - x0)**n, x, x0)` (default n is 6).
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以 `x = x0` 点为中心，关于 `x` 展开到 `O((x - x0)**n, x, x0)` 的级数展开（默认 n 为 6）。
- en: If `x=None` and `self` is univariate, the univariate symbol will be supplied,
    otherwise an error will be raised.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x=None` 并且 `self` 是一元符号，则会提供该一元符号，否则会引发错误。
- en: 'Parameters:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : Expression'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr** ：表达式'
- en: The expression whose series is to be expanded.
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要展开其级数的表达式。
- en: '**x** : Symbol'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '**x** ：符号'
- en: It is the variable of the expression to be calculated.
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它是要计算的表达式的变量。
- en: '**x0** : Value'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0** ：数值'
- en: The value around which `x` is calculated. Can be any value from `-oo` to `oo`.
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算 `x` 的值。可以是从 `-oo` 到 `oo` 的任何值。
- en: '**n** : Value'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** ：数值'
- en: The value used to represent the order in terms of `x**n`, up to which the series
    is to be expanded.
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表示按 `x**n` 展开级数的阶数，展开到该阶数。
- en: '**dir** : String, optional'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '**dir** ：字符串，可选'
- en: The series-expansion can be bi-directional. If `dir="+"`, then (x->x0+). If
    [PRE333] (`oo` or `-oo`), the `dir` argument is determined from the direction
    of the infinity (i.e., `dir="-"` for `oo`).
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 级数展开可以是双向的。如果 `dir="+"`，则 (x->x0+)。如果 [PRE333] (`oo` 或 `-oo`)，则 `dir` 参数从无穷大的方向确定（例如对于
    `oo`，`dir="-"`）。
- en: '**logx** : optional'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**logx** ：可选'
- en: It is used to replace any log(x) in the returned series with a symbolic value
    rather than evaluating the actual value.
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于将返回的级数中的任何 log(x) 替换为符号值，而不是计算实际值。
- en: '**cdir** : optional'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '**cdir** ：可选'
- en: It stands for complex direction, and indicates the direction from which the
    expansion needs to be evaluated.
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它代表复杂方向，并指示需要从哪个方向评估展开。
- en: 'Returns:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**Expr** : Expression'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**Expr** ：表达式'
- en: Series expansion of the expression about x0
  id: totrans-974
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于 x0 的表达式的级数展开
- en: 'Raises:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 异常：
- en: '**TypeError**'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '**TypeError**'
- en: If “n” and “x0” are infinity objects
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果“n”和“x0”是无穷对象
- en: '**PoleError**'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '**PoleError**'
- en: If “x0” is an infinity object
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果“x0”是一个无限对象
- en: Examples
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE334]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: If `n=None` then a generator of the series terms will be returned.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `n=None`，则将返回级数项的生成器。
- en: '[PRE335]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: For `dir=+` (default) the series is calculated from the right and for `dir=-`
    the series from the left. For smooth functions this flag will not alter the results.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `dir=+`（默认），从右侧计算级数；对于 `dir=-`，从左侧计算级数。对于光滑函数，此标志不会改变结果。
- en: '[PRE336]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: For rational expressions this method may return original expression without
    the Order term. >>> (1/x).series(x, n=8) 1/x
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有理表达式，此方法可能返回原始表达式而不包括 Order 项。>>> (1/x).series(x, n=8) 1/x
- en: '[PRE338]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: General method for the taylor term.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 泰勒级数项的通用方法。
- en: This method is slow, because it differentiates n-times. Subclasses can redefine
    it to make it faster by using the “previous_terms”.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法速度较慢，因为需要 n 次求导。子类可以重新定义此方法，通过使用“previous_terms”使其更快。
- en: '[PRE339]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: See the together function in sympy.polys
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.polys 中的 together 函数
- en: '[PRE340]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: See the trigsimp function in sympy.simplify
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.simplify 中的 trigsimp 函数
- en: '[PRE341]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Expression that is not evaluated unless released.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 除非释放，否则不计算的表达式。
- en: Examples
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE342]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: A parent class for object which are both atoms and Exprs.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 既是原子又是 Exprs 的对象的父类。
- en: 'For example: Symbol, Number, Rational, Integer, … But not: Add, Mul, Pow, …  ##
    symbol'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '例如：Symbol, Number, Rational, Integer, … 但不包括：Add, Mul, Pow, …  ## symbol'
- en: '[PRE344]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Symbol class is used to create symbolic variables.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: Symbol类用于创建符号变量。
- en: 'Parameters:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**AtomicExpr: variable name**'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**AtomicExpr：变量名称**'
- en: '**Boolean: Assumption with a boolean value(True or False)**'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔值：带有布尔值(True或False)的假设**'
- en: Explanation
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Symbolic variables are placeholders for mathematical symbols that can represent
    numbers, constants, or any other mathematical entities and can be used in mathematical
    expressions and to perform symbolic computations.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 符号变量是数学符号的占位符，可以表示数字、常数或任何其他数学实体，并可用于数学表达式和进行符号计算。
- en: 'Assumptions:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 假设：
- en: commutative = True positive = True real = True imaginary = True complex = True
    complete list of more assumptions- [Predicates](assumptions/predicates.html#predicates)
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: commutative = True positive = True real = True imaginary = True complex = True
    完整列表的更多假设- [谓词](assumptions/predicates.html#predicates)
- en: You can override the default assumptions in the constructor.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在构造函数中覆盖默认假设。
- en: Examples
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE345]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'passing in greek letters:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 传入希腊字母：
- en: '[PRE346]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'Trailing digits are automatically treated like subscripts of what precedes
    them in the name. General format to add subscript to a symbol : `<var_name> =
    Symbol(''<symbol_name>_<subscript>'')`'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 尾随数字会自动视为前面名称中的下标。向符号添加下标的一般格式：<var_name> = Symbol('<symbol_name>_<subscript>')。
- en: '[PRE347]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: A Wild symbol matches anything, or anything without whatever is explicitly excluded.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: Wild符号可以匹配任何东西，或者不包含明确排除的内容。
- en: 'Parameters:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**name** : str'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '**name** : 字符串'
- en: Name of the Wild instance.
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Wild实例的名称。
- en: '**exclude** : iterable, optional'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**exclude** : 可迭代对象，可选'
- en: Instances in `exclude` will not be matched.
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exclude`中的实例将不会被匹配。'
- en: '**properties** : iterable of functions, optional'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**properties** : 函数的可迭代集合，可选'
- en: Functions, each taking an expressions as input and returns a `bool`. All functions
    in `properties` need to return `True` in order for the Wild instance to match
    the expression.
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数，每个函数以表达式作为输入并返回一个`bool`值。`properties`中的所有函数都需要返回`True`，以便Wild实例能够匹配表达式。
- en: Examples
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE349]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Tips
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'When using Wild, be sure to use the exclude keyword to make the pattern more
    precise. Without the exclude pattern, you may get matches that are technically
    correct, but not what you wanted. For example, using the above without exclude:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Wild时，请确保使用exclude关键字使模式更精确。没有exclude模式，您可能会获得在技术上正确但不符合预期的匹配项。例如，使用上述情况而没有exclude：
- en: '[PRE350]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: This is technically correct, because (2/x)*x + 3*y == 2 + 3*y, but you probably
    wanted it to not match at all. The issue is that you really did not want a and
    b to include x and y, and the exclude parameter lets you specify exactly this.
    With the exclude parameter, the pattern will not match.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术上是正确的，因为(2/x)*x + 3*y == 2 + 3*y，但您可能希望它根本不匹配。问题在于，您实际上不希望a和b包含x和y，并且exclude参数允许您精确指定这一点。使用exclude参数，该模式将不会匹配。
- en: '[PRE351]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: Exclude also helps remove ambiguity from matches.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: Exclude还有助于消除匹配的歧义。
- en: '[PRE352]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'Wild also accepts a `properties` parameter:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: Wild也接受一个`properties`参数：
- en: '[PRE353]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'Dummy symbols are each unique, even if they have the same name:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: Dummy符号是唯一的，即使它们具有相同的名称：
- en: Examples
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE355]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: If a name is not supplied then a string value of an internal count will be used.
    This is useful when a temporary variable is needed and the name of the variable
    used in the expression is not important.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供名称，则将使用内部计数的字符串值。当需要临时变量且表达式中使用的变量名称不重要时，这很有用。
- en: '[PRE356]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: Transform strings into instances of [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    class.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为[`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")类的实例。
- en: '[`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols") function
    returns a sequence of symbols with names taken from `names` argument, which can
    be a comma or whitespace delimited string, or a sequence of strings:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '[`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")函数返回从`names`参数获取名称的符号序列，该参数可以是逗号或空格分隔的字符串，或者是字符串序列：'
- en: '[PRE358]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'The type of output is dependent on the properties of input arguments:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类型取决于输入参数的属性：
- en: '[PRE359]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'If an iterable container is needed for a single symbol, set the `seq` argument
    to `True` or terminate the symbol name with a comma:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个单一符号的可迭代容器，则将`seq`参数设置为`True`或在符号名称末尾加上逗号：
- en: '[PRE360]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'To reduce typing, range syntax is supported to create indexed symbols. Ranges
    are indicated by a colon and the type of range is determined by the character
    to the right of the colon. If the character is a digit then all contiguous digits
    to the left are taken as the nonnegative starting value (or 0 if there is no digit
    left of the colon) and all contiguous digits to the right are taken as 1 greater
    than the ending value:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入，支持使用范围语法创建索引符号。范围由冒号表示，并且范围类型由冒号右侧的字符确定。如果该字符是数字，则将左侧所有连续的数字视为非负起始值（如果冒号左侧没有数字，则起始值为0），将右侧所有连续的数字视为结束值加1：
- en: '[PRE361]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'If the character to the right of the colon is a letter, then the single letter
    to the left (or ‘a’ if there is none) is taken as the start and all characters
    in the lexicographic range *through* the letter to the right are used as the range:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 如果冒号右侧的字符是字母，则左侧的单个字母（如果没有，则为‘a’）作为起始，并且使用字母范围中的所有字符*直到*右侧的字母作为范围：
- en: '[PRE362]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: 'Multiple ranges are supported; contiguous numerical ranges should be separated
    by parentheses to disambiguate the ending number of one range from the starting
    number of the next:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多个范围；应通过括号分隔连续的数值范围，以消除一个范围的结束数字与下一个范围的开始数字之间的歧义：
- en: '[PRE363]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'Only one pair of parentheses surrounding ranges are removed, so to include
    parentheses around ranges, double them. And to include spaces, commas, or colons,
    escape them with a backslash:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个括号包围的范围被删除，因此要包含括号周围的范围，请将它们双倍。要包含空格、逗号或冒号，请使用反斜杠进行转义：
- en: '[PRE364]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'All newly created symbols have assumptions set according to `args`:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新创建的符号都根据`args`设置了假设：
- en: '[PRE365]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'Despite its name, [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    can create symbol-like objects like instances of Function or Wild classes. To
    achieve this, set `cls` keyword argument to the desired type:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称如此，[`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")可以创建类似符号的对象，如Function或Wild类的实例。要实现此目的，请将`cls`关键字参数设置为所需类型：
- en: '[PRE366]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: Create symbols and inject them into the global namespace.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 创建符号并将它们注入全局命名空间。
- en: Explanation
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'This calls [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    with the same arguments and puts the results into the *global* namespace. It’s
    recommended not to use [`var()`](#sympy.core.symbol.var "sympy.core.symbol.var")
    in library code, where [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    has to be used:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用相同的参数调用 [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    并将结果放入*全局*命名空间。建议在库代码中不使用 [`var()`](#sympy.core.symbol.var "sympy.core.symbol.var")，而是使用
    [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")：
- en: '[PRE368]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'See [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols") documentation
    for more details on what kinds of arguments can be passed to [`var()`](#sympy.core.symbol.var
    "sympy.core.symbol.var").  ## intfunc'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '详见 [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols") 文档，了解可以传递给
    [`var()`](#sympy.core.symbol.var "sympy.core.symbol.var") 的参数类型详细信息。  ## intfunc'
- en: '[PRE373]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: Return the number of digits needed to express n in give base.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以给定基数表示n所需的位数。
- en: 'Parameters:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n: integer**'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**n: 整数**'
- en: The number whose digits are counted.
  id: totrans-1078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 被计算其位数的数字。
- en: '**b: integer**'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '**b: 整数**'
- en: The base in which digits are computed.
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算数字计算的基数。
- en: Examples
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE374]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: See also
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.ntheory.digits.digits`](ntheory.html#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits"),
    [`sympy.ntheory.digits.count_digits`](ntheory.html#sympy.ntheory.digits.count_digits
    "sympy.ntheory.digits.count_digits")'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.digits.digits`](ntheory.html#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits"),
    [`sympy.ntheory.digits.count_digits`](ntheory.html#sympy.ntheory.digits.count_digits
    "sympy.ntheory.digits.count_digits")'
- en: '[PRE375]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: Count the number of trailing zero digits in the binary representation of n,
    i.e. determine the largest power of 2 that divides n.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 计算n的二进制表示中末尾零位数的数量，即确定能整除n的最大2的幂次数。
- en: Examples
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE376]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: See also
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity")'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity")'
- en: '[PRE377]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: Computes integer least common multiple.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 计算整数的最小公倍数。
- en: Examples
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE378]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: Computes nonnegative integer greatest common divisor.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 计算非负整数的最大公约数。
- en: Explanation
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The algorithm is based on the well known Euclid’s algorithm [[R123]](#r123).
    To improve speed, `igcd()` has its own caching mechanism. If you do not need the
    cache mechanism, using `sympy.external.gmpy.gcd`.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法基于著名的欧几里得算法[[R123]](#r123)。为了提高速度，`igcd()`具有自己的缓存机制。如果不需要缓存机制，可以使用`sympy.external.gmpy.gcd`。
- en: Examples
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE380]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: References
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R123] ([1](#id22),[2](#id23))'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '[R123] ([1](#id22),[2](#id23))'
- en: '[https://en.wikipedia.org/wiki/Euclidean_algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euclidean_algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)'
- en: '[PRE381]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: Computes greatest common divisor of two integers.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 计算两个整数的最大公约数。
- en: Explanation
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Euclid’s algorithm for the computation of the greatest common divisor `gcd(a,
    b)` of two (positive) integers \(a\) and \(b\) is based on the division identity
    $$ a = q \times b + r$$, where the quotient \(q\) and the remainder \(r\) are
    integers and \(0 \le r < b\). Then each common divisor of \(a\) and \(b\) divides
    \(r\), and it follows that `gcd(a, b) == gcd(b, r)`. The algorithm works by constructing
    the sequence r0, r1, r2, …, where r0 = a, r1 = b, and each rn is the remainder
    from the division of the two preceding elements.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里德算法用于计算两个（正）整数 \(a\) 和 \(b\) 的最大公约数 `gcd(a, b)`，基于除法恒等式 $$ a = q \times b
    + r$$，其中商 \(q\) 和余数 \(r\) 是整数，且 \(0 \le r < b\)。然后，\(a\) 和 \(b\) 的每个公约数都可以整除 \(r\)，由此可知
    `gcd(a, b) == gcd(b, r)`。该算法通过构造序列 r0, r1, r2, …，其中 r0 = a，r1 = b，并且每个 rn 都是前两个元素的余数来实现。
- en: In Python, `q = a // b` and `r = a % b` are obtained by the floor division and
    the remainder operations, respectively. These are the most expensive arithmetic
    operations, especially for large a and b.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`q = a // b` 和 `r = a % b` 分别通过地板除法和取余操作获得。这些是最昂贵的算术操作，特别是对于大的 a 和
    b。
- en: Lehmer’s algorithm [[R124]](#r124) is based on the observation that the quotients
    `qn = r(n-1) // rn` are in general small integers even when a and b are very large.
    Hence the quotients can be usually determined from a relatively small number of
    most significant bits.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 利用观察到的商 `qn = r(n-1) // rn`，即使 a 和 b 非常大，勒默算法 [[R124]](#r124) 中的商通常也是小整数。因此，这些商通常可以从相对较少的最显著位确定。
- en: The efficiency of the algorithm is further enhanced by not computing each long
    remainder in Euclid’s sequence. The remainders are linear combinations of a and
    b with integer coefficients derived from the quotients. The coefficients can be
    computed as far as the quotients can be determined from the chosen most significant
    parts of a and b. Only then a new pair of consecutive remainders is computed and
    the algorithm starts anew with this pair.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不计算欧几里德序列中的每个长余数来进一步提高算法效率。余数是从选定的最显著部分的 a 和 b 导出的整数系数的线性组合。只有当从 a 和 b 的最显著部分确定了商后，才计算出新的一对连续余数，并且算法从这一对重新开始。
- en: References
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[R124] ([1](#id24),[2](#id25))'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '[R124] ([1](#id24),[2](#id25))'
- en: '[https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm](https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm)'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm](https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm)'
- en: '[PRE382]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: Returns x, y, g such that g = x*a + y*b = gcd(a, b).
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 x, y, g，使得 g = x*a + y*b = gcd(a, b)。
- en: Examples
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE383]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: Return the largest integer less than or equal to \(\sqrt{n}\).
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回不大于 \(\sqrt{n}\) 的最大整数。
- en: 'Parameters:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**n** : non-negative integer'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**n** : 非负整数'
- en: 'Returns:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**int** : \(\left\lfloor\sqrt{n}\right\rfloor\)'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数** : \(\left\lfloor\sqrt{n}\right\rfloor\)'
- en: 'Raises:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出：
- en: '**ValueError**'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: If n is negative.
  id: totrans-1127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 n 为负数。
- en: '**TypeError**'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型错误**'
- en: If n is of a type that cannot be compared to `int`. Therefore, a TypeError is
    raised for `str`, but not for `float`.
  id: totrans-1129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 n 的类型无法与 `int` 比较。因此，对于 `str` 报错 `TypeError`，但对于 `float` 则不会。
- en: Examples
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE386]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether
    the result is exact (that is, whether x**n == y).
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个元组，其中 x = \(\left\lfloor y^{(1/n)} \right\rfloor\)，并返回一个布尔值，指示结果是否精确（即，是否满足
    \(x^n == y\)）。
- en: Examples
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE388]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'To simply determine if a number is a perfect square, the is_square function
    should be used:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 若要简单确定一个数是否为完全平方数，应使用 is_square 函数：
- en: '[PRE389]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: See also
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square"), [`integer_log`](#sympy.core.intfunc.integer_log
    "sympy.core.intfunc.integer_log")'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square"), [`integer_log`](#sympy.core.intfunc.integer_log
    "sympy.core.intfunc.integer_log")'
- en: '[PRE390]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Returns `(e, bool)` where e is the largest nonnegative integer such that \(|n|
    \geq |b^e|\) and `bool` is True if \(n = b^e\).
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `(e, bool)`，其中 e 是最大非负整数，使得 \(|n| \geq |b^e|\)，并且 `bool` 为 True 如果 \(n =
    b^e\)。
- en: Examples
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE391]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'If the base is positive and the number negative the return value will always
    be the same except for 2:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底数为正数且数字为负数，则返回值除了 2 以外始终相同：
- en: '[PRE392]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'When the base is negative, the returned value will only be True if the parity
    of the exponent is correct for the sign of the base:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 当底数为负时，仅当指数的奇偶性符合底数的符号时，返回的值才为 True：
- en: '[PRE393]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: See also
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[`integer_nthroot`](#sympy.core.intfunc.integer_nthroot "sympy.core.intfunc.integer_nthroot"),
    [`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square"), [`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity"), [`sympy.ntheory.factor_.perfect_power`](ntheory.html#sympy.ntheory.factor_.perfect_power
    "sympy.ntheory.factor_.perfect_power")'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '[`integer_nthroot`](#sympy.core.intfunc.integer_nthroot "sympy.core.intfunc.integer_nthroot")，[`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square")，[`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity")，[`sympy.ntheory.factor_.perfect_power`](ntheory.html#sympy.ntheory.factor_.perfect_power
    "sympy.ntheory.factor_.perfect_power")'
- en: '[PRE394]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Return the number \(c\) such that, \(a \times c = 1 \pmod{m}\) where \(c\) has
    the same sign as \(m\). If no such value exists, a ValueError is raised.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数 \(c\)，使得 \(a \times c = 1 \pmod{m}\)，其中 \(c\) 与 \(m\) 的符号相同。如果不存在这样的值，则引发
    ValueError。
- en: Examples
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE395]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: 'Suppose we wish to find multiplicative inverse \(x\) of 3 modulo 11\. This
    is the same as finding \(x\) such that \(3x = 1 \pmod{11}\). One value of x that
    satisfies this congruence is 4\. Because \(3 \times 4 = 12\) and \(12 = 1 \pmod{11}\).
    This is the value returned by `mod_inverse`:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望找到模 11 下的数 3 的乘法逆元 \(x\)。这等同于找到 \(x\) 使得 \(3x = 1 \pmod{11}\)。满足这个同余的一个
    \(x\) 的值是 4。因为 \(3 \times 4 = 12\) 并且 \(12 = 1 \pmod{11}\)。这是 `mod_inverse` 返回的值：
- en: '[PRE396]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: 'When there is a common factor between the numerators of \(a\) and \(m\) the
    inverse does not exist:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(a\) 和 \(m\) 的分子之间有一个公因数时，逆元不存在：
- en: '[PRE397]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: References
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R125](#id26)]'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R125](#id26)]'
- en: '[https://en.wikipedia.org/wiki/Modular_multiplicative_inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '[模数乘法逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
- en: '[[R126](#id27)]'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R126](#id27)]'
- en: '[https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)  ##
    numbers'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展欧几里得算法](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)  ##
    numbers'
- en: '[PRE399]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Represents atomic numbers in SymPy.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 SymPy 中的原子数。
- en: Explanation
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Floating point numbers are represented by the Float class. Rational numbers
    (of any size) are represented by the Rational class. Integer numbers (of any size)
    are represented by the Integer class. Float and Rational are subclasses of Number;
    Integer is a subclass of Rational.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数由 Float 类表示。任意大小的有理数由 Rational 类表示。任意大小的整数由 Integer 类表示。Float 和 Rational
    是 Number 的子类；Integer 是 Rational 的子类。
- en: For example, `2/3` is represented as `Rational(2, 3)` which is a different object
    from the floating point number obtained with Python division `2/3`. Even for numbers
    that are exactly represented in binary, there is a difference between how two
    forms, such as `Rational(1, 2)` and `Float(0.5)`, are used in SymPy. The rational
    form is to be preferred in symbolic computations.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`2/3` 表示为 `Rational(2, 3)`，它与使用 Python 除法 `2/3` 得到的浮点数是不同的对象。即使对于在二进制中精确表示的数字，如
    `Rational(1, 2)` 和 `Float(0.5)`，它们在 SymPy 中的使用方式也有所不同。在符号计算中应优先选择有理数形式。
- en: Other kinds of numbers, such as algebraic numbers `sqrt(2)` or complex numbers
    `3 + 4*I`, are not instances of Number class as they are not atomic.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的数，如代数数 `sqrt(2)` 或复数 `3 + 4*I`，因为不是原子，所以不是 Number 类的实例。
- en: See also
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float"), [`Integer`](#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), [`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float")，[`Integer`](#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer")，[`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
- en: '[PRE400]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: Efficiently extract the coefficient of a summation.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取求和的系数。
- en: '[PRE401]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: Efficiently extract the coefficient of a product.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取乘积的系数。
- en: '[PRE402]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Compute GCD and cofactors of \(self\) and \(other\).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 \(self\) 和 \(other\) 的最大公约数及其余因子。
- en: '[PRE403]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: Compute GCD of \(self\) and \(other\).
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 \(self\) 和 \(other\) 的最大公约数。
- en: '[PRE404]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: Compute LCM of \(self\) and \(other\).
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 \(self\) 和 \(other\) 的最小公倍数。
- en: '[PRE405]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Represent a floating-point number of arbitrary precision.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 表示任意精度浮点数。
- en: Examples
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE406]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: Creating Floats from strings (and Python `int` and `long` types) will give a
    minimum precision of 15 digits, but the precision will automatically increase
    to capture all digits entered.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串（以及 Python 的 `int` 和 `long` 类型）创建浮点数将给出至少 15 位数的精度，但精度将自动增加以捕获输入的所有数字。
- en: '[PRE407]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: 'However, *floating-point* numbers (Python `float` types) retain only 15 digits
    of precision:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*浮点数*（Python 的 `float` 类型）只保留 15 位精度：
- en: '[PRE408]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: 'It may be preferable to enter high-precision decimal numbers as strings:'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将高精度的十进制数作为字符串输入：
- en: '[PRE409]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: 'The desired number of digits can also be specified:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以指定所需的数字位数：
- en: '[PRE410]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: Float can automatically count significant figures if a null string is sent for
    the precision; spaces or underscores are also allowed. (Auto- counting is only
    allowed for strings, ints and longs).
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将空字符串发送给精度，Float 可以自动计算有效数字；空格或下划线也是允许的。（自动计数仅适用于字符串、整数和长整数）。
- en: '[PRE411]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: 'If a number is written in scientific notation, only the digits before the exponent
    are considered significant if a decimal appears, otherwise the “e” signifies only
    how to move the decimal:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字用科学计数法写成，那么指数前的数字被认为是有效的，如果出现小数点，则“e”只表示如何移动小数点：
- en: '[PRE412]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: Notes
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Floats are inexact by their nature unless their value is a binary-exact value.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数本质上是不精确的，除非它们的值是二进制精确值。
- en: '[PRE413]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'For calculation purposes, evalf needs to be able to change the precision but
    this will not increase the accuracy of the inexact value. The following is the
    most accurate 5-digit approximation of a value of 0.1 that had only 1 digit of
    precision:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算目的，evalf 需要能够更改精度，但这不会增加不精确值的准确性。以下是一个值为 0.1 的最准确的 5 位近似值，只有 1 位精度：
- en: '[PRE414]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'By contrast, 0.125 is exact in binary (as it is in base 10) and so it can be
    passed to Float or evalf to obtain an arbitrary precision with matching accuracy:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，0.125 在二进制中是精确的（就像在十进制中一样），因此可以传递给 Float 或 evalf 以获得匹配精度的任意精度：
- en: '[PRE415]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'Trying to make a high-precision Float from a float is not disallowed, but one
    must keep in mind that the *underlying float* (not the apparent decimal value)
    is being obtained with high precision. For example, 0.3 does not have a finite
    binary representation. The closest rational is the fraction 5404319552844595/2**54\.
    So if you try to obtain a Float of 0.3 to 20 digits of precision you will not
    see the same thing as 0.3 followed by 19 zeros:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从浮点数创建高精度的 Float 不是不允许的，但必须记住正在以高精度获得*底层浮点数*（而不是表面的十进制值）。例如，0.3 没有有限的二进制表示。最接近的有理数是分数
    5404319552844595/2**54。因此，如果尝试获得 0.3 的 20 位精度的 Float，你将看不到与 0.3 后面跟着 19 个零的相同结果：
- en: '[PRE416]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: 'If you want a 20-digit value of the decimal 0.3 (not the floating point approximation
    of 0.3) you should send the 0.3 as a string. The underlying representation is
    still binary but a higher precision than Python’s float is used:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个 20 位数值的十进制 0.3（而不是浮点数近似值 0.3），你应该将 0.3 作为字符串发送。底层表示仍然是二进制，但使用的精度高于 Python
    的浮点数：
- en: '[PRE417]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'Although you can increase the precision of an existing Float using Float it
    will not increase the accuracy – the underlying value is not changed:'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用 Float 增加现有 Float 的精度，但这不会增加准确性 - 底层值不会改变：
- en: '[PRE418]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'The same thing happens when evalf is used on a Float:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Float 上使用 evalf 时也会发生同样的情况：
- en: '[PRE419]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'Finally, Floats can be instantiated with an mpf tuple (n, c, p) to produce
    the number (-1)**n*c*2**p:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 mpf 元组（n，c，p）实例化 Float，以产生数字 (-1)**n*c*2**p：
- en: '[PRE420]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: 'An actual mpf tuple also contains the number of bits in c as the last element
    of the tuple:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 mpf 元组还包含元组的最后一个元素中 c 的位数：
- en: '[PRE421]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: This is not needed for instantiation and is not the same thing as the precision.
    The mpf tuple and the precision are two separate quantities that Float tracks.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于实例化不是必需的，也不同于精度。mpf 元组和精度是 Float 跟踪的两个独立数量。
- en: 'In SymPy, a Float is a number that can be computed with arbitrary precision.
    Although floating point ‘inf’ and ‘nan’ are not such numbers, Float can create
    these numbers:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，Float 是可以用任意精度计算的数字。虽然浮点数 'inf' 和 'nan' 不是这样的数字，但 Float 可以创建这些数字：
- en: '[PRE422]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: Zero in Float only has a single value. Values are not separate for positive
    and negative zeroes.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数中的零只有一个值。正零和负零的值不是分开的。
- en: '[PRE423]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: Represents rational numbers (p/q) of any size.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 表示任意大小的有理数（p/q）。
- en: Examples
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE424]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'Rational is unprejudiced in accepting input. If a float is passed, the underlying
    value of the binary representation will be returned:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: Rational 在接受输入时是不偏见的。如果传递了一个浮点数，将返回二进制表示的底层值：
- en: '[PRE425]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: 'If the simpler representation of the float is desired then consider limiting
    the denominator to the desired value or convert the float to a string (which is
    roughly equivalent to limiting the denominator to 10**12):'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望获得浮点数的简化表示，则考虑将分母限制在所需值或将浮点数转换为字符串（这大致相当于将分母限制在 10**12）：
- en: '[PRE426]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'An arbitrarily precise Rational is obtained when a string literal is passed:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递字符串字面值时，将获得任意精度的有理数：
- en: '[PRE427]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'The conversion of other types of strings can be handled by the sympify() function,
    and conversion of floats to expressions or simple fractions can be handled with
    nsimplify:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的字符串可以通过 sympify() 函数进行转换，将浮点数转换为表达式或简单分数可以使用 nsimplify 处理：
- en: '[PRE428]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'But if the input does not reduce to a literal Rational, an error will be raised:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果输入不能简化为字面意义上的有理数，则会引发错误：
- en: '[PRE429]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: Low-level
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 低级
- en: 'Access numerator and denominator as .p and .q:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 访问分子和分母如 .p 和 .q：
- en: '[PRE430]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: 'Note that p and q return integers (not SymPy Integers) so some care is needed
    when using them in expressions:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 p 和 q 返回整数（而不是 SymPy 整数），因此在表达式中使用它们时需要注意：
- en: '[PRE431]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: If an unevaluated Rational is desired, `gcd=1` can be passed and this will keep
    common divisors of the numerator and denominator from being eliminated. It is
    not possible, however, to leave a negative value in the denominator.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要一个未评估的有理数，可以传递 `gcd=1`，这将保留分子和分母的公因数，不会被消除。然而，不能在分母中留下负值。
- en: '[PRE432]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: See also
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.sympify.sympify`](#sympy.core.sympify.sympify "sympy.core.sympify.sympify"),
    [`sympy.simplify.simplify.nsimplify`](simplify/simplify.html#sympy.simplify.simplify.nsimplify
    "sympy.simplify.simplify.nsimplify")'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.sympify.sympify`](#sympy.core.sympify.sympify "sympy.core.sympify.sympify")，[`sympy.simplify.simplify.nsimplify`](simplify/simplify.html#sympy.simplify.simplify.nsimplify
    "sympy.simplify.simplify.nsimplify")'
- en: '[PRE433]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: Efficiently extract the coefficient of a summation.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取求和的系数。
- en: '[PRE434]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: Efficiently extract the coefficient of a product.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取乘积的系数。
- en: '[PRE435]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组 (R, self/R)，其中 R 是从 self 提取的正有理数。
- en: Examples
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE436]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: See docstring of Expr.as_content_primitive for more examples.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Expr.as_content_primitive 的文档字符串以获取更多示例。
- en: '[PRE437]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: A wrapper to factorint which return factors of self that are smaller than limit
    (or cheap to compute). Special methods of factoring are disabled by default so
    that only trial division is used.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个封装到 factorint 的包装器，返回小于限制值（或便宜计算的）的 self 的因子。默认情况下禁用特殊的因子分解方法，因此仅使用试除法。
- en: '[PRE438]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Closest Rational to self with denominator at most max_denominator.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 最接近 self 的有理数，其分母最多为 max_denominator。
- en: Examples
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE439]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: Represents integer numbers of any size.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 表示任意大小的整数。
- en: Examples
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE441]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: If a float or a rational is passed to Integer, the fractional part will be discarded;
    the effect is of rounding toward zero.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递浮点数或有理数给 Integer，则会丢弃其小数部分；效果相当于向零舍入。
- en: '[PRE442]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'A string is acceptable input if it can be parsed as an integer:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串可以解析为整数，则接受字符串作为输入：
- en: '[PRE443]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: It is rarely needed to explicitly instantiate an Integer, because Python integers
    are automatically converted to Integer when they are used in SymPy expressions.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 很少需要显式实例化 Integer，因为在 SymPy 表达式中使用 Python 整数时会自动转换为 Integer。
- en: '[PRE444]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: Class for representing algebraic numbers in SymPy.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 SymPy 中代数数的类。
- en: Symbolically, an instance of this class represents an element \(\alpha \in \mathbb{Q}(\theta)
    \hookrightarrow \mathbb{C}\). That is, the algebraic number \(\alpha\) is represented
    as an element of a particular number field \(\mathbb{Q}(\theta)\), with a particular
    embedding of this field into the complex numbers.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 符号上，该类的一个实例表示一个元素 \(\alpha \in \mathbb{Q}(\theta) \hookrightarrow \mathbb{C}\)。也就是说，代数数
    \(\alpha\) 被表示为特定数域 \(\mathbb{Q}(\theta)\) 的一个元素，这个数域以一种特定的方式嵌入到复数域中。
- en: 'Formally, the primitive element \(\theta\) is given by two data points: (1)
    its minimal polynomial (which defines \(\mathbb{Q}(\theta)\)), and (2) a particular
    complex number that is a root of this polynomial (which defines the embedding
    \(\mathbb{Q}(\theta) \hookrightarrow \mathbb{C}\)). Finally, the algebraic number
    \(\alpha\) which we represent is then given by the coefficients of a polynomial
    in \(\theta\).'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，原始元素 \(\theta\) 由两个数据点给出：（1）其最小多项式（定义了 \(\mathbb{Q}(\theta)\)），以及（2）作为该多项式根的特定复数（定义了嵌入
    \(\mathbb{Q}(\theta) \hookrightarrow \mathbb{C}\)）。最后，我们表示的代数数 \(\alpha\) 是由 \(\theta\)
    的多项式的系数给出的。
- en: '[PRE445]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: Construct a new algebraic number \(\alpha\) belonging to a number field \(k
    = \mathbb{Q}(\theta)\).
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个属于数域 \( k = \mathbb{Q}(\theta) \) 的新代数数 \(\alpha\)。
- en: 'There are four instance attributes to be determined:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个待确定的实例属性：
- en: '| Attribute | Type/Meaning |'
  id: totrans-1275
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 类型/含义 |'
- en: '| --- | --- |'
  id: totrans-1276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `root` | [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr") for \(\theta\)
    as a complex number |'
  id: totrans-1277
  prefs: []
  type: TYPE_TB
  zh: '| `root` | 表示\(\theta\)为复数的[`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")'
- en: '| `minpoly` | [`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    the minimal polynomial of \(\theta\) |'
  id: totrans-1278
  prefs: []
  type: TYPE_TB
  zh: '| `minpoly` | [`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")，\(\theta\)的最小多项式
    |'
- en: '| `rep` | [`DMP`](polys/domainsref.html#sympy.polys.polyclasses.DMP "sympy.polys.polyclasses.DMP")
    giving \(\alpha\) as poly in \(\theta\) |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
  zh: '| `rep` | [`DMP`](polys/domainsref.html#sympy.polys.polyclasses.DMP "sympy.polys.polyclasses.DMP")
    将\(\alpha\)表示为\(\theta\)的多项式 |'
- en: '| `alias` | [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    for \(\theta\), or `None` |'
  id: totrans-1280
  prefs: []
  type: TYPE_TB
  zh: '| `alias` | [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    代表\(\theta\)，或者为`None` |'
- en: See Parameters section for how they are determined.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 参见参数部分以了解它们是如何确定的。
- en: 'Parameters:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr"), or pair
    \((m, r)\)'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr** : [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")，或者是对\((m,
    r)\)的一对'
- en: There are three distinct modes of construction, depending on what is passed
    as *expr*.
  id: totrans-1284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有三种不同的构造模式，具体取决于作为*expr*传递的内容。
- en: ''
  id: totrans-1285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(1)** *expr* is an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber"): In this case we begin by copying all four
    instance attributes from *expr*. If *coeffs* were also given, we compose the two
    coeff polynomials (see below). If an *alias* was given, it overrides.'
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**(1)** *expr* 是一个[`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")：在这种情况下，我们首先从*expr*复制所有四个实例属性。如果也提供了*coeffs*，我们将组合这两个系数多项式（见下文）。如果提供了*alias*，则覆盖之。'
- en: ''
  id: totrans-1287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(2)** *expr* is any other type of [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr"):
    Then `root` will equal *expr*. Therefore it must express an algebraic quantity,
    and we will compute its `minpoly`.'
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**(2)** *expr* 是任何其他类型的[`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")：那么`root`将等于*expr*。因此，它必须表达一个代数量，并且我们将计算其`minpoly`。'
- en: ''
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(3)** *expr* is an ordered pair \((m, r)\) giving the `minpoly` \(m\), and
    a `root` \(r\) thereof, which together define \(\theta\). In this case \(m\) may
    be either a univariate [`Poly`](polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") or any [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")
    which represents the same, while \(r\) must be some [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") representing a complex number that is a root of \(m\),
    including both explicit expressions in radicals, and instances of [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") or [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").'
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**(3)** *expr* 是有序对\((m, r)\)，给出`minpoly` \(m\)，及其根`root` \(r\)，二者共同定义了\(\theta\)。在这种情况下，\(m\)可以是一个单变量的[`Poly`](polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")，或者任何表示相同含义的[`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")，而\(r\)必须是某个表示\(m\)根的[`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr")，包括根据复数的明确表达式以及[`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")或[`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber")的实例。'
- en: '**coeffs** : list, [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), None, optional (default=None)'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '**coeffs** : 列表，[`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")，默认为None（可选）'
- en: This defines `rep`, giving the algebraic number \(\alpha\) as a polynomial in
    \(\theta\).
  id: totrans-1292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这定义了`rep`，将代数数\(\alpha\)表示为\(\theta\)的多项式。
- en: ''
  id: totrans-1293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a list, the elements should be integers or rational numbers. If an [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), we take its coefficients (using its [`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list") method). If `None`, then the list of coefficients
    defaults to `[1, 0]`, meaning that \(\alpha = \theta\) is the primitive element
    of the field.
  id: totrans-1294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是列表，则元素应为整数或有理数。如果是[`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")，则使用其[`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list")方法获取其系数。如果为`None`，则系数列表默认为`[1, 0]`，这意味着\(\alpha
    = \theta\)是域的原始元素。
- en: ''
  id: totrans-1295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If *expr* was an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber"),
    let \(g(x)\) be its `rep` polynomial, and let \(f(x)\) be the polynomial defined
    by *coeffs*. Then `self.rep` will represent the composition \((f \circ g)(x)\).
  id: totrans-1296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 *expr* 是一个 [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")，让
    \(g(x)\) 是它的 `rep` 多项式，让 \(f(x)\) 是由 *coeffs* 定义的多项式。那么 `self.rep` 将表示组合 \((f
    \circ g)(x)\)。
- en: '**alias** : str, [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    None, optional (default=None)'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '**alias**：字符串，[`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")，默认为
    `None`，可选（默认值为 `None`）'
- en: This is a way to provide a name for the primitive element. We described several
    ways in which the *expr* argument can define the value of the primitive element,
    but none of these methods gave it a name. Here, for example, *alias* could be
    set as `Symbol('theta')`, in order to make this symbol appear when \(\alpha\)
    is printed, or rendered as a polynomial, using the [`as_poly()`](#sympy.core.numbers.AlgebraicNumber.as_poly
    "sympy.core.numbers.AlgebraicNumber.as_poly") method.
  id: totrans-1298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是为原始元素提供名称的一种方法。我们描述了 *expr* 参数定义原始元素值的几种方式，但是没有一种方法给它起一个名字。例如，在这里，*alias*
    可以设置为 `Symbol('theta')`，以便在打印 \(\alpha\) 或使用 [`as_poly()`](#sympy.core.numbers.AlgebraicNumber.as_poly
    "sympy.core.numbers.AlgebraicNumber.as_poly") 方法渲染为多项式时出现该符号。
- en: Examples
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: Recall that we are constructing an algebraic number as a field element \(\alpha
    \in \mathbb{Q}(\theta)\).
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们正在构造一个代数数作为域元素 \(\alpha \in \mathbb{Q}(\theta)\)。
- en: '[PRE446]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: 'Example (1): \(\alpha = \theta = \sqrt{2}\)'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（1）：\(\alpha = \theta = \sqrt{2}\)
- en: '[PRE447]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'Example (2): \(\alpha = 3 \sqrt{2} - 5\), \(\theta = \sqrt{2}\). We can either
    build on the last example:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（2）：\(\alpha = 3 \sqrt{2} - 5\), \(\theta = \sqrt{2}\)。我们可以继续上一个示例：
- en: '[PRE448]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'or start from scratch:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从头开始：
- en: '[PRE449]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: 'Example (3): \(\alpha = 6 \sqrt{2} - 11\), \(\theta = \sqrt{2}\). Again we
    can build on the previous example, and we see that the coeff polys are composed:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（3）：\(\alpha = 6 \sqrt{2} - 11\), \(\theta = \sqrt{2}\)。同样，我们可以基于前一个示例，并且我们看到系数多项式是组合的：
- en: '[PRE450]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: reflecting the fact that \((2x - 1) \circ (3x - 5) = 6x - 11\).
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 反映了事实，即 \((2x - 1) \circ (3x - 5) = 6x - 11\)。
- en: 'Example (4): \(\alpha = \sqrt{2}\), \(\theta = \sqrt{2} + \sqrt{3}\). The easiest
    way is to use the [`to_number_field()`](polys/numberfields.html#sympy.polys.numberfields.subfield.to_number_field
    "sympy.polys.numberfields.subfield.to_number_field") function:'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（4）：\(\alpha = \sqrt{2}\)，\(\theta = \sqrt{2} + \sqrt{3}\)。最简单的方法是使用 [`to_number_field()`](polys/numberfields.html#sympy.polys.numberfields.subfield.to_number_field
    "sympy.polys.numberfields.subfield.to_number_field") 函数：
- en: '[PRE451]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'but if you already knew the right coefficients, you could construct it directly:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你已经知道了正确的系数，你可以直接构造它：
- en: '[PRE452]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Example (5): Construct the Golden Ratio as an element of the 5th cyclotomic
    field, supposing we already know its coefficients. This time we introduce the
    alias \(\zeta\) for the primitive element of the field:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（5）：在第五旋轉数域中构造黄金比例作为一个元素，假设我们已经知道它的系数。这次我们引入别名 \(\zeta\) 作为该域的原始元素：
- en: '[PRE453]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: (The index `-1` to `CRootOf` selects the complex root with the largest real
    and imaginary parts, which in this case is \(\mathrm{e}^{2i\pi/5}\). See [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").)
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: （索引 `-1` 到 `CRootOf` 选择具有最大实部和虚部的复数根，这种情况下是 \(\mathrm{e}^{2i\pi/5}\)。参见 [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")。）
- en: 'Example (6): Building on the last example, construct the number \(2 \phi \in
    \mathbb{Q}(\phi)\), where \(\phi\) is the Golden Ratio:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 示例（6）：在上一个示例的基础上，构造数 \(2 \phi \in \mathbb{Q}(\phi)\)，其中 \(\phi\) 是黄金比例：
- en: '[PRE454]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: 'Note that we needed to use `a5.to_root()`, since passing `a5` as the first
    argument would have constructed the number \(2 \phi\) as an element of the field
    \(\mathbb{Q}(\zeta)\):'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要使用 `a5.to_root()`，因为将 `a5` 作为第一个参数传递会将数 \(2 \phi\) 构造为域 \(\mathbb{Q}(\zeta)\)
    的一个元素：
- en: '[PRE455]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: Create a Basic expression from `self`.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `self` 创建一个基本表达式。
- en: '[PRE457]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: Create a Poly instance from `self`.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `self` 创建一个 Poly 实例。
- en: '[PRE458]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: Returns all SymPy coefficients of an algebraic number.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 返回代数数的所有 SymPy 系数。
- en: '[PRE459]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Form another element of the same number field.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 以同一数域的另一个元素形式。
- en: 'Parameters:'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**coeffs** : list, [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '**coeffs**：列表，[`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")'
- en: Like the *coeffs* arg to the class [`constructor`](#sympy.core.numbers.AlgebraicNumber.__new__
    "sympy.core.numbers.AlgebraicNumber.__new__"), defines the new element as a polynomial
    in the primitive element.
  id: totrans-1332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类似于类 [`构造器`](#sympy.core.numbers.AlgebraicNumber.__new__ "sympy.core.numbers.AlgebraicNumber.__new__")
    的 *coeffs* 参数，将新元素定义为原始元素的多项式。
- en: ''
  id: totrans-1333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a list, the elements should be integers or rational numbers. If an [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), we take its coefficients (using its [`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list") method).
  id: totrans-1334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是列表，则其元素应为整数或有理数。如果是 [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")，我们使用其系数（使用其 [`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list") 方法）。
- en: Explanation
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If we represent \(\alpha \in \mathbb{Q}(\theta)\), form another element \(\beta
    \in \mathbb{Q}(\theta)\) of the same number field.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们表示 \(\alpha \in \mathbb{Q}(\theta)\)，构造另一个属于同一数域 \(\mathbb{Q}(\theta)\)
    的元素 \(\beta\)。
- en: Examples
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE460]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: See also
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '[`代数数`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")'
- en: '[PRE461]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: Returns `True` if `alias` was set.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `alias`，则返回 `True`。
- en: '[PRE462]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: Say whether this algebraic number \(\alpha \in \mathbb{Q}(\theta)\) is equal
    to the primitive element \(\theta\) for its field.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 判断此代数数 \(\alpha \in \mathbb{Q}(\theta)\) 是否等于其数域的原始元素 \(\theta\)。
- en: '[PRE463]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: Compute the minimal polynomial for this algebraic number.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 计算此代数数的最小多项式。
- en: Explanation
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Recall that we represent an element \(\alpha \in \mathbb{Q}(\theta)\). Our instance
    attribute `self.minpoly` is the minimal polynomial for our primitive element \(\theta\).
    This method computes the minimal polynomial for \(\alpha\).
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们表示一个元素 \(\alpha \in \mathbb{Q}(\theta)\)。我们的实例属性 `self.minpoly` 是我们原始元素
    \(\theta\) 的最小多项式。此方法计算 \(\alpha\) 的最小多项式。
- en: '[PRE464]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: Returns all native coefficients of an algebraic number.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个代数数的所有本地系数。
- en: '[PRE465]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: Get the primitive element \(\theta\) for the number field \(\mathbb{Q}(\theta)\)
    to which this algebraic number \(\alpha\) belongs.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数域 \(\mathbb{Q}(\theta)\) 中此代数数 \(\alpha\) 所属的原始元素 \(\theta\)。
- en: 'Returns:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: AlgebraicNumber
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数
- en: '[PRE466]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Convert `self` to an algebraic integer.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `self` 转换为代数整数。
- en: '[PRE467]'
  id: totrans-1357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: Convert `self` to an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") instance that is equal to its own primitive
    element.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `self` 转换为一个 [`代数数`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    实例，该实例等于其自身的原始元素。
- en: 'Parameters:'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**radicals** : boolean, optional (default=True)'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '**根式**：布尔值，可选（默认为True）'
- en: If `True`, then we will try to return an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") whose `root` is an expression in radicals.
    If that is not possible (or if *radicals* is `False`), `root` will be a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").
  id: totrans-1361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为 `True`，则我们将尝试返回一个根式表达式中的 [`代数数`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")。如果不可能（或者
    *radicals* 为 `False`），则 `root` 将是 [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")。
- en: 'Returns:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: AlgebraicNumber
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数
- en: Explanation
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If we represent \(\alpha \in \mathbb{Q}(\theta)\), \(\alpha \neq \theta\), construct
    a new [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    that represents \(\alpha \in \mathbb{Q}(\alpha)\).
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们表示 \(\alpha \in \mathbb{Q}(\theta)\)，\(\alpha \neq \theta\)，构造一个新的 [`代数数`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") 来表示 \(\alpha \in \mathbb{Q}(\alpha)\)。
- en: Examples
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE468]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: The [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    `a` represents the number \(\sqrt{2}\) in the field \(\mathbb{Q}(\sqrt{2} + \sqrt{3})\).
    Rendering `a` as a polynomial,
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '[`代数数`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    `a` 在域 \(\mathbb{Q}(\sqrt{2} + \sqrt{3})\) 中代表数字 \(\sqrt{2}\)。将 `a` 渲染为多项式，'
- en: '[PRE469]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: reflects the fact that \(\sqrt{2} = \theta^3/2 - 9 \theta/2\), where \(\theta
    = \sqrt{2} + \sqrt{3}\).
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 反映了 \(\sqrt{2} = \theta^3/2 - 9 \theta/2\) 这一事实，其中 \(\theta = \sqrt{2} + \sqrt{3}\)。
- en: '`a` is not equal to its own primitive element. Its minpoly'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 不等于其自身的原始元素。其最小多项式'
- en: '[PRE470]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: is that of \(\theta\).
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 是关于 \(\theta\) 的。
- en: Converting to a primitive element,
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为一个原始元素，
- en: '[PRE471]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: we obtain an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    whose `minpoly` is that of the number itself.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个 [`代数数`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")，其
    `minpoly` 与该数本身相同。
- en: See also
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`is_primitive_element`](#sympy.core.numbers.AlgebraicNumber.is_primitive_element
    "sympy.core.numbers.AlgebraicNumber.is_primitive_element")'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '[`is_primitive_element`](#sympy.core.numbers.AlgebraicNumber.is_primitive_element
    "sympy.core.numbers.AlgebraicNumber.is_primitive_element")'
- en: '[PRE472]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: Convert to an [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr") that is
    not an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber"),
    specifically, either a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf"), or, optionally and where possible, an
    expression in radicals.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为一个 [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")，而不是一个 [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber")，具体来说，要么是 [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")，或者在可能的情况下是一个根式表达式。
- en: 'Parameters:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**radicals** : boolean, optional (default=True)'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '**radicals**：布尔值，可选（默认为 True）'
- en: If `True`, then we will try to return the root as an expression in radicals.
    If that is not possible, we will return a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为 `True`，则尝试返回根式表达式的根。如果不可能，将返回一个 [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")。
- en: '**minpoly** : [`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**minpoly**：[`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")'
- en: If the minimal polynomial for \(self\) has been pre-computed, it can be passed
    in order to save time.
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果已经预先计算了 `self` 的最小多项式，则可以传入以节省时间。
- en: '[PRE473]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: Return an interval with number_cls endpoints that contains the value of NumberSymbol.
    If not implemented, then return None.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含 NumberSymbol 值的 number_cls 端点的区间。如果未实现，则返回 None。
- en: '[PRE475]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: alias of [`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float")
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为 [`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float")
- en: '[PRE476]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: Should SymPy raise an exception on 0/0 or return a nan?
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 是否应在 0/0 时抛出异常或返回 NaN？
- en: divide == True …. raise an exception divide == False … return nan
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: divide == True …. 抛出异常 divide == False … 返回 NaN
- en: '[PRE477]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: The number zero.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 数字零。
- en: Zero is a singleton, and can be accessed by `S.Zero`
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: Zero 是一个单例，可以通过 `S.Zero` 访问。
- en: Examples
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE478]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: References
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R127](#id28)]'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R127](#id28)]'
- en: '[https://en.wikipedia.org/wiki/Zero](https://en.wikipedia.org/wiki/Zero)'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Zero](https://en.wikipedia.org/wiki/Zero)'
- en: '[PRE479]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: The number one.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 数字一。
- en: One is a singleton, and can be accessed by `S.One`.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: One 是一个单例，可以通过 `S.One` 访问。
- en: Examples
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE480]'
  id: totrans-1406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: References
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R128](#id29)]'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R128](#id29)]'
- en: '[https://en.wikipedia.org/wiki/1_%28number%29](https://en.wikipedia.org/wiki/1_%28number%29)'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/1_%28number%29](https://en.wikipedia.org/wiki/1_%28number%29)'
- en: '[PRE481]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: The number negative one.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 数字负一。
- en: NegativeOne is a singleton, and can be accessed by `S.NegativeOne`.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: NegativeOne 是一个单例，可以通过 `S.NegativeOne` 访问。
- en: Examples
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE482]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: See also
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`One`](#sympy.core.numbers.One "sympy.core.numbers.One")'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '[`One`](#sympy.core.numbers.One "sympy.core.numbers.One")'
- en: References
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R129](#id30)]'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R129](#id30)]'
- en: '[https://en.wikipedia.org/wiki/%E2%88%921_%28number%29](https://en.wikipedia.org/wiki/%E2%88%921_%28number%29)'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/%E2%88%921_%28number%29](https://en.wikipedia.org/wiki/%E2%88%921_%28number%29)'
- en: '[PRE483]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: The rational number 1/2.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数 1/2。
- en: Half is a singleton, and can be accessed by `S.Half`.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: Half 是一个单例，可以通过 `S.Half` 访问。
- en: Examples
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE484]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: References
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R130](#id31)]'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R130](#id31)]'
- en: '[https://en.wikipedia.org/wiki/One_half](https://en.wikipedia.org/wiki/One_half)'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/One_half](https://en.wikipedia.org/wiki/One_half)'
- en: '[PRE485]'
  id: totrans-1428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: Not a Number.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 非数字。
- en: Explanation
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This serves as a place holder for numeric values that are indeterminate. Most
    operations on NaN, produce another NaN. Most indeterminate forms, such as `0/0`
    or [PRE486] and `oo**0`, which all produce `1` (this is consistent with Python’s
    float).
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 这用作不定数的数值占位符。NaN 的大多数运算会产生另一个 NaN。大多数不定形式，如 `0/0` 或 [PRE486] 和 `oo**0`，都会产生
    `1`（这与 Python 的浮点数一致）。
- en: NaN is loosely related to floating point nan, which is defined in the IEEE 754
    floating point standard, and corresponds to the Python `float('nan')`. Differences
    are noted below.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: NaN 与浮点数的 nan 松散相关，后者在 IEEE 754 浮点数标准中定义，并对应于 Python 的 `float('nan')`。下面会说明它们的差异。
- en: NaN is mathematically not equal to anything else, even NaN itself. This explains
    the initially counter-intuitive results with `Eq` and `==` in the examples below.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: NaN 在数学上与任何其他值都不相等，甚至不等于自身。这解释了下面示例中 `Eq` 和 `==` 的最初反直觉结果。
- en: NaN is not comparable so inequalities raise a TypeError. This is in contrast
    with floating point nan where all inequalities are false.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: NaN 不可比较，因此不等式会引发 TypeError。这与浮点数的 nan 不同，后者所有不等式均为假。
- en: NaN is a singleton, and can be accessed by `S.NaN`, or can be imported as `nan`.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: NaN 是一个单例，可以通过 `S.NaN` 访问，或者可以导入为 `nan`。
- en: Examples
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE487]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: References
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R131](#id32)]'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R131](#id32)]'
- en: '[https://en.wikipedia.org/wiki/NaN](https://en.wikipedia.org/wiki/NaN)'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/NaN](https://en.wikipedia.org/wiki/NaN)'
- en: '[PRE488]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: Positive infinite quantity.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 正无穷大量。
- en: Explanation
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'In real analysis the symbol \(\infty\) denotes an unbounded limit: \(x\to\infty\)
    means that \(x\) grows without bound.'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 在实分析中，符号 \(\infty\) 表示无界极限：\(x\to\infty\) 意味着 \(x\) 增长无限。
- en: Infinity is often used not only to define a limit but as a value in the affinely
    extended real number system. Points labeled \(+\infty\) and \(-\infty\) can be
    added to the topological space of the real numbers, producing the two-point compactification
    of the real numbers. Adding algebraic properties to this gives us the extended
    real numbers.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 无穷大常被用来不仅定义极限，而且作为扩展实数系统中的一个值。标记为 \(+\infty\) 和 \(-\infty\) 的点可以添加到实数的拓扑空间中，从而产生实数的二点紧致化。在此基础上添加代数属性给我们扩展了的实数。
- en: Infinity is a singleton, and can be accessed by `S.Infinity`, or can be imported
    as `oo`.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: Infinity 是一个单例，可以通过 `S.Infinity` 访问，或者可以导入为 `oo`。
- en: Examples
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE489]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: See also
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
- en: References
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R132](#id33)]'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R132](#id33)]'
- en: '[https://en.wikipedia.org/wiki/Infinity](https://en.wikipedia.org/wiki/Infinity)'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Infinity](https://en.wikipedia.org/wiki/Infinity)'
- en: '[PRE490]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: Negative infinite quantity.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 负无穷大量。
- en: NegativeInfinity is a singleton, and can be accessed by `S.NegativeInfinity`.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: NegativeInfinity 是一个单例，可以通过 `S.NegativeInfinity` 访问。
- en: See also
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
- en: '[PRE491]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Complex infinity.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 复数无穷大。
- en: Explanation
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: In complex analysis the symbol \(\tilde\infty\), called “complex infinity”,
    represents a quantity with infinite magnitude, but undetermined complex phase.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在复分析中，符号 \(\tilde\infty\)，称为“复无穷大”，表示具有无限大小但未确定复相位的量。
- en: ComplexInfinity is a singleton, and can be accessed by `S.ComplexInfinity`,
    or can be imported as `zoo`.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: ComplexInfinity 是一个单例，可以通过 `S.ComplexInfinity` 访问，或者可以导入为 `zoo`。
- en: Examples
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE492]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: See also
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
- en: '[PRE493]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: The \(e\) constant.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: \(e\) 常数。
- en: Explanation
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The transcendental number \(e = 2.718281828\ldots\) is the base of the natural
    logarithm and of the exponential function, \(e = \exp(1)\). Sometimes called Euler’s
    number or Napier’s constant.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 超越数 \(e = 2.718281828\ldots\) 是自然对数和指数函数的底数，\(e = \exp(1)\)。有时称为欧拉数或纳皮尔常数。
- en: Exp1 is a singleton, and can be accessed by `S.Exp1`, or can be imported as
    `E`.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: Exp1 是一个单例，可以通过 `S.Exp1` 访问，或者可以导入为 `E`。
- en: Examples
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE494]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: References
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R133](#id34)]'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R133](#id34)]'
- en: '[https://en.wikipedia.org/wiki/E_%28mathematical_constant%29](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/E_%28mathematical_constant%29](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)'
- en: '[PRE495]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: The imaginary unit, \(i = \sqrt{-1}\).
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 虚数单位，\(i = \sqrt{-1}\)。
- en: I is a singleton, and can be accessed by `S.I`, or can be imported as `I`.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: I 是一个单例，可以通过 `S.I` 访问，或者可以导入为 `I`。
- en: Examples
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE496]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: References
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R134](#id35)]'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R134](#id35)]'
- en: '[https://en.wikipedia.org/wiki/Imaginary_unit](https://en.wikipedia.org/wiki/Imaginary_unit)'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Imaginary_unit](https://en.wikipedia.org/wiki/Imaginary_unit)'
- en: '[PRE497]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: The \(\pi\) constant.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周率 \(\pi\) 常数。
- en: Explanation
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The transcendental number \(\pi = 3.141592654\ldots\) represents the ratio of
    a circle’s circumference to its diameter, the area of the unit circle, the half-period
    of trigonometric functions, and many other things in mathematics.
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 超越数 \(\pi = 3.141592654\ldots\) 表示圆周率与其直径的比率，单位圆的面积，三角函数的半周期以及数学中的许多其他内容。
- en: Pi is a singleton, and can be accessed by `S.Pi`, or can be imported as `pi`.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周率是一个单例，可以通过 `S.Pi` 访问，或者可以导入为 `pi`。
- en: Examples
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE498]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: References
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R135](#id36)]'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R135](#id36)]'
- en: '[https://en.wikipedia.org/wiki/Pi](https://en.wikipedia.org/wiki/Pi)'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Pi](https://en.wikipedia.org/wiki/Pi)'
- en: '[PRE499]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: The Euler-Mascheroni constant.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-马斯切罗尼常数。
- en: Explanation
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '\(\gamma = 0.5772157\ldots\) (also called Euler’s constant) is a mathematical
    constant recurring in analysis and number theory. It is defined as the limiting
    difference between the harmonic series and the natural logarithm:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: \(\gamma = 0.5772157\ldots\)（也称为欧拉常数）是分析和数论中经常出现的数学常数。它被定义为调和级数与自然对数之间的极限差：
- en: \[\gamma = \lim\limits_{n\to\infty} \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln
    n\right)\]
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: \[\gamma = \lim\limits_{n\to\infty} \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln
    n\right)\]
- en: EulerGamma is a singleton, and can be accessed by `S.EulerGamma`.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉-马斯谢罗常数是一个单例，可以通过 `S.EulerGamma` 访问。
- en: Examples
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE500]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: References
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R136](#id37)]'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R136](#id37)]'
- en: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant)'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant)'
- en: '[PRE501]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: Catalan’s constant.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 卡塔兰常数。
- en: Explanation
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: \(G = 0.91596559\ldots\) is given by the infinite series
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: \(G = 0.91596559\ldots\) 是由无限级数给出的
- en: \[G = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}\]
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: \[G = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}\]
- en: Catalan is a singleton, and can be accessed by `S.Catalan`.
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 卡塔兰常数是一个单例，可以通过 `S.Catalan` 访问。
- en: Examples
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE502]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: References
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R137](#id38)]'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R137](#id38)]'
- en: '[https://en.wikipedia.org/wiki/Catalan%27s_constant](https://en.wikipedia.org/wiki/Catalan%27s_constant)'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Catalan%27s_constant](https://en.wikipedia.org/wiki/Catalan%27s_constant)'
- en: '[PRE503]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: The golden ratio, \(\phi\).
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金比例，\(\phi\)。
- en: Explanation
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: \(\phi = \frac{1 + \sqrt{5}}{2}\) is an algebraic number. Two quantities are
    in the golden ratio if their ratio is the same as the ratio of their sum to the
    larger of the two quantities, i.e. their maximum.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: \(\phi = \frac{1 + \sqrt{5}}{2}\) 是一个代数数。如果两个量的比率等于它们的和与较大量的比率，那么它们就处于黄金比例，即它们的最大量。
- en: GoldenRatio is a singleton, and can be accessed by `S.GoldenRatio`.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金比例是一个单例，可以通过 `S.GoldenRatio` 访问。
- en: Examples
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE504]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: References
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R138](#id39)]'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R138](#id39)]'
- en: '[https://en.wikipedia.org/wiki/Golden_ratio](https://en.wikipedia.org/wiki/Golden_ratio)'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Golden_ratio](https://en.wikipedia.org/wiki/Golden_ratio)'
- en: '[PRE505]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: The tribonacci constant.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 三波那契常数。
- en: Explanation
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The tribonacci numbers are like the Fibonacci numbers, but instead of starting
    with two predetermined terms, the sequence starts with three predetermined terms
    and each term afterwards is the sum of the preceding three terms.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 三波那契数类似于斐波那契数，但是不是从两个预定项开始，而是从三个预定项开始，后面的每一项是前三项的和。
- en: The tribonacci constant is the ratio toward which adjacent tribonacci numbers
    tend. It is a root of the polynomial \(x^3 - x^2 - x - 1 = 0\), and also satisfies
    the equation \(x + x^{-3} = 2\).
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 三波那契常数是相邻三波那契数趋向的比率。它是多项式 \(x^3 - x^2 - x - 1 = 0\) 的根，同时满足方程 \(x + x^{-3} =
    2\)。
- en: TribonacciConstant is a singleton, and can be accessed by `S.TribonacciConstant`.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 三波那契常数是一个单例，可以通过 `S.TribonacciConstant` 访问。
- en: Examples
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE506]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: References
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R139](#id40)]'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R139](#id40)]'
- en: '[https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers](https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers)'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers](https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers)'
- en: '[PRE507]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Return the number \(c\) such that, \(a \times c = 1 \pmod{m}\) where \(c\) has
    the same sign as \(m\). If no such value exists, a ValueError is raised.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数 \(c\)，使得 \(a \times c = 1 \pmod{m}\)，其中 \(c\) 的符号与 \(m\) 相同。如果不存在这样的值，则引发
    ValueError。
- en: Examples
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE508]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: 'Suppose we wish to find multiplicative inverse \(x\) of 3 modulo 11\. This
    is the same as finding \(x\) such that \(3x = 1 \pmod{11}\). One value of x that
    satisfies this congruence is 4\. Because \(3 \times 4 = 12\) and \(12 = 1 \pmod{11}\).
    This is the value returned by `mod_inverse`:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望找到模 11 下的数 3 的乘法逆元 \(x\)。这等同于找到满足 \(3x = 1 \pmod{11}\) 的 \(x\)。满足这个同余的一个值是
    4。因为 \(3 \times 4 = 12\) 并且 \(12 = 1 \pmod{11}\)。这是 `mod_inverse` 返回的值：
- en: '[PRE509]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: 'When there is a common factor between the numerators of \(a\) and \(m\) the
    inverse does not exist:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 当分子 \(a\) 和 \(m\) 之间有公共因子时，逆元不存在：
- en: '[PRE510]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-1547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: References
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R140](#id41)]'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R140](#id41)]'
- en: '[https://en.wikipedia.org/wiki/Modular_multiplicative_inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Modular_multiplicative_inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
- en: '[[R141](#id42)]'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R141](#id42)]'
- en: '[https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)'
- en: '[PRE512]'
  id: totrans-1553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: Compare expressions treating plain floats as rationals.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 比较将普通浮点数作为有理数处理的表达式。
- en: Examples
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE513]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: 'In SymPy expressions with Floats compare unequal to corresponding expressions
    with rationals:'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy表达式中，Floats与对应的Rationals比较不相等：
- en: '[PRE514]'
  id: totrans-1558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: 'However an individual Float compares equal to a Rational:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单个Float与Rational比较相等：
- en: '[PRE515]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: In a future version of SymPy this might change so that Rational and Float compare
    unequal. This function provides the behavior currently expected of `==` so that
    it could still be used if the behavior of `==` were to change in future.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的SymPy版本中，这可能会改变，以使Rational和Float比较不相等。此函数提供了当前预期的`==`行为，以便在未来更改`==`行为时仍然可以使用。
- en: '[PRE516]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: Explanation
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: In future SymPy verions Float and Rational might compare unequal and floats
    with different precisions might compare unequal. In that context a function is
    needed that can check if a number is equal to 1 or 0 etc. The idea is that instead
    of testing `if x == 1:` if we want to accept floats like `1.0` as well then the
    test can be written as `if equal_valued(x, 1):` or `if equal_valued(x, 2):`. Since
    this function is intended to be used in situations where one or both operands
    are expected to be concrete numbers like 1 or 0 the function does not recurse
    through the args of any compound expression to compare any nested floats.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的SymPy版本中，Float和Rational可能会比较不相等，不同精度的浮点数可能会比较不相等。在这种情况下，需要一个函数来检查一个数是否等于1或0等。这个想法是，不再测试`if
    x == 1:`如果我们想接受像`1.0`这样的浮点数，那么测试可以写成`if equal_valued(x, 1):`或`if equal_valued(x,
    2):`。由于这个函数旨在用于期望一个或两个操作数为具体数字（如1或0）的情况，所以该函数不会递归通过任何复合表达式的参数来比较任何嵌套浮点数。
- en: References
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R142](#id43)]'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R142](#id43)]'
- en: '[https://github.com/sympy/sympy/pull/20033](https://github.com/sympy/sympy/pull/20033)  ##
    power'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sympy/sympy/pull/20033](https://github.com/sympy/sympy/pull/20033)  ##
    power'
- en: '[PRE517]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: Defines the expression x**y as “x raised to a power y”
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 定义表达式x**y为“x的y次幂”
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.7起不推荐使用：在核心操作符（`Mul`、`Add`和`Pow`）中使用非[`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")子类的参数已被弃用。有关详情，请参阅[Core
    operators no longer accept non-Expr args](../explanation/active-deprecations.html#non-expr-args-deprecated)。
- en: 'Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: '单例定义涉及(0, 1, -1, oo, -oo, I, -I):'
- en: '| expr | value | reason |'
  id: totrans-1572
  prefs: []
  type: TYPE_TB
  zh: '| expr | value | reason |'
- en: '| --- | --- | --- |'
  id: totrans-1573
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| z**0 | 1 | Although arguments over 0**0 exist, see [2]. |'
  id: totrans-1574
  prefs: []
  type: TYPE_TB
  zh: '| z**0 | 1 | 尽管关于0**0的论点存在，参见[2]。 |'
- en: '| z**1 | z |  |'
  id: totrans-1575
  prefs: []
  type: TYPE_TB
  zh: '| z**1 | z |  |'
- en: '| (-oo)**(-1) | 0 |  |'
  id: totrans-1576
  prefs: []
  type: TYPE_TB
  zh: '| (-oo)**(-1) | 0 |  |'
- en: '| (-1)**-1 | -1 |  |'
  id: totrans-1577
  prefs: []
  type: TYPE_TB
  zh: '| (-1)**-1 | -1 |  |'
- en: '| S.Zero**-1 | zoo | This is not strictly true, as 0**-1 may be undefined,
    but is convenient in some contexts where the base is assumed to be positive. |'
  id: totrans-1578
  prefs: []
  type: TYPE_TB
  zh: '| S.Zero**-1 | zoo | 这并非严格正确，因为0**-1可能未定义，但在某些假设基数为正时很方便。 |'
- en: '| 1**-1 | 1 |  |'
  id: totrans-1579
  prefs: []
  type: TYPE_TB
  zh: '| 1**-1 | 1 |  |'
- en: '| oo**-1 | 0 |  |'
  id: totrans-1580
  prefs: []
  type: TYPE_TB
  zh: '| oo**-1 | 0 |  |'
- en: '| 0**oo | 0 | Because for all complex numbers z near 0, z**oo -> 0. |'
  id: totrans-1581
  prefs: []
  type: TYPE_TB
  zh: '| 0**oo | 0 | 因为对于所有接近0的复数z，z**oo -> 0。 |'
- en: '| 0**-oo | zoo | This is not strictly true, as 0**oo may be oscillating between
    positive and negative values or rotating in the complex plane. It is convenient,
    however, when the base is positive. |'
  id: totrans-1582
  prefs: []
  type: TYPE_TB
  zh: '| 0**-oo | zoo | 这并非严格正确，因为0**oo可能在复平面中正负值之间震荡或旋转。但是，当基数为正时，这是方便的。 |'
- en: '| 1**oo 1**-oo | nan | Because there are various cases where lim(x(t),t)=1,
    lim(y(t),t)=oo (or -oo), but lim( x(t)**y(t), t) != 1\. See [3]. |'
  id: totrans-1583
  prefs: []
  type: TYPE_TB
  zh: '| 1**oo 1**-oo | nan | 因为存在lim(x(t),t)=1，lim(y(t),t)=oo（或-oo），但lim(x(t)**y(t),
    t) != 1。参见[3]。 |'
- en: '| b**zoo | nan | Because b**z has no limit as z -> zoo |'
  id: totrans-1584
  prefs: []
  type: TYPE_TB
  zh: '| b**zoo | nan | 因为b**z在z -> zoo时没有极限。 |'
- en: '| (-1)**oo (-1)**(-oo) | nan | Because of oscillations in the limit. |'
  id: totrans-1585
  prefs: []
  type: TYPE_TB
  zh: '| (-1)**oo (-1)**(-oo) | nan | 因为极限中存在振荡。 |'
- en: '| oo**oo | oo |  |'
  id: totrans-1586
  prefs: []
  type: TYPE_TB
  zh: '| oo**oo | oo |  |'
- en: '| oo**-oo | 0 |  |'
  id: totrans-1587
  prefs: []
  type: TYPE_TB
  zh: '| oo**-oo | 0 |  |'
- en: '| (-oo)**oo (-oo)**-oo | nan |  |'
  id: totrans-1588
  prefs: []
  type: TYPE_TB
  zh: '| (-oo)**oo (-oo)**-oo | nan |  |'
- en: '| oo**I (-oo)**I | nan | oo**e could probably be best thought of as the limit
    of x**e for real x as x tends to oo. If e is I, then the limit does not exist
    and nan is used to indicate that. |'
  id: totrans-1589
  prefs: []
  type: TYPE_TB
  zh: '| oo**I (-oo)**I | nan | 可以将oo**e最好视为x趋于oo时实数x**e的极限。如果e是I，则极限不存在，使用nan表示。
    |'
- en: '| oo**(1+I) (-oo)**(1+I) | zoo | If the real part of e is positive, then the
    limit of abs(x**e) is oo. So the limit value is zoo. |'
  id: totrans-1590
  prefs: []
  type: TYPE_TB
  zh: '| oo**(1+I) (-oo)**(1+I) | zoo | 如果 e 的实部为正，则 abs(x**e) 的极限为 oo。因此极限值为 zoo。
    |'
- en: '| oo**(-1+I) -oo**(-1+I) | 0 | If the real part of e is negative, then the
    limit is 0. |'
  id: totrans-1591
  prefs: []
  type: TYPE_TB
  zh: '| oo**(-1+I) -oo**(-1+I) | 0 | 如果 e 的实部为负，则极限为 0。 |'
- en: Because symbolic computations are more flexible than floating point calculations
    and we prefer to never return an incorrect answer, we choose not to conform to
    all IEEE 754 conventions. This helps us avoid extra test-case code in the calculation
    of limits.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 因为符号计算比浮点计算更灵活，并且我们更倾向于不返回不正确的答案，所以我们选择不遵循所有 IEEE 754 的约定。这有助于我们避免在计算极限时额外的测试案例代码。
- en: See also
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity"),
    [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`sympy.core.numbers.NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity"),
    [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`sympy.core.numbers.NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
- en: References
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R143](#id44)]'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R143](#id44)]'
- en: '[https://en.wikipedia.org/wiki/Exponentiation](https://en.wikipedia.org/wiki/Exponentiation)'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Exponentiation](https://en.wikipedia.org/wiki/Exponentiation)'
- en: '[[R144](#id45)]'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R144](#id45)]'
- en: '[https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero](https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero)'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero](https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero)'
- en: '[[R145](#id46)]'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R145](#id46)]'
- en: '[https://en.wikipedia.org/wiki/Indeterminate_forms](https://en.wikipedia.org/wiki/Indeterminate_forms)'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Indeterminate_forms](https://en.wikipedia.org/wiki/Indeterminate_forms)'
- en: '[PRE518]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: Return base and exp of self.
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 self 的基数和指数。
- en: Explanation
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If base a Rational less than 1, then return 1/Rational, -exp. If this extra
    processing is not needed, the base and exp properties will give the raw arguments.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基数小于 1，则返回 1/有理数，-exp。如果不需要此额外处理，则基数和 exp 属性将给出原始参数。
- en: Examples
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE519]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组 (R, self/R)，其中 R 是从 self 中提取的正有理数。
- en: Examples
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE521]'
  id: totrans-1611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: 'See docstring of Expr.as_content_primitive for more examples.  ## mul'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '有关更多示例，请参阅 Expr.as_content_primitive 的文档字符串。  ## mul'
- en: '[PRE525]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: Expression representing multiplication operation for algebraic field.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 表示代数场中乘法操作的表达式。
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.7 弃用：在核心运算符（[`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul")、[`Add`](#sympy.core.add.Add
    "sympy.core.add.Add") 和 [`Pow`](#sympy.core.power.Pow "sympy.core.power.Pow")）中使用非
    Expr 子类的参数。有关详细信息，请参阅[不再接受非 Expr 参数的核心运算符](../explanation/active-deprecations.html#non-expr-args-deprecated)。
- en: Every argument of `Mul()` must be `Expr`. Infix operator `*` on most scalar
    objects in SymPy calls this class.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul()` 的每个参数都必须是 `Expr`。在 SymPy 中大多数标量对象上的中缀运算符 `*` 都调用此类。'
- en: Another use of `Mul()` is to represent the structure of abstract multiplication
    so that its arguments can be substituted to return different class. Refer to examples
    section for this.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul()` 的另一个用途是表示抽象乘法的结构，以便其参数可以被替换以返回不同的类。有关此内容，请参阅示例部分。'
- en: '`Mul()` evaluates the argument unless `evaluate=False` is passed. The evaluation
    logic includes:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul()` 会评估参数，除非传递了 `evaluate=False`。评估逻辑包括：'
- en: Flattening
  id: totrans-1622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平
- en: '`Mul(x, Mul(y, z))` -> `Mul(x, y, z)`'
  id: totrans-1623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Mul(x, Mul(y, z))` -> `Mul(x, y, z)`'
- en: Identity removing
  id: totrans-1624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除身份
- en: '`Mul(x, 1, y)` -> `Mul(x, y)`'
  id: totrans-1625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Mul(x, 1, y)` -> `Mul(x, y)`'
- en: Exponent collecting by `.as_base_exp()`
  id: totrans-1626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `.as_base_exp()` 收集指数
- en: '`Mul(x, x**2)` -> `Pow(x, 3)`'
  id: totrans-1627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Mul(x, x**2)` -> `Pow(x, 3)`'
- en: Term sorting
  id: totrans-1628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项排序
- en: '`Mul(y, x, 2)` -> `Mul(2, x, y)`'
  id: totrans-1629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Mul(y, x, 2)` -> `Mul(2, x, y)`'
- en: Since multiplication can be vector space operation, arguments may have the different
    [`sympy.core.kind.Kind()`](#sympy.core.kind.Kind "sympy.core.kind.Kind"). Kind
    of the resulting object is automatically inferred.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 由于乘法可以是矢量空间操作，参数可能具有不同的 [`sympy.core.kind.Kind()`](#sympy.core.kind.Kind "sympy.core.kind.Kind")。结果对象的种类将自动推断。
- en: Examples
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE526]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: If `evaluate=False` is passed, result is not evaluated.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了 `evaluate=False`，则结果不会被评估。
- en: '[PRE527]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '`Mul()` also represents the general structure of multiplication operation.'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul()` 也表示乘法操作的一般结构。'
- en: '[PRE528]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: See also
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`MatMul`](matrices/expressions.html#sympy.matrices.expressions.MatMul "sympy.matrices.expressions.MatMul")'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MatMul`](matrices/expressions.html#sympy.matrices.expressions.MatMul "sympy.matrices.expressions.MatMul")'
- en: '[PRE529]'
  id: totrans-1639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: Efficiently extract the coefficient of a product.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取乘积的系数。
- en: '[PRE530]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组（R, self/R），其中R是从self中提取的正有理数。
- en: Examples
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE531]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: See docstring of Expr.as_content_primitive for more examples.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Expr.as_content_primitive`的文档字符串以获取更多示例。
- en: '[PRE532]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: Transform an expression into an ordered list of factors.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式转换为因子的有序列表。
- en: Examples
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE533]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: Return head and tail of self.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 返回self的头部和尾部。
- en: This is the most efficient way to get the head and tail of an expression.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取表达式头部和尾部的最有效方式。
- en: if you want only the head, use self.args[0];
  id: totrans-1654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只需要头部，请使用self.args[0];
- en: if you want to process the arguments of the tail then use self.as_coef_mul()
    which gives the head and a tuple containing the arguments of the tail when treated
    as a Mul.
  id: totrans-1655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要处理尾部的参数，则使用self.as_coef_mul()，它在将其视为Mul时给出头部和包含尾部参数的元组。
- en: if you want the coefficient when self is treated as an Add then use self.as_coeff_add()[0]
  id: totrans-1656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果希望在将self视为Add时获取系数，请使用self.as_coeff_add()[0]
- en: Examples
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE536]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Return commutative, noncommutative and order arguments by combining related
    terms.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合相关术语返回可交换、非可交换和顺序参数。
- en: Notes
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In an expression like `a*b*c`, Python process this through SymPy as `Mul(Mul(a,
    b), c)`. This can have undesirable consequences.
  id: totrans-1662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类似`a*b*c`的表达式中，Python将其通过SymPy处理为`Mul(Mul(a, b), c)`。这可能会产生不良后果。
- en: 'Sometimes terms are not combined as one would like: {c.f. [https://github.com/sympy/sympy/issues/4596](https://github.com/sympy/sympy/issues/4596)}'
  id: totrans-1663
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时术语不能像预期的那样组合：{参见 [https://github.com/sympy/sympy/issues/4596](https://github.com/sympy/sympy/issues/4596)}
- en: '[PRE538]'
  id: totrans-1664
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE538]'
- en: ''
  id: totrans-1665
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Powers with compound bases may not find a single base to combine with unless
    all arguments are processed at once. Post-processing may be necessary in such
    cases. {c.f. [https://github.com/sympy/sympy/issues/5728](https://github.com/sympy/sympy/issues/5728)}
  id: totrans-1666
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 具有复合基数的幂可能找不到单个基数来组合，除非所有参数一次处理。在这种情况下可能需要后处理。{参见 [https://github.com/sympy/sympy/issues/5728](https://github.com/sympy/sympy/issues/5728)}
- en: ''
  id: totrans-1667
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE539]'
  id: totrans-1668
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE539]'
- en: 'If more than two terms are being multiplied then all the previous terms will
    be re-processed for each new argument. So if each of `a`, `b` and `c` were [`Mul`](#sympy.core.mul.Mul
    "sympy.core.mul.Mul") expression, then `a*b*c` (or building up the product with
    `*=`) will process all the arguments of `a` and `b` twice: once when `a*b` is
    computed and again when `c` is multiplied.'
  id: totrans-1669
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在相乘的术语超过两个，则所有先前的术语将对每个新的参数重新处理。因此，如果每个`a`、`b`和`c`都是[`Mul`](#sympy.core.mul.Mul
    "sympy.core.mul.Mul")表达式，那么`a*b*c`（或通过`*=`逐步建立乘积）将会两次处理`a`和`b`的所有参数：一次是计算`a*b`时，另一次是乘以`c`时。
- en: Using `Mul(a, b, c)` will process all arguments once.
  id: totrans-1670
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Mul(a, b, c)`将会处理所有参数一次。
- en: The results of Mul are cached according to arguments, so flatten will only be
    called once for `Mul(a, b, c)`. If you can structure a calculation so the arguments
    are most likely to be repeats then this can save time in computing the answer.
    For example, say you had a Mul, M, that you wished to divide by `d[i]` and multiply
    by `n[i]` and you suspect there are many repeats in `n`. It would be better to
    compute `M*n[i]/d[i]` rather than `M/d[i]*n[i]` since every time n[i] is a repeat,
    the product, `M*n[i]` will be returned without flattening – the cached value will
    be returned. If you divide by the `d[i]` first (and those are more unique than
    the `n[i]`) then that will create a new Mul, `M/d[i]` the args of which will be
    traversed again when it is multiplied by `n[i]`.
  id: totrans-1671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mul`的结果会根据参数进行缓存，因此仅对`Mul(a, b, c)`调用一次`flatten`。如果可以结构化计算使得参数最有可能重复，那么可以节省计算答案的时间。例如，假设你有一个Mul，M，希望除以`d[i]`并乘以`n[i]`，并且你怀疑`n`中有许多重复。最好计算`M*n[i]/d[i]`而不是`M/d[i]*n[i]`，因为每次`n[i]`重复时，乘积`M*n[i]`将返回而无需扁平化
    – 将返回缓存的值。如果首先除以`d[i]`（而这些与`n[i]`相比更独特），那么将创建一个新的Mul，`M/d[i]`其参数将在乘以`n[i]`时再次遍历。'
- en: '{c.f. [https://github.com/sympy/sympy/issues/5706](https://github.com/sympy/sympy/issues/5706)}'
  id: totrans-1672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{参见 [https://github.com/sympy/sympy/issues/5706](https://github.com/sympy/sympy/issues/5706)}'
- en: This consideration is moot if the cache is turned off.
  id: totrans-1673
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果缓存关闭，则此考虑无效。
- en: Nb
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The validity of the above notes depends on the implementation details of Mul
    and flatten which may change at any time. Therefore, you should only consider
    them when your code is highly performance sensitive.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 上述说明的有效性取决于Mul和flatten的实现细节，这些细节可能随时更改。 因此，只有在您的代码非常关注性能时才应考虑它们。
- en: Removal of 1 from the sequence is already handled by AssocOp.__new__.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列中删除1已由AssocOp.__new__处理。
- en: '[PRE540]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: Return product of elements of a. Start with int 1 so if only
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组元素的乘积。从整数1开始，所以如果只有
- en: ints are included then an int result is returned.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: ints被包括在内，然后返回一个int结果。
- en: Examples
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE541]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: 'You can start the product at something other than 1:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从1以外的某个值开始产品：
- en: '[PRE542]  ## add'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE542]  ## add'
- en: '[PRE543]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: Expression representing addition operation for algebraic group.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 表示代数组的加法操作的表达式。
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.7起不推荐使用：在核心运算符（[`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul")、[`Add`](#sympy.core.add.Add
    "sympy.core.add.Add")和[`Pow`](#sympy.core.power.Pow "sympy.core.power.Pow")）中使用非Expr参数已被弃用。
    有关详细信息，请参阅[Core operators no longer accept non-Expr args](../explanation/active-deprecations.html#non-expr-args-deprecated)。
- en: Every argument of `Add()` must be `Expr`. Infix operator `+` on most scalar
    objects in SymPy calls this class.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`的每个参数都必须是`Expr`。 SymPy中大多数标量对象上的中缀运算符`+`调用这个类。'
- en: Another use of `Add()` is to represent the structure of abstract addition so
    that its arguments can be substituted to return different class. Refer to examples
    section for this.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`的另一个用途是表示抽象加法结构，以便可以替换其参数以返回不同的类。 有关此内容，请参阅示例部分。'
- en: '`Add()` evaluates the argument unless `evaluate=False` is passed. The evaluation
    logic includes:'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未传递`evaluate=False`，则`Add()`会评估参数。 评估逻辑包括：
- en: Flattening
  id: totrans-1690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平
- en: '`Add(x, Add(y, z))` -> `Add(x, y, z)`'
  id: totrans-1691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Add(x, Add(y, z))` -> `Add(x, y, z)`'
- en: Identity removing
  id: totrans-1692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除标识
- en: '`Add(x, 0, y)` -> `Add(x, y)`'
  id: totrans-1693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Add(x, 0, y)` -> `Add(x, y)`'
- en: Coefficient collecting by `.as_coeff_Mul()`
  id: totrans-1694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`.as_coeff_Mul()`进行系数收集
- en: '`Add(x, 2*x)` -> `Mul(3, x)`'
  id: totrans-1695
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Add(x, 2*x)` -> `Mul(3, x)`'
- en: Term sorting
  id: totrans-1696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项排序
- en: '`Add(y, x, 2)` -> `Add(2, x, y)`'
  id: totrans-1697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Add(y, x, 2)` -> `Add(2, x, y)`'
- en: If no argument is passed, identity element 0 is returned. If single element
    is passed, that element is returned.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递参数，则返回标识元素0。 如果传递单个元素，则返回该元素。
- en: Note that `Add(*args)` is more efficient than `sum(args)` because it flattens
    the arguments. `sum(a, b, c, ...)` recursively adds the arguments as `a + (b +
    (c + ...))`, which has quadratic complexity. On the other hand, `Add(a, b, c,
    d)` does not assume nested structure, making the complexity linear.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Add(*args)`比`sum(args)`更有效，因为它会展平参数。 `sum(a, b, c, ...)`以递归方式添加参数，即`a +
    (b + (c + ...))`，具有二次复杂度。 另一方面，`Add(a, b, c, d)`不假设嵌套结构，使得复杂度为线性。
- en: Since addition is group operation, every argument should have the same [`sympy.core.kind.Kind()`](#sympy.core.kind.Kind
    "sympy.core.kind.Kind").
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加法是组操作，每个参数都应具有相同的[`sympy.core.kind.Kind()`](#sympy.core.kind.Kind "sympy.core.kind.Kind")。
- en: Examples
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE544]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: If `evaluate=False` is passed, result is not evaluated.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递`evaluate=False`，结果不会被评估。
- en: '[PRE545]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '`Add()` also represents the general structure of addition operation.'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`还表示加法操作的一般结构。'
- en: '[PRE546]'
  id: totrans-1706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: Note that the printers do not display in args order.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打印机不会按照args的顺序显示。
- en: '[PRE547]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: See also
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`MatAdd`](matrices/expressions.html#sympy.matrices.expressions.MatAdd "sympy.matrices.expressions.MatAdd")'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MatAdd`](matrices/expressions.html#sympy.matrices.expressions.MatAdd "sympy.matrices.expressions.MatAdd")'
- en: '[PRE548]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: Efficiently extract the coefficient of a summation.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地提取求和的系数。
- en: '[PRE549]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: Returns a tuple (coeff, args) where self is treated as an Add and coeff is the
    Number term and args is a tuple of all other terms.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个元组(coeff, args)，其中self被视为Add，coeff是数字项，args是所有其他项的元组。
- en: Examples
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE550]'
  id: totrans-1716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self. If radical is True (default is False) then common radicals will be removed
    and included as a factor of the primitive expression.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组(R, self/R)，其中R是从self中提取的正有理数。 如果radical为True（默认为False），则将删除常见的根，并将其包含为原始表达式的因子。
- en: Examples
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE552]'
  id: totrans-1720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: 'Radical content can also be factored out of the primitive:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 基本内容也可以从原始元素中分解出来：
- en: '[PRE553]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: See docstring of Expr.as_content_primitive for more examples.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多示例，请参阅Expr.as_content_primitive的文档字符串。
- en: '[PRE554]'
  id: totrans-1724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Decomposes an expression to its numerator part and its denominator part.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式分解为其分子部分和分母部分。
- en: Examples
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE555]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: See also
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.expr.Expr.as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom
    "sympy.core.expr.Expr.as_numer_denom")'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.expr.Expr.as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom
    "sympy.core.expr.Expr.as_numer_denom")'
- en: '[PRE556]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: Return a tuple representing a complex number.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表示复数的元组。
- en: Examples
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE557]'
  id: totrans-1733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: Return head and tail of self.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 返回self的头部和尾部。
- en: This is the most efficient way to get the head and tail of an expression.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取表达式头部和尾部的最有效方式。
- en: if you want only the head, use self.args[0];
  id: totrans-1737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只想获取头部，请使用`self.args[0]`；
- en: if you want to process the arguments of the tail then use self.as_coef_add()
    which gives the head and a tuple containing the arguments of the tail when treated
    as an Add.
  id: totrans-1738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想处理尾部的参数，请使用`self.as_coef_add()`，它返回头部和作为Add处理时尾部参数的元组。
- en: if you want the coefficient when self is treated as a Mul then use self.as_coeff_mul()[0]
  id: totrans-1739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望在将self视为Mul时获取系数，请使用`self.as_coeff_mul()[0]`
- en: '[PRE559]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: Returns the leading term and its order.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 返回主导项及其顺序。
- en: Examples
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE561]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-1745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: Takes the sequence “seq” of nested Adds and returns a flatten list.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 获取嵌套Add的序列“seq”并返回一个扁平化列表。
- en: 'Returns: (commutative_part, noncommutative_part, order_symbols)'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：（可交换部分，非可交换部分，顺序符号）
- en: Applies associativity, all terms are commutable with respect to addition.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 应用结合性，所有术语均可相对于加法交换。
- en: 'NB: the removal of 0 is already handled by AssocOp.__new__'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：去除0已由AssocOp.__new__处理。
- en: See also
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.mul.Mul.flatten`](#sympy.core.mul.Mul.flatten "sympy.core.mul.Mul.flatten")'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.mul.Mul.flatten`](#sympy.core.mul.Mul.flatten "sympy.core.mul.Mul.flatten")'
- en: '[PRE563]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: Return `(R, self/R)` where `` R` `` is the Rational GCD of `` self` ``.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`(R, self/R)`其中`` R` ``是`` self` ``的有理GCD。
- en: '`R` is collected only from the leading coefficient of each term.'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: '`R`仅从每个术语的主导系数中收集。'
- en: Examples
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE564]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-1757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-1759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'No subprocessing of term factors is performed:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行术语因子的子处理：
- en: '[PRE568]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: 'Recursive processing can be done with the `as_content_primitive()` method:'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 递归处理可以使用`as_content_primitive()`方法完成：
- en: '[PRE569]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: 'See also: primitive() function in polytools.py  ## mod'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '另见：polytools.py中的primitive()函数  ## mod'
- en: '[PRE570]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: Represents a modulo operation on symbolic expressions.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 表示符号表达式的模运算。
- en: 'Parameters:'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**p** : Expr'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: '**p** : Expr'
- en: Dividend.
  id: totrans-1769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 被除数。
- en: '**q** : Expr'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '**q** : Expr'
- en: Divisor.
  id: totrans-1771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除数。
- en: Notes
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The convention used is the same as Python’s: the remainder always has the same
    sign as the divisor.'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的约定与Python相同：余数始终与除数具有相同的符号。
- en: 'Many objects can be evaluated modulo `n` much faster than they can be evaluated
    directly (or at all). For this, `evaluate=False` is necessary to prevent eager
    evaluation:'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对象在模`n`下的求值速度比直接（或根本）求值要快得多。为此，必须使用`evaluate=False`来防止急切求值：
- en: '[PRE571]'
  id: totrans-1775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: Examples
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE572]  ## relational'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE572]  ## 关系型'
- en: '[PRE573]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: Base class for all relation types.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关系类型的基类。
- en: 'Parameters:'
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**rop** : str or None'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: '**rop** : str or None'
- en: Indicates what subclass to instantiate. Valid values can be found in the keys
    of Relational.ValidRelationOperator.
  id: totrans-1782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示实例化的子类。有效值可以在Relational.ValidRelationOperator的键中找到。
- en: Explanation
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Subclasses of Relational should generally be instantiated directly, but Relational
    can be instantiated with a valid `rop` value to dispatch to the appropriate subclass.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: Relational的子类通常应直接实例化，但可以使用有效的`rop`值实例化Relational以分派到适当的子类。
- en: Examples
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE574]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: 'A relation’s type can be defined upon creation using `rop`. The relation type
    of an existing expression can be obtained using its `rel_op` property. Here is
    a table of all the relation types, along with their `rop` and `rel_op` values:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`rop`参数在创建时定义关系类型。可以使用其`rel_op`属性获取现有表达式的关系类型。以下是所有关系类型的表格，以及它们的`rop`和`rel_op`值：
- en: '| Relation | `rop` | `rel_op` |'
  id: totrans-1788
  prefs: []
  type: TYPE_TB
  zh: '| Relation | `rop` | `rel_op` |'
- en: '| --- | --- | --- |'
  id: totrans-1789
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Equality` | `==` or `eq` or `None` | `==` |'
  id: totrans-1790
  prefs: []
  type: TYPE_TB
  zh: '| `Equality` | `==` or `eq` or `None` | `==` |'
- en: '| `Unequality` | `!=` or `ne` | `!=` |'
  id: totrans-1791
  prefs: []
  type: TYPE_TB
  zh: '| `Unequality` | `!=` or `ne` | `!=` |'
- en: '| `GreaterThan` | `>=` or `ge` | `>=` |'
  id: totrans-1792
  prefs: []
  type: TYPE_TB
  zh: '| `GreaterThan` | `>=` or `ge` | `>=` |'
- en: '| `LessThan` | `<=` or `le` | `<=` |'
  id: totrans-1793
  prefs: []
  type: TYPE_TB
  zh: '| `LessThan` | `<=` or `le` | `<=` |'
- en: '| `StrictGreaterThan` | `>` or `gt` | `>` |'
  id: totrans-1794
  prefs: []
  type: TYPE_TB
  zh: '| `StrictGreaterThan` | `>` or `gt` | `>` |'
- en: '| `StrictLessThan` | `<` or `lt` | `<` |'
  id: totrans-1795
  prefs: []
  type: TYPE_TB
  zh: '| `StrictLessThan` | `<` or `lt` | `<` |'
- en: 'For example, setting `rop` to `==` produces an `Equality` relation, `Eq()`.
    So does setting `rop` to `eq`, or leaving `rop` unspecified. That is, the first
    three `Rel()` below all produce the same result. Using a `rop` from a different
    row in the table produces a different relation type. For example, the fourth `Rel()`
    below using `lt` for `rop` produces a `StrictLessThan` inequality:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将`rop`设置为`==`会产生一个`Equality`关系，`Eq()`。设置`rop`为`eq`或不指定`rop`也是如此。也就是说，下面的前三个`Rel()`都会产生相同的结果。使用表中不同行的`rop`，例如，将`rop`设置为`lt`会产生一个`StrictLessThan`不等式：
- en: '[PRE575]'
  id: totrans-1797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: 'To obtain the relation type of an existing expression, get its `rel_op` property.
    For example, `rel_op` is `==` for the `Equality` relation above, and `<` for the
    strict less than inequality above:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得现有表达式的关系类型，请获取其`rel_op`属性。例如，上述`Equality`关系的`rel_op`为`==`，上述严格小于不等式的`rel_op`为`<`：
- en: '[PRE576]'
  id: totrans-1799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-1800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: Return a canonical form of the relational by putting a number on the rhs, canonically
    removing a sign or else ordering the args canonically. No other simplification
    is attempted.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在rhs上放置一个数字、规范地移除一个符号或以规范的顺序对args进行排序来返回关系的规范形式。不尝试进行其他简化。
- en: Examples
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE578]'
  id: totrans-1803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: 'The canonicalization is recursively applied:'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化递归应用：
- en: '[PRE579]'
  id: totrans-1805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: Return True if the sides of the relationship are mathematically identical and
    the type of relationship is the same. If failing_expression is True, return the
    expression whose truth value was unknown.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系的两侧在数学上完全相同且关系类型相同，则返回True。如果`failing_expression`为True，则返回其真值未知的表达式。
- en: '[PRE581]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: The left-hand side of the relation.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的左侧。
- en: '[PRE582]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: Return the negated relationship.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 返回否定的关系。
- en: Examples
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE583]'
  id: totrans-1813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: Notes
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记
- en: This works more or less identical to `~`/`Not`. The difference is that `negated`
    returns the relationship even if `evaluate=False`. Hence, this is useful in code
    when checking for e.g. negated relations to existing ones as it will not be affected
    by the \(evaluate\) flag.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`~`/`Not`基本相同。不同之处在于，即使`evaluate=False`，`negated`也返回关系。因此，在代码中检查例如反向的关系时非常有用，因为它不受\(evaluate\)标志的影响。
- en: '[PRE584]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: Return the relationship with sides reversed.
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 返回两侧关系颠倒。
- en: Examples
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE585]'
  id: totrans-1819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: Return the relationship with signs reversed.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 返回带有符号反转的关系。
- en: Examples
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE587]'
  id: totrans-1823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: The right-hand side of the relation.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的右侧。
- en: '[PRE589]'
  id: totrans-1826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: return the strict version of the inequality or self
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 返回严格版本的不等式或自身
- en: Examples
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE590]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: return the non-strict version of the inequality or self
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 返回非严格版本的不等式或自身
- en: Examples
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE592]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-1834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: alias of [`Relational`](#sympy.core.relational.Relational "sympy.core.relational.Relational")
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`Relational`](#sympy.core.relational.Relational "sympy.core.relational.Relational")
- en: '[PRE594]'
  id: totrans-1836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: alias of [`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")
- en: '[PRE595]'
  id: totrans-1838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: alias of [`Unequality`](#sympy.core.relational.Unequality "sympy.core.relational.Unequality")
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`Unequality`](#sympy.core.relational.Unequality "sympy.core.relational.Unequality")
- en: '[PRE596]'
  id: totrans-1840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: alias of [`StrictLessThan`](#sympy.core.relational.StrictLessThan "sympy.core.relational.StrictLessThan")
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`StrictLessThan`](#sympy.core.relational.StrictLessThan "sympy.core.relational.StrictLessThan")
- en: '[PRE597]'
  id: totrans-1842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: alias of [`LessThan`](#sympy.core.relational.LessThan "sympy.core.relational.LessThan")
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`LessThan`](#sympy.core.relational.LessThan "sympy.core.relational.LessThan")
- en: '[PRE598]'
  id: totrans-1844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: alias of [`StrictGreaterThan`](#sympy.core.relational.StrictGreaterThan "sympy.core.relational.StrictGreaterThan")
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`StrictGreaterThan`](#sympy.core.relational.StrictGreaterThan "sympy.core.relational.StrictGreaterThan")
- en: '[PRE599]'
  id: totrans-1846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: alias of [`GreaterThan`](#sympy.core.relational.GreaterThan "sympy.core.relational.GreaterThan")
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`GreaterThan`](#sympy.core.relational.GreaterThan "sympy.core.relational.GreaterThan")
- en: '[PRE600]'
  id: totrans-1848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: An equal relation between two objects.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象之间的相等关系。
- en: Explanation
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Represents that two objects are equal. If they can be easily shown to be definitively
    equal (or unequal), this will reduce to True (or False). Otherwise, the relation
    is maintained as an unevaluated Equality object. Use the `simplify` function on
    this object for more nontrivial evaluation of the equality relation.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 表示两个对象相等。如果可以轻松地显示它们明确相等（或不相等），则会简化为True（或False）。否则，关系将保持为未评估的Equality对象。对此对象使用`simplify`函数以进行更复杂的等式关系评估。
- en: As usual, the keyword argument `evaluate=False` can be used to prevent any evaluation.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用关键字参数`evaluate=False`来防止任何评估。
- en: Examples
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE601]'
  id: totrans-1854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Notes
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记
- en: 'Python treats 1 and True (and 0 and False) as being equal; SymPy does not.
    And integer will always compare as unequal to a Boolean:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: Python将1和True（以及0和False）视为相等；SymPy则不是。整数将始终与布尔值比较为不相等：
- en: '[PRE602]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: This class is not the same as the == operator. The == operator tests for exact
    structural equality between two expressions; this class compares expressions mathematically.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与 == 操作符不同。== 操作符用于测试两个表达式之间的精确结构相等性；而这个类则是数学上比较表达式。
- en: If either object defines an `_eval_Eq` method, it can be used in place of the
    default algorithm. If `lhs._eval_Eq(rhs)` or `rhs._eval_Eq(lhs)` returns anything
    other than None, that return value will be substituted for the Equality. If None
    is returned by `_eval_Eq`, an Equality object will be created as usual.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个对象定义了 `_eval_Eq` 方法，则可以用它来替换默认算法。如果 `lhs._eval_Eq(rhs)` 或 `rhs._eval_Eq(lhs)`
    返回除 None 外的任何值，则该返回值将替换等式。如果 `_eval_Eq` 返回 None，则将像往常一样创建一个等式对象。
- en: Since this object is already an expression, it does not respond to the method
    `as_expr` if one tries to create \(x - y\) from `Eq(x, y)`. If `eq = Eq(x, y)`
    then write \(eq.lhs - eq.rhs\) to get `x - y`.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此对象已经是一个表达式，如果尝试从 `Eq(x, y)` 创建 \(x - y\)，它不会响应 `as_expr` 方法。如果 `eq = Eq(x,
    y)`，则写 \(eq.lhs - eq.rhs\) 可以得到 `x - y`。
- en: 'Deprecated since version 1.5: `Eq(expr)` with a single argument is a shorthand
    for `Eq(expr, 0)`, but this behavior is deprecated and will be removed in a future
    version of SymPy.'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.5 弃用：`Eq(expr)` 的单个参数是 `Eq(expr, 0)` 的简写，但这种行为已弃用，将在 SymPy 的未来版本中移除。
- en: See also
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.logic.boolalg.Equivalent`](logic.html#sympy.logic.boolalg.Equivalent
    "sympy.logic.boolalg.Equivalent")'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.logic.boolalg.Equivalent`](logic.html#sympy.logic.boolalg.Equivalent
    "sympy.logic.boolalg.Equivalent")'
- en: for representing equality between two boolean expressions
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示两个布尔表达式之间的相等性
- en: '[PRE603]'
  id: totrans-1865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Returns lhs-rhs as a Poly
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 lhs-rhs 作为多项式
- en: Examples
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE604]'
  id: totrans-1868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-1869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: See the integrate function in sympy.integrals
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 sympy.integrals 中的 integrate 函数
- en: '[PRE606]'
  id: totrans-1871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: Class representations of inequalities.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不等式的类。
- en: Explanation
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Than` 类表示不等关系，其中左侧通常比右侧大或小。例如，GreaterThan 类表示不等关系，其中左侧至少与右侧一样大，如果不是更大的话。在数学符号中表示为：'
- en: lhs \(\ge\) rhs
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: lhs \(\ge\) rhs
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有四个 `*Than` 类，用于表示四种不等式：
- en: '| Class Name | Symbol |'
  id: totrans-1877
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 符号 |'
- en: '| --- | --- |'
  id: totrans-1878
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan | `>=` |'
  id: totrans-1879
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan | `>=` |'
- en: '| LessThan | `<=` |'
  id: totrans-1880
  prefs: []
  type: TYPE_TB
  zh: '| LessThan | `<=` |'
- en: '| StrictGreaterThan | `>` |'
  id: totrans-1881
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan | `>` |'
- en: '| StrictLessThan | `<` |'
  id: totrans-1882
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan | `<` |'
- en: All classes take two arguments, lhs and rhs.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都接受两个参数，lhs 和 rhs。
- en: '| Signature Example | Math Equivalent |'
  id: totrans-1884
  prefs: []
  type: TYPE_TB
  zh: '| 签名示例 | 数学等价物 |'
- en: '| --- | --- |'
  id: totrans-1885
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  id: totrans-1886
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  id: totrans-1887
  prefs: []
  type: TYPE_TB
  zh: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  id: totrans-1888
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  id: totrans-1889
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关系的正常 .lhs 和 .rhs 外，`*Than` 不等式对象还具有 .lts 和 .gts 属性，分别表示“小于侧”和“大于侧”的运算符。在算法中使用
    .lts 和 .gts 而不是 .lhs 和 .rhs 作为不等方向的假设，会更明确地表达某一段代码的意图，并使其对客户端代码的更改更具鲁棒性：
- en: '[PRE607]'
  id: totrans-1891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: Examples
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不直接实例化这些类，而是使用各种便利方法：
- en: '[PRE609]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是直接使用 Python 的不等式运算符（`>=`、`>`、`<=`、`<`）。它们相对于 `Ge`、`Gt`、`Le` 和 `Lt` 的优势在于，可以编写更“数学化”的语句，而不是在数学中散布奇怪的函数调用。但是，还有一些需要注意的（次要）注意事项（请搜索下面的‘注意事项’）。
- en: '[PRE610]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，也完全可以不那么简洁和方便地实例化一个 `*Than` 类：
- en: '[PRE611]'
  id: totrans-1899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-1900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: Notes
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Python 的运算符时，有几个需要注意的地方。
- en: 'The first is that what your write is not always what you get:'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是你写的不一定是你得到的：
- en: '[PRE613]'
  id: totrans-1904
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE613]'
- en: ''
  id: totrans-1905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  id: totrans-1906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 解析语句的顺序，它可能不会立即找到两个可比较的对象。当评估 `1 < x` 时，Python 认识到数字 1 是本地数，而 x *不是*。因为本地
    Python 数字不知道如何与 SymPy 对象进行比较，Python 将尝试反射操作，`x > 1`，这是被评估的形式，因此返回。
- en: ''
  id: totrans-1907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  id: totrans-1908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果语句的顺序很重要（例如对于控制台的视觉输出），可以通过以下几种方法来解决这个问题：
- en: ''
  id: totrans-1909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  id: totrans-1910
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较之前“sympify”文字
- en: ''
  id: totrans-1911
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1912
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE614]'
  id: totrans-1914
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE614]'
- en: ''
  id: totrans-1915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  id: totrans-1916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (2) 使用其中一个包装器或上述 less 方法
- en: ''
  id: totrans-1917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE615]'
  id: totrans-1918
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE615]'
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的地方涉及在文字关系涉及等式测试时写等式：
- en: '[PRE616]'
  id: totrans-1920
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE616]'
- en: ''
  id: totrans-1921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  id: totrans-1922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决此问题的方法是将文字关系用括号括起来：
- en: ''
  id: totrans-1923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE617]'
  id: totrans-1924
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个需要注意的地方涉及不涉及 `==` 或 `!=` 的链式不等式。偶尔，人们可能会尝试写成：
- en: '[PRE618]'
  id: totrans-1926
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE618]'
- en: ''
  id: totrans-1927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R146]](#r146), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  id: totrans-1928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 的实现细节或决策 [[R146]](#r146)，SymPy 无法使用该语法创建链式不等式，因此必须使用 And：
- en: ''
  id: totrans-1929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE619]'
  id: totrans-1930
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE619]'
- en: ''
  id: totrans-1931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  id: totrans-1932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这也可以使用‘&’运算符完成，但不能使用‘and’运算符完成：
- en: ''
  id: totrans-1933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE620]'
  id: totrans-1934
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[[R146](#id47)]'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R146](#id47)]'
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的实现细节是，它没有可靠的方法来确定正在构建链式不等式。链式比较运算符按对分析，使用“and”逻辑进行评估（参见 [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)）。这样做是高效的，因此每个比较的对象只评估一次，比较可以短路。例如，Python
    将 `1 > 2 > 3` 评估为 `(1 > 2) and (2 > 3)`。`and` 运算符将每一侧强制转换为 bool，在短路时返回对象本身。由于
    -Than 运算符会有意引发 TypeError，因为 SymPy 无法确定符号表达式的数学顺序。因此，如果我们计算 `x > y > z`，其中 `x`、`y`
    和 `z` 是符号，Python 大致将语句转换为以下步骤：
- en: x > y > z
  id: totrans-1937
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: x > y > z
- en: ''
  id: totrans-1938
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  id: totrans-1940
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (x > y) 和 (y > z)
- en: ''
  id: totrans-1941
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1942
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  id: totrans-1943
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject) 和 (y > z)
- en: ''
  id: totrans-1944
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1945
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  id: totrans-1946
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject.__bool__()) 和 (y > z)
- en: ''
  id: totrans-1947
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1948
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  id: totrans-1949
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeError
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二步添加了 `and`，语句变成了一个弱三元语句，并且第一个对象的 `__bool__` 方法会引发 TypeError。因此，创建链式不等式是不可能的。
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  id: totrans-1951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Python中，无法重写`and`运算符，或控制其短路的方式，因此无法使类似`x > y > z`的表达式起作用。曾经有一个PEP提议修改此行为，[**PEP
    335**](https://peps.python.org/pep-0335/)，但该提议在2012年3月正式关闭。
- en: '[PRE621]'
  id: totrans-1952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: Class representations of inequalities.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 类不等式的表示。
- en: Explanation
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Than`类表示不等关系，其中左侧通常比右侧大或小。例如，GreaterThan类表示一种不等关系，其中左侧至少与右侧一样大，如果不是更大。在数学符号中：'
- en: lhs \(\ge\) rhs
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: lhs \(\ge\) rhs
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有四个`*Than`类，用于表示四种不等式：
- en: '| Class Name | Symbol |'
  id: totrans-1958
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 符号 |'
- en: '| --- | --- |'
  id: totrans-1959
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan | `>=` |'
  id: totrans-1960
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | `>=` |'
- en: '| LessThan | `<=` |'
  id: totrans-1961
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | `<=` |'
- en: '| StrictGreaterThan | `>` |'
  id: totrans-1962
  prefs: []
  type: TYPE_TB
  zh: '| 严格大于 | `>` |'
- en: '| StrictLessThan | `<` |'
  id: totrans-1963
  prefs: []
  type: TYPE_TB
  zh: '| 严格小于 | `<` |'
- en: All classes take two arguments, lhs and rhs.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都接受两个参数，lhs和rhs。
- en: '| Signature Example | Math Equivalent |'
  id: totrans-1965
  prefs: []
  type: TYPE_TB
  zh: '| 签名示例 | 数学等效物 |'
- en: '| --- | --- |'
  id: totrans-1966
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  id: totrans-1967
  prefs: []
  type: TYPE_TB
  zh: '| 大于（lhs，rhs）| lhs \(\ge\) rhs |'
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  id: totrans-1968
  prefs: []
  type: TYPE_TB
  zh: '| 小于（lhs，rhs）| lhs \(\le\) rhs |'
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  id: totrans-1969
  prefs: []
  type: TYPE_TB
  zh: '| 严格大于（lhs，rhs）| lhs \(>\) rhs |'
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  id: totrans-1970
  prefs: []
  type: TYPE_TB
  zh: '| 严格小于（lhs，rhs）| lhs \(<\) rhs |'
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Relations的正常.lhs和.rhs之外，“*Than”不等式对象还具有.lts和.gts属性，它们分别表示操作符的“小于侧”和“大于侧”。在算法中使用.lts和.gts而不是.lhs和.rhs作为不等方向的假设，将更明确地表达特定代码段的意图，并使其对客户端代码变更更加鲁棒：
- en: '[PRE622]'
  id: totrans-1972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-1973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: Examples
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不直接实例化这些类，而是使用各种便利方法：
- en: '[PRE624]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是直接使用Python的不等运算符（`>=`，`>`，`<=`，`<`）。它们相对于`Ge`，`Gt`，`Le`和`Lt`的优势在于可以编写更“数学化”的语句，而不是用奇怪的函数调用来弄乱数学表达。但是也有一些（轻微的）注意事项需要注意（在下面搜索“坑”）。
- en: '[PRE625]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 但也完全可以不那么简洁和方便地实例化`*Than`类：
- en: '[PRE626]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-1981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: Notes
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python运算符时要注意的一些“坑”。
- en: 'The first is that what your write is not always what you get:'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是你所写的并不总是你得到的：
- en: '[PRE628]'
  id: totrans-1985
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE628]'
- en: ''
  id: totrans-1986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  id: totrans-1987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于Python解析语句的顺序，可能无法立即找到两个可比较的对象。当评估`1 < x`时，Python认识到数字1是本机数字，而x不是。因为本机Python数字不知道如何与SymPy对象比较，Python将尝试反射操作`x
    > 1`，这是评估的形式，因此返回。
- en: ''
  id: totrans-1988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  id: totrans-1989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果语句的顺序很重要（例如用于控制台的可视输出），可以通过几种方式解决这个问题：
- en: ''
  id: totrans-1990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  id: totrans-1991
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字面量转换为符号进行比较
- en: ''
  id: totrans-1992
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1993
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE629]'
  id: totrans-1995
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE629]'
- en: ''
  id: totrans-1996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  id: totrans-1997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （2）使用上述包装器或较不简洁的方法之一
- en: ''
  id: totrans-1998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE630]'
  id: totrans-1999
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE630]'
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的地方涉及在关系测试中写入一个或两个测试的文字关系时。
- en: '[PRE631]'
  id: totrans-2001
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE631]'
- en: ''
  id: totrans-2002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  id: totrans-2003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这种情况的解决方法是将文字关系放在括号中：
- en: ''
  id: totrans-2004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE632]'
  id: totrans-2005
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个需要注意的地方涉及不涉及 `==` 或 `!=` 的链式不等式。有时会有人试图写成：
- en: '[PRE633]'
  id: totrans-2007
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE633]'
- en: ''
  id: totrans-2008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R147]](#r147), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  id: totrans-2009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 的一个实现细节或决定[[R147]](#r147)，SymPy 无法使用该语法创建链式不等式，因此必须使用 And：
- en: ''
  id: totrans-2010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE634]'
  id: totrans-2011
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE634]'
- en: ''
  id: totrans-2012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  id: totrans-2013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这也可以使用 ‘&’ 操作符完成，但不能使用 ‘and’ 操作符：
- en: ''
  id: totrans-2014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE635]'
  id: totrans-2015
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[[R147](#id48)]'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R147](#id48)]'
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的这个实现细节是，它没有可靠的方法来确定是否正在构建链式不等式。链式比较运算符会成对地进行评估，使用“and”逻辑（参见 [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)）。这样做的效率很高，因此每个比较的对象只评估一次，比较可以短路。例如，`1
    > 2 > 3` 在 Python 中被评估为 `(1 > 2) and (2 > 3)`。`and` 操作符会将每一侧强制转换为布尔值，在短路时返回对象本身。比较运算符的布尔值会故意引发
    TypeError，因为 SymPy 无法确定符号表达式的数学顺序。因此，如果我们计算 `x > y > z`，其中 `x`、`y` 和 `z` 是符号，Python
    大致将该语句转换为以下步骤：
- en: x > y > z
  id: totrans-2018
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: x > y > z
- en: ''
  id: totrans-2019
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2020
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  id: totrans-2021
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (x > y) and (y > z)
- en: ''
  id: totrans-2022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2023
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  id: totrans-2024
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject) 和 (y > z)
- en: ''
  id: totrans-2025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2026
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  id: totrans-2027
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject.__bool__()) 和 (y > z)
- en: ''
  id: totrans-2028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2029
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  id: totrans-2030
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeError
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步添加了 `and`，语句被转换为弱三元语句，并且第一个对象的 `__bool__` 方法将引发 TypeError。因此，创建链式不等式是不可能的。
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  id: totrans-2032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Python 中，无法重写 `and` 操作符，或控制它如何短路，因此不可能使类似 `x > y > z` 的表达式工作。曾有一个 PEP 提议改变这一点，[**PEP
    335**](https://peps.python.org/pep-0335/)，但它在2012年3月正式关闭。
- en: '[PRE636]'
  id: totrans-2033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: An unequal relation between two objects.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象之间的不等关系。
- en: Explanation
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Represents that two objects are not equal. If they can be shown to be definitively
    equal, this will reduce to False; if definitively unequal, this will reduce to
    True. Otherwise, the relation is maintained as an Unequality object.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 表示两个对象不相等。如果可以确定它们是相等的，则结果将减少为 False；如果确定它们不相等，则结果将减少为 True。否则，关系将保持为 Unequality
    对象。
- en: Examples
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE637]'
  id: totrans-2038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: Notes
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This class is not the same as the != operator. The != operator tests for exact
    structural equality between two expressions; this class compares expressions mathematically.
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与 != 操作符不同。!= 操作符测试两个表达式之间的结构完全相等性；而这个类则是数学上比较表达式。
- en: This class is effectively the inverse of Equality. As such, it uses the same
    algorithms, including any available \(_eval_Eq\) methods.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实际上是 Equality 的反义。因此，它使用相同的算法，包括任何可用的\_eval\_Eq 方法。
- en: See also
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")'
- en: '[PRE638]'
  id: totrans-2044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: Class representations of inequalities.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式的类表示。
- en: Explanation
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Than` 类表示不等关系，其中左侧通常比右侧大或小。例如，GreaterThan 类表示一个不等关系，其中左侧至少与右侧一样大，如果不是更大的话。在数学符号中：'
- en: lhs \(\ge\) rhs
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: lhs \(\ge\) rhs
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有四个 `*Than` 类，用于表示四种不等式：
- en: '| Class Name | Symbol |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 符号 |'
- en: '| --- | --- |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan | `>=` |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan | `>=` |'
- en: '| LessThan | `<=` |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
  zh: '| LessThan | `<=` |'
- en: '| StrictGreaterThan | `>` |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan | `>` |'
- en: '| StrictLessThan | `<` |'
  id: totrans-2055
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan | `<` |'
- en: All classes take two arguments, lhs and rhs.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都接受两个参数，lhs 和 rhs。
- en: '| Signature Example | Math Equivalent |'
  id: totrans-2057
  prefs: []
  type: TYPE_TB
  zh: '| Signature Example | Math Equivalent |'
- en: '| --- | --- |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  id: totrans-2059
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  id: totrans-2060
  prefs: []
  type: TYPE_TB
  zh: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  id: totrans-2061
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  id: totrans-2062
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关系的正常 .lhs 和 .rhs 之外，`*Than` 不等式对象还具有 .lts 和 .gts 属性，分别表示操作符的“小于一侧”和“大于一侧”。在算法中使用
    .lts 和 .gts 而不是 .lhs 和 .rhs 作为不等式方向的假设，将更明确地表达代码的意图，并使其对客户端代码的更改同样更健壮：
- en: '[PRE639]'
  id: totrans-2064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-2065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: Examples
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不直接实例化这些类，而是使用各种方便的方法：
- en: '[PRE641]'
  id: totrans-2068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是直接使用 Python 的不等式操作符 (`>=`, `>`, `<=`, `<`)。它们相比于 `Ge`, `Gt`, `Le`, 和 `Lt`
    类的主要优势在于可以编写更“数学化”的语句，而不是用怪异的函数调用来散布数学公式。但是，有一些（轻微的）需要注意的小问题（搜索以下的 ‘gotcha’）。
- en: '[PRE642]'
  id: totrans-2070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也可以不那么简洁和方便地实例化 `*Than` 类：
- en: '[PRE643]'
  id: totrans-2072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-2073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: Notes
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 操作符时，有几个“gotcha”需要注意。
- en: 'The first is that what your write is not always what you get:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是你所写的并不总是你所得到的：
- en: '[PRE645]'
  id: totrans-2077
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE645]'
- en: ''
  id: totrans-2078
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  id: totrans-2079
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 解析语句的顺序，可能不会立即找到两个可比较的对象。当评估 `1 < x` 时，Python 识别到数字 1 是本机数字，而 x 不是。因为本机
    Python 数字不知道如何与 SymPy 对象比较，Python 将尝试反射操作 `x > 1`，这是评估的形式，因此返回。
- en: ''
  id: totrans-2080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  id: totrans-2081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果语句的顺序很重要（例如视觉输出到控制台），可以通过几种方式来解决这个烦恼：
- en: ''
  id: totrans-2082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  id: totrans-2083
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较之前“符号化”文字
- en: ''
  id: totrans-2084
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2085
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE646]'
  id: totrans-2087
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE646]'
- en: ''
  id: totrans-2088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  id: totrans-2089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (2) 使用以上描述的包装器或不那么简洁的方法之一
- en: ''
  id: totrans-2090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE647]'
  id: totrans-2091
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE647]'
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个“gotcha”涉及在文字关系涉及的测试之间写相等测试时，其中一个或两个测试的一侧涉及文字关系：
- en: '[PRE648]'
  id: totrans-2093
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE648]'
- en: ''
  id: totrans-2094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  id: totrans-2095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这种情况的解决方案是将文字关系包裹在括号中：
- en: ''
  id: totrans-2096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE649]'
  id: totrans-2097
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个“gotcha”涉及链式不等式，不涉及 `==` 或 `!=`。偶尔，人们可能会想要写：
- en: '[PRE650]'
  id: totrans-2099
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE650]'
- en: ''
  id: totrans-2100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R148]](#r148), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  id: totrans-2101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于Python的一个实现细节或决定[[R148]](#r148)，SymPy无法使用该语法创建链式不等式，因此必须使用And：
- en: ''
  id: totrans-2102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE651]'
  id: totrans-2103
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE651]'
- en: ''
  id: totrans-2104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  id: totrans-2105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管这也可以通过‘&’运算符来实现，但不能使用‘and’运算符：
- en: ''
  id: totrans-2106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE652]'
  id: totrans-2107
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[[R148](#id49)]'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R148](#id49)]'
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现细节是Python没有可靠的方法来确定是否正在构建链式不等式。链式比较操作符会成对地使用“and”逻辑进行评估（参见[https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)）。这是一种高效的方式，使得每个比较对象只被评估一次，并且可以短路。例如，Python将`1
    > 2 > 3`评估为`(1 > 2) and (2 > 3)`。`and`运算符会将每一侧强制转换为bool值，在短路时返回对象本身。--Than运算符的bool值将故意引发TypeError，因为SymPy无法确定符号表达式的数学排序。因此，如果我们计算`x
    > y > z`，其中`x`、`y`和`z`是符号，Python将大致将语句转换为以下步骤：
- en: x > y > z
  id: totrans-2110
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: x > y > z
- en: ''
  id: totrans-2111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  id: totrans-2113
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (x > y) and (y > z)
- en: ''
  id: totrans-2114
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2115
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  id: totrans-2116
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject) and (y > z)
- en: ''
  id: totrans-2117
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  id: totrans-2119
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject.__bool__()) and (y > z)
- en: ''
  id: totrans-2120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  id: totrans-2122
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeError
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在第二步中添加了`and`，语句变成了一个弱三元语句，并且第一个对象的`__bool__`方法将引发TypeError。因此，创建链式不等式是不可能的。
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  id: totrans-2124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Python中，没有办法重写`and`运算符，或者控制它如何短路，因此无法使类似于`x > y > z`的东西工作。曾经有一个PEP尝试改变这一点，[**PEP
    335**](https://peps.python.org/pep-0335/)，但于2012年3月正式关闭。
- en: '[PRE653]'
  id: totrans-2125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Class representations of inequalities.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式的类表示。
- en: Explanation
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Than`类表示不等关系，其中左侧通常大于或小于右侧。例如，GreaterThan类表示一个不等关系，其中左侧至少与右侧一样大，如果不是更大。在数学符号中表示为：'
- en: lhs \(\ge\) rhs
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: lhs \(\ge\) rhs
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有四个`*Than`类，用来表示四种不等式：
- en: '| Class Name | Symbol |'
  id: totrans-2131
  prefs: []
  type: TYPE_TB
  zh: '| Class Name | Symbol |'
- en: '| --- | --- |'
  id: totrans-2132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan | `>=` |'
  id: totrans-2133
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan | `>=` |'
- en: '| LessThan | `<=` |'
  id: totrans-2134
  prefs: []
  type: TYPE_TB
  zh: '| LessThan | `<=` |'
- en: '| StrictGreaterThan | `>` |'
  id: totrans-2135
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan | `>` |'
- en: '| StrictLessThan | `<` |'
  id: totrans-2136
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan | `<` |'
- en: All classes take two arguments, lhs and rhs.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都接受两个参数，lhs和rhs。
- en: '| Signature Example | Math Equivalent |'
  id: totrans-2138
  prefs: []
  type: TYPE_TB
  zh: '| Signature Example | Math Equivalent |'
- en: '| --- | --- |'
  id: totrans-2139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  id: totrans-2140
  prefs: []
  type: TYPE_TB
  zh: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  id: totrans-2141
  prefs: []
  type: TYPE_TB
  zh: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  id: totrans-2142
  prefs: []
  type: TYPE_TB
  zh: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
  zh: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的 .lhs 和 .rhs 关系外，`*Than` 不等式对象还具有 .lts 和 .gts 属性，分别表示运算符的“小于侧”和“大于侧”。在算法中使用
    .lts 和 .gts 而不是 .lhs 和 .rhs 作为不等式方向的假设，将更明确地表达某段代码的意图，并使其对客户端代码更加鲁棒：
- en: '[PRE654]'
  id: totrans-2145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-2146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: Examples
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不直接实例化这些类，而是使用各种便利方法：
- en: '[PRE656]'
  id: totrans-2149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是直接使用 Python 的不等式运算符（`>=`, `>`, `<=`, `<`）。它们与 `Ge`, `Gt`, `Le`, `Lt` 等对应的主要优势在于，可以编写更“数学化”的语句，而不是用奇怪的函数调用来弄乱数学表达式。但是，需要注意其中的某些（小）注意事项（下文搜索‘gotcha’）。
- en: '[PRE657]'
  id: totrans-2151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实例化一个 `*Than` 类的方式虽然不太简洁且不太方便，但也是完全有效的：
- en: '[PRE658]'
  id: totrans-2153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-2154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: Notes
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 运算符时，需要注意几个“gotcha”。
- en: 'The first is that what your write is not always what you get:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个注意事项是，你写的内容并不总是你得到的内容：
- en: '[PRE660]'
  id: totrans-2158
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE660]'
- en: ''
  id: totrans-2159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  id: totrans-2160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 解析语句的顺序，可能不会立即找到两个可比较的对象。当评估 `1 < x` 时，Python 会识别数字 1 是本地数字，而 x 则不是。因为本地
    Python 数字不知道如何与 SymPy 对象比较，Python 将尝试反射操作 `x > 1`，这是被评估和返回的形式。
- en: ''
  id: totrans-2161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  id: totrans-2162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果语句的顺序很重要（例如用于控制台的可视输出），可以通过几种方法避免这种烦恼：
- en: ''
  id: totrans-2163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  id: totrans-2164
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在比较之前“符号化”字面值
- en: ''
  id: totrans-2165
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2166
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE661]'
  id: totrans-2168
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE661]'
- en: ''
  id: totrans-2169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  id: totrans-2170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (2) 使用上述其中一个包装器或不太简洁的方法
- en: ''
  id: totrans-2171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE662]'
  id: totrans-2172
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个注意事项涉及在关系之间写等式测试时，当测试的一侧或两侧涉及字面关系时：
- en: '[PRE663]'
  id: totrans-2174
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE663]'
- en: ''
  id: totrans-2175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  id: totrans-2176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于这种情况的解决方案是，将字面不等式用括号括起来：
- en: ''
  id: totrans-2177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE664]'
  id: totrans-2178
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE664]'
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个注意事项涉及链式不等式，不涉及 `==` 或 `!=`。偶尔，你可能会想要写：
- en: '[PRE665]'
  id: totrans-2180
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE665]'
- en: ''
  id: totrans-2181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R149]](#r149), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  id: totrans-2182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 Python 的实现细节或决策 [[R149]](#r149)，SymPy 无法使用该语法创建链式不等式，因此必须使用 And：
- en: ''
  id: totrans-2183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE666]'
  id: totrans-2184
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE666]'
- en: ''
  id: totrans-2185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  id: totrans-2186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管可以使用 ‘&’ 运算符来完成此操作，但无法使用 ‘and’ 运算符：
- en: ''
  id: totrans-2187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE667]'
  id: totrans-2188
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[[R149](#id50)]'
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R149](#id50)]'
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现细节是Python没有可靠的方法来确定是否正在构建一个链式不等式。链式比较运算符使用“and”逻辑成对评估（见[https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)）。这样做是为了高效地，使得每个被比较的对象仅被评估一次，并且比较可以短路。例如，`1
    > 2 > 3`在Python中被评估为`(1 > 2) and (2 > 3)`。`and`运算符将每一侧强制转换为bool，在短路时返回对象本身。--Than运算符的bool故意引发类型错误，因为SymPy无法确定符号表达式的数学排序。因此，如果我们计算`x
    > y > z`，其中`x`，`y`和`z`是Symbols，Python大致将语句转换为以下步骤：
- en: x > y > z
  id: totrans-2191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: x > y > z
- en: ''
  id: totrans-2192
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2193
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  id: totrans-2194
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (x > y) and (y > z)
- en: ''
  id: totrans-2195
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2196
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  id: totrans-2197
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject) and (y > z)
- en: ''
  id: totrans-2198
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2199
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  id: totrans-2200
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: (GreaterThanObject.__bool__()) and (y > z)
- en: ''
  id: totrans-2201
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2202
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  id: totrans-2203
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型错误
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第2步添加的`and`，语句变成了一个弱三元语句，并且第一个对象的`__bool__`方法将引发类型错误。因此，创建一个链式不等式是不可能的。
- en: 'In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.  ## multidimensional'
  id: totrans-2205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '在Python中，无法重写`and`运算符，或控制其短路的方式，因此无法使类似`x > y > z`的语法生效。曾有一份PEP提案试图改变这一点，[**PEP
    335**](https://peps.python.org/pep-0335/)，但于2012年3月正式关闭。  ## 多维'
- en: '[PRE668]'
  id: totrans-2206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: Generalizes a function taking scalars to accept multidimensional arguments.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 将标量转为接受多维参数的函数。
- en: Examples
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE669]'
  id: totrans-2209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-2212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]  ## function'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE673]  ## 函数'
- en: '[PRE674]'
  id: totrans-2214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: 'Lambda(x, expr) represents a lambda function similar to Python’s ‘lambda x:
    expr’. A function of several variables is written as Lambda((x, y, …), expr).'
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lambda(x, expr)表示一个类似Python中的‘lambda x: expr’的lambda函数。具有多个变量的函数写作为Lambda((x,
    y, …), expr)。'
- en: Examples
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: 'A simple example:'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子：
- en: '[PRE675]'
  id: totrans-2218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: 'For multivariate functions, use:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多变量函数，请使用：
- en: '[PRE676]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: 'It is also possible to unpack tuple arguments:'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以解包元组参数：
- en: '[PRE677]'
  id: totrans-2222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: 'A handy shortcut for lots of arguments:'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数的便捷快捷方式：
- en: '[PRE678]'
  id: totrans-2224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-2225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: The variables used in the internal representation of the function
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 用于函数内部表示的变量
- en: '[PRE680]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: The return value of the function
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值
- en: '[PRE681]'
  id: totrans-2229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: Return `True` if this `Lambda` is an identity function.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`Lambda`是一个恒等函数，则返回`True`。
- en: '[PRE682]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: The expected form of the arguments to be unpacked into variables
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 要解包为变量的参数的预期形式
- en: '[PRE683]'
  id: totrans-2233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: The variables used in the internal representation of the function
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 用于函数内部表示的变量
- en: '[PRE684]'
  id: totrans-2235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: A WildFunction function matches any function (with its arguments).
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
  zh: WildFunction函数匹配任何函数（及其参数）。
- en: Examples
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE685]'
  id: totrans-2238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: 'To match functions with a given number of arguments, set `nargs` to the desired
    value at instantiation:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配具有给定参数数量的函数，请在实例化时将`nargs`设置为所需的值：
- en: '[PRE686]'
  id: totrans-2240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: To match functions with a range of arguments, set `nargs` to a tuple containing
    the desired number of arguments, e.g. if `nargs = (1, 2)` then functions with
    1 or 2 arguments will be matched.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配具有一系列参数的函数，请将`nargs`设置为包含所需参数数量的元组，例如，如果`nargs = (1, 2)`，则将匹配具有1个或2个参数的函数。
- en: '[PRE687]'
  id: totrans-2242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-2243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: Carries out differentiation of the given expression with respect to symbols.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定表达式进行关于符号的微分。
- en: Examples
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE689]'
  id: totrans-2246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-2247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: 'Denesting of derivatives retains the ordering of variables:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 导数去嵌套保留变量的顺序：
- en: '[PRE691]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: 'Contiguously identical symbols are merged into a tuple giving the symbol and
    the count:'
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 连续相同符号合并为给定符号和计数的元组：
- en: '[PRE692]'
  id: totrans-2251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: 'If the derivative cannot be performed, and evaluate is True, the order of the
    variables of differentiation will be made canonical:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法执行导数，并且evaluate为True，则将分化变量的顺序设置为规范：
- en: '[PRE693]'
  id: totrans-2253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: 'Derivatives with respect to undefined functions can be calculated:'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 可以计算对未定义函数的导数：
- en: '[PRE694]'
  id: totrans-2255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: 'Such derivatives will show up when the chain rule is used to evalulate a derivative:'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 当链规则用于评估导数时，这样的导数会显示出来：
- en: '[PRE695]'
  id: totrans-2257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'Substitution is used to represent derivatives of functions with arguments that
    are not symbols or functions:'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
  zh: 替换用于表示带有非符号或函数参数的函数的导数：
- en: '[PRE696]'
  id: totrans-2259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: Notes
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Simplification of high-order derivatives:'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶导数的简化：
- en: Because there can be a significant amount of simplification that can be done
    when multiple differentiations are performed, results will be automatically simplified
    in a fairly conservative fashion unless the keyword `simplify` is set to False.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在执行多次差异化时可以进行大量简化，所以结果将以相当保守的方式自动简化，除非关键字 `simplify` 设置为 False。
- en: '[PRE697]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-2264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: 'Ordering of variables:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的顺序：
- en: If evaluate is set to True and the expression cannot be evaluated, the list
    of differentiation symbols will be sorted, that is, the expression is assumed
    to have continuous derivatives up to the order asked.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 evaluate 设置为 True 并且无法评估表达式，则差异化符号列表将被排序，即假设表达式具有连续的导数直到所要求的顺序。
- en: 'Derivative wrt non-Symbols:'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 对非符号的导数：
- en: 'For the most part, one may not differentiate wrt non-symbols. For example,
    we do not allow differentiation wrt \(x*y\) because there are multiple ways of
    structurally defining where x*y appears in an expression: a very strict definition
    would make (x*y*z).diff(x*y) == 0\. Derivatives wrt defined functions (like cos(x))
    are not allowed, either:'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，不可对非符号进行差异化。例如，我们不允许对 \(x*y\) 进行差异化，因为在表达式中定义 \(x*y\) 出现的多种方式：非常严格的定义会使得
    (x*y*z).diff(x*y) == 0。也不允许对定义的函数（如 cos(x)）进行导数计算：
- en: '[PRE699]'
  id: totrans-2269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: 'To make it easier to work with variational calculus, however, derivatives wrt
    AppliedUndef and Derivatives are allowed. For example, in the Euler-Lagrange method
    one may write F(t, u, v) where u = f(t) and v = f’(t). These variables can be
    written explicitly as functions of time:'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易处理变分计算，允许对 AppliedUndef 和 Derivatives 进行导数计算。例如，在欧拉-拉格朗日方法中，可以写成 F(t, u,
    v)，其中 u = f(t) 且 v = f’(t)。这些变量可以明确地写成时间的函数：
- en: '[PRE700]'
  id: totrans-2271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: 'The derivative wrt f(t) can be obtained directly:'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 f(t) 的导数可以直接得到：
- en: '[PRE701]'
  id: totrans-2273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: 'When differentiation wrt a non-Symbol is attempted, the non-Symbol is temporarily
    converted to a Symbol while the differentiation is performed and the same answer
    is obtained:'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试对非符号进行差异化时，将非符号暂时转换为符号，同时执行差异化，并获得相同的答案：
- en: '[PRE702]'
  id: totrans-2275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'The implication of this non-symbol replacement is that all functions are treated
    as independent of other functions and the symbols are independent of the functions
    that contain them:'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 此非符号替换的含义是，所有函数都被视为独立于其他函数，并且符号独立于包含它们的函数：
- en: '[PRE703]'
  id: totrans-2277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: 'It also means that derivatives are assumed to depend only on the variables
    of differentiation, not on anything contained within the expression being differentiated:'
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着假设导数仅依赖于差异化变量，而不依赖于被差异化表达式中的任何内容：
- en: '[PRE704]'
  id: totrans-2279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: 'The last example can be made explicit by showing the replacement of Fx in Fxx
    with y:'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子可以通过显示 Fx 在 Fxx 中用 y 替换来明确：
- en: '[PRE705]'
  id: totrans-2281
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE705]'
- en: ''
  id: totrans-2282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since that in itself will evaluate to zero, differentiating wrt Fx will also
    be zero:'
  id: totrans-2283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于这本身将评估为零，不同iating wrt Fx 也将是零：
- en: ''
  id: totrans-2284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE706]'
  id: totrans-2285
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE706]'
- en: Replacing undefined functions with concrete expressions
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 用具体表达式替换未定义的函数
- en: 'One must be careful to replace undefined functions with expressions that contain
    variables consistent with the function definition and the variables of differentiation
    or else insconsistent result will be obtained. Consider the following example:'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 必须小心地用包含与函数定义和差异化变量一致的变量的表达式替换未定义的函数，否则将得到不一致的结果。考虑以下例子：
- en: '[PRE707]'
  id: totrans-2288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: The results differ because \(f(x)\) was replaced with an expression that involved
    both variables of differentiation. In the abstract case, differentiation of \(f(x)\)
    by \(y\) is 0; in the concrete case, the presence of \(y\) made that derivative
    nonvanishing and produced the extra \(g(y)\) term.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不同，因为 \(f(x)\) 被替换为涉及差异化变量的表达式。在抽象情况下，对 \(y\) 的 \(f(x)\) 的差异化为 0；在具体情况下，\(y\)
    的存在使得该导数非零，并产生额外的 \(g(y)\) 项。
- en: Defining differentiation for an object
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 定义对象的差异化
- en: An object must define ._eval_derivative(symbol) method that returns the differentiation
    result. This function only needs to consider the non-trivial case where expr contains
    symbol and it should call the diff() method internally (not _eval_derivative);
    Derivative should be the only one to call _eval_derivative.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 对象必须定义 `._eval_derivative(symbol)` 方法，该方法返回微分结果。此函数仅需要考虑表达式包含符号的非平凡情况，并且应在内部调用
    diff() 方法（而不是 _eval_derivative）；Derivative 应是唯一调用 _eval_derivative 的对象。
- en: Any class can allow derivatives to be taken with respect to itself (while indicating
    its scalar nature). See the docstring of Expr._diff_wrt.
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以允许相对于自身进行导数操作（同时指示其标量性质）。请参阅 Expr._diff_wrt 的文档字符串。
- en: See also
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`_sort_variable_count`](#sympy.core.function.Derivative._sort_variable_count
    "sympy.core.function.Derivative._sort_variable_count")'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: '[`_sort_variable_count`](#sympy.core.function.Derivative._sort_variable_count
    "sympy.core.function.Derivative._sort_variable_count")'
- en: '[PRE708]'
  id: totrans-2295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: An expression may be differentiated wrt a Derivative if it is in elementary
    form.
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可能相对于导数进行微分，如果它处于基本形式中。
- en: Examples
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE709]'
  id: totrans-2298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-2299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: A Derivative might be an unevaluated form of what will not be a valid variable
    of differentiation if evaluated. For example,
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果评估，Derivative 可能是将不是有效的差异化变量的未评估形式。例如，
- en: '[PRE711]'
  id: totrans-2301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: 'Such an expression will present the same ambiguities as arise when dealing
    with any other product, like `2*x`, so `_diff_wrt` is False:'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表达式将出现与处理任何其他乘积时相同的歧义，比如 `2*x`，因此 `_diff_wrt` 为 False：
- en: '[PRE712]'
  id: totrans-2303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-2304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'Sort (variable, count) pairs into canonical order while retaining order of
    variables that do not commute during differentiation:'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 将（变量，计数）对排序为规范顺序，同时保留在微分过程中不对易变量的顺序：
- en: symbols and functions commute with each other
  id: totrans-2306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号和函数彼此交换
- en: derivatives commute with each other
  id: totrans-2307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数彼此对易
- en: a derivative does not commute with anything it contains
  id: totrans-2308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导数不与包含的任何内容对易
- en: any other object is not allowed to commute if it has free symbols in common
    with another object
  id: totrans-2309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它与另一个对象具有共同的自由符号，则不允许任何其他对象对易
- en: Examples
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE714]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: 'Contiguous items are collapsed into one pair:'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 连续项目折叠成一个对：
- en: '[PRE715]'
  id: totrans-2313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: Ordering is canonical.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是规范的。
- en: '[PRE716]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-2316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: 'Symbols are sorted as far to the left as possible but never move to the left
    of a derivative having the same symbol in its variables; the same applies to AppliedUndef
    which are always sorted after Symbols:'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 符号尽可能向左移动，但绝不移动到具有其变量中相同符号的导数左侧；对于始终在符号后排序的 AppliedUndef，同样适用：
- en: '[PRE718]'
  id: totrans-2318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-2319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: Expresses a Derivative instance as a finite difference.
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Derivative 实例表达为有限差分。
- en: 'Parameters:'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**points** : sequence or coefficient, optional'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: '**points**：序列或系数，可选'
- en: 'If sequence: discrete values (length >= order+1) of the independent variable
    used for generating the finite difference weights. If it is a coefficient, it
    will be used as the step-size for generating an equidistant sequence of length
    order+1 centered around `x0`. Default: 1 (step-size 1)'
  id: totrans-2323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果序列：用于生成有限差分权重的独立变量的离散值（长度>= order+1）。如果它是系数，则将用作围绕 `x0` 的长度为 order+1 的等距序列的步长。默认值：1（步长1）
- en: '**x0** : number or Symbol, optional'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0**：数字或符号，可选'
- en: 'the value of the independent variable (`wrt`) at which the derivative is to
    be approximated. Default: same as `wrt`.'
  id: totrans-2325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 独立变量的值（`wrt`）是导数近似的值。默认情况下与 `wrt` 相同。
- en: '**wrt** : Symbol, optional'
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: '**wrt**：符号，可选'
- en: '“with respect to” the variable for which the (partial) derivative is to be
    approximated for. If not provided it is required that the derivative is ordinary.
    Default: `None`.'
  id: totrans-2327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “关于”用于近似（部分）导数的变量。如果未提供，则要求导数是普通的。默认值：`None`。
- en: Examples
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE720]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: 'The default step size and number of points are 1 and `order + 1` respectively.
    We can change the step size by passing a symbol as a parameter:'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 默认步长和点数为1和`order + 1`。我们可以通过将符号作为参数传递来更改步长：
- en: '[PRE721]'
  id: totrans-2331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: 'We can also specify the discretized values to be used in a sequence:'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定用于序列中使用的离散化值：
- en: '[PRE722]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: 'The algorithm is not restricted to use equidistant spacing, nor do we need
    to make the approximation around `x0`, but we can get an expression estimating
    the derivative at an offset:'
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法不限于使用等距间隔，也不需要围绕 `x0` 进行近似，但我们可以得到一个表达式，估计在偏移处的导数：
- en: '[PRE723]'
  id: totrans-2335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: 'To approximate `Derivative` around `x0` using a non-equidistant spacing step,
    the algorithm supports assignment of undefined functions to `points`:'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用非等距间隔步骤近似 `Derivative` 环绕 `x0`，算法支持将未定义函数分配给 `points`：
- en: '[PRE724]'
  id: totrans-2337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: 'Partial derivatives are also supported:'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 也支持偏导数：
- en: '[PRE725]'
  id: totrans-2339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: 'We can apply `as_finite_difference` to `Derivative` instances in compound expressions
    using `replace`:'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在复合表达式中对 `Derivative` 实例应用 `as_finite_difference`，使用 `replace`：
- en: '[PRE726]'
  id: totrans-2341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: See also
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.calculus.finite_diff.apply_finite_diff`](calculus/index.html#sympy.calculus.finite_diff.apply_finite_diff
    "sympy.calculus.finite_diff.apply_finite_diff"), [`sympy.calculus.finite_diff.differentiate_finite`](calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite"), [`sympy.calculus.finite_diff.finite_diff_weights`](calculus/index.html#sympy.calculus.finite_diff.finite_diff_weights
    "sympy.calculus.finite_diff.finite_diff_weights")'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.calculus.finite_diff.apply_finite_diff`](calculus/index.html#sympy.calculus.finite_diff.apply_finite_diff
    "sympy.calculus.finite_diff.apply_finite_diff"), [`sympy.calculus.finite_diff.differentiate_finite`](calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite"), [`sympy.calculus.finite_diff.finite_diff_weights`](calculus/index.html#sympy.calculus.finite_diff.finite_diff_weights
    "sympy.calculus.finite_diff.finite_diff_weights")'
- en: '[PRE727]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: Evaluate the derivative at z numerically.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值上评估导数在 `z` 处的值。
- en: When we can represent derivatives at a point, this should be folded into the
    normal evalf. For now, we need a special method.
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够表示点上的导数时，这应该折叠到普通的 `evalf` 中。目前，我们需要一个特殊的方法。
- en: '[PRE728]'
  id: totrans-2347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: Differentiate f with respect to symbols.
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 对符号求解 `f` 的导数。
- en: Explanation
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This is just a wrapper to unify .diff() and the Derivative class; its interface
    is similar to that of integrate(). You can use the same shortcuts for multiple
    variables as with Derivative. For example, diff(f(x), x, x, x) and diff(f(x),
    x, 3) both return the third derivative of f(x).
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个包装器，用于统一 `.diff()` 和 `Derivative` 类；其接口类似于 `integrate()`。您可以像对待 `Derivative`
    一样对多个变量使用相同的快捷方式。例如，`diff(f(x), x, x, x)` 和 `diff(f(x), x, 3)` 都返回 `f(x)` 的三阶导数。
- en: You can pass evaluate=False to get an unevaluated Derivative class. Note that
    if there are 0 symbols (such as diff(f(x), x, 0), then the result will be the
    function (the zeroth derivative), even if evaluate=False.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递 `evaluate=False` 以获取未评估的 `Derivative` 类。请注意，如果没有符号（例如 `diff(f(x), x, 0)`），则结果将是函数（零阶导数），即使
    `evaluate=False`。
- en: Examples
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE729]'
  id: totrans-2353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-2354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-2355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-2356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: Note that `diff(sin(x))` syntax is meant only for convenience in interactive
    sessions and should be avoided in library code.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `diff(sin(x))` 的语法仅用于交互式会话的便利性，应避免在库代码中使用。
- en: See also
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Derivative`](#sympy.core.function.Derivative "sympy.core.function.Derivative")'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Derivative`](#sympy.core.function.Derivative "sympy.core.function.Derivative")'
- en: '[`idiff`](geometry/utils.html#sympy.geometry.util.idiff "sympy.geometry.util.idiff")'
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: '[`idiff`](geometry/utils.html#sympy.geometry.util.idiff "sympy.geometry.util.idiff")'
- en: computes the derivative implicitly
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式计算导数
- en: References
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R150](#id51)]'
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R150](#id51)]'
- en: '[https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html](https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html)'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html](https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html)'
- en: '[PRE733]'
  id: totrans-2365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: Base class for function classes. FunctionClass is a subclass of type.
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类的基类。`FunctionClass` 是 `type` 的子类。
- en: Use Function(‘<function name>’ [ , signature ]) to create undefined function
    classes.
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Function('<function name>' [, 签名])` 创建未定义函数类。
- en: '[PRE734]'
  id: totrans-2368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: Return a set of the allowed number of arguments for the function.
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数允许的参数数量的集合。
- en: Examples
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE735]'
  id: totrans-2371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: 'If the function can take any number of arguments, the set of whole numbers
    is returned:'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数可以接受任意数量的参数，则返回整数集合：
- en: '[PRE736]'
  id: totrans-2373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: 'If the function was initialized to accept one or more arguments, a corresponding
    set will be returned:'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数被初始化为接受一个或多个参数，则将返回相应的集合：
- en: '[PRE737]'
  id: totrans-2375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: 'The undefined function, after application, also has the nargs attribute; the
    actual number of arguments is always available by checking the `args` attribute:'
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用后，未定义的函数也具有 `nargs` 属性；通过检查 `args` 属性始终可以获得实际的参数数量：
- en: '[PRE738]'
  id: totrans-2377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-2378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Base class for applied mathematical functions.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数学函数的基类。
- en: It also serves as a constructor for undefined function classes.
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 它还充当未定义函数类的构造函数。
- en: See the [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide for details on how to subclass `Function` and what methods can be defined.
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何子类化 `Function` 和可以定义哪些方法的详细信息，请参见[编写自定义函数](../guides/custom-functions.html#custom-functions)指南。
- en: Examples
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '**Undefined Functions**'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: '**未定义函数**'
- en: To create an undefined function, pass a string of the function name to `Function`.
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个未定义的函数，请将函数名称的字符串传递给 `Function`。
- en: '[PRE740]'
  id: totrans-2385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: 'Assumptions can be passed to `Function` the same as with a [`Symbol`](#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"). Alternatively, you can use a `Symbol` with assumptions
    for the function name and the function will inherit the name and assumptions associated
    with the `Symbol`:'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
  zh: 假设可以像[`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")一样传递给`Function`。或者，您可以使用带有函数名称和假设的`Symbol`来命名函数，并且函数将继承与`Symbol`相关联的名称和假设：
- en: '[PRE741]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: Note that assumptions on a function are unrelated to the assumptions on the
    variables it is called on. If you want to add a relationship, subclass `Function`
    and define custom assumptions handler methods. See the [Assumptions](../guides/custom-functions.html#custom-functions-assumptions)
    section of the [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide for more details.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数上的假设与调用它的变量的假设无关。如果要添加关系，请子类化`Function`并定义自定义假设处理方法。请参阅[Assumptions](../guides/custom-functions.html#custom-functions-assumptions)部分的[编写自定义函数](../guides/custom-functions.html#custom-functions)指南获取更多详细信息。
- en: '**Custom Function Subclasses**'
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义函数子类**'
- en: The [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide has several [Complete Examples](../guides/custom-functions.html#custom-functions-complete-examples)
    of how to subclass `Function` to create a custom function.
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '[编写自定义函数](../guides/custom-functions.html#custom-functions)指南有几个[完整示例](../guides/custom-functions.html#custom-functions-complete-examples)，展示了如何子类化`Function`以创建自定义函数。'
- en: '[PRE742]'
  id: totrans-2391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: Returns the method as the 2-tuple (base, exponent).
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 返回方法作为2元组（基数，指数）。
- en: '[PRE743]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: Returns the first derivative of the function.
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数的第一阶导数。
- en: '[PRE744]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: Tests whether the argument is an essential singularity or a branch point, or
    the functions is non-holomorphic.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 检查参数是否是本质奇点或分支点，或者函数是非全纯的。
- en: Note
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all functions are the same
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有函数都相同
- en: 'SymPy defines many functions (like `cos` and `factorial`). It also allows the
    user to create generic functions which act as argument holders. Such functions
    are created just like symbols:'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy定义了许多函数（如`cos`和`factorial`）。它还允许用户创建作为参数持有者的通用函数。此类函数的创建方式与符号相同：
- en: '[PRE745]'
  id: totrans-2400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: 'If you want to see which functions appear in an expression you can use the
    atoms method:'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看表达式中出现的函数，可以使用atoms方法：
- en: '[PRE746]'
  id: totrans-2402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: 'If you just want the function you defined, not SymPy functions, the thing to
    search for is AppliedUndef:'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想要您定义的函数，而不是SymPy函数，请搜索AppliedUndef：
- en: '[PRE747]'
  id: totrans-2404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-2405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: Represents unevaluated substitutions of an expression.
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 表示表达式的未评估替换。
- en: '`Subs(expr, x, x0)` represents the expression resulting from substituting x
    with x0 in expr.'
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subs(expr, x, x0)`表示在expr中用x0替换x后得到的表达式。'
- en: 'Parameters:'
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : Expr'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：Expr'
- en: An expression.
  id: totrans-2410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个表达式。
- en: '**x** : tuple, variable'
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: '**x**：元组，变量'
- en: A variable or list of distinct variables.
  id: totrans-2412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个变量或不同变量的列表。
- en: '**x0** : tuple or list of tuples'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0**：元组或元组列表'
- en: A point or list of evaluation points corresponding to those variables.
  id: totrans-2414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与这些变量相对应的点或评估点列表。
- en: Examples
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE749]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: 'Subs are created when a particular substitution cannot be made. The x in the
    derivative cannot be replaced with 0 because 0 is not a valid variables of differentiation:'
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定替换无法进行时创建Subs。在导数中的x无法替换为0，因为0不是一个有效的差异化变量：
- en: '[PRE750]'
  id: totrans-2418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: 'Once f is known, the derivative and evaluation at 0 can be done:'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦f已知，就可以进行导数计算和在0处的评估：
- en: '[PRE751]'
  id: totrans-2420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: 'Subs can also be created directly with one or more variables:'
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: Subs也可以直接使用一个或多个变量创建：
- en: '[PRE752]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: Notes
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Subs` objects are generally useful to represent unevaluated derivatives calculated
    at a point.'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subs`对象通常用于表示在某一点计算的未评估导数。'
- en: The variables may be expressions, but they are subjected to the limitations
    of subs(), so it is usually a good practice to use only symbols for variables,
    since in that case there can be no ambiguity.
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以是表达式，但它们受subs()的限制，因此通常最好仅对变量使用符号，因为在这种情况下不会有歧义。
- en: There’s no automatic expansion - use the method .doit() to effect all possible
    substitutions of the object and also of objects inside the expression.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动展开 - 使用方法.doit()来影响对象及其表达式内部的所有可能的替换。
- en: When evaluating derivatives at a point that is not a symbol, a Subs object is
    returned. One is also able to calculate derivatives of Subs objects - in this
    case the expression is always expanded (for the unevaluated form, use Derivative()).
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估非符号点处的导数时，将返回一个Subs对象。还可以计算Subs对象的导数 - 在这种情况下，表达式总是会被展开（对于未评估的形式，请使用Derivative()）。
- en: 'In order to allow expressions to combine before doit is done, a representation
    of the Subs expression is used internally to make expressions that are superficially
    different compare the same:'
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许表达式在执行时结合，内部使用Subs表达式的表示来使表面上不同的表达式进行比较：
- en: '[PRE753]'
  id: totrans-2429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: 'This can lead to unexpected consequences when using methods like \(has\) that
    are cached:'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像\(has\)这样的方法时可能会导致意外后果，因为它们被缓存：
- en: '[PRE754]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-2432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: The variables to be evaluated
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估的变量
- en: '[PRE756]'
  id: totrans-2434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: The expression on which the substitution operates
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 替换操作的表达式
- en: '[PRE757]'
  id: totrans-2436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: The values for which the variables are to be substituted
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
  zh: 用于替换变量的值
- en: '[PRE758]'
  id: totrans-2438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: The variables to be evaluated
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估的变量
- en: '[PRE759]'
  id: totrans-2440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: Expand an expression using methods given as hints.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的提示方法展开表达式。
- en: Explanation
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'Hints evaluated unless explicitly set to False are: `basic`, `log`, `multinomial`,
    `mul`, `power_base`, and `power_exp` The following hints are supported but not
    applied unless set to True: `complex`, `func`, and `trig`. In addition, the following
    meta-hints are supported by some or all of the other hints: `frac`, `numer`, `denom`,
    `modulus`, and `force`. `deep` is supported by all hints. Additionally, subclasses
    of Expr may define their own hints or meta-hints.'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 除非显式设置为False，否则将评估以下提示：`basic`，`log`，`multinomial`，`mul`，`power_base`和`power_exp`。以下提示受支持但仅在设置为True时应用：`complex`，`func`和`trig`。此外，其他提示也支持一些或所有其他提示的元提示：`frac`，`numer`，`denom`，`modulus`和`force`。所有提示都支持`deep`。此外，Expr的子类还可以定义自己的提示或元提示。
- en: The `basic` hint is used for any special rewriting of an object that should
    be done automatically (along with the other hints like `mul`) when expand is called.
    This is a catch-all hint to handle any sort of expansion that may not be described
    by the existing hint names. To use this hint an object should override the `_eval_expand_basic`
    method. Objects may also define their own expand methods, which are not run by
    default. See the API section below.
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic`提示用于在调用`expand`时自动完成对象的任何特殊重写（以及像`mul`这样的其他提示）。这是一个捕获所有提示的提示，用于处理可能不被现有提示名称描述的任何扩展。要使用此提示，对象应重写`_eval_expand_basic`方法。对象还可以定义其自己的展开方法，这些方法不会默认运行。请参阅下面的API部分。'
- en: If `deep` is set to `True` (the default), things like arguments of functions
    are recursively expanded. Use `deep=False` to only expand on the top level.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`deep`设置为`True`（默认值），诸如函数参数之类的东西将被递归展开。使用`deep=False`仅在顶层展开。
- en: If the `force` hint is used, assumptions about variables will be ignored in
    making the expansion.
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`force`提示，将忽略关于变量的假设以进行展开。
- en: Hints
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: These hints are run by default
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提示默认情况下会运行
- en: Mul
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: Mul
- en: 'Distributes multiplication over addition:'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 在加法上分配乘法：
- en: '[PRE760]'
  id: totrans-2451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: Multinomial
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式
- en: Expand (x + y + …)**n where n is a positive integer.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 展开`(x + y + …)**n`，其中n是正整数。
- en: '[PRE761]'
  id: totrans-2454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: Power_exp
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: Power_exp
- en: Expand addition in exponents into multiplied bases.
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 将指数中的加法展开为乘以基数。
- en: '[PRE762]'
  id: totrans-2457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: Power_base
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: Power_base
- en: Split powers of multiplied bases.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 将乘以基数的幂分开。
- en: 'This only happens by default if assumptions allow, or if the `force` meta-hint
    is used:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在默认情况下发生，如果假设允许，或者使用`force`元提示：
- en: '[PRE763]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: 'Note that in some cases where this expansion always holds, SymPy performs it
    automatically:'
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下，SymPy会自动执行此展开：
- en: '[PRE764]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: Log
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: 对数
- en: Pull out power of an argument as a coefficient and split logs products into
    sums of logs.
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数的幂作为系数提取出来，并将对数乘积分成对数和的和。
- en: 'Note that these only work if the arguments of the log function have the proper
    assumptions–the arguments must be positive and the exponents must be real–or else
    the `force` hint must be True:'
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些仅在对数函数的参数具有适当假设（参数必须为正数，指数必须为实数）或者`force`提示必须为True时才有效：
- en: '[PRE765]'
  id: totrans-2467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: Basic
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
  zh: Basic
- en: This hint is intended primarily as a way for custom subclasses to enable expansion
    by default.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示主要用于自定义子类以便默认情况下启用扩展。
- en: 'These hints are not run by default:'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提示默认情况下不运行：
- en: Complex
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂
- en: Split an expression into real and imaginary parts.
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式分成实部和虚部。
- en: '[PRE766]'
  id: totrans-2473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: Note that this is just a wrapper around `as_real_imag()`. Most objects that
    wish to redefine `_eval_expand_complex()` should consider redefining `as_real_imag()`
    instead.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是对`as_real_imag()`的包装。大多数希望重新定义`_eval_expand_complex()`的对象应考虑重新定义`as_real_imag()`。
- en: Func
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: Expand other functions.
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 展开其他函数。
- en: '[PRE767]'
  id: totrans-2477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: Trig
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 三角
- en: Do trigonometric expansions.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 进行三角展开。
- en: '[PRE768]'
  id: totrans-2480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: Note that the forms of `sin(n*x)` and `cos(n*x)` in terms of `sin(x)` and `cos(x)`
    are not unique, due to the identity \(\sin^2(x) + \cos^2(x) = 1\). The current
    implementation uses the form obtained from Chebyshev polynomials, but this may
    change. See [this MathWorld article](https://mathworld.wolfram.com/Multiple-AngleFormulas.html)
    for more information.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `sin(n*x)` 和 `cos(n*x)` 关于 `sin(x)` 和 `cos(x)` 的形式并不唯一，这是由于恒等式 \(\sin^2(x)
    + \cos^2(x) = 1\)。当前实现使用从切比雪夫多项式获得的形式，但这可能会改变。请参阅 [这篇 MathWorld 文章](https://mathworld.wolfram.com/Multiple-AngleFormulas.html)
    获取更多信息。
- en: Notes
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'You can shut off unwanted methods:'
  id: totrans-2483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以关闭不需要的方法：
- en: '[PRE769]'
  id: totrans-2484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE769]'
- en: 'Use deep=False to only expand on the top level:'
  id: totrans-2485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `deep=False` 仅在顶层扩展：
- en: '[PRE770]'
  id: totrans-2486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE770]'
- en: 'Hints are applied in an arbitrary, but consistent order (in the current implementation,
    they are applied in alphabetical order, except multinomial comes before mul, but
    this may change). Because of this, some hints may prevent expansion by other hints
    if they are applied first. For example, `mul` may distribute multiplications and
    prevent `log` and `power_base` from expanding them. Also, if `mul` is applied
    before [PRE771] helper functions or to use `hint=False` to this function to finely
    control which hints are applied. Here are some examples:'
  id: totrans-2487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示以任意但一致的顺序应用（在当前实现中，它们按字母顺序应用，但 multinomial 在 mul 之前，但这可能会改变）。因此，某些提示可能会通过首先应用它们来阻止其他提示的扩展。例如，`mul`
    可能会分配乘法并阻止 `log` 和 `power_base` 扩展它们。此外，如果 `mul` 在 [PRE771] 帮助函数之前应用，或者要使用 `hint=False`
    来精确控制哪些提示应用于此函数。以下是一些示例：
- en: '[PRE772]'
  id: totrans-2488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE772]'
- en: 'Here, we see that `log` was applied before `mul`. To get the mul expanded form,
    either of the following will work:'
  id: totrans-2489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `log` 在 `mul` 之前被应用。要获取 `mul` 的展开形式，可以使用以下任一方法：
- en: '[PRE773]'
  id: totrans-2490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'A similar thing can happen with the `power_base` hint:'
  id: totrans-2491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似的情况也可能发生在 `power_base` 提示中：
- en: '[PRE774]'
  id: totrans-2492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE774]'
- en: 'To get the `power_base` expanded form, either of the following will work:'
  id: totrans-2493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获取 `power_base` 的展开形式，可以使用以下任一方法：
- en: '[PRE775]'
  id: totrans-2494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE775]'
- en: 'The parts of a rational expression can be targeted:'
  id: totrans-2495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以针对有理表达式的部分进行目标化：
- en: '[PRE776]'
  id: totrans-2496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'The `modulus` meta-hint can be used to reduce the coefficients of an expression
    post-expansion:'
  id: totrans-2497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modulus` 元提示可用于在扩展后减少表达式的系数：'
- en: '[PRE777]'
  id: totrans-2498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE777]'
- en: 'Either `expand()` the function or `.expand()` the method can be used. Both
    are equivalent:'
  id: totrans-2499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expand()` 函数或 `.expand()` 方法都可以使用。两者是等效的：'
- en: '[PRE778]'
  id: totrans-2500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE778]'
- en: Api
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: Api
- en: 'Objects can define their own expand hints by defining `_eval_expand_hint()`.
    The function should take the form:'
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以通过定义 `_eval_expand_hint()` 来定义其自己的扩展提示。该函数应采用以下形式：
- en: '[PRE779]'
  id: totrans-2503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: See also the example below. Objects should define `_eval_expand_hint()` methods
    only if `hint` applies to that specific object. The generic `_eval_expand_hint()`
    method defined in Expr will handle the no-op case.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅下面的示例。对象应仅在特定对象适用于该提示时定义 `_eval_expand_hint()` 方法。在 Expr 中定义的通用 `_eval_expand_hint()`
    方法将处理无操作的情况。
- en: Each hint should be responsible for expanding that hint only. Furthermore, the
    expansion should be applied to the top-level expression only. `expand()` takes
    care of the recursion that happens when `deep=True`.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提示都应该负责扩展该提示。此外，扩展应该仅应用于顶层表达式。`expand()` 负责处理 `deep=True` 时发生的递归。
- en: You should only call `_eval_expand_hint()` methods directly if you are 100%
    sure that the object has the method, as otherwise you are liable to get unexpected
    [PRE780]. `_eval_expand_hint()` should generally not be used at all outside of
    an `_eval_expand_hint()` method. If you want to apply a specific expansion from
    within another method, use the public `expand()` function, method, or `expand_hint()`
    functions.
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您确信对象具有该方法时，才可以直接调用 `_eval_expand_hint()` 方法，否则可能会得到意外的结果 [PRE780]。通常情况下，应完全避免使用
    `_eval_expand_hint()`。如果您想在另一个方法内应用特定的扩展，请使用公共的 `expand()` 函数、方法或 `expand_hint()`
    函数。
- en: In order for expand to work, objects must be rebuildable by their args, i.e.,
    `obj.func(*obj.args) == obj` must hold.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使扩展正常工作，对象必须能够通过它们的参数进行重建，即 `obj.func(*obj.args) == obj` 必须成立。
- en: Expand methods are passed `**hints` so that expand hints may use ‘metahints’–hints
    that control how different expand methods are applied. For example, the `force=True`
    hint described above that causes `expand(log=True)` to ignore assumptions is such
    a metahint. The `deep` meta-hint is handled exclusively by `expand()` and is not
    passed to `_eval_expand_hint()` methods.
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法传递 `**hints`，因此扩展提示可以使用“元提示”——控制如何应用不同扩展方法的提示。例如，`force=True` 提示会导致 `expand(log=True)`
    忽略假设，这是一种元提示。`deep` 元提示仅由 `expand()` 处理，不会传递给 `_eval_expand_hint()` 方法。
- en: Note that expansion hints should generally be methods that perform some kind
    of ‘expansion’. For hints that simply rewrite an expression, use the .rewrite()
    API.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，扩展提示通常应该是执行某种“扩展”的方法。对于简单重写表达式的提示，请使用.rewrite() API。
- en: Examples
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE781]'
  id: totrans-2511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: '[PRE782]'
  id: totrans-2512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: See also
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`expand_log`](#sympy.core.function.expand_log "sympy.core.function.expand_log"),
    [`expand_mul`](#sympy.core.function.expand_mul "sympy.core.function.expand_mul"),
    [`expand_multinomial`](#sympy.core.function.expand_multinomial "sympy.core.function.expand_multinomial"),
    [`expand_complex`](#sympy.core.function.expand_complex "sympy.core.function.expand_complex"),
    [`expand_trig`](#sympy.core.function.expand_trig "sympy.core.function.expand_trig"),
    [`expand_power_base`](#sympy.core.function.expand_power_base "sympy.core.function.expand_power_base"),
    [`expand_power_exp`](#sympy.core.function.expand_power_exp "sympy.core.function.expand_power_exp"),
    [`expand_func`](#sympy.core.function.expand_func "sympy.core.function.expand_func"),
    [`sympy.simplify.hyperexpand.hyperexpand`](simplify/simplify.html#sympy.simplify.hyperexpand.hyperexpand
    "sympy.simplify.hyperexpand.hyperexpand")'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
  zh: '[`expand_log`](#sympy.core.function.expand_log "sympy.core.function.expand_log")，[`expand_mul`](#sympy.core.function.expand_mul
    "sympy.core.function.expand_mul")，[`expand_multinomial`](#sympy.core.function.expand_multinomial
    "sympy.core.function.expand_multinomial")，[`expand_complex`](#sympy.core.function.expand_complex
    "sympy.core.function.expand_complex")，[`expand_trig`](#sympy.core.function.expand_trig
    "sympy.core.function.expand_trig")，[`expand_power_base`](#sympy.core.function.expand_power_base
    "sympy.core.function.expand_power_base")，[`expand_power_exp`](#sympy.core.function.expand_power_exp
    "sympy.core.function.expand_power_exp")，[`expand_func`](#sympy.core.function.expand_func
    "sympy.core.function.expand_func")，[`sympy.simplify.hyperexpand.hyperexpand`](simplify/simplify.html#sympy.simplify.hyperexpand.hyperexpand
    "sympy.simplify.hyperexpand.hyperexpand")'
- en: '[PRE783]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: '[PRE784]'
  id: totrans-2516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: Return a representation (integer or expression) of the operations in expr.
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 返回expr中操作的表示（整数或表达式）。
- en: 'Parameters:'
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : Expr'
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：Expr'
- en: If expr is an iterable, the sum of the op counts of the items will be returned.
  id: totrans-2520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果expr是可迭代的，则将返回项的操作计数的总和。
- en: '**visual** : bool, optional'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: '**visual**：bool，可选'
- en: If `False` (default) then the sum of the coefficients of the visual expression
    will be returned. If `True` then the number of each type of operation is shown
    with the core class types (or their virtual equivalent) multiplied by the number
    of times they occur.
  id: totrans-2522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`False`（默认），则返回可视化表达式的系数之和。如果`True`，则显示每种操作类型的数量，每种核心类类型（或其虚拟等效）乘以其出现次数。
- en: Examples
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE785]'
  id: totrans-2524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'Although there is not a SUB object, minus signs are interpreted as either negations
    or subtractions:'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有SUB对象，减号被解释为否定或减法之一：
- en: '[PRE786]'
  id: totrans-2526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: 'Here, there are two Adds and a Pow:'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两个Adds和一个Pow：
- en: '[PRE787]'
  id: totrans-2528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: 'In the following, an Add, Mul, Pow and two functions:'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有一个Add，Mul，Pow和两个函数：
- en: '[PRE788]'
  id: totrans-2530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: 'for a total of 5:'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 总共为5：
- en: '[PRE789]'
  id: totrans-2532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: 'Note that “what you type” is not always what you get. The expression 1/x/y
    is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather than two
    DIVs:'
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“你输入的内容”并非总是你得到的内容。表达式1/x/y被sympy翻译为1/(x*y)，因此它会给出DIV和MUL，而不是两个DIV：
- en: '[PRE790]'
  id: totrans-2534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: 'The visual option can be used to demonstrate the difference in operations for
    expressions in different forms. Here, the Horner representation is compared with
    the expanded form of a polynomial:'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 可视选项可用于展示不同形式表达式的操作差异。在此处，Horner表示法与多项式的展开形式进行比较：
- en: '[PRE791]'
  id: totrans-2536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: 'The count_ops function also handles iterables:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: count_ops函数还处理可迭代对象：
- en: '[PRE792]'
  id: totrans-2538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[PRE793]'
  id: totrans-2539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: Wrapper around expand that only uses the mul hint. See the expand docstring
    for more information.
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用mul提示的扩展。
- en: Examples
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE794]'
  id: totrans-2542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[PRE795]'
  id: totrans-2543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: Wrapper around expand that only uses the log hint. See the expand docstring
    for more information.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用log提示的扩展。有关更多信息，请参阅扩展docstring。
- en: Examples
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE796]'
  id: totrans-2546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: '[PRE797]'
  id: totrans-2547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: Wrapper around expand that only uses the func hint. See the expand docstring
    for more information.
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用func提示的扩展。有关更多信息，请参阅扩展docstring。
- en: Examples
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE798]'
  id: totrans-2550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: '[PRE799]'
  id: totrans-2551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: Wrapper around expand that only uses the trig hint. See the expand docstring
    for more information.
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用trig提示的扩展。有关更多信息，请参阅扩展docstring。
- en: Examples
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE800]'
  id: totrans-2554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: '[PRE801]'
  id: totrans-2555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: Wrapper around expand that only uses the complex hint. See the expand docstring
    for more information.
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用complex提示的扩展。有关更多信息，请参阅扩展docstring。
- en: Examples
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE802]'
  id: totrans-2558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: See also
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.core.expr.Expr.as_real_imag`](#sympy.core.expr.Expr.as_real_imag "sympy.core.expr.Expr.as_real_imag")'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.expr.Expr.as_real_imag`](#sympy.core.expr.Expr.as_real_imag "sympy.core.expr.Expr.as_real_imag")'
- en: '[PRE803]'
  id: totrans-2561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: Wrapper around expand that only uses the multinomial hint. See the expand docstring
    for more information.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用多项式提示的扩展。有关更多信息，请参阅扩展docstring。
- en: Examples
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE804]'
  id: totrans-2564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: '[PRE805]'
  id: totrans-2565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: Wrapper around expand that only uses the power_exp hint.
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器，仅使用power_exp提示。
- en: See the expand docstring for more information.
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参见 expand 文档字符串。
- en: Examples
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE806]'
  id: totrans-2569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: 'If `x = 0` the value of the expression depends on the value of `y`; if the
    expression were expanded the result would be 0\. So expansion is only done if
    `x != 0`:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x = 0`，表达式的值取决于 `y` 的值；如果展开表达式，结果将为0。因此，仅当 `x != 0` 时才进行展开：
- en: '[PRE807]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: '[PRE808]'
  id: totrans-2572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: Wrapper around expand that only uses the power_base hint.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅使用 power_base 提示的情况下扩展的包装器。
- en: A wrapper to expand(power_base=True) which separates a power with a base that
    is a Mul into a product of powers, without performing any other expansions, provided
    that assumptions about the power’s base and exponent allow.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 将使一个以 Mul 为基数的幂展开（仅当关于幂的基数和指数的假设允许时），而不进行任何其他展开。
- en: deep=False (default is True) will only apply to the top-level expression.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: deep=False（默认为True）仅适用于顶级表达式。
- en: force=True (default is False) will cause the expansion to ignore assumptions
    about the base and exponent. When False, the expansion will only happen if the
    base is non-negative or the exponent is an integer.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: force=True（默认为False）将导致展开忽略关于基数和指数的假设。当为 False 时，仅在基数为非负数或指数为整数时才会展开。
- en: '[PRE809]'
  id: totrans-2577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: '[PRE810]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: '[PRE811]'
  id: totrans-2579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: '[PRE812]'
  id: totrans-2580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: '[PRE813]'
  id: totrans-2581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: '[PRE814]'
  id: totrans-2582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: '[PRE815]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: 'Notice that sums are left untouched. If this is not the desired behavior, apply
    full `expand()` to the expression:'
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，和式保持不变。如果这不是期望的行为，请将完整的 `expand()` 应用于表达式：
- en: '[PRE816]'
  id: totrans-2585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: '[PRE817]'
  id: totrans-2586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: 'The power that is unexpanded can be expanded safely when `y != 0`, otherwise
    different values might be obtained for the expression:'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
  zh: 未展开的幂可以在 `y != 0` 时安全展开，否则可能会得到表达式的不同值：
- en: '[PRE818]'
  id: totrans-2588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: 'If we indicate that `y` is positive but then replace it with a value of 0 after
    expansion, the expression becomes 0:'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指出 `y` 是正数，但在展开后将其替换为0，则表达式变为0：
- en: '[PRE819]'
  id: totrans-2590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: 'But if `z = -1` the expression would not be zero:'
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果 `z = -1`，表达式将不为零：
- en: '[PRE820]'
  id: totrans-2592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: See also
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`expand`](#sympy.core.function.expand "sympy.core.function.expand")'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: '[`expand`](#sympy.core.function.expand "sympy.core.function.expand")'
- en: '[PRE821]'
  id: totrans-2595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: Make all Rationals in expr Floats except those in exponents (unless the exponents
    flag is set to True) and those in undefined functions. When processing dictionaries,
    do not modify the keys unless `dkeys=True`.
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 使 expr 中所有有理数成为浮点数，除了指数中的那些（除非将 exponents 标志设置为 True）和未定义函数中的那些。在处理字典时，请不要修改键，除非
    `dkeys=True`。
- en: Examples
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE822]'
  id: totrans-2598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: 'Container types are not modified:'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 容器类型不被修改：
- en: '[PRE823]  ## evalf'
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE823]  ## evalf'
- en: '[PRE824]'
  id: totrans-2601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: Mixin class adding evalf capability.
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 evalf 能力的混合类。
- en: '[PRE825]'
  id: totrans-2603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: Evaluate the given formula to an accuracy of *n* digits.
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的公式评估到 *n* 位数的精度。
- en: 'Parameters:'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**subs** : dict, optional'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
  zh: '**subs** : 字典，可选'
- en: Substitute numerical values for symbols, e.g. `subs={x:3, y:1+pi}`. The substitutions
    must be given as a dictionary.
  id: totrans-2607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于符号的数值替换，例如 `subs={x:3, y:1+pi}`。替换必须以字典形式给出。
- en: '**maxn** : int, optional'
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: '**maxn** : 整数，可选'
- en: Allow a maximum temporary working precision of maxn digits.
  id: totrans-2609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许最大临时工作精度为 maxn 位数。
- en: '**chop** : bool or number, optional'
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
  zh: '**chop** : 布尔值或数字，可选'
- en: Specifies how to replace tiny real or imaginary parts in subresults by exact
    zeros.
  id: totrans-2611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定如何将子结果中微小的实部或虚部替换为精确的零。
- en: ''
  id: totrans-2612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `True` the chop value defaults to standard precision.
  id: totrans-2613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 `True` 时，chop 值默认为标准精度。
- en: ''
  id: totrans-2614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise the chop value is used to determine the magnitude of “small” for purposes
    of chopping.
  id: totrans-2615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，chop 值用于确定“小”的量级以进行切除。
- en: ''
  id: totrans-2616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE826]'
  id: totrans-2617
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '**strict** : bool, optional'
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
  zh: '**strict** : 布尔值，可选'
- en: Raise `PrecisionExhausted` if any subresult fails to evaluate to full accuracy,
    given the available maxprec.
  id: totrans-2619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果任何子结果未能在可用的最大精度下完全准确评估，则引发 `PrecisionExhausted`。
- en: '**quad** : str, optional'
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: '**quad** : 字符串，可选'
- en: Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature
    is used. For oscillatory integrals on an infinite interval, try `quad='osc'`.
  id: totrans-2621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择数值积分的算法。默认情况下，使用双曲正弦积分法。对于无限区间上的振荡积分，尝试 `quad='osc'`。
- en: '**verbose** : bool, optional'
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: '**verbose** : 布尔值，可选'
- en: Print debug information.
  id: totrans-2623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印调试信息。
- en: Notes
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When Floats are naively substituted into an expression, precision errors may
    adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate
    to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what
    happens in the following:'
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
  zh: 当浮点数被天真地替换到表达式中时，精度误差可能会对结果产生不利影响。例如，将1e16（一个浮点数）加到1时会截断为1e16；如果随后减去1e16，则结果将为0。以下正是发生的情况：
- en: '[PRE827]'
  id: totrans-2626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: 'Using the subs argument for evalf is the accurate way to evaluate such an expression:'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 evalf 的 subs 参数是评估此类表达式的准确方法：
- en: '[PRE828]'
  id: totrans-2628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: '[PRE829]'
  id: totrans-2629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Evaluate the given formula to an accuracy of *n* digits.
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的公式评估到 *n* 位数的精度。
- en: 'Parameters:'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**subs** : dict, optional'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
  zh: '**subs** : 字典，可选'
- en: Substitute numerical values for symbols, e.g. `subs={x:3, y:1+pi}`. The substitutions
    must be given as a dictionary.
  id: totrans-2633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 替换符号的数值值，例如 `subs={x:3, y:1+pi}`。替换必须作为字典给出。
- en: '**maxn** : int, optional'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: '**maxn**：int，可选'
- en: Allow a maximum temporary working precision of maxn digits.
  id: totrans-2635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许最大临时工作精度达到 maxn 位数。
- en: '**chop** : bool or number, optional'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: '**chop**：bool 或 number，可选'
- en: Specifies how to replace tiny real or imaginary parts in subresults by exact
    zeros.
  id: totrans-2637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定如何用精确的零替换子结果中微小的实部或虚部。
- en: ''
  id: totrans-2638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `True` the chop value defaults to standard precision.
  id: totrans-2639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 `True` 时，chop 值默认为标准精度。
- en: ''
  id: totrans-2640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise the chop value is used to determine the magnitude of “small” for purposes
    of chopping.
  id: totrans-2641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，将使用截断值来确定“小数”的量级。
- en: ''
  id: totrans-2642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE830]'
  id: totrans-2643
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE830]'
- en: '**strict** : bool, optional'
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
  zh: '**strict**：bool，可选'
- en: Raise `PrecisionExhausted` if any subresult fails to evaluate to full accuracy,
    given the available maxprec.
  id: totrans-2645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果任何子结果未能在给定的 maxprec 下完全精确计算，则抛出 `PrecisionExhausted`。
- en: '**quad** : str, optional'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: '**quad**：str，可选'
- en: Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature
    is used. For oscillatory integrals on an infinite interval, try `quad='osc'`.
  id: totrans-2647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择数值积分的算法。默认情况下，使用 tanh-sinh 积分。对于在无穷区间上的振荡积分，尝试 `quad='osc'`。
- en: '**verbose** : bool, optional'
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: '**verbose**：bool，可选'
- en: Print debug information.
  id: totrans-2649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打印调试信息。
- en: Notes
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When Floats are naively substituted into an expression, precision errors may
    adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate
    to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what
    happens in the following:'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Floats 被天真地替换到表达式中时，精度误差可能会对结果产生不利影响。例如，将 1e16（一个 Float）加到 1 中将截断为 1e16；如果然后减去
    1e16，则结果将为 0。这正是以下情况发生的：
- en: '[PRE831]'
  id: totrans-2652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: 'Using the subs argument for evalf is the accurate way to evaluate such an expression:'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 evalf 的子参数，使用此方法来准确评估这样的表达式：
- en: '[PRE832]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: '[PRE833]'
  id: totrans-2655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: '[PRE834]'
  id: totrans-2656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: Calls x.evalf(n, **options).
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 x.evalf(n, **options)。
- en: Explanations
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Both .n() and N() are equivalent to .evalf(); use the one that you like better.
    See also the docstring of .evalf() for information on the options.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: '`.n()` 和 `N()` 都等同于 `.evalf()`；使用你喜欢的那个。另请参阅 `.evalf()` 的文档字符串，了解选项信息。'
- en: Examples
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE835]  ## containers'
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE835]  ## containers'
- en: '[PRE836]'
  id: totrans-2662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: Wrapper around the builtin tuple object.
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 封装内置的 tuple 对象。
- en: 'Parameters:'
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**sympify** : bool'
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: '**sympify**：bool'
- en: If `False`, `sympify` is not called on `args`. This can be used for speedups
    for very large tuples where the elements are known to already be SymPy objects.
  id: totrans-2666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 若为 `False`，则不在 `args` 上调用 `sympify`。这可用于对已知元素为 SymPy 对象的非常大的 tuple 进行加速。
- en: Explanation
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The Tuple is a subclass of Basic, so that it works well in the SymPy framework.
    The wrapped tuple is available as self.args, but you can also access elements
    or slices with [:] syntax.
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: Tuple 是 Basic 的子类，因此在 SymPy 框架中能很好地运行。包装后的 tuple 可作为 self.args 使用，但也可以使用 [:]
    语法访问元素或切片。
- en: Examples
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE837]'
  id: totrans-2670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: '[PRE838]'
  id: totrans-2671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: Searches and returns the first index of the value.
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索并返回值的第一个索引。
- en: '[PRE839]'
  id: totrans-2673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: The kind of a Tuple instance.
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: Tuple 实例的种类。
- en: The kind of a Tuple is always of [`TupleKind`](#sympy.core.containers.TupleKind
    "sympy.core.containers.TupleKind") but parametrised by the number of elements
    and the kind of each element.
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: Tuple 的种类始终为 [`TupleKind`](#sympy.core.containers.TupleKind "sympy.core.containers.TupleKind")，但由元素数量和每个元素的种类参数化。
- en: Examples
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE840]'
  id: totrans-2677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: See also
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.matrices.kind.MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind"), [`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind
    "sympy.core.kind.NumberKind")'
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.matrices.kind.MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind"), [`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind
    "sympy.core.kind.NumberKind")'
- en: '[PRE841]'
  id: totrans-2680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: Return number of occurrences of value.
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的出现次数。
- en: '[PRE842]'
  id: totrans-2682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: TupleKind is a subclass of Kind, which is used to define Kind of `Tuple`.
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: TupleKind 是 Kind 的子类，用于定义 `Tuple` 的种类。
- en: Parameters of TupleKind will be kinds of all the arguments in Tuples, for example
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: TupleKind 的参数将是 Tuples 中所有参数的种类，例如
- en: 'Parameters:'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**args** : tuple(element_kind)'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: '**args**：tuple(element_kind)'
- en: element_kind is kind of element. args is tuple of kinds of element
  id: totrans-2687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: element_kind 是元素的种类。args 是元素种类的 tuple
- en: Examples
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE843]'
  id: totrans-2689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: See also
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind "sympy.core.kind.NumberKind"),
    [`MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind "sympy.matrices.kind.MatrixKind"),
    [`sympy.sets.sets.SetKind`](sets.html#sympy.sets.conditionset.SetKind "sympy.sets.sets.SetKind")'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind "sympy.core.kind.NumberKind"),
    [`MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind "sympy.matrices.kind.MatrixKind"),
    [`sympy.sets.sets.SetKind`](sets.html#sympy.sets.conditionset.SetKind "sympy.sets.sets.SetKind")'
- en: '[PRE844]'
  id: totrans-2692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: Wrapper around the builtin dict object.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 封装了内置的 dict 对象。
- en: Explanation
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The Dict is a subclass of Basic, so that it works well in the SymPy framework.
    Because it is immutable, it may be included in sets, but its values must all be
    given at instantiation and cannot be changed afterwards. Otherwise it behaves
    identically to the Python dict.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dict` 是 `Basic` 的子类，因此它在 SymPy 框架中表现良好。由于它是不可变的，可以包含在集合中，但其值必须在实例化时全部给定，并且不能后续更改。否则，其行为与
    Python 的 dict 完全相同。'
- en: Examples
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE845]'
  id: totrans-2697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: '[PRE846]'
  id: totrans-2698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: 'The args are sympified so the 1 and 2 are Integers and the values are Symbols.
    Queries automatically sympify args so the following work:'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被 sympify，所以 1 和 2 是整数，而值是符号。查询自动 sympify 参数，因此以下操作有效：
- en: '[PRE847]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: '[PRE848]'
  id: totrans-2701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: Returns the value for key if the key is in the dictionary.
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中，则返回键的值。
- en: '[PRE849]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: Returns a set-like object providing a view on dict’s items.
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 返回提供字典条目视图的类似集合的对象。
- en: '[PRE850]'
  id: totrans-2705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: Returns the list of the dict’s keys.
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字典键的列表。
- en: '[PRE851]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: 'Returns the list of the dict’s values.  ## exprtools'
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: '返回字典值的列表。  ## exprtools'
- en: '[PRE852]'
  id: totrans-2709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: Compute the GCD of `terms` and put them together.
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `terms` 的最大公约数并将它们放在一起。
- en: 'Parameters:'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**terms** : Expr'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
  zh: '**terms** : 表达式'
- en: Can be an expression or a non-Basic sequence of expressions which will be handled
    as though they are terms from a sum.
  id: totrans-2713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以是一个表达式或非 Basic 序列的表达式，这将被处理为一个求和项。
- en: '**isprimitive** : bool, optional'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
  zh: '**isprimitive** : 布尔值，可选'
- en: If `isprimitive` is True the _gcd_terms will not run the primitive method on
    the terms.
  id: totrans-2715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `isprimitive` 为 True，则 _gcd_terms 不会在项上运行原始方法。
- en: '**clear** : bool, optional'
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: '**clear** : 布尔值，可选'
- en: It controls the removal of integers from the denominator of an Add expression.
    When True (default), all numerical denominator will be cleared; when False the
    denominators will be cleared only if all terms had numerical denominators other
    than 1.
  id: totrans-2717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它控制从 Add 表达式的分母中移除整数的操作。当为 True（默认）时，将清除所有数值分母；当为 False 时，仅当所有项的数值分母不为 1 时，才清除分母。
- en: '**fraction** : bool, optional'
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: '**fraction** : 布尔值，可选'
- en: When True (default), will put the expression over a common denominator.
  id: totrans-2719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当为 True（默认）时，将表达式置于通用分母之上。
- en: Examples
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE853]'
  id: totrans-2721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: '[PRE854]'
  id: totrans-2722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: '[PRE855]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: The `clear` flag was ignored in this case because the returned expression was
    a rational expression, not a simple sum.
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`clear` 标志被忽略，因为返回的表达式是一个有理数表达式，而不是一个简单的求和。
- en: See also
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`factor_terms`](#sympy.core.exprtools.factor_terms "sympy.core.exprtools.factor_terms"),
    [`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")'
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factor_terms`](#sympy.core.exprtools.factor_terms "sympy.core.exprtools.factor_terms")，[`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")'
- en: '[PRE856]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: Remove common factors from terms in all arguments without changing the underlying
    structure of the expr. No expansion or simplification (and no processing of non-commutatives)
    is performed.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有参数的项中去除公共因子，而不改变表达式的基本结构。不进行展开或简化（也不处理非交换元素）。
- en: 'Parameters:'
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**radical: bool, optional**'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: '**radical: 布尔值，可选**'
- en: If radical=True then a radical common to all terms will be factored out of any
    Add sub-expressions of the expr.
  id: totrans-2731
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 radical=True，则所有项的常见根号将从表达式的任何 Add 子表达式中因式分解出来。
- en: '**clear** : bool, optional'
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: '**clear** : 布尔值，可选'
- en: If clear=False (default) then coefficients will not be separated from a single
    Add if they can be distributed to leave one or more terms with integer coefficients.
  id: totrans-2733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 clear=False（默认值），则不会从单个 Add 中分离系数，如果可以分布到一个或多个具有整数系数的项中。
- en: '**fraction** : bool, optional'
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: '**fraction** : 布尔值，可选'
- en: If fraction=True (default is False) then a common denominator will be constructed
    for the expression.
  id: totrans-2735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 fraction=True（默认为 False），则将为表达式构造一个通用分母。
- en: '**sign** : bool, optional'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: '**sign** : 布尔值，可选'
- en: If sign=True (default) then even if the only factor in common is a -1, it will
    be factored out of the expression.
  id: totrans-2737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 sign=True（默认值），即使唯一的共同因子是 -1，它也会从表达式中因式分解出来。
- en: Examples
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE857]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: 'When `clear` is False, a rational will only be factored out of an Add expression
    if all terms of the Add have coefficients that are fractions:'
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `clear` 为 False 时，如果 Add 表达式的所有项的系数都是分数，则仅从中因式分解出一个有理数：
- en: '[PRE858]'
  id: totrans-2741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: 'If a -1 is all that can be factored out, to *not* factor it out, the flag `sign`
    must be False:'
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 -1 是唯一可以因式分解的内容，则 *不* 因式分解它，`sign` 标志必须为 False：
- en: '[PRE859]'
  id: totrans-2743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: See also
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`gcd_terms`](#sympy.core.exprtools.gcd_terms "sympy.core.exprtools.gcd_terms"),
    [`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")  ## kind'
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: '[`gcd_terms`](#sympy.core.exprtools.gcd_terms "sympy.core.exprtools.gcd_terms")，[`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")  ## 类型'
- en: '[PRE860]'
  id: totrans-2746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: Base class for kinds.
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: 种类的基类。
- en: Kind of the object represents the mathematical classification that the entity
    falls into. It is expected that functions and classes recognize and filter the
    argument by its kind.
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的种类表示实体所属的数学分类。函数和类应当通过其种类来识别和过滤参数。
- en: Kind of every object must be carefully selected so that it shows the intention
    of design. Expressions may have different kind according to the kind of its arguments.
    For example, arguments of `Add` must have common kind since addition is group
    operator, and the resulting `Add()` has the same kind.
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象的种类必须谨慎选择，以表明设计意图。根据其参数的种类，表达式可能有不同的种类。例如，`Add`的参数必须具有共同的种类，因为加法是群操作符，而生成的`Add()`也具有相同的种类。
- en: For the performance, each kind is as broad as possible and is not based on set
    theory. For example, `NumberKind` includes not only complex number but expression
    containing `S.Infinity` or `S.NaN` which are not strictly number.
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能，每种种类尽可能广泛，并且不基于集合理论。例如，`NumberKind`不仅包括复数，还包括包含非严格数字`S.Infinity`或`S.NaN`的表达式。
- en: Kind may have arguments as parameter. For example, `MatrixKind()` may be constructed
    with one element which represents the kind of its elements.
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: 种类可以作为参数具有参数。例如，`MatrixKind()`可以用一个元素构造，该元素表示其元素的种类。
- en: '`Kind` behaves in singleton-like fashion. Same signature will return the same
    object.'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kind`表现得像单例模式。相同的签名将返回相同的对象。'
- en: '[PRE861]'
  id: totrans-2753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: alias of NumberKind
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberKind`的别名'
- en: '[PRE862]'
  id: totrans-2755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: alias of UndefinedKind
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: '`UndefinedKind`的别名'
- en: '[PRE863]'
  id: totrans-2757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: alias of BooleanKind
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: '`BooleanKind`的别名'
- en: Sorting
  id: totrans-2759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: '[PRE864]'
  id: totrans-2760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: Return a key that can be used for sorting.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 返回可用于排序的关键字。
- en: 'The key has the structure:'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字的结构如下：
- en: (class_key, (len(args), args), exponent.sort_key(), coefficient)
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: (class_key, (len(args), args), exponent.sort_key(), coefficient)
- en: This key is supplied by the sort_key routine of Basic objects when `item` is
    a Basic object or an object (other than a string) that sympifies to a Basic object.
    Otherwise, this function produces the key.
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 当`item`是Basic对象或符号化为Basic对象的对象（而不是字符串）时，此关键字由Basic对象的`sort_key`例程提供。否则，此函数将生成关键字。
- en: 'The `order` argument is passed along to the sort_key routine and is used to
    determine how the terms *within* an expression are ordered. (See examples below)
    `order` options are: ‘lex’, ‘grlex’, ‘grevlex’, and reversed values of the same
    (e.g. ‘rev-lex’). The default order value is None (which translates to ‘lex’).'
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`参数传递给`sort_key`例程，并用于确定表达式中项的顺序。 （请参见下面的示例）`order`选项包括：''lex''，''grlex''，''grevlex''和相同的反向值（例如''rev-lex''）。默认的`order`值为None（即''lex''）。'
- en: Examples
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE865]'
  id: totrans-2767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: 'The following are equivalent ways of getting the key for an object:'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对象关键字的等效方法如下：
- en: '[PRE866]'
  id: totrans-2769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: 'Here are some examples of the key that is produced:'
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的关键字的一些示例：
- en: '[PRE867]'
  id: totrans-2771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: 'While sort_key is a method only defined for SymPy objects, default_sort_key
    will accept anything as an argument so it is more robust as a sorting key. For
    the following, using key= lambda i: i.sort_key() would fail because 2 does not
    have a sort_key method; that’s why default_sort_key is used. Note, that it also
    handles sympification of non-string items likes ints:'
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然`sort_key`是SymPy对象专有的方法，但`default_sort_key`将接受任何参数作为参数，因此作为排序关键字更加健壮。对于下面的例子，使用`key=lambda
    i: i.sort_key()`会失败，因为2没有`sort_key`方法；这就是为什么使用`default_sort_key`。请注意，它还处理非字符串项（如整数）的符号化：'
- en: '[PRE868]'
  id: totrans-2773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: 'The returned key can be used anywhere that a key can be specified for a function,
    e.g. sort, min, max, etc…:'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的关键字可用于函数中可以指定关键字的任何位置，例如排序、最小值、最大值等：
- en: '[PRE869]'
  id: totrans-2775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: Notes
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'The key returned is useful for getting items into a canonical order that will
    be the same across platforms. It is not directly useful for sorting lists of expressions:'
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的关键字可用于按照平台通用的规范顺序获取项目。它并不直接用于对表达式列表进行排序：
- en: '[PRE870]'
  id: totrans-2778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: 'Since `a` has only 1 term, its value of sort_key is unaffected by `order`:'
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`a`只有1个项，其`sort_key`值不受`order`的影响：
- en: '[PRE871]'
  id: totrans-2780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: 'If `a` and `b` are combined then the key will differ because there are terms
    that can be ordered:'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合并`a`和`b`，则关键字将不同，因为可以排序的项有所不同：
- en: '[PRE872]'
  id: totrans-2782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: 'But since the keys for each of these terms are independent of `order`’s value,
    they do not sort differently when they appear separately in a list:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于每个项的关键字都独立于`order`的值，因此当它们单独出现在列表中时，它们不会按不同的顺序排序：
- en: '[PRE873]'
  id: totrans-2784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: The order of terms obtained when using these keys is the order that would be
    obtained if those terms were *factors* in a product.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些关键字时获得的项的顺序是在一个乘积中作为*因子*时获得的顺序。
- en: 'Although it is useful for quickly putting expressions in canonical order, it
    does not sort expressions based on their complexity defined by the number of operations,
    power of variables and others:'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它对于快速将表达式放入规范顺序很有用，但它不根据操作数量、变量的幂次和其他定义的复杂性对表达式进行排序：
- en: '[PRE874]'
  id: totrans-2787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: See also
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`ordered`](#sympy.core.sorting.ordered "sympy.core.sorting.ordered"), [`sympy.core.expr.Expr.as_ordered_factors`](#sympy.core.expr.Expr.as_ordered_factors
    "sympy.core.expr.Expr.as_ordered_factors"), [`sympy.core.expr.Expr.as_ordered_terms`](#sympy.core.expr.Expr.as_ordered_terms
    "sympy.core.expr.Expr.as_ordered_terms")'
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: '[有序](#sympy.core.sorting.ordered "sympy.core.sorting.ordered")，[sympy.core.expr.Expr.as_ordered_factors](#sympy.core.expr.Expr.as_ordered_factors
    "sympy.core.expr.Expr.as_ordered_factors")，[sympy.core.expr.Expr.as_ordered_terms](#sympy.core.expr.Expr.as_ordered_terms
    "sympy.core.expr.Expr.as_ordered_terms")'
- en: '[PRE875]'
  id: totrans-2790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: 'Return an iterator of the seq where keys are used to break ties in a conservative
    fashion: if, after applying a key, there are no ties then no other keys will be
    computed.'
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个序列的迭代器，其中键被保守地用于打破平局：如果应用一个键后没有平局，则不会计算其他键。
- en: Two default keys will be applied if 1) keys are not provided or 2) the given
    keys do not resolve all ties (but only if `default` is True). The two keys are
    `_nodes` (which places smaller expressions before large) and `default_sort_key`
    which (if the `sort_key` for an object is defined properly) should resolve any
    ties. This strategy is similar to sorting done by `Basic.compare`, but differs
    in that `ordered` never makes a decision based on an objects name.
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供键或给定键未解决所有平局（但仅当`default`为True时），将应用两个默认键：`_nodes`（将较小的表达式放在前面）和`default_sort_key`（如果对象的`sort_key`正确定义，则应解决任何平局）。此策略类似于`Basic.compare`所做的排序，但不同之处在于`ordered`从不基于对象名称做决定。
- en: If `warn` is True then an error will be raised if there were no keys remaining
    to break ties. This can be used if it was expected that there should be no ties
    between items that are not identical.
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`warn`为True，则如果没有剩余的键来打破平局，则会引发错误。如果预期不应该有非相同项目之间的平局，则可以使用此功能。
- en: Examples
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE876]'
  id: totrans-2795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: 'The count_ops is not sufficient to break ties in this list and the first two
    items appear in their original order (i.e. the sorting is stable):'
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_ops`不足以在此列表中打破平局，并且前两个项目以其原始顺序出现（即排序是稳定的）：'
- en: '[PRE877]'
  id: totrans-2797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: 'The default_sort_key allows the tie to be broken:'
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_sort_key`允许打破平局：'
- en: '[PRE878]'
  id: totrans-2799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: 'Here, sequences are sorted by length, then sum:'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，序列按长度排序，然后按总和排序：
- en: '[PRE879]'
  id: totrans-2801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: 'If `warn` is True, an error will be raised if there were not enough keys to
    break ties:'
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`warn`为True，则如果没有足够的键来打破平局，则会引发错误：
- en: '[PRE880]'
  id: totrans-2803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: Notes
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'The decorated sort is one of the fastest ways to sort a sequence for which
    special item comparison is desired: the sequence is decorated, sorted on the basis
    of the decoration (e.g. making all letters lower case) and then undecorated. If
    one wants to break ties for items that have the same decorated value, a second
    key can be used. But if the second key is expensive to compute then it is inefficient
    to decorate all items with both keys: only those items having identical first
    key values need to be decorated. This function applies keys successively only
    when needed to break ties. By yielding an iterator, use of the tie-breaker is
    delayed as long as possible.'
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰排序是希望特定项目比较的一种最快排序序列的方式之一：序列被装饰，根据装饰进行排序（例如将所有字母变成小写），然后取消装饰。如果想要打破具有相同装饰值项目的平局，则可以使用第二个键。但是如果计算第二个键很昂贵，那么使用两个键来装饰所有项目是低效的：只有具有相同第一个键值的项目才需要装饰。该函数仅在需要打破平局时连续应用键。通过生成迭代器，使用打破平局者被尽可能延迟使用。
- en: This function is best used in cases when use of the first key is expected to
    be a good hashing function; if there are no unique hashes from application of
    a key, then that key should not have been used. The exception, however, is that
    even if there are many collisions, if the first group is small and one does not
    need to process all items in the list then time will not be wasted sorting what
    one was not interested in. For example, if one were looking for the minimum in
    a list and there were several criteria used to define the sort order, then this
    function would be good at returning that quickly if the first group of candidates
    is small relative to the number of items being processed.
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: 当预期使用第一个键作为良好的哈希函数时，此函数最好用于案例；如果从键的应用中没有唯一的哈希，则不应该使用该键。但例外情况是，即使有许多碰撞，如果第一组较小并且不需要处理列表中的所有项，则不会浪费时间对不感兴趣的内容进行排序。例如，如果要在列表中查找最小值，并且有几个标准用于定义排序顺序，那么如果第一组候选人相对于正在处理的项目数较小，则此功能将快速返回结果。
- en: '## Random'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: '## 随机'
- en: When you need to use random numbers in SymPy library code, import from here
    so there is only one generator working for SymPy. Imports from here should behave
    the same as if they were being imported from Python’s random module. But only
    the routines currently used in SymPy are included here. To use others import `rng`
    and access the method directly. For example, to capture the current state of the
    generator use `rng.getstate()`.
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在SymPy库代码中使用随机数时，请从这里导入，以便为SymPy仅工作一个生成器。从这里导入应该与从Python的随机模块导入的行为相同。但这里仅包括当前在SymPy中使用的例程。要使用其他例程，请导入`rng`并直接访问方法。例如，要捕获生成器的当前状态，请使用`rng.getstate()`。
- en: There is intentionally no Random to import from here. If you want to control
    the state of the generator, import `seed` and call it with or without an argument
    to set the state.
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有意没有Random可供导入。如果要控制生成器的状态，请导入`seed`并调用它，可以带参数也可以不带参数来设置状态。
- en: Examples
  id: totrans-2810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE881]'
  id: totrans-2811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: '[PRE882]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: Return a random complex number.
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个随机复数。
- en: To reduce chance of hitting branch cuts or anything, we guarantee b <= Im z
    <= d, a <= Re z <= c
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少命中分支切割或任何东西的机会，我们保证b <= Im z <= d，a <= Re z <= c
- en: When rational is True, a rational approximation to a random number is obtained
    within specified tolerance, if any.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: 当rational为True时，可以在指定的容差范围内获得对随机数的有理逼近。
- en: '[PRE883]'
  id: totrans-2816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: Test numerically that f and g agree when evaluated in the argument z.
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 数值上测试在参数z处评估时f和g是否一致。
- en: If z is None, all symbols will be tested. This routine does not test whether
    there are Floats present with precision higher than 15 digits so if there are,
    your results may not be what you expect due to round- off errors.
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: 如果z为None，则将测试所有符号。此例程不测试是否存在精度高于15位的浮点数，因此如果有，则由于舍入误差，您的结果可能不符合预期。
- en: Examples
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE884]'
  id: totrans-2820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: '[PRE885]'
  id: totrans-2821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: Test numerically that the symbolically computed derivative of f with respect
    to z is correct.
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 数值上测试f对z的符号计算导数是否正确。
- en: This routine does not test whether there are Floats present with precision higher
    than 15 digits so if there are, your results may not be what you expect due to
    round-off errors.
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程不测试是否存在精度高于15位的浮点数，因此如果有，则由于舍入误差，您的结果可能不符合预期。
- en: Examples
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE886]'
  id: totrans-2825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: '[PRE887]'
  id: totrans-2826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: Return a randrange generator.
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个randrange生成器。
- en: '`seed` can be'
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed`可以'
- en: None - return randomly seeded generator
  id: totrans-2829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: None - 返回随机种子生成器
- en: int - return a generator seeded with the int
  id: totrans-2830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int - 返回用int种子的生成器
- en: list - the values to be returned will be taken from the list in the order given;
    the provided list is not modified.
  id: totrans-2831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: list - 将返回的值按给定顺序从列表中取出；不修改提供的列表。
- en: Examples
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE888]'
  id: totrans-2833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: '[PRE889]'
  id: totrans-2834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: Return a randint generator.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个randint生成器。
- en: '`seed` can be'
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed`可以'
- en: None - return randomly seeded generator
  id: totrans-2837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: None - 返回随机种子生成器
- en: int - return a generator seeded with the int
  id: totrans-2838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int - 返回用int种子的生成器
- en: list - the values to be returned will be taken from the list in the order given;
    the provided list is not modified.
  id: totrans-2839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: list - 将返回的值按给定顺序从列表中取出；不修改提供的列表。
- en: Examples
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE890]  ## Traversal'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE890]  ## 遍历'
- en: '[PRE891]'
  id: totrans-2842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: Apply `F` to all expressions in an expression tree from the bottom up. If `atoms`
    is True, apply `F` even if there are no args; if `nonbasic` is True, try to apply
    `F` to non-Basic objects.
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 对表达式树中的所有表达式从底向上应用`F`。如果`atoms`为True，则即使没有参数也应用`F`；如果`nonbasic`为True，则尝试将`F`应用于非基本对象。
- en: '[PRE892]'
  id: totrans-2844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: Do a postorder traversal of a tree.
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 对树进行后序遍历。
- en: This generator recursively yields nodes that it has visited in a postorder fashion.
    That is, it descends through the tree depth-first to yield all of a node’s children’s
    postorder traversal before yielding the node itself.
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: 此生成器以后序方式递归地生成已访问的节点。也就是说，它通过深度优先方式下降以生成所有节点子节点的后序遍历，然后才生成节点本身。
- en: 'Parameters:'
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**node** : SymPy expression'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: '**node**：SymPy 表达式'
- en: The expression to traverse.
  id: totrans-2849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遍历表达式。
- en: '**keys** : (default None) sort key(s)'
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: '**keys**：（默认为 None）排序键'
- en: The key(s) used to sort args of Basic objects. When None, args of Basic objects
    are processed in arbitrary order. If key is defined, it will be passed along to
    ordered() as the only key(s) to use to sort the arguments; if `key` is simply
    True then the default keys of `ordered` will be used (node count and default_sort_key).
  id: totrans-2851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于排序 Basic 对象的键。当为 None 时，处理 Basic 对象的 args 的顺序是任意的。如果定义了 key，则它将作为唯一的键传递给 ordered()；如果
    `key` 简单地为 True，则将使用 ordered 的默认键（节点计数和默认排序键）。
- en: 'Yields:'
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '**subtree** : SymPy expression'
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
  zh: '**子树**：SymPy 表达式'
- en: All of the subtrees in the tree.
  id: totrans-2854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 树中的所有子树。
- en: Examples
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE893]'
  id: totrans-2856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: The nodes are returned in the order that they are encountered unless key is
    given; simply passing key=True will guarantee that the traversal is unique.
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 节点按照遇到的顺序返回，除非提供了关键字；仅传递 key=True 将确保遍历是唯一的。
- en: '[PRE894]'
  id: totrans-2858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: '[PRE895]'
  id: totrans-2859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: Do a pre-order traversal of a tree.
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 对树进行先序遍历。
- en: This iterator recursively yields nodes that it has visited in a pre-order fashion.
    That is, it yields the current node then descends through the tree breadth-first
    to yield all of a node’s children’s pre-order traversal.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 此迭代器以先序方式递归地生成已访问的节点。也就是说，它生成当前节点，然后以广度优先方式下降以生成所有节点子节点的先序遍历。
- en: For an expression, the order of the traversal depends on the order of .args,
    which in many cases can be arbitrary.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式，遍历的顺序取决于 .args 的顺序，在许多情况下可以是任意的。
- en: 'Parameters:'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**node** : SymPy expression'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
  zh: '**node**：SymPy 表达式'
- en: The expression to traverse.
  id: totrans-2865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遍历表达式。
- en: '**keys** : (default None) sort key(s)'
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: '**keys**：（默认为 None）排序键'
- en: The key(s) used to sort args of Basic objects. When None, args of Basic objects
    are processed in arbitrary order. If key is defined, it will be passed along to
    ordered() as the only key(s) to use to sort the arguments; if `key` is simply
    True then the default keys of ordered will be used.
  id: totrans-2867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于排序 Basic 对象的键。当为 None 时，处理 Basic 对象的 args 的顺序是任意的。如果定义了 key，则它将作为唯一的键传递给 ordered()；如果
    `key` 简单地为 True，则将使用 ordered 的默认键。
- en: 'Yields:'
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '**subtree** : SymPy expression'
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: '**子树**：SymPy 表达式'
- en: All of the subtrees in the tree.
  id: totrans-2870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 树中的所有子树。
- en: Examples
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE896]'
  id: totrans-2872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: The nodes are returned in the order that they are encountered unless key is
    given; simply passing key=True will guarantee that the traversal is unique.
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
  zh: 节点按照遇到的顺序返回，除非提供了关键字；仅传递 key=True 将确保遍历是唯一的。
- en: '[PRE897]'
  id: totrans-2874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: '[PRE898]'
  id: totrans-2875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: Use `func` to transform `expr` at the given level.
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `func` 在给定级别转换 `expr`。
- en: Examples
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE899]'
  id: totrans-2878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: '[PRE900]'
  id: totrans-2879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: '[PRE901]'
  id: totrans-2880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: '[PRE902]'
  id: totrans-2881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: Iterate through the args that are the given types (target) and return a list
    of the args that were traversed; arguments that are not of the specified types
    are not traversed.
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历给定类型的参数并返回遍历过的参数列表；不是指定类型的参数不会遍历。
- en: Examples
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE903]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: See also
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`bottom_up`](#sympy.core.traversal.bottom_up "sympy.core.traversal.bottom_up")'
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: '[`bottom_up`](#sympy.core.traversal.bottom_up "sympy.core.traversal.bottom_up")'
