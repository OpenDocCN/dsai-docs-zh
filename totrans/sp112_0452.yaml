- en: scipy.optimize.curve_fit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use non-linear least squares to fit a function, f, to data.
  prefs: []
  type: TYPE_NORMAL
- en: Assumes `ydata = f(xdata, *params) + eps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The model function, f(x, …). It must take the independent variable as the first
    argument and the parameters to fit as separate remaining arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**xdata**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable where the data is measured. Should usually be an M-length
    sequence or an (k,M)-shaped array for functions with k predictors, and each element
    should be float convertible if it is an array like object.
  prefs: []
  type: TYPE_NORMAL
- en: '**ydata**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The dependent data, a length M array - nominally `f(xdata, ...)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**p0**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess for the parameters (length N). If None, then the initial values
    will all be 1 (if the number of parameters for the function can be determined
    using introspection, otherwise a ValueError is raised).
  prefs: []
  type: TYPE_NORMAL
- en: '**sigma**None or scalar or M-length sequence or MxM array, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determines the uncertainty in *ydata*. If we define residuals as `r = ydata
    - f(xdata, *popt)`, then the interpretation of *sigma* depends on its number of
    dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: A scalar or 1-D *sigma* should contain values of standard deviations of errors
    in *ydata*. In this case, the optimized function is `chisq = sum((r / sigma) **
    2)`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A 2-D *sigma* should contain the covariance matrix of errors in *ydata*. In
    this case, the optimized function is `chisq = r.T @ inv(sigma) @ r`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 0.19.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None (default) is equivalent of 1-D *sigma* filled with ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**absolute_sigma**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, *sigma* is used in an absolute sense and the estimated parameter covariance
    *pcov* reflects these absolute values.
  prefs: []
  type: TYPE_NORMAL
- en: If False (default), only the relative magnitudes of the *sigma* values matter.
    The returned parameter covariance matrix *pcov* is based on scaling *sigma* by
    a constant factor. This constant is set by demanding that the reduced *chisq*
    for the optimal parameters *popt* when using the *scaled* *sigma* equals unity.
    In other words, *sigma* is scaled to match the sample variance of the residuals
    after the fit. Default is False. Mathematically, `pcov(absolute_sigma=False) =
    pcov(absolute_sigma=True) * chisq(popt)/(M-N)`
  prefs: []
  type: TYPE_NORMAL
- en: '**check_finite**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, check that the input arrays do not contain nans of infs, and raise
    a ValueError if they do. Setting this parameter to False may silently produce
    nonsensical results if the input arrays do contain nans. Default is True if *nan_policy*
    is not specified explicitly and False otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**2-tuple of array_like or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lower and upper bounds on parameters. Defaults to no bounds. There are two
    ways to specify the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2-tuple of array_like: Each element of the tuple must be either an array with
    the length equal to the number of parameters, or a scalar (in which case the bound
    is taken to be the same for all parameters). Use `np.inf` with an appropriate
    sign to disable bounds on all or some parameters.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**method**{‘lm’, ‘trf’, ‘dogbox’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use for optimization. See [`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") for more details. Default is ‘lm’ for unconstrained
    problems and ‘trf’ if *bounds* are provided. The method ‘lm’ won’t work when the
    number of observations is less than the number of variables, use ‘trf’ or ‘dogbox’
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.17.
  prefs: []
  type: TYPE_NORMAL
- en: '**jac**callable, string or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Function with signature `jac(x, ...)` which computes the Jacobian matrix of
    the model function with respect to parameters as a dense array_like structure.
    It will be scaled according to provided *sigma*. If None (default), the Jacobian
    will be estimated numerically. String keywords for ‘trf’ and ‘dogbox’ methods
    can be used to select a finite difference scheme, see [`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.18.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**boolean, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If True, this function returns additioal information: *infodict*, *mesg*, and
    *ier*.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: '**nan_policy**{‘raise’, ‘omit’, None}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defines how to handle when input contains nan. The following options are available
    (default is None):'
  prefs: []
  type: TYPE_NORMAL
- en: '‘raise’: throws an error'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘omit’: performs the calculations ignoring nan values'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'None: no special handling of NaNs is performed (except what is done by check_finite);
    the behavior when NaNs are present is implementation-dependent and may change.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if this value is specified explicitly (not None), *check_finite* will
    be set as False.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.11.
  prefs: []
  type: TYPE_NORMAL
- en: '****kwargs**'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments passed to [`leastsq`](scipy.optimize.leastsq.html#scipy.optimize.leastsq
    "scipy.optimize.leastsq") for `method='lm'` or [`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**popt**array'
  prefs: []
  type: TYPE_NORMAL
- en: Optimal values for the parameters so that the sum of the squared residuals of
    `f(xdata, *popt) - ydata` is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: '**pcov**2-D array'
  prefs: []
  type: TYPE_NORMAL
- en: The estimated approximate covariance of popt. The diagonals provide the variance
    of the parameter estimate. To compute one standard deviation errors on the parameters,
    use `perr = np.sqrt(np.diag(pcov))`. Note that the relationship between *cov*
    and parameter error estimates is derived based on a linear approximation to the
    model function around the optimum [1]. When this approximation becomes inaccurate,
    *cov* may not provide an accurate measure of uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: How the *sigma* parameter affects the estimated covariance depends on *absolute_sigma*
    argument, as described above.
  prefs: []
  type: TYPE_NORMAL
- en: If the Jacobian matrix at the solution doesn’t have a full rank, then ‘lm’ method
    returns a matrix filled with `np.inf`, on the other hand ‘trf’ and ‘dogbox’ methods
    use Moore-Penrose pseudoinverse to compute the covariance matrix. Covariance matrices
    with large condition numbers (e.g. computed with [`numpy.linalg.cond`](https://numpy.org/devdocs/reference/generated/numpy.linalg.cond.html#numpy.linalg.cond
    "(in NumPy v2.0.dev0)")) may indicate that results are unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: '**infodict**dict (returned only if *full_output* is True)'
  prefs: []
  type: TYPE_NORMAL
- en: 'a dictionary of optional outputs with the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nfev`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of function calls. Methods ‘trf’ and ‘dogbox’ do not count function
    calls for numerical Jacobian approximation, as opposed to ‘lm’ method.
  prefs: []
  type: TYPE_NORMAL
- en: '`fvec`'
  prefs: []
  type: TYPE_NORMAL
- en: The residual values evaluated at the solution, for a 1-D *sigma* this is `(f(x,
    *popt) - ydata)/sigma`.
  prefs: []
  type: TYPE_NORMAL
- en: '`fjac`'
  prefs: []
  type: TYPE_NORMAL
- en: A permutation of the R matrix of a QR factorization of the final approximate
    Jacobian matrix, stored column wise. Together with ipvt, the covariance of the
    estimate can be approximated. Method ‘lm’ only provides this information.
  prefs: []
  type: TYPE_NORMAL
- en: '`ipvt`'
  prefs: []
  type: TYPE_NORMAL
- en: An integer array of length N which defines a permutation matrix, p, such that
    fjac*p = q*r, where r is upper triangular with diagonal elements of nonincreasing
    magnitude. Column j of p is column ipvt(j) of the identity matrix. Method ‘lm’
    only provides this information.
  prefs: []
  type: TYPE_NORMAL
- en: '`qtf`'
  prefs: []
  type: TYPE_NORMAL
- en: The vector (transpose(q) * fvec). Method ‘lm’ only provides this information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: '**mesg**str (returned only if *full_output* is True)'
  prefs: []
  type: TYPE_NORMAL
- en: A string message giving information about the solution.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: '**ier**int (returned only if *full_output* is True)'
  prefs: []
  type: TYPE_NORMAL
- en: An integer flag. If it is equal to 1, 2, 3 or 4, the solution was found. Otherwise,
    the solution was not found. In either case, the optional output variable *mesg*
    gives more information.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: ValueError
  prefs: []
  type: TYPE_NORMAL
- en: if either *ydata* or *xdata* contain NaNs, or if incompatible options are used.
  prefs: []
  type: TYPE_NORMAL
- en: RuntimeError
  prefs: []
  type: TYPE_NORMAL
- en: if the least-squares minimization fails.
  prefs: []
  type: TYPE_NORMAL
- en: OptimizeWarning
  prefs: []
  type: TYPE_NORMAL
- en: if covariance of the parameters can not be estimated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the sum of squares of nonlinear functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.stats.linregress`](scipy.stats.linregress.html#scipy.stats.linregress
    "scipy.stats.linregress")'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate a linear least squares regression for two sets of measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Users should ensure that inputs *xdata*, *ydata*, and the output of *f* are
    `float64`, or else the optimization may return incorrect results.
  prefs: []
  type: TYPE_NORMAL
- en: With `method='lm'`, the algorithm uses the Levenberg-Marquardt algorithm through
    [`leastsq`](scipy.optimize.leastsq.html#scipy.optimize.leastsq "scipy.optimize.leastsq").
    Note that this algorithm can only deal with unconstrained problems.
  prefs: []
  type: TYPE_NORMAL
- en: Box constraints can be handled by methods ‘trf’ and ‘dogbox’. Refer to the docstring
    of [`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") for more information.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] K. Vugrin et al. Confidence region estimation techniques for nonlinear'
  prefs: []
  type: TYPE_NORMAL
- en: 'regression in groundwater flow: Three case studies. Water Resources Research,
    Vol. 43, W03423, [DOI:10.1029/2005WR004804](https://doi.org/10.1029/2005WR004804)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the data to be fit with some noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Fit for the parameters a, b, c of the function *func*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Constrain the optimization to the region of `0 <= a <= 3`, `0 <= b <= 1` and
    `0 <= c <= 0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-optimize-curve_fit-1_00_00.png](../Images/47da01739fd3987e89d6c69c1d1c5cc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For reliable results, the model *func* should not be overparametrized; redundant
    parameters can cause unreliable covariance matrices and, in some cases, poorer
    quality fits. As a quick check of whether the model may be overparameterized,
    calculate the condition number of the covariance matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is small, so it does not raise much concern. If, however, we were
    to add a fourth parameter `d` to *func* with the same effect as `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a large value is cause for concern. The diagonal elements of the covariance
    matrix, which is related to uncertainty of the fit, gives more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first and last terms are much larger than the other elements,
    suggesting that the optimal values of these parameters are ambiguous and that
    only one of these parameters is needed in the model.
  prefs: []
  type: TYPE_NORMAL
