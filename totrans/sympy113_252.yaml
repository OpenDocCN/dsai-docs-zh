- en: Iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/utilities/iterables.html](https://docs.sympy.org/latest/modules/utilities/iterables.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use this as mixin when creating a class which is not supposed to return true
    when iterable() is called on its instances because calling list() on the instance,
    for example, would result in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generates the binary partition of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: A binary partition consists only of numbers that are powers of two. Each step
    reduces a \(2^{k+1}\) to \(2^k\) and \(2^k\). Thus 16 is converted to 8 and 8.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1053](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: TAOCP 4, section 7.2.1.5, problem 64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper to necklaces to return a free (unrestricted) necklace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Return the printed output of func().
  prefs: []
  type: TYPE_NORMAL
- en: '`func` should be a function without arguments that produces output with print
    statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Return the subsequence that is a common start of sequences in `seqs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Return the subsequence that is a common ending of sequences in `seqs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Connected components of an undirected graph or weakly connected components of
    a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**G** : tuple[list, list[tuple[T, T]]'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple consisting of a list of vertices and a list of edges of a graph whose
    connected components are to be found.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: graph { A -- B C -- D }
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the connected components using this function if we include each
    edge in both directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The weakly connected components of a directed graph can found the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The vertices of the graph must be hashable for the data structures used. If
    the vertices are unhashable replace them with integer indices.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses Tarjan’s algorithm to compute the connected components in
    \(O(|V|+|E|)\) (linear) time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.strongly_connected_components`](#sympy.utilities.iterables.strongly_connected_components
    "sympy.utilities.iterables.strongly_connected_components")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1054](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Component_%28graph_theory%29](https://en.wikipedia.org/wiki/Component_%28graph_theory%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1055](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Merge dictionaries into a single dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Only yield elements from \(iterator\) that do not occur in \(exclude\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iterator** : iterable'
  prefs: []
  type: TYPE_NORMAL
- en: iterator to take elements from
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**exclude** : iterable'
  prefs: []
  type: TYPE_NORMAL
- en: elements to exclude
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iterator** : iterator'
  prefs: []
  type: TYPE_NORMAL
- en: filtered iterator
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Recursively denest iterable containers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to denest only a specified number of levels of nested containers,
    then set `levels` flag to the desired number of levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If cls argument is specified, it will only flatten instances of that class,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: adapted from [https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks](https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Return permutations of [0, 1, …, n - 1] such that each permutation differs from
    the last by the exchange of a single pair of neighbors. The `n!` permutations
    are returned as an iterator. In order to obtain the next permutation from a random
    starting permutation, use the `next_trotterjohnson` method of the Permutation
    class (which generates the same sequence in a different manner).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the sort of permutation used in the ringing of physical bells, and
    does not produce permutations in lexicographical order. Rather, the permutations
    differ from each other by exactly one inversion, and the position at which the
    swapping occurs varies periodically in a simple fashion. Consider the first few
    permutations of 4 elements generated by `permutations` and `generate_bell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the 2nd and 3rd lexicographical permutations have 3 elements out
    of place whereas each “bell” permutation always has only two elements out of place
    relative to the previous permutation (and so the signature (+/-1) of a permutation
    is opposite of the signature of the previous permutation).
  prefs: []
  type: TYPE_NORMAL
- en: 'How the position of inversion varies across the elements can be seen by tracing
    out where the largest number appears in the permutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.combinatorics.permutations.Permutation.next_trotterjohnson`](../combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.next_trotterjohnson
    "sympy.combinatorics.permutations.Permutation.next_trotterjohnson")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1056](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Method_ringing](https://en.wikipedia.org/wiki/Method_ringing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1057](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/4856615/recursive-permutation/4857018](https://stackoverflow.com/questions/4856615/recursive-permutation/4857018)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1058](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20160313023044/http://programminggeeks.com/bell-algorithm-for-permutation/](https://web.archive.org/web/20160313023044/http://programminggeeks.com/bell-algorithm-for-permutation/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1059](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm](https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1060](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: Generating involutions, derangements, and relatives by ECO Vincent Vajnovszki,
    DMTCS vol 1 issue 12, 2010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Return unique derangements of the elements of iterable `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.functions.combinatorial.factorials.subfactorial`](../functions/combinatorial.html#sympy.functions.combinatorial.factorials.subfactorial
    "sympy.functions.combinatorial.factorials.subfactorial")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generates involutions.
  prefs: []
  type: TYPE_NORMAL
- en: An involution is a permutation that when multiplied by itself equals the identity
    permutation. In this implementation the involutions are generated using Fixed
    Points.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, an involution can be considered as a permutation that does not
    contain any cycles with a length that is greater than two.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1061](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PermutationInvolution.html](https://mathworld.wolfram.com/PermutationInvolution.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm generates oriented forests.
  prefs: []
  type: TYPE_NORMAL
- en: An oriented graph is a directed graph having no symmetric pair of directed edges.
    A forest is an acyclic graph, i.e., it has no cycles. A forest can also be described
    as a disjoint union of trees, which are graphs in which any two vertices are connected
    by exactly one simple path.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1062](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'T. Beyer and S.M. Hedetniemi: constant time generation of rooted trees, SIAM
    J. Computing Vol. 9, No. 4, November 1980'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1063](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python](https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Splits a sequence into a list of lists of equal, adjacent elements.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`multiset`](#sympy.utilities.iterables.multiset "sympy.utilities.iterables.multiset")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Return True if there are any duplicate elements in `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return True if there are any different elements in `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of length `bits` corresponding to the binary value of `n` with
    small bits to the right (last). If bits is omitted, the length will be the number
    required to represent `n`. If the bits are desired in reversed order, use the
    `[::-1]` slice of the returned list.
  prefs: []
  type: TYPE_NORMAL
- en: If a sequence of all bits-length lists starting from `[0, 0,..., 0]` through
    `[1, 1, ..., 1]` are desired, pass a non-integer for bits, e.g. `'all'`.
  prefs: []
  type: TYPE_NORMAL
- en: If the bit *string* is desired pass `str=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If all lists corresponding to 0 to 2**n - 1, pass a non-integer for bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If a bit string is desired of a given length, use str=True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Cartesian product of iterables.
  prefs: []
  type: TYPE_NORMAL
- en: Generator of the Cartesian product of iterables. This is analogous to itertools.product
    except that it works with infinite iterables and will yield any item from the
    infinite product eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With an infinite iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[itertools.product](https://docs.python.org/3/library/itertools.html#itertools.product)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Return True if the sequence is the same from left to right as it is from right
    to left in the whole sequence (default) or in the Python slice `s[i: j]`; else
    False.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Normal Python slicing is performed in place so there is no need to create a
    slice of the sequence for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.digits.is_palindromic`](../ntheory.html#sympy.ntheory.digits.is_palindromic
    "sympy.ntheory.digits.is_palindromic")'
  prefs: []
  type: TYPE_NORMAL
- en: tests integers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return a boolean indicating whether `i` is a sequence in the SymPy sense. If
    anything that fails the test below should be included as being a sequence for
    your application, set ‘include’ to that object’s type; multiple types should be
    passed as a tuple of types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: although generators can generate a sequence, they often need special
    handling to make sure their elements are captured before the generator is exhausted,
    so these are not included by default in the definition of a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'See also: iterable'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Return a boolean indicating whether `i` is SymPy iterable. True also indicates
    that the iterator is finite, e.g. you can call list(…) on the instance.
  prefs: []
  type: TYPE_NORMAL
- en: When SymPy is working with iterables, it is almost always assuming that the
    iterable is not a string or a mapping, so those are excluded by default. If you
    want a pure Python definition, make exclude=None. To exclude multiple items, pass
    them as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the _iterable attribute to True or False on your class, which
    will override the checks here, including the exclude test.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, some SymPy functions use this to check if they should recursively
    map over an object. If an object is technically iterable in the Python sense but
    does not desire this behavior (e.g., because its iteration is not finite, or because
    iteration might induce an unwanted computation), it should disable it by setting
    the _iterable attribute to False.
  prefs: []
  type: TYPE_NORMAL
- en: 'See also: is_sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Return sequence `l` partitioned into `k` bins.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'The default is to give the items in the same order, but grouped into k partitions
    without any reordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ordered` flag is either None (to give the simple partition of the elements)
    or is a 2 digit integer indicating whether the order of the bins and the order
    of the items in the bins matters. Given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'the following values for `ordered` have the shown meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`partitions`](#sympy.utilities.iterables.partitions "sympy.utilities.iterables.partitions"),
    [`multiset_partitions`](#sympy.utilities.iterables.multiset_partitions "sympy.utilities.iterables.multiset_partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of steps of left rotation required to obtain lexicographically
    minimal string/list/tuple, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1064](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Return the rotation of the sequence in which the lexically smallest elements
    appear first, e.g. \(cba \rightarrow acb\).
  prefs: []
  type: TYPE_NORMAL
- en: The sequence returned is a tuple, unless the input sequence is a string in which
    case a string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If `directed` is False then the smaller of the sequence and the reversed sequence
    is returned, e.g. \(cba \rightarrow abc\).
  prefs: []
  type: TYPE_NORMAL
- en: If `key` is not None then it is used to extract a comparison key from each element
    in iterable.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Return the hashable sequence in multiset form with values being the multiplicity
    of the item in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`group`](#sympy.utilities.iterables.group "sympy.utilities.iterables.group")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Return the unique combinations of size `n` from multiset `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The number of combinations depends on the number of letters; the number of unique
    combinations depends on how the letters are repeated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Generate derangements of the elements of s *in place*.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the derangements of multisets (not sets) are generated in place, copies
    of the return value must be made if a collection of derangements is desired or
    else all values will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Return unique partitions of the given multiset (in list form). If `m` is None,
    all multisets will be returned, otherwise only partitions with `m` parts will
    be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If `multiset` is an integer, a range [0, 1, …, multiset - 1] will be supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Only unique partitions are returned and these will be returned in a canonical
    order regardless of the order of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If m is omitted then all partitions will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Counting
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of partitions of a set is given by the bell number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of partitions of length k from a set of size n is given by the Stirling
    Number of the 2nd kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: These comments on counting apply to *sets*, not multisets.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: When all the elements are the same in the multiset, the order of the returned
    partitions is determined by the `partitions` routine. If one is counting partitions
    then it is better to use the `nT` function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`partitions`](#sympy.utilities.iterables.partitions "sympy.utilities.iterables.partitions"),
    [`sympy.combinatorics.partitions.Partition`](../combinatorics/partitions.html#sympy.combinatorics.partitions.Partition
    "sympy.combinatorics.partitions.Partition"), [`sympy.combinatorics.partitions.IntegerPartition`](../combinatorics/partitions.html#sympy.combinatorics.partitions.IntegerPartition
    "sympy.combinatorics.partitions.IntegerPartition"), [`sympy.functions.combinatorial.numbers.nT`](../functions/combinatorial.html#sympy.functions.combinatorial.numbers.nT
    "sympy.functions.combinatorial.numbers.nT")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Return the unique permutations of multiset `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: A routine to generate necklaces that may (free=True) or may not (free=False)
    be turned over to be viewed. The “necklaces” returned are comprised of `n` integers
    (beads) with `k` different values (colors). Only unique necklaces are returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The “unrestricted necklace” is sometimes also referred to as a “bracelet” (an
    object that can be turned over, a sequence that can be reversed) and the term
    “necklace” is used to imply a sequence that cannot be reversed. So ACB == ABC
    for a bracelet (rotate and reverse) while the two are different for a necklace
    since rotation alone cannot make the two sequences the same.
  prefs: []
  type: TYPE_NORMAL
- en: '(mnemonic: Bracelets can be viewed Backwards, but Not Necklaces.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1065](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/Necklace.html](https://mathworld.wolfram.com/Necklace.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1066](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: Frank Ruskey, Carla Savage, and Terry Min Yih Wang, Generating necklaces, Journal
    of Algorithms 13 (1992), 414-430; [https://doi.org/10.1016/0196-6774(92)90047-G](https://doi.org/10.1016/0196-6774(92)90047-G)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Generate an infinite stream of Symbols consisting of a prefix and increasing
    subscripts provided that they do not occur in `exclude`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**prefix** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The prefix to use. By default, this function will generate symbols of the form
    “x0”, “x1”, etc.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**cls** : class, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The class to use. By default, it uses `Symbol`, but you can also use `Wild`
    or `Dummy`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**start** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The start number. By default, it is 0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**exclude** : list, tuple, set of cls, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols to be excluded.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '***args, **kwargs**'
  prefs: []
  type: TYPE_NORMAL
- en: Additional positional and keyword arguments are passed to the *cls* class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sym** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The subscripted symbols.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Generates ordered partitions of integer *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The default value gives partitions of all sizes else only those with size m.
    In addition, if *m* is not None then partitions are generated *in place* (see
    examples).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**sort** : bool, default: True'
  prefs: []
  type: TYPE_NORMAL
- en: Controls whether partitions are returned in sorted order when *m* is not None;
    when False, the partitions are returned as fast as possible with elements sorted,
    but when m|n the partitions will not be in ascending lexicographical order.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'All partitions of 5 in ascending lexicographical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Only partitions of 5 with two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When `m` is given, a given list objects will be used more than once for speed
    reasons so you will not see the correct partitions unless you make a copy of each
    as it is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: When `n` is a multiple of `m`, the elements are still sorted but the partitions
    themselves will be *unordered* if sort is False; the default is to return them
    in ascending lexicographical order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'But if speed is more important than ordering, sort can be set to False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1067](#id15)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating Integer Partitions, [online], Available: [https://jeromekelleher.net/generating-integer-partitions.html](https://jeromekelleher.net/generating-integer-partitions.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1068](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jerome Kelleher and Barry O’Sullivan, “Generating All Partitions: A Comparison
    Of Two Encodings”, [online], Available: [https://arxiv.org/pdf/0909.2331v2.pdf](https://arxiv.org/pdf/0909.2331v2.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Generate all partitions of positive integer, n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each partition is represented as a dictionary, mapping an integer to the number
    of copies of that integer in the partition. For example, the first partition of
    4 returned is {4: 1}, “4: one of them”.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'limits number of parts in partition (mnemonic: m, maximum parts)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**k** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'limits the numbers that are kept in the partition (mnemonic: k, keys)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**size** : bool, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, (M, P) is returned where M is the sum of the multiplicities and P
    is the generated partition. If `False`, only the generated partition is returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The numbers appearing in the partition (the key of the returned dict) are limited
    with k:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The maximum number of parts in the partition (the sum of the values in the
    returned dict) are limited with m (default value, None, gives partitions from
    1 through n):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.combinatorics.partitions.Partition`](../combinatorics/partitions.html#sympy.combinatorics.partitions.Partition
    "sympy.combinatorics.partitions.Partition"), [`sympy.combinatorics.partitions.IntegerPartition`](../combinatorics/partitions.html#sympy.combinatorics.partitions.IntegerPartition
    "sympy.combinatorics.partitions.IntegerPartition")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1069](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'modified from Tim Peter’s version to allow for k and m values: [https://code.activestate.com/recipes/218332-generator-for-integer-partitions/](https://code.activestate.com/recipes/218332-generator-for-integer-partitions/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Return iterator in which the signs of non-zero elements of t are permuted.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Generate all postfixes of a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Generate all prefixes of a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of elements in which none are in the same positions as they were
    originally. If an element fills more than half of the positions then an error
    will be raised since no derangement is possible. To obtain a derangement of as
    many items as possible–with some of the most numerous remaining in their original
    positions–pass \(strict=False\). To produce a pseudorandom derangment, pass a
    pseudorandom selector like \(choice\) (see below).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'A predictable result can be obtained by using a pseudorandom generator for
    the choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'By reseeding, the same sequence can be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Reshape the sequence according to the template in `how`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Left rotates a list x by the number of steps specified in y.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Right rotates a list x by the number of steps specified in y.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Return a generator giving the items in s as list where each subsequent list
    has the items rotated to the left (default) or right (`dir=-1`) relative to the
    previous list.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'roundrobin recipe taken from itertools documentation: [https://docs.python.org/3/library/itertools.html#itertools-recipes](https://docs.python.org/3/library/itertools.html#itertools-recipes)'
  prefs: []
  type: TYPE_NORMAL
- en: roundrobin(‘ABC’, ‘D’, ‘EF’) –> A D E B F C
  prefs: []
  type: TYPE_NORMAL
- en: Recipe credited to George Sakkis
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Group the sequence into lists in which successive elements all compare the
    same with the comparison operator, `op`: op(seq[i + 1], seq[i]) is True from all
    elements in a run.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Returns the partition of sequence \(l\) into \(n\) bins
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**l** : Sequence[T]'
  prefs: []
  type: TYPE_NORMAL
- en: A nonempty sequence of any Python objects
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n** : int'
  prefs: []
  type: TYPE_NORMAL
- en: A positive integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out** : list[Sequence[T]]'
  prefs: []
  type: TYPE_NORMAL
- en: A list of sequences with concatenation equals \(l\). This should conform with
    the type of \(l\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given the sequence \(l_1 \cdots l_m \in V^+\) where \(V^+\) is the Kleene plus
    of \(V\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of \(n\) partitions of \(l\) is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\{(s_1, \cdots, s_n) | s_1 \in V^+, \cdots, s_n \in V^+, s_1 \cdots s_n =
    l_1 \cdots l_m\}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This is modified version of EnricoGiampieri’s partition generator from [https://stackoverflow.com/questions/13131491/partition-n-items-into-k-bins-in-python-lazily](https://stackoverflow.com/questions/13131491/partition-n-items-into-k-bins-in-python-lazily)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sequence_partitions_empty`](#sympy.utilities.iterables.sequence_partitions_empty
    "sympy.utilities.iterables.sequence_partitions_empty")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Returns the partition of sequence \(l\) into \(n\) bins with empty sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**l** : Sequence[T]'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of any Python objects (can be possibly empty)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n** : int'
  prefs: []
  type: TYPE_NORMAL
- en: A positive integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out** : list[Sequence[T]]'
  prefs: []
  type: TYPE_NORMAL
- en: A list of sequences with concatenation equals \(l\). This should conform with
    the type of \(l\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given the sequence \(l_1 \cdots l_m \in V^*\) where \(V^*\) is the Kleene star
    of \(V\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of \(n\) partitions of \(l\) is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\{(s_1, \cdots, s_n) | s_1 \in V^*, \cdots, s_n \in V^*, s_1 \cdots s_n =
    l_1 \cdots l_m\}\]
  prefs: []
  type: TYPE_NORMAL
- en: There are more combinations than [`sequence_partitions()`](#sympy.utilities.iterables.sequence_partitions
    "sympy.utilities.iterables.sequence_partitions") because empty sequence can fill
    everywhere, so we try to provide different utility for this.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sequence_partitions`](#sympy.utilities.iterables.sequence_partitions "sympy.utilities.iterables.sequence_partitions")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Sift the sequence, `seq` according to `keyfunc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: When `binary` is `False` (default), the output is a dictionary
  prefs: []
  type: TYPE_NORMAL
- en: where elements of `seq` are stored in a list keyed to the value
  prefs: []
  type: TYPE_NORMAL
- en: of keyfunc for that element. If `binary` is True then a tuple
  prefs: []
  type: TYPE_NORMAL
- en: with lists `T` and `F` are returned where `T` is a list
  prefs: []
  type: TYPE_NORMAL
- en: containing elements of seq for which `keyfunc` was `True` and
  prefs: []
  type: TYPE_NORMAL
- en: '`F` containing those elements for which `keyfunc` was `False`;'
  prefs: []
  type: TYPE_NORMAL
- en: a ValueError is raised if the `keyfunc` is not binary.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: sift() returns a defaultdict() object, so any key that has no matches will give
    [].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you will not know how many keys you will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you expect the results to be binary; the results can be unpacked
    by setting `binary` to True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'A ValueError is raised if the predicate was not actually binary (which is a
    good test for the logic where sifting is used and binary results were expected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-binary sifting shows that there were 3 keys generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: If you need to sort the sifted items it might be better to use `ordered` which
    can economically apply multiple sort keys to a sequence while sorting.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ordered`](../core.html#sympy.core.sorting.ordered "sympy.core.sorting.ordered")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Return iterator in which the signs of non-zero elements of t and the order of
    the elements are permuted and all returned values are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Strongly connected components of a directed graph in reverse topological order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**G** : tuple[list, list[tuple[T, T]]'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple consisting of a list of vertices and a list of edges of a graph whose
    strongly connected components are to be found.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a directed graph (in dot notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: digraph { A -> B A -> C B -> C C -> B B -> D }
  prefs: []
  type: TYPE_NORMAL
- en: 'where vertices are the letters A, B, C and D. This graph can be encoded using
    Python’s elementary data structures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The strongly connected components of this graph can be computed as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This also gives the components in reverse topological order.
  prefs: []
  type: TYPE_NORMAL
- en: Since the subgraph containing B and C has a cycle they must be together in a
    strongly connected component. A and D are connected to the rest of the graph but
    not in a cyclic manner so they appear as their own strongly connected components.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The vertices of the graph must be hashable for the data structures used. If
    the vertices are unhashable replace them with integer indices.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses Tarjan’s algorithm to compute the strongly connected components
    in \(O(|V|+|E|)\) (linear) time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.connected_components`](#sympy.utilities.iterables.connected_components
    "sympy.utilities.iterables.connected_components")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1070](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Strongly_connected_component](https://en.wikipedia.org/wiki/Strongly_connected_component)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1071](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Generates all \(k\)-subsets (combinations) from an \(n\)-element set, `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: A \(k\)-subset of an \(n\)-element set is any subset of length exactly \(k\).
    The number of \(k\)-subsets of an \(n\)-element set is given by `binomial(n, k)`,
    whereas there are \(2^n\) subsets all together. If \(k\) is `None` then all \(2^n\)
    subsets will be returned from shortest to longest.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '`subsets(seq, k)` will return the \(\frac{n!}{k!(n - k)!}\) \(k\)-subsets (combinations)
    without repetition, i.e. once an item has been removed, it can no longer be “taken”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '`subsets(seq, k, repetition=True)` will return the \(\frac{(n - 1 + k)!}{k!(n
    - 1)!}\) combinations *with* repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ask for more items than are in the set you get the empty set unless
    you allow repetitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Return `n` items from `iter` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Topological sort of graph’s vertices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**graph** : tuple[list, list[tuple[T, T]]'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple consisting of a list of vertices and a list of edges of a graph to be
    sorted topologically.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key** : callable[T] (optional)'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering key for vertices on the same level. By default the natural (e.g. lexicographic)
    ordering is used (in this case the base type must implement ordering relations).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'where vertices are integers. This graph can be encoded using elementary Python’s
    data structures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute a topological sort for graph `(V, E)` issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'If specific tie breaking approach is needed, use `key` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Only acyclic graphs can be sorted. If the input graph has a cycle, then `ValueError`
    will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R1072](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Topological_sorting](https://en.wikipedia.org/wiki/Topological_sorting)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Group `iter` into tuples of length `n`. Raise an error if the length of `iter`
    is not a multiple of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Yield unique elements from `seq` as an iterator. The second parameter `result`
    is used internally; it is not necessary to pass anything for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: changing the sequence during iteration will raise a RuntimeError if the
    size of the sequence is known; if you pass an iterator and advance the iterator
    you will change the output of this routine but there will be no warning.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Returns an iterator over the n-sized variations of `seq` (size N). `repetition`
    controls whether items in `seq` can appear more than once;
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '`variations(seq, n)` will return \(\frac{N!}{(N - n)!}\) permutations without
    repetition of `seq`’s elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '`variations(seq, n, True)` will return the \(N^n\) permutations obtained by
    allowing repetition of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ask for more items than are in the set you get the empty set unless
    you allow repetitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[itertools.permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations),
    [itertools.product](https://docs.python.org/3/library/itertools.html#itertools.product)'
  prefs: []
  type: TYPE_NORMAL
- en: variations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: variations(seq, n) Returns all the variations of the list of size n.
  prefs: []
  type: TYPE_NORMAL
- en: Has an optional third argument. Must be a boolean value and makes the method
    return the variations with repetition if set to True, or the variations without
    repetition if set to False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: partitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the combinatorics module contains Partition and IntegerPartition classes
    for investigation and manipulation of partitions, there are a few functions to
    generate partitions that can be used as low-level tools for routines: `partitions`
    and `multiset_partitions`. The former gives integer partitions, and the latter
    gives enumerated partitions of elements. There is also a routine `kbins` that
    will give a variety of permutations of partitions. And to obtain partitions as
    a list instead of a dictionary, there is the `ordered_partition` function which
    is quite fast. Finally, to simply obtain a count of the number of partitions without
    enumerating them, there is the `nT` function.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: sympy.utilities.iterables.ordered_partitions, sympy.functions.combinatorial.numbers.nT
  prefs: []
  type: TYPE_NORMAL
- en: 'partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'multiset_partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'kbins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
