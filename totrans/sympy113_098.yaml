- en: Concrete
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体
- en: Original text：[https://docs.sympy.org/latest/modules/concrete.html](https://docs.sympy.org/latest/modules/concrete.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/modules/concrete.html](https://docs.sympy.org/latest/modules/concrete.html)
- en: Hypergeometric terms
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超几何项
- en: The center stage, in recurrence solving and summations, play hypergeometric
    terms. Formally these are sequences annihilated by first order linear recurrence
    operators. In simple words if we are given term \(a(n)\) then it is hypergeometric
    if its consecutive term ratio is a rational function in \(n\).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归求解和求和中，超几何项占据了中心舞台。正式地说，这些是被一阶线性递推算子消灭的序列。简单地说，如果给定项 \(a(n)\)，则如果其连续项比是 \(n\)
    的有理函数，则它是超几何的。
- en: 'To check if a sequence is of this type you can use the `is_hypergeometric`
    method which is available in Basic class. Here is simple example involving a polynomial:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个序列是否是这种类型，可以使用 `is_hypergeometric` 方法，该方法在 Basic 类中可用。以下是涉及多项式的简单示例：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Of course polynomials are hypergeometric but are there any more complicated
    sequences of this type? Here are some trivial examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，多项式是超几何的，但还有更复杂的这种类型的序列吗？以下是一些简单的例子：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We see that all species used in summations and other parts of concrete mathematics
    are hypergeometric. Note also that binomial coefficients and both rising and falling
    factorials are hypergeometric in both their arguments:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在具体数学的求和和其他部分中使用的所有特殊物种都是超几何的。还要注意，二项式系数以及升序和降序阶乘在它们的参数中都是超几何的：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To say more, all previously shown examples are valid for integer linear arguments:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步说，所有先前显示的例子都适用于整数线性参数：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However nonlinear arguments make those sequences fail to be hypergeometric:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非线性参数使得这些序列无法成为超几何序列：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If not only the knowledge of being hypergeometric or not is needed, you can
    use `hypersimp()` function. It will try to simplify combinatorial expression and
    if the term given is hypergeometric it will return a quotient of polynomials of
    minimal degree. Otherwise is will return \(None\) to say that sequence is not
    hypergeometric:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的不仅仅是判断是否为超几何序列的知识，可以使用 `hypersimp()` 函数。它将尝试简化组合表达式，并且如果给定的项是超几何的，则返回最小度数多项式的商。否则，将返回
    \(None\) 表示序列不是超几何的：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Concrete Class Reference
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具体类参考
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Represents unevaluated summation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表示未计算的求和。
- en: Explanation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: '`Sum` represents a finite or infinite series, with the first argument being
    the general form of terms in the series, and the second argument being `(dummy_variable,
    start, end)`, with `dummy_variable` taking all integer values from `start` through
    `end`. In accordance with long-standing mathematical convention, the end term
    is included in the summation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum` 表示一个有限或无限级数，第一个参数是级数项的一般形式，第二个参数是 `(dummy_variable, start, end)`，其中 `dummy_variable`
    取从 `start` 到 `end` 的所有整数值。根据长期以来的数学约定，包含结束项在内的求和。'
- en: Finite Sums
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有限和
- en: 'For finite sums (and sums with symbolic limits assumed to be finite) we follow
    the summation convention described by Karr [1], especially definition 3 of section
    1.4\. The sum:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '对于有限和（和假定有限的符号限制），我们遵循 Karr [1] 描述的求和惯例，特别是第 1.4 节的定义 3。这个和:'
- en: \[\sum_{m \leq i < n} f(i)\]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{m \leq i < n} f(i)\]
- en: 'has *the obvious meaning* for \(m < n\), namely:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 \(m < n\)，具有*显而易见的含义*，即:'
- en: \[\sum_{m \leq i < n} f(i) = f(m) + f(m+1) + \ldots + f(n-2) + f(n-1)\]
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{m \leq i < n} f(i) = f(m) + f(m+1) + \ldots + f(n-2) + f(n-1)\]
- en: 'with the upper limit value \(f(n)\) excluded. The sum over an empty set is
    zero if and only if \(m = n\):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上限值 \(f(n)\) 排除。如果 \(m = n\)，则空集的和为零：
- en: \[\sum_{m \leq i < n} f(i) = 0 \quad \mathrm{for} \quad m = n\]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{m \leq i < n} f(i) = 0 \quad \mathrm{for} \quad m = n\]
- en: 'Finally, for all other sums over empty sets we assume the following definition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于所有其他空集的求和，我们假设以下定义：
- en: \[\sum_{m \leq i < n} f(i) = - \sum_{n \leq i < m} f(i) \quad \mathrm{for} \quad
    m > n\]
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{m \leq i < n} f(i) = - \sum_{n \leq i < m} f(i) \quad \mathrm{for} \quad
    m > n\]
- en: 'It is important to note that Karr defines all sums with the upper limit being
    exclusive. This is in contrast to the usual mathematical notation, but does not
    affect the summation convention. Indeed we have:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，Karr 定义了所有上限为排除的求和。这与通常的数学符号形成对比，但不影响求和约定。确实，我们有:'
- en: \[\sum_{m \leq i < n} f(i) = \sum_{i = m}^{n - 1} f(i)\]
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{m \leq i < n} f(i) = \sum_{i = m}^{n - 1} f(i)\]
- en: where the difference in notation is intentional to emphasize the meaning, with
    limits typeset on the top being inclusive.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 符号差异是故意的，以强调其含义，顶部的限制被设置为包含。
- en: Examples
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here are examples to do summation with symbolic indices. You can use either
    Function of IndexedBase classes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有用符号索引进行求和的示例。您可以使用 Function 或 IndexedBase 类：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An example showing that the symbolic result of a summation is still valid for
    seemingly nonsensical values of the limits. Then the Karr convention allows us
    to give a perfectly valid interpretation to those sums by interchanging the limits
    according to the above rules:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子显示求和的符号结果对于看似荒谬的极限值仍然有效。然后 Karr 约定允许我们根据上述规则交换极限，从而为这些求和给出完全有效的解释：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An explicit example of the Karr summation convention:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Karr 求和约定的显式示例：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`summation`](#sympy.concrete.summations.summation "sympy.concrete.summations.summation"),
    [`Product`](#sympy.concrete.products.Product "sympy.concrete.products.Product"),
    [`sympy.concrete.products.product`](#sympy.concrete.products.product "sympy.concrete.products.product")'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[`summation`](#sympy.concrete.summations.summation "sympy.concrete.summations.summation"),
    [`Product`](#sympy.concrete.products.Product "sympy.concrete.products.Product"),
    [`sympy.concrete.products.product`](#sympy.concrete.products.product "sympy.concrete.products.product")'
- en: References
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R98](#id1)]'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R98](#id1)]'
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Karr，“Summation in Finite Terms”，Journal of the ACM，Volume 28 Issue
    2，April 1981，Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
- en: '[[R99](#id2)]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R99](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation](https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation](https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation)'
- en: '[[R100](#id3)]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R100](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Empty_sum](https://en.wikipedia.org/wiki/Empty_sum)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Empty_sum](https://en.wikipedia.org/wiki/Empty_sum)'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Return an Euler-Maclaurin approximation of self, where m is the number of leading
    terms to sum directly and n is the number of terms in the tail.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 返回自身的 Euler-Maclaurin 近似，其中 m 是直接求和的前导项数，n 是尾部项数。
- en: With m = n = 0, this is simply the corresponding integral plus a first-order
    endpoint correction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当 m = n = 0 时，这只是对应积分加上一阶端点修正。
- en: 'Returns (s, e) where s is the Euler-Maclaurin approximation and e is the estimated
    error (taken to be the magnitude of the first omitted term in the tail):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 (s, e)，其中 s 是 Euler-Maclaurin 近似，e 是估计的误差（取尾部省略项的大小）：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The endpoints may be symbolic:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 端点可以是符号的：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the function is a polynomial of degree at most 2n+1, the Euler-Maclaurin
    formula becomes exact (and e = 0 is returned):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是至多 2n+1 次的多项式，则 Euler-Maclaurin 公式变得精确（并返回 e = 0）：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With a nonzero eps specified, the summation is ended as soon as the remainder
    term is less than the epsilon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定非零eps时，只要剩余项小于epsilon，就结束求和。
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check whether the function matches with the zeta function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数是否与 zeta 函数匹配。
- en: If it matches, then return a \(Piecewise\) expression because zeta function
    does not converge unless \(s > 1\) and \(q > 0\)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配，则返回 \(Piecewise\) 表达式，因为 zeta 函数只有在 \(s > 1\) 和 \(q > 0\) 时收敛。
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Checks for the absolute convergence of an infinite series.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 检查无穷级数的绝对收敛性。
- en: Same as checking convergence of absolute value of sequence_term of an infinite
    series.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 检查无穷级数的绝对收敛性。
- en: Examples
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`Sum.is_convergent`](#sympy.concrete.summations.Sum.is_convergent "sympy.concrete.summations.Sum.is_convergent")'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sum.is_convergent`](#sympy.concrete.summations.Sum.is_convergent "sympy.concrete.summations.Sum.is_convergent")'
- en: References
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R101](#id4)]'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R101](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Absolute_convergence](https://en.wikipedia.org/wiki/Absolute_convergence)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Absolute_convergence](https://en.wikipedia.org/wiki/Absolute_convergence)'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Checks for the convergence of a Sum.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Sum 的收敛性。
- en: Explanation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: We divide the study of convergence of infinite sums and products in two parts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将无穷级数和乘积的收敛性研究分为两部分。
- en: 'First Part: One part is the question whether all the terms are well defined,
    i.e., they are finite in a sum and also non-zero in a product. Zero is the analogy
    of (minus) infinity in products as \(e^{-\infty} = 0\).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分：一个问题是所有项是否良好定义，即它们在求和中是有限的，在乘积中也是非零的。零在乘积中类似于（负）无穷大，即 \(e^{-\infty} = 0\)。
- en: 'Second Part: The second part is the question of convergence after infinities,
    and zeros in products, have been omitted assuming that their number is finite.
    This means that we only consider the tail of the sum or product, starting from
    some point after which all terms are well defined.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分：第二部分是在忽略了无穷大和乘积中的零后的收敛性问题，假设它们的数量是有限的。这意味着我们只考虑求和或乘积的尾部，从某个点开始，所有项都是良定义的。
- en: 'For example, in a sum of the form:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在形如：
- en: \[\sum_{1 \leq i < \infty} \frac{1}{n^2 + an + b}\]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{1 \leq i < \infty} \frac{1}{n^2 + an + b}\]
- en: 'where a and b are numbers. The routine will return true, even if there are
    infinities in the term sequence (at most two). An analogous product would be:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中a和b是数字的求和中，例程将返回true，即使在项序列中存在无穷大（至多两个）。类似的乘积会是：
- en: \[\prod_{1 \leq i < \infty} e^{\frac{1}{n^2 + an + b}}\]
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{1 \leq i < \infty} e^{\frac{1}{n^2 + an + b}}\]
- en: This is how convergence is interpreted. It is concerned with what happens at
    the limit. Finding the bad terms is another independent matter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是收敛性的解释方式。它关注于极限时发生的情况。寻找不良项是另一个独立的问题。
- en: 'Note: It is responsibility of user to see that the sum or product is well defined.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保用户自行负责确保求和或乘积的定义良好。
- en: There are various tests employed to check the convergence like divergence test,
    root test, integral test, alternating series test, comparison tests, Dirichlet
    tests. It returns true if Sum is convergent and false if divergent and NotImplementedError
    if it cannot be checked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种测试用于检查收敛性，如发散测试，根测试，积分测试，交替级数测试，比较测试，狄利克雷测试。如果求和收敛则返回true，发散则返回false，如果无法检查则返回NotImplementedError。
- en: Examples
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`Sum.is_absolutely_convergent`](#sympy.concrete.summations.Sum.is_absolutely_convergent
    "sympy.concrete.summations.Sum.is_absolutely_convergent"), [`sympy.concrete.products.Product.is_convergent`](#sympy.concrete.products.Product.is_convergent
    "sympy.concrete.products.Product.is_convergent")'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sum.is_absolutely_convergent`](#sympy.concrete.summations.Sum.is_absolutely_convergent
    "sympy.concrete.summations.Sum.is_absolutely_convergent"), [`sympy.concrete.products.Product.is_convergent`](#sympy.concrete.products.Product.is_convergent
    "sympy.concrete.products.Product.is_convergent")'
- en: References
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R102](#id5)]'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R102](#id5)]'
- en: '[https://en.wikipedia.org/wiki/Convergence_tests](https://en.wikipedia.org/wiki/Convergence_tests)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Convergence_tests](https://en.wikipedia.org/wiki/Convergence_tests)'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Reverse the order of a limit in a Sum.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 反转求和中的极限顺序。
- en: Explanation
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`reverse_order(self, *indices)` reverses some limits in the expression `self`
    which can be either a `Sum` or a `Product`. The selectors in the argument `indices`
    specify some indices whose limits get reversed. These selectors are either variable
    names or numerical indices counted starting from the inner-most limit tuple.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_order(self, *indices)` 反转表达式`self`中的一些限制，它可以是`Sum`或`Product`。参数`indices`中的选择器指定了要反转限制的索引。这些选择器可以是变量名或从最内层限制元组开始计数的数值索引。'
- en: Examples
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While one should prefer variable names when specifying which limits to reverse,
    the index counting notation comes in handy in case there are several symbols with
    the same name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定反转哪些限制时应优先使用变量名，但是如果有几个符号具有相同名称，则索引计数符号非常方便。
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Of course we can mix both notations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以混合两种表示法：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
- en: References
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R103](#id6)]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R103](#id6)]'
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Karr，《有限项求和》，ACM期刊，第28卷第2期，1981年4月，305-350页 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Represents unevaluated products.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表示未评估的乘积。
- en: Explanation
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`Product` represents a finite or infinite product, with the first argument
    being the general form of terms in the series, and the second argument being `(dummy_variable,
    start, end)`, with `dummy_variable` taking all integer values from `start` through
    `end`. In accordance with long-standing mathematical convention, the end term
    is included in the product.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 表示一个有限或无限的乘积，第一个参数是序列中项的一般形式，第二个参数是 `(dummy_variable, start, end)`，其中
    `dummy_variable` 取从 `start` 到 `end` 的所有整数值。根据长期以来的数学惯例，最后一项包括在乘积中。'
- en: Finite Products
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有限乘积
- en: 'For finite products (and products with symbolic limits assumed to be finite)
    we follow the analogue of the summation convention described by Karr [1], especially
    definition 3 of section 1.4\. The product:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有限乘积（以及假设为有限的符号极限乘积），我们遵循卡尔描述的和约定的类似方式 [1]，特别是第1.4节的定义3。乘积：
- en: \[\prod_{m \leq i < n} f(i)\]
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{m \leq i < n} f(i)\]
- en: 'has *the obvious meaning* for \(m < n\), namely:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(m < n\)，具有 *明显的含义*，即：
- en: \[\prod_{m \leq i < n} f(i) = f(m) f(m+1) \cdot \ldots \cdot f(n-2) f(n-1)\]
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{m \leq i < n} f(i) = f(m) f(m+1) \cdot \ldots \cdot f(n-2) f(n-1)\]
- en: 'with the upper limit value \(f(n)\) excluded. The product over an empty set
    is one if and only if \(m = n\):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 具有排除上限值 \(f(n)\)。如果且仅如果 \(m = n\)，则空集的乘积为一：
- en: \[\prod_{m \leq i < n} f(i) = 1 \quad \mathrm{for} \quad m = n\]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{m \leq i < n} f(i) = 1 \quad \mathrm{for} \quad m = n\]
- en: 'Finally, for all other products over empty sets we assume the following definition:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于所有空集合上的其他乘积，我们假设以下定义：
- en: \[\prod_{m \leq i < n} f(i) = \frac{1}{\prod_{n \leq i < m} f(i)} \quad \mathrm{for}
    \quad m > n\]
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{m \leq i < n} f(i) = \frac{1}{\prod_{n \leq i < m} f(i)} \quad \mathrm{for}
    \quad m > n\]
- en: 'It is important to note that above we define all products with the upper limit
    being exclusive. This is in contrast to the usual mathematical notation, but does
    not affect the product convention. Indeed we have:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在上文中我们定义所有带有排除上限的乘积。这与通常的数学表示形式相反，但不影响乘积约定。确实，我们有：
- en: \[\prod_{m \leq i < n} f(i) = \prod_{i = m}^{n - 1} f(i)\]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{m \leq i < n} f(i) = \prod_{i = m}^{n - 1} f(i)\]
- en: where the difference in notation is intentional to emphasize the meaning, with
    limits typeset on the top being inclusive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中符号上的差异是故意的，以强调含义，极限的排版在顶部是包含的。
- en: Examples
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Wallis’ product for pi:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦利斯的π乘积：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Direct computation currently fails:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的直接计算失败：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But we can approach the infinite product by a limit of finite products:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以通过有限乘积的极限逼近无限乘积：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By the same formula we can compute sin(pi/2):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的公式也可以计算 sin(pi/2)：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Products with the lower limit being larger than the upper one:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 具有下限大于上限的产品：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The empty product:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 空产品：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An example showing that the symbolic result of a product is still valid for
    seemingly nonsensical values of the limits. Then the Karr convention allows us
    to give a perfectly valid interpretation to those products by interchanging the
    limits according to the above rules:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了一个示例，即使在极限看似荒谬的情况下，产品的符号结果仍然有效。然后，根据上述规则，卡尔约定允许我们对这些产品进行完全有效的解释：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An explicit example of the Karr summation convention applied to products:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 卡尔总和约定应用于乘积的明确示例：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And another one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和另一个：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: See also
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum"), [`summation`](#sympy.concrete.summations.summation
    "sympy.concrete.summations.summation"), [`product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum")，[`summation`](#sympy.concrete.summations.summation
    "sympy.concrete.summations.summation")，[`product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
- en: References
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R104](#id7)]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R104](#id7)]'
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔·卡尔，“有限术语的总和”，ACM期刊，第28卷第2期，1981年4月，305-350页 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
- en: '[[R105](#id8)]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R105](#id8)]'
- en: '[https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation](https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/%E4%B9%98%E6%B3%95](https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation)'
- en: '[[R106](#id9)]'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R106](#id9)]'
- en: '[https://en.wikipedia.org/wiki/Empty_product](https://en.wikipedia.org/wiki/Empty_product)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/%E7%A9%BA%E4%BA%A7%E4%B9%98%E7%A7%AF](https://en.wikipedia.org/wiki/Empty_product)'
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See docs of [`Sum.is_convergent()`](#sympy.concrete.summations.Sum.is_convergent
    "sympy.concrete.summations.Sum.is_convergent") for explanation of convergence
    in SymPy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [`Sum.is_convergent()`](#sympy.concrete.summations.Sum.is_convergent "sympy.concrete.summations.Sum.is_convergent")
    的文档，了解 SymPy 中收敛的解释。
- en: Explanation
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The infinite product:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 无限乘积：
- en: \[\prod_{1 \leq i < \infty} f(i)\]
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{1 \leq i < \infty} f(i)\]
- en: 'is defined by the sequence of partial products:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由部分乘积序列定义：
- en: \[\prod_{i=1}^{n} f(i) = f(1) f(2) \cdots f(n)\]
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: \[\prod_{i=1}^{n} f(i) = f(1) f(2) \cdots f(n)\]
- en: 'as n increases without bound. The product converges to a non-zero value if
    and only if the sum:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \( n \) 无限增大时。该乘积在且仅在和式收敛到非零值时收敛：
- en: \[\sum_{1 \leq i < \infty} \log{f(n)}\]
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{1 \leq i < \infty} \log{f(n)}\]
- en: converges.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛。
- en: Examples
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: References
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R107](#id10)]'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R107](#id10)]'
- en: '[https://en.wikipedia.org/wiki/Infinite_product](https://en.wikipedia.org/wiki/Infinite_product)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Infinite_product](https://en.wikipedia.org/wiki/Infinite_product)'
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Reverse the order of a limit in a Product.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 反转产品中限制的顺序。
- en: Explanation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`reverse_order(expr, *indices)` reverses some limits in the expression `expr`
    which can be either a `Sum` or a `Product`. The selectors in the argument `indices`
    specify some indices whose limits get reversed. These selectors are either variable
    names or numerical indices counted starting from the inner-most limit tuple.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_order(expr, *indices)` 反转表达式 `expr` 中的一些限制条件，可以是 `Sum` 或 `Product`。参数
    `indices` 中的选择器指定要反转限制条件的索引。这些选择器可以是变量名或从内部限制元组开始计数的数值索引。'
- en: Examples
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While one should prefer variable names when specifying which limits to reverse,
    the index counting notation comes in handy in case there are several symbols with
    the same name.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定要反转的限制条件时，应优先使用变量名，但索引计数符号在多个同名符号的情况下非常有用。
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course we can mix both notations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以混合使用这两种符号：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
- en: References
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R108](#id11)]'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R108](#id11)]'
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Karr，“Summation in Finite Terms”，Journal of the ACM，Volume 28 Issue
    2，April 1981，Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Superclass for Product and Sum.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 产品和和的超类。
- en: See also
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.concrete.expr_with_limits.ExprWithLimits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits
    "sympy.concrete.expr_with_limits.ExprWithLimits"), [`sympy.concrete.products.Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.summations.Sum`](#sympy.concrete.summations.Sum
    "sympy.concrete.summations.Sum")'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.concrete.expr_with_limits.ExprWithLimits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits
    "sympy.concrete.expr_with_limits.ExprWithLimits"), [`sympy.concrete.products.Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.summations.Sum`](#sympy.concrete.summations.Sum
    "sympy.concrete.summations.Sum")'
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Change index of a Sum or Product.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 更改和积的索引。
- en: Perform a linear transformation \(x \mapsto a x + b\) on the index variable
    \(x\). For \(a\) the only values allowed are \(\pm 1\). A new variable to be used
    after the change of index can also be specified.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对索引变量 \( x \) 执行线性变换 \( x \mapsto a x + b \)。允许的 \( a \) 值仅限于 \( \pm 1 \)。在索引变更后也可以指定一个新变量。
- en: Explanation
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`change_index(expr, var, trafo, newvar=None)` where `var` specifies the index
    variable \(x\) to transform. The transformation `trafo` must be linear and given
    in terms of `var`. If the optional argument `newvar` is provided then `var` gets
    replaced by `newvar` in the final expression.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`change_index(expr, var, trafo, newvar=None)` 其中 `var` 指定要变换的索引变量 \( x \)。变换
    `trafo` 必须是线性的，并且以 `var` 的形式给出。如果提供了可选参数 `newvar`，则最终表达式中的 `var` 将被替换为 `newvar`。'
- en: Examples
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When dealing with symbols only, we can make a general linear transformation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅处理符号时，我们可以进行一般的线性转换：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: However, the last result can be inconsistent with usual summation where the
    index increment is always 1\. This is obvious as we get back the original value
    only for `u` equal +1 or -1.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最后的结果可能与通常的求和不一致，其中索引增量始终为 1。这很明显，因为我们仅在 `u` 等于 +1 或 -1 时才返回原始值。
- en: See also
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 见也
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Returns True if the Sum or Product is computed for an empty sequence.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对空序列计算求和或乘积，则返回 True。
- en: Examples
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: See also
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 见也
- en: '[`has_reversed_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits"), [`has_finite_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits")'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[`has_reversed_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits"), [`has_finite_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits")'
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Return the index of a dummy variable in the list of limits.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在极限列表中的虚拟变量的索引。
- en: Explanation
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`index(expr, x)` returns the index of the dummy variable `x` in the limits
    of `expr`. Note that we start counting with 0 at the inner-most limits tuple.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`index(expr, x)` 返回表达式 `expr` 中变量 `x` 在极限中的索引。注意，我们从最内层的极限元组开始以 0 开始计数。'
- en: Examples
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: See also
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 见也
- en: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Reorder limits in a expression containing a Sum or a Product.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含求和或乘积的表达式中重新排序极限。
- en: Explanation
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`expr.reorder(*arg)` reorders the limits in the expression `expr` according
    to the list of tuples given by `arg`. These tuples can contain numerical indices
    or index variable names or involve both.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr.reorder(*arg)` 根据给定的元组列表 `arg` 重新排序表达式 `expr` 中的极限。这些元组可以包含数值索引、索引变量名称或二者的组合。'
- en: Examples
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can also select the index variables by counting them, starting with the
    inner-most one:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过计数选择索引变量，从最内层开始：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And of course we can mix both schemes:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以混合使用这两种方案：
- en: '[PRE68]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 见也
- en: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Interchange two limit tuples of a Sum or Product expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 交换 Sum 或 Product 表达式的两个限制元组。
- en: Explanation
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: '`expr.reorder_limit(x, y)` interchanges two limit tuples. The arguments `x`
    and `y` are integers corresponding to the index variables of the two limits which
    are to be interchanged. The expression `expr` has to be either a Sum or a Product.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr.reorder_limit(x, y)` 交换两个限制元组。参数 `x` 和 `y` 是对应于要交换的两个限制的索引变量的整数。表达式 `expr`
    必须是 Sum 或 Product。'
- en: Examples
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: See also
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"),
    [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"),
    [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"),
    [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"),
    [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
- en: Concrete Functions Reference
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具体函数参考
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Compute the summation of f with respect to symbols.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 计算符号与符号的和。
- en: Explanation
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: The notation for symbols is similar to the notation used in Integral. summation(f,
    (i, a, b)) computes the sum of f with respect to i from a to b, i.e.,
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的表示法类似于积分中使用的符号。`summation(f, (i, a, b))` 计算 f 对于 i 从 a 到 b 的求和，即，
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If it cannot compute the sum, it returns an unevaluated Sum object. Repeated
    sums can be computed by introducing additional symbols tuples:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法计算和，则返回一个未计算的 Sum 对象。通过引入额外的符号元组可以计算重复的和：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: See also
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum"), [`Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.products.product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum"), [`Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.products.product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Compute the product.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 计算乘积。
- en: Explanation
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: The notation for symbols is similar to the notation used in Sum or Integral.
    product(f, (i, a, b)) computes the product of f with respect to i from a to b,
    i.e.,
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的表示法类似于求和或积分中使用的符号。`product(f, (i, a, b))` 计算 f 对于 i 从 a 到 b 的乘积，即，
- en: '[PRE80]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If it cannot compute the product, it returns an unevaluated Product object.
    Repeated products can be computed by introducing additional symbols tuples:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法计算乘积，则返回一个未计算的 Product 对象。通过引入额外的符号元组可以计算重复的乘积：
- en: '[PRE81]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Compute the Gosper’s normal form of `f` and `g`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `f` 和 `g` 的 Gosper 正常形式。
- en: Explanation
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: 'Given relatively prime univariate polynomials `f` and `g`, rewrite their quotient
    to a normal form defined as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相对质的一元多项式 `f` 和 `g`，将它们的商重写为以下定义的正常形式：
- en: \[\frac{f(n)}{g(n)} = Z \cdot \frac{A(n) C(n+1)}{B(n) C(n)}\]
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{f(n)}{g(n)} = Z \cdot \frac{A(n) C(n+1)}{B(n) C(n)}\]
- en: 'where `Z` is an arbitrary constant and `A`, `B`, `C` are monic polynomials
    in `n` with the following properties:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `Z` 是任意常数，`A`, `B`, `C` 是关于 `n` 的首一多项式，并具有以下性质：
- en: \(\gcd(A(n), B(n+h)) = 1 \forall h \in \mathbb{N}\)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\gcd(A(n), B(n+h)) = 1 \forall h \in \mathbb{N}\)
- en: \(\gcd(B(n), C(n+1)) = 1\)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\gcd(B(n), C(n+1)) = 1\)
- en: \(\gcd(A(n), C(n)) = 1\)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\gcd(A(n), C(n)) = 1\)
- en: This normal form, or rational factorization in other words, is a crucial step
    in Gosper’s algorithm and in solving of difference equations. It can be also used
    to decide if two hypergeometric terms are similar or not.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此正常形式，或者说是有理分解，是 Gosper 算法和求解差分方程的关键步骤。它还可以用来判断两个超几何项是否相似。
- en: This procedure will return a tuple containing elements of this factorization
    in the form `(Z*A, B, C)`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程将返回一个包含分解元素的元组，形式为`(Z*A, B, C)`。
- en: Examples
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE85]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Compute Gosper’s hypergeometric term for `f`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 `f` 的 Gosper 超几何项。
- en: Explanation
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'Suppose `f` is a hypergeometric term such that:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `f` 是一个超几何项，使得：
- en: \[s_n = \sum_{k=0}^{n-1} f_k\]
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: \[s_n = \sum_{k=0}^{n-1} f_k\]
- en: and \(f_k\) does not depend on \(n\). Returns a hypergeometric term \(g_n\)
    such that \(g_{n+1} - g_n = f_n\).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 \(f_k\) 不依赖于 \(n\)。返回一个超几何项 \(g_n\)，使得 \(g_{n+1} - g_n = f_n\)。
- en: Examples
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE88]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Gosper’s hypergeometric summation algorithm.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Gosper 的超几何求和算法。
- en: Explanation
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'Given a hypergeometric term `f` such that:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个超几何项 `f`，使得：
- en: \[s_n = \sum_{k=0}^{n-1} f_k\]
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: \[s_n = \sum_{k=0}^{n-1} f_k\]
- en: and \(f(n)\) does not depend on \(n\), returns \(g_{n} - g(0)\) where \(g_{n+1}
    - g_n = f_n\), or `None` if \(s_n\) cannot be expressed in closed form as a sum
    of hypergeometric terms.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 \(f(n)\) 不依赖于 \(n\)，返回 \(g_{n} - g(0)\)，其中 \(g_{n+1} - g_n = f_n\)，或者如果 \(s_n\)
    无法作为超几何项和的封闭形式表示，则返回 `None`。
- en: Examples
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE91]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: References
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[R109](#id12)]'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R109](#id12)]'
- en: Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B, AK Peters, Ltd.,
    Wellesley, MA, USA, 1997, pp. 73–100
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B, AK Peters, Ltd.,
    Wellesley, MA, USA, 1997, pp. 73–100
