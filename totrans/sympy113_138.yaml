- en: Number Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/ntheory.html](https://docs.sympy.org/latest/modules/ntheory.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Ntheory Class Reference'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A list of prime numbers, implemented as a dynamically growing sieve of Eratosthenes.
    When a lookup is requested involving an odd number that has not been sieved, the
    sieve is automatically extended up to that number. Implementation details limit
    the number of primes to `2^32-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Grow the sieve to cover all primes <= n.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extend to include the ith prime number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The list is extended by 50% if it is too short, so it is likely that it will
    be longer than requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Generate all mobius numbers for the range [a, b).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: First number in range
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: First number outside of range
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Generate all prime numbers in the range [2, a) or [a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All primes less than 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All primes greater than or equal to 7 and less than 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All primes through the 10th prime
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Return the indices i, j of the primes that bound n.
  prefs: []
  type: TYPE_NORMAL
- en: If n is prime then i == j.
  prefs: []
  type: TYPE_NORMAL
- en: Although n can be an expression, if ceiling cannot convert it to an integer
    then an n error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Generate all totient numbers for the range [a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Ntheory Functions Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Return the nth prime, with the primes indexed as prime(1) = 2, prime(2) = 3,
    etc…. The nth prime is approximately \(n\log(n)\).
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic integral of \(x\) is a pretty nice approximation for number of primes
    \(\le x\), i.e. li(x) ~ pi(x) In fact, for the numbers we are concerned about(
    x<1e11 ), li(x) - pi(x) < 50000
  prefs: []
  type: TYPE_NORMAL
- en: Also, li(x) > pi(x) can be safely assumed for the numbers which can be evaluated
    by this function.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we find the least integer m such that li(m) > n using binary search. Now
    pi(m-1) < li(m-1) <= n,
  prefs: []
  type: TYPE_NORMAL
- en: We find pi(m - 1) using primepi function.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from m, we have to find n - pi(m-1) more primes.
  prefs: []
  type: TYPE_NORMAL
- en: For the inputs this implementation can handle, we will have to test primality
    for at max about 10**5 numbers, to get our answer.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Test if n is prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of primes less than or equal to n
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R648](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29](https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R649](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number](https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R650](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Skewes%27_number](https://en.wikipedia.org/wiki/Skewes%27_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Represents the prime counting function pi(n) = the number of prime numbers less
    than or equal to n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `primepi` function is deprecated. Use [`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm Description:'
  prefs: []
  type: TYPE_NORMAL
- en: In sieve method, we remove all multiples of prime p except p itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let phi(i,j) be the number of integers 2 <= k <= i which remain after sieving
    from primes less than or equal to j. Clearly, pi(n) = phi(n, sqrt(n))
  prefs: []
  type: TYPE_NORMAL
- en: If j is not a prime, phi(i,j) = phi(i, j - 1)
  prefs: []
  type: TYPE_NORMAL
- en: if j is a prime, We remove all numbers(except j) whose smallest prime factor
    is j.
  prefs: []
  type: TYPE_NORMAL
- en: Let \(x= j \times a\) be such a number, where \(2 \le a \le i / j\) Now, after
    sieving from primes \(\le j - 1\), a must remain (because x, and hence a has no
    prime factor \(\le j - 1\)) Clearly, there are phi(i / j, j - 1) such a which
    remain on sieving from primes \(\le j - 1\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if a is a prime less than equal to j - 1, \(x= j \times a\) has smallest
    prime factor = a, and has already been removed(by sieving from a). So, we do not
    need to remove it again. (Note: there will be pi(j - 1) such x)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, number of x, that will be removed are: phi(i / j, j - 1) - phi(j - 1,
    j - 1) (Note that pi(j - 1) = phi(j - 1, j - 1))'
  prefs: []
  type: TYPE_NORMAL
- en: \(\Rightarrow\) phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j
    - 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'So,following recursion is used and implemented as dp:'
  prefs: []
  type: TYPE_NORMAL
- en: phi(a, b) = phi(a, b - 1), if b is not a prime phi(a, b) = phi(a, b-1)-phi(a
    / b, b-1) + phi(b-1, b-1), if b is prime
  prefs: []
  type: TYPE_NORMAL
- en: Clearly a is always of the form floor(n / k), which can take at most \(2\sqrt{n}\)
    values. Two arrays arr1,arr2 are maintained arr1[i] = phi(i, j), arr2[i] = phi(n
    // i, j)
  prefs: []
  type: TYPE_NORMAL
- en: Finally the answer is arr2[1]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So there are 9 primes less than or equal to 25\. Is 25 prime?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not. So the first prime less than 25 must be the 9th prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Test if n is prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Return the ith prime greater than n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**ith** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**int** : Return the ith prime greater than n'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `ith <= 0`. If `n` or `ith` is not an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Potential primes are located at 6*j +/- 1\. This property is used during searching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the largest prime smaller than n
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Return the largest prime smaller than n.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Potential primes are located at 6*j +/- 1\. This property is used during searching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the ith prime greater than n
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generates all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generate a list of all prime numbers in the range [2, a), or [a, b).
  prefs: []
  type: TYPE_NORMAL
- en: If the range exists in the default sieve, the values will be returned from there;
    otherwise values will be returned but will not modify the sieve.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All primes less than 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All primes greater than or equal to 7 and less than 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All primes through the 10th prime
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The Sieve method, primerange, is generally faster but it will occupy more memory
    as the sieve stores values. The default instance of Sieve, named sieve, can be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Some famous conjectures about the occurrence of primes in a given range are
    [1]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Twin primes: though often not, the following will give 2 primes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'an infinite number of times:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: primerange(6*n - 1, 6*n + 2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Legendre’s: the following always yields at least one prime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: primerange(n**2, (n+1)**2+1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bertrand’s (proven): there is always a prime in the range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: primerange(n, 2*n)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Brocard’s: there are at least four primes in the range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: primerange(prime(n)**2, prime(n+1)**2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The average gap between primes is log(n) [2]; the gap between primes can be
    arbitrarily large since sequences of composite numbers are arbitrarily large,
    e.g. the numbers in the sequence n! + 2, n! + 3 … n! + n are all composite.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the ith prime greater than n
  prefs: []
  type: TYPE_NORMAL
- en: '[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the largest prime smaller than n
  prefs: []
  type: TYPE_NORMAL
- en: '[`randprime`](#sympy.ntheory.generate.randprime "sympy.ntheory.generate.randprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a random prime in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`primorial`](#sympy.ntheory.generate.primorial "sympy.ntheory.generate.primorial")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the product of primes based on condition
  prefs: []
  type: TYPE_NORMAL
- en: '[`Sieve.primerange`](#sympy.ntheory.generate.Sieve.primerange "sympy.ntheory.generate.Sieve.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: return range from already computed primes or extend the sieve to contain the
    requested range.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R651](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R652](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://primes.utm.edu/notes/gaps.html](https://primes.utm.edu/notes/gaps.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Return a random prime number in the range [a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Bertrand’s postulate assures that randprime(a, 2*a) will always succeed for
    a > 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note that due to implementation difficulties, the prime numbers chosen are not
    uniformly random. For example, there are two primes in the range [112, 128), `113`
    and `127`, but `randprime(112, 128)` returns `127` with a probability of 15/17.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R653](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bertrand’s_postulate](https://en.wikipedia.org/wiki/Bertrand''s_postulate)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Returns the product of the first n primes (default) or the primes less than
    or equal to n (when `nth=False`).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: One can argue that the primes are infinite since if you take a set of primes
    and multiply them together (e.g. the primorial) and then add or subtract 1, the
    result cannot be divided by any of the original factors, hence either 1 or more
    new primes must divide this product of primes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the number itself is a new prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case two new primes are the factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, some primes smaller and larger than the primes multiplied together are
    obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For a given iterated sequence, return a generator that gives the length of the
    iterated cycle (lambda) and the length of terms before the cycle begins (mu);
    if `values` is True then the terms of the sequence will be returned instead. The
    sequence is started with value `x0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: more than the first lambda + mu terms may be returned and this is the
    cost of cycle detection with Brent’s method; there are, however, generally less
    terms calculated than would have been calculated if the proper ending point were
    determined, e.g. by using Floyd’s method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will yield successive values of i <– func(i):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A function is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'and given a seed of 4 and the mu and lambda terms calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see what is meant by looking at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There are 6 repeating values after the first 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a sequence is suspected of being longer than you might wish, `nmax` can
    be used to exit early (and mu will be returned as None):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Code modified from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cycle_detection](https://en.wikipedia.org/wiki/Cycle_detection).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Return the nth composite number, with the composite numbers indexed as composite(1)
    = 4, composite(2) = 6, etc….
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Test if n is prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of primes less than or equal to n
  prefs: []
  type: TYPE_NORMAL
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`compositepi`](#sympy.ntheory.generate.compositepi "sympy.ntheory.generate.compositepi")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of positive composite numbers less than or equal to n
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of positive composite numbers less than or equal to n. The
    first positive composite is 4, i.e. compositepi(4) = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")'
  prefs: []
  type: TYPE_NORMAL
- en: Test if n is prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: '[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of primes less than or equal to n
  prefs: []
  type: TYPE_NORMAL
- en: '[`composite`](#sympy.ntheory.generate.composite "sympy.ntheory.generate.composite")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth composite number
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Return the B-smooth and B-power smooth values of n.
  prefs: []
  type: TYPE_NORMAL
- en: The smoothness of n is the largest prime factor of n; the power- smoothness
    is the largest divisor raised to its multiplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a list of [m, (p, (M, sm(p + m), psm(p + m)))…] where:'
  prefs: []
  type: TYPE_NORMAL
- en: p**M is the base-p divisor of n
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sm(p + m) is the smoothness of p + m (m = -1 by default)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: psm(p + m) is the power smoothness of p + m
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list is sorted according to smoothness (default) or by power smoothness
    if power=1.
  prefs: []
  type: TYPE_NORMAL
- en: The smoothness of the numbers to the left (m = -1) or right (m = 1) of a factor
    govern the results that are obtained from the p +/- 1 type factoring methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If visual=True then an annotated string will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This string can also be generated directly from a factorization dictionary
    and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The table of the output logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Visual |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Input | True | False | other |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| dict | str | tuple | str |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| str | str | tuple | dict |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| tuple | str | tuple | str |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| n | str | tuple | tuple |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| mul | str | tuple | tuple |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Find the greatest integer m such that p**m divides n.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: when checking for the multiplicity of a number in a large factorial it
    is most efficient to send it as an unevaluated factorial or to call `multiplicity_in_factorial`
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`trailing`](core.html#sympy.core.intfunc.trailing "sympy.core.intfunc.trailing")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return `(b, e)` such that `n` == `b**e` if `n` is a unique perfect power with
    `e > 1`, else `False` (e.g. 1 is not a perfect power). A ValueError is raised
    if `n` is not Rational.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the base is recursively decomposed and the exponents collected so
    the largest possible `e` is sought. If `big=False` then the smallest possible
    `e` (thus prime) will be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: If `factor=True` then simultaneous factorization of `n` is attempted since finding
    a factor indicates the only possible root for `n`. This is True by default since
    only a few small factors will be tested in the course of searching for the perfect
    power.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `candidates` is primarily for internal use; if provided, False will
    be returned if `n` cannot be written as a power with one of the candidates as
    an exponent and factoring (beyond testing for a factor of 2) will not be attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative numbers can only have odd perfect powers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Rationals are also recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: To know whether an integer is a perfect power of 2 use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It is not necessary to provide `candidates`. When provided it will be assumed
    that they are ints. The first one that is larger than the computed maximum possible
    exponent will signal failure for the routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.integer_nthroot`](core.html#sympy.core.intfunc.integer_nthroot
    "sympy.core.intfunc.integer_nthroot"), [`sympy.ntheory.primetest.is_square`](#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Use Pollard’s rho method to try to extract a nontrivial factor of `n`. The returned
    factor may be a composite number. If no factor is found, `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm generates pseudo-random values of x with a generator function,
    replacing x with F(x). If F is not supplied then the function x**2 + `a` is used.
    The first value supplied to F(x) is `s`. Upon failure (if `retries` is > 0) a
    new `a` and `s` will be supplied; the `a` will be ignored if F was supplied.
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of numbers generated by such functions generally have a a lead-up
    to some number and then loop around back to that number and begin to repeat the
    sequence, e.g. 1, 2, 3, 4, 5, 3, 4, 5 – this leader and loop look a bit like the
    Greek letter rho, and thus the name, ‘rho’.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given function, very different leader-loop values can be obtained so
    it is a good idea to allow for retries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explicit example where there is a three element leadup to a sequence
    of 3 numbers (11, 14, 4) that then repeat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Instead of checking the differences of all generated values for a gcd with n,
    only the kth and 2*kth numbers are checked, e.g. 1st and 2nd, 2nd and 4th, 3rd
    and 6th until it has been detected that the loop has been traversed. Loops may
    be many thousands of steps long before rho finds a factor or reports failure.
    If `max_steps` is specified, the iteration is cancelled with a failure after the
    specified number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the default setting with a bad value of `a` and no retries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If retries is > 0 then perhaps the problem will correct itself when new values
    are generated for a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R654](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 229-231'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Use Pollard’s p-1 method to try to extract a nontrivial factor of `n`. Either
    a divisor (perhaps composite) or `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `a` is the base that is used in the test gcd(a**M - 1, n). The
    default is 2\. If `retries` > 0 then if no factor is found after the first attempt,
    a new `a` will be generated randomly (using the `seed`) and the process repeated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the value of M is lcm(1..B) = reduce(ilcm, range(2, B + 1)).'
  prefs: []
  type: TYPE_NORMAL
- en: A search is made for factors next to even numbers having a power smoothness
    less than `B`. Choosing a larger B increases the likelihood of finding a larger
    factor but takes longer. Whether a factor of n is found or not depends on `a`
    and the power smoothness of the even number just less than the factor p (hence
    the name p - 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although some discussion of what constitutes a good `a` some descriptions are
    hard to interpret. At the modular.math site referenced below it is stated that
    if gcd(a**M - 1, n) = N then a**M % q**r is 1 for every prime power divisor of
    N. But consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'So we should (and can) find a root with B=16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to increase B to 256 we find that it does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the value of `a` is changed we find that only multiples of 257 work,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking different `a` values shows that all the ones that did not work had
    a gcd value not equal to `n` but equal to one of the factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: But does aM % d for every divisor of n give 1?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'No, only one of them. So perhaps the principle is that a root will be found
    for a given value of B provided that:'
  prefs: []
  type: TYPE_NORMAL
- en: the power smoothness of the p - 1 value next to the root does not exceed B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a**M % p != 1 for any of the divisors of n.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By trying more than one `a` it is possible that one of them will yield a factor.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'With the default smoothness bound, this number cannot be cracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Increasing the smoothness bound helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the smoothness of the factors of this number we find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The B and B-pow are the same for the p - 1 factorizations of the divisors because
    those factorizations had a very large prime factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that until B reaches the B-pow value of 1787, the number is not cracked;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The B value has to do with the factors of the number next to the divisor, not
    the divisors themselves. A worst case scenario is that the number next to the
    factor p has a large prime divisisor or is a perfect power. If these conditions
    apply then the power-smoothness will be about p/2 or p. The more realistic is
    that there will be a large prime factor next to p requiring a B value on the order
    of p/2\. Although primes may have been searched for up to this level, the p/2
    is a factor of p - 1, something that we do not know. The modular.math reference
    below states that 15% of numbers in the range of 10**15 to 15**15 + 10**4 are
    10**6 power smooth so a B of 10**6 will fail 85% of the time in that range. From
    10**8 to 10**8 + 10**3 the percentages are nearly reversed…but in that range the
    simple trial division is quite fast.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R655](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 236-238'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R656](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html](https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R657](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.cs.toronto.edu/~yuvalf/Factorization.pdf](https://www.cs.toronto.edu/~yuvalf/Factorization.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a positive integer `n`, `factorint(n)` returns a dict containing the
    prime factors of `n` as keys and their respective multiplicities as values. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For input less than 2, factorint behaves as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`factorint(1)` returns the empty factorization, `{}`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`factorint(0)` returns `{0:1}`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`factorint(-n)` adds `-1:1` to the factors and then factors `n`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Partial Factorization:'
  prefs: []
  type: TYPE_NORMAL
- en: If `limit` (> 3) is specified, the search is stopped after performing trial
    division up to (and including) the limit (or taking a corresponding number of
    rho/p-1 steps). This is useful if one has a large number and only is interested
    in finding small factors (if any). Note that setting a limit does not prevent
    larger factors from being found early; it simply means that the largest factor
    may be composite. Since checking for perfect power is relatively cheap, it is
    done regardless of the limit setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This number, for example, has two small factors and a huge semi-prime factor
    that cannot be reduced easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This number has a small factor and a residual perfect power whose base is greater
    than the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'List of Factors:'
  prefs: []
  type: TYPE_NORMAL
- en: If `multiple` is set to `True` then a list containing the prime factors including
    multiplicities is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Visual Factorization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `visual` is set to `True`, then it will return a visual factorization of
    the integer. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is achieved by using the evaluate=False flag in Mul and Pow.
    If you do other manipulations with an expression where evaluate=False, it may
    evaluate. Therefore, you should use the visual option only for visualization,
    and use the normal dictionary returned by visual=False if you want to perform
    operations on the factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily switch between the two forms by sending them back to factorint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to send a number to be factored in a partially factored form you
    can do so with a dictionary or unevaluated expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The table of the output logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Input | True | False | other |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| dict | mul | dict | mul |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| n | mul | dict | dict |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| mul | mul | dict | dict |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function switches between multiple algorithms. Trial division quickly finds
    small factors (of the order 1-5 digits), and finds all large factors if given
    enough time. The Pollard rho and p-1 algorithms are used to find large factors
    ahead of time; they will often find factors of the order of 10 digits within a
    few seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Any of these methods can optionally be disabled with the following boolean
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`use_trial`: Toggle use of trial division'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_rho`: Toggle use of Pollard’s rho method'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_pm1`: Toggle use of Pollard’s p-1 method'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '`factorint` also periodically checks if the remaining part is a prime number
    or a perfect power, and in those cases stops.'
  prefs: []
  type: TYPE_NORMAL
- en: For unevaluated factorial, it uses Legendre’s formula(theorem).
  prefs: []
  type: TYPE_NORMAL
- en: If `verbose` is set to `True`, detailed progress is printed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness"),
    [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a Rational `r`, `factorrat(r)` returns a dict containing the prime factors
    of `r` as keys and their respective multiplicities as values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Please see the docstring for `factorint` for detailed explanations and examples
    of the following keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`limit`: Integer limit up to which trial division is done'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_trial`: Toggle use of trial division'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_rho`: Toggle use of Pollard’s rho method'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`use_pm1`: Toggle use of Pollard’s p-1 method'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`verbose`: Toggle detailed printing of progress'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`multiple`: Toggle returning a list of factors or dict'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`visual`: Toggle product form of output'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Return a sorted list of n’s prime factors, ignoring multiplicity and any composite
    factor that remains if the limit was set too low for complete factorization. Unlike
    factorint(), primefactors() does not return -1 or 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**limit, verbose, **kwargs :**'
  prefs: []
  type: TYPE_NORMAL
- en: Additional keyword arguments to be passed to `factorint`. Since `kwargs` is
    new in version 1.13, `limit` and `verbose` are retained for compatibility purposes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**list(int)** : List of prime numbers dividing `n`'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Return all divisors of n sorted from 1..n by default. If generator is `True`
    an unordered generator is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The number of divisors of n can be quite large if there are many prime factors
    (counting repeated factors). If only the number of factors is desired use divisor_count(n).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a slightly modified version of Tim Peters referenced at: [https://stackoverflow.com/questions/1010381/python-factorization](https://stackoverflow.com/questions/1010381/python-factorization)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Return all divisors of n except n, sorted by default. If generator is `True`
    an unordered generator is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count "sympy.ntheory.factor_.proper_divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of divisors of `n`. If `modulus` is not 1 then only those
    that are divisible by `modulus` are counted. If `proper` is True then the divisor
    of `n` will not be counted.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count
    "sympy.ntheory.factor_.proper_divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of proper divisors of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`proper_divisors`](#sympy.ntheory.factor_.proper_divisors "sympy.ntheory.factor_.proper_divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return all unitary divisors of n sorted from 1..n by default. If generator is
    `True` an unordered generator is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The number of unitary divisors of n can be quite large if there are many prime
    factors. If only the number of unitary divisors is desired use udivisor_count(n).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count "sympy.ntheory.factor_.udivisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R658](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Unitary_divisor](https://en.wikipedia.org/wiki/Unitary_divisor)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R659](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/UnitaryDivisor.html](https://mathworld.wolfram.com/UnitaryDivisor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of unitary divisors of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`udivisors`](#sympy.ntheory.factor_.udivisors "sympy.ntheory.factor_.udivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R660](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Return all antidivisors of n sorted from 1..n by default.
  prefs: []
  type: TYPE_NORMAL
- en: Antidivisors [[R661]](#r661) of n are numbers that do not divide n by the largest
    possible margin. If generator is True an unordered generator is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"),
    [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`antidivisor_count`](#sympy.ntheory.factor_.antidivisor_count "sympy.ntheory.factor_.antidivisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R661] ([1](#id14),[2](#id15))'
  prefs: []
  type: TYPE_NORMAL
- en: definition is described in [https://oeis.org/A066272/a066272a.html](https://oeis.org/A066272/a066272a.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of antidivisors [[R662]](#r662) of `n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"),
    [`antidivisors`](#sympy.ntheory.factor_.antidivisors "sympy.ntheory.factor_.antidivisors"),
    [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R662] ([1](#id16),[2](#id17))'
  prefs: []
  type: TYPE_NORMAL
- en: formula from [https://oeis.org/A066272](https://oeis.org/A066272)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the Euler totient function phi(n)
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `totient` function is deprecated. Use [`sympy.functions.combinatorial.numbers.totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '`totient(n)` or \(\phi(n)\) is the number of positive integers \(\leq\) n that
    are relatively prime to n.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R663](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler%27s_totient_function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R664](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/TotientFunction.html](https://mathworld.wolfram.com/TotientFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the Carmichael reduced totient function lambda(n)
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `reduced_totient` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.reduced_totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '`reduced_totient(n)` or \(\lambda(n)\) is the smallest m > 0 such that \(k^m
    \equiv 1 \mod n\) for all k relatively prime to n.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R665](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Carmichael_function](https://en.wikipedia.org/wiki/Carmichael_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R666](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/CarmichaelFunction.html](https://mathworld.wolfram.com/CarmichaelFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the divisor function \(\sigma_k(n)\) for positive integer n
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `divisor_sigma` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.divisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '`divisor_sigma(n, k)` is equal to `sum([x**k for x in divisors(n)])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[\sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots + p_i^{m_ik}).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : integer, optional'
  prefs: []
  type: TYPE_NORMAL
- en: power of divisors in the sum
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'for k = 0, 1: `divisor_sigma(n, 0)` is equal to `divisor_count(n)` `divisor_sigma(n,
    1)` is equal to `sum(divisors(n))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for k is 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R667](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Divisor_function](https://en.wikipedia.org/wiki/Divisor_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the unitary divisor function \(\sigma_k^*(n)\) for positive integer
    n
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `udivisor_sigma` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.udivisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.udivisor_sigma
    "sympy.functions.combinatorial.numbers.udivisor_sigma") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '`udivisor_sigma(n, k)` is equal to `sum([x**k for x in udivisors(n)])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[\sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : power of divisors in the sum'
  prefs: []
  type: TYPE_NORMAL
- en: 'for k = 0, 1: `udivisor_sigma(n, 0)` is equal to `udivisor_count(n)` `udivisor_sigma(n,
    1)` is equal to `sum(udivisors(n))`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for k is 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"),
    [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors
    "sympy.ntheory.factor_.divisors"), [`udivisors`](#sympy.ntheory.factor_.udivisors
    "sympy.ntheory.factor_.udivisors"), [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count
    "sympy.ntheory.factor_.udivisor_count"), [`divisor_sigma`](#sympy.ntheory.factor_.divisor_sigma
    "sympy.ntheory.factor_.divisor_sigma"), [`factorint`](#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R668](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Calculate core(n, t) = \(core_t(n)\) of a positive integer n
  prefs: []
  type: TYPE_NORMAL
- en: '`core_2(n)` is equal to the squarefree part of n'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^\omega p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[core_t(n) = \prod_{i=1}^\omega p_i^{m_i \mod t}.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**t** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: core(n, t) calculates the t-th power free part of n
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`core(n, 2)` is the squarefree part of `n` `core(n, 3)` is the cubefree part
    of `n`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default for t is 2.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"),
    [`sympy.solvers.diophantine.diophantine.square_factor`](solvers/diophantine.html#sympy.solvers.diophantine.diophantine.square_factor
    "sympy.solvers.diophantine.diophantine.square_factor")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R669](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core](https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of the digits of `n` in base `b`. The first element in the list
    is `b` (or `-b` if `n` is negative).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The number whose digits are returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The base in which digits are computed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**digits: integer (or None for all digits)**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of digits to be returned (padded with zeros, if necessary).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number is negative, the negative sign will be placed on the base (which
    is the first element in the returned list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases other than 10 (and greater than 1) can be selected with `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `digits` keyword if a certain number of digits is desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the number of distinct prime factors for a positive integer n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `primenu` function is deprecated. Use [`sympy.functions.combinatorial.numbers.primenu`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primenu
    "sympy.functions.combinatorial.numbers.primenu") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: 'then `primenu(n)` or \(\nu(n)\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\nu(n) = k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R670](#id25)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the number of prime factors counting multiplicities for a positive
    integer n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `primeomega` function is deprecated. Use
    [`sympy.functions.combinatorial.numbers.primeomega`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primeomega
    "sympy.functions.combinatorial.numbers.primeomega") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If n’s prime factorization is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[n = \prod_{i=1}^k p_i^{m_i},\]
  prefs: []
  type: TYPE_NORMAL
- en: 'then `primeomega(n)` or \(\Omega(n)\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\Omega(n) = \sum_{i=1}^k m_i.\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R671](#id26)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Returns the exponent `i` for the nth Mersenne prime (which has the form \(2^i
    - 1\)).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `n` is a perfect number, else False.
  prefs: []
  type: TYPE_NORMAL
- en: A perfect number is equal to the sum of its positive, proper divisors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R672](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PerfectNumber.html](https://mathworld.wolfram.com/PerfectNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R673](#id28)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Perfect_number](https://en.wikipedia.org/wiki/Perfect_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Returns the difference between the sum of the positive proper divisors of a
    number and the number.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `n` is an abundant number, else False.
  prefs: []
  type: TYPE_NORMAL
- en: A abundant number is smaller than the sum of its positive proper divisors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R674](#id29)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/AbundantNumber.html](https://mathworld.wolfram.com/AbundantNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `n` is a deficient number, else False.
  prefs: []
  type: TYPE_NORMAL
- en: A deficient number is greater than the sum of its positive proper divisors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R675](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/DeficientNumber.html](https://mathworld.wolfram.com/DeficientNumber.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if the numbers \(m\) and \(n\) are “amicable”, else False.
  prefs: []
  type: TYPE_NORMAL
- en: Amicable numbers are two different numbers so related that the sum of the proper
    divisors of each is equal to that of the other.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R676](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Amicable_numbers](https://en.wikipedia.org/wiki/Amicable_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if the numbers \(n\) is Carmichael number, else False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R677](#id32)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Carmichael_number](https://en.wikipedia.org/wiki/Carmichael_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R678](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/A002997](https://oeis.org/A002997)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list of the number of Carmichael in the range
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Returns the first n Carmichael numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Return the residual mod m such that it is within half of the modulus.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Chinese Remainder Theorem.
  prefs: []
  type: TYPE_NORMAL
- en: The moduli in m are assumed to be pairwise coprime. The output is then an integer
    f, such that f = v_i mod m_i for each pair out of v and m. If `symmetric` is False
    a positive integer will be returned, else |f| will be less than or equal to the
    LCM of the moduli, and thus f may be negative.
  prefs: []
  type: TYPE_NORMAL
- en: If the moduli are not co-prime the correct result will be returned if/when the
    test of the result is found to be incorrect. This result will be None if there
    is no solution.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `check` can be set to False if it is known that the moduli are coprime.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example consider a set of residues `U = [49, 76, 65]` and a set of moduli
    `M = [99, 97, 95]`. Then we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the correct result because:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'If the moduli are not co-prime, you may receive an incorrect result if you
    use `check=False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: the order of gf_crt’s arguments is reversed relative to crt, and that
    solve_congruence takes residue, modulus pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmer’s note: rather than checking that all pairs of moduli share no GCD
    (an O(n**2) test) and rather than factoring all moduli and seeing that there is
    no factor in common, a check that the result gives the indicated residuals is
    performed – an O(n) operation.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve_congruence`](#sympy.ntheory.modular.solve_congruence "sympy.ntheory.modular.solve_congruence")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.galoistools.gf_crt`](polys/internals.html#sympy.polys.galoistools.gf_crt
    "sympy.polys.galoistools.gf_crt")'
  prefs: []
  type: TYPE_NORMAL
- en: low level crt routine used by this routine
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: First part of Chinese Remainder Theorem, for multiple application.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: The following two codes have the same result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is faster when we want to fix `m` and compute for multiple `v`,
    i.e. the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.galoistools.gf_crt1`](polys/internals.html#sympy.polys.galoistools.gf_crt1
    "sympy.polys.galoistools.gf_crt1")'
  prefs: []
  type: TYPE_NORMAL
- en: low level crt routine used by this routine
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt2`](#sympy.ntheory.modular.crt2 "sympy.ntheory.modular.crt2")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Second part of Chinese Remainder Theorem, for multiple application.
  prefs: []
  type: TYPE_NORMAL
- en: See `crt1` for usage.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.galoistools.gf_crt2`](polys/internals.html#sympy.polys.galoistools.gf_crt2
    "sympy.polys.galoistools.gf_crt2")'
  prefs: []
  type: TYPE_NORMAL
- en: low level crt routine used by this routine
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"),
    [`sympy.ntheory.modular.crt1`](#sympy.ntheory.modular.crt1 "sympy.ntheory.modular.crt1")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the integer `n` that has the residual `ai` when it is divided by `mi`
    where the `ai` and `mi` are given as pairs to this function: ((a1, m1), (a2, m2),
    …). If there is no solution, return None. Otherwise return `n` and its modulus.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mi` values need not be co-prime. If it is known that the moduli are not
    co-prime then the hint `check` can be set to False (default=True) and the check
    for a quicker solution via crt() (valid when the moduli are co-prime) will be
    skipped.
  prefs: []
  type: TYPE_NORMAL
- en: If the hint `symmetric` is True (default is False), the value of `n` will be
    within 1/2 of the modulus, possibly negative.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: What number is 2 mod 3, 3 mod 5 and 2 mod 7?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to work with all remainder in one list and all moduli in another,
    send the arguments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The moduli need not be co-prime; in this case there may or may not be a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The symmetric flag will make the result be within 1/2 of the modulus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")'
  prefs: []
  type: TYPE_NORMAL
- en: high level routine implementing the Chinese Remainder Theorem
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a dictionary containing pairs \({(k1,k2) : C_kn}\) where \(C_kn\) are
    binomial coefficients and \(n=k1+k2\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`binomial_coefficients_list`](#sympy.ntheory.multinomial.binomial_coefficients_list
    "sympy.ntheory.multinomial.binomial_coefficients_list"), [`multinomial_coefficients`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of binomial coefficients as rows of the Pascal’s triangle.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`binomial_coefficients`](#sympy.ntheory.multinomial.binomial_coefficients
    "sympy.ntheory.multinomial.binomial_coefficients"), [`multinomial_coefficients`](#sympy.ntheory.multinomial.multinomial_coefficients
    "sympy.ntheory.multinomial.multinomial_coefficients")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a dictionary containing pairs `{(k1,k2,..,km) : C_kn}` where `C_kn`
    are multinomial coefficients such that `n=k1+k2+..+km`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is based on the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\binom{n}{k_1, \ldots, k_m} = \frac{k_1 + 1}{n - k_1} \sum_{i=2}^m \binom{n}{k_1
    + 1, \ldots, k_i - 1, \ldots}\]
  prefs: []
  type: TYPE_NORMAL
- en: Code contributed to Sage by Yann Laigle-Chapuy, copied with permission of the
    author.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`binomial_coefficients_list`](#sympy.ntheory.multinomial.binomial_coefficients_list
    "sympy.ntheory.multinomial.binomial_coefficients_list"), [`binomial_coefficients`](#sympy.ntheory.multinomial.binomial_coefficients
    "sympy.ntheory.multinomial.binomial_coefficients")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: multinomial coefficient iterator
  prefs: []
  type: TYPE_NORMAL
- en: This routine has been optimized for \(m\) large with respect to \(n\) by taking
    advantage of the fact that when the monomial tuples \(t\) are stripped of zeros,
    their coefficient is the same as that of the monomial tuples from `multinomial_coefficients(n,
    n)`. Therefore, the latter coefficients are precomputed to save memory and time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the partition function P(n), i.e. the number of ways that n can be
    written as a sum of positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `npartitions` function is deprecated. Use
    [`sympy.functions.combinatorial.numbers.partition`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.partition
    "sympy.functions.combinatorial.numbers.partition") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: P(n) is computed using the Hardy-Ramanujan-Rademacher formula [[R679]](#r679).
  prefs: []
  type: TYPE_NORMAL
- en: The correctness of this implementation has been tested through \(10^{10}\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R679] ([1](#id34),[2](#id35))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PartitionFunctionP.html](https://mathworld.wolfram.com/PartitionFunctionP.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a^{n-1} \equiv 1 \pmod{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: (where mod refers to the modulo operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is a positive integer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**a** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If `n` is prime, it always returns `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: The composite number that returns `True` is called an Fermat pseudoprime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R680](#id36)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Fermat_pseudoprime](https://en.wikipedia.org/wiki/Fermat_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a^{(n-1)/2} \equiv \pm 1 \pmod{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: (where mod refers to the modulo operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is a positive integer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**a** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If `n` is prime, it always returns `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: The composite number that returns `True` is called an Euler pseudoprime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R681](#id37)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler_pseudoprime](https://en.wikipedia.org/wiki/Euler_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns True if `n` is prime or is an odd composite integer that is coprime
    to `a` and satisfy the modular arithmetic congruence relation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a^{(n-1)/2} \equiv \left(\frac{a}{n}\right) \pmod{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: (where mod refers to the modulo operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is a positive integer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**a** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is a positive integer. `a` and `n` should be relatively prime.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If `n` is prime, it always returns `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: The composite number that returns `True` is called an Euler-Jacobi pseudoprime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R682](#id38)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime](https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Return True if n == a * a for some integer a, else False. If n is suspected
    of *not* being a square then this is a quick method of confirming that it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.isqrt`](core.html#sympy.core.intfunc.isqrt "sympy.core.intfunc.isqrt")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R683](#id39)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mersenneforum.org/showpost.php?p=110896](https://mersenneforum.org/showpost.php?p=110896)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Perform a Miller-Rabin strong pseudoprime test on n using a given list of bases/witnesses.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R684](#id40)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”,
    Springer, 2nd edition, 135-138'
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of thresholds and the bases they require are here: [https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Standard Lucas compositeness test with Selfridge parameters. Returns False if
    n is definitely composite, and True if n is a Lucas probable prime.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically used in combination with the Miller-Rabin test.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R685](#id41)]'
  prefs: []
  type: TYPE_NORMAL
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R686](#id42)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'OEIS A217120: Lucas Pseudoprimes [https://oeis.org/A217120](https://oeis.org/A217120)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R687](#id43)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Strong Lucas compositeness test with Selfridge parameters. Returns False if
    n is definitely composite, and True if n is a strong Lucas probable prime.
  prefs: []
  type: TYPE_NORMAL
- en: This is often used in combination with the Miller-Rabin test, and in particular,
    when combined with M-R base 2 creates the strong BPSW test.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R688](#id44)]'
  prefs: []
  type: TYPE_NORMAL
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R689](#id45)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'OEIS A217255: Strong Lucas Pseudoprimes [https://oeis.org/A217255](https://oeis.org/A217255)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R690](#id46)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R691](#id47)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Extra Strong Lucas compositeness test. Returns False if n is definitely composite,
    and True if n is an “extra strong” Lucas probable prime.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters are selected using P = 3, Q = 1, then incrementing P until (D|n)
    == -1\. The test itself is as defined in [[R692]](#r692), from the Mo and Jones
    preprint. The parameter selection and test are the same as used in OEIS A217719,
    Perl’s Math::Prime::Util, and the Lucas pseudoprime page on Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: It is 20-50% faster than the strong test.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the different parameters selected, there is no relationship between
    the strong Lucas pseudoprimes and extra strong Lucas pseudoprimes. In particular,
    one is not a subset of the other.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R692] ([1](#id48),[2](#id49))'
  prefs: []
  type: TYPE_NORMAL
- en: Jon Grantham, Frobenius Pseudoprimes, Math. Comp. Vol 70, Number 234 (2001),
    pp. 873-891, [https://doi.org/10.1090%2FS0025-5718-00-01197-2](https://doi.org/10.1090%2FS0025-5718-00-01197-2)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R693](#id50)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'OEIS A217719: Extra Strong Lucas Pseudoprimes [https://oeis.org/A217719](https://oeis.org/A217719)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R694](#id51)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lucas_pseudoprime](https://en.wikipedia.org/wiki/Lucas_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Test if the Proth number \(n = k2^m + 1\) is prime. where k is a positive odd
    number and \(2^m > k\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '`n` is Proth number'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If `True`, then `n` is the Proth prime'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is not Proth number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R695](#id52)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Proth_prime](https://en.wikipedia.org/wiki/Proth_prime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `n` is a Mersenne prime, else False.
  prefs: []
  type: TYPE_NORMAL
- en: A Mersenne prime is a prime number having the form \(2^i - 1\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R696](#id53)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/MersennePrime.html](https://mathworld.wolfram.com/MersennePrime.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Test if n is a prime number (True) or not (False). For n < 2^64 the answer is
    definitive; larger n values have a small probability of actually being pseudoprimes.
  prefs: []
  type: TYPE_NORMAL
- en: Negative numbers (e.g. -2) are not considered prime.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is looking for trivial factors, which if found enables a quick
    return. Next, if the sieve is large enough, use bisection search on the sieve.
    For small numbers, a set of deterministic Miller-Rabin tests are performed with
    bases that are known to have no counterexamples in their range. Finally if the
    number is larger than 2^64, a strong BPSW test is performed. While this is a probable
    prime test and we believe counterexamples exist, there are no known counterexamples.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This routine is intended only for integer input, not numerical expressions
    which may represent numbers. Floats are also rejected as input because they represent
    numbers of limited precision. While it is tempting to permit 7.0 to represent
    an integer there are errors that may “pass silently” if this is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.generate.primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")'
  prefs: []
  type: TYPE_NORMAL
- en: Generates all primes in a given range
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi
    "sympy.functions.combinatorial.numbers.primepi")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the number of primes less than or equal to n
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.generate.prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")'
  prefs: []
  type: TYPE_NORMAL
- en: Return the nth prime
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R697](#id54)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Strong_pseudoprime](https://en.wikipedia.org/wiki/Strong_pseudoprime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R698](#id55)]'
  prefs: []
  type: TYPE_NORMAL
- en: Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35,
    Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6)
    [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R699](#id56)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Test if num is a Gaussian prime number.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R700](#id57)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://oeis.org/wiki/Gaussian_primes](https://oeis.org/wiki/Gaussian_primes)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Returns the order of `a` modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : integer, n > 1\. a and n should be relatively prime'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**int** : the order of `a` modulo `n`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If \(n \le 1\) or \(\gcd(a, n) \neq 1\). If `a` or `n` is not an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The order of `a` modulo `n` is the smallest integer `k` such that \(a^k\) leaves
    a remainder of 1 with `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
  prefs: []
  type: TYPE_NORMAL
- en: We say that `a` is a primitive root of `n` when the order of `a` modulo `n`
    equals `totient(n)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `a` is a primitive root of `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : integer, `p` > 1\. `a` and `p` should be relatively prime'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If True, `a` is the primitive root of `p`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If \(p \le 1\) or \(\gcd(a, p) \neq 1\). If `a` or `p` is not an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is said to be the primitive root of `p` if \(\gcd(a, p) = 1\) and \(\phi(p)\)
    is the smallest positive number s.t.'
  prefs: []
  type: TYPE_NORMAL
- en: \(a^{\phi(p)} \equiv 1 \pmod{p}\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where \(\phi(p)\) is Euler’s totient function.
  prefs: []
  type: TYPE_NORMAL
- en: The primitive root of `p` exist only for \(p = 2, 4, q^e, 2q^e\) (`q` is an
    odd prime). Hence, if it is not such a `p`, it returns False. To determine the
    primitive root, we need to know the prime factorization of `q-1`. The hardness
    of the determination depends on this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`primitive_root`](#sympy.ntheory.residue_ntheory.primitive_root "sympy.ntheory.residue_ntheory.primitive_root")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Returns a primitive root of `p` or None.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : integer, p > 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**smallest** : if True the smallest primitive root is returned or None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'int | None :'
  prefs: []
  type: TYPE_NORMAL
- en: If the primitive root exists, return the primitive root of `p`. If not, return
    None.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If \(p \le 1\) or `p` is not an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For the definition of primitive root, see the explanation of `is_primitive_root`.
  prefs: []
  type: TYPE_NORMAL
- en: The primitive root of `p` exist only for \(p = 2, 4, q^e, 2q^e\) (`q` is an
    odd prime). Now, if we know the primitive root of `q`, we can calculate the primitive
    root of \(q^e\), and if we know the primitive root of \(q^e\), we can calculate
    the primitive root of \(2q^e\). When there is no need to find the smallest primitive
    root, this property can be used to obtain a fast primitive root. On the other
    hand, when we want the smallest primitive root, we naively determine whether it
    is a primitive root or not.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R701](#id58)]'
  prefs: []
  type: TYPE_NORMAL
- en: Stein “Elementary Number Theory” (2011), page 44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[[R702](#id59)]'
  prefs: []
  type: TYPE_NORMAL
- en: Hackman “Elementary Number Theory” (2009), Chapter C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of `x**2 = a mod p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**all_roots** : if True the list of roots is returned or None'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If there is no root it is returned None; else the returned root is less or equal
    to `p // 2`; in general is not the smallest one. It is returned `p // 2` only
    if it is the only root.
  prefs: []
  type: TYPE_NORMAL
- en: Use `all_roots` only when it is expected that all the roots fit in memory; otherwise
    use `sqrt_mod_iter`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over solutions to `x**2 = a mod p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**domain** : integer domain, `int`, `ZZ` or `Integer`'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
  prefs: []
  type: TYPE_NORMAL
- en: Same functionality, but you want a sorted list or only one solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Returns the list of quadratic residues.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Find the solutions to `x**n = a mod p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**all_roots** : if False returns the smallest root, else the list of roots'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'list[int] | int | None :'
  prefs: []
  type: TYPE_NORMAL
- en: 'solutions to `x**n = a mod p`. The table of the output type is:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| all_roots | has roots | Returns |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| True | Yes | list[int] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| True | No | [] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| False | Yes | int |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| False | No | None |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `a`, `n` or `p` is not integer. If `n` or `p` is not positive.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R703](#id60)]'
  prefs: []
  type: TYPE_NORMAL
- en: Hackman “Elementary Number Theory” (2009), page 76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `x**n == a (mod m)` has solutions.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R704](#id61)]'
  prefs: []
  type: TYPE_NORMAL
- en: Hackman “Elementary Number Theory” (2009), page 76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `a` (mod `p`) is in the set of squares mod `p`, i.e a % p in
    set([i**2 % p for i in range(p)]).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bool** : If True, `x**2 == a (mod p)` has solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `a`, `p` is not integer. If `p` is not positive.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, `pow(39, 2, 100)` would be 21.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: That is, for any integer `x`, `pow(x, 2, 120)` is not 21.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `p` is an odd prime, an iterative method is used to make the determination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol"),
    [`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Legendre symbol \((a / p)\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `legendre_symbol` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.legendre_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.legendre_symbol
    "sympy.functions.combinatorial.numbers.legendre_symbol") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: For an integer `a` and an odd prime `p`, the Legendre symbol is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\genfrac(){}{}{a}{p} = \begin{cases} 0 & \text{if } p \text{
    divides } a\\ 1 & \text{if } a \text{ is a quadratic residue modulo } p\\ -1 &
    \text{if } a \text{ is a quadratic nonresidue modulo } p \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : odd prime'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"),
    [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Jacobi symbol \((m / n)\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `jacobi_symbol` function is deprecated.
    Use [`sympy.functions.combinatorial.numbers.jacobi_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.jacobi_symbol
    "sympy.functions.combinatorial.numbers.jacobi_symbol") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For any integer `m` and any positive odd integer `n` the Jacobi symbol is defined
    as the product of the Legendre symbols corresponding to the prime factors of `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\genfrac(){}{}{m}{n} = \genfrac(){}{}{m}{p^{1}}^{\alpha_1} \genfrac(){}{}{m}{p^{2}}^{\alpha_2}
    ... \genfrac(){}{}{m}{p^{k}}^{\alpha_k} \text{ where } n = p_1^{\alpha_1} p_2^{\alpha_2}
    ... p_k^{\alpha_k}\]
  prefs: []
  type: TYPE_NORMAL
- en: Like the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n} = -1\)
    then `m` is a quadratic nonresidue modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: But, unlike the Legendre symbol, if the Jacobi symbol \(\genfrac(){}{}{m}{n}
    = 1\) then `m` may or may not be a quadratic residue modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : odd positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationship between the `jacobi_symbol` and `legendre_symbol` can be demonstrated
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"),
    [`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Mobius function maps natural number to {-1, 0, 1}
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.13: The `mobius` function is deprecated. Use [`sympy.functions.combinatorial.numbers.mobius`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.mobius
    "sympy.functions.combinatorial.numbers.mobius") instead. See its documentation
    for more information. See [Relocate symbolic functions from ntheory to functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)
    for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \(1\) if \(n = 1\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(0\) if \(n\) has a squared prime factor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \((-1)^k\) if \(n\) is a square-free positive integer with \(k\) number of prime
    factors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an important multiplicative function in number theory and combinatorics.
    It has applications in mathematical series, algebraic number theory and also physics
    (Fermion operator has very concrete realization with Mobius Function model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R705](#id62)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/M%C3%B6bius_function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R706](#id63)]'
  prefs: []
  type: TYPE_NORMAL
- en: Thomas Koshy “Elementary Number Theory with Applications”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Compute the discrete logarithm of `a` to the base `b` modulo `n`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recursive function to reduce the discrete logarithm problem in cyclic
    groups of composite order to the problem in cyclic groups of prime order.
  prefs: []
  type: TYPE_NORMAL
- en: 'It employs different algorithms depending on the problem (subgroup order size,
    prime order or not):'
  prefs: []
  type: TYPE_NORMAL
- en: Trial multiplication
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Baby-step giant-step
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Pollard’s Rho
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Index Calculus
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Pohlig-Hellman
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R707](#id64)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/DiscreteLogarithm.html](https://mathworld.wolfram.com/DiscreteLogarithm.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R708](#id65)]'
  prefs: []
  type: TYPE_NORMAL
- en: “Handbook of applied cryptography”, Menezes, A. J., Van, O. P. C., & Vanstone,
    S. A. (1997).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Find the solutions to \(a x^2 + b x + c \equiv 0 \pmod{n}\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '**b** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '**c** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : int'
  prefs: []
  type: TYPE_NORMAL
- en: A positive integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'list[int] :'
  prefs: []
  type: TYPE_NORMAL
- en: A sorted list of solutions. If no solution exists, `[]`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`polynomial_congruence`](#sympy.ntheory.residue_ntheory.polynomial_congruence
    "sympy.ntheory.residue_ntheory.polynomial_congruence")'
  prefs: []
  type: TYPE_NORMAL
- en: Solve the polynomial congruence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Find the solutions to a polynomial congruence equation modulo m.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : integer coefficient polynomial'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.galoistools.gf_csolve`](polys/internals.html#sympy.polys.galoistools.gf_csolve
    "sympy.polys.galoistools.gf_csolve")'
  prefs: []
  type: TYPE_NORMAL
- en: low level solving routine used by this routine
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Compute `binomial(n, m) % k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : an integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : an integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : a positive integer'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Returns `binomial(n, m) % k` using a generalization of Lucas’ Theorem for prime
    powers given by Granville [[R709]](#r709), in conjunction with the Chinese Remainder
    Theorem. The residue for each prime power is calculated in time O(log^2(n) + q^4*log(n)log(p)
    + q^4*p*log^3(p)).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R709] ([1](#id66),[2](#id67))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binomial coefficients modulo prime powers, Andrew Granville, Available: [https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Return the continued fraction representation of a Rational or quadratic irrational.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce"), [`continued_fraction_convergents`](#sympy.ntheory.continued_fraction.continued_fraction_convergents
    "sympy.ntheory.continued_fraction.continued_fraction_convergents")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Return an iterator over the convergents of a continued fraction (cf).
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter should be in either of the following to forms: - A list of partial
    quotients, possibly with the last element being a list of repeating partial quotients,
    such as might be returned by continued_fraction and continued_fraction_periodic.
    - An iterable returning successive partial quotients of the continued fraction,
    such as might be returned by continued_fraction_iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: In computing the convergents, the continued fraction need not be strictly in
    canonical form (all integers, all but the first positive). Rational and negative
    elements may be present in the expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction`](#sympy.ntheory.continued_fraction.continued_fraction
    "sympy.ntheory.continued_fraction.continued_fraction"), [`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Return continued fraction expansion of x as iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R710](#id68)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Continued_fraction](https://en.wikipedia.org/wiki/Continued_fraction)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Find the periodic continued fraction expansion of a quadratic irrational.
  prefs: []
  type: TYPE_NORMAL
- en: Compute the continued fraction expansion of a rational or a quadratic irrational
    number, i.e. \(\frac{p + s\sqrt{d}}{q}\), where \(p\), \(q \ne 0\) and \(d \ge
    0\) are integers.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the continued fraction representation (canonical form) as a list of
    integers, optionally ending (for quadratic irrationals) with list of integers
    representing the repeating digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : int'
  prefs: []
  type: TYPE_NORMAL
- en: the rational part of the number’s numerator
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**q** : int'
  prefs: []
  type: TYPE_NORMAL
- en: the denominator of the number
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**d** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: the irrational part (discriminator) of the number’s numerator
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**s** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: the coefficient of the irrational part
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Golden ratio has the simplest continued fraction expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'If the discriminator is zero or a perfect square then the number will be a
    rational number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator
    "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce
    "sympy.ntheory.continued_fraction.continued_fraction_reduce")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R711](#id69)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Periodic_continued_fraction](https://en.wikipedia.org/wiki/Periodic_continued_fraction)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R712](#id70)]'
  prefs: []
  type: TYPE_NORMAL
- en: K. Rosen. Elementary Number theory and its applications. Addison-Wesley, 3 Sub
    edition, pages 379-381, January 1992.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Reduce a continued fraction to a rational or quadratic irrational.
  prefs: []
  type: TYPE_NORMAL
- en: Compute the rational or quadratic irrational number from its terminating or
    periodic continued fraction expansion. The continued fraction expansion (cf) should
    be supplied as a terminating iterator supplying the terms of the expansion. For
    terminating continued fractions, this is equivalent to `list(continued_fraction_convergents(cf))[-1]`,
    only a little more efficient. If the expansion has a repeating part, a list of
    the repeating terms should be returned as the last element from the iterator.
    This is the format returned by continued_fraction_periodic.
  prefs: []
  type: TYPE_NORMAL
- en: For quadratic irrationals, returns the largest solution found, which is generally
    the one sought, if the fraction is in canonical form (all terms positive except
    possibly the first).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic
    "sympy.ntheory.continued_fraction.continued_fraction_periodic")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary whose keys are the digits of `n` in the given base, `b`,
    with keys indicating the digits appearing in the number and values indicating
    how many times that digit appeared.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'The digits returned are always represented in base-10 but the number itself
    can be entered in any format that is understood by Python; the base of the number
    can also be given if it is different than 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'The default dictionary will return a 0 for any digit that did not appear in
    the number. For example, which digits appear 7 times in `77!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`digits`](#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of the digits of `n` in base `b`. The first element in the list
    is `b` (or `-b` if `n` is negative).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The number whose digits are returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The base in which digits are computed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**digits: integer (or None for all digits)**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of digits to be returned (padded with zeros, if necessary).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number is negative, the negative sign will be placed on the base (which
    is the first element in the returned list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'Bases other than 10 (and greater than 1) can be selected with `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `digits` keyword if a certain number of digits is desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"),
    [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: return True if `n` is the same when read from left to right or right to left
    in the given base, `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument allows you to test numbers in other bases. For example,
    88 is palindromic in base-10 but not in base-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a number can be palindromic in base-8 but not in base-10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it might be palindromic in both bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Return the list of denominators of an Egyptian fraction expansion [[R713]](#r713)
    of the said rational \(r\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**r** : Rational or (p, q)'
  prefs: []
  type: TYPE_NORMAL
- en: a positive rational number, `p/q`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**algorithm** : { “Greedy”, “Graham Jewett”, “Takenouchi”, “Golomb” }, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Denotes the algorithm to be used (the default is “Greedy”).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently the following algorithms are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Greedy Algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also called the Fibonacci-Sylvester algorithm [[R714]](#r714). At each step,
    extract the largest unit fraction less than the target and replace the target
    with the remainder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It has some distinct properties:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given \(p/q\) in lowest terms, generates an expansion of maximum length \(p\).
    Even as the numerators get large, the number of terms is seldom more than a handful.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses minimal memory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The terms can blow up (standard examples of this are 5/121 and 31/311). The
    denominator is at most squared at each step (doubly-exponential growth) and typically
    exhibits singly-exponential growth.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Graham Jewett Algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The algorithm suggested by the result of Graham and Jewett. Note that this
    has a tendency to blow up: the length of the resulting expansion is always `2**(x/gcd(x,
    y)) - 1`. See [[R715]](#r715).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Takenouchi Algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm suggested by Takenouchi (1921). Differs from the Graham-Jewett
    algorithm only in the handling of duplicates. See [[R715]](#r715).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Golomb’s Algorithm
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method given by Golumb (1962), using modular arithmetic and inverses. It yields
    the same results as a method using continued fractions proposed by Bleicher (1972).
    See [[R716]](#r716).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the given rational is greater than or equal to 1, a greedy algorithm of summing
    the harmonic sequence 1/1 + 1/2 + 1/3 + … is used, taking all the unit fractions
    of this sequence until adding one more would be greater than the given number.
    This list of denominators is prefixed to the result from the requested algorithm
    used on the remainder. For example, if r is 8/3, using the Greedy algorithm, we
    get [1, 2, 3, 4, 5, 6, 7, 14, 420], where the beginning of the sequence, [1, 2,
    3, 4, 5, 6, 7] is part of the harmonic sequence summing to 363/140, leaving a
    remainder of 31/420, which yields [14, 420] by the Greedy algorithm. The result
    of egyptian_fraction(Rational(8, 3), “Golomb”) is [1, 2, 3, 4, 5, 6, 7, 14, 574,
    2788, 6460, 11590, 33062, 113820], and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.numbers.Rational`](core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R713] ([1](#id71),[2](#id76))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Egyptian_fraction](https://en.wikipedia.org/wiki/Egyptian_fraction)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R714] ([1](#id72),[2](#id77))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions](https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R715] ([1](#id73),[2](#id74),[3](#id78))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html](https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R716] ([1](#id75),[2](#id79))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf](https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Returns a string containing `prec` (default 14) digits starting at the nth digit
    of pi in hex. Counting of digits starts at 0 and the decimal is not counted, so
    for n = 0 the returned value starts with 3; n = 1 corresponds to the first digit
    past the decimal point (which in hex is 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : non-negative integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**prec** : non-negative integer. default = 14'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**str** : Returns a string containing `prec` digits'
  prefs: []
  type: TYPE_NORMAL
- en: starting at the nth digit of pi in hex. If `prec` = 0, returns empty string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `n` < 0 or `prec` < 0. Or `n` or `prec` is not an integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: These are consistent with the following results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R717](#id80)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.numberworld.org/digits/Pi/](http://www.numberworld.org/digits/Pi/)'
  prefs: []
  type: TYPE_NORMAL
- en: '## ECM function'
  prefs: []
  type: TYPE_NORMAL
- en: The \(ecm\) function is a subexponential factoring algorithm capable of factoring
    numbers of around ~35 digits comfortably within few seconds. The time complexity
    of \(ecm\) is dependent on the smallest proper factor of the number. So even if
    the number is really large but its factors are comparatively smaller then \(ecm\)
    can easily factor them. For example we take \(N\) with 15 digit factors \(15154262241479\),
    \(15423094826093\), \(799333555511111\), \(809709509409109\), \(888888877777777\),
    \(914148152112161\). Now N is a 87 digit number. \(ECM\) takes under around 47s
    to factorise this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Performs factorization using Lenstra’s Elliptic curve method.
  prefs: []
  type: TYPE_NORMAL
- en: This function repeatedly calls `_ecm_one_factor` to compute the factors of n.
    First all the small factors are taken out using trial division. Then `_ecm_one_factor`
    is used to compute one factor at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Number to be Factored'
  prefs: []
  type: TYPE_NORMAL
- en: '**B1** : Stage 1 Bound. Must be an even number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**B2** : Stage 2 Bound. Must be an even number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**max_curve** : Maximum number of curves generated'
  prefs: []
  type: TYPE_NORMAL
- en: '**seed** : Initialize pseudorandom generator'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE284]  ## QS function'
  prefs: []
  type: TYPE_NORMAL
- en: The \(qs\) function is a subexponential factoring algorithm, the fastest factoring
    algorithm for numbers within 100 digits. The time complexity of \(qs\) is dependent
    on the size of the number so it is used if the number contains large factors.
    Due to this while factoring numbers first \(ecm\) is used to get smaller factors
    of around ~15 digits then \(qs\) is used to get larger factors.
  prefs: []
  type: TYPE_NORMAL
- en: For factoring \(2709077133180915240135586837960864768806330782747\) which is
    a semi-prime number with two 25 digit factors. \(qs\) is able to factorize this
    in around 248s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Performs factorization using Self-Initializing Quadratic Sieve. In SIQS, let
    N be a number to be factored, and this N should not be a perfect power. If we
    find two integers such that `X**2 = Y**2 modN` and `X != +-Y modN`, then \(gcd(X
    + Y, N)\) will reveal a proper factor of N. In order to find these integers X
    and Y we try to find relations of form t**2 = u modN where u is a product of small
    primes. If we have enough of these relations then we can form `(t1*t2...ti)**2
    = u1*u2...ui modN` such that the right hand side is a square, thus we found a
    relation of `X**2 = Y**2 modN`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, several optimizations are done like using multiple polynomials for sieving,
    fast changing between polynomials and using partial relations. The use of partial
    relations can speeds up the factoring by 2 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**N** : Number to be Factored'
  prefs: []
  type: TYPE_NORMAL
- en: '**prime_bound** : upper bound for primes in the factor base'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** : Sieve Interval'
  prefs: []
  type: TYPE_NORMAL
- en: '**ERROR_TERM** : Error term for checking smoothness'
  prefs: []
  type: TYPE_NORMAL
- en: '**threshold** : Extra smooth relations for factorization'
  prefs: []
  type: TYPE_NORMAL
- en: '**seed** : generate pseudo prime numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R718](#id81)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf](https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R719](#id82)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve](https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
