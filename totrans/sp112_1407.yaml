- en: SciPy Core Developer Guide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/dev/core-dev/index.html](https://docs.scipy.org/doc/scipy-1.12.0/dev/core-dev/index.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Decision making process'
  prefs: []
  type: TYPE_NORMAL
- en: SciPy has a formal governance model, documented in [SciPy Project Governance](../governance.html#governance).
    The section below documents in an informal way what happens in practice for decision
    making about code and commit rights. The formal governance model is leading, the
    below is only provided for context.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any significant decisions on adding (or not adding) new features, breaking backwards
    compatibility or making other significant changes to the codebase should be made
    on the scipy-dev mailing list after a discussion (preferably with full consensus).
  prefs: []
  type: TYPE_NORMAL
- en: Any non-trivial change (where trivial means a typo, or a one-liner maintenance
    commit) has to go in through a pull request (PR). It has to be reviewed by another
    developer. In case review doesn’t happen quickly enough and it is important that
    the PR is merged quickly, the submitter of the PR should send a message to mailing
    list saying he/she intends to merge that PR without review at time X for reason
    Y unless someone reviews it before then.
  prefs: []
  type: TYPE_NORMAL
- en: Changes and new additions should be tested. Untested code is broken code.
  prefs: []
  type: TYPE_NORMAL
- en: Commit rights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Who gets commit rights is decided by the SciPy Steering Council; changes in
    commit rights will then be announced on the scipy-dev mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: '## Deciding on new features'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general decision rule to accept a proposed new feature has so far been
    conditional on:'
  prefs: []
  type: TYPE_NORMAL
- en: The method is applicable in many fields and “generally agreed” to be useful,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It fits the topic of the submodule, and does not require extensive support frameworks
    to operate,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation looks sound and unlikely to need much tweaking in the future
    (e.g., limited expected maintenance burden),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Someone wants to contribute it, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Someone wants to review it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last criterion is often a sticking point for proposed features. Code cannot
    be merged until it has been thoroughly reviewed, and there is always a backlog
    of maintenance tasks that compete for reviewers’ time. Ideally, contributors should
    line up a reviewer with suitable domain expertise before beginning work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s difficult to give hard rules on what “generally useful and generally
    agreed to work” means, it may help to weigh the following against each other:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the method used/useful in different domains in practice? How much domain-specific
    background knowledge is needed to use it properly?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the code already in the module. Is what you are adding an omission?
    Does it solve a problem that you’d expect the module be able to solve? Does it
    supplement an existing feature in a significant way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the equivalence class of similar methods / features usually expected.
    Among them, what would in principle be the minimal set so that there’s not a glaring
    omission in the offered features remaining? How much stuff would that be? Does
    including a representative one of them cover most use cases? Would it in principle
    sound reasonable to include everything from the minimal set in the module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is what you are adding something that is well understood in the literature?
    If not, how sure are you that it will turn out well? Does the method perform well
    compared to other similar ones?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the twice-a-year release cycle and backward-compatibility policy makes
    correcting things later on more difficult.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scopes of the submodules also vary, so it’s probably best to consider each
    as if it’s a separate project - “numerical evaluation of special functions” is
    relatively well-defined, but “commonly needed optimization algorithms” less so.
  prefs: []
  type: TYPE_NORMAL
- en: Development on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SciPy development largely takes place on GitHub; this section describes the
    expected way of working for issues, pull requests and managing the main `scipy`
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: '### Labels and Milestones'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each issue and pull request normally gets at least two labels: one for the
    topic or component (`scipy.stats`, `Documentation`, etc.), and one for the nature
    of the issue or pull request (`enhancement`, `maintenance`, `defect`, etc.). Other
    labels that may be added depending on the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`easy-fix`: for issues suitable to be tackled by new contributors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`needs-work`: for pull requests that have review comments that haven’t been
    addressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`needs-decision`: for issues or pull requests that need a decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`needs-champion`: for pull requests that were not finished by the original
    author, but are worth resurrecting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backport-candidate`: bugfixes that should be considered for backporting by
    the release manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A milestone is created for each version number for which a release is planned.
    Issues that need to be addressed and pull requests that need to be merged for
    a particular release should be set to the corresponding milestone. After a pull
    request is merged, its milestone (and that of the issue it closes) should be set
    to the next upcoming release - this makes it easy to get an overview of changes
    and to add a complete list of those to the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request review workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When reviewing pull requests, please make use of pull request workflow features,
    see [Using workflow features](../contributor/reviewing_prs.html#pull-request-workflow-features).
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with pull requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When merging contributions, a committer is responsible for ensuring that those
    meet the requirements outlined in [Contributing to SciPy](https://github.com/scipy/scipy/blob/main/doc/source/dev/hacking.rst).
    Also check that new features and backwards compatibility breaks were discussed
    on the scipy-dev mailing list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New code goes in via a pull request (PR).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge new code with the green button. In case of merge conflicts, ask the PR
    submitter to rebase (this may require providing some git instructions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backports and trivial additions to finish a PR (really trivial, like a typo
    or PEP8 fix) can be pushed directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For PRs that add new features or are in some way complex, wait at least a day
    or two before merging it. That way, others get a chance to comment before the
    code goes in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squashing commits or cleaning up commit messages of a PR that you consider too
    messy is OK. Make sure though to retain the original author name when doing this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the labels and milestone on a merged PR are set correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you want to reject a PR: if it’s very obvious you can just close it and
    explain why, if not obvious then it’s a good idea to first explain why you think
    the PR is not suitable for inclusion in SciPy and then let a second committer
    comment or close.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Backporting'
  prefs: []
  type: TYPE_NORMAL
- en: All pull requests (whether they contain enhancements, bug fixes or something
    else), should be made against main. Only bug fixes are candidates for backporting
    to a maintenance branch. The backport strategy for SciPy is to (a) only backport
    fixes that are important, and (b) to only backport when it’s reasonably sure that
    a new bugfix release on the relevant maintenance branch will be made. Typically,
    the developer who merges an important bugfix adds the `backport-candidate` label
    and pings the release manager, who decides on whether and when the backport is
    done. After the backport is completed, the `backport-candidate` label has to be
    removed again.
  prefs: []
  type: TYPE_NORMAL
- en: A good strategy for a backport pull request is to combine several main branch
    pull requests, to reduce the burden on continuous integration tests and to reduce
    the merge commit cluttering of maintenance branch history. It is generally best
    to have a single commit for each of the main branch pull requests represented
    in the backport pull request. This way, history is clear and can be reverted in
    a straightforward manner if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Release notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a PR gets merged, consider if the changes need to be mentioned in the
    release notes. What needs mentioning: new features, backwards incompatible changes,
    deprecations, and “other changes” (anything else noteworthy enough, see older
    release notes for the kinds of things worth mentioning).'
  prefs: []
  type: TYPE_NORMAL
- en: Release note entries are maintained on the wiki, (e.g. [https://github.com/scipy/scipy/wiki/Release-note-entries-for-SciPy-1.2.0](https://github.com/scipy/scipy/wiki/Release-note-entries-for-SciPy-1.2.0)).
    The release manager will gather content from there and integrate it into the html
    docs. We use this mechanism to avoid merge conflicts that would happen if every
    PR touched the same file under `doc/release/` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes can be monitored ([Atom feed](https://github.com/scipy/scipy/wiki.atom))
    and pulled (the wiki is a git repo: `https://github.com/scipy/scipy.wiki.git`).'
  prefs: []
  type: TYPE_NORMAL
- en: Other
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*PR status page:* When new commits get added to a pull request, GitHub doesn’t
    send out any notifications. The `needs-work` label may not be justified anymore
    though. [This page](https://pav.iki.fi/scipy-needs-work/) gives an overview of
    PRs that were updated, need review, need a decision, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cross-referencing:* Cross-referencing issues and pull requests on GitHub is
    often useful. GitHub allows doing that by using `gh-xxxx` or `#xxxx` with `xxxx`
    the issue/PR number. The `gh-xxxx` format is strongly preferred, because it’s
    clear that that is a GitHub link. Older issues contain `#xxxx` which is about
    Trac (what we used pre-GitHub) tickets.'
  prefs: []
  type: TYPE_NORMAL
- en: '*PR naming convention:* Pull requests, issues and commit messages usually start
    with a three-letter abbreviation like `ENH:` or `BUG:`. This is useful to quickly
    see what the nature of the commit/PR/issue is. For the full list of abbreviations,
    see [writing the commit message](https://numpy.org/devdocs/dev/development_workflow.html#writing-the-commit-message
    "(in NumPy v2.0.dev0)").'
  prefs: []
  type: TYPE_NORMAL
- en: '## Licensing'
  prefs: []
  type: TYPE_NORMAL
- en: SciPy is distributed under the [modified (3-clause) BSD license](https://opensource.org/licenses/BSD-3-Clause).
    All code, documentation and other files added to SciPy by contributors is licensed
    under this license, unless another license is explicitly specified in the source
    code. Contributors keep the copyright for code they wrote and submit for inclusion
    to SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: Other licenses that are compatible with the modified BSD license that SciPy
    uses are 2-clause BSD, MIT and PSF. Incompatible licenses are GPL, Apache and
    custom licenses that require attribution/citation or prohibit use for commercial
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: PRs are often submitted with content copied or derived from unlicensed code
    or code from a default license that is not compatible with SciPy’s license. For
    instance, code published on StackOverflow is covered by a CC-BY-SA license, which
    is not compatible due to the share-alike clause. These contributions cannot be
    accepted for inclusion in SciPy unless the original code author is willing to
    (re)license his/her code under the modified BSD (or compatible) license. If the
    original author agrees, add a comment saying so to the source files and forward
    the relevant communication to the scipy-dev mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common occurrence is for code to be translated or derived from code
    in R, Octave (both GPL-licensed) or a commercial application. Such code also cannot
    be included in SciPy. Simply implementing functionality with the same API as found
    in R/Octave/… is fine though, as long as the author doesn’t look at the original
    incompatibly-licensed source code.  ## Version numbering'
  prefs: []
  type: TYPE_NORMAL
- en: 'SciPy version numbering complies to [PEP 440](https://www.python.org/dev/peps/pep-0440).
    Released final versions, which are the only versions appearing on [PyPI](https://pypi.org/),
    are numbered `MAJOR.MINOR.MICRO` where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAJOR` is an integer indicating the major version. It changes very rarely;
    a change in `MAJOR` indicates large (possibly backwards-incompatible) changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MINOR` is an integer indicating the minor version. Minor versions are typically
    released twice a year and can contain new features, deprecations and bug-fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MICRO` is an integer indicating a bug-fix version. Bug-fix versions are released
    when needed, typically one or two per minor version. They cannot contain new features
    or deprecations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Released alpha, beta and rc (release candidate) versions are numbered like final
    versions but with postfixes `a#`, `b#` and `rc#` respectively, with `#` an integer.
    Development versions are postfixed with `.dev0+<git-commit-hash>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of valid SciPy version strings are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An installed SciPy version contains these version identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]  ## Deprecations'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various reasons for wanting to remove existing functionality: it’s
    buggy, the API isn’t understandable, it’s superseded by functionality with better
    performance, it needs to be moved to another SciPy submodule, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general it’s not a good idea to remove something without warning users about
    that removal first. Therefore this is what should be done before removing something
    from the public API:'
  prefs: []
  type: TYPE_NORMAL
- en: Propose to deprecate the functionality on the scipy-dev mailing list and get
    agreement that that’s OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `DeprecationWarning` for it, which states that the functionality was deprecated,
    and in which release. For Cython APIs, see [Deprecating public Cython APIs](../contributor/public_cython_api.html#deprecating-public-cython-api)
    for the practical steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mention the deprecation in the release notes for that release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait till at least 6 months after the release date of the release that introduced
    the `DeprecationWarning` before removing the functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mention the removal of the functionality in the release notes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 6 months waiting period in practice usually means waiting two releases.
    When introducing the warning, also ensure that those warnings are filtered out
    when running the test suite so they don’t pollute the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible that there is reason to want to ignore this deprecation policy
    for a particular deprecation; this can always be discussed on the scipy-dev mailing
    list.  ## Distributing'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing Python packages is nontrivial - especially for a package with complex
    build requirements like SciPy - and subject to change. For an up-to-date overview
    of recommended tools and techniques, see the [Python Packaging User Guide](https://packaging.python.org).
    This document discusses some of the main issues and considerations for SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dependencies are things that a user has to install in order to use (or build/test)
    a package. They usually cause trouble, especially if they’re not optional. SciPy
    tries to keep its dependencies to a minimum; currently they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unconditional run-time dependencies:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Numpy](https://numpy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conditional run-time dependencies:*'
  prefs: []
  type: TYPE_NORMAL
- en: pytest (to run the test suite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asv](https://asv.readthedocs.org) (to run the benchmarks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[matplotlib](https://matplotlib.org) (for some functions that can produce plots)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pooch](https://www.fatiando.org/pooch/latest/) (for the scipy.datasets module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pillow](https://pillow.readthedocs.org) (for image loading/saving)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[scikits.umfpack](https://pypi.org/project/scikit-umfpack) (optionally used
    in `sparse.linalg`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[mpmath](http://mpmath.org) (for more extended tests in `special`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pydata/sparse (compatibility support in `scipy.sparse`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[threadpoolctl](https://github.com/joblib/threadpoolctl) (to control BLAS/LAPACK
    threading in test suite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hypothesis](https://hypothesis.readthedocs.io/en/latest/index.html) (to run
    certain unit tests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unconditional build-time dependencies:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Numpy](https://numpy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BLAS and LAPACK implementation (reference BLAS/LAPACK, ATLAS, OpenBLAS, MKL
    are all known to work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cython](https://cython.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[setuptools](https://github.com/pypa/setuptools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pybind11](https://github.com/pybind/pybind11)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conditional build-time dependencies:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[wheel](https://wheel.readthedocs.io/) (`python setup.py bdist_wheel`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx](http://www.sphinx-doc.org/) (docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyData Sphinx theme](https://pydata-sphinx-theme.readthedocs.io/en/latest/)
    (docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx-Design](https://sphinx-design.readthedocs.io) (docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[matplotlib](https://matplotlib.org) (docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MyST-NB](https://myst-nb.readthedocs.io/) (docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore of course one needs C, C++ and Fortran compilers to build SciPy,
    but those we don’t consider to be dependencies and are therefore not discussed
    here. For details, see [https://scipy.github.io/devdocs/dev/contributor/building.html](https://scipy.github.io/devdocs/dev/contributor/building.html).
  prefs: []
  type: TYPE_NORMAL
- en: When a package provides useful functionality and it’s proposed as a new dependency,
    consider also if it makes sense to vendor (i.e. ship a copy of it with scipy)
    the package instead. For example, [decorator](https://github.com/micheles/decorator)
    is vendored in `scipy._lib`.
  prefs: []
  type: TYPE_NORMAL
- en: The only dependency that is reported to [pip](https://pip.pypa.io/en/stable/)
    is [Numpy](https://numpy.org), see `install_requires` in SciPy’s main `setup.py`.
    The other dependencies aren’t needed for SciPy to function correctly
  prefs: []
  type: TYPE_NORMAL
- en: Issues with dependency handling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are some issues with how Python packaging tools handle dependencies reported
    by projects. Because SciPy gets regular bug reports about this, we go in a bit
    of detail here.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy only reports its dependency on NumPy via `install_requires` if NumPy isn’t
    installed at all on a system, or when building wheels with `bdist_wheel`. SciPy
    no longer uses `setup_requires` (which in the past invoked `easy_install`); build
    dependencies are now handled only via `pyproject.toml`. `pyproject.toml` relies
    on PEP 517; `pip` has `--no-use-pep517` and `--no-build-isolation` flags that
    may ignore `pyproject.toml` or treat it differently - if users use those flags,
    they are responsible for installing the correct build dependencies themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Version ranges for NumPy and other dependencies'
  prefs: []
  type: TYPE_NORMAL
- en: For dependencies it’s important to set lower and upper bounds on their versions.
    For *build-time* dependencies, they are specified in `pyproject.toml` and the
    versions will *only* apply to the SciPy build itself. It’s fine to specify either
    a range or a specific version for a dependency like `wheel` or `setuptools`. For
    NumPy we have to worry about ABI compatibility too, hence we specify the version
    with `==` to the lowest supported version (because NumPy’s ABI is backward but
    not forward compatible).
  prefs: []
  type: TYPE_NORMAL
- en: 'For *run-time dependencies* (currently only `numpy`), we specify the range
    of versions in `pyproject.toml` and in `install_requires` in `setup.py`. Getting
    the upper bound right is slightly tricky. If we don’t set any bound, a too-new
    version will be pulled in a few years down the line, and NumPy may have deprecated
    and removed some API that SciPy depended on by then. On the other hand if we set
    the upper bound to the newest already-released version, then as soon as a new
    NumPy version is released there will be no matching SciPy version that works with
    it. Given that NumPy and SciPy both release in a 6-monthly cadence and that features
    that get deprecated in NumPy should stay around for another two releases, we specify
    the upper bound as `<1.xx+3.0` (where `xx` is the minor version of the latest
    already-released NumPy.  ### Supported Python and NumPy versions'
  prefs: []
  type: TYPE_NORMAL
- en: The [Python](https://www.python.org) versions that SciPy supports are listed
    in the list of PyPI classifiers in `setup.py`, and mentioned in the release notes
    for each release. All newly released Python versions will be supported as soon
    as possible. For the general policy on dropping support for a Python or NumPy
    version, see [NEP 29](https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29
    "(in NumPy Enhancement Proposals)"). The final decision on dropping support is
    always taken on the scipy-dev mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lowest supported [Numpy](https://numpy.org) version for a SciPy version
    is mentioned in the release notes and is encoded in `pyproject.toml`, `scipy/__init__.py`
    and the `install_requires` field of `setup.py`. Typically the latest SciPy release
    supports ~5-7 minor versions of NumPy: up to 2.5 years’ old NumPy versions, (given
    that the frequency of NumPy releases is about 2x/year at the time of writing)
    plus two versions into the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Supported versions of optional dependencies and compilers is documented in [Toolchain
    Roadmap](../toolchain.html#toolchain-roadmap). Note that not all versions of optional
    dependencies that are supported are tested well or at all by SciPy’s Continuous
    Integration setup. Issues regarding this are dealt with as they come up in the
    issue tracker or mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: Building binary installers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This section is only about building SciPy binary installers to *distribute*.
    For info on building SciPy on the same machine as where it will be used, see [this
    scipy.org page](https://scipy.github.io/devdocs/dev/contributor/building.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of things to take into consideration when building binaries
    and distributing them on PyPI or elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '**General**'
  prefs: []
  type: TYPE_NORMAL
- en: A binary is specific for a single Python version (because different Python versions
    aren’t ABI-compatible, at least up to Python 3.4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build against the lowest NumPy version that you need to support, then it will
    work for all NumPy versions with the same major version number (NumPy does maintain
    backwards ABI compatibility).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest available toolchain for building portable SciPy binaries is our
    `cibuildwheel` infrastructure for common platforms, with details available in
    our CI infrastructure code and available via the `cibuildwheel` command on Windows,
    Linux, and MacOS, albeit with some extra external dependencies required in some
    cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: For 64-bit Windows installers built with a free toolchain, use the method documented
    at [https://github.com/numpy/numpy/wiki/Mingw-static-toolchain](https://github.com/numpy/numpy/wiki/Mingw-static-toolchain).
    That method will likely be used for SciPy itself once it’s clear that the maintenance
    of that toolchain is sustainable long-term. See the [MingwPy](https://mingwpy.github.io)
    project and [this thread](https://mail.python.org/pipermail/numpy-discussion/2015-October/074056.html)
    for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other way to produce 64-bit Windows installers is with `icc`, `ifort` plus
    `MKL` (or `MSVC` instead of `icc`). For Intel toolchain instructions see [this
    article](https://software.intel.com/en-us/articles/numpyscipy-with-intel-mkl)
    and for (partial) MSVC instructions see [this wiki page](https://github.com/numpy/numpy/wiki/Building-with-MSVC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Older SciPy releases contained a .exe “superpack” installer. Those contain 3
    complete builds (no SSE, SSE2, SSE3), and were built with [https://github.com/numpy/numpy-vendor](https://github.com/numpy/numpy-vendor).
    That build setup is known to not work well anymore and is no longer supported.
    It used g77 instead of gfortran, due to complex DLL distribution issues (see [gh-2829](https://github.com/scipy/scipy/issues/2829)).
    Because the toolchain is no longer supported, g77 support isn’t needed anymore
    and SciPy can now include Fortran 90/95 code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: PyPI-compatible Linux wheels can be produced via the [manylinux](https://github.com/pypa/manylinux/)
    project, which is used under the hood by our `cibuildwheel` infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other Linux build-setups result in PyPI incompatible wheels, which would need
    to be distributed via custom channels, e.g. in a [Wheelhouse](https://pypi.org/project/Wheelhouse),
    see at the [wheel](https://wheel.readthedocs.io/) and [Wheelhouse](https://pypi.org/project/Wheelhouse)
    docs.  ## Making a SciPy release'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the highest level, this is what the release manager does to release a new
    SciPy version:'
  prefs: []
  type: TYPE_NORMAL
- en: Propose a release schedule on the scipy-dev mailing list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the maintenance branch for the release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag the release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build all release artifacts (sources, installers, docs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the release artifacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Announce the release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Port relevant changes to release notes and build scripts to main.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this guide we attempt to describe in detail how to perform each of the above
    steps. In addition to those steps, which have to be performed by the release manager,
    here are descriptions of release-related activities and conventions of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Backporting](#backporting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Labels and Milestones](#labels-and-milestones)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Version numbering](#version-numbering)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Supported Python and NumPy versions](#supported-py-numpy-versions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deprecations](#deprecations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proposing a release schedule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical release cycle looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the maintenance branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release a beta version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release a “release candidate” (RC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If needed, release one or more new RCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release the final version once there are no issues with the last release candidate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s usually at least one week between each of the above steps. Experience
    shows that a cycle takes between 4 and 8 weeks for a new minor version. Bug-fix
    versions don’t need a beta or RC, and can be done much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally the final release is identical to the last RC, however there may be
    minor difference - it’s up to the release manager to judge the risk of that. Typically,
    if compiled code or complex pure Python code changes then a new RC is needed,
    while a simple bug-fix that’s backported from main doesn’t require a new RC.
  prefs: []
  type: TYPE_NORMAL
- en: To propose a schedule, send a list with estimated dates for branching and beta/rc/final
    releases to scipy-dev. In the same email, ask everyone to check if there are important
    issues/PRs that need to be included and aren’t tagged with the Milestone for the
    release or the “backport-candidate” label.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the maintenance branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before branching, ensure that the release notes are updated as far as possible.
    Include the output of `tools/gh_lists.py` and `tools/authors.py` in the release
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance branches are named `maintenance/<major>.<minor>.x` (e.g. 0.19.x).
    To create one, simply push a branch with the correct name to the scipy repo. Immediately
    after, push a commit where you increment the version number on the main branch
    and add release notes for that new version. Send an email to scipy-dev to let
    people know that you’ve done this.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the version switcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The version switcher dropdown needs to be updated with the new release information.
  prefs: []
  type: TYPE_NORMAL
- en: '`doc/source/_static/version_switcher.json`: add the new release as well as
    the new development version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating upper bounds of dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In main we do not set upper bounds, because we want to test new releases or
    development versions of dependencies there. In a maintenance branch however, the
    goal is to be able to create releases that stay working for years. Hence correct
    upper bounds must be set. The following places must be updated after creating
    a maintenance branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pyproject.toml`: all build-time dependencies, as well as supported Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and NumPy versions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`setup.py`: supported Python and NumPy versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scipy/__init__.py`: for NumPy version check'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each file has comments describing how to set the correct upper bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging a release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First ensure that you have set up GPG correctly. See [https://github.com/scipy/scipy/issues/4919](https://github.com/scipy/scipy/issues/4919)
    for a discussion of signing release tags, and [https://keyring.debian.org/creating-key.html](https://keyring.debian.org/creating-key.html)
    for instructions on creating a GPG key if you do not have one. Note that on some
    platforms it may be more suitable to use `gpg2` instead of `gpg` so that passwords
    may be stored by `gpg-agent` as discussed in [https://github.com/scipy/scipy/issues/10189](https://github.com/scipy/scipy/issues/10189).
    When preparing a release remotely, it may be necessary to set `pinentry-mode loopback`
    in `~/.gnupg/gpg-agent.conf` because use of `gpg2` will otherwise proceed via
    an inaccessible graphical password prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your key more readily identifiable as you, consider sending your key
    to public key servers, with a command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Check that all relevant commits are in the branch. In particular, check issues
    and PRs under the Milestone for the release ([https://github.com/scipy/scipy/milestones](https://github.com/scipy/scipy/milestones)),
    PRs labeled “backport-candidate”, and that the release notes are up-to-date and
    included in the html docs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then edit `meson.build` and `tools/version_utils.py` to get the correct version
    number (set `version:` in the former, and `ISRELEASED = True` in the latter) and
    commit it with a message like `REL: set version to <version-number>`. Don’t push
    this commit to the SciPy repo yet.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally tag the release locally with `git tag -s <v1.x.y>` (the `-s` ensures
    the tag is signed). If `gpg2` is preferred, then `git config --global gpg.program
    gpg2` may be appropriate. Continue with building release artifacts (next section).
    Only push the release commit to the scipy repo once you have built the sdists
    and docs successfully. Then continue with building wheels. Only push the release
    tag to the repo once all wheels have been built successfully on TravisCI and Appveyor
    (if it fails, you have to move the tag otherwise - which is bad practice). Finally,
    after pushing the tag, also push a second commit which increments the version
    number and appends `.dev0` for `version:` and sets `ISRELEASED` to False again.
    This also applies with new release candidates, and for removing the `rc` affix
    when switching from release candidate to release proper.
  prefs: []
  type: TYPE_NORMAL
- en: Building release artifacts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a complete list of artifacts created for a release:'
  prefs: []
  type: TYPE_NORMAL
- en: sdist (`scipy-x.y.y.tar.gz`, for both PyPI and GitHub Releases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary wheels for Windows, Linux and macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation (html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `README.txt` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Changelog` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `sdist` is generated by running `python -m build --sdist` (note: we still
    need to move this into a CI job!), and the Changelog and README are built by running
    `python dev.py notes` (with tags, see `python dev.py notes --help`) in the repo
    root, and end up in `REPO_ROOT/release/`. Do this after you’ve created the signed
    tag locally. If this completes without issues, push the release commit (not the
    tag, see section above) to the scipy repo.'
  prefs: []
  type: TYPE_NORMAL
- en: To build wheels, push a commit containing the text `[wheel build]` to the branch
    used for the current release. This triggers `cibuildwheel` builds for all needed
    Python versions and platforms. The appropriate version pins for NumPy and other
    dependencies should have been updated in `pyproject.toml` just after branching.
    If the wheel builds reveal issues that need to be fixed with backports on the
    maintenance branch, you may remove the local tags (for example `git tag -d v1.2.0rc1`)
    and restart with tagging above on the new candidate commit.
  prefs: []
  type: TYPE_NORMAL
- en: The `cibuildwheel` infrastructure runs the tests from the built wheels and if
    they pass, uploads the wheels to [https://anaconda.org/multibuild-wheels-staging/scipy](https://anaconda.org/multibuild-wheels-staging/scipy).
  prefs: []
  type: TYPE_NORMAL
- en: 'From there you can download them for uploading to PyPI. This can be done in
    an automated fashion using `tools/download-wheels.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After this, we want to regenerate the README file, in order to have the MD5
    and SHA256 checksums of the just downloaded wheels in it. Run `python dev.py notes`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading release artifacts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a release there are currently five places on the web to upload things to:'
  prefs: []
  type: TYPE_NORMAL
- en: PyPI (sdist, wheels)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Releases (sdist, release notes, Changelog)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scipy.org (an announcement of the release)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: docs.scipy.org (html docs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PyPI:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload first the wheels and then the sdist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Github Releases:**'
  prefs: []
  type: TYPE_NORMAL
- en: Use GUI on [https://github.com/scipy/scipy/releases](https://github.com/scipy/scipy/releases)
    to create release and upload all release artifacts. At this stage, it is appropriate
    to push the tag and associate the new release (candidate) with this tag in the
    GUI. For example, `git push upstream v1.2.0rc1`, where `upstream` represents `scipy/scipy`.
    It is useful to check a previous release to determine exactly which artifacts
    should be included in the GUI upload process. Also, note that the release notes
    are not automatically populated into the release description on GitHub, and some
    manual reformatting to markdown can be quite helpful to match the formatting of
    previous releases on the site. We generally do not include Issue and Pull Request
    lists in these GUI descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '**scipy.org:**'
  prefs: []
  type: TYPE_NORMAL
- en: Sources for the site are in [https://github.com/scipy/scipy.org](https://github.com/scipy/scipy.org).
    Update the News section in `content/en/news.md` via a PR. This is only for proper
    releases, not release candidates.
  prefs: []
  type: TYPE_NORMAL
- en: '**docs.scipy.org:**'
  prefs: []
  type: TYPE_NORMAL
- en: First build the scipy docs, by running `make dist` in `scipy/doc/`. Verify that
    they look OK, then upload them to the doc server with `make upload USERNAME=rgommers
    RELEASE=0.19.0`. Note that SSH access to the doc server is needed; ask @pv (server
    admin), @tylerjereddy or @rgommers (can upload) if you don’t have that.
  prefs: []
  type: TYPE_NORMAL
- en: The sources for the website itself are maintained in [https://github.com/scipy/docs.scipy.org/](https://github.com/scipy/docs.scipy.org/).
    Add the new SciPy version in the table of releases in `index.rst`. Push that commit,
    then do `make upload USERNAME=yourusername`. This is only for proper releases,
    not release candidates.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Send an email announcing the release to the following mailing lists:'
  prefs: []
  type: TYPE_NORMAL
- en: scipy-dev
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: numpy-discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: python-announce (not for beta/rc releases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For beta and rc versions, ask people in the email to test (run the scipy tests
    and test against their own code) and report issues on Github or scipy-dev.
  prefs: []
  type: TYPE_NORMAL
- en: After the final release is done, port relevant changes to release notes, build
    scripts, author name mapping in `tools/authors.py` and any other changes that
    were only made on the maintenance branch to main.
  prefs: []
  type: TYPE_NORMAL
