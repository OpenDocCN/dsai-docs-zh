- en: numpy.in1d
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.in1d.html](https://numpy.org/doc/1.26/reference/generated/numpy.in1d.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Test whether each element of a 1-D array is also present in a second array.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a boolean array the same length as *ar1* that is True where an element
    of *ar1* is in *ar2* and False otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using [`isin`](numpy.isin.html#numpy.isin "numpy.isin") instead
    of [`in1d`](#numpy.in1d "numpy.in1d") for new code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ar1**(M,) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input array.
  prefs: []
  type: TYPE_NORMAL
- en: '**ar2**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The values against which to test each value of *ar1*.
  prefs: []
  type: TYPE_NORMAL
- en: '**assume_unique**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the input arrays are both assumed to be unique, which can speed up
    the calculation. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: '**invert**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the values in the returned array are inverted (that is, False where
    an element of *ar1* is in *ar2* and True otherwise). Default is False. `np.in1d(a,
    b, invert=True)` is equivalent to (but is faster than) `np.invert(in1d(a, b))`.
  prefs: []
  type: TYPE_NORMAL
- en: '**kind**{None, ‘sort’, ‘table’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm to use. This will not affect the final result, but will affect
    the speed and memory use. The default, None, will select automatically based on
    memory considerations.
  prefs: []
  type: TYPE_NORMAL
- en: If ‘sort’, will use a mergesort-based approach. This will have a memory usage
    of roughly 6 times the sum of the sizes of *ar1* and *ar2*, not accounting for
    size of dtypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If ‘table’, will use a lookup table approach similar to a counting sort. This
    is only available for boolean and integer arrays. This will have a memory usage
    of the size of *ar1* plus the max-min value of *ar2*. *assume_unique* has no effect
    when the ‘table’ option is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If None, will automatically choose ‘table’ if the required memory allocation
    is less than or equal to 6 times the sum of the sizes of *ar1* and *ar2*, otherwise
    will use ‘sort’. This is done to not use a large amount of memory by default,
    even though ‘table’ may be faster in most cases. If ‘table’ is chosen, *assume_unique*
    will have no effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**in1d**(M,) ndarray, bool'
  prefs: []
  type: TYPE_NORMAL
- en: The values *ar1[in1d]* are in *ar2*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`isin`](numpy.isin.html#numpy.isin "numpy.isin")'
  prefs: []
  type: TYPE_NORMAL
- en: Version of this function that preserves the shape of ar1.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.lib.arraysetops`](numpy.lib.arraysetops.html#module-numpy.lib.arraysetops
    "numpy.lib.arraysetops")'
  prefs: []
  type: TYPE_NORMAL
- en: Module with a number of other functions for performing set operations on arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '[`in1d`](#numpy.in1d "numpy.in1d") can be considered as an element-wise function
    version of the python keyword *in*, for 1-D sequences. `in1d(a, b)` is roughly
    equivalent to `np.array([item in b for item in a])`. However, this idea fails
    if *ar2* is a set, or similar (non-sequence) container: As `ar2` is converted
    to an array, in those cases `asarray(ar2)` is an object array rather than the
    expected array of contained values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `kind=''table''` tends to be faster than *kind=’sort’* if the following
    relationship is true: `log10(len(ar2)) > (log10(max(ar2)-min(ar2)) - 2.27) / 0.927`,
    but may use greater memory. The default value for *kind* will be automatically
    selected based only on memory usage, so one may manually set `kind=''table''`
    if memory constraints can be relaxed.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
