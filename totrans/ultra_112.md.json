["```py\n    `pip  install  ros_numpy` \n    ```", "```py\n    `pip  install  ultralytics` \n    ```", "```py\n`import time  import rospy  from ultralytics import YOLO  detection_model = YOLO(\"yolov8m.pt\") segmentation_model = YOLO(\"yolov8m-seg.pt\") rospy.init_node(\"ultralytics\") time.sleep(1)` \n```", "```py\n`from sensor_msgs.msg import Image  det_image_pub = rospy.Publisher(\"/ultralytics/detection/image\", Image, queue_size=5) seg_image_pub = rospy.Publisher(\"/ultralytics/segmentation/image\", Image, queue_size=5)` \n```", "```py\n`import ros_numpy   def callback(data):   \"\"\"Callback function to process image and publish annotated images.\"\"\"     array = ros_numpy.numpify(data)     if det_image_pub.get_num_connections():         det_result = detection_model(array)         det_annotated = det_result[0].plot(show=False)         det_image_pub.publish(ros_numpy.msgify(Image, det_annotated, encoding=\"rgb8\"))      if seg_image_pub.get_num_connections():         seg_result = segmentation_model(array)         seg_annotated = seg_result[0].plot(show=False)         seg_image_pub.publish(ros_numpy.msgify(Image, seg_annotated, encoding=\"rgb8\"))   rospy.Subscriber(\"/camera/color/image_raw\", Image, callback)  while True:     rospy.spin()` \n```", "```py\n`import time  import ros_numpy import rospy from sensor_msgs.msg import Image  from ultralytics import YOLO  detection_model = YOLO(\"yolov8m.pt\") segmentation_model = YOLO(\"yolov8m-seg.pt\") rospy.init_node(\"ultralytics\") time.sleep(1)  det_image_pub = rospy.Publisher(\"/ultralytics/detection/image\", Image, queue_size=5) seg_image_pub = rospy.Publisher(\"/ultralytics/segmentation/image\", Image, queue_size=5)   def callback(data):   \"\"\"Callback function to process image and publish annotated images.\"\"\"     array = ros_numpy.numpify(data)     if det_image_pub.get_num_connections():         det_result = detection_model(array)         det_annotated = det_result[0].plot(show=False)         det_image_pub.publish(ros_numpy.msgify(Image, det_annotated, encoding=\"rgb8\"))      if seg_image_pub.get_num_connections():         seg_result = segmentation_model(array)         seg_annotated = seg_result[0].plot(show=False)         seg_image_pub.publish(ros_numpy.msgify(Image, seg_annotated, encoding=\"rgb8\"))   rospy.Subscriber(\"/camera/color/image_raw\", Image, callback)  while True:     rospy.spin()` \n```", "```py\n`import time  import ros_numpy import rospy from sensor_msgs.msg import Image from std_msgs.msg import String  from ultralytics import YOLO  detection_model = YOLO(\"yolov8m.pt\") rospy.init_node(\"ultralytics\") time.sleep(1) classes_pub = rospy.Publisher(\"/ultralytics/detection/classes\", String, queue_size=5)   def callback(data):   \"\"\"Callback function to process image and publish detected classes.\"\"\"     array = ros_numpy.numpify(data)     if classes_pub.get_num_connections():         det_result = detection_model(array)         classes = det_result[0].boxes.cls.cpu().numpy().astype(int)         names = [det_result[0].names[i] for i in classes]         classes_pub.publish(String(data=str(names)))   rospy.Subscriber(\"/camera/color/image_raw\", Image, callback) while True:     rospy.spin()` \n```", "```py\n`import time  import rospy from std_msgs.msg import String  from ultralytics import YOLO  rospy.init_node(\"ultralytics\") time.sleep(1)  segmentation_model = YOLO(\"yolov8m-seg.pt\")  classes_pub = rospy.Publisher(\"/ultralytics/detection/distance\", String, queue_size=5)` \n```", "```py\n`import numpy as np import ros_numpy from sensor_msgs.msg import Image   def callback(data):   \"\"\"Callback function to process depth image and RGB image.\"\"\"     image = rospy.wait_for_message(\"/camera/color/image_raw\", Image)     image = ros_numpy.numpify(image)     depth = ros_numpy.numpify(data)     result = segmentation_model(image)      for index, cls in enumerate(result[0].boxes.cls):         class_index = int(cls.cpu().numpy())         name = result[0].names[class_index]         mask = result[0].masks.data.cpu().numpy()[index, :, :].astype(int)         obj = depth[mask == 1]         obj = obj[~np.isnan(obj)]         avg_distance = np.mean(obj) if len(obj) else np.inf      classes_pub.publish(String(data=str(all_objects)))   rospy.Subscriber(\"/camera/depth/image_raw\", Image, callback)  while True:     rospy.spin()` \n```", "```py\n`import time  import numpy as np import ros_numpy import rospy from sensor_msgs.msg import Image from std_msgs.msg import String  from ultralytics import YOLO  rospy.init_node(\"ultralytics\") time.sleep(1)  segmentation_model = YOLO(\"yolov8m-seg.pt\")  classes_pub = rospy.Publisher(\"/ultralytics/detection/distance\", String, queue_size=5)   def callback(data):   \"\"\"Callback function to process depth image and RGB image.\"\"\"     image = rospy.wait_for_message(\"/camera/color/image_raw\", Image)     image = ros_numpy.numpify(image)     depth = ros_numpy.numpify(data)     result = segmentation_model(image)      for index, cls in enumerate(result[0].boxes.cls):         class_index = int(cls.cpu().numpy())         name = result[0].names[class_index]         mask = result[0].masks.data.cpu().numpy()[index, :, :].astype(int)         obj = depth[mask == 1]         obj = obj[~np.isnan(obj)]         avg_distance = np.mean(obj) if len(obj) else np.inf      classes_pub.publish(String(data=str(all_objects)))   rospy.Subscriber(\"/camera/depth/image_raw\", Image, callback)  while True:     rospy.spin()` \n```", "```py\n`import time  import rospy  from ultralytics import YOLO  rospy.init_node(\"ultralytics\") time.sleep(1) segmentation_model = YOLO(\"yolov8m-seg.pt\")` \n```", "```py\n`import numpy as np import ros_numpy   def pointcloud2_to_array(pointcloud2: PointCloud2) -> tuple:   \"\"\"  Convert a ROS PointCloud2 message to a numpy array.   Args:  pointcloud2 (PointCloud2): the PointCloud2 message   Returns:  (tuple): tuple containing (xyz, rgb)  \"\"\"     pc_array = ros_numpy.point_cloud2.pointcloud2_to_array(pointcloud2)     split = ros_numpy.point_cloud2.split_rgb_field(pc_array)     rgb = np.stack([split[\"b\"], split[\"g\"], split[\"r\"]], axis=2)     xyz = ros_numpy.point_cloud2.get_xyz_points(pc_array, remove_nans=False)     xyz = np.array(xyz).reshape((pointcloud2.height, pointcloud2.width, 3))     nan_rows = np.isnan(xyz).all(axis=2)     xyz[nan_rows] = [0, 0, 0]     rgb[nan_rows] = [0, 0, 0]     return xyz, rgb` \n```", "```py\n`import sys  import open3d as o3d  ros_cloud = rospy.wait_for_message(\"/camera/depth/points\", PointCloud2) xyz, rgb = pointcloud2_to_array(ros_cloud) result = segmentation_model(rgb)  if not len(result[0].boxes.cls):     print(\"No objects detected\")     sys.exit()  classes = result[0].boxes.cls.cpu().numpy().astype(int) for index, class_id in enumerate(classes):     mask = result[0].masks.data.cpu().numpy()[index, :, :].astype(int)     mask_expanded = np.stack([mask, mask, mask], axis=2)      obj_rgb = rgb * mask_expanded     obj_xyz = xyz * mask_expanded      pcd = o3d.geometry.PointCloud()     pcd.points = o3d.utility.Vector3dVector(obj_xyz.reshape((ros_cloud.height * ros_cloud.width, 3)))     pcd.colors = o3d.utility.Vector3dVector(obj_rgb.reshape((ros_cloud.height * ros_cloud.width, 3)) / 255)     o3d.visualization.draw_geometries([pcd])` \n```", "```py\n`import sys import time  import numpy as np import open3d as o3d import ros_numpy import rospy  from ultralytics import YOLO  rospy.init_node(\"ultralytics\") time.sleep(1) segmentation_model = YOLO(\"yolov8m-seg.pt\")   def pointcloud2_to_array(pointcloud2: PointCloud2) -> tuple:   \"\"\"  Convert a ROS PointCloud2 message to a numpy array.   Args:  pointcloud2 (PointCloud2): the PointCloud2 message   Returns:  (tuple): tuple containing (xyz, rgb)  \"\"\"     pc_array = ros_numpy.point_cloud2.pointcloud2_to_array(pointcloud2)     split = ros_numpy.point_cloud2.split_rgb_field(pc_array)     rgb = np.stack([split[\"b\"], split[\"g\"], split[\"r\"]], axis=2)     xyz = ros_numpy.point_cloud2.get_xyz_points(pc_array, remove_nans=False)     xyz = np.array(xyz).reshape((pointcloud2.height, pointcloud2.width, 3))     nan_rows = np.isnan(xyz).all(axis=2)     xyz[nan_rows] = [0, 0, 0]     rgb[nan_rows] = [0, 0, 0]     return xyz, rgb   ros_cloud = rospy.wait_for_message(\"/camera/depth/points\", PointCloud2) xyz, rgb = pointcloud2_to_array(ros_cloud) result = segmentation_model(rgb)  if not len(result[0].boxes.cls):     print(\"No objects detected\")     sys.exit()  classes = result[0].boxes.cls.cpu().numpy().astype(int) for index, class_id in enumerate(classes):     mask = result[0].masks.data.cpu().numpy()[index, :, :].astype(int)     mask_expanded = np.stack([mask, mask, mask], axis=2)      obj_rgb = rgb * mask_expanded     obj_xyz = xyz * mask_expanded      pcd = o3d.geometry.PointCloud()     pcd.points = o3d.utility.Vector3dVector(obj_xyz.reshape((ros_cloud.height * ros_cloud.width, 3)))     pcd.colors = o3d.utility.Vector3dVector(obj_rgb.reshape((ros_cloud.height * ros_cloud.width, 3)) / 255)     o3d.visualization.draw_geometries([pcd])` \n```", "```py\n`pip  install  ros_numpy  ultralytics` \n```", "```py\n`import ros_numpy import rospy from sensor_msgs.msg import Image  from ultralytics import YOLO  detection_model = YOLO(\"yolov8m.pt\") rospy.init_node(\"ultralytics\") det_image_pub = rospy.Publisher(\"/ultralytics/detection/image\", Image, queue_size=5)   def callback(data):     array = ros_numpy.numpify(data)     det_result = detection_model(array)     det_annotated = det_result[0].plot(show=False)     det_image_pub.publish(ros_numpy.msgify(Image, det_annotated, encoding=\"rgb8\"))   rospy.Subscriber(\"/camera/color/image_raw\", Image, callback) rospy.spin()` \n```", "```py\n`rospy.Subscriber(\"/camera/color/image_raw\", Image, callback)` \n```", "```py\n`import sys  import open3d as o3d import ros_numpy import rospy from sensor_msgs.msg import PointCloud2  from ultralytics import YOLO  rospy.init_node(\"ultralytics\") segmentation_model = YOLO(\"yolov8m-seg.pt\")   def pointcloud2_to_array(pointcloud2):     pc_array = ros_numpy.point_cloud2.pointcloud2_to_array(pointcloud2)     split = ros_numpy.point_cloud2.split_rgb_field(pc_array)     rgb = np.stack([split[\"b\"], split[\"g\"], split[\"r\"]], axis=2)     xyz = ros_numpy.point_cloud2.get_xyz_points(pc_array, remove_nans=False)     xyz = np.array(xyz).reshape((pointcloud2.height, pointcloud2.width, 3))     return xyz, rgb   ros_cloud = rospy.wait_for_message(\"/camera/depth/points\", PointCloud2) xyz, rgb = pointcloud2_to_array(ros_cloud) result = segmentation_model(rgb)  if not len(result[0].boxes.cls):     print(\"No objects detected\")     sys.exit()  classes = result[0].boxes.cls.cpu().numpy().astype(int) for index, class_id in enumerate(classes):     mask = result[0].masks.data.cpu().numpy()[index, :, :].astype(int)     mask_expanded = np.stack([mask, mask, mask], axis=2)      obj_rgb = rgb * mask_expanded     obj_xyz = xyz * mask_expanded      pcd = o3d.geometry.PointCloud()     pcd.points = o3d.utility.Vector3dVector(obj_xyz.reshape((-1, 3)))     pcd.colors = o3d.utility.Vector3dVector(obj_rgb.reshape((-1, 3)) / 255)     o3d.visualization.draw_geometries([pcd])` \n```"]