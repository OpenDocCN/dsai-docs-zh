# 优化和根查找（scipy.optimize）

> 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/optimize.html](https://docs.scipy.org/doc/scipy-1.12.0/reference/optimize.html)

SciPy `optimize` 提供了用于最小化（或最大化）目标函数的函数，可能受约束条件限制。它包括非线性问题的求解器（支持局部和全局优化算法）、线性规划、约束和非线性最小二乘法、根查找和曲线拟合。

不同求解器共享的常见函数和对象包括：

| [`show_options`](generated/scipy.optimize.show_options.html#scipy.optimize.show_options "scipy.optimize.show_options")([solver, method, disp]) | 显示优化求解器的附加选项文档。 |
| --- | --- |
| [`OptimizeResult`](generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult "scipy.optimize.OptimizeResult") | 表示优化结果。 |
| [`OptimizeWarning`](generated/scipy.optimize.OptimizeWarning.html#scipy.optimize.OptimizeWarning "scipy.optimize.OptimizeWarning") |  |

## 优化

### 标量函数优化

| [`minimize_scalar`](generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar "scipy.optimize.minimize_scalar")(fun[, bracket, bounds, ...]) | 对一维标量函数进行局部最小化。 |
| --- | --- |

[`minimize_scalar`](generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar "scipy.optimize.minimize_scalar") 函数支持以下方法：

+   [minimize_scalar(method=’brent’)](optimize.minimize_scalar-brent.html)

+   [minimize_scalar(method=’bounded’)](optimize.minimize_scalar-bounded.html)

+   [minimize_scalar(method=’golden’)](optimize.minimize_scalar-golden.html)

### 本地（多变量）优化

| [`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")(fun, x0[, args, method, jac, hess, ...]) | 对一个或多个变量的标量函数进行最小化。 |
| --- | --- |

[`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize") 函数支持以下方法：

+   [minimize(method=’Nelder-Mead’)](optimize.minimize-neldermead.html)

+   [minimize(method=’Powell’)](optimize.minimize-powell.html)

+   [minimize(method=’CG’)](optimize.minimize-cg.html)

+   [minimize(method=’BFGS’)](optimize.minimize-bfgs.html)

+   [minimize(method=’Newton-CG’)](optimize.minimize-newtoncg.html)

+   [minimize(method=’L-BFGS-B’)](optimize.minimize-lbfgsb.html)

+   [minimize(method=’TNC’)](optimize.minimize-tnc.html)

+   [minimize(method=’COBYLA’)](optimize.minimize-cobyla.html)

+   [minimize(method=’SLSQP’)](optimize.minimize-slsqp.html)

+   [minimize(method=’trust-constr’)](optimize.minimize-trustconstr.html)

+   [minimize(method=’dogleg’)](optimize.minimize-dogleg.html)

+   [minimize(method=’trust-ncg’)](optimize.minimize-trustncg.html)

+   [minimize(method=’trust-krylov’)](optimize.minimize-trustkrylov.html)

+   [minimize(method=’trust-exact’)](optimize.minimize-trustexact.html)

约束以单个对象或来自以下类的对象列表形式传递给[`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")函数：

| [`NonlinearConstraint`](generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint "scipy.optimize.NonlinearConstraint")(fun, lb, ub[, jac, ...]) | 变量的非线性约束。 |
| --- | --- |
| [`LinearConstraint`](generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint "scipy.optimize.LinearConstraint")(A[, lb, ub, keep_feasible]) | 变量的线性约束。 |

简单的边界约束分别处理，并且有一个专门的类：

| [`Bounds`](generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")([lb, ub, keep_feasible]) | 变量的边界约束。 |
| --- | --- |

实现[`HessianUpdateStrategy`](generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy "scipy.optimize.HessianUpdateStrategy")接口的拟牛顿策略可用于在[`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")函数中近似黑塞矩阵（仅适用于“trust-constr”方法）。实现此接口的可用拟牛顿方法包括：

| [`BFGS`](generated/scipy.optimize.BFGS.html#scipy.optimize.BFGS "scipy.optimize.BFGS")([exception_strategy, min_curvature, ...]) | BFGS（Broyden-Fletcher-Goldfarb-Shanno）海森更新策略。 |
| --- | --- |
| [`SR1`](generated/scipy.optimize.SR1.html#scipy.optimize.SR1 "scipy.optimize.SR1")([min_denominator, init_scale]) | 对称秩-1海森更新策略。 |

### 全局优化

| [`basinhopping`](generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping "scipy.optimize.basinhopping")(func, x0[, niter, T, stepsize, ...]) | 使用盆地跳跃算法找到函数的全局最小值。 |
| --- | --- |
| [`brute`](generated/scipy.optimize.brute.html#scipy.optimize.brute "scipy.optimize.brute")(func, ranges[, args, Ns, full_output, ...]) | 通过蛮力法在给定范围内最小化函数。 |
| [`differential_evolution`](generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution "scipy.optimize.differential_evolution")(func, bounds[, args, ...]) | 多元函数的全局最小值。 |
| [`shgo`](generated/scipy.optimize.shgo.html#scipy.optimize.shgo "scipy.optimize.shgo")(func, bounds[, args, constraints, n, ...]) | 使用SHG优化找到函数的全局最小值。 |
| [`dual_annealing`](generated/scipy.optimize.dual_annealing.html#scipy.optimize.dual_annealing "scipy.optimize.dual_annealing")(func, bounds[, args, ...]) | 使用双退火法找到函数的全局最小值。 |
| [`direct`](generated/scipy.optimize.direct.html#scipy.optimize.direct "scipy.optimize.direct")(func, bounds, *[, args, eps, maxfun, ...]) | 使用 DIRECT 算法寻找函数的全局最小值。 |

## 最小二乘和曲线拟合

### 非线性最小二乘

| [`least_squares`](generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares "scipy.optimize.least_squares")(fun, x0[, jac, bounds, ...]) | 解决带有变量边界的非线性最小二乘问题。 |
| --- | --- |

### 线性最小二乘

| [`nnls`](generated/scipy.optimize.nnls.html#scipy.optimize.nnls "scipy.optimize.nnls")(A, b[, maxiter, atol]) | 解决 `argmin_x | | Ax - b | | _2` 且 `x>=0`。 |
| --- | --- | --- | --- | --- | --- |
| [`lsq_linear`](generated/scipy.optimize.lsq_linear.html#scipy.optimize.lsq_linear "scipy.optimize.lsq_linear")(A, b[, bounds, method, tol, ...]) | 解决带有变量边界的线性最小二乘问题。 |
| [`isotonic_regression`](generated/scipy.optimize.isotonic_regression.html#scipy.optimize.isotonic_regression "scipy.optimize.isotonic_regression")(y, *[, weights, increasing]) | 非参数等距回归。 |

### 曲线拟合

| [`curve_fit`](generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit "scipy.optimize.curve_fit")(f, xdata, ydata[, p0, sigma, ...]) | 使用非线性最小二乘拟合函数 `f` 到数据。 |
| --- | --- |

## 根查找

### 标量函数

| [`root_scalar`](generated/scipy.optimize.root_scalar.html#scipy.optimize.root_scalar "scipy.optimize.root_scalar")(f[, args, method, bracket, ...]) | 寻找标量函数的根。 |
| --- | --- |
| [`brentq`](generated/scipy.optimize.brentq.html#scipy.optimize.brentq "scipy.optimize.brentq")(f, a, b[, args, xtol, rtol, maxiter, ...]) | 使用 Brent 方法在一个区间内寻找函数的根。 |
| [`brenth`](generated/scipy.optimize.brenth.html#scipy.optimize.brenth "scipy.optimize.brenth")(f, a, b[, args, xtol, rtol, maxiter, ...]) | 使用 Brent 方法及双曲线外推在一个区间内寻找函数的根。 |
| [`ridder`](generated/scipy.optimize.ridder.html#scipy.optimize.ridder "scipy.optimize.ridder")(f, a, b[, args, xtol, rtol, maxiter, ...]) | 使用 Ridder 方法在一个区间内寻找函数的根。 |
| [`bisect`](generated/scipy.optimize.bisect.html#scipy.optimize.bisect "scipy.optimize.bisect")(f, a, b[, args, xtol, rtol, maxiter, ...]) | 使用二分法在一个区间内寻找函数的根。 |
| [`newton`](generated/scipy.optimize.newton.html#scipy.optimize.newton "scipy.optimize.newton")(func, x0[, fprime, args, tol, ...]) | 使用牛顿-拉弗森（或割线或哈雷）方法寻找实数或复数函数的根。 |
| [`toms748`](generated/scipy.optimize.toms748.html#scipy.optimize.toms748 "scipy.optimize.toms748")(f, a, b[, args, k, xtol, rtol, ...]) | 使用 TOMS 算法 748 方法寻找根。 |
| [`RootResults`](generated/scipy.optimize.RootResults.html#scipy.optimize.RootResults "scipy.optimize.RootResults")(root, iterations, ...) | 表示根查找结果。 |

[`root_scalar`](generated/scipy.optimize.root_scalar.html#scipy.optimize.root_scalar "scipy.optimize.root_scalar") 函数支持以下方法：

+   [root_scalar(method=’brentq’)](optimize.root_scalar-brentq.html)

+   [root_scalar(method=’brenth’)](optimize.root_scalar-brenth.html)

+   [root_scalar(method=’bisect’)](optimize.root_scalar-bisect.html)

+   [root_scalar(method=’ridder’)](optimize.root_scalar-ridder.html)

+   [root_scalar(method=’newton’)](optimize.root_scalar-newton.html)

+   [root_scalar(method=’toms748’)](optimize.root_scalar-toms748.html)

+   [root_scalar(method=’secant’)](optimize.root_scalar-secant.html)

+   [root_scalar(method=’halley’)](optimize.root_scalar-halley.html)

下表列出了情况及适当的方法，以及每次迭代（和每次函数评估）的渐近收敛率，以便成功收敛到简单根(*）。二分法是最慢的，每次函数评估增加一位有效数字，但保证收敛。其他括号法（最终）每次函数评估增加大约50%的准确位数。基于导数的方法，都建立在[`newton`](generated/scipy.optimize.newton.html#scipy.optimize.newton "scipy.optimize.newton")上，如果初始值接近根，可以相当快速地收敛。它们也可应用于在复平面（的子集上）定义的函数。

| 函数域 | 是否括号化？ | 是否有导数？ | 求解器 | 收敛性 |
| --- | --- | --- | --- | --- |
| *fprime* | *fprime2* | 是否保证？ | 收敛率(*) |
| --- | --- | --- | --- |
| *R* | 是 | N/A | N/A |

+   二分法

+   brentq

+   brenth

+   ridder

+   toms748

|

+   是

+   是

+   是

+   是

+   是

|

+   1 “线性”

+   >=1, <= 1.62

+   >=1, <= 1.62

+   2.0 (1.41)

+   2.7 (1.65)

|

| *R* 或 *C* | 否 | 否 | 否 | 切线法 | 否 | 1.62 (1.62) |
| --- | --- | --- | --- | --- | --- | --- |
| *R* 或 *C* | 否 | 是 | 否 | 牛顿法 | 否 | 2.00 (1.41) |
| *R* 或 *C* | 否 | 是 | 是 | 亥姆法 | 否 | 3.00 (1.44) |

另见

[`scipy.optimize.cython_optimize`](optimize.cython_optimize.html#module-scipy.optimize.cython_optimize "scipy.optimize.cython_optimize") – Typed Cython 版本的根查找函数

寻找不动点：

| [`fixed_point`](generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point "scipy.optimize.fixed_point")(func, x0[, args, xtol, maxiter, ...]) | 查找函数的不动点。 |
| --- | --- |

### 多维的

| [`root`](generated/scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root")(fun, x0[, args, method, jac, tol, ...]) | 查找向量函数的根。 |
| --- | --- |

[`root`](generated/scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root") 函数支持以下方法：

+   [root(method=’hybr’)](optimize.root-hybr.html)

+   [root(method=’lm’)](optimize.root-lm.html)

+   [root(method=’broyden1’)](optimize.root-broyden1.html)

+   [root(method=’broyden2’)](optimize.root-broyden2.html)

+   [root(method=’anderson’)](optimize.root-anderson.html)

+   [root(method=’linearmixing’)](optimize.root-linearmixing.html)

+   [root(method=’diagbroyden’)](optimize.root-diagbroyden.html)

+   [root(method=’excitingmixing’)](optimize.root-excitingmixing.html)

+   [root(method=’krylov’)](optimize.root-krylov.html)

+   [root(method=’df-sane’)](optimize.root-dfsane.html)

## 线性规划 / MILP

| [`milp`](generated/scipy.optimize.milp.html#scipy.optimize.milp "scipy.optimize.milp")(c, *[, integrality, bounds, ...]) | 混合整数线性规划 |
| --- | --- |
| [`linprog`](generated/scipy.optimize.linprog.html#scipy.optimize.linprog "scipy.optimize.linprog")(c[, A_ub, b_ub, A_eq, b_eq, bounds, ...]) | 线性规划：最小化线性目标函数，满足线性等式和不等式约束。 |

[`linprog`](generated/scipy.optimize.linprog.html#scipy.optimize.linprog "scipy.optimize.linprog") 函数支持以下方法：

+   [linprog(method=’simplex’)](optimize.linprog-simplex.html)

+   [linprog(method=’interior-point’)](optimize.linprog-interior-point.html)

+   [linprog(method=’revised simplex’)](optimize.linprog-revised_simplex.html)

+   [linprog(method=’highs-ipm’)](optimize.linprog-highs-ipm.html)

+   [linprog(method=’highs-ds’)](optimize.linprog-highs-ds.html)

+   [linprog(method=’highs’)](optimize.linprog-highs.html)

简单法、内点法和修订单纯法方法支持回调函数，例如：

| [`linprog_verbose_callback`](generated/scipy.optimize.linprog_verbose_callback.html#scipy.optimize.linprog_verbose_callback "scipy.optimize.linprog_verbose_callback")(res) | 演示 linprog 回调接口的样本回调函数。 |
| --- | --- |

## 分配问题

| [`linear_sum_assignment`](generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment "scipy.optimize.linear_sum_assignment") | 解决线性求和分配问题。 |
| --- | --- |
| [`quadratic_assignment`](generated/scipy.optimize.quadratic_assignment.html#scipy.optimize.quadratic_assignment "scipy.optimize.quadratic_assignment")(A, B[, method, options]) | 近似解决二次分配问题和图匹配问题。 |

[`quadratic_assignment`](generated/scipy.optimize.quadratic_assignment.html#scipy.optimize.quadratic_assignment "scipy.optimize.quadratic_assignment") 函数支持以下方法：

+   [quadratic_assignment(method=’faq’)](optimize.qap-faq.html)

+   [quadratic_assignment(method=’2opt’)](optimize.qap-2opt.html)

## 实用工具

### Finite-difference approximation

| [`approx_fprime`](generated/scipy.optimize.approx_fprime.html#scipy.optimize.approx_fprime "scipy.optimize.approx_fprime")(xk, f[, epsilon]) | 标量或向量值函数的有限差分近似导数。 |
| --- | --- |
| [`check_grad`](generated/scipy.optimize.check_grad.html#scipy.optimize.check_grad "scipy.optimize.check_grad")(func, grad, x0, *args[, epsilon, ...]) | 通过将其与梯度的（前向）有限差分近似比较，检查梯度函数的正确性。 |

### 线搜索：

| [`bracket`](generated/scipy.optimize.bracket.html#scipy.optimize.bracket "scipy.optimize.bracket")(func[, xa, xb, args, grow_limit, ...]) | 定位函数最小值的区间。 |
| --- | --- |
| [`line_search`](generated/scipy.optimize.line_search.html#scipy.optimize.line_search "scipy.optimize.line_search")(f, myfprime, xk, pk[, gfk, ...]) | 寻找满足强 Wolfe 条件的 alpha。 |

### Hessian 近似：

| [`LbfgsInvHessProduct`](generated/scipy.optimize.LbfgsInvHessProduct.html#scipy.optimize.LbfgsInvHessProduct "scipy.optimize.LbfgsInvHessProduct")(*args, **kwargs) | L-BFGS 近似逆 Hessian 的线性算子。 |
| --- | --- |
| [`HessianUpdateStrategy`](generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy "scipy.optimize.HessianUpdateStrategy")() | 实现 Hessian 更新策略的接口。 |

### 基准问题：

| [`rosen`](generated/scipy.optimize.rosen.html#scipy.optimize.rosen "scipy.optimize.rosen")(x) | Rosenbrock 函数。 |
| --- | --- |
| [`rosen_der`](generated/scipy.optimize.rosen_der.html#scipy.optimize.rosen_der "scipy.optimize.rosen_der")(x) | Rosenbrock 函数的导数（即梯度）。 |
| [`rosen_hess`](generated/scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess "scipy.optimize.rosen_hess")(x) | Rosenbrock 函数的 Hessian 矩阵。 |
| [`rosen_hess_prod`](generated/scipy.optimize.rosen_hess_prod.html#scipy.optimize.rosen_hess_prod "scipy.optimize.rosen_hess_prod")(x, p) | Rosenbrock 函数的 Hessian 矩阵与向量的乘积。 |

## 遗留函数：

下面的函数不建议在新脚本中使用；所有这些方法都可以通过提供的更新、更一致的接口访问。

### 优化：

通用多元方法：

| [`fmin`](generated/scipy.optimize.fmin.html#scipy.optimize.fmin "scipy.optimize.fmin")(func, x0[, args, xtol, ftol, maxiter, ...]) | 使用下降单纯形算法最小化函数。 |
| --- | --- |
| [`fmin_powell`](generated/scipy.optimize.fmin_powell.html#scipy.optimize.fmin_powell "scipy.optimize.fmin_powell")(func, x0[, args, xtol, ftol, ...]) | 使用修改后的 Powell 方法最小化函数。 |
| [`fmin_cg`](generated/scipy.optimize.fmin_cg.html#scipy.optimize.fmin_cg "scipy.optimize.fmin_cg")(f, x0[, fprime, args, gtol, norm, ...]) | 使用非线性共轭梯度算法最小化函数。 |
| [`fmin_bfgs`](generated/scipy.optimize.fmin_bfgs.html#scipy.optimize.fmin_bfgs "scipy.optimize.fmin_bfgs")(f, x0[, fprime, args, gtol, norm, ...]) | 使用 BFGS 算法最小化函数。 |
| [`fmin_ncg`](generated/scipy.optimize.fmin_ncg.html#scipy.optimize.fmin_ncg "scipy.optimize.fmin_ncg")(f, x0, fprime[, fhess_p, fhess, ...]) | 使用牛顿-CG方法无约束最小化函数。 |

约束多元方法：

| [`fmin_l_bfgs_b`](generated/scipy.optimize.fmin_l_bfgs_b.html#scipy.optimize.fmin_l_bfgs_b "scipy.optimize.fmin_l_bfgs_b")(func, x0[, fprime, args, ...]) | 使用L-BFGS-B算法最小化函数func。 |
| --- | --- |
| [`fmin_tnc`](generated/scipy.optimize.fmin_tnc.html#scipy.optimize.fmin_tnc "scipy.optimize.fmin_tnc")(func, x0[, fprime, args, ...]) | 使用截断牛顿算法最小化受界限约束的变量函数，并使用梯度信息。 |
| [`fmin_cobyla`](generated/scipy.optimize.fmin_cobyla.html#scipy.optimize.fmin_cobyla "scipy.optimize.fmin_cobyla")(func, x0, cons[, args, ...]) | 使用线性逼近约束优化（COBYLA）方法最小化函数。 |
| [`fmin_slsqp`](generated/scipy.optimize.fmin_slsqp.html#scipy.optimize.fmin_slsqp "scipy.optimize.fmin_slsqp")(func, x0[, eqcons, f_eqcons, ...]) | 使用顺序最小二乘规划（SLSQP）方法最小化函数。 |

单变量（标量）最小化方法：

| [`fminbound`](generated/scipy.optimize.fminbound.html#scipy.optimize.fminbound "scipy.optimize.fminbound")(func, x1, x2[, args, xtol, ...]) | 标量函数的有界最小化。 |
| --- | --- |
| [`brent`](generated/scipy.optimize.brent.html#scipy.optimize.brent "scipy.optimize.brent")(func[, args, brack, tol, full_output, ...]) | 给定一个变量函数和可能的区间，返回函数的局部最小化器，精确到tol的分数精度。 |
| [`golden`](generated/scipy.optimize.golden.html#scipy.optimize.golden "scipy.optimize.golden")(func[, args, brack, tol, ...]) | 使用黄金分割法返回单变量函数的最小化器。 |

### 最小二乘

| [`leastsq`](generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq "scipy.optimize.leastsq")(func, x0[, args, Dfun, full_output, ...]) | 最小化一组方程的平方和。 |
| --- | --- |

### 根查找：

一般非线性求解器：

| [`fsolve`](generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve "scipy.optimize.fsolve")(func, x0[, args, fprime, ...]) | 找到函数的根。 |
| --- | --- |
| [`broyden1`](generated/scipy.optimize.broyden1.html#scipy.optimize.broyden1 "scipy.optimize.broyden1")(F, xin[, iter, alpha, ...]) | 使用布罗伊登第一雅可比逼近找到函数的根。 |
| [`broyden2`](generated/scipy.optimize.broyden2.html#scipy.optimize.broyden2 "scipy.optimize.broyden2")(F, xin[, iter, alpha, ...]) | 使用布罗伊登第二雅可比逼近找到函数的根。 |

大规模非线性求解器：

| [`newton_krylov`](generated/scipy.optimize.newton_krylov.html#scipy.optimize.newton_krylov "scipy.optimize.newton_krylov")\(F, xin\[\, iter, rdiff, method, ...\]\) | 使用Krylov逼近方法求解函数的根，用于逆雅可比矩阵。 |
| --- | --- |
| [`anderson`](generated/scipy.optimize.anderson.html#scipy.optimize.anderson "scipy.optimize.anderson")(F, xin[, iter, alpha, w0, M, ...]) | 使用（扩展的）安德森混合方法寻找函数的根。 |
| [`BroydenFirst`](generated/scipy.optimize.BroydenFirst.html#scipy.optimize.BroydenFirst "scipy.optimize.BroydenFirst")([alpha, reduction_method, max_rank]) | 使用Broyden第一雅可比逼近方法寻找函数的根。 |
| [`InverseJacobian`](generated/scipy.optimize.InverseJacobian.html#scipy.optimize.InverseJacobian "scipy.optimize.InverseJacobian")(jacobian) |  |

属性：

|

| [`KrylovJacobian`](generated/scipy.optimize.KrylovJacobian.html#scipy.optimize.KrylovJacobian "scipy.optimize.KrylovJacobian")([rdiff, method, ...]) | 使用Krylov逼近方法求解函数的根，用于逆雅可比矩阵。 |
| --- | --- |

简单迭代求解器：

| [`excitingmixing`](generated/scipy.optimize.excitingmixing.html#scipy.optimize.excitingmixing "scipy.optimize.excitingmixing")\(F, xin\[\, iter, alpha, ...\]\) | 使用调整的对角雅可比逼近方法寻找函数的根。 |
| --- | --- |
| [`linearmixing`](generated/scipy.optimize.linearmixing.html#scipy.optimize.linearmixing "scipy.optimize.linearmixing")\(F, xin\[\, iter, alpha, verbose, ...\]\) | 使用标量雅可比逼近方法寻找函数的根。 |
| [`diagbroyden`](generated/scipy.optimize.diagbroyden.html#scipy.optimize.diagbroyden "scipy.optimize.diagbroyden")(F, xin[, iter, alpha, verbose, ...]) | 使用对角Broyden雅可比逼近方法寻找函数的根。 |
