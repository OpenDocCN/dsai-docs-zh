["```py\nclass sympy.physics.vector.frame.CoordinateSym(name, frame, index)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, CoordinateSym\n>>> A = ReferenceFrame('A')\n>>> A[1]\nA_y\n>>> type(A[0])\n<class 'sympy.physics.vector.frame.CoordinateSym'>\n>>> a_y = CoordinateSym('a_y', A, 1)\n>>> a_y == A[1]\nTrue \n```", "```py\nclass sympy.physics.vector.frame.ReferenceFrame(name, indices=None, latexs=None, variables=None)\n```", "```py\nang_acc_in(otherframe)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> V = 10 * N.x\n>>> A.set_ang_acc(N, V)\n>>> A.ang_acc_in(N)\n10*N.x \n```", "```py\nang_vel_in(otherframe)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> V = 10 * N.x\n>>> A.set_ang_vel(N, V)\n>>> A.ang_vel_in(N)\n10*N.x \n```", "```py\ndcm(otherframe)\n```", "```py\n>>> from sympy import symbols, sin, cos\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q1 = symbols('q1')\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> A.orient_axis(N, q1, N.x)\n>>> N.dcm(A)\nMatrix([\n[1,       0,        0],\n[0, cos(q1), -sin(q1)],\n[0, sin(q1),  cos(q1)]]) \n```", "```py\n>>> Ny = 0*A.x + cos(q1)*A.y - sin(q1)*A.z \n```", "```py\n>>> N.y.express(A)\ncos(q1)*A.y - sin(q1)*A.z \n```", "```py\norient(parent, rot_type, amounts, rot_order='')\n```", "```py\norient_axis(parent, axis, angle)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q1 = symbols('q1')\n>>> N = ReferenceFrame('N')\n>>> B = ReferenceFrame('B')\n>>> B.orient_axis(N, N.x, q1) \n```", "```py\n>>> B.dcm(N)\nMatrix([\n[1,       0,      0],\n[0,  cos(q1), sin(q1)],\n[0, -sin(q1), cos(q1)]])\n>>> N.dcm(B)\nMatrix([\n[1,       0,        0],\n[0, cos(q1), -sin(q1)],\n[0, sin(q1),  cos(q1)]]) \n```", "```py\n>>> B.orient_axis(N, -N.x, q1)\n>>> B.orient_axis(N, N.x, -q1) \n```", "```py\norient_body_fixed(parent, angles, rotation_order)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q1, q2, q3 = symbols('q1, q2, q3')\n>>> N = ReferenceFrame('N')\n>>> B = ReferenceFrame('B')\n>>> B1 = ReferenceFrame('B1')\n>>> B2 = ReferenceFrame('B2')\n>>> B3 = ReferenceFrame('B3') \n```", "```py\n>>> B.orient_body_fixed(N, (q1, q2, q3), 'XYX')\n>>> B.dcm(N)\nMatrix([\n[        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n[sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n[sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]]) \n```", "```py\n>>> B1.orient_axis(N, N.x, q1)\n>>> B2.orient_axis(B1, B1.y, q2)\n>>> B3.orient_axis(B2, B2.x, q3)\n>>> B3.dcm(N)\nMatrix([\n[        cos(q2),                            sin(q1)*sin(q2),                           -sin(q2)*cos(q1)],\n[sin(q2)*sin(q3), -sin(q1)*sin(q3)*cos(q2) + cos(q1)*cos(q3),  sin(q1)*cos(q3) + sin(q3)*cos(q1)*cos(q2)],\n[sin(q2)*cos(q3), -sin(q1)*cos(q2)*cos(q3) - sin(q3)*cos(q1), -sin(q1)*sin(q3) + cos(q1)*cos(q2)*cos(q3)]]) \n```", "```py\n>>> B.orient_body_fixed(N, (q1, q2, 0), 'ZXZ')\n>>> B.orient_body_fixed(N, (q1, q2, 0), '121')\n>>> B.orient_body_fixed(N, (q1, q2, q3), 123) \n```", "```py\norient_dcm(parent, dcm)\n```", "```py\n>>> from sympy import symbols, Matrix, sin, cos\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q1 = symbols('q1')\n>>> A = ReferenceFrame('A')\n>>> B = ReferenceFrame('B')\n>>> N = ReferenceFrame('N') \n```", "```py\n>>> dcm = Matrix([[1, 0, 0],\n...               [0,  cos(q1), sin(q1)],\n...               [0, -sin(q1), cos(q1)]])\n>>> A.orient_dcm(N, dcm)\n>>> A.dcm(N)\nMatrix([\n[1,       0,      0],\n[0,  cos(q1), sin(q1)],\n[0, -sin(q1), cos(q1)]]) \n```", "```py\n>>> B.orient_axis(N, N.x, q1)\n>>> B.dcm(N)\nMatrix([\n[1,       0,      0],\n[0,  cos(q1), sin(q1)],\n[0, -sin(q1), cos(q1)]]) \n```", "```py\norient_quaternion(parent, numbers)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n>>> N = ReferenceFrame('N')\n>>> B = ReferenceFrame('B') \n```", "```py\n>>> B.orient_quaternion(N, (q0, q1, q2, q3))\n>>> B.dcm(N)\nMatrix([\n[q0**2 + q1**2 - q2**2 - q3**2,             2*q0*q3 + 2*q1*q2,            -2*q0*q2 + 2*q1*q3],\n[           -2*q0*q3 + 2*q1*q2, q0**2 - q1**2 + q2**2 - q3**2,             2*q0*q1 + 2*q2*q3],\n[            2*q0*q2 + 2*q1*q3,            -2*q0*q1 + 2*q2*q3, q0**2 - q1**2 - q2**2 + q3**2]]) \n```", "```py\norient_space_fixed(parent, angles, rotation_order)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame\n>>> q1, q2, q3 = symbols('q1, q2, q3')\n>>> N = ReferenceFrame('N')\n>>> B = ReferenceFrame('B')\n>>> B1 = ReferenceFrame('B1')\n>>> B2 = ReferenceFrame('B2')\n>>> B3 = ReferenceFrame('B3') \n```", "```py\n>>> B.orient_space_fixed(N, (q1, q2, q3), '312')\n>>> B.dcm(N)\nMatrix([\n[ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n[-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n[                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]]) \n```", "```py\n>>> B1.orient_axis(N, N.z, q1)\n>>> B2.orient_axis(B1, N.x, q2)\n>>> B3.orient_axis(B2, N.y, q3)\n>>> B3.dcm(N).simplify()\nMatrix([\n[ sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1)],\n[-sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3)],\n[                           sin(q3)*cos(q2),        -sin(q2),                           cos(q2)*cos(q3)]]) \n```", "```py\n>>> B.orient_space_fixed(N, (q1, q2, q3), '231')\n>>> B.dcm(N)\nMatrix([\n[cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n[       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n[sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]]) \n```", "```py\n>>> B.orient_body_fixed(N, (q3, q2, q1), '132')\n>>> B.dcm(N)\nMatrix([\n[cos(q1)*cos(q2), sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), -sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],\n[       -sin(q2),                           cos(q2)*cos(q3),                            sin(q3)*cos(q2)],\n[sin(q1)*cos(q2), sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1),  sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3)]]) \n```", "```py\norientnew(newname, rot_type, amounts, rot_order='', variables=None, indices=None, latexs=None)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame, vlatex\n>>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n>>> N = ReferenceFrame('N') \n```", "```py\n>>> A = N.orientnew('A', 'Axis', (q0, N.x)) \n```", "```py\n>>> B = N.orientnew('B', 'Body', (q1, q2, q3), '123') \n```", "```py\n>>> C = N.orientnew('C', 'Axis', (q0, N.x), indices=('1', '2', '3'),\n... latexs=(r'\\hat{\\mathbf{c}}_1',r'\\hat{\\mathbf{c}}_2',\n... r'\\hat{\\mathbf{c}}_3'))\n>>> C['1']\nC['1']\n>>> print(vlatex(C['1']))\n\\hat{\\mathbf{c}}_1 \n```", "```py\npartial_velocity(frame, *gen_speeds)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> u1, u2 = dynamicsymbols('u1, u2')\n>>> A.set_ang_vel(N, u1 * A.x + u2 * N.y)\n>>> A.partial_velocity(N, u1)\nA.x\n>>> A.partial_velocity(N, u1, u2)\n(A.x, N.y) \n```", "```py\nset_ang_acc(otherframe, value)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> V = 10 * N.x\n>>> A.set_ang_acc(N, V)\n>>> A.ang_acc_in(N)\n10*N.x \n```", "```py\nset_ang_vel(otherframe, value)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> N = ReferenceFrame('N')\n>>> A = ReferenceFrame('A')\n>>> V = 10 * N.x\n>>> A.set_ang_vel(N, V)\n>>> A.ang_vel_in(N)\n10*N.x \n```", "```py\nproperty u\n```", "```py\nvariable_map(otherframe)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n>>> A = ReferenceFrame('A')\n>>> q = dynamicsymbols('q')\n>>> B = A.orientnew('B', 'Axis', [q, A.z])\n>>> A.variable_map(B)\n{A_x: B_x*cos(q(t)) - B_y*sin(q(t)), A_y: B_x*sin(q(t)) + B_y*cos(q(t)), A_z: B_z} \n```", "```py\nproperty x\n```", "```py\nproperty xx\n```", "```py\nproperty xy\n```", "```py\nproperty xz\n```", "```py\nproperty y\n```", "```py\nproperty yx\n```", "```py\nproperty yy\n```", "```py\nproperty yz\n```", "```py\nproperty z\n```", "```py\nproperty zx\n```", "```py\nproperty zy\n```", "```py\nproperty zz\n```", "```py\nclass sympy.physics.vector.vector.Vector(inlist)\n```", "```py\nangle_between(vec)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> A = ReferenceFrame(\"A\")\n>>> v1 = A.x\n>>> v2 = A.y\n>>> v1.angle_between(v2)\npi/2 \n```", "```py\n>>> v3 = A.x + A.y + A.z\n>>> v1.angle_between(v3)\nacos(sqrt(3)/3) \n```", "```py\napplyfunc(f)\n```", "```py\ncross(other)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame, cross\n>>> q1 = symbols('q1')\n>>> N = ReferenceFrame('N')\n>>> cross(N.x, N.y)\nN.z\n>>> A = ReferenceFrame('A')\n>>> A.orient_axis(N, q1, N.x)\n>>> cross(A.x, N.y)\nN.z\n>>> cross(N.y, A.x)\n- sin(q1)*A.y - cos(q1)*A.z \n```", "```py\ndiff(var, frame, var_in_dcm=True)\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.physics.vector import dynamicsymbols, ReferenceFrame\n>>> from sympy.physics.vector import init_vprinting\n>>> init_vprinting(pretty_print=False)\n>>> t = Symbol('t')\n>>> q1 = dynamicsymbols('q1')\n>>> N = ReferenceFrame('N')\n>>> A = N.orientnew('A', 'Axis', [q1, N.y])\n>>> A.x.diff(t, N)\n- sin(q1)*q1'*N.x - cos(q1)*q1'*N.z\n>>> A.x.diff(t, N).express(A).simplify()\n- q1'*A.z\n>>> B = ReferenceFrame('B')\n>>> u1, u2 = dynamicsymbols('u1, u2')\n>>> v = u1 * A.x + u2 * B.y\n>>> v.diff(u2, N, var_in_dcm=False)\nB.y \n```", "```py\ndoit(**hints)\n```", "```py\ndot(other)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, dot\n>>> from sympy import symbols\n>>> q1 = symbols('q1')\n>>> N = ReferenceFrame('N')\n>>> dot(N.x, N.x)\n1\n>>> dot(N.x, N.y)\n0\n>>> A = N.orientnew('A', 'Axis', [q1, N.x])\n>>> dot(N.y, A.y)\ncos(q1) \n```", "```py\ndt(otherframe)\n```", "```py\nexpress(otherframe, variables=False)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, dynamicsymbols\n>>> from sympy.physics.vector import init_vprinting\n>>> init_vprinting(pretty_print=False)\n>>> q1 = dynamicsymbols('q1')\n>>> N = ReferenceFrame('N')\n>>> A = N.orientnew('A', 'Axis', [q1, N.y])\n>>> A.x.express(N)\ncos(q1)*N.x - sin(q1)*N.z \n```", "```py\nfree_dynamicsymbols(reference_frame)\n```", "```py\nfree_symbols(reference_frame)\n```", "```py\nproperty func\n```", "```py\nmagnitude()\n```", "```py\nnormalize()\n```", "```py\nouter(other)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, outer\n>>> N = ReferenceFrame('N')\n>>> outer(N.x, N.x)\n(N.x|N.x) \n```", "```py\nseparate()\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R1 = ReferenceFrame('R1')\n>>> R2 = ReferenceFrame('R2')\n>>> v = R1.x + R2.x\n>>> v.separate() == {R1: R1.x, R2: R2.x}\nTrue \n```", "```py\nsimplify()\n```", "```py\nsubs(*args, **kwargs)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> from sympy import Symbol\n>>> N = ReferenceFrame('N')\n>>> s = Symbol('s')\n>>> a = N.x * s\n>>> a.subs({s: 2})\n2*N.x \n```", "```py\nto_matrix(reference_frame)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.vector import ReferenceFrame\n>>> a, b, c = symbols('a, b, c')\n>>> N = ReferenceFrame('N')\n>>> vector = a * N.x + b * N.y + c * N.z\n>>> vector.to_matrix(N)\nMatrix([\n[a],\n[b],\n[c]])\n>>> beta = symbols('beta')\n>>> A = N.orientnew('A', 'Axis', (beta, N.x))\n>>> vector.to_matrix(A)\nMatrix([\n[                         a],\n[ b*cos(beta) + c*sin(beta)],\n[-b*sin(beta) + c*cos(beta)]]) \n```", "```py\nxreplace(rule)\n```", "```py\n>>> from sympy import symbols, pi\n>>> from sympy.physics.vector import ReferenceFrame\n>>> A = ReferenceFrame('A')\n>>> x, y, z = symbols('x y z')\n>>> ((1 + x*y) * A.x).xreplace({x: pi})\n(pi*y + 1)*A.x\n>>> ((1 + x*y) * A.x).xreplace({x: pi, y: 2})\n(1 + 2*pi)*A.x \n```", "```py\n>>> ((x*y + z) * A.x).xreplace({x*y: pi})\n(z + pi)*A.x\n>>> ((x*y*z) * A.x).xreplace({x*y: pi})\nx*y*z*A.x \n```", "```py\nclass sympy.physics.vector.dyadic.Dyadic(inlist)\n```", "```py\napplyfunc(f)\n```", "```py\ncross(other)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, outer, cross\n>>> N = ReferenceFrame('N')\n>>> d = outer(N.x, N.x)\n>>> cross(d, N.y)\n(N.x|N.z) \n```", "```py\ndoit(**hints)\n```", "```py\ndot(other)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, outer\n>>> N = ReferenceFrame('N')\n>>> D1 = outer(N.x, N.y)\n>>> D2 = outer(N.y, N.y)\n>>> D1.dot(D2)\n(N.x|N.y)\n>>> D1.dot(N.y)\nN.x \n```", "```py\ndt(frame)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, outer, dynamicsymbols\n>>> from sympy.physics.vector import init_vprinting\n>>> init_vprinting(pretty_print=False)\n>>> N = ReferenceFrame('N')\n>>> q = dynamicsymbols('q')\n>>> B = N.orientnew('B', 'Axis', [q, N.z])\n>>> d = outer(N.x, N.x)\n>>> d.dt(B)\n- q'*(N.y|N.x) - q'*(N.x|N.y) \n```", "```py\nexpress(frame1, frame2=None)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, outer, dynamicsymbols\n>>> from sympy.physics.vector import init_vprinting\n>>> init_vprinting(pretty_print=False)\n>>> N = ReferenceFrame('N')\n>>> q = dynamicsymbols('q')\n>>> B = N.orientnew('B', 'Axis', [q, N.z])\n>>> d = outer(N.x, N.x)\n>>> d.express(B, N)\ncos(q)*(B.x|N.x) - sin(q)*(B.y|N.x) \n```", "```py\nproperty func\n```", "```py\nsimplify()\n```", "```py\nsubs(*args, **kwargs)\n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> from sympy import Symbol\n>>> N = ReferenceFrame('N')\n>>> s = Symbol('s')\n>>> a = s*(N.x|N.x)\n>>> a.subs({s: 2})\n2*(N.x|N.x) \n```", "```py\nto_matrix(reference_frame, second_reference_frame=None)\n```", "```py\n>>> from sympy import symbols, trigsimp\n>>> from sympy.physics.vector import ReferenceFrame\n>>> from sympy.physics.mechanics import inertia\n>>> Ixx, Iyy, Izz, Ixy, Iyz, Ixz = symbols('Ixx, Iyy, Izz, Ixy, Iyz, Ixz')\n>>> N = ReferenceFrame('N')\n>>> inertia_dyadic = inertia(N, Ixx, Iyy, Izz, Ixy, Iyz, Ixz)\n>>> inertia_dyadic.to_matrix(N)\nMatrix([\n[Ixx, Ixy, Ixz],\n[Ixy, Iyy, Iyz],\n[Ixz, Iyz, Izz]])\n>>> beta = symbols('beta')\n>>> A = N.orientnew('A', 'Axis', (beta, N.x))\n>>> trigsimp(inertia_dyadic.to_matrix(A))\nMatrix([\n[                           Ixx,                                           Ixy*cos(beta) + Ixz*sin(beta),                                           -Ixy*sin(beta) + Ixz*cos(beta)],\n[ Ixy*cos(beta) + Ixz*sin(beta), Iyy*cos(2*beta)/2 + Iyy/2 + Iyz*sin(2*beta) - Izz*cos(2*beta)/2 + Izz/2,                 -Iyy*sin(2*beta)/2 + Iyz*cos(2*beta) + Izz*sin(2*beta)/2],\n[-Ixy*sin(beta) + Ixz*cos(beta),                -Iyy*sin(2*beta)/2 + Iyz*cos(2*beta) + Izz*sin(2*beta)/2, -Iyy*cos(2*beta)/2 + Iyy/2 - Iyz*sin(2*beta) + Izz*cos(2*beta)/2 + Izz/2]]) \n```", "```py\nxreplace(rule)\n```", "```py\n>>> from sympy import symbols, pi\n>>> from sympy.physics.vector import ReferenceFrame, outer\n>>> N = ReferenceFrame('N')\n>>> D = outer(N.x, N.x)\n>>> x, y, z = symbols('x y z')\n>>> ((1 + x*y) * D).xreplace({x: pi})\n(pi*y + 1)*(N.x|N.x)\n>>> ((1 + x*y) * D).xreplace({x: pi, y: 2})\n(1 + 2*pi)*(N.x|N.x) \n```", "```py\n>>> ((x*y + z) * D).xreplace({x*y: pi})\n(z + pi)*(N.x|N.x)\n>>> ((x*y*z) * D).xreplace({x*y: pi})\nx*y*z*(N.x|N.x) \n```"]