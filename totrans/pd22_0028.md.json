["```py\nIn [1]: dates = pd.date_range('1/1/2000', periods=8)\n\nIn [2]: df = pd.DataFrame(np.random.randn(8, 4),\n ...:                  index=dates, columns=['A', 'B', 'C', 'D'])\n ...: \n\nIn [3]: df\nOut[3]: \n A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885 \n```", "```py\nIn [4]: s = df['A']\n\nIn [5]: s[dates[5]]\nOut[5]: -0.6736897080883706 \n```", "```py\nIn [6]: df\nOut[6]: \n A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885\n\nIn [7]: df[['B', 'A']] = df[['A', 'B']]\n\nIn [8]: df\nOut[8]: \n A         B         C         D\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n2000-01-04 -0.706771  0.721555 -1.039575  0.271860\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885 \n```", "```py\nIn [9]: df[['A', 'B']]\nOut[9]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647\n\nIn [10]: df.loc[:, ['B', 'A']] = df[['A', 'B']]\n\nIn [11]: df[['A', 'B']]\nOut[11]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647 \n```", "```py\nIn [12]: df.loc[:, ['B', 'A']] = df[['A', 'B']].to_numpy()\n\nIn [13]: df[['A', 'B']]\nOut[13]: \n A         B\n2000-01-01  0.469112 -0.282863\n2000-01-02  1.212112 -0.173215\n2000-01-03 -0.861849 -2.104569\n2000-01-04  0.721555 -0.706771\n2000-01-05 -0.424972  0.567020\n2000-01-06 -0.673690  0.113648\n2000-01-07  0.404705  0.577046\n2000-01-08 -0.370647 -1.157892 \n```", "```py\nIn [14]: df[['A', 'B']]\nOut[14]: \n A         B\n2000-01-01  0.469112 -0.282863\n2000-01-02  1.212112 -0.173215\n2000-01-03 -0.861849 -2.104569\n2000-01-04  0.721555 -0.706771\n2000-01-05 -0.424972  0.567020\n2000-01-06 -0.673690  0.113648\n2000-01-07  0.404705  0.577046\n2000-01-08 -0.370647 -1.157892\n\nIn [15]: df.iloc[:, [1, 0]] = df[['A', 'B']]\n\nIn [16]: df[['A','B']]\nOut[16]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647 \n```", "```py\nIn [17]: sa = pd.Series([1, 2, 3], index=list('abc'))\n\nIn [18]: dfa = df.copy() \n```", "```py\nIn [19]: sa.b\nOut[19]: 2\n\nIn [20]: dfa.A\nOut[20]: \n2000-01-01   -0.282863\n2000-01-02   -0.173215\n2000-01-03   -2.104569\n2000-01-04   -0.706771\n2000-01-05    0.567020\n2000-01-06    0.113648\n2000-01-07    0.577046\n2000-01-08   -1.157892\nFreq: D, Name: A, dtype: float64 \n```", "```py\nIn [21]: sa.a = 5\n\nIn [22]: sa\nOut[22]: \na    5\nb    2\nc    3\ndtype: int64\n\nIn [23]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists\n\nIn [24]: dfa\nOut[24]: \n A         B         C         D\n2000-01-01  0  0.469112 -1.509059 -1.135632\n2000-01-02  1  1.212112  0.119209 -1.044236\n2000-01-03  2 -0.861849 -0.494929  1.071804\n2000-01-04  3  0.721555 -1.039575  0.271860\n2000-01-05  4 -0.424972  0.276232 -1.087401\n2000-01-06  5 -0.673690 -1.478427  0.524988\n2000-01-07  6  0.404705 -1.715002 -1.039268\n2000-01-08  7 -0.370647 -1.344312  0.844885\n\nIn [25]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column\n\nIn [26]: dfa\nOut[26]: \n A         B         C         D\n2000-01-01  0  0.469112 -1.509059 -1.135632\n2000-01-02  1  1.212112  0.119209 -1.044236\n2000-01-03  2 -0.861849 -0.494929  1.071804\n2000-01-04  3  0.721555 -1.039575  0.271860\n2000-01-05  4 -0.424972  0.276232 -1.087401\n2000-01-06  5 -0.673690 -1.478427  0.524988\n2000-01-07  6  0.404705 -1.715002 -1.039268\n2000-01-08  7 -0.370647 -1.344312  0.844885 \n```", "```py\nIn [27]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})\n\nIn [28]: x.iloc[1] = {'x': 9, 'y': 99}\n\nIn [29]: x\nOut[29]: \n x   y\n0  1   3\n1  9  99\n2  3   5 \n```", "```py\nIn [30]: df_new = pd.DataFrame({'one': [1., 2., 3.]})\n\nIn [31]: df_new.two = [4, 5, 6]\n\nIn [32]: df_new\nOut[32]: \n one\n0  1.0\n1  2.0\n2  3.0 \n```", "```py\nIn [33]: s[:5]\nOut[33]: \n2000-01-01    0.469112\n2000-01-02    1.212112\n2000-01-03   -0.861849\n2000-01-04    0.721555\n2000-01-05   -0.424972\nFreq: D, Name: A, dtype: float64\n\nIn [34]: s[::2]\nOut[34]: \n2000-01-01    0.469112\n2000-01-03   -0.861849\n2000-01-05   -0.424972\n2000-01-07    0.404705\nFreq: 2D, Name: A, dtype: float64\n\nIn [35]: s[::-1]\nOut[35]: \n2000-01-08   -0.370647\n2000-01-07    0.404705\n2000-01-06   -0.673690\n2000-01-05   -0.424972\n2000-01-04    0.721555\n2000-01-03   -0.861849\n2000-01-02    1.212112\n2000-01-01    0.469112\nFreq: -1D, Name: A, dtype: float64 \n```", "```py\nIn [36]: s2 = s.copy()\n\nIn [37]: s2[:5] = 0\n\nIn [38]: s2\nOut[38]: \n2000-01-01    0.000000\n2000-01-02    0.000000\n2000-01-03    0.000000\n2000-01-04    0.000000\n2000-01-05    0.000000\n2000-01-06   -0.673690\n2000-01-07    0.404705\n2000-01-08   -0.370647\nFreq: D, Name: A, dtype: float64 \n```", "```py\nIn [39]: df[:3]\nOut[39]: \n A         B         C         D\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n\nIn [40]: df[::-1]\nOut[40]: \n A         B         C         D\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401\n2000-01-04 -0.706771  0.721555 -1.039575  0.271860\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632 \n```", "```py\n> In [41]: dfl = pd.DataFrame(np.random.randn(5, 4),\n>  ....:                   columns=list('ABCD'),\n>  ....:                   index=pd.date_range('20130101', periods=5))\n>  ....: \n> \n> In [42]: dfl\n> Out[42]: \n>  A         B         C         D\n> 2013-01-01  1.075770 -0.109050  1.643563 -1.469388\n> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061\n> 2013-01-05  0.895717  0.805244 -1.206412  2.565646\n> \n> In [43]: dfl.loc[2:3]\n> ---------------------------------------------------------------------------\n> TypeError  Traceback (most recent call last)\n> Cell In[43], line 1\n> ----> 1 dfl.loc[2:3]\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n>   1189 maybe_callable = com.apply_if_callable(key, self.obj)\n>   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n> -> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n>   1409 if isinstance(key, slice):\n>   1410     self._validate_key(key, axis)\n> -> 1411     return self._get_slice_axis(key, axis=axis)\n>   1412 elif com.is_bool_indexer(key):\n>   1413     return self._getbool_axis(key, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n>   1440     return obj.copy(deep=False)\n>   1442 labels = obj._get_axis(axis)\n> -> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n>   1445 if isinstance(indexer, slice):\n>   1446     return self.obj._slice(indexer, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:682, in DatetimeIndex.slice_indexer(self, start, end, step)\n>   674 # GH#33146 if start and end are combinations of str and None and Index is not\n>   675 # monotonic, we can not use Index.slice_indexer because it does not honor the\n>   676 # actual elements, is only searching for start and end\n>   677 if (\n>   678     check_str_or_none(start)\n>   679     or check_str_or_none(end)\n>   680     or self.is_monotonic_increasing\n>   681 ):\n> --> 682     return Index.slice_indexer(self, start, end, step)\n>   684 mask = np.array(True)\n>   685 in_index = True\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n>   6618 def slice_indexer(\n>   6619     self,\n>   6620     start: Hashable | None = None,\n>   6621     end: Hashable | None = None,\n>   6622     step: int | None = None,\n>   6623 ) -> slice:\n>   6624  \"\"\"\n>   6625 Compute the slice indexer for input labels and step.\n>   6626  \n>  (...)\n>   6660 slice(1, 3, None)\n>   6661 \"\"\"\n> -> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n>   6664     # return a slice\n>   6665     if not is_scalar(start_slice):\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n>   6877 start_slice = None\n>   6878 if start is not None:\n> -> 6879     start_slice = self.get_slice_bound(start, \"left\")\n>   6880 if start_slice is None:\n>   6881     start_slice = 0\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6794, in Index.get_slice_bound(self, label, side)\n>   6790 original_label = label\n>   6792 # For datetime indices label may be a string that has to be converted\n>   6793 # to datetime boundary according to its resolution.\n> -> 6794 label = self._maybe_cast_slice_bound(label, side)\n>   6796 # we need to look up the label\n>   6797 try:\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:642, in DatetimeIndex._maybe_cast_slice_bound(self, label, side)\n>   637 if isinstance(label, dt.date) and not isinstance(label, dt.datetime):\n>   638     # Pandas supports slicing with dates, treated as datetimes at midnight.\n>   639     # https://github.com/pandas-dev/pandas/issues/31501\n>   640     label = Timestamp(label).to_pydatetime()\n> --> 642 label = super()._maybe_cast_slice_bound(label, side)\n>   643 self._data._assert_tzawareness_compat(label)\n>   644 return Timestamp(label)\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimelike.py:378, in DatetimeIndexOpsMixin._maybe_cast_slice_bound(self, label, side)\n>   376     return lower if side == \"left\" else upper\n>   377 elif not isinstance(label, self._data._recognized_scalars):\n> --> 378     self._raise_invalid_indexer(\"slice\", label)\n>   380 return label\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:4301, in Index._raise_invalid_indexer(self, form, key, reraise)\n>   4299 if reraise is not lib.no_default:\n>   4300     raise TypeError(msg) from reraise\n> -> 4301 raise TypeError(msg)\n> \n> TypeError: cannot do slice indexing on DatetimeIndex with these indexers [2] of type int \n> ```", "```py\nIn [44]: dfl.loc['20130102':'20130104']\nOut[44]: \n A         B         C         D\n2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061 \n```", "```py\nIn [45]: s1 = pd.Series(np.random.randn(6), index=list('abcdef'))\n\nIn [46]: s1\nOut[46]: \na    1.431256\nb    1.340309\nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [47]: s1.loc['c':]\nOut[47]: \nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [48]: s1.loc['b']\nOut[48]: 1.3403088497993827 \n```", "```py\nIn [49]: s1.loc['c':] = 0\n\nIn [50]: s1\nOut[50]: \na    1.431256\nb    1.340309\nc    0.000000\nd    0.000000\ne    0.000000\nf    0.000000\ndtype: float64 \n```", "```py\nIn [51]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list('abcdef'),\n ....:                   columns=list('ABCD'))\n ....: \n\nIn [52]: df1\nOut[52]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nc  1.024180  0.569605  0.875906 -2.211372\nd  0.974466 -2.006747 -0.410001 -0.078638\ne  0.545952 -1.219217 -1.226825  0.769804\nf -1.281247 -0.727707 -0.121306 -0.097883\n\nIn [53]: df1.loc[['a', 'b', 'd'], :]\nOut[53]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nd  0.974466 -2.006747 -0.410001 -0.078638 \n```", "```py\nIn [54]: df1.loc['d':, 'A':'C']\nOut[54]: \n A         B         C\nd  0.974466 -2.006747 -0.410001\ne  0.545952 -1.219217 -1.226825\nf -1.281247 -0.727707 -0.121306 \n```", "```py\nIn [55]: df1.loc['a']\nOut[55]: \nA    0.132003\nB   -0.827317\nC   -0.076467\nD   -1.187678\nName: a, dtype: float64 \n```", "```py\nIn [56]: df1.loc['a'] > 0\nOut[56]: \nA     True\nB    False\nC    False\nD    False\nName: a, dtype: bool\n\nIn [57]: df1.loc[:, df1.loc['a'] > 0]\nOut[57]: \n A\na  0.132003\nb  1.130127\nc  1.024180\nd  0.974466\ne  0.545952\nf -1.281247 \n```", "```py\nIn [58]: mask = pd.array([True, False, True, False, pd.NA, False], dtype=\"boolean\")\n\nIn [59]: mask\nOut[59]: \n<BooleanArray>\n[True, False, True, False, <NA>, False]\nLength: 6, dtype: boolean\n\nIn [60]: df1[mask]\nOut[60]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nc  1.024180  0.569605  0.875906 -2.211372 \n```", "```py\n# this is also equivalent to ``df1.at['a','A']``\nIn [61]: df1.loc['a', 'A']\nOut[61]: 0.13200317033032932 \n```", "```py\nIn [62]: s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])\n\nIn [63]: s.loc[3:5]\nOut[63]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [64]: s.sort_index()\nOut[64]: \n0    a\n2    c\n3    b\n4    e\n5    d\ndtype: object\n\nIn [65]: s.sort_index().loc[1:6]\nOut[65]: \n2    c\n3    b\n4    e\n5    d\ndtype: object \n```", "```py\nIn [66]: s = pd.Series(list('abcdef'), index=[0, 3, 2, 5, 4, 2])\n\nIn [67]: s.loc[3:5]\nOut[67]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [68]: s1 = pd.Series(np.random.randn(5), index=list(range(0, 10, 2)))\n\nIn [69]: s1\nOut[69]: \n0    0.695775\n2    0.341734\n4    0.959726\n6   -1.110336\n8   -0.619976\ndtype: float64\n\nIn [70]: s1.iloc[:3]\nOut[70]: \n0    0.695775\n2    0.341734\n4    0.959726\ndtype: float64\n\nIn [71]: s1.iloc[3]\nOut[71]: -1.110336102891167 \n```", "```py\nIn [72]: s1.iloc[:3] = 0\n\nIn [73]: s1\nOut[73]: \n0    0.000000\n2    0.000000\n4    0.000000\n6   -1.110336\n8   -0.619976\ndtype: float64 \n```", "```py\nIn [74]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list(range(0, 12, 2)),\n ....:                   columns=list(range(0, 8, 2)))\n ....: \n\nIn [75]: df1\nOut[75]: \n 0         2         4         6\n0   0.149748 -0.732339  0.687738  0.176444\n2   0.403310 -0.154951  0.301624 -2.179861\n4  -1.369849 -0.954208  1.462696 -1.743161\n6  -0.826591 -0.345352  1.314232  0.690579\n8   0.995761  2.396780  0.014871  3.357427\n10 -0.317441 -1.236269  0.896171 -0.487602 \n```", "```py\nIn [76]: df1.iloc[:3]\nOut[76]: \n 0         2         4         6\n0  0.149748 -0.732339  0.687738  0.176444\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161\n\nIn [77]: df1.iloc[1:5, 2:4]\nOut[77]: \n 4         6\n2  0.301624 -2.179861\n4  1.462696 -1.743161\n6  1.314232  0.690579\n8  0.014871  3.357427 \n```", "```py\nIn [78]: df1.iloc[[1, 3, 5], [1, 3]]\nOut[78]: \n 2         6\n2  -0.154951 -2.179861\n6  -0.345352  0.690579\n10 -1.236269 -0.487602 \n```", "```py\nIn [79]: df1.iloc[1:3, :]\nOut[79]: \n 0         2         4         6\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161 \n```", "```py\nIn [80]: df1.iloc[:, 1:3]\nOut[80]: \n 2         4\n0  -0.732339  0.687738\n2  -0.154951  0.301624\n4  -0.954208  1.462696\n6  -0.345352  1.314232\n8   2.396780  0.014871\n10 -1.236269  0.896171 \n```", "```py\n# this is also equivalent to ``df1.iat[1,1]``\nIn [81]: df1.iloc[1, 1]\nOut[81]: -0.1549507744249032 \n```", "```py\nIn [82]: df1.iloc[1]\nOut[82]: \n0    0.403310\n2   -0.154951\n4    0.301624\n6   -2.179861\nName: 2, dtype: float64 \n```", "```py\n# these are allowed in Python/NumPy.\nIn [83]: x = list('abcdef')\n\nIn [84]: x\nOut[84]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [85]: x[4:10]\nOut[85]: ['e', 'f']\n\nIn [86]: x[8:10]\nOut[86]: []\n\nIn [87]: s = pd.Series(x)\n\nIn [88]: s\nOut[88]: \n0    a\n1    b\n2    c\n3    d\n4    e\n5    f\ndtype: object\n\nIn [89]: s.iloc[4:10]\nOut[89]: \n4    e\n5    f\ndtype: object\n\nIn [90]: s.iloc[8:10]\nOut[90]: Series([], dtype: object) \n```", "```py\nIn [91]: dfl = pd.DataFrame(np.random.randn(5, 2), columns=list('AB'))\n\nIn [92]: dfl\nOut[92]: \n A         B\n0 -0.082240 -2.182937\n1  0.380396  0.084844\n2  0.432390  1.519970\n3 -0.493662  0.600178\n4  0.274230  0.132885\n\nIn [93]: dfl.iloc[:, 2:3]\nOut[93]: \nEmpty DataFrame\nColumns: []\nIndex: [0, 1, 2, 3, 4]\n\nIn [94]: dfl.iloc[:, 1:3]\nOut[94]: \n B\n0 -2.182937\n1  0.084844\n2  1.519970\n3  0.600178\n4  0.132885\n\nIn [95]: dfl.iloc[4:6]\nOut[95]: \n A         B\n4  0.27423  0.132885 \n```", "```py\nIn [96]: dfl.iloc[[4, 5, 6]]\n---------------------------------------------------------------------------\nIndexError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1714, in _iLocIndexer._get_list_axis(self, key, axis)\n  1713 try:\n-> 1714     return self.obj._take_with_is_copy(key, axis=axis)\n  1715 except IndexError as err:\n  1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4153, in NDFrame._take_with_is_copy(self, indices, axis)\n  4144  \"\"\"\n  4145 Internal version of the `take` method that sets the `_is_copy`\n  4146 attribute to keep track of the parent dataframe (using in indexing\n (...)\n  4151 See the docstring of `take` for full explanation of the parameters.\n  4152 \"\"\"\n-> 4153 result = self.take(indices=indices, axis=axis)\n  4154 # Maybe set copy if we didn't actually change the index.\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4133, in NDFrame.take(self, indices, axis, **kwargs)\n  4129     indices = np.arange(\n  4130         indices.start, indices.stop, indices.step, dtype=np.intp\n  4131     )\n-> 4133 new_data = self._mgr.take(\n  4134     indices,\n  4135     axis=self._get_block_manager_axis(axis),\n  4136     verify=True,\n  4137 )\n  4138 return self._constructor_from_mgr(new_data, axes=new_data.axes).__finalize__(\n  4139     self, method=\"take\"\n  4140 )\n\nFile ~/work/pandas/pandas/pandas/core/internals/managers.py:891, in BaseBlockManager.take(self, indexer, axis, verify)\n  890 n = self.shape[axis]\n--> 891 indexer = maybe_convert_indices(indexer, n, verify=verify)\n  893 new_labels = self.axes[axis].take(indexer)\n\nFile ~/work/pandas/pandas/pandas/core/indexers/utils.py:282, in maybe_convert_indices(indices, n, verify)\n  281     if mask.any():\n--> 282         raise IndexError(\"indices are out-of-bounds\")\n  283 return indices\n\nIndexError: indices are out-of-bounds\n\nThe above exception was the direct cause of the following exception:\n\nIndexError  Traceback (most recent call last)\nCell In[96], line 1\n----> 1 dfl.iloc[[4, 5, 6]]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1743, in _iLocIndexer._getitem_axis(self, key, axis)\n  1741 # a list of integers\n  1742 elif is_list_like_indexer(key):\n-> 1743     return self._get_list_axis(key, axis=axis)\n  1745 # a single integer\n  1746 else:\n  1747     key = item_from_zerodim(key)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1717, in _iLocIndexer._get_list_axis(self, key, axis)\n  1714     return self.obj._take_with_is_copy(key, axis=axis)\n  1715 except IndexError as err:\n  1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d\n-> 1717     raise IndexError(\"positional indexers are out-of-bounds\") from err\n\nIndexError: positional indexers are out-of-bounds \n```", "```py\nIn [97]: dfl.iloc[:, 4]\n---------------------------------------------------------------------------\nIndexError  Traceback (most recent call last)\nCell In[97], line 1\n----> 1 dfl.iloc[:, 4]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1690, in _iLocIndexer._getitem_tuple(self, tup)\n  1689 def _getitem_tuple(self, tup: tuple):\n-> 1690     tup = self._validate_tuple_indexer(tup)\n  1691     with suppress(IndexingError):\n  1692         return self._getitem_lowerdim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:966, in _LocationIndexer._validate_tuple_indexer(self, key)\n  964 for i, k in enumerate(key):\n  965     try:\n--> 966         self._validate_key(k, i)\n  967     except ValueError as err:\n  968         raise ValueError(\n  969             \"Location based indexing can only have \"\n  970             f\"[{self._valid_types}] types\"\n  971         ) from err\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1592, in _iLocIndexer._validate_key(self, key, axis)\n  1590     return\n  1591 elif is_integer(key):\n-> 1592     self._validate_integer(key, axis)\n  1593 elif isinstance(key, tuple):\n  1594     # a tuple should already have been caught by this point\n  1595     # so don't treat a tuple as a valid indexer\n  1596     raise IndexingError(\"Too many indexers\")\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1685, in _iLocIndexer._validate_integer(self, key, axis)\n  1683 len_axis = len(self.obj._get_axis(axis))\n  1684 if key >= len_axis or key < -len_axis:\n-> 1685     raise IndexError(\"single positional indexer is out-of-bounds\")\n\nIndexError: single positional indexer is out-of-bounds \n```", "```py\nIn [98]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list('abcdef'),\n ....:                   columns=list('ABCD'))\n ....: \n\nIn [99]: df1\nOut[99]: \n A         B         C         D\na -0.023688  2.410179  1.450520  0.206053\nb -0.251905 -2.213588  1.063327  1.266143\nc  0.299368 -0.863838  0.408204 -1.048089\nd -0.025747 -0.988387  0.094055  1.262731\ne  1.289997  0.082423 -0.055758  0.536580\nf -0.489682  0.369374 -0.034571 -2.484478\n\nIn [100]: df1.loc[lambda df: df['A'] > 0, :]\nOut[100]: \n A         B         C         D\nc  0.299368 -0.863838  0.408204 -1.048089\ne  1.289997  0.082423 -0.055758  0.536580\n\nIn [101]: df1.loc[:, lambda df: ['A', 'B']]\nOut[101]: \n A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [102]: df1.iloc[:, lambda df: [0, 1]]\nOut[102]: \n A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [103]: df1[lambda df: df.columns[0]]\nOut[103]: \na   -0.023688\nb   -0.251905\nc    0.299368\nd   -0.025747\ne    1.289997\nf   -0.489682\nName: A, dtype: float64 \n```", "```py\nIn [104]: df1['A'].loc[lambda s: s > 0]\nOut[104]: \nc    0.299368\ne    1.289997\nName: A, dtype: float64 \n```", "```py\nIn [105]: bb = pd.read_csv('data/baseball.csv', index_col='id')\n\nIn [106]: (bb.groupby(['year', 'team']).sum(numeric_only=True)\n .....:   .loc[lambda df: df['r'] > 100])\n .....: \nOut[106]: \n stint    g    ab    r    h  X2b  ...     so   ibb   hbp    sh    sf  gidp\nyear team                                   ... \n2007 CIN       6  379   745  101  203   35  ...  127.0  14.0   1.0   1.0  15.0  18.0\n DET       5  301  1062  162  283   54  ...  176.0   3.0  10.0   4.0   8.0  28.0\n HOU       4  311   926  109  218   47  ...  212.0   3.0   9.0  16.0   6.0  17.0\n LAN      11  413  1021  153  293   61  ...  141.0   8.0   9.0   3.0   8.0  29.0\n NYN      13  622  1854  240  509  101  ...  310.0  24.0  23.0  18.0  15.0  48.0\n SFN       5  482  1305  198  337   67  ...  188.0  51.0   8.0  16.0   6.0  41.0\n TEX       2  198   729  115  200   40  ...  140.0   4.0   5.0   2.0   8.0  16.0\n TOR       4  459  1408  187  378   96  ...  265.0  16.0  12.0   4.0  16.0  38.0\n\n[8 rows x 18 columns] \n```", "```py\nIn [107]: dfd = pd.DataFrame({'A': [1, 2, 3],\n .....:                    'B': [4, 5, 6]},\n .....:                   index=list('abc'))\n .....: \n\nIn [108]: dfd\nOut[108]: \n A  B\na  1  4\nb  2  5\nc  3  6\n\nIn [109]: dfd.loc[dfd.index[[0, 2]], 'A']\nOut[109]: \na    1\nc    3\nName: A, dtype: int64 \n```", "```py\nIn [110]: dfd.iloc[[0, 2], dfd.columns.get_loc('A')]\nOut[110]: \na    1\nc    3\nName: A, dtype: int64 \n```", "```py\nIn [111]: dfd.iloc[[0, 2], dfd.columns.get_indexer(['A', 'B'])]\nOut[111]: \n A  B\na  1  4\nc  3  6 \n```", "```py\nIn [112]: s = pd.Series([1, 2, 3])\n\nIn [113]: s.reindex([1, 2, 3])\nOut[113]: \n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [114]: labels = [1, 2, 3]\n\nIn [115]: s.loc[s.index.intersection(labels)]\nOut[115]: \n1    2\n2    3\ndtype: int64 \n```", "```py\nIn [116]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])\n\nIn [117]: labels = ['c', 'd']\n\nIn [118]: s.reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[118], line 1\n----> 1 s.reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [119]: s.loc[s.index.intersection(labels)].reindex(labels)\nOut[119]: \nc    3.0\nd    NaN\ndtype: float64 \n```", "```py\nIn [120]: labels = ['a', 'd']\n\nIn [121]: s.loc[s.index.intersection(labels)].reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[121], line 1\n----> 1 s.loc[s.index.intersection(labels)].reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [122]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# When no arguments are passed, returns 1 row.\nIn [123]: s.sample()\nOut[123]: \n4    4\ndtype: int64\n\n# One may specify either a number of rows:\nIn [124]: s.sample(n=3)\nOut[124]: \n0    0\n4    4\n1    1\ndtype: int64\n\n# Or a fraction of the rows:\nIn [125]: s.sample(frac=0.5)\nOut[125]: \n5    5\n3    3\n1    1\ndtype: int64 \n```", "```py\nIn [126]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# Without replacement (default):\nIn [127]: s.sample(n=6, replace=False)\nOut[127]: \n0    0\n1    1\n5    5\n3    3\n2    2\n4    4\ndtype: int64\n\n# With replacement:\nIn [128]: s.sample(n=6, replace=True)\nOut[128]: \n0    0\n4    4\n3    3\n2    2\n4    4\n4    4\ndtype: int64 \n```", "```py\nIn [129]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\nIn [130]: example_weights = [0, 0, 0.2, 0.2, 0.2, 0.4]\n\nIn [131]: s.sample(n=3, weights=example_weights)\nOut[131]: \n5    5\n4    4\n3    3\ndtype: int64\n\n# Weights will be re-normalized automatically\nIn [132]: example_weights2 = [0.5, 0, 0, 0, 0, 0]\n\nIn [133]: s.sample(n=1, weights=example_weights2)\nOut[133]: \n0    0\ndtype: int64 \n```", "```py\nIn [134]: df2 = pd.DataFrame({'col1': [9, 8, 7, 6],\n .....:                    'weight_column': [0.5, 0.4, 0.1, 0]})\n .....: \n\nIn [135]: df2.sample(n=3, weights='weight_column')\nOut[135]: \n col1  weight_column\n1     8            0.4\n0     9            0.5\n2     7            0.1 \n```", "```py\nIn [136]: df3 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\nIn [137]: df3.sample(n=1, axis=1)\nOut[137]: \n col1\n0     1\n1     2\n2     3 \n```", "```py\nIn [138]: df4 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\n# With a given seed, the sample will always draw the same rows.\nIn [139]: df4.sample(n=2, random_state=2)\nOut[139]: \n col1  col2\n2     3     4\n1     2     3\n\nIn [140]: df4.sample(n=2, random_state=2)\nOut[140]: \n col1  col2\n2     3     4\n1     2     3 \n```", "```py\nIn [141]: se = pd.Series([1, 2, 3])\n\nIn [142]: se\nOut[142]: \n0    1\n1    2\n2    3\ndtype: int64\n\nIn [143]: se[5] = 5.\n\nIn [144]: se\nOut[144]: \n0    1.0\n1    2.0\n2    3.0\n5    5.0\ndtype: float64 \n```", "```py\nIn [145]: dfi = pd.DataFrame(np.arange(6).reshape(3, 2),\n .....:                   columns=['A', 'B'])\n .....: \n\nIn [146]: dfi\nOut[146]: \n A  B\n0  0  1\n1  2  3\n2  4  5\n\nIn [147]: dfi.loc[:, 'C'] = dfi.loc[:, 'A']\n\nIn [148]: dfi\nOut[148]: \n A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4 \n```", "```py\nIn [149]: dfi.loc[3] = 5\n\nIn [150]: dfi\nOut[150]: \n A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4\n3  5  5  5 \n```", "```py\nIn [151]: s.iat[5]\nOut[151]: 5\n\nIn [152]: df.at[dates[5], 'A']\nOut[152]: 0.1136484096888855\n\nIn [153]: df.iat[3, 0]\nOut[153]: -0.7067711336300845 \n```", "```py\nIn [154]: df.at[dates[5], 'E'] = 7\n\nIn [155]: df.iat[3, 0] = 7 \n```", "```py\nIn [156]: df.at[dates[-1] + pd.Timedelta('1 day'), 0] = 7\n\nIn [157]: df\nOut[157]: \n A         B         C         D    E    0\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632  NaN  NaN\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236  NaN  NaN\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804  NaN  NaN\n2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN  NaN\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN  NaN\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0  NaN\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN  NaN\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885  NaN  NaN\n2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0 \n```", "```py\nIn [158]: s = pd.Series(range(-3, 4))\n\nIn [159]: s\nOut[159]: \n0   -3\n1   -2\n2   -1\n3    0\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [160]: s[s > 0]\nOut[160]: \n4    1\n5    2\n6    3\ndtype: int64\n\nIn [161]: s[(s < -1) | (s > 0.5)]\nOut[161]: \n0   -3\n1   -2\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [162]: s[~(s < 0)]\nOut[162]: \n3    0\n4    1\n5    2\n6    3\ndtype: int64 \n```", "```py\nIn [163]: df[df['A'] > 0]\nOut[163]: \n A         B         C         D    E   0\n2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN NaN\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN NaN\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0 NaN\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN NaN \n```", "```py\nIn [164]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],\n .....:                    'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],\n .....:                    'c': np.random.randn(7)})\n .....: \n\n# only want 'two' or 'three'\nIn [165]: criterion = df2['a'].map(lambda x: x.startswith('t'))\n\nIn [166]: df2[criterion]\nOut[166]: \n a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# equivalent but slower\nIn [167]: df2[[x.startswith('t') for x in df2['a']]]\nOut[167]: \n a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# Multiple criteria\nIn [168]: df2[criterion & (df2['b'] == 'x')]\nOut[168]: \n a  b         c\n3  three  x  0.361719 \n```", "```py\nIn [169]: df2.loc[criterion & (df2['b'] == 'x'), 'b':'c']\nOut[169]: \n b         c\n3  x  0.361719 \n```", "```py\nIn [170]: df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n .....:                  index=list('abc'),\n .....:                  columns=['A', 'B'])\n .....: \n\nIn [171]: s = (df['A'] > 2)\n\nIn [172]: s\nOut[172]: \na    False\nb     True\nc     True\nName: A, dtype: bool\n\nIn [173]: df.loc[s, 'B']\nOut[173]: \nb    4\nc    6\nName: B, dtype: int64\n\nIn [174]: df.iloc[s.values, 1]\nOut[174]: \nb    4\nc    6\nName: B, dtype: int64 \n```", "```py\nIn [175]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')\n\nIn [176]: s\nOut[176]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [177]: s.isin([2, 4, 6])\nOut[177]: \n4    False\n3    False\n2     True\n1    False\n0     True\ndtype: bool\n\nIn [178]: s[s.isin([2, 4, 6])]\nOut[178]: \n2    2\n0    4\ndtype: int64 \n```", "```py\nIn [179]: s[s.index.isin([2, 4, 6])]\nOut[179]: \n4    0\n2    2\ndtype: int64\n\n# compare it to the following\nIn [180]: s.reindex([2, 4, 6])\nOut[180]: \n2    2.0\n4    0.0\n6    NaN\ndtype: float64 \n```", "```py\nIn [181]: s_mi = pd.Series(np.arange(6),\n .....:                 index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))\n .....: \n\nIn [182]: s_mi\nOut[182]: \n0  a    0\n b    1\n c    2\n1  a    3\n b    4\n c    5\ndtype: int64\n\nIn [183]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]\nOut[183]: \n0  c    2\n1  a    3\ndtype: int64\n\nIn [184]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]\nOut[184]: \n0  a    0\n c    2\n1  a    3\n c    5\ndtype: int64 \n```", "```py\nIn [185]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f', 'n'],\n .....:                   'ids2': ['a', 'n', 'c', 'n']})\n .....: \n\nIn [186]: values = ['a', 'b', 1, 3]\n\nIn [187]: df.isin(values)\nOut[187]: \n vals    ids   ids2\n0   True   True   True\n1  False   True  False\n2   True  False  False\n3  False  False  False \n```", "```py\nIn [188]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [189]: df.isin(values)\nOut[189]: \n vals    ids   ids2\n0   True   True  False\n1  False   True  False\n2   True  False  False\n3  False  False  False \n```", "```py\nIn [190]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [191]: ~df.isin(values)\nOut[191]: \n vals    ids  ids2\n0  False  False  True\n1   True  False  True\n2  False   True  True\n3   True   True  True \n```", "```py\nIn [192]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}\n\nIn [193]: row_mask = df.isin(values).all(1)\n\nIn [194]: df[row_mask]\nOut[194]: \n vals ids ids2\n0     1   a    a \n```", "```py\nIn [195]: s[s > 0]\nOut[195]: \n3    1\n2    2\n1    3\n0    4\ndtype: int64 \n```", "```py\nIn [196]: s.where(s > 0)\nOut[196]: \n4    NaN\n3    1.0\n2    2.0\n1    3.0\n0    4.0\ndtype: float64 \n```", "```py\nIn [197]: dates = pd.date_range('1/1/2000', periods=8)\n\nIn [198]: df = pd.DataFrame(np.random.randn(8, 4),\n .....:                  index=dates, columns=['A', 'B', 'C', 'D'])\n .....: \n\nIn [199]: df[df < 0]\nOut[199]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838 \n```", "```py\nIn [200]: df.where(df < 0, -df)\nOut[200]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166\n2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824\n2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059\n2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203\n2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416\n2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048\n2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838 \n```", "```py\nIn [201]: s2 = s.copy()\n\nIn [202]: s2[s2 < 0] = 0\n\nIn [203]: s2\nOut[203]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [204]: df2 = df.copy()\n\nIn [205]: df2[df2 < 0] = 0\n\nIn [206]: df2\nOut[206]: \n A         B         C         D\n2000-01-01  0.000000  0.000000  0.485855  0.245166\n2000-01-02  0.000000  0.390389  0.000000  1.655824\n2000-01-03  0.000000  0.299674  0.000000  0.281059\n2000-01-04  0.846958  0.000000  0.600705  0.000000\n2000-01-05  0.669692  0.000000  0.000000  0.342416\n2000-01-06  0.868584  0.000000  2.297780  0.000000\n2000-01-07  0.000000  0.000000  0.168904  0.000000\n2000-01-08  0.801196  1.392071  0.000000  0.000000 \n```", "```py\nIn [207]: df.where(df < 0, -df) == np.where(df < 0, df, -df)\nOut[207]: \n A     B     C     D\n2000-01-01  True  True  True  True\n2000-01-02  True  True  True  True\n2000-01-03  True  True  True  True\n2000-01-04  True  True  True  True\n2000-01-05  True  True  True  True\n2000-01-06  True  True  True  True\n2000-01-07  True  True  True  True\n2000-01-08  True  True  True  True \n```", "```py\nIn [208]: df2 = df.copy()\n\nIn [209]: df2[df2[1:4] > 0] = 3\n\nIn [210]: df2\nOut[210]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525  0.485855  0.245166\n2000-01-02 -0.352480  3.000000 -1.192319  3.000000\n2000-01-03 -0.864883  3.000000 -0.227870  3.000000\n2000-01-04  3.000000 -1.222082  3.000000 -1.233203\n2000-01-05  0.669692 -0.605656 -1.169184  0.342416\n2000-01-06  0.868584 -0.948458  2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722  0.168904 -0.048048\n2000-01-08  0.801196  1.392071 -0.048788 -0.808838 \n```", "```py\nIn [211]: df2 = df.copy()\n\nIn [212]: df2.where(df2 > 0, df2['A'], axis='index')\nOut[212]: \n A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196 \n```", "```py\nIn [213]: df2 = df.copy()\n\nIn [214]: df.apply(lambda x, y: x.where(x > 0, y), y=df['A'])\nOut[214]: \n A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196 \n```", "```py\nIn [215]: df3 = pd.DataFrame({'A': [1, 2, 3],\n .....:                    'B': [4, 5, 6],\n .....:                    'C': [7, 8, 9]})\n .....: \n\nIn [216]: df3.where(lambda x: x > 4, lambda x: x + 10)\nOut[216]: \n A   B  C\n0  11  14  7\n1  12   5  8\n2  13   6  9 \n```", "```py\nIn [217]: s.mask(s >= 0)\nOut[217]: \n4   NaN\n3   NaN\n2   NaN\n1   NaN\n0   NaN\ndtype: float64\n\nIn [218]: df.mask(df >= 0)\nOut[218]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838 \n```", "```py\nIn [219]: df = pd.DataFrame({'col1': list('ABBC'), 'col2': list('ZZXY')})\n\nIn [220]: df['color'] = np.where(df['col2'] == 'Z', 'green', 'red')\n\nIn [221]: df\nOut[221]: \n col1 col2  color\n0    A    Z  green\n1    B    Z  green\n2    B    X    red\n3    C    Y    red \n```", "```py\nIn [222]: conditions = [\n .....:    (df['col2'] == 'Z') & (df['col1'] == 'A'),\n .....:    (df['col2'] == 'Z') & (df['col1'] == 'B'),\n .....:    (df['col1'] == 'B')\n .....: ]\n .....: \n\nIn [223]: choices = ['yellow', 'blue', 'purple']\n\nIn [224]: df['color'] = np.select(conditions, choices, default='black')\n\nIn [225]: df\nOut[225]: \n col1 col2   color\n0    A    Z  yellow\n1    B    Z    blue\n2    B    X  purple\n3    C    Y   black \n```", "```py\nIn [226]: n = 10\n\nIn [227]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [228]: df\nOut[228]: \n a         b         c\n0  0.438921  0.118680  0.863670\n1  0.138138  0.577363  0.686602\n2  0.595307  0.564592  0.520630\n3  0.913052  0.926075  0.616184\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n6  0.792342  0.216974  0.564056\n7  0.397890  0.454131  0.915716\n8  0.074315  0.437913  0.019794\n9  0.559209  0.502065  0.026437\n\n# pure python\nIn [229]: df[(df['a'] < df['b']) & (df['b'] < df['c'])]\nOut[229]: \n a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716\n\n# query\nIn [230]: df.query('(a < b) & (b < c)')\nOut[230]: \n a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716 \n```", "```py\nIn [231]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))\n\nIn [232]: df.index.name = 'a'\n\nIn [233]: df\nOut[233]: \n b  c\na \n0  0  4\n1  0  1\n2  3  4\n3  4  3\n4  1  4\n5  0  3\n6  0  1\n7  3  4\n8  2  3\n9  1  1\n\nIn [234]: df.query('a < b and b < c')\nOut[234]: \n b  c\na \n2  3  4 \n```", "```py\nIn [235]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))\n\nIn [236]: df\nOut[236]: \n b  c\n0  3  1\n1  3  0\n2  5  6\n3  5  2\n4  7  4\n5  0  1\n6  2  5\n7  0  1\n8  6  0\n9  7  9\n\nIn [237]: df.query('index < b < c')\nOut[237]: \n b  c\n2  5  6 \n```", "```py\nIn [238]: df = pd.DataFrame({'a': np.random.randint(5, size=5)})\n\nIn [239]: df.index.name = 'a'\n\nIn [240]: df.query('a > 2')  # uses the column 'a', not the index\nOut[240]: \n a\na \n1  3\n3  3 \n```", "```py\nIn [241]: df.query('index > 2')\nOut[241]: \n a\na \n3  3\n4  2 \n```", "```py\nIn [242]: n = 10\n\nIn [243]: colors = np.random.choice(['red', 'green'], size=n)\n\nIn [244]: foods = np.random.choice(['eggs', 'ham'], size=n)\n\nIn [245]: colors\nOut[245]: \narray(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',\n 'green', 'green'], dtype='<U5')\n\nIn [246]: foods\nOut[246]: \narray(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',\n 'eggs'], dtype='<U4')\n\nIn [247]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])\n\nIn [248]: df = pd.DataFrame(np.random.randn(n, 2), index=index)\n\nIn [249]: df\nOut[249]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [250]: df.query('color == \"red\"')\nOut[250]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [251]: df.index.names = [None, None]\n\nIn [252]: df\nOut[252]: \n 0         1\nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [253]: df.query('ilevel_0 == \"red\"')\nOut[253]: \n 0         1\nred ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [254]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [255]: df\nOut[255]: \n a         b         c\n0  0.224283  0.736107  0.139168\n1  0.302827  0.657803  0.713897\n2  0.611185  0.136624  0.984960\n3  0.195246  0.123436  0.627712\n4  0.618673  0.371660  0.047902\n5  0.480088  0.062993  0.185760\n6  0.568018  0.483467  0.445289\n7  0.309040  0.274580  0.587101\n8  0.258993  0.477769  0.370255\n9  0.550459  0.840870  0.304611\n\nIn [256]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)\n\nIn [257]: df2\nOut[257]: \n a         b         c\n0   0.357579  0.229800  0.596001\n1   0.309059  0.957923  0.965663\n2   0.123102  0.336914  0.318616\n3   0.526506  0.323321  0.860813\n4   0.518736  0.486514  0.384724\n5   0.190804  0.505723  0.614533\n6   0.891939  0.623977  0.676639\n7   0.480559  0.378528  0.460858\n8   0.420223  0.136404  0.141295\n9   0.732206  0.419540  0.604675\n10  0.604466  0.848974  0.896165\n11  0.589168  0.920046  0.732716\n\nIn [258]: expr = '0.0 <= a <= c <= 0.5'\n\nIn [259]: map(lambda frame: frame.query(expr), [df, df2])\nOut[259]: <map at 0x7ff2e57db2e0> \n```", "```py\nIn [260]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))\n\nIn [261]: df\nOut[261]: \n a  b  c\n0  7  8  9\n1  1  0  7\n2  2  7  2\n3  6  2  2\n4  2  6  3\n5  3  8  2\n6  1  7  2\n7  5  1  5\n8  9  8  0\n9  1  5  0\n\nIn [262]: df.query('(a < b) & (b < c)')\nOut[262]: \n a  b  c\n0  7  8  9\n\nIn [263]: df[(df['a'] < df['b']) & (df['b'] < df['c'])]\nOut[263]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [264]: df.query('a < b & b < c')\nOut[264]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [265]: df.query('a < b and b < c')\nOut[265]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [266]: df.query('a < b < c')\nOut[266]: \n a  b  c\n0  7  8  9 \n```", "```py\n# get all rows where columns \"a\" and \"b\" have overlapping values\nIn [267]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),\n .....:                   'c': np.random.randint(5, size=12),\n .....:                   'd': np.random.randint(9, size=12)})\n .....: \n\nIn [268]: df\nOut[268]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [269]: df.query('a in b')\nOut[269]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\n# How you'd do it in pure Python\nIn [270]: df[df['a'].isin(df['b'])]\nOut[270]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\nIn [271]: df.query('a not in b')\nOut[271]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [272]: df[~df['a'].isin(df['b'])]\nOut[272]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\n# rows where cols a and b have overlapping values\n# and col c's values are less than col d's\nIn [273]: df.query('a in b and c < d')\nOut[273]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n4  c  b  3  6\n5  c  b  0  2\n\n# pure Python\nIn [274]: df[df['b'].isin(df['a']) & (df['c'] < df['d'])]\nOut[274]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n4   c  b  3  6\n5   c  b  0  2\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\ndf.query('a in b + c + d') \n```", "```py\nIn [275]: df.query('b == [\"a\", \"b\", \"c\"]')\nOut[275]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [276]: df[df['b'].isin([\"a\", \"b\", \"c\"])]\nOut[276]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [277]: df.query('c == [1, 2]')\nOut[277]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [278]: df.query('c != [1, 2]')\nOut[278]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# using in/not in\nIn [279]: df.query('[1, 2] in c')\nOut[279]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [280]: df.query('[1, 2] not in c')\nOut[280]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# pure Python\nIn [281]: df[df['c'].isin([1, 2])]\nOut[281]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2 \n```", "```py\nIn [282]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [283]: df['bools'] = np.random.rand(len(df)) > 0.5\n\nIn [284]: df.query('~bools')\nOut[284]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [285]: df.query('not bools')\nOut[285]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [286]: df.query('not bools') == df[~df['bools']]\nOut[286]: \n a     b     c  bools\n2  True  True  True   True\n7  True  True  True   True\n8  True  True  True   True \n```", "```py\n# short query syntax\nIn [287]: shorter = df.query('a < b < c and (not bools) or bools > 2')\n\n# equivalent in pure Python\nIn [288]: longer = df[(df['a'] < df['b'])\n .....:            & (df['b'] < df['c'])\n .....:            & (~df['bools'])\n .....:            | (df['bools'] > 2)]\n .....: \n\nIn [289]: shorter\nOut[289]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [290]: longer\nOut[290]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [291]: shorter == longer\nOut[291]: \n a     b     c  bools\n7  True  True  True   True \n```", "```py\nIn [292]: df = pd.DataFrame(np.random.randn(8, 4),\n .....:                  index=dates, columns=['A', 'B', 'C', 'D'])\n .....: \n\nIn [293]: df2 = df.copy() \n```", "```py\nIn [294]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],\n .....:                    'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],\n .....:                    'c': np.random.randn(7)})\n .....: \n\nIn [295]: df2\nOut[295]: \n a  b         c\n0    one  x -1.067137\n1    one  y  0.309500\n2    two  x -0.211056\n3    two  y -1.842023\n4    two  x -0.390820\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [296]: df2.duplicated('a')\nOut[296]: \n0    False\n1     True\n2    False\n3     True\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [297]: df2.duplicated('a', keep='last')\nOut[297]: \n0     True\n1    False\n2     True\n3     True\n4    False\n5    False\n6    False\ndtype: bool\n\nIn [298]: df2.duplicated('a', keep=False)\nOut[298]: \n0     True\n1     True\n2     True\n3     True\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [299]: df2.drop_duplicates('a')\nOut[299]: \n a  b         c\n0    one  x -1.067137\n2    two  x -0.211056\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [300]: df2.drop_duplicates('a', keep='last')\nOut[300]: \n a  b         c\n1    one  y  0.309500\n4    two  x -0.390820\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [301]: df2.drop_duplicates('a', keep=False)\nOut[301]: \n a  b         c\n5  three  x -1.964475\n6   four  x  1.298329 \n```", "```py\nIn [302]: df2.duplicated(['a', 'b'])\nOut[302]: \n0    False\n1    False\n2    False\n3    False\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [303]: df2.drop_duplicates(['a', 'b'])\nOut[303]: \n a  b         c\n0    one  x -1.067137\n1    one  y  0.309500\n2    two  x -0.211056\n3    two  y -1.842023\n5  three  x -1.964475\n6   four  x  1.298329 \n```", "```py\nIn [304]: df3 = pd.DataFrame({'a': np.arange(6),\n .....:                    'b': np.random.randn(6)},\n .....:                   index=['a', 'a', 'b', 'c', 'b', 'a'])\n .....: \n\nIn [305]: df3\nOut[305]: \n a         b\na  0  1.440455\na  1  2.456086\nb  2  1.038402\nc  3 -0.894409\nb  4  0.683536\na  5  3.082764\n\nIn [306]: df3.index.duplicated()\nOut[306]: array([False,  True, False, False,  True,  True])\n\nIn [307]: df3[~df3.index.duplicated()]\nOut[307]: \n a         b\na  0  1.440455\nb  2  1.038402\nc  3 -0.894409\n\nIn [308]: df3[~df3.index.duplicated(keep='last')]\nOut[308]: \n a         b\nc  3 -0.894409\nb  4  0.683536\na  5  3.082764\n\nIn [309]: df3[~df3.index.duplicated(keep=False)]\nOut[309]: \n a         b\nc  3 -0.894409 \n```", "```py\nIn [310]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nIn [311]: s.get('a')  # equivalent to s['a']\nOut[311]: 1\n\nIn [312]: s.get('x', default=-1)\nOut[312]: -1 \n```", "```py\nIn [313]: df = pd.DataFrame({'col': [\"A\", \"A\", \"B\", \"B\"],\n .....:                   'A': [80, 23, np.nan, 22],\n .....:                   'B': [80, 55, 76, 67]})\n .....: \n\nIn [314]: df\nOut[314]: \n col     A   B\n0   A  80.0  80\n1   A  23.0  55\n2   B   NaN  76\n3   B  22.0  67\n\nIn [315]: idx, cols = pd.factorize(df['col'])\n\nIn [316]: df.reindex(cols, axis=1).to_numpy()[np.arange(len(df)), idx]\nOut[316]: array([80., 23., 76., 67.]) \n```", "```py\nIn [317]: index = pd.Index(['e', 'd', 'a', 'b'])\n\nIn [318]: index\nOut[318]: Index(['e', 'd', 'a', 'b'], dtype='object')\n\nIn [319]: 'd' in index\nOut[319]: True \n```", "```py\nIn [320]: index = pd.Index([1, 5, 12])\n\nIn [321]: index\nOut[321]: Index([1, 5, 12], dtype='int64')\n\nIn [322]: 5 in index\nOut[322]: True \n```", "```py\nIn [323]: index = pd.Index(['e', 'd', 'a', 'b'], dtype=\"string\")\n\nIn [324]: index\nOut[324]: Index(['e', 'd', 'a', 'b'], dtype='string')\n\nIn [325]: index = pd.Index([1, 5, 12], dtype=\"int8\")\n\nIn [326]: index\nOut[326]: Index([1, 5, 12], dtype='int8')\n\nIn [327]: index = pd.Index([1, 5, 12], dtype=\"float32\")\n\nIn [328]: index\nOut[328]: Index([1.0, 5.0, 12.0], dtype='float32') \n```", "```py\nIn [329]: index = pd.Index(['e', 'd', 'a', 'b'], name='something')\n\nIn [330]: index.name\nOut[330]: 'something' \n```", "```py\nIn [331]: index = pd.Index(list(range(5)), name='rows')\n\nIn [332]: columns = pd.Index(['A', 'B', 'C'], name='cols')\n\nIn [333]: df = pd.DataFrame(np.random.randn(5, 3), index=index, columns=columns)\n\nIn [334]: df\nOut[334]: \ncols         A         B         C\nrows \n0     1.295989 -1.051694  1.340429\n1    -2.366110  0.428241  0.387275\n2     0.433306  0.929548  0.278094\n3     2.154730 -0.315628  0.264223\n4     1.126818  1.132290 -0.353310\n\nIn [335]: df['A']\nOut[335]: \nrows\n0    1.295989\n1   -2.366110\n2    0.433306\n3    2.154730\n4    1.126818\nName: A, dtype: float64 \n```", "```py\nIn [336]: ind = pd.Index([1, 2, 3])\n\nIn [337]: ind.rename(\"apple\")\nOut[337]: Index([1, 2, 3], dtype='int64', name='apple')\n\nIn [338]: ind\nOut[338]: Index([1, 2, 3], dtype='int64')\n\nIn [339]: ind = ind.set_names([\"apple\"])\n\nIn [340]: ind.name = \"bob\"\n\nIn [341]: ind\nOut[341]: Index([1, 2, 3], dtype='int64', name='bob') \n```", "```py\nIn [342]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])\n\nIn [343]: index\nOut[343]: \nMultiIndex([(0, 'one'),\n (0, 'two'),\n (1, 'one'),\n (1, 'two'),\n (2, 'one'),\n (2, 'two')],\n names=['first', 'second'])\n\nIn [344]: index.levels[1]\nOut[344]: Index(['one', 'two'], dtype='object', name='second')\n\nIn [345]: index.set_levels([\"a\", \"b\"], level=1)\nOut[345]: \nMultiIndex([(0, 'a'),\n (0, 'b'),\n (1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['first', 'second']) \n```", "```py\nIn [346]: a = pd.Index(['c', 'b', 'a'])\n\nIn [347]: b = pd.Index(['c', 'e', 'd'])\n\nIn [348]: a.difference(b)\nOut[348]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [349]: idx1 = pd.Index([1, 2, 3, 4])\n\nIn [350]: idx2 = pd.Index([2, 3, 4, 5])\n\nIn [351]: idx1.symmetric_difference(idx2)\nOut[351]: Index([1, 5], dtype='int64') \n```", "```py\nIn [352]: idx1 = pd.Index([0, 1, 2])\n\nIn [353]: idx2 = pd.Index([0.5, 1.5])\n\nIn [354]: idx1.union(idx2)\nOut[354]: Index([0.0, 0.5, 1.0, 1.5, 2.0], dtype='float64') \n```", "```py\nIn [355]: idx1 = pd.Index([1, np.nan, 3, 4])\n\nIn [356]: idx1\nOut[356]: Index([1.0, nan, 3.0, 4.0], dtype='float64')\n\nIn [357]: idx1.fillna(2)\nOut[357]: Index([1.0, 2.0, 3.0, 4.0], dtype='float64')\n\nIn [358]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'),\n .....:                         pd.NaT,\n .....:                         pd.Timestamp('2011-01-03')])\n .....: \n\nIn [359]: idx2\nOut[359]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)\n\nIn [360]: idx2.fillna(pd.Timestamp('2011-01-02'))\nOut[360]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [361]: data = pd.DataFrame({'a': ['bar', 'bar', 'foo', 'foo'],\n .....:                     'b': ['one', 'two', 'one', 'two'],\n .....:                     'c': ['z', 'y', 'x', 'w'],\n .....:                     'd': [1., 2., 3, 4]})\n .....: \n\nIn [362]: data\nOut[362]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [363]: indexed1 = data.set_index('c')\n\nIn [364]: indexed1\nOut[364]: \n a    b    d\nc \nz  bar  one  1.0\ny  bar  two  2.0\nx  foo  one  3.0\nw  foo  two  4.0\n\nIn [365]: indexed2 = data.set_index(['a', 'b'])\n\nIn [366]: indexed2\nOut[366]: \n c    d\na   b \nbar one  z  1.0\n two  y  2.0\nfoo one  x  3.0\n two  w  4.0 \n```", "```py\nIn [367]: frame = data.set_index('c', drop=False)\n\nIn [368]: frame = frame.set_index(['a', 'b'], append=True)\n\nIn [369]: frame\nOut[369]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0 \n```", "```py\nIn [370]: data.set_index('c', drop=False)\nOut[370]: \n a    b  c    d\nc \nz  bar  one  z  1.0\ny  bar  two  y  2.0\nx  foo  one  x  3.0\nw  foo  two  w  4.0 \n```", "```py\nIn [371]: data\nOut[371]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [372]: data.reset_index()\nOut[372]: \n index    a    b  c    d\n0      0  bar  one  z  1.0\n1      1  bar  two  y  2.0\n2      2  foo  one  x  3.0\n3      3  foo  two  w  4.0 \n```", "```py\nIn [373]: frame\nOut[373]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0\n\nIn [374]: frame.reset_index(level=1)\nOut[374]: \n a  c    d\nc b \nz one  bar  z  1.0\ny two  bar  y  2.0\nx one  foo  x  3.0\nw two  foo  w  4.0 \n```", "```py\nIn [375]: df_idx = pd.DataFrame(range(4))\n\nIn [376]: df_idx.index = pd.Index([10, 20, 30, 40], name=\"a\")\n\nIn [377]: df_idx\nOut[377]: \n 0\na \n10  0\n20  1\n30  2\n40  3 \n```", "```py\nIn [378]: dfmi = pd.DataFrame([list('abcd'),\n .....:                     list('efgh'),\n .....:                     list('ijkl'),\n .....:                     list('mnop')],\n .....:                    columns=pd.MultiIndex.from_product([['one', 'two'],\n .....:                                                        ['first', 'second']]))\n .....: \n\nIn [379]: dfmi\nOut[379]: \n one          two \n first second first second\n0     a      b     c      d\n1     e      f     g      h\n2     i      j     k      l\n3     m      n     o      p \n```", "```py\nIn [380]: dfmi['one']['second']\nOut[380]: \n0    b\n1    f\n2    j\n3    n\nName: second, dtype: object \n```", "```py\nIn [381]: dfmi.loc[:, ('one', 'second')]\nOut[381]: \n0    b\n1    f\n2    j\n3    n\nName: (one, second), dtype: object \n```", "```py\ndfmi.loc[:, ('one', 'second')] = value\n# becomes\ndfmi.loc.__setitem__((slice(None), ('one', 'second')), value) \n```", "```py\ndfmi['one']['second'] = value\n# becomes\ndfmi.__getitem__('one').__setitem__('second', value) \n```", "```py\ndef do_something(df):\n    foo = df[['bar', 'baz']]  # Is foo a view? A copy? Nobody knows!\n    # ... many lines here ...\n    # We don't know whether this will modify df or not!\n    foo['quux'] = value\n    return foo \n```", "```py\nIn [382]: dfb = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\n# This will show the SettingWithCopyWarning\n# but the frame values will be set\nIn [383]: dfb['c'][dfb['a'].str.startswith('o')] = 42 \n```", "```py\nIn [384]: with pd.option_context('mode.chained_assignment','warn'):\n .....:    dfb[dfb['a'].str.startswith('o')]['c'] = 42\n .....: \n```", "```py\nIn [385]: dfc = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\nIn [386]: dfd = dfc.copy()\n\n# Setting multiple items using a mask\nIn [387]: mask = dfd['a'].str.startswith('o')\n\nIn [388]: dfd.loc[mask, 'c'] = 42\n\nIn [389]: dfd\nOut[389]: \n a   c\n0    one  42\n1    one  42\n2    two   2\n3  three   3\n4    two   4\n5    one  42\n6    six   6\n\n# Setting a single item\nIn [390]: dfd = dfc.copy()\n\nIn [391]: dfd.loc[2, 'a'] = 11\n\nIn [392]: dfd\nOut[392]: \n a  c\n0    one  0\n1    one  1\n2     11  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [393]: dfd = dfc.copy()\n\nIn [394]: dfd['a'][2] = 111\n\nIn [395]: dfd\nOut[395]: \n a  c\n0    one  0\n1    one  1\n2    111  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [396]: with pd.option_context('mode.chained_assignment','raise'):\n .....:    dfd.loc[0]['a'] = 1111\n .....: \n---------------------------------------------------------------------------\nSettingWithCopyError  Traceback (most recent call last)\n<ipython-input-396-32ce785aaa5b> in ?()\n  1 with pd.option_context('mode.chained_assignment','raise'):\n----> 2     dfd.loc[0]['a'] = 1111\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self, key, value)\n  1284                 )\n  1285 \n  1286         check_dict_or_set_indexers(key)\n  1287         key = com.apply_if_callable(key, self)\n-> 1288         cacher_needs_updating = self._check_is_chained_assignment_possible()\n  1289 \n  1290         if key is Ellipsis:\n  1291             key = slice(None)\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self)\n  1489             ref = self._get_cacher()\n  1490             if ref is not None and ref._is_mixed_type:\n  1491                 self._check_setitem_copy(t=\"referent\", force=True)\n  1492             return True\n-> 1493         return super()._check_is_chained_assignment_possible()\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self)\n  4395         single-dtype meaning that the cacher should be updated following\n  4396         setting.\n  4397         \"\"\"\n  4398 if self._is_copy:\n-> 4399 self._check_setitem_copy(t=\"referent\")\n  4400 return False\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self, t, force)\n  4469 \"indexing.html#returning-a-view-versus-a-copy\"\n  4470 )\n  4471  \n  4472 if value == \"raise\":\n-> 4473 raise SettingWithCopyError(t)\n  4474 if value == \"warn\":\n  4475 warnings.warn(t, SettingWithCopyWarning, stacklevel=find_stack_level())\n\nSettingWithCopyError: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy \n```", "```py\nIn [1]: dates = pd.date_range('1/1/2000', periods=8)\n\nIn [2]: df = pd.DataFrame(np.random.randn(8, 4),\n ...:                  index=dates, columns=['A', 'B', 'C', 'D'])\n ...: \n\nIn [3]: df\nOut[3]: \n A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885 \n```", "```py\nIn [4]: s = df['A']\n\nIn [5]: s[dates[5]]\nOut[5]: -0.6736897080883706 \n```", "```py\nIn [6]: df\nOut[6]: \n A         B         C         D\n2000-01-01  0.469112 -0.282863 -1.509059 -1.135632\n2000-01-02  1.212112 -0.173215  0.119209 -1.044236\n2000-01-03 -0.861849 -2.104569 -0.494929  1.071804\n2000-01-04  0.721555 -0.706771 -1.039575  0.271860\n2000-01-05 -0.424972  0.567020  0.276232 -1.087401\n2000-01-06 -0.673690  0.113648 -1.478427  0.524988\n2000-01-07  0.404705  0.577046 -1.715002 -1.039268\n2000-01-08 -0.370647 -1.157892 -1.344312  0.844885\n\nIn [7]: df[['B', 'A']] = df[['A', 'B']]\n\nIn [8]: df\nOut[8]: \n A         B         C         D\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n2000-01-04 -0.706771  0.721555 -1.039575  0.271860\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885 \n```", "```py\nIn [9]: df[['A', 'B']]\nOut[9]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647\n\nIn [10]: df.loc[:, ['B', 'A']] = df[['A', 'B']]\n\nIn [11]: df[['A', 'B']]\nOut[11]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647 \n```", "```py\nIn [12]: df.loc[:, ['B', 'A']] = df[['A', 'B']].to_numpy()\n\nIn [13]: df[['A', 'B']]\nOut[13]: \n A         B\n2000-01-01  0.469112 -0.282863\n2000-01-02  1.212112 -0.173215\n2000-01-03 -0.861849 -2.104569\n2000-01-04  0.721555 -0.706771\n2000-01-05 -0.424972  0.567020\n2000-01-06 -0.673690  0.113648\n2000-01-07  0.404705  0.577046\n2000-01-08 -0.370647 -1.157892 \n```", "```py\nIn [14]: df[['A', 'B']]\nOut[14]: \n A         B\n2000-01-01  0.469112 -0.282863\n2000-01-02  1.212112 -0.173215\n2000-01-03 -0.861849 -2.104569\n2000-01-04  0.721555 -0.706771\n2000-01-05 -0.424972  0.567020\n2000-01-06 -0.673690  0.113648\n2000-01-07  0.404705  0.577046\n2000-01-08 -0.370647 -1.157892\n\nIn [15]: df.iloc[:, [1, 0]] = df[['A', 'B']]\n\nIn [16]: df[['A','B']]\nOut[16]: \n A         B\n2000-01-01 -0.282863  0.469112\n2000-01-02 -0.173215  1.212112\n2000-01-03 -2.104569 -0.861849\n2000-01-04 -0.706771  0.721555\n2000-01-05  0.567020 -0.424972\n2000-01-06  0.113648 -0.673690\n2000-01-07  0.577046  0.404705\n2000-01-08 -1.157892 -0.370647 \n```", "```py\nIn [17]: sa = pd.Series([1, 2, 3], index=list('abc'))\n\nIn [18]: dfa = df.copy() \n```", "```py\nIn [19]: sa.b\nOut[19]: 2\n\nIn [20]: dfa.A\nOut[20]: \n2000-01-01   -0.282863\n2000-01-02   -0.173215\n2000-01-03   -2.104569\n2000-01-04   -0.706771\n2000-01-05    0.567020\n2000-01-06    0.113648\n2000-01-07    0.577046\n2000-01-08   -1.157892\nFreq: D, Name: A, dtype: float64 \n```", "```py\nIn [21]: sa.a = 5\n\nIn [22]: sa\nOut[22]: \na    5\nb    2\nc    3\ndtype: int64\n\nIn [23]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists\n\nIn [24]: dfa\nOut[24]: \n A         B         C         D\n2000-01-01  0  0.469112 -1.509059 -1.135632\n2000-01-02  1  1.212112  0.119209 -1.044236\n2000-01-03  2 -0.861849 -0.494929  1.071804\n2000-01-04  3  0.721555 -1.039575  0.271860\n2000-01-05  4 -0.424972  0.276232 -1.087401\n2000-01-06  5 -0.673690 -1.478427  0.524988\n2000-01-07  6  0.404705 -1.715002 -1.039268\n2000-01-08  7 -0.370647 -1.344312  0.844885\n\nIn [25]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column\n\nIn [26]: dfa\nOut[26]: \n A         B         C         D\n2000-01-01  0  0.469112 -1.509059 -1.135632\n2000-01-02  1  1.212112  0.119209 -1.044236\n2000-01-03  2 -0.861849 -0.494929  1.071804\n2000-01-04  3  0.721555 -1.039575  0.271860\n2000-01-05  4 -0.424972  0.276232 -1.087401\n2000-01-06  5 -0.673690 -1.478427  0.524988\n2000-01-07  6  0.404705 -1.715002 -1.039268\n2000-01-08  7 -0.370647 -1.344312  0.844885 \n```", "```py\nIn [27]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})\n\nIn [28]: x.iloc[1] = {'x': 9, 'y': 99}\n\nIn [29]: x\nOut[29]: \n x   y\n0  1   3\n1  9  99\n2  3   5 \n```", "```py\nIn [30]: df_new = pd.DataFrame({'one': [1., 2., 3.]})\n\nIn [31]: df_new.two = [4, 5, 6]\n\nIn [32]: df_new\nOut[32]: \n one\n0  1.0\n1  2.0\n2  3.0 \n```", "```py\nIn [33]: s[:5]\nOut[33]: \n2000-01-01    0.469112\n2000-01-02    1.212112\n2000-01-03   -0.861849\n2000-01-04    0.721555\n2000-01-05   -0.424972\nFreq: D, Name: A, dtype: float64\n\nIn [34]: s[::2]\nOut[34]: \n2000-01-01    0.469112\n2000-01-03   -0.861849\n2000-01-05   -0.424972\n2000-01-07    0.404705\nFreq: 2D, Name: A, dtype: float64\n\nIn [35]: s[::-1]\nOut[35]: \n2000-01-08   -0.370647\n2000-01-07    0.404705\n2000-01-06   -0.673690\n2000-01-05   -0.424972\n2000-01-04    0.721555\n2000-01-03   -0.861849\n2000-01-02    1.212112\n2000-01-01    0.469112\nFreq: -1D, Name: A, dtype: float64 \n```", "```py\nIn [36]: s2 = s.copy()\n\nIn [37]: s2[:5] = 0\n\nIn [38]: s2\nOut[38]: \n2000-01-01    0.000000\n2000-01-02    0.000000\n2000-01-03    0.000000\n2000-01-04    0.000000\n2000-01-05    0.000000\n2000-01-06   -0.673690\n2000-01-07    0.404705\n2000-01-08   -0.370647\nFreq: D, Name: A, dtype: float64 \n```", "```py\nIn [39]: df[:3]\nOut[39]: \n A         B         C         D\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n\nIn [40]: df[::-1]\nOut[40]: \n A         B         C         D\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401\n2000-01-04 -0.706771  0.721555 -1.039575  0.271860\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632 \n```", "```py\n> In [41]: dfl = pd.DataFrame(np.random.randn(5, 4),\n>  ....:                   columns=list('ABCD'),\n>  ....:                   index=pd.date_range('20130101', periods=5))\n>  ....: \n> \n> In [42]: dfl\n> Out[42]: \n>  A         B         C         D\n> 2013-01-01  1.075770 -0.109050  1.643563 -1.469388\n> 2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n> 2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n> 2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061\n> 2013-01-05  0.895717  0.805244 -1.206412  2.565646\n> \n> In [43]: dfl.loc[2:3]\n> ---------------------------------------------------------------------------\n> TypeError  Traceback (most recent call last)\n> Cell In[43], line 1\n> ----> 1 dfl.loc[2:3]\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n>   1189 maybe_callable = com.apply_if_callable(key, self.obj)\n>   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n> -> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n>   1409 if isinstance(key, slice):\n>   1410     self._validate_key(key, axis)\n> -> 1411     return self._get_slice_axis(key, axis=axis)\n>   1412 elif com.is_bool_indexer(key):\n>   1413     return self._getbool_axis(key, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n>   1440     return obj.copy(deep=False)\n>   1442 labels = obj._get_axis(axis)\n> -> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n>   1445 if isinstance(indexer, slice):\n>   1446     return self.obj._slice(indexer, axis=axis)\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:682, in DatetimeIndex.slice_indexer(self, start, end, step)\n>   674 # GH#33146 if start and end are combinations of str and None and Index is not\n>   675 # monotonic, we can not use Index.slice_indexer because it does not honor the\n>   676 # actual elements, is only searching for start and end\n>   677 if (\n>   678     check_str_or_none(start)\n>   679     or check_str_or_none(end)\n>   680     or self.is_monotonic_increasing\n>   681 ):\n> --> 682     return Index.slice_indexer(self, start, end, step)\n>   684 mask = np.array(True)\n>   685 in_index = True\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n>   6618 def slice_indexer(\n>   6619     self,\n>   6620     start: Hashable | None = None,\n>   6621     end: Hashable | None = None,\n>   6622     step: int | None = None,\n>   6623 ) -> slice:\n>   6624  \"\"\"\n>   6625 Compute the slice indexer for input labels and step.\n>   6626  \n>  (...)\n>   6660 slice(1, 3, None)\n>   6661 \"\"\"\n> -> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n>   6664     # return a slice\n>   6665     if not is_scalar(start_slice):\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n>   6877 start_slice = None\n>   6878 if start is not None:\n> -> 6879     start_slice = self.get_slice_bound(start, \"left\")\n>   6880 if start_slice is None:\n>   6881     start_slice = 0\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:6794, in Index.get_slice_bound(self, label, side)\n>   6790 original_label = label\n>   6792 # For datetime indices label may be a string that has to be converted\n>   6793 # to datetime boundary according to its resolution.\n> -> 6794 label = self._maybe_cast_slice_bound(label, side)\n>   6796 # we need to look up the label\n>   6797 try:\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:642, in DatetimeIndex._maybe_cast_slice_bound(self, label, side)\n>   637 if isinstance(label, dt.date) and not isinstance(label, dt.datetime):\n>   638     # Pandas supports slicing with dates, treated as datetimes at midnight.\n>   639     # https://github.com/pandas-dev/pandas/issues/31501\n>   640     label = Timestamp(label).to_pydatetime()\n> --> 642 label = super()._maybe_cast_slice_bound(label, side)\n>   643 self._data._assert_tzawareness_compat(label)\n>   644 return Timestamp(label)\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/datetimelike.py:378, in DatetimeIndexOpsMixin._maybe_cast_slice_bound(self, label, side)\n>   376     return lower if side == \"left\" else upper\n>   377 elif not isinstance(label, self._data._recognized_scalars):\n> --> 378     self._raise_invalid_indexer(\"slice\", label)\n>   380 return label\n> \n> File ~/work/pandas/pandas/pandas/core/indexes/base.py:4301, in Index._raise_invalid_indexer(self, form, key, reraise)\n>   4299 if reraise is not lib.no_default:\n>   4300     raise TypeError(msg) from reraise\n> -> 4301 raise TypeError(msg)\n> \n> TypeError: cannot do slice indexing on DatetimeIndex with these indexers [2] of type int \n> ```", "```py\nIn [44]: dfl.loc['20130102':'20130104']\nOut[44]: \n A         B         C         D\n2013-01-02  0.357021 -0.674600 -1.776904 -0.968914\n2013-01-03 -1.294524  0.413738  0.276662 -0.472035\n2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061 \n```", "```py\nIn [45]: s1 = pd.Series(np.random.randn(6), index=list('abcdef'))\n\nIn [46]: s1\nOut[46]: \na    1.431256\nb    1.340309\nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [47]: s1.loc['c':]\nOut[47]: \nc   -1.170299\nd   -0.226169\ne    0.410835\nf    0.813850\ndtype: float64\n\nIn [48]: s1.loc['b']\nOut[48]: 1.3403088497993827 \n```", "```py\nIn [49]: s1.loc['c':] = 0\n\nIn [50]: s1\nOut[50]: \na    1.431256\nb    1.340309\nc    0.000000\nd    0.000000\ne    0.000000\nf    0.000000\ndtype: float64 \n```", "```py\nIn [51]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list('abcdef'),\n ....:                   columns=list('ABCD'))\n ....: \n\nIn [52]: df1\nOut[52]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nc  1.024180  0.569605  0.875906 -2.211372\nd  0.974466 -2.006747 -0.410001 -0.078638\ne  0.545952 -1.219217 -1.226825  0.769804\nf -1.281247 -0.727707 -0.121306 -0.097883\n\nIn [53]: df1.loc[['a', 'b', 'd'], :]\nOut[53]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nb  1.130127 -1.436737 -1.413681  1.607920\nd  0.974466 -2.006747 -0.410001 -0.078638 \n```", "```py\nIn [54]: df1.loc['d':, 'A':'C']\nOut[54]: \n A         B         C\nd  0.974466 -2.006747 -0.410001\ne  0.545952 -1.219217 -1.226825\nf -1.281247 -0.727707 -0.121306 \n```", "```py\nIn [55]: df1.loc['a']\nOut[55]: \nA    0.132003\nB   -0.827317\nC   -0.076467\nD   -1.187678\nName: a, dtype: float64 \n```", "```py\nIn [56]: df1.loc['a'] > 0\nOut[56]: \nA     True\nB    False\nC    False\nD    False\nName: a, dtype: bool\n\nIn [57]: df1.loc[:, df1.loc['a'] > 0]\nOut[57]: \n A\na  0.132003\nb  1.130127\nc  1.024180\nd  0.974466\ne  0.545952\nf -1.281247 \n```", "```py\nIn [58]: mask = pd.array([True, False, True, False, pd.NA, False], dtype=\"boolean\")\n\nIn [59]: mask\nOut[59]: \n<BooleanArray>\n[True, False, True, False, <NA>, False]\nLength: 6, dtype: boolean\n\nIn [60]: df1[mask]\nOut[60]: \n A         B         C         D\na  0.132003 -0.827317 -0.076467 -1.187678\nc  1.024180  0.569605  0.875906 -2.211372 \n```", "```py\n# this is also equivalent to ``df1.at['a','A']``\nIn [61]: df1.loc['a', 'A']\nOut[61]: 0.13200317033032932 \n```", "```py\nIn [62]: s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])\n\nIn [63]: s.loc[3:5]\nOut[63]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [64]: s.sort_index()\nOut[64]: \n0    a\n2    c\n3    b\n4    e\n5    d\ndtype: object\n\nIn [65]: s.sort_index().loc[1:6]\nOut[65]: \n2    c\n3    b\n4    e\n5    d\ndtype: object \n```", "```py\nIn [66]: s = pd.Series(list('abcdef'), index=[0, 3, 2, 5, 4, 2])\n\nIn [67]: s.loc[3:5]\nOut[67]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [62]: s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])\n\nIn [63]: s.loc[3:5]\nOut[63]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [64]: s.sort_index()\nOut[64]: \n0    a\n2    c\n3    b\n4    e\n5    d\ndtype: object\n\nIn [65]: s.sort_index().loc[1:6]\nOut[65]: \n2    c\n3    b\n4    e\n5    d\ndtype: object \n```", "```py\nIn [66]: s = pd.Series(list('abcdef'), index=[0, 3, 2, 5, 4, 2])\n\nIn [67]: s.loc[3:5]\nOut[67]: \n3    b\n2    c\n5    d\ndtype: object \n```", "```py\nIn [68]: s1 = pd.Series(np.random.randn(5), index=list(range(0, 10, 2)))\n\nIn [69]: s1\nOut[69]: \n0    0.695775\n2    0.341734\n4    0.959726\n6   -1.110336\n8   -0.619976\ndtype: float64\n\nIn [70]: s1.iloc[:3]\nOut[70]: \n0    0.695775\n2    0.341734\n4    0.959726\ndtype: float64\n\nIn [71]: s1.iloc[3]\nOut[71]: -1.110336102891167 \n```", "```py\nIn [72]: s1.iloc[:3] = 0\n\nIn [73]: s1\nOut[73]: \n0    0.000000\n2    0.000000\n4    0.000000\n6   -1.110336\n8   -0.619976\ndtype: float64 \n```", "```py\nIn [74]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list(range(0, 12, 2)),\n ....:                   columns=list(range(0, 8, 2)))\n ....: \n\nIn [75]: df1\nOut[75]: \n 0         2         4         6\n0   0.149748 -0.732339  0.687738  0.176444\n2   0.403310 -0.154951  0.301624 -2.179861\n4  -1.369849 -0.954208  1.462696 -1.743161\n6  -0.826591 -0.345352  1.314232  0.690579\n8   0.995761  2.396780  0.014871  3.357427\n10 -0.317441 -1.236269  0.896171 -0.487602 \n```", "```py\nIn [76]: df1.iloc[:3]\nOut[76]: \n 0         2         4         6\n0  0.149748 -0.732339  0.687738  0.176444\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161\n\nIn [77]: df1.iloc[1:5, 2:4]\nOut[77]: \n 4         6\n2  0.301624 -2.179861\n4  1.462696 -1.743161\n6  1.314232  0.690579\n8  0.014871  3.357427 \n```", "```py\nIn [78]: df1.iloc[[1, 3, 5], [1, 3]]\nOut[78]: \n 2         6\n2  -0.154951 -2.179861\n6  -0.345352  0.690579\n10 -1.236269 -0.487602 \n```", "```py\nIn [79]: df1.iloc[1:3, :]\nOut[79]: \n 0         2         4         6\n2  0.403310 -0.154951  0.301624 -2.179861\n4 -1.369849 -0.954208  1.462696 -1.743161 \n```", "```py\nIn [80]: df1.iloc[:, 1:3]\nOut[80]: \n 2         4\n0  -0.732339  0.687738\n2  -0.154951  0.301624\n4  -0.954208  1.462696\n6  -0.345352  1.314232\n8   2.396780  0.014871\n10 -1.236269  0.896171 \n```", "```py\n# this is also equivalent to ``df1.iat[1,1]``\nIn [81]: df1.iloc[1, 1]\nOut[81]: -0.1549507744249032 \n```", "```py\nIn [82]: df1.iloc[1]\nOut[82]: \n0    0.403310\n2   -0.154951\n4    0.301624\n6   -2.179861\nName: 2, dtype: float64 \n```", "```py\n# these are allowed in Python/NumPy.\nIn [83]: x = list('abcdef')\n\nIn [84]: x\nOut[84]: ['a', 'b', 'c', 'd', 'e', 'f']\n\nIn [85]: x[4:10]\nOut[85]: ['e', 'f']\n\nIn [86]: x[8:10]\nOut[86]: []\n\nIn [87]: s = pd.Series(x)\n\nIn [88]: s\nOut[88]: \n0    a\n1    b\n2    c\n3    d\n4    e\n5    f\ndtype: object\n\nIn [89]: s.iloc[4:10]\nOut[89]: \n4    e\n5    f\ndtype: object\n\nIn [90]: s.iloc[8:10]\nOut[90]: Series([], dtype: object) \n```", "```py\nIn [91]: dfl = pd.DataFrame(np.random.randn(5, 2), columns=list('AB'))\n\nIn [92]: dfl\nOut[92]: \n A         B\n0 -0.082240 -2.182937\n1  0.380396  0.084844\n2  0.432390  1.519970\n3 -0.493662  0.600178\n4  0.274230  0.132885\n\nIn [93]: dfl.iloc[:, 2:3]\nOut[93]: \nEmpty DataFrame\nColumns: []\nIndex: [0, 1, 2, 3, 4]\n\nIn [94]: dfl.iloc[:, 1:3]\nOut[94]: \n B\n0 -2.182937\n1  0.084844\n2  1.519970\n3  0.600178\n4  0.132885\n\nIn [95]: dfl.iloc[4:6]\nOut[95]: \n A         B\n4  0.27423  0.132885 \n```", "```py\nIn [96]: dfl.iloc[[4, 5, 6]]\n---------------------------------------------------------------------------\nIndexError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1714, in _iLocIndexer._get_list_axis(self, key, axis)\n  1713 try:\n-> 1714     return self.obj._take_with_is_copy(key, axis=axis)\n  1715 except IndexError as err:\n  1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4153, in NDFrame._take_with_is_copy(self, indices, axis)\n  4144  \"\"\"\n  4145 Internal version of the `take` method that sets the `_is_copy`\n  4146 attribute to keep track of the parent dataframe (using in indexing\n (...)\n  4151 See the docstring of `take` for full explanation of the parameters.\n  4152 \"\"\"\n-> 4153 result = self.take(indices=indices, axis=axis)\n  4154 # Maybe set copy if we didn't actually change the index.\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4133, in NDFrame.take(self, indices, axis, **kwargs)\n  4129     indices = np.arange(\n  4130         indices.start, indices.stop, indices.step, dtype=np.intp\n  4131     )\n-> 4133 new_data = self._mgr.take(\n  4134     indices,\n  4135     axis=self._get_block_manager_axis(axis),\n  4136     verify=True,\n  4137 )\n  4138 return self._constructor_from_mgr(new_data, axes=new_data.axes).__finalize__(\n  4139     self, method=\"take\"\n  4140 )\n\nFile ~/work/pandas/pandas/pandas/core/internals/managers.py:891, in BaseBlockManager.take(self, indexer, axis, verify)\n  890 n = self.shape[axis]\n--> 891 indexer = maybe_convert_indices(indexer, n, verify=verify)\n  893 new_labels = self.axes[axis].take(indexer)\n\nFile ~/work/pandas/pandas/pandas/core/indexers/utils.py:282, in maybe_convert_indices(indices, n, verify)\n  281     if mask.any():\n--> 282         raise IndexError(\"indices are out-of-bounds\")\n  283 return indices\n\nIndexError: indices are out-of-bounds\n\nThe above exception was the direct cause of the following exception:\n\nIndexError  Traceback (most recent call last)\nCell In[96], line 1\n----> 1 dfl.iloc[[4, 5, 6]]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1743, in _iLocIndexer._getitem_axis(self, key, axis)\n  1741 # a list of integers\n  1742 elif is_list_like_indexer(key):\n-> 1743     return self._get_list_axis(key, axis=axis)\n  1745 # a single integer\n  1746 else:\n  1747     key = item_from_zerodim(key)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1717, in _iLocIndexer._get_list_axis(self, key, axis)\n  1714     return self.obj._take_with_is_copy(key, axis=axis)\n  1715 except IndexError as err:\n  1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d\n-> 1717     raise IndexError(\"positional indexers are out-of-bounds\") from err\n\nIndexError: positional indexers are out-of-bounds \n```", "```py\nIn [97]: dfl.iloc[:, 4]\n---------------------------------------------------------------------------\nIndexError  Traceback (most recent call last)\nCell In[97], line 1\n----> 1 dfl.iloc[:, 4]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1690, in _iLocIndexer._getitem_tuple(self, tup)\n  1689 def _getitem_tuple(self, tup: tuple):\n-> 1690     tup = self._validate_tuple_indexer(tup)\n  1691     with suppress(IndexingError):\n  1692         return self._getitem_lowerdim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:966, in _LocationIndexer._validate_tuple_indexer(self, key)\n  964 for i, k in enumerate(key):\n  965     try:\n--> 966         self._validate_key(k, i)\n  967     except ValueError as err:\n  968         raise ValueError(\n  969             \"Location based indexing can only have \"\n  970             f\"[{self._valid_types}] types\"\n  971         ) from err\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1592, in _iLocIndexer._validate_key(self, key, axis)\n  1590     return\n  1591 elif is_integer(key):\n-> 1592     self._validate_integer(key, axis)\n  1593 elif isinstance(key, tuple):\n  1594     # a tuple should already have been caught by this point\n  1595     # so don't treat a tuple as a valid indexer\n  1596     raise IndexingError(\"Too many indexers\")\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1685, in _iLocIndexer._validate_integer(self, key, axis)\n  1683 len_axis = len(self.obj._get_axis(axis))\n  1684 if key >= len_axis or key < -len_axis:\n-> 1685     raise IndexError(\"single positional indexer is out-of-bounds\")\n\nIndexError: single positional indexer is out-of-bounds \n```", "```py\nIn [98]: df1 = pd.DataFrame(np.random.randn(6, 4),\n ....:                   index=list('abcdef'),\n ....:                   columns=list('ABCD'))\n ....: \n\nIn [99]: df1\nOut[99]: \n A         B         C         D\na -0.023688  2.410179  1.450520  0.206053\nb -0.251905 -2.213588  1.063327  1.266143\nc  0.299368 -0.863838  0.408204 -1.048089\nd -0.025747 -0.988387  0.094055  1.262731\ne  1.289997  0.082423 -0.055758  0.536580\nf -0.489682  0.369374 -0.034571 -2.484478\n\nIn [100]: df1.loc[lambda df: df['A'] > 0, :]\nOut[100]: \n A         B         C         D\nc  0.299368 -0.863838  0.408204 -1.048089\ne  1.289997  0.082423 -0.055758  0.536580\n\nIn [101]: df1.loc[:, lambda df: ['A', 'B']]\nOut[101]: \n A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [102]: df1.iloc[:, lambda df: [0, 1]]\nOut[102]: \n A         B\na -0.023688  2.410179\nb -0.251905 -2.213588\nc  0.299368 -0.863838\nd -0.025747 -0.988387\ne  1.289997  0.082423\nf -0.489682  0.369374\n\nIn [103]: df1[lambda df: df.columns[0]]\nOut[103]: \na   -0.023688\nb   -0.251905\nc    0.299368\nd   -0.025747\ne    1.289997\nf   -0.489682\nName: A, dtype: float64 \n```", "```py\nIn [104]: df1['A'].loc[lambda s: s > 0]\nOut[104]: \nc    0.299368\ne    1.289997\nName: A, dtype: float64 \n```", "```py\nIn [105]: bb = pd.read_csv('data/baseball.csv', index_col='id')\n\nIn [106]: (bb.groupby(['year', 'team']).sum(numeric_only=True)\n .....:   .loc[lambda df: df['r'] > 100])\n .....: \nOut[106]: \n stint    g    ab    r    h  X2b  ...     so   ibb   hbp    sh    sf  gidp\nyear team                                   ... \n2007 CIN       6  379   745  101  203   35  ...  127.0  14.0   1.0   1.0  15.0  18.0\n DET       5  301  1062  162  283   54  ...  176.0   3.0  10.0   4.0   8.0  28.0\n HOU       4  311   926  109  218   47  ...  212.0   3.0   9.0  16.0   6.0  17.0\n LAN      11  413  1021  153  293   61  ...  141.0   8.0   9.0   3.0   8.0  29.0\n NYN      13  622  1854  240  509  101  ...  310.0  24.0  23.0  18.0  15.0  48.0\n SFN       5  482  1305  198  337   67  ...  188.0  51.0   8.0  16.0   6.0  41.0\n TEX       2  198   729  115  200   40  ...  140.0   4.0   5.0   2.0   8.0  16.0\n TOR       4  459  1408  187  378   96  ...  265.0  16.0  12.0   4.0  16.0  38.0\n\n[8 rows x 18 columns] \n```", "```py\nIn [107]: dfd = pd.DataFrame({'A': [1, 2, 3],\n .....:                    'B': [4, 5, 6]},\n .....:                   index=list('abc'))\n .....: \n\nIn [108]: dfd\nOut[108]: \n A  B\na  1  4\nb  2  5\nc  3  6\n\nIn [109]: dfd.loc[dfd.index[[0, 2]], 'A']\nOut[109]: \na    1\nc    3\nName: A, dtype: int64 \n```", "```py\nIn [110]: dfd.iloc[[0, 2], dfd.columns.get_loc('A')]\nOut[110]: \na    1\nc    3\nName: A, dtype: int64 \n```", "```py\nIn [111]: dfd.iloc[[0, 2], dfd.columns.get_indexer(['A', 'B'])]\nOut[111]: \n A  B\na  1  4\nc  3  6 \n```", "```py\nIn [112]: s = pd.Series([1, 2, 3])\n\nIn [113]: s.reindex([1, 2, 3])\nOut[113]: \n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [114]: labels = [1, 2, 3]\n\nIn [115]: s.loc[s.index.intersection(labels)]\nOut[115]: \n1    2\n2    3\ndtype: int64 \n```", "```py\nIn [116]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])\n\nIn [117]: labels = ['c', 'd']\n\nIn [118]: s.reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[118], line 1\n----> 1 s.reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [119]: s.loc[s.index.intersection(labels)].reindex(labels)\nOut[119]: \nc    3.0\nd    NaN\ndtype: float64 \n```", "```py\nIn [120]: labels = ['a', 'd']\n\nIn [121]: s.loc[s.index.intersection(labels)].reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[121], line 1\n----> 1 s.loc[s.index.intersection(labels)].reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [112]: s = pd.Series([1, 2, 3])\n\nIn [113]: s.reindex([1, 2, 3])\nOut[113]: \n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [114]: labels = [1, 2, 3]\n\nIn [115]: s.loc[s.index.intersection(labels)]\nOut[115]: \n1    2\n2    3\ndtype: int64 \n```", "```py\nIn [116]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])\n\nIn [117]: labels = ['c', 'd']\n\nIn [118]: s.reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[118], line 1\n----> 1 s.reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [119]: s.loc[s.index.intersection(labels)].reindex(labels)\nOut[119]: \nc    3.0\nd    NaN\ndtype: float64 \n```", "```py\nIn [120]: labels = ['a', 'd']\n\nIn [121]: s.loc[s.index.intersection(labels)].reindex(labels)\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nCell In[121], line 1\n----> 1 s.loc[s.index.intersection(labels)].reindex(labels)\n\nFile ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)\n  5136 @doc(\n  5137     NDFrame.reindex,  # type: ignore[has-type]\n  5138     klass=_shared_doc_kwargs[\"klass\"],\n   (...)\n  5151     tolerance=None,\n  5152 ) -> Series:\n-> 5153     return super().reindex(\n  5154         index=index,\n  5155         method=method,\n  5156         copy=copy,\n  5157         level=level,\n  5158         fill_value=fill_value,\n  5159         limit=limit,\n  5160         tolerance=tolerance,\n  5161     )\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)\n  5607     return self._reindex_multi(axes, copy, fill_value)\n  5609 # perform the reindex on the axes\n-> 5610 return self._reindex_axes(\n  5611     axes, level, limit, tolerance, method, fill_value, copy\n  5612 ).__finalize__(self, method=\"reindex\")\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)\n  5630     continue\n  5632 ax = self._get_axis(a)\n-> 5633 new_index, indexer = ax.reindex(\n  5634     labels, level=level, limit=limit, tolerance=tolerance, method=method\n  5635 )\n  5637 axis = self._get_axis_number(a)\n  5638 obj = obj._reindex_with_indexers(\n  5639     {axis: [new_index, indexer]},\n  5640     fill_value=fill_value,\n  5641     copy=copy,\n  5642     allow_dups=False,\n  5643 )\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)\n  4426     raise ValueError(\"cannot handle a non-unique multi-index!\")\n  4427 elif not self.is_unique:\n  4428     # GH#42568\n-> 4429     raise ValueError(\"cannot reindex on an axis with duplicate labels\")\n  4430 else:\n  4431     indexer, _ = self.get_indexer_non_unique(target)\n\nValueError: cannot reindex on an axis with duplicate labels \n```", "```py\nIn [122]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# When no arguments are passed, returns 1 row.\nIn [123]: s.sample()\nOut[123]: \n4    4\ndtype: int64\n\n# One may specify either a number of rows:\nIn [124]: s.sample(n=3)\nOut[124]: \n0    0\n4    4\n1    1\ndtype: int64\n\n# Or a fraction of the rows:\nIn [125]: s.sample(frac=0.5)\nOut[125]: \n5    5\n3    3\n1    1\ndtype: int64 \n```", "```py\nIn [126]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\n# Without replacement (default):\nIn [127]: s.sample(n=6, replace=False)\nOut[127]: \n0    0\n1    1\n5    5\n3    3\n2    2\n4    4\ndtype: int64\n\n# With replacement:\nIn [128]: s.sample(n=6, replace=True)\nOut[128]: \n0    0\n4    4\n3    3\n2    2\n4    4\n4    4\ndtype: int64 \n```", "```py\nIn [129]: s = pd.Series([0, 1, 2, 3, 4, 5])\n\nIn [130]: example_weights = [0, 0, 0.2, 0.2, 0.2, 0.4]\n\nIn [131]: s.sample(n=3, weights=example_weights)\nOut[131]: \n5    5\n4    4\n3    3\ndtype: int64\n\n# Weights will be re-normalized automatically\nIn [132]: example_weights2 = [0.5, 0, 0, 0, 0, 0]\n\nIn [133]: s.sample(n=1, weights=example_weights2)\nOut[133]: \n0    0\ndtype: int64 \n```", "```py\nIn [134]: df2 = pd.DataFrame({'col1': [9, 8, 7, 6],\n .....:                    'weight_column': [0.5, 0.4, 0.1, 0]})\n .....: \n\nIn [135]: df2.sample(n=3, weights='weight_column')\nOut[135]: \n col1  weight_column\n1     8            0.4\n0     9            0.5\n2     7            0.1 \n```", "```py\nIn [136]: df3 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\nIn [137]: df3.sample(n=1, axis=1)\nOut[137]: \n col1\n0     1\n1     2\n2     3 \n```", "```py\nIn [138]: df4 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})\n\n# With a given seed, the sample will always draw the same rows.\nIn [139]: df4.sample(n=2, random_state=2)\nOut[139]: \n col1  col2\n2     3     4\n1     2     3\n\nIn [140]: df4.sample(n=2, random_state=2)\nOut[140]: \n col1  col2\n2     3     4\n1     2     3 \n```", "```py\nIn [141]: se = pd.Series([1, 2, 3])\n\nIn [142]: se\nOut[142]: \n0    1\n1    2\n2    3\ndtype: int64\n\nIn [143]: se[5] = 5.\n\nIn [144]: se\nOut[144]: \n0    1.0\n1    2.0\n2    3.0\n5    5.0\ndtype: float64 \n```", "```py\nIn [145]: dfi = pd.DataFrame(np.arange(6).reshape(3, 2),\n .....:                   columns=['A', 'B'])\n .....: \n\nIn [146]: dfi\nOut[146]: \n A  B\n0  0  1\n1  2  3\n2  4  5\n\nIn [147]: dfi.loc[:, 'C'] = dfi.loc[:, 'A']\n\nIn [148]: dfi\nOut[148]: \n A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4 \n```", "```py\nIn [149]: dfi.loc[3] = 5\n\nIn [150]: dfi\nOut[150]: \n A  B  C\n0  0  1  0\n1  2  3  2\n2  4  5  4\n3  5  5  5 \n```", "```py\nIn [151]: s.iat[5]\nOut[151]: 5\n\nIn [152]: df.at[dates[5], 'A']\nOut[152]: 0.1136484096888855\n\nIn [153]: df.iat[3, 0]\nOut[153]: -0.7067711336300845 \n```", "```py\nIn [154]: df.at[dates[5], 'E'] = 7\n\nIn [155]: df.iat[3, 0] = 7 \n```", "```py\nIn [156]: df.at[dates[-1] + pd.Timedelta('1 day'), 0] = 7\n\nIn [157]: df\nOut[157]: \n A         B         C         D    E    0\n2000-01-01 -0.282863  0.469112 -1.509059 -1.135632  NaN  NaN\n2000-01-02 -0.173215  1.212112  0.119209 -1.044236  NaN  NaN\n2000-01-03 -2.104569 -0.861849 -0.494929  1.071804  NaN  NaN\n2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN  NaN\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN  NaN\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0  NaN\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN  NaN\n2000-01-08 -1.157892 -0.370647 -1.344312  0.844885  NaN  NaN\n2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0 \n```", "```py\nIn [158]: s = pd.Series(range(-3, 4))\n\nIn [159]: s\nOut[159]: \n0   -3\n1   -2\n2   -1\n3    0\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [160]: s[s > 0]\nOut[160]: \n4    1\n5    2\n6    3\ndtype: int64\n\nIn [161]: s[(s < -1) | (s > 0.5)]\nOut[161]: \n0   -3\n1   -2\n4    1\n5    2\n6    3\ndtype: int64\n\nIn [162]: s[~(s < 0)]\nOut[162]: \n3    0\n4    1\n5    2\n6    3\ndtype: int64 \n```", "```py\nIn [163]: df[df['A'] > 0]\nOut[163]: \n A         B         C         D    E   0\n2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN NaN\n2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN NaN\n2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0 NaN\n2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN NaN \n```", "```py\nIn [164]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],\n .....:                    'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],\n .....:                    'c': np.random.randn(7)})\n .....: \n\n# only want 'two' or 'three'\nIn [165]: criterion = df2['a'].map(lambda x: x.startswith('t'))\n\nIn [166]: df2[criterion]\nOut[166]: \n a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# equivalent but slower\nIn [167]: df2[[x.startswith('t') for x in df2['a']]]\nOut[167]: \n a  b         c\n2    two  y  0.041290\n3  three  x  0.361719\n4    two  y -0.238075\n\n# Multiple criteria\nIn [168]: df2[criterion & (df2['b'] == 'x')]\nOut[168]: \n a  b         c\n3  three  x  0.361719 \n```", "```py\nIn [169]: df2.loc[criterion & (df2['b'] == 'x'), 'b':'c']\nOut[169]: \n b         c\n3  x  0.361719 \n```", "```py\nIn [170]: df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n .....:                  index=list('abc'),\n .....:                  columns=['A', 'B'])\n .....: \n\nIn [171]: s = (df['A'] > 2)\n\nIn [172]: s\nOut[172]: \na    False\nb     True\nc     True\nName: A, dtype: bool\n\nIn [173]: df.loc[s, 'B']\nOut[173]: \nb    4\nc    6\nName: B, dtype: int64\n\nIn [174]: df.iloc[s.values, 1]\nOut[174]: \nb    4\nc    6\nName: B, dtype: int64 \n```", "```py\nIn [175]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')\n\nIn [176]: s\nOut[176]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [177]: s.isin([2, 4, 6])\nOut[177]: \n4    False\n3    False\n2     True\n1    False\n0     True\ndtype: bool\n\nIn [178]: s[s.isin([2, 4, 6])]\nOut[178]: \n2    2\n0    4\ndtype: int64 \n```", "```py\nIn [179]: s[s.index.isin([2, 4, 6])]\nOut[179]: \n4    0\n2    2\ndtype: int64\n\n# compare it to the following\nIn [180]: s.reindex([2, 4, 6])\nOut[180]: \n2    2.0\n4    0.0\n6    NaN\ndtype: float64 \n```", "```py\nIn [181]: s_mi = pd.Series(np.arange(6),\n .....:                 index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))\n .....: \n\nIn [182]: s_mi\nOut[182]: \n0  a    0\n b    1\n c    2\n1  a    3\n b    4\n c    5\ndtype: int64\n\nIn [183]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]\nOut[183]: \n0  c    2\n1  a    3\ndtype: int64\n\nIn [184]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]\nOut[184]: \n0  a    0\n c    2\n1  a    3\n c    5\ndtype: int64 \n```", "```py\nIn [185]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f', 'n'],\n .....:                   'ids2': ['a', 'n', 'c', 'n']})\n .....: \n\nIn [186]: values = ['a', 'b', 1, 3]\n\nIn [187]: df.isin(values)\nOut[187]: \n vals    ids   ids2\n0   True   True   True\n1  False   True  False\n2   True  False  False\n3  False  False  False \n```", "```py\nIn [188]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [189]: df.isin(values)\nOut[189]: \n vals    ids   ids2\n0   True   True  False\n1  False   True  False\n2   True  False  False\n3  False  False  False \n```", "```py\nIn [190]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}\n\nIn [191]: ~df.isin(values)\nOut[191]: \n vals    ids  ids2\n0  False  False  True\n1   True  False  True\n2  False   True  True\n3   True   True  True \n```", "```py\nIn [192]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}\n\nIn [193]: row_mask = df.isin(values).all(1)\n\nIn [194]: df[row_mask]\nOut[194]: \n vals ids ids2\n0     1   a    a \n```", "```py\nIn [195]: s[s > 0]\nOut[195]: \n3    1\n2    2\n1    3\n0    4\ndtype: int64 \n```", "```py\nIn [196]: s.where(s > 0)\nOut[196]: \n4    NaN\n3    1.0\n2    2.0\n1    3.0\n0    4.0\ndtype: float64 \n```", "```py\nIn [197]: dates = pd.date_range('1/1/2000', periods=8)\n\nIn [198]: df = pd.DataFrame(np.random.randn(8, 4),\n .....:                  index=dates, columns=['A', 'B', 'C', 'D'])\n .....: \n\nIn [199]: df[df < 0]\nOut[199]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838 \n```", "```py\nIn [200]: df.where(df < 0, -df)\nOut[200]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166\n2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824\n2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059\n2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203\n2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416\n2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048\n2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838 \n```", "```py\nIn [201]: s2 = s.copy()\n\nIn [202]: s2[s2 < 0] = 0\n\nIn [203]: s2\nOut[203]: \n4    0\n3    1\n2    2\n1    3\n0    4\ndtype: int64\n\nIn [204]: df2 = df.copy()\n\nIn [205]: df2[df2 < 0] = 0\n\nIn [206]: df2\nOut[206]: \n A         B         C         D\n2000-01-01  0.000000  0.000000  0.485855  0.245166\n2000-01-02  0.000000  0.390389  0.000000  1.655824\n2000-01-03  0.000000  0.299674  0.000000  0.281059\n2000-01-04  0.846958  0.000000  0.600705  0.000000\n2000-01-05  0.669692  0.000000  0.000000  0.342416\n2000-01-06  0.868584  0.000000  2.297780  0.000000\n2000-01-07  0.000000  0.000000  0.168904  0.000000\n2000-01-08  0.801196  1.392071  0.000000  0.000000 \n```", "```py\nIn [207]: df.where(df < 0, -df) == np.where(df < 0, df, -df)\nOut[207]: \n A     B     C     D\n2000-01-01  True  True  True  True\n2000-01-02  True  True  True  True\n2000-01-03  True  True  True  True\n2000-01-04  True  True  True  True\n2000-01-05  True  True  True  True\n2000-01-06  True  True  True  True\n2000-01-07  True  True  True  True\n2000-01-08  True  True  True  True \n```", "```py\nIn [208]: df2 = df.copy()\n\nIn [209]: df2[df2[1:4] > 0] = 3\n\nIn [210]: df2\nOut[210]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525  0.485855  0.245166\n2000-01-02 -0.352480  3.000000 -1.192319  3.000000\n2000-01-03 -0.864883  3.000000 -0.227870  3.000000\n2000-01-04  3.000000 -1.222082  3.000000 -1.233203\n2000-01-05  0.669692 -0.605656 -1.169184  0.342416\n2000-01-06  0.868584 -0.948458  2.297780 -0.684718\n2000-01-07 -2.670153 -0.114722  0.168904 -0.048048\n2000-01-08  0.801196  1.392071 -0.048788 -0.808838 \n```", "```py\nIn [211]: df2 = df.copy()\n\nIn [212]: df2.where(df2 > 0, df2['A'], axis='index')\nOut[212]: \n A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196 \n```", "```py\nIn [213]: df2 = df.copy()\n\nIn [214]: df.apply(lambda x, y: x.where(x > 0, y), y=df['A'])\nOut[214]: \n A         B         C         D\n2000-01-01 -2.104139 -2.104139  0.485855  0.245166\n2000-01-02 -0.352480  0.390389 -0.352480  1.655824\n2000-01-03 -0.864883  0.299674 -0.864883  0.281059\n2000-01-04  0.846958  0.846958  0.600705  0.846958\n2000-01-05  0.669692  0.669692  0.669692  0.342416\n2000-01-06  0.868584  0.868584  2.297780  0.868584\n2000-01-07 -2.670153 -2.670153  0.168904 -2.670153\n2000-01-08  0.801196  1.392071  0.801196  0.801196 \n```", "```py\nIn [215]: df3 = pd.DataFrame({'A': [1, 2, 3],\n .....:                    'B': [4, 5, 6],\n .....:                    'C': [7, 8, 9]})\n .....: \n\nIn [216]: df3.where(lambda x: x > 4, lambda x: x + 10)\nOut[216]: \n A   B  C\n0  11  14  7\n1  12   5  8\n2  13   6  9 \n```", "```py\nIn [217]: s.mask(s >= 0)\nOut[217]: \n4   NaN\n3   NaN\n2   NaN\n1   NaN\n0   NaN\ndtype: float64\n\nIn [218]: df.mask(df >= 0)\nOut[218]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838 \n```", "```py\nIn [217]: s.mask(s >= 0)\nOut[217]: \n4   NaN\n3   NaN\n2   NaN\n1   NaN\n0   NaN\ndtype: float64\n\nIn [218]: df.mask(df >= 0)\nOut[218]: \n A         B         C         D\n2000-01-01 -2.104139 -1.309525       NaN       NaN\n2000-01-02 -0.352480       NaN -1.192319       NaN\n2000-01-03 -0.864883       NaN -0.227870       NaN\n2000-01-04       NaN -1.222082       NaN -1.233203\n2000-01-05       NaN -0.605656 -1.169184       NaN\n2000-01-06       NaN -0.948458       NaN -0.684718\n2000-01-07 -2.670153 -0.114722       NaN -0.048048\n2000-01-08       NaN       NaN -0.048788 -0.808838 \n```", "```py\nIn [219]: df = pd.DataFrame({'col1': list('ABBC'), 'col2': list('ZZXY')})\n\nIn [220]: df['color'] = np.where(df['col2'] == 'Z', 'green', 'red')\n\nIn [221]: df\nOut[221]: \n col1 col2  color\n0    A    Z  green\n1    B    Z  green\n2    B    X    red\n3    C    Y    red \n```", "```py\nIn [222]: conditions = [\n .....:    (df['col2'] == 'Z') & (df['col1'] == 'A'),\n .....:    (df['col2'] == 'Z') & (df['col1'] == 'B'),\n .....:    (df['col1'] == 'B')\n .....: ]\n .....: \n\nIn [223]: choices = ['yellow', 'blue', 'purple']\n\nIn [224]: df['color'] = np.select(conditions, choices, default='black')\n\nIn [225]: df\nOut[225]: \n col1 col2   color\n0    A    Z  yellow\n1    B    Z    blue\n2    B    X  purple\n3    C    Y   black \n```", "```py\nIn [226]: n = 10\n\nIn [227]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [228]: df\nOut[228]: \n a         b         c\n0  0.438921  0.118680  0.863670\n1  0.138138  0.577363  0.686602\n2  0.595307  0.564592  0.520630\n3  0.913052  0.926075  0.616184\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n6  0.792342  0.216974  0.564056\n7  0.397890  0.454131  0.915716\n8  0.074315  0.437913  0.019794\n9  0.559209  0.502065  0.026437\n\n# pure python\nIn [229]: df[(df['a'] < df['b']) & (df['b'] < df['c'])]\nOut[229]: \n a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716\n\n# query\nIn [230]: df.query('(a < b) & (b < c)')\nOut[230]: \n a         b         c\n1  0.138138  0.577363  0.686602\n4  0.078718  0.854477  0.898725\n5  0.076404  0.523211  0.591538\n7  0.397890  0.454131  0.915716 \n```", "```py\nIn [231]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))\n\nIn [232]: df.index.name = 'a'\n\nIn [233]: df\nOut[233]: \n b  c\na \n0  0  4\n1  0  1\n2  3  4\n3  4  3\n4  1  4\n5  0  3\n6  0  1\n7  3  4\n8  2  3\n9  1  1\n\nIn [234]: df.query('a < b and b < c')\nOut[234]: \n b  c\na \n2  3  4 \n```", "```py\nIn [235]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))\n\nIn [236]: df\nOut[236]: \n b  c\n0  3  1\n1  3  0\n2  5  6\n3  5  2\n4  7  4\n5  0  1\n6  2  5\n7  0  1\n8  6  0\n9  7  9\n\nIn [237]: df.query('index < b < c')\nOut[237]: \n b  c\n2  5  6 \n```", "```py\nIn [238]: df = pd.DataFrame({'a': np.random.randint(5, size=5)})\n\nIn [239]: df.index.name = 'a'\n\nIn [240]: df.query('a > 2')  # uses the column 'a', not the index\nOut[240]: \n a\na \n1  3\n3  3 \n```", "```py\nIn [241]: df.query('index > 2')\nOut[241]: \n a\na \n3  3\n4  2 \n```", "```py\nIn [242]: n = 10\n\nIn [243]: colors = np.random.choice(['red', 'green'], size=n)\n\nIn [244]: foods = np.random.choice(['eggs', 'ham'], size=n)\n\nIn [245]: colors\nOut[245]: \narray(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',\n 'green', 'green'], dtype='<U5')\n\nIn [246]: foods\nOut[246]: \narray(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',\n 'eggs'], dtype='<U4')\n\nIn [247]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])\n\nIn [248]: df = pd.DataFrame(np.random.randn(n, 2), index=index)\n\nIn [249]: df\nOut[249]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [250]: df.query('color == \"red\"')\nOut[250]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [251]: df.index.names = [None, None]\n\nIn [252]: df\nOut[252]: \n 0         1\nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [253]: df.query('ilevel_0 == \"red\"')\nOut[253]: \n 0         1\nred ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [254]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [255]: df\nOut[255]: \n a         b         c\n0  0.224283  0.736107  0.139168\n1  0.302827  0.657803  0.713897\n2  0.611185  0.136624  0.984960\n3  0.195246  0.123436  0.627712\n4  0.618673  0.371660  0.047902\n5  0.480088  0.062993  0.185760\n6  0.568018  0.483467  0.445289\n7  0.309040  0.274580  0.587101\n8  0.258993  0.477769  0.370255\n9  0.550459  0.840870  0.304611\n\nIn [256]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)\n\nIn [257]: df2\nOut[257]: \n a         b         c\n0   0.357579  0.229800  0.596001\n1   0.309059  0.957923  0.965663\n2   0.123102  0.336914  0.318616\n3   0.526506  0.323321  0.860813\n4   0.518736  0.486514  0.384724\n5   0.190804  0.505723  0.614533\n6   0.891939  0.623977  0.676639\n7   0.480559  0.378528  0.460858\n8   0.420223  0.136404  0.141295\n9   0.732206  0.419540  0.604675\n10  0.604466  0.848974  0.896165\n11  0.589168  0.920046  0.732716\n\nIn [258]: expr = '0.0 <= a <= c <= 0.5'\n\nIn [259]: map(lambda frame: frame.query(expr), [df, df2])\nOut[259]: <map at 0x7ff2e57db2e0> \n```", "```py\nIn [260]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))\n\nIn [261]: df\nOut[261]: \n a  b  c\n0  7  8  9\n1  1  0  7\n2  2  7  2\n3  6  2  2\n4  2  6  3\n5  3  8  2\n6  1  7  2\n7  5  1  5\n8  9  8  0\n9  1  5  0\n\nIn [262]: df.query('(a < b) & (b < c)')\nOut[262]: \n a  b  c\n0  7  8  9\n\nIn [263]: df[(df['a'] < df['b']) & (df['b'] < df['c'])]\nOut[263]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [264]: df.query('a < b & b < c')\nOut[264]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [265]: df.query('a < b and b < c')\nOut[265]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [266]: df.query('a < b < c')\nOut[266]: \n a  b  c\n0  7  8  9 \n```", "```py\n# get all rows where columns \"a\" and \"b\" have overlapping values\nIn [267]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),\n .....:                   'c': np.random.randint(5, size=12),\n .....:                   'd': np.random.randint(9, size=12)})\n .....: \n\nIn [268]: df\nOut[268]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [269]: df.query('a in b')\nOut[269]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\n# How you'd do it in pure Python\nIn [270]: df[df['a'].isin(df['b'])]\nOut[270]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\nIn [271]: df.query('a not in b')\nOut[271]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [272]: df[~df['a'].isin(df['b'])]\nOut[272]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\n# rows where cols a and b have overlapping values\n# and col c's values are less than col d's\nIn [273]: df.query('a in b and c < d')\nOut[273]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n4  c  b  3  6\n5  c  b  0  2\n\n# pure Python\nIn [274]: df[df['b'].isin(df['a']) & (df['c'] < df['d'])]\nOut[274]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n4   c  b  3  6\n5   c  b  0  2\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\ndf.query('a in b + c + d') \n```", "```py\nIn [275]: df.query('b == [\"a\", \"b\", \"c\"]')\nOut[275]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [276]: df[df['b'].isin([\"a\", \"b\", \"c\"])]\nOut[276]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [277]: df.query('c == [1, 2]')\nOut[277]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [278]: df.query('c != [1, 2]')\nOut[278]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# using in/not in\nIn [279]: df.query('[1, 2] in c')\nOut[279]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [280]: df.query('[1, 2] not in c')\nOut[280]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# pure Python\nIn [281]: df[df['c'].isin([1, 2])]\nOut[281]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2 \n```", "```py\nIn [282]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [283]: df['bools'] = np.random.rand(len(df)) > 0.5\n\nIn [284]: df.query('~bools')\nOut[284]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [285]: df.query('not bools')\nOut[285]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [286]: df.query('not bools') == df[~df['bools']]\nOut[286]: \n a     b     c  bools\n2  True  True  True   True\n7  True  True  True   True\n8  True  True  True   True \n```", "```py\n# short query syntax\nIn [287]: shorter = df.query('a < b < c and (not bools) or bools > 2')\n\n# equivalent in pure Python\nIn [288]: longer = df[(df['a'] < df['b'])\n .....:            & (df['b'] < df['c'])\n .....:            & (~df['bools'])\n .....:            | (df['bools'] > 2)]\n .....: \n\nIn [289]: shorter\nOut[289]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [290]: longer\nOut[290]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [291]: shorter == longer\nOut[291]: \n a     b     c  bools\n7  True  True  True   True \n```", "```py\nIn [292]: df = pd.DataFrame(np.random.randn(8, 4),\n .....:                  index=dates, columns=['A', 'B', 'C', 'D'])\n .....: \n\nIn [293]: df2 = df.copy() \n```", "```py\nIn [242]: n = 10\n\nIn [243]: colors = np.random.choice(['red', 'green'], size=n)\n\nIn [244]: foods = np.random.choice(['eggs', 'ham'], size=n)\n\nIn [245]: colors\nOut[245]: \narray(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',\n 'green', 'green'], dtype='<U5')\n\nIn [246]: foods\nOut[246]: \narray(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',\n 'eggs'], dtype='<U4')\n\nIn [247]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])\n\nIn [248]: df = pd.DataFrame(np.random.randn(n, 2), index=index)\n\nIn [249]: df\nOut[249]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [250]: df.query('color == \"red\"')\nOut[250]: \n 0         1\ncolor food \nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [251]: df.index.names = [None, None]\n\nIn [252]: df\nOut[252]: \n 0         1\nred   ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255\ngreen eggs -0.748199  1.318931\n eggs -2.029766  0.792652\n ham   0.461007 -0.542749\n ham  -0.305384 -0.479195\n eggs  0.095031 -0.270099\n eggs -0.707140 -0.773882\n eggs  0.229453  0.304418\n\nIn [253]: df.query('ilevel_0 == \"red\"')\nOut[253]: \n 0         1\nred ham   0.194889 -0.381994\n ham   0.318587  2.089075\n eggs -0.728293 -0.090255 \n```", "```py\nIn [254]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [255]: df\nOut[255]: \n a         b         c\n0  0.224283  0.736107  0.139168\n1  0.302827  0.657803  0.713897\n2  0.611185  0.136624  0.984960\n3  0.195246  0.123436  0.627712\n4  0.618673  0.371660  0.047902\n5  0.480088  0.062993  0.185760\n6  0.568018  0.483467  0.445289\n7  0.309040  0.274580  0.587101\n8  0.258993  0.477769  0.370255\n9  0.550459  0.840870  0.304611\n\nIn [256]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)\n\nIn [257]: df2\nOut[257]: \n a         b         c\n0   0.357579  0.229800  0.596001\n1   0.309059  0.957923  0.965663\n2   0.123102  0.336914  0.318616\n3   0.526506  0.323321  0.860813\n4   0.518736  0.486514  0.384724\n5   0.190804  0.505723  0.614533\n6   0.891939  0.623977  0.676639\n7   0.480559  0.378528  0.460858\n8   0.420223  0.136404  0.141295\n9   0.732206  0.419540  0.604675\n10  0.604466  0.848974  0.896165\n11  0.589168  0.920046  0.732716\n\nIn [258]: expr = '0.0 <= a <= c <= 0.5'\n\nIn [259]: map(lambda frame: frame.query(expr), [df, df2])\nOut[259]: <map at 0x7ff2e57db2e0> \n```", "```py\nIn [260]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))\n\nIn [261]: df\nOut[261]: \n a  b  c\n0  7  8  9\n1  1  0  7\n2  2  7  2\n3  6  2  2\n4  2  6  3\n5  3  8  2\n6  1  7  2\n7  5  1  5\n8  9  8  0\n9  1  5  0\n\nIn [262]: df.query('(a < b) & (b < c)')\nOut[262]: \n a  b  c\n0  7  8  9\n\nIn [263]: df[(df['a'] < df['b']) & (df['b'] < df['c'])]\nOut[263]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [264]: df.query('a < b & b < c')\nOut[264]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [265]: df.query('a < b and b < c')\nOut[265]: \n a  b  c\n0  7  8  9 \n```", "```py\nIn [266]: df.query('a < b < c')\nOut[266]: \n a  b  c\n0  7  8  9 \n```", "```py\n# get all rows where columns \"a\" and \"b\" have overlapping values\nIn [267]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),\n .....:                   'c': np.random.randint(5, size=12),\n .....:                   'd': np.random.randint(9, size=12)})\n .....: \n\nIn [268]: df\nOut[268]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [269]: df.query('a in b')\nOut[269]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\n# How you'd do it in pure Python\nIn [270]: df[df['a'].isin(df['b'])]\nOut[270]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n3  b  a  2  1\n4  c  b  3  6\n5  c  b  0  2\n\nIn [271]: df.query('a not in b')\nOut[271]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [272]: df[~df['a'].isin(df['b'])]\nOut[272]: \n a  b  c  d\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\n# rows where cols a and b have overlapping values\n# and col c's values are less than col d's\nIn [273]: df.query('a in b and c < d')\nOut[273]: \n a  b  c  d\n0  a  a  2  6\n1  a  a  4  7\n2  b  a  1  6\n4  c  b  3  6\n5  c  b  0  2\n\n# pure Python\nIn [274]: df[df['b'].isin(df['a']) & (df['c'] < df['d'])]\nOut[274]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n4   c  b  3  6\n5   c  b  0  2\n10  f  c  0  6\n11  f  c  1  2 \n```", "```py\ndf.query('a in b + c + d') \n```", "```py\nIn [275]: df.query('b == [\"a\", \"b\", \"c\"]')\nOut[275]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\n# pure Python\nIn [276]: df[df['b'].isin([\"a\", \"b\", \"c\"])]\nOut[276]: \n a  b  c  d\n0   a  a  2  6\n1   a  a  4  7\n2   b  a  1  6\n3   b  a  2  1\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n7   d  b  2  1\n8   e  c  4  3\n9   e  c  2  0\n10  f  c  0  6\n11  f  c  1  2\n\nIn [277]: df.query('c == [1, 2]')\nOut[277]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [278]: df.query('c != [1, 2]')\nOut[278]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# using in/not in\nIn [279]: df.query('[1, 2] in c')\nOut[279]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2\n\nIn [280]: df.query('[1, 2] not in c')\nOut[280]: \n a  b  c  d\n1   a  a  4  7\n4   c  b  3  6\n5   c  b  0  2\n6   d  b  3  3\n8   e  c  4  3\n10  f  c  0  6\n\n# pure Python\nIn [281]: df[df['c'].isin([1, 2])]\nOut[281]: \n a  b  c  d\n0   a  a  2  6\n2   b  a  1  6\n3   b  a  2  1\n7   d  b  2  1\n9   e  c  2  0\n11  f  c  1  2 \n```", "```py\nIn [282]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))\n\nIn [283]: df['bools'] = np.random.rand(len(df)) > 0.5\n\nIn [284]: df.query('~bools')\nOut[284]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [285]: df.query('not bools')\nOut[285]: \n a         b         c  bools\n2  0.697753  0.212799  0.329209  False\n7  0.275396  0.691034  0.826619  False\n8  0.190649  0.558748  0.262467  False\n\nIn [286]: df.query('not bools') == df[~df['bools']]\nOut[286]: \n a     b     c  bools\n2  True  True  True   True\n7  True  True  True   True\n8  True  True  True   True \n```", "```py\n# short query syntax\nIn [287]: shorter = df.query('a < b < c and (not bools) or bools > 2')\n\n# equivalent in pure Python\nIn [288]: longer = df[(df['a'] < df['b'])\n .....:            & (df['b'] < df['c'])\n .....:            & (~df['bools'])\n .....:            | (df['bools'] > 2)]\n .....: \n\nIn [289]: shorter\nOut[289]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [290]: longer\nOut[290]: \n a         b         c  bools\n7  0.275396  0.691034  0.826619  False\n\nIn [291]: shorter == longer\nOut[291]: \n a     b     c  bools\n7  True  True  True   True \n```", "```py\nIn [292]: df = pd.DataFrame(np.random.randn(8, 4),\n .....:                  index=dates, columns=['A', 'B', 'C', 'D'])\n .....: \n\nIn [293]: df2 = df.copy() \n```", "```py\nIn [294]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],\n .....:                    'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],\n .....:                    'c': np.random.randn(7)})\n .....: \n\nIn [295]: df2\nOut[295]: \n a  b         c\n0    one  x -1.067137\n1    one  y  0.309500\n2    two  x -0.211056\n3    two  y -1.842023\n4    two  x -0.390820\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [296]: df2.duplicated('a')\nOut[296]: \n0    False\n1     True\n2    False\n3     True\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [297]: df2.duplicated('a', keep='last')\nOut[297]: \n0     True\n1    False\n2     True\n3     True\n4    False\n5    False\n6    False\ndtype: bool\n\nIn [298]: df2.duplicated('a', keep=False)\nOut[298]: \n0     True\n1     True\n2     True\n3     True\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [299]: df2.drop_duplicates('a')\nOut[299]: \n a  b         c\n0    one  x -1.067137\n2    two  x -0.211056\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [300]: df2.drop_duplicates('a', keep='last')\nOut[300]: \n a  b         c\n1    one  y  0.309500\n4    two  x -0.390820\n5  three  x -1.964475\n6   four  x  1.298329\n\nIn [301]: df2.drop_duplicates('a', keep=False)\nOut[301]: \n a  b         c\n5  three  x -1.964475\n6   four  x  1.298329 \n```", "```py\nIn [302]: df2.duplicated(['a', 'b'])\nOut[302]: \n0    False\n1    False\n2    False\n3    False\n4     True\n5    False\n6    False\ndtype: bool\n\nIn [303]: df2.drop_duplicates(['a', 'b'])\nOut[303]: \n a  b         c\n0    one  x -1.067137\n1    one  y  0.309500\n2    two  x -0.211056\n3    two  y -1.842023\n5  three  x -1.964475\n6   four  x  1.298329 \n```", "```py\nIn [304]: df3 = pd.DataFrame({'a': np.arange(6),\n .....:                    'b': np.random.randn(6)},\n .....:                   index=['a', 'a', 'b', 'c', 'b', 'a'])\n .....: \n\nIn [305]: df3\nOut[305]: \n a         b\na  0  1.440455\na  1  2.456086\nb  2  1.038402\nc  3 -0.894409\nb  4  0.683536\na  5  3.082764\n\nIn [306]: df3.index.duplicated()\nOut[306]: array([False,  True, False, False,  True,  True])\n\nIn [307]: df3[~df3.index.duplicated()]\nOut[307]: \n a         b\na  0  1.440455\nb  2  1.038402\nc  3 -0.894409\n\nIn [308]: df3[~df3.index.duplicated(keep='last')]\nOut[308]: \n a         b\nc  3 -0.894409\nb  4  0.683536\na  5  3.082764\n\nIn [309]: df3[~df3.index.duplicated(keep=False)]\nOut[309]: \n a         b\nc  3 -0.894409 \n```", "```py\nIn [310]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nIn [311]: s.get('a')  # equivalent to s['a']\nOut[311]: 1\n\nIn [312]: s.get('x', default=-1)\nOut[312]: -1 \n```", "```py\nIn [313]: df = pd.DataFrame({'col': [\"A\", \"A\", \"B\", \"B\"],\n .....:                   'A': [80, 23, np.nan, 22],\n .....:                   'B': [80, 55, 76, 67]})\n .....: \n\nIn [314]: df\nOut[314]: \n col     A   B\n0   A  80.0  80\n1   A  23.0  55\n2   B   NaN  76\n3   B  22.0  67\n\nIn [315]: idx, cols = pd.factorize(df['col'])\n\nIn [316]: df.reindex(cols, axis=1).to_numpy()[np.arange(len(df)), idx]\nOut[316]: array([80., 23., 76., 67.]) \n```", "```py\nIn [317]: index = pd.Index(['e', 'd', 'a', 'b'])\n\nIn [318]: index\nOut[318]: Index(['e', 'd', 'a', 'b'], dtype='object')\n\nIn [319]: 'd' in index\nOut[319]: True \n```", "```py\nIn [320]: index = pd.Index([1, 5, 12])\n\nIn [321]: index\nOut[321]: Index([1, 5, 12], dtype='int64')\n\nIn [322]: 5 in index\nOut[322]: True \n```", "```py\nIn [323]: index = pd.Index(['e', 'd', 'a', 'b'], dtype=\"string\")\n\nIn [324]: index\nOut[324]: Index(['e', 'd', 'a', 'b'], dtype='string')\n\nIn [325]: index = pd.Index([1, 5, 12], dtype=\"int8\")\n\nIn [326]: index\nOut[326]: Index([1, 5, 12], dtype='int8')\n\nIn [327]: index = pd.Index([1, 5, 12], dtype=\"float32\")\n\nIn [328]: index\nOut[328]: Index([1.0, 5.0, 12.0], dtype='float32') \n```", "```py\nIn [329]: index = pd.Index(['e', 'd', 'a', 'b'], name='something')\n\nIn [330]: index.name\nOut[330]: 'something' \n```", "```py\nIn [331]: index = pd.Index(list(range(5)), name='rows')\n\nIn [332]: columns = pd.Index(['A', 'B', 'C'], name='cols')\n\nIn [333]: df = pd.DataFrame(np.random.randn(5, 3), index=index, columns=columns)\n\nIn [334]: df\nOut[334]: \ncols         A         B         C\nrows \n0     1.295989 -1.051694  1.340429\n1    -2.366110  0.428241  0.387275\n2     0.433306  0.929548  0.278094\n3     2.154730 -0.315628  0.264223\n4     1.126818  1.132290 -0.353310\n\nIn [335]: df['A']\nOut[335]: \nrows\n0    1.295989\n1   -2.366110\n2    0.433306\n3    2.154730\n4    1.126818\nName: A, dtype: float64 \n```", "```py\nIn [336]: ind = pd.Index([1, 2, 3])\n\nIn [337]: ind.rename(\"apple\")\nOut[337]: Index([1, 2, 3], dtype='int64', name='apple')\n\nIn [338]: ind\nOut[338]: Index([1, 2, 3], dtype='int64')\n\nIn [339]: ind = ind.set_names([\"apple\"])\n\nIn [340]: ind.name = \"bob\"\n\nIn [341]: ind\nOut[341]: Index([1, 2, 3], dtype='int64', name='bob') \n```", "```py\nIn [342]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])\n\nIn [343]: index\nOut[343]: \nMultiIndex([(0, 'one'),\n (0, 'two'),\n (1, 'one'),\n (1, 'two'),\n (2, 'one'),\n (2, 'two')],\n names=['first', 'second'])\n\nIn [344]: index.levels[1]\nOut[344]: Index(['one', 'two'], dtype='object', name='second')\n\nIn [345]: index.set_levels([\"a\", \"b\"], level=1)\nOut[345]: \nMultiIndex([(0, 'a'),\n (0, 'b'),\n (1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['first', 'second']) \n```", "```py\nIn [346]: a = pd.Index(['c', 'b', 'a'])\n\nIn [347]: b = pd.Index(['c', 'e', 'd'])\n\nIn [348]: a.difference(b)\nOut[348]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [349]: idx1 = pd.Index([1, 2, 3, 4])\n\nIn [350]: idx2 = pd.Index([2, 3, 4, 5])\n\nIn [351]: idx1.symmetric_difference(idx2)\nOut[351]: Index([1, 5], dtype='int64') \n```", "```py\nIn [352]: idx1 = pd.Index([0, 1, 2])\n\nIn [353]: idx2 = pd.Index([0.5, 1.5])\n\nIn [354]: idx1.union(idx2)\nOut[354]: Index([0.0, 0.5, 1.0, 1.5, 2.0], dtype='float64') \n```", "```py\nIn [355]: idx1 = pd.Index([1, np.nan, 3, 4])\n\nIn [356]: idx1\nOut[356]: Index([1.0, nan, 3.0, 4.0], dtype='float64')\n\nIn [357]: idx1.fillna(2)\nOut[357]: Index([1.0, 2.0, 3.0, 4.0], dtype='float64')\n\nIn [358]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'),\n .....:                         pd.NaT,\n .....:                         pd.Timestamp('2011-01-03')])\n .....: \n\nIn [359]: idx2\nOut[359]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)\n\nIn [360]: idx2.fillna(pd.Timestamp('2011-01-02'))\nOut[360]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [336]: ind = pd.Index([1, 2, 3])\n\nIn [337]: ind.rename(\"apple\")\nOut[337]: Index([1, 2, 3], dtype='int64', name='apple')\n\nIn [338]: ind\nOut[338]: Index([1, 2, 3], dtype='int64')\n\nIn [339]: ind = ind.set_names([\"apple\"])\n\nIn [340]: ind.name = \"bob\"\n\nIn [341]: ind\nOut[341]: Index([1, 2, 3], dtype='int64', name='bob') \n```", "```py\nIn [342]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])\n\nIn [343]: index\nOut[343]: \nMultiIndex([(0, 'one'),\n (0, 'two'),\n (1, 'one'),\n (1, 'two'),\n (2, 'one'),\n (2, 'two')],\n names=['first', 'second'])\n\nIn [344]: index.levels[1]\nOut[344]: Index(['one', 'two'], dtype='object', name='second')\n\nIn [345]: index.set_levels([\"a\", \"b\"], level=1)\nOut[345]: \nMultiIndex([(0, 'a'),\n (0, 'b'),\n (1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['first', 'second']) \n```", "```py\nIn [346]: a = pd.Index(['c', 'b', 'a'])\n\nIn [347]: b = pd.Index(['c', 'e', 'd'])\n\nIn [348]: a.difference(b)\nOut[348]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [349]: idx1 = pd.Index([1, 2, 3, 4])\n\nIn [350]: idx2 = pd.Index([2, 3, 4, 5])\n\nIn [351]: idx1.symmetric_difference(idx2)\nOut[351]: Index([1, 5], dtype='int64') \n```", "```py\nIn [352]: idx1 = pd.Index([0, 1, 2])\n\nIn [353]: idx2 = pd.Index([0.5, 1.5])\n\nIn [354]: idx1.union(idx2)\nOut[354]: Index([0.0, 0.5, 1.0, 1.5, 2.0], dtype='float64') \n```", "```py\nIn [355]: idx1 = pd.Index([1, np.nan, 3, 4])\n\nIn [356]: idx1\nOut[356]: Index([1.0, nan, 3.0, 4.0], dtype='float64')\n\nIn [357]: idx1.fillna(2)\nOut[357]: Index([1.0, 2.0, 3.0, 4.0], dtype='float64')\n\nIn [358]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'),\n .....:                         pd.NaT,\n .....:                         pd.Timestamp('2011-01-03')])\n .....: \n\nIn [359]: idx2\nOut[359]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)\n\nIn [360]: idx2.fillna(pd.Timestamp('2011-01-02'))\nOut[360]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None) \n```", "```py\nIn [361]: data = pd.DataFrame({'a': ['bar', 'bar', 'foo', 'foo'],\n .....:                     'b': ['one', 'two', 'one', 'two'],\n .....:                     'c': ['z', 'y', 'x', 'w'],\n .....:                     'd': [1., 2., 3, 4]})\n .....: \n\nIn [362]: data\nOut[362]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [363]: indexed1 = data.set_index('c')\n\nIn [364]: indexed1\nOut[364]: \n a    b    d\nc \nz  bar  one  1.0\ny  bar  two  2.0\nx  foo  one  3.0\nw  foo  two  4.0\n\nIn [365]: indexed2 = data.set_index(['a', 'b'])\n\nIn [366]: indexed2\nOut[366]: \n c    d\na   b \nbar one  z  1.0\n two  y  2.0\nfoo one  x  3.0\n two  w  4.0 \n```", "```py\nIn [367]: frame = data.set_index('c', drop=False)\n\nIn [368]: frame = frame.set_index(['a', 'b'], append=True)\n\nIn [369]: frame\nOut[369]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0 \n```", "```py\nIn [370]: data.set_index('c', drop=False)\nOut[370]: \n a    b  c    d\nc \nz  bar  one  z  1.0\ny  bar  two  y  2.0\nx  foo  one  x  3.0\nw  foo  two  w  4.0 \n```", "```py\nIn [371]: data\nOut[371]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [372]: data.reset_index()\nOut[372]: \n index    a    b  c    d\n0      0  bar  one  z  1.0\n1      1  bar  two  y  2.0\n2      2  foo  one  x  3.0\n3      3  foo  two  w  4.0 \n```", "```py\nIn [373]: frame\nOut[373]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0\n\nIn [374]: frame.reset_index(level=1)\nOut[374]: \n a  c    d\nc b \nz one  bar  z  1.0\ny two  bar  y  2.0\nx one  foo  x  3.0\nw two  foo  w  4.0 \n```", "```py\nIn [375]: df_idx = pd.DataFrame(range(4))\n\nIn [376]: df_idx.index = pd.Index([10, 20, 30, 40], name=\"a\")\n\nIn [377]: df_idx\nOut[377]: \n 0\na \n10  0\n20  1\n30  2\n40  3 \n```", "```py\nIn [361]: data = pd.DataFrame({'a': ['bar', 'bar', 'foo', 'foo'],\n .....:                     'b': ['one', 'two', 'one', 'two'],\n .....:                     'c': ['z', 'y', 'x', 'w'],\n .....:                     'd': [1., 2., 3, 4]})\n .....: \n\nIn [362]: data\nOut[362]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [363]: indexed1 = data.set_index('c')\n\nIn [364]: indexed1\nOut[364]: \n a    b    d\nc \nz  bar  one  1.0\ny  bar  two  2.0\nx  foo  one  3.0\nw  foo  two  4.0\n\nIn [365]: indexed2 = data.set_index(['a', 'b'])\n\nIn [366]: indexed2\nOut[366]: \n c    d\na   b \nbar one  z  1.0\n two  y  2.0\nfoo one  x  3.0\n two  w  4.0 \n```", "```py\nIn [367]: frame = data.set_index('c', drop=False)\n\nIn [368]: frame = frame.set_index(['a', 'b'], append=True)\n\nIn [369]: frame\nOut[369]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0 \n```", "```py\nIn [370]: data.set_index('c', drop=False)\nOut[370]: \n a    b  c    d\nc \nz  bar  one  z  1.0\ny  bar  two  y  2.0\nx  foo  one  x  3.0\nw  foo  two  w  4.0 \n```", "```py\nIn [371]: data\nOut[371]: \n a    b  c    d\n0  bar  one  z  1.0\n1  bar  two  y  2.0\n2  foo  one  x  3.0\n3  foo  two  w  4.0\n\nIn [372]: data.reset_index()\nOut[372]: \n index    a    b  c    d\n0      0  bar  one  z  1.0\n1      1  bar  two  y  2.0\n2      2  foo  one  x  3.0\n3      3  foo  two  w  4.0 \n```", "```py\nIn [373]: frame\nOut[373]: \n c    d\nc a   b \nz bar one  z  1.0\ny bar two  y  2.0\nx foo one  x  3.0\nw foo two  w  4.0\n\nIn [374]: frame.reset_index(level=1)\nOut[374]: \n a  c    d\nc b \nz one  bar  z  1.0\ny two  bar  y  2.0\nx one  foo  x  3.0\nw two  foo  w  4.0 \n```", "```py\nIn [375]: df_idx = pd.DataFrame(range(4))\n\nIn [376]: df_idx.index = pd.Index([10, 20, 30, 40], name=\"a\")\n\nIn [377]: df_idx\nOut[377]: \n 0\na \n10  0\n20  1\n30  2\n40  3 \n```", "```py\nIn [378]: dfmi = pd.DataFrame([list('abcd'),\n .....:                     list('efgh'),\n .....:                     list('ijkl'),\n .....:                     list('mnop')],\n .....:                    columns=pd.MultiIndex.from_product([['one', 'two'],\n .....:                                                        ['first', 'second']]))\n .....: \n\nIn [379]: dfmi\nOut[379]: \n one          two \n first second first second\n0     a      b     c      d\n1     e      f     g      h\n2     i      j     k      l\n3     m      n     o      p \n```", "```py\nIn [380]: dfmi['one']['second']\nOut[380]: \n0    b\n1    f\n2    j\n3    n\nName: second, dtype: object \n```", "```py\nIn [381]: dfmi.loc[:, ('one', 'second')]\nOut[381]: \n0    b\n1    f\n2    j\n3    n\nName: (one, second), dtype: object \n```", "```py\ndfmi.loc[:, ('one', 'second')] = value\n# becomes\ndfmi.loc.__setitem__((slice(None), ('one', 'second')), value) \n```", "```py\ndfmi['one']['second'] = value\n# becomes\ndfmi.__getitem__('one').__setitem__('second', value) \n```", "```py\ndef do_something(df):\n    foo = df[['bar', 'baz']]  # Is foo a view? A copy? Nobody knows!\n    # ... many lines here ...\n    # We don't know whether this will modify df or not!\n    foo['quux'] = value\n    return foo \n```", "```py\nIn [382]: dfb = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\n# This will show the SettingWithCopyWarning\n# but the frame values will be set\nIn [383]: dfb['c'][dfb['a'].str.startswith('o')] = 42 \n```", "```py\nIn [384]: with pd.option_context('mode.chained_assignment','warn'):\n .....:    dfb[dfb['a'].str.startswith('o')]['c'] = 42\n .....: \n```", "```py\nIn [385]: dfc = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\nIn [386]: dfd = dfc.copy()\n\n# Setting multiple items using a mask\nIn [387]: mask = dfd['a'].str.startswith('o')\n\nIn [388]: dfd.loc[mask, 'c'] = 42\n\nIn [389]: dfd\nOut[389]: \n a   c\n0    one  42\n1    one  42\n2    two   2\n3  three   3\n4    two   4\n5    one  42\n6    six   6\n\n# Setting a single item\nIn [390]: dfd = dfc.copy()\n\nIn [391]: dfd.loc[2, 'a'] = 11\n\nIn [392]: dfd\nOut[392]: \n a  c\n0    one  0\n1    one  1\n2     11  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [393]: dfd = dfc.copy()\n\nIn [394]: dfd['a'][2] = 111\n\nIn [395]: dfd\nOut[395]: \n a  c\n0    one  0\n1    one  1\n2    111  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [396]: with pd.option_context('mode.chained_assignment','raise'):\n .....:    dfd.loc[0]['a'] = 1111\n .....: \n---------------------------------------------------------------------------\nSettingWithCopyError  Traceback (most recent call last)\n<ipython-input-396-32ce785aaa5b> in ?()\n  1 with pd.option_context('mode.chained_assignment','raise'):\n----> 2     dfd.loc[0]['a'] = 1111\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self, key, value)\n  1284                 )\n  1285 \n  1286         check_dict_or_set_indexers(key)\n  1287         key = com.apply_if_callable(key, self)\n-> 1288         cacher_needs_updating = self._check_is_chained_assignment_possible()\n  1289 \n  1290         if key is Ellipsis:\n  1291             key = slice(None)\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self)\n  1489             ref = self._get_cacher()\n  1490             if ref is not None and ref._is_mixed_type:\n  1491                 self._check_setitem_copy(t=\"referent\", force=True)\n  1492             return True\n-> 1493         return super()._check_is_chained_assignment_possible()\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self)\n  4395         single-dtype meaning that the cacher should be updated following\n  4396         setting.\n  4397         \"\"\"\n  4398 if self._is_copy:\n-> 4399 self._check_setitem_copy(t=\"referent\")\n  4400 return False\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self, t, force)\n  4469 \"indexing.html#returning-a-view-versus-a-copy\"\n  4470 )\n  4471  \n  4472 if value == \"raise\":\n-> 4473 raise SettingWithCopyError(t)\n  4474 if value == \"warn\":\n  4475 warnings.warn(t, SettingWithCopyWarning, stacklevel=find_stack_level())\n\nSettingWithCopyError: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy \n```", "```py\ndfmi.loc[:, ('one', 'second')] = value\n# becomes\ndfmi.loc.__setitem__((slice(None), ('one', 'second')), value) \n```", "```py\ndfmi['one']['second'] = value\n# becomes\ndfmi.__getitem__('one').__setitem__('second', value) \n```", "```py\ndef do_something(df):\n    foo = df[['bar', 'baz']]  # Is foo a view? A copy? Nobody knows!\n    # ... many lines here ...\n    # We don't know whether this will modify df or not!\n    foo['quux'] = value\n    return foo \n```", "```py\nIn [382]: dfb = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\n# This will show the SettingWithCopyWarning\n# but the frame values will be set\nIn [383]: dfb['c'][dfb['a'].str.startswith('o')] = 42 \n```", "```py\nIn [384]: with pd.option_context('mode.chained_assignment','warn'):\n .....:    dfb[dfb['a'].str.startswith('o')]['c'] = 42\n .....: \n```", "```py\nIn [385]: dfc = pd.DataFrame({'a': ['one', 'one', 'two',\n .....:                          'three', 'two', 'one', 'six'],\n .....:                    'c': np.arange(7)})\n .....: \n\nIn [386]: dfd = dfc.copy()\n\n# Setting multiple items using a mask\nIn [387]: mask = dfd['a'].str.startswith('o')\n\nIn [388]: dfd.loc[mask, 'c'] = 42\n\nIn [389]: dfd\nOut[389]: \n a   c\n0    one  42\n1    one  42\n2    two   2\n3  three   3\n4    two   4\n5    one  42\n6    six   6\n\n# Setting a single item\nIn [390]: dfd = dfc.copy()\n\nIn [391]: dfd.loc[2, 'a'] = 11\n\nIn [392]: dfd\nOut[392]: \n a  c\n0    one  0\n1    one  1\n2     11  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [393]: dfd = dfc.copy()\n\nIn [394]: dfd['a'][2] = 111\n\nIn [395]: dfd\nOut[395]: \n a  c\n0    one  0\n1    one  1\n2    111  2\n3  three  3\n4    two  4\n5    one  5\n6    six  6 \n```", "```py\nIn [396]: with pd.option_context('mode.chained_assignment','raise'):\n .....:    dfd.loc[0]['a'] = 1111\n .....: \n---------------------------------------------------------------------------\nSettingWithCopyError  Traceback (most recent call last)\n<ipython-input-396-32ce785aaa5b> in ?()\n  1 with pd.option_context('mode.chained_assignment','raise'):\n----> 2     dfd.loc[0]['a'] = 1111\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self, key, value)\n  1284                 )\n  1285 \n  1286         check_dict_or_set_indexers(key)\n  1287         key = com.apply_if_callable(key, self)\n-> 1288         cacher_needs_updating = self._check_is_chained_assignment_possible()\n  1289 \n  1290         if key is Ellipsis:\n  1291             key = slice(None)\n\n~/work/pandas/pandas/pandas/core/series.py in ?(self)\n  1489             ref = self._get_cacher()\n  1490             if ref is not None and ref._is_mixed_type:\n  1491                 self._check_setitem_copy(t=\"referent\", force=True)\n  1492             return True\n-> 1493         return super()._check_is_chained_assignment_possible()\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self)\n  4395         single-dtype meaning that the cacher should be updated following\n  4396         setting.\n  4397         \"\"\"\n  4398 if self._is_copy:\n-> 4399 self._check_setitem_copy(t=\"referent\")\n  4400 return False\n\n~/work/pandas/pandas/pandas/core/generic.py in ?(self, t, force)\n  4469 \"indexing.html#returning-a-view-versus-a-copy\"\n  4470 )\n  4471  \n  4472 if value == \"raise\":\n-> 4473 raise SettingWithCopyError(t)\n  4474 if value == \"warn\":\n  4475 warnings.warn(t, SettingWithCopyWarning, stacklevel=find_stack_level())\n\nSettingWithCopyError: \nA value is trying to be set on a copy of a slice from a DataFrame\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy \n```"]