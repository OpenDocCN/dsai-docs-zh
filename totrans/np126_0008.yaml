- en: NumPy for MATLAB users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MATLAB用户的NumPy
- en: 原文：[https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html](https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html](https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html)
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 介绍'
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB® 和 NumPy有很多共同之处，但NumPy是为了与Python一起使用而创建的，而不是MATLAB的克隆。本指南将帮助MATLAB用户开始使用NumPy。
- en: Some key differences
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些主要区别
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 在MATLAB中，即使对于标量，基本类型也是多维数组。在MATLAB中的数组赋值都以双精度浮点数的2D数组存储，除非你指定维数和类型。对这些数组的2D实例的操作都是模仿线性代数中的矩阵操作。
    | 在NumPy中，基本类型是多维`数组`。在NumPy中的数组赋值通常存储为[n维数组](../reference/arrays.html#arrays)，只需要最小类型来存储对象，除非你指定维数和类型。NumPy执行元素按元素的操作，所以用`*`来乘以2D数组不是矩阵乘法
    - 这是元素按元素的乘法。（自Python 3.5开始，可以使用`@`运算符进行传统的矩阵乘法。） |'
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB 数字从1开始索引；`a(1)` 是第一个元素。[参见说明 索引](#numpy-for-matlab-users-notes) |
    NumPy，与Python一样，数字从0开始索引；`a[0]` 是第一个元素。 |'
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB的脚本语言是为了线性代数而创建的，因此一些数组操作的语法比NumPy更紧凑。另一方面，添加GUI和创建完整的应用程序的API更多或多或少是事后想法。
    | NumPy是基于Python的通用语言。NumPy的优势在于访问Python库，包括：[SciPy](https://www.scipy.org/)，[Matplotlib](https://matplotlib.org/)，[Pandas](https://pandas.pydata.org/)，[OpenCV](https://opencv.org/)等。此外，Python经常作为[嵌入式脚本语言](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)嵌入到其他软件中，也可以在那里使用NumPy。
    |'
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB 数组切片使用值传递语义，采用延迟写入复制方案以防止创建副本，直到需要为止。切片操作复制数组的部分。 | NumPy 数组切片使用按引用传递的方式，不复制参数。切片操作是对数组的视图。
    |'
- en: Rough equivalents
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大致等效项
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下表提供了一些常见MATLAB表达式的大致等效项。这些是类似的表达式，而不是等效项。详情请参见[文档](../reference/index.html#reference)。
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下表中，假设你已经在Python中执行了以下命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还假设如果备注谈论“矩阵”，那么参数是二维实体。
- en: General purpose equivalents
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用等效物
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB | NumPy | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `help func` | `info(func)` 或 `help(func)` 或 `func?`（在 IPython 中） | 获取关于函数
    *func* 的帮助信息 |'
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `which func` | [参见注释 HELP](#numpy-for-matlab-users-notes) | 找出 *func* 的定义位置
    |'
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `type func` | `np.source(func)` 或 `func??`（在 IPython 中） | 输出 *func* 的源代码（如果不是原生函数）
    |'
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `% comment` | `# comment` | 在代码行中注释文本“comment” |'
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 使用 for 循环使用 [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "（在 Python v3.11 中）") 打印数字 1, 2 和 3 |'
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `a && b` | `a and b` | 短路逻辑 AND 运算符（[Python 原生运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "（在 Python v3.11 中）")）；仅适用于标量参数 |'
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124;&#124; b` | `a or b` | 短路逻辑 OR 运算符（[Python 原生运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "���在 Python v3.11 中）")）；仅适用于标量参数 |'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| Python 中的[布尔对象](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "（在 Python v3.11 中）")为 `True` 和 `False`，而不是 MATLAB 的逻辑类型 `1` 和 `0`。 |'
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个 if-else 语句来检查 `a` 是否为 4 或 5 并打印结果 |'
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | 复数 |'
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `eps` | `np.finfo(float).eps` 或 `np.spacing(1)` | 双精度中离 1 最近的下一个可表示实数的距离
    |'
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `load data.mat` | `io.loadmat(''data.mat'')` | 加载保存为文件 `data.mat` 的 MATLAB
    变量。（注意：在 MATLAB/Octave 中将数组保存到 `data.mat` 时，请使用最新的二进制格式。[`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "（在 SciPy v1.11.2 中）") 将创建一个带有保存的数组和更多信息的字典。） |'
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `ode45` | `integrate.solve_ivp(f)` | 使用龙格-库塔 4,5 积分一个 ODE |'
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | 使用 BDF 方法积分一个 ODE |'
- en: Linear algebra equivalents
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性代数等价操作
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB | NumPy | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `ndims(a)` | `np.ndim(a)` 或 `a.ndim` | 数组 `a` 的维数 |'
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `numel(a)` | `np.size(a)` 或 `a.size` | 数组 `a` 的元素数量 |'
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `size(a)` | `np.shape(a)` 或 `a.shape` | 数组 `a` 的“大小” |'
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `size(a,n)` | `a.shape[n-1]` | 获取数组 `a` 的第 n 维的元素数量。（注意 MATLAB 使用基于 1 的索引，而
    Python 使用基于 0 的索引，参见 [INDEXING](#numpy-for-matlab-users-notes) 注释） |'
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | 定义一个 2x3
    的二维数组 |'
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | 从块 `a`, `b`, `c` 和 `d` 构建矩阵
    |'
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `a(end)` | `a[-1]` | 访问 MATLAB 向量（1xn 或 nx1）或 1D NumPy 数组 `a`（长度 n）中的最后一个元素
    |'
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,5)` | `a[1, 4]` | 访问二维数组 `a` 中第二行第五列的元素 |'
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,:)` | `a[1]` 或 `a[1, :]` | 二维数组 `a` 的整个第二行 |'
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:5,:)` | `a[0:5]` 或 `a[:5]` 或 `a[0:5, :]` | 二维数组 `a` 的前 5 行 |'
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `a(end-4:end,:)` | `a[-5:]` | 二维数组 `a` 的最后 5 行 |'
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | 二维数组 `a` 的前三行和第五至第九列 |'
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | 第 2、4 和 5 行以及第 1 和
    3 列。这样可以修改矩阵，而且不需要常规切片。 |'
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `a(3:2:21,:)` | `a[2:21:2,:]` | `a` 的每两行，从第三行开始到第二十一行 |'
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:2:end,:)` | `a[::2, :]` | `a` 的每两行，从第一行开始 |'
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `a(end:-1:1,:)` 或 `flipud(a)` | `a[::-1,:]` | `a` 的行顺序反转 |'
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` 的复制，将第一行附加到末尾 |'
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `a.''` | `a.transpose()` 或 `a.T` | `a` 的转置 |'
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `a''` | `a.conj().transpose()` 或 `a.conj().T` | `a` 的共轭转置 |'
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | `a @ b` | 矩阵相乘 |'
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `a .* b` | `a * b` | 逐元素相乘 |'
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `a./b` | `a/b` | 逐元素除 |'
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `a.^3` | `a**3` | 逐元素求幂 |'
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `(a > 0.5)` | `(a > 0.5)` | 矩阵的第 i,j 个元素为 (a_ij > 0.5)。MATLAB 的结果是逻辑值 0 和
    1 的数组。NumPy 的结果是布尔值 `False` 和 `True` 的数组。 |'
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | 找出 (`a` > 0.5) 的索引 |'
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | 提取 `a` 中向量 v > 0.5
    的列 |'
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | 提取 `a` 中列向量 v > 0.5 的列 |'
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` 中小于 0.5 的元素清零 |'
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` 中小于 0.5 的元素清零 |'
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `a(:) = 3` | `a[:] = 3` | 将所有值设为相同的标量值 |'
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `y=x` | `y = x.copy()` | NumPy 通过引用进行赋值 |'
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy 切片是引用传递的 |'
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(:)` | `y = x.flatten()` | 将数组转换为向量（注意这会强制进行一次复制）。要获得与 MATLAB 相同的数据顺序，使用
    `x.flatten(''F'')`。 |'
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `1:10` | `np.arange(1., 11.)` 或 `np.r_[1.:11.]` 或 `np.r_[1:10:10j]` | 创建递增向量（见注释
    [RANGES](#numpy-for-matlab-users-notes)） |'
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `0:9` | `np.arange(10.)` 或 `np.r_[:10.]` 或 `np.r_[:9:10j]` | 创建递增向量（见注释 [RANGES](#numpy-for-matlab-users-notes)）
    |'
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | 创建列向量 |'
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4)` | `np.zeros((3, 4))` | 64 位浮点 0 组成的 3x4 二维数组 |'
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 64 位浮点 0 组成的 3x4x5 三维数组 |'
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ones(3,4)` | `np.ones((3, 4))` | 64 位浮点 1 组成的 3x4 二维数组 |'
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `eye(3)` | `np.eye(3)` | 3x3 单位矩阵 |'
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `diag(a)` | `np.diag(a)` | 返回二维数组 `a` 的对角元素向量 |'
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `diag(v,0)` | `np.diag(v, 0)` | 返回一个正方形对角阵，其非零值是向量`v`的元素 |'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者旧版本：`random.rand((3, 4))` | 用默认随机数生成器和seed = 42生成一个3x4的随机数组 |
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 在1和3之间生成4个等间距的样本，包括边界值 |'
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]`或`np.meshgrid(r_[0:9.],r_[0:6.])`
    | 两个二维数组：一个是x值，另一个是y值 |'
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  | `ogrid[0:9.,0:6.]`或`np.ix_(np.r_[0:9.],np.r_[0:6.]` | 在网格上评估函数的最佳方法 |'
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  | `np.ix_([1,2,4],[2,4,5])` | 在网格上评估函数的最佳方法 |'
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | 创建m行n列的`a`副本 |'
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `[a b]` | `np.concatenate((a,b),1)`或`np.hstack((a,b))`或`np.column_stack((a,b))`或`np.c_[a,b]`
    | 连接`a`和`b`的列 |'
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `[a; b]` | `np.concatenate((a,b))`或`np.vstack((a,b))`或`np.r_[a,b]` | 连接`a`和`b`的行
    |'
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `max(max(a))` | `a.max()`或`np.nanmax(a)` | `a`的最大元素（对于MATLAB，如果存在NaN值，`nanmax`将忽略这些值并返回最大值）
    |'
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `max(a)` | `a.max(0)` | 数组`a`每列的最大元素 |'
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,[],2)` | `a.max(1)` | 数组`a`每行的最大元素 |'
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,b)` | `np.maximum(a, b)` | 逐元素比较`a`和`b`，并返回每对中的最大值 |'
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `norm(v)` | `np.sqrt(v @ v)`或`np.linalg.norm(v)` | 向量`v`的L2范数 |'
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `a & b` | `logical_and(a,b)` | 逐元素的与运算符（NumPy ufunc）[查看逻辑运算符注意事项](#numpy-for-matlab-users-notes)
    |'
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124; b` | `np.logical_or(a,b)` | 逐元素的或运算符（NumPy ufunc）[查看逻辑运算符注意事项](#numpy-for-matlab-users-notes)
    |'
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `bitand(a,b)` | `a & b` | 位与运算符（Python原生和NumPy ufunc） |'
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `bitor(a,b)` | `a &#124; b` | 位或运算符（Python原生和NumPy ufunc） |'
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `inv(a)` | `linalg.inv(a)` | 二维方阵`a`的逆矩阵 |'
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `pinv(a)` | `linalg.pinv(a)` | 二维数组`a`的伪逆矩阵 |'
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `rank(a)` | `np.linalg.matrix_rank(a)` | 二维数组`a`的矩阵秩 |'
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `a\b` | 如果`a`是方阵，则`linalg.solve(a, b)`；否则为`linalg.lstsq(a, b)` | 解方程`a x
    = b` |'
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `b/a` | 解`a.T x.T = b.T` | 解方程`x a = b` |'
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | `a`的奇异值分解 |'
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `chol(a)` | `linalg.cholesky(a)` | 二维数组`a`的Cholesky分解 |'
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | `a`的特征值\(\lambda\)和特征向量\(v\)，其中\(\mathbf{a}
    v = \lambda v\) |'
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | `a`, `b`的特征值\(\lambda\)和特征向量\(v\)，其中\(\mathbf{a}
    v = \lambda \mathbf{b} v\) |'
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | 二维数组`a`的前`k=3`个最大特征值和特征向量 |'
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR 分解 |'
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `[L,U,P]=lu(a)`，其中 `a==P''*L*U` | `P,L,U = linalg.lu(a)`，其中 `a == P@L@U`
    | 带有部分主元选取的 LU 分解（注意：P（MATLAB）== transpose(P（NumPy）)） |'
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `conjgrad` | `cg` | 共轭梯度求解器 |'
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `fft(a)` | `np.fft.fft(a)` | 数组 `a` 的傅里叶变换 |'
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `ifft(a)` | `np.fft.ifft(a)` | 数组 `a` 的逆傅里叶变换 |'
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a)` | `np.sort(a)` 或 `a.sort(axis=0)` | 对二维数组 `a` 的每一列进行排序 |'
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a, 2)` | `np.sort(a, axis=1)` 或 `a.sort(axis=1)` | 对二维数组 `a` 的每一行进行排序
    |'
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | 将数组 `a` 按照第一列排序后保存为数组
    `b` |'
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | 执行形如 \(\mathbf{Zx}=\mathbf{y}\) 的线性回归
    |'
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | 用低通滤波进行下采样 |'
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `unique(a)` | `np.unique(a)` | 数组 `a` 中唯一的数值 |'
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `squeeze(a)` | `a.squeeze()` | 删除数组 `a` 的单元素维度。注意，MATLAB 始终返回 2D 或更高维度的数组，而
    NumPy 返回 0D 或更高维度的数组 |'
- en: '## Notes'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '## 注意事项'
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**子矩阵**：可以使用索引列表和 `ix_` 命令对子矩阵进行赋值。例如，对于二维数组 `a`，可以执行：`ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`。'
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**HELP**: Python 没有直接等价于 MATLAB 的 `which` 命令，但是 `help` 命令和 [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") 命令通常会列出函数所在的文件名。Python 还有一个 `inspect` 模块（使用 `import inspect` 导入），其中提供了一个
    `getfile` 方法，该方法通常起作用。'
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**INDEXING**: MATLAB 使用基于 1 的索引，所以一个序列的初始元素索引为 1。Python 使用基于 0 的索引，所以一个序列的初始元素索引为
    0。混淆和争议产生是因为每种方式都有优劣之处。基于 1 的索引与人们常用的自然语言使用方式一致，其中序列的“第一个”元素索引为 1。基于 0 的索引[简化了索引操作](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en)。还可参考[Edsger
    W. Dijkstra 教授的某篇文本](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)。'
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**RANGES**：在 MATLAB 中，`0:5` 可以作为区间文字和“切片”索引使用（在圆括号内）；然而，在 Python 中，形如 `0:5`
    的结构*只能*作为“切片”索引使用（在方括号内）。因此，为了使 NumPy 具有类似简洁的区间构造机制，创建了有点古怪的 `r_` 对象。注意，`r_` 不像函数或构造函数一样调用，而是使用方括号进行索引，这允许在参数中使用
    Python 的切片语法。'
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**：在NumPy中，`&`或`|`是按位AND/OR运算符，而在MATLAB中，&和`|`是逻辑AND/OR运算符。这两者看起来可能是相同的，但存在重要的区别。如果你曾经使用过MATLAB的`&`或`|`运算符，你应该使用NumPy的ufuncs
    `logical_and`/`logical_or`。MATLAB的`&`和`|`运算符与NumPy的`&`和`|`运算符之间的显着差异包括：'
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非逻辑{0,1}输入：NumPy的输出是输入的按位AND运算。MATLAB将任何非零值视为1，并返回逻辑AND。例如，在NumPy中`(3 & 4)`是`0`，而在MATLAB中`3`和`4`都被视为逻辑真，`(3
    & 4)`返回`1`。
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级：NumPy的&运算符的优先级高于诸如`<`和`>`的逻辑运算符；MATLAB的优先级相反。
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你有布尔参数，你可以使用NumPy的按位运算符，但要小心处理括号，就像这样：`z = (x > 1) & (x < 2)`。NumPy没有`logical_and`和`logical_or`运算符形式是Python设计中不幸的结果。
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**重塑和线性索引**：MATLAB始终允许使用标量或线性索引来访问多维数组，NumPy则不允许。线性索引在MATLAB程序中很常见，例如对矩阵进行`find()`操作返回它们，而NumPy的`find()`操作行为不同。在转换MATLAB代码时，可能需要首先将矩阵重塑为线性序列，进行一些索引操作，然后再重塑回去。由于重塑（通常）生成对存储空间的视图，因此应该可以相当有效地进行此操作。请注意，NumPy中的reshape使用的扫描顺序默认为“C”顺序，而MATLAB使用Fortran顺序。如果你只是将其转换为线性序列并返回，这并不重要。但是，如果你要从依赖扫描顺序的MATLAB代码中转换重塑操作，那么此MATLAB代码：`z
    = reshape(x,3,4);`应该在NumPy中变成`z = x.reshape(3,4,order=''F'').copy()`。'
- en: ‘array’ or ‘matrix’? Which should I use?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ‘array’或‘matrix’？我应该使用哪一个？
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史角度来看，NumPy提供了一个特殊的矩阵类型* np.matrix*，它是ndarray的子类，可以进行二进制运算和线性代数运算。你可能会在一些现有代码中看到它的使用，而不是*
    np.array*。那么，应该使用哪一个？
- en: Short answer
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简短回答
- en: '**Use arrays**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用数组**。'
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在MATLAB中支持的多维数组代数
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是NumPy的标准向量/矩阵/张量类型。许多NumPy函数返回数组而不是矩阵。
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在元素级运算和线性代数运算之间存在明显区别。
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以拥有标准向量或行/列向量。
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Python 3.5之前，使用数组类型的唯一劣势是你必须使用`dot`而不是`*`来对两个张量（标量积，矩阵向量乘法等）进行乘法运算。自Python
    3.5以来，你可以使用矩阵乘法`@`运算符。
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述问题，我们打算最终弃用`matrix`。
- en: Long answer
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长回答
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy包含`array`类和`matrix`类。`array`类旨在为许多种数值计算提供通用的n维数组，而`matrix`类旨在特定的线性代数计算。实际上，这两者之间只有少数几个关键的区别。
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符`*`和`@`，函数`dot()`和`multiply()`：
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`array`，**``*``表示逐元素相乘**，而**``@``表示矩阵乘法**；它们有关联的函数`multiply()`和`dot()`。（在Python
    3.5之前，`@`不存在，必须使用`dot()`进行矩阵乘法）。
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`matrix`，**``*``表示矩阵乘法**，对于逐元素相乘，必须使用`multiply()`函数。
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理向量（一维数组）
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`array`，**形状为1xN、Nx1和N的向量是完全不同的**。例如`A[:,1]`返回形状为N的一维数组，而不是形状为Nx1的二维数组。一维`array`的转置没有任何效果。
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`matrix`，**一维数组始终被上转换为1xN或Nx1矩阵**（行向量或列向量）。`A[:,1]`返回形状为Nx1的二维矩阵。
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理更高维度数组（ndim > 2）
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`对象**可以有大于2的维度**；'
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix`对象**始终具有确切的两个维度**。'
- en: Convenience attributes
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便的属性
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`**具有.T属性**，返回数据的转置。'
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix`**还具有.H、.I和.A属性**，分别返回矩阵的共轭转置、逆矩阵和asarray()。'
- en: Convenience constructor
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便的构造函数
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`构造函数**以（嵌套）Python序列作为初始化器**。如，`array([[1,2,3],[4,5,6]])`。'
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix`构造函数另外**接受方便的字符串初始化器**。如`matrix("[1 2 3; 4 5 6]")`。'
- en: 'There are pros and cons to using both:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两者都有利有弊：
- en: '`array`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`'
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 逐元素相乘很容易：`A*B`。'
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:(` 必须记住，矩阵乘法有自己的操作符`@`。'
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 您可以将一维数组视为*行向量*或*列向量*。`A @ v`将`v`视为列向量，而`v @ A`将`v`视为行向量。这可以节省您的很多转置输入。'
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` `array`是“默认”的NumPy类型，因此经过最多测试，并且是第三方使用NumPy的代码最有可能返回的类型。'
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 可以很好地处理任意维度的数据。'
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 如果你熟悉张量代数，`:`更接近语义。'
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` *所有*操作（`*`，`/`，`+`，`-` 等）都是逐元素的。'
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:(` 来自`scipy.sparse`的稀疏矩阵与数组的交互性不佳。'
- en: '`matrix`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix`'
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:\\` 行为更像MATLAB的矩阵。'
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(`最多为二维。要保存三维数据，您需要`array`或者可能是一个`matrix`的Python列表。'
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(`最少为二维。不能有向量。它们必须被强制转换为单列或单行矩阵。'
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 由于`array`在NumPy中是默认值，一些函数可能返回一个`array`，即使你给它们一个`matrix`作为参数。这不应该发生在NumPy函数中（如果发生了，那是一个错误），但基于NumPy的第三方代码可能不会像NumPy那样遵守类型保留。'
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` `A*B`是矩阵乘法，因此看起来就像您在线性代数中编写一样（对于Python >= 3.5，普通数组使用`@`操作符具有相同的便利）。'
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 按元素相乘需要调用函数`multiply(A,B)`。'
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 操作符重载的使用有点不合逻辑：`*`不是按元素运行，但`/`是。'
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`scipy.sparse`的交互方式更清晰。
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`array`更加明智。的确，我们最终打算废弃`matrix`。
- en: Customizing your environment
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义您的环境
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在MATLAB中，用于自定义环境的主要工具是修改搜索路径，包含您喜欢函数的位置。您可以将这种定制放入MATLAB将在启动时运行的启动脚本中。
- en: NumPy, or rather Python, has similar facilities.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy，或者更确切地说是Python，具有类似的功能。
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改Python搜索路径以包括您自己模块的位置，请定义`PYTHONPATH`环境变量。
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在启动交互式Python解释器时执行特定的脚本文件，请定义`PYTHONSTARTUP`环境变量，其中包含您启动脚本的名称。
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与MATLAB不同，在Python中，您需要首先执行一个‘import’语句来使特定文件中的函数可访问。
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个看起来像这样的启动脚本（注意：这只是一个例子，不是“最佳实践”的陈述）：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不推荐使用的*matrix*和其他*matlib*函数：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Links
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)找到另一个有些过时的MATLAB/NumPy交叉参考。
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[专题软件页面](https://scipy.org/topical-software.html)中找到用于科学工作的Python的工具的广泛列表。
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[Python软件列表：脚本](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)以获取使用Python作为脚本语言的软件列表
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB®和SimuLink®是The MathWorks，Inc.的注册商标。
- en: Introduction
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB®和NumPy有很多共同之处，但NumPy是为了与Python一起工作而创建的，并不是MATLAB的克隆。本指南将帮助MATLAB用户开始使用NumPy。
- en: Some key differences
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些关键区别
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: Rough equivalents
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: General purpose equivalents
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 使用 for 循环使用 [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(在 Python v3.11)") 打印数字 1、2 和 3 |'
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `a && b` | `a and b` | 短路逻辑与运算符（[Python 原生运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "(在 Python v3.11)")）；只适用于标量参数 |'
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124;&#124; b` | `a or b` | 短路逻辑或运算符（[Python 原生运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "(在 Python v3.11)")）；只适用于标量参数 |'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| Python 中的[布尔对象](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(在 Python v3.11)")是 `True` 和 `False`，不同于 MATLAB 的逻辑类型为 `1` 和 `0`。 |'
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个 if-else 语句来检查 `a` 是否为 4 或 5 并打印结果 |'
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | 复数 |'
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `eps` | `np.finfo(float).eps` 或 `np.spacing(1)` | 浮���数精度，即从 1 到下一个更大的可表示实数的距离
    |'
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `load data.mat` | `io.loadmat(''data.mat'')` | 加载保存在文件 `data.mat` 中的 MATLAB
    变量。 （注意：在 MATLAB/Octave 中将数组保存到 `data.mat` 时，请使用最新的二进制格式。[`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(在 SciPy v1.11.2)") 将创建一个带有保存的数组和进一步信息的字典。） |'
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `ode45` | `integrate.solve_ivp(f)` | 用 4,5 阶龙格-库塔法积分解一个 ODE |'
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | 用 BDF 方法积分解一个 ODE |'
- en: Linear algebra equivalents
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性代数的等价操作
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: MATLAB | NumPy | 注释 |
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `ndims(a)` | `np.ndim(a)` 或 `a.ndim` | 数组 `a` 的维数 |'
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `numel(a)` | `np.size(a)` 或 `a.size` | 数组 `a` 的元素个数 |'
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `size(a)` | `np.shape(a)` 或 `a.shape` | 数组 `a` 的“大小” |'
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `size(a,n)` | `a.shape[n-1]` | 获取数组 `a` 的第 n 维中的元素数。 （注意 MATLAB 使用基于 1 的索引，而
    Python 使用基于 0 的索引，请参见[INDEXING](#numpy-for-matlab-users-notes)） |'
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | 定义一个 2x3
    的 2D 数组 |'
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | 从块 `a`、`b`、`c` 和 `d` 构造一个矩阵
    |'
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `a(end)` | `a[-1]` | 访问 MATLAB 向量（1xn 或 nx1）或 1D NumPy 数组 `a`（长度为 n）中的最后一个元素
    |'
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,5)` | `a[1, 4]` | 访问 2D 数组 `a` 中第二行第五列的元素 |'
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,:)` | `a[1]` 或 `a[1, :]` | 2D 数组 `a` 的整个第二行 |'
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:5,:)` | `a[0:5]` 或 `a[:5]` 或 `a[0:5, :]` | 数组 `a` 的前 5 行 |'
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `a(end-4:end,:)` | `a[-5:]` | 2D 数组 `a` 的最后 5 行 |'
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | 2D 数组 `a` 的第一行到第三行和第五列到第九列 |'
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | 第 2、4 和 5 行以及第 1 和
    3 列。 这样可以修改矩阵，不需要常规切片。 |'
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `a(3:2:21,:)` | `a[2:21:2,:]` | 每隔一行的`a`，从第三行开始到第二十一行 |'
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:2:end,:)` | `a[::2, :]` | `a` 的每隔一行，从第一行开始 |'
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `a(end:-1:1,:)` 或 `flipud(a)` | `a[::-1,:]` | 行以相反顺序的`a` |'
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | 在末尾附加第一行后的`a` |'
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `a.''` | `a.transpose()` 或 `a.T` | `a` 的转置 |'
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `a''` | `a.conj().transpose()` 或 `a.conj().T` | `a` 的共轭转置 |'
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | `a @ b` | 矩阵相乘 |'
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `a .* b` | `a * b` | 逐元素相乘 |'
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `a./b` | `a/b` | 逐元素除法 |'
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `a.^3` | `a**3` | 逐元素指数运算 |'
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `(a > 0.5)` | `(a > 0.5)` | 其i，j元素为(a_ij > 0.5)的矩阵。MATLAB结果是由逻辑值0和1组成的数组。NumPy结果是由布尔值`False`和`True`组成的数组。
    |'
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | 寻找(`a` > 0.5)的索引 |'
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | 提取向量v中大于0.5的列的`a`
    |'
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | 提取向量v中大于0.5的列的`a` |'
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` 中小于0.5的元素归零 |'
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` 中小于0.5的元素归零 |'
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `a(:) = 3` | `a[:] = 3` | 将所有值设置为相同的标量值 |'
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `y=x` | `y = x.copy()` | NumPy通过引用赋值 |'
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy的切片是通过引用进行的 |'
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(:)` | `y = x.flatten()` | 将数组转换为向量（请注意，这会强制进行复制）。要获得与MATLAB中的数据顺序相同的数据顺序，请使用`x.flatten(''F'')`。
    |'
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `1:10` | `np.arange(1., 11.)` 或 `np.r_[1.:11.]` 或 `np.r_[1:10:10j]` | 创建一个递增向量（见注[RANGES](#numpy-for-matlab-users-notes)）
    |'
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `0:9` | `np.arange(10.)` 或 `np.r_[:10.]` 或 `np.r_[:9:10j]` | 创建一个递增向量（见注[RANGES](#numpy-for-matlab-users-notes)）
    |'
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | 创建一个列向量 |'
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4)` | `np.zeros((3, 4))` | 64位浮点零值填充的3x4二维数组 |'
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 64位浮点零值填充的3x4x5三维数组 |'
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `ones(3,4)` | `np.ones((3, 4))` | 64位浮点1值填充的3x4二维数组 |'
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `eye(3)` | `np.eye(3)` | 3x3单位矩阵 |'
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `diag(a)` | `np.diag(a)` | 返回2D数组`a`的对角线元素的向量 |'
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `diag(v,0)` | `np.diag(v, 0)` | 返回一个非零值为向量`v`元素的方形对角矩阵 |'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'or older version: `random.rand((3, 4))` | 用默认的随机数生成器和种子 = 42 生成一个随机的3x4数组 |'
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 在1和3之间等间隔取4个样本，包括1和3 |'
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` 或 `np.meshgrid(r_[0:9.],r_[0:6.])`
    | 两个二维数组：一个是 x 值，另一个是 y 值 |'
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  | `ogrid[0:9.,0:6.]` 或 `np.ix_(np.r_[0:9.],np.r_[0:6.]` | 在网格上评估函数的最佳方法
    |'
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` | 两个二维数组：一个是
    x 值，另一个是 y 值 |'
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  | `np.ix_([1,2,4],[2,4,5])` | 在网格上评估函数的最佳方法 |'
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | 创建 `a` 的 m 行 n 列的副本 |'
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `[a b]` | `np.concatenate((a,b),1)` 或 `np.hstack((a,b))` 或 `np.column_stack((a,b))`
    或 `np.c_[a,b]` | 拼接 `a` 和 `b` 的列 |'
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `[a; b]` | `np.concatenate((a,b))` 或 `np.vstack((a,b))` 或 `np.r_[a,b]` |
    拼接 `a` 和 `b` 的行 |'
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `max(max(a))` | `a.max()` 或 `np.nanmax(a)` | `a` 的最大元素（对于 MATLAB 的 ndims(a)<=2，如果存在
    NaN，则 `nanmax` 将忽略这些值并返回最大值） |'
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `max(a)` | `a.max(0)` | 数组 `a` 每列的最大元素 |'
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,[],2)` | `a.max(1)` | 数组 `a` 每行的最大元素 |'
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,b)` | `np.maximum(a, b)` | 逐元素比较 `a` 和 `b` ，返回每对中最大的值 |'
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `norm(v)` | `np.sqrt(v @ v)` 或 `np.linalg.norm(v)` | 向量 `v` 的 L2 范数 |'
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `a & b` | `logical_and(a,b)` | 逐元素 AND 运算符（NumPy ufunc）[参见注释 LOGICOPS](#numpy-for-matlab-users-notes)
    |'
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124; b` | `np.logical_or(a,b)` | 逐元素 OR 运算符（NumPy ufunc）[参见注释 LOGICOPS](#numpy-for-matlab-users-notes)
    |'
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `bitand(a,b)` | `a & b` | 按位 AND 运算符（Python 原生和 NumPy ufunc） |'
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `bitor(a,b)` | `a &#124; b` | 按位 OR 运���符（Python 原生和 NumPy ufunc） |'
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `inv(a)` | `linalg.inv(a)` | 方阵 `a` 的逆 |'
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `pinv(a)` | `linalg.pinv(a)` | 二维数组 `a` 的伪逆 |'
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `rank(a)` | `np.linalg.matrix_rank(a)` | 二维数组 `a` 的秩 |'
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `a\b` | 如果 `a` 是方阵，则为 `linalg.solve(a, b)`；否则为 `linalg.lstsq(a, b)` | 解方程
    a x = b 的解 x |'
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `b/a` | 解方程 `a.T x.T = b.T` | 解方程 x a = b 的解 x |'
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | 二维数组 `a` 的奇异值分解
    |'
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `chol(a)` | `linalg.cholesky(a)` | 二维数组 `a` 的 Cholesky 分解 |'
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | `a` 的特征值 \(\lambda\) 和特征向量 \(v\)
    ，满足 \(\mathbf{a} v = \lambda v\) |'
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | `a`，`b` 的特征值 \(\lambda\) 和特征向量
    \(v\) ，满足 \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | 找到二维数组 `a` 中最大的 `k=3` 个特征值和特征向量
    |'
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR 分解 |'
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `[L,U,P]=lu(a)`，其中 `a==P''*L*U` | `P,L,U = linalg.lu(a)`，其中 `a == P@L@U`
    | 带部分主元的 LU 分解（注意：P（MATLAB）==传置（P（NumPy））） |'
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `conjgrad` | `cg` | 共轭梯度解算器 |'
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `fft(a)` | `np.fft.fft(a)` | `a` 的傅里叶变换 |'
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `ifft(a)` | `np.fft.ifft(a)` | `a`的傅立叶反变换 |'
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a)` | `np.sort(a)`或`a.sort(axis=0)` | 排序2D数组`a`的每一列 |'
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a, 2)` | `np.sort(a, axis=1)`或`a.sort(axis=1)` | 对2D数组`a`的每一行进行排序 |'
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I, :]` | 将数组`a`按第一列排序，并保存为数组`b`
    |'
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | 执行形式为\(\mathbf{Zx}=\mathbf{y}\)的线性回归
    |'
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | 通过低通滤波进行下采样
    |'
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `unique(a)` | `np.unique(a)` | 数组`a`中唯一值的向量 |'
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `squeeze(a)` | `a.squeeze()` | 移除数组`a`的单例维度。注意，MATLAB将始终返回2D或更高维数组，而NumPy将返回0D或更高维数组
    |'
- en: General purpose equivalents
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用等价物
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB | NumPy | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `help func` | `info(func)`或`help(func)`或`func?`（在IPython中） | 获取函数*func*的帮助信息
    |'
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `which func` | [见注意事项HELP](#numpy-for-matlab-users-notes) | 查找*func*的定义位置
    |'
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `type func` | `np.source(func)`或`func??`（在IPython中） | 打印*func*的源代码（如果不是原生函数）
    |'
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `% comment` | `# comment` | 使用文本`comment`对代码行进行注释 |'
- en: '|'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 使用for循环打印数字1, 2和3，使用[`range`](https://docs.python.org/3/library/stdtypes.
    html#range "(在Python v3.11中)") |'
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `a && b` | `a and b` | 短路逻辑AND运算符（[Python本机运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "(在Python v3.11中)"); 仅标量参数 |'
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124;&#124; b` | `a or b` | 短路逻辑OR运算符（[Python本机运算符](https://docs.python.org/3/library/stdtypes.html#boolean
    "(在Python v3.11中)"); 仅标量参数 |'
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 在Python中，[布尔对象](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(在Python v3.11中)")是`True`和`False`，而不是MATLAB的逻辑类型`1`和`0`。'
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 创建一个if-else语句以检查`a`是否为4或5，并打印结果 |'
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `1*i`、`1*j`、`1i`、`1j` | `1j` | 复数 |'
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `eps` | `np.finfo(float).eps`或`np.spacing(1)` | 从1到双精度下一个较大可表示的实数的距离 |'
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `load data.mat` | `io.loadmat(''data.mat'')` | 加载保存在文件`data.mat`中的MATLAB变量。（注意：在MATLAB/Octave中将数组保存到`data.mat`时，请使用最近的二进制格式。[`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(在SciPy v1.11.2中)")将创建一个包含已保存数组和其他信息的字典。） |'
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `ode45` | `integrate.solve_ivp(f)` | 使用龙格-库塔4,5积分ODE |'
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | 使用BDF方法积分ODE |'
- en: Linear algebra equivalents
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同等的线性代数
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| MATLAB | NumPy | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | 数组 `a` 的维度数 |'
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `numel(a)` | `np.size(a)` or `a.size` | 数组 `a` 的元素个数 |'
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `size(a)` | `np.shape(a)` or `a.shape` | 数组 `a` 的尺寸 |'
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `size(a,n)` | `a.shape[n-1]` | 获取数组 `a` 的第 n 维度的元素个数。（注意 MATLAB 使用基于 1 的索引，而
    Python 使用基于 0 的索引，参见注释 [INDEXING](#numpy-for-matlab-users-notes)） |'
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | 定义一个 2x3
    的 2D 数组 |'
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | 从块 `a`、`b`、`c` 和 `d` 构造矩阵
    |'
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `a(end)` | `a[-1]` | 访问 MATLAB 向量（1xn 或 nx1）或长度为 n 的 1D NumPy 数组 `a` 中的最后一个元素
    |'
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,5)` | `a[1, 4]` | 访问 2D 数组 `a` 中第二行第五列的元素 |'
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `a(2,:)` | `a[1]` or `a[1, :]` | 2D 数组 `a` 的第二行 |'
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | 2D 数组 `a` 的前 5 行 |'
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `a(end-4:end,:)` | `a[-5:]` | 2D 数组 `a` 的最后 5 行 |'
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | 2D 数组 `a` 的第一到第三行和第五到第九列 |'
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | 第 2、4 和 5 行以及第 1 和
    3 列。这允许修改矩阵，并且不需要常规切片。 |'
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `a(3:2:21,:)` | `a[2:21:2,:]` | 从第三行开始，每隔一行的 `a`，直到第二十一行 |'
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `a(1:2:end,:)` | `a[::2, :]` | `a` 的每隔一行，从第一行开始 |'
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | 行顺序相��的 `a` |'
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` 的副本，附加了第一行的副本到末尾 |'
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `a.''` | `a.transpose()` or `a.T` | `a` 的转置 |'
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `a''` | `a.conj().transpose()` or `a.conj().T` | `a` 的共轭转置 |'
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | `a @ b` | 矩阵相乘 |'
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `a .* b` | `a * b` | 逐元素相乘 |'
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `a./b` | `a/b` | 逐元素相除 |'
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `a.^3` | `a**3` | 逐元素求幂 |'
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `(a > 0.5)` | `(a > 0.5)` | 矩阵，其第 i、j 个元素为 (a_ij > 0.5)。MATLAB 结果是一个由 0 和
    1 组成的逻辑值数组。NumPy 结果是一个由布尔值 `False` 和 `True` 组成的数组。 |'
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | 找到满足 (`a` > 0.5) 的索引 |'
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | 提取矩阵 `a` 中向量 v > 0.5
    的列 |'
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | 提取矩阵 `a` 中列向量 v > 0.5 的列 |'
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | 小于 0.5 的 `a` 元素变为零 |'
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `a .* (a>0.5)` | `a * (a > 0.5)` | 小于 0.5 的 `a` 元素变为零 |'
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `a(:) = 3` | `a[:] = 3` | 将所有值设置为相同的标量值 |'
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `y=x` | `y = x.copy()` | NumPy 通过引用赋值 |'
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy 的切片是通过引用进行的 |'
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `y=x(:)` | `y = x.flatten()` | 将数组转换成向量（请注意，这会强制执行复制）。为了获得与 MATLAB 中相同的数据排序，使用
    `x.flatten(''F'')`。'
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | 创建一个递增的向量（参见
    [范围注释（RANGES）](#numpy-for-matlab-users-notes)） |'
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | 创建一个递增的向量（参见
    [范围注释（RANGES）](#numpy-for-matlab-users-notes)） |'
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | 创建一个列向量 |'
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4)` | `np.zeros((3, 4))` | 全部为 0 的 3x4 二维数组，64 位浮点类型 |'
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 全部为 0 的 3x4x5 三维数组，64 位浮点类型 |'
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `ones(3,4)` | `np.ones((3, 4))` | 全部为 1 的 3x4 二维数组，64 位浮点类型 |'
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `eye(3)` | `np.eye(3)` | 3x3 单位矩阵 |'
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `diag(a)` | `np.diag(a)` | 返回二维数组 `a` 对角线上的元素构成的向量 |'
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `diag(v,0)` | `np.diag(v, 0)` | 返回一个正方形对角矩阵，其非零值为向量 `v` 的元素 |'
- en: '|'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 或者旧版本：`random.rand((3, 4))` | 使用默认的随机数生成器和 seed = 42 生成一个随机的 3x4 数组 |
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 在 1 到 3 之间生成 4 个等差样本，包括边界值 |'
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | 两个 2D 数组：一个是 x 值，另一个是 y 值 |'
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | 在网格上计算函数的最佳方法
    |'
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|  | `np.ix_([1,2,4],[2,4,5])` | 在网格上计算函数的最佳方法 |'
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | 创建大小为 m × n 的 `a` 的副本 |'
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | 连接数组 `a` 和 `b` 的列 |'
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | 连接数组 `a` 和 `b` 的行 |'
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | `a` 的最大值（对于 MATLAB，ndims(a)<=2，如果存在
    NaN，则 `nanmax` 会忽略这些 NaN 并返回最大值） |'
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `max(a)` | `a.max(0)` | 数组 `a` 每列的最大值 |'
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,[],2)` | `a.max(1)` | 数组 `a` 每行的最大值 |'
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `max(a,b)` | `np.maximum(a, b)` | 比较 `a` 和 `b` 的元素并��个返回最大值 |'
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | 向量 `v` 的 L2 范数 |'
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `a & b` | `logical_and(a,b)` | 元素逐个进行与运算（NumPy ufunc）[查看逻辑操作注释（LOGICOPS）](#numpy-for-matlab-users-notes)
    |'
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `a &#124; b` | `np.logical_or(a,b)` | 元素逐个进行或运算（NumPy ufunc）[查看逻辑操作注释（LOGICOPS）](#numpy-for-matlab-users-notes)
    |'
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `bitand(a,b)` | `a & b` | 按位与运算符（Python 原生和 NumPy ufunc） |'
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `bitor(a,b)` | `a &#124; b` | 按位或运算符（Python本地和NumPy ufunc） |'
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `inv(a)` | `linalg.inv(a)` | 2D数组`a`的逆 |'
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `pinv(a)` | `linalg.pinv(a)` | 2D数组`a`的伪逆 |'
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `rank(a)` | `np.linalg.matrix_rank(a)` | 2D数组`a`的矩阵秩 |'
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `a\b` | 若`a`是方阵使用`linalg.solve(a, b)`；否则使用`linalg.lstsq(a, b)` | 解线性方程组`a
    x = b`得到的解x |'
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `b/a` | 解`a.T x.T = b.T` | 解方程`x a = b`得到的解x |'
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | `a`的奇异值分解 |'
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `chol(a)` | `linalg.cholesky(a)` | 2D数组`a`的Cholesky分解 |'
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | `a`的特征值\(\lambda\)和特征向量\(v\)，其中\(\mathbf{a}
    v = \lambda v\) |'
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | `a`和`b`的特征值\(\lambda\)和特征向量\(v\)，其中\(\mathbf{a}
    v = \lambda \mathbf{b} v\) |'
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | 找到2D数组`a`的前`k=3`个最大特征值和特征向量 |'
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR分解 |'
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `[L,U,P]=lu(a)`，其中`a==P''*L*U` | `P,L,U = linalg.lu(a)`，其中`a == P@L@U` |
    具有部分主元的LU分解（注意：P（MATLAB）==转置P（NumPy）） |'
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `conjgrad` | `cg` | 共轭梯度解算器 |'
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `fft(a)` | `np.fft.fft(a)` | `a`的傅里叶变换 |'
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `ifft(a)` | `np.fft.ifft(a)` | `a`的傅里叶逆变换 |'
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a)` | `np.sort(a)`或`a.sort(axis=0)` | 对2D数组`a`的每一列排序 |'
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `sort(a, 2)` | `np.sort(a, axis=1)`或`a.sort(axis=1)` | 对2D数组`a`的每一行排序 |'
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | 将数组`a`按第一列排序后保存为数组`b`
    |'
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | 执行形式为\(\mathbf{Zx}=\mathbf{y}\)的线性回归
    |'
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | 通过低通滤波下采样 |'
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `unique(a)` | `np.unique(a)` | 数组`a`中的唯一值向量 |'
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `squeeze(a)` | `a.squeeze()` | 移除数组`a`的单例维度。请注意，MATLAB始终返回2D或更高阶数组，而NumPy将返回0D或更高阶数组
    |'
- en: '## Notes'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '## 注释'
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**子矩阵**: 可以使用`ix_`命令和索引列表对子矩阵进行赋值。例如，对于2D数组`a`，可以这样操作：`ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`。'
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助**: Python没有直接相当于MATLAB中`which`命令的命令，但[`help`](https://docs.python.org/3/library/functions.html#help
    "(in Python v3.11)")和[`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source")命令通常会列出函数所在的文件名。Python还有一个`inspect`模块（导入`import inspect`），其中提供了一个`getfile`函数通常也会起作用。'
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引**：MATLAB 使用基于一的索引，因此序列的初始元素索引为 1。Python 使用基于零的索引，因此序列的初始元素索引为 0。关于这一点可能会产生混淆和激烈争论，因为每种方式都有其优势和劣势。基于一的索引符合通常的人类语言使用习惯，其中序列的“第一个”元素索引为
    1。基于零的索引简化了索引操作。也请参见 [Edsger W. Dijkstra 教授的一篇文章](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)。'
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**范围**：在 MATLAB 中，`0:5`既可以用作范围字面量，也可以用作‘切片’索引（放在括号内）；然而在 Python 中，像`0:5`这样的构造只能作为切片索引（放在方括号内）使用。因此，为了使
    NumPy 可以拥有类似简洁的范围构造机制，特别创建了`r_`对象。需要注意的是，`r_` 不像函数或构造函数一样被调用，而是使用方括号进行索引，这样可以在参数中使用
    Python 的切片语法。'
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑操作**：在 NumPy 中，`&` 和 `|` 是按位与/或运算，而在 MATLAB 中，& 和 `|` 分别是逻辑与/或运算。这两者看起来可能是一样的，但实际上存在重要的区别。如果你曾经使用过
    MATLAB 的 `&` 或 `|` 运算符，那么在 NumPy 中应该使用对应的 ufuncs `logical_and`/`logical_or`。MATLAB
    和 NumPy 的 `&` 和 `|` 操作符之间的显著区别包括：'
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非逻辑 {0,1} 输入：NumPy 的输出是输入的按位与。MATLAB 将任何非零值视为 1，并返回逻辑与。例如在 NumPy 中 `(3 & 4)`
    的结果是 `0`，而在 MATLAB 中 `3` 和 `4` 都被视为逻辑 true，因此 `(3 & 4)` 的结果是 `1`。
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级：NumPy 的 `&` 运算符的优先级高于诸如 `<` 和 `>` 的逻辑运算符；而 MATLAB 则相反。
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道参数是布尔值，你可以使用 NumPy 的按位运算符，但是在使用括号时要小心，就像这样：`z = (x > 1) & (x < 2)`。NumPy
    没有形式上的 `logical_and` 和 `logical_or` 运算符是 Python 设计的一个不幸的结果。
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: ‘array’ or ‘matrix’? Which should I use?
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 与张量代数更接近的语义，如果你熟悉的话。'
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` 所有操作（`*`、`/`、`+`、`-` 等）都是逐个元素进行的。'
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:(` 使用 `scipy.sparse` 的稀疏矩阵与数组的交互效果不太好。'
- en: '`matrix`'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:\\` 行为更像 MATLAB 矩阵。'
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 二维矩阵的最大值。要保存三维数据，你需要使用 `array` 或者可能是一个 `matrix` 的 Python 列表。'
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 二维矩阵的最小值。你不能有向量。它们必须被转换为单列矩阵或单行矩阵。'
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 由于 `array` 是 NumPy 的默认选项，所以一些函数可能会返回一个 `array`，即使你将 `matrix` 作为参数传递给它们也会如此。
    NumPy 函数不应该出现这种情况（如果出现了就是一个 bug），但基于 NumPy 的第三方代码可能不像 NumPy 那样保留类型信息。'
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` `A*B` 是矩阵乘法，因此它的写法与线性代数中一样（对于 Python >= 3.5，普通数组可以使用 `@` 操作符达到相同的方便性）。'
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 对元素进行逐个乘法操作需要调用函数 `multiply(A, B)`。'
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 操作符重载的使用有点不合逻辑：`*` 不对元素进行操作，但 `/` 是对每个元素进行操作的。'
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `scipy.sparse` 的交互更清晰。
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更建议使用 `array`。事实上，我们打算最终废弃 `matrix`。
- en: Customizing your environment
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制环境
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MATLAB 中，定制环境的主要工具是修改搜索路径以包含你喜欢的函数的位置。你可以将这样的定制放入 MATLAB 在启动时运行的启动脚本中。
- en: NumPy, or rather Python, has similar facilities.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy，或者更准确地说是 Python，有类似的功能。
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要修改 Python 搜索路径以包含自己模块的位置，请定义 `PYTHONPATH` 环境变量。
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动交互式 Python 解释器时，若要执行特定的脚本文件，请定义 `PYTHONSTARTUP` 环境变量，其包含你启动脚本的名称。
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MATLAB 不同，你需要先使用 'import' 语句使特定文件中的函数可访问，然后才能立即调用。
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个启动脚本，内容如下（注意：此处仅为示例，并不是“最佳实践”的陈述）：
- en: '[PRE28]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用已弃用的 *matrix* 和其他 *matlib* 函数：
- en: '[PRE29]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Links
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/) 可以找到另一个相对陈旧的 MATLAB/NumPy
    相关信息。
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [主题软件页面](https://scipy.org/topical-software.html) 中找到用于使用 Python 进行科学工作的工具的详尽列表。
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 [Python 软件列表：脚本语言](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    获取使用 Python 作为脚本语言的软件列表。
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB® 和 SimuLink® 是 The MathWorks, Inc. 的注册商标。
