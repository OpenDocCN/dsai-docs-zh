- en: scipy.linalg.qz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.qz.html#scipy.linalg.qz](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.qz.html#scipy.linalg.qz)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: QZ decomposition for generalized eigenvalues of a pair of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The QZ, or generalized Schur, decomposition for a pair of n-by-n matrices (A,B)
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'where AA, BB is in generalized Schur form if BB is upper-triangular with non-negative
    diagonal and AA is upper-triangular, or for real QZ decomposition (`output=''real''`)
    block upper triangular with 1x1 and 2x2 blocks. In this case, the 1x1 blocks correspond
    to real generalized eigenvalues and 2x2 blocks are ‘standardized’ by making the
    corresponding elements of BB have the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and the pair of corresponding 2x2 blocks in AA and BB will have a complex conjugate
    pair of generalized eigenvalues. If (`output='complex'`) or A and B are complex
    matrices, Z’ denotes the conjugate-transpose of Z. Q and Z are unitary matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: 2-D array to decompose
  prefs: []
  type: TYPE_NORMAL
- en: '**B**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: 2-D array to decompose
  prefs: []
  type: TYPE_NORMAL
- en: '**output**{‘real’, ‘complex’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the real or complex QZ decomposition for real matrices. Default is
    ‘real’.
  prefs: []
  type: TYPE_NORMAL
- en: '**lwork**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Work array size. If None or -1, it is automatically computed.
  prefs: []
  type: TYPE_NORMAL
- en: '**sort**{None, callable, ‘lhp’, ‘rhp’, ‘iuc’, ‘ouc’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE: THIS INPUT IS DISABLED FOR NOW. Use ordqz instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifies whether the upper eigenvalues should be sorted. A callable may be
    passed that, given a eigenvalue, returns a boolean denoting whether the eigenvalue
    should be sorted to the top-left (True). For real matrix pairs, the sort function
    takes three real arguments (alphar, alphai, beta). The eigenvalue `x = (alphar
    + alphai*1j)/beta`. For complex matrix pairs or output=’complex’, the sort function
    takes two complex arguments (alpha, beta). The eigenvalue `x = (alpha/beta)`.
    Alternatively, string parameters may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘lhp’ Left-hand plane (x.real < 0.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rhp’ Right-hand plane (x.real > 0.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘iuc’ Inside the unit circle (x*x.conjugate() < 1.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘ouc’ Outside the unit circle (x*x.conjugate() > 1.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Defaults to None (no sorting).
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_a**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to overwrite data in a (may improve performance)
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_b**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to overwrite data in b (may improve performance)
  prefs: []
  type: TYPE_NORMAL
- en: '**check_finite**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If true checks the elements of *A* and *B* are finite numbers. If false does
    no checking and passes matrix through to underlying algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AA**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized Schur form of A.
  prefs: []
  type: TYPE_NORMAL
- en: '**BB**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized Schur form of B.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The left Schur vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The right Schur vectors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ordqz`](scipy.linalg.ordqz.html#scipy.linalg.ordqz "scipy.linalg.ordqz")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Q is transposed versus the equivalent function in Matlab.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compute the decomposition. The QZ decomposition is not unique, so depending
    on the underlying library that is used, there may be differences in the signs
    of coefficients in the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Verify the QZ decomposition. With real output, we only need the transpose of
    `Z` in the following expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Repeat the decomposition, but with `output='complex'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For conciseness in the output, we use `np.set_printoptions()` to set the output
    precision of NumPy arrays to 3 and display tiny values as 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With complex arrays, we must use `Z.conj().T` in the following expressions to
    verify the decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
