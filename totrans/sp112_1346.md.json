["```py\nscipy.stats.permutation_test(data, statistic, *, permutation_type='independent', vectorized=None, n_resamples=9999, batch=None, alternative='two-sided', axis=0, random_state=None)\n```", "```py\nnp.prod([binom(sum(n[i:]), sum(n[i+1:])) for i in range(len(n)-1)]) \n```", "```py\nfactorial(n)**m \n```", "```py\nfactorial(m)**n \n```", "```py\n>>> import numpy as np\n>>> def statistic(x, y, axis):\n...     return np.mean(x, axis=axis) - np.mean(y, axis=axis) \n```", "```py\n>>> from scipy.stats import norm\n>>> rng = np.random.default_rng()\n>>> x = norm.rvs(size=5, random_state=rng)\n>>> y = norm.rvs(size=6, loc = 3, random_state=rng)\n>>> statistic(x, y, 0)\n-3.5411688580987266 \n```", "```py\n>>> from scipy.stats import permutation_test\n>>> # because our statistic is vectorized, we pass `vectorized=True`\n>>> # `n_resamples=np.inf` indicates that an exact test is to be performed\n>>> res = permutation_test((x, y), statistic, vectorized=True,\n...                        n_resamples=np.inf, alternative='less')\n>>> print(res.statistic)\n-3.5411688580987266\n>>> print(res.pvalue)\n0.004329004329004329 \n```", "```py\n>>> x = norm.rvs(size=100, random_state=rng)\n>>> y = norm.rvs(size=120, loc=0.3, random_state=rng)\n>>> res = permutation_test((x, y), statistic, n_resamples=100000,\n...                        vectorized=True, alternative='less',\n...                        random_state=rng)\n>>> print(res.statistic)\n-0.5230459671240913\n>>> print(res.pvalue)\n0.00016999830001699983 \n```", "```py\n>>> from scipy.stats import ttest_ind\n>>> res_asymptotic = ttest_ind(x, y, alternative='less')\n>>> print(res_asymptotic.pvalue)\n0.00012688101537979522 \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> plt.hist(res.null_distribution, bins=50)\n>>> plt.title(\"Permutation distribution of test statistic\")\n>>> plt.xlabel(\"Value of Statistic\")\n>>> plt.ylabel(\"Frequency\")\n>>> plt.show() \n```", "```py\n>>> from scipy.stats import pearsonr\n>>> x = [1, 2, 4, 3]\n>>> y = [2, 4, 6, 8]\n>>> def statistic(x, y):\n...     return pearsonr(x, y).statistic\n>>> res = permutation_test((x, y), statistic, vectorized=False,\n...                        permutation_type='pairings',\n...                        alternative='greater')\n>>> r, pvalue, null = res.statistic, res.pvalue, res.null_distribution \n```", "```py\n>>> r\n0.8\n>>> unique = np.unique(null)\n>>> unique\narray([-1\\. , -0.8, -0.8, -0.6, -0.4, -0.2, -0.2,  0\\. ,  0.2,  0.2,  0.4,\n 0.6,  0.8,  0.8,  1\\. ]) # may vary\n>>> unique[np.isclose(r, unique)].tolist()\n[0.7999999999999999, 0.8] \n```", "```py\n>>> incorrect_pvalue = np.count_nonzero(null >= r) / len(null)\n>>> incorrect_pvalue\n0.1111111111111111  # may vary \n```", "```py\n>>> correct_pvalue = np.count_nonzero(null >= r - 1e-14) / len(null)\n>>> correct_pvalue\n0.16666666666666666\n>>> res.pvalue == correct_pvalue\nTrue \n```"]