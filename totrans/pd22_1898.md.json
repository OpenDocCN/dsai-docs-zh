["```py\npd.options.future.infer_string = True \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\nIn [2]: df.sum()\nOut[2]:\na    5\nb    9\ndtype: int64\nIn [3]: df = df.astype(\"int64[pyarrow]\")\nIn [4]: df.sum()\nOut[4]:\na    5\nb    9\ndtype: int64 \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\n\nIn [2]: df.sum()\nOut[2]: \na    5\nb    9\ndtype: Int64\n\nIn [3]: df = df.astype(\"int64[pyarrow]\")\n\nIn [4]: df.sum()\nOut[4]: \na    5\nb    9\ndtype: int64[pyarrow] \n```", "```py\nIn [1]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\nIn [2]: ser.map(str.upper, na_action=\"ignore\")\nNotImplementedError\nIn [3]: df = pd.DataFrame(ser)\nIn [4]: df.applymap(str.upper, na_action=\"ignore\")  # worked for DataFrame\n 0\n0    A\n1    B\n2  NaN\nIn [5]: idx = pd.Index(ser)\nIn [6]: idx.map(str.upper, na_action=\"ignore\")\nTypeError: CategoricalIndex.map() got an unexpected keyword argument 'na_action' \n```", "```py\nIn [5]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\n\nIn [6]: ser.map(str.upper, na_action=\"ignore\")\nOut[6]: \n0      A\n1      B\n2    NaN\ndtype: category\nCategories (2, object): ['A', 'B']\n\nIn [7]: df = pd.DataFrame(ser)\n\nIn [8]: df.map(str.upper, na_action=\"ignore\")\nOut[8]: \n 0\n0    A\n1    B\n2  NaN\n\nIn [9]: idx = pd.Index(ser)\n\nIn [10]: idx.map(str.upper, na_action=\"ignore\")\nOut[10]: CategoricalIndex(['A', 'B', nan], categories=['A', 'B'], ordered=False, dtype='category') \n```", "```py\nIn [11]: columns = pd.MultiIndex.from_tuples([(\"B\", \"d\"), (\"A\", \"c\")])\n\nIn [12]: df = pd.DataFrame([[0, 2], [1, 3]], index=[\"z\", \"y\"], columns=columns)\n\nIn [13]: df\nOut[13]: \n B  A\n d  c\nz  0  2\ny  1  3 \n```", "```py\nIn [14]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[14]: \nz  A  c    2.0\n B  d    0.0\ny  A  c    3.0\n B  d    1.0\ndtype: float64\n\nIn [15]: df.stack([0, 1], future_stack=True)\nOut[15]: \nz  B  d    0\n A  c    2\ny  B  d    1\n A  c    3\ndtype: int64 \n```", "```py\nIn [16]: df = pd.DataFrame([[0, 2], [np.nan, np.nan]], columns=columns)\n\nIn [17]: df\nOut[17]: \n B    A\n d    c\n0  0.0  2.0\n1  NaN  NaN\n\nIn [18]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[18]: \n0  A  c    2.0\n B  d    0.0\ndtype: float64\n\nIn [19]: df.stack([0, 1], future_stack=False, dropna=False)\nOut[19]: \n0  A  d    NaN\n c    2.0\n B  d    0.0\n c    NaN\n1  A  d    NaN\n c    NaN\n B  d    NaN\n c    NaN\ndtype: float64\n\nIn [20]: df.stack([0, 1], future_stack=True)\nOut[20]: \n0  B  d    0.0\n A  c    2.0\n1  B  d    NaN\n A  c    NaN\ndtype: float64 \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\nFutureWarning:\n Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas.\n Value 'not an int64' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [21]: ser = pd.Series([1, 2, 3])\n\nIn [22]: ser = ser.astype('object')\n\nIn [23]: ser[0] = 'not an int64'\n\nIn [24]: ser\nOut[24]: \n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [25]: ser = pd.Series([1, 2, 3])\n\nIn [26]: ser = ser.astype('float64')\n\nIn [27]: ser[0] = 1.1\n\nIn [28]: ser\nOut[28]: \n0    1.1\n1    2.0\n2    3.0\ndtype: float64 \n```", "```py\nIn [7]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [8]:  pd.to_datetime(data, utc=False)\nOut[8]:\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [9]: pd.to_datetime(data, utc=False)\nFutureWarning:\n In a future version of pandas, parsing datetimes with mixed time zones will raise\n a warning unless `utc=True`. Please specify `utc=True` to opt in to the new behaviour\n and silence this warning. To create a `Series` with mixed offsets and `object` dtype,\n please use `apply` and `datetime.datetime.strptime`.\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [29]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [30]: pd.to_datetime(data, utc=True)\nOut[30]: DatetimeIndex(['2019-12-31 18:00:00+00:00', '2019-12-31 23:00:00+00:00'], dtype='datetime64[ns, UTC]', freq=None) \n```", "```py\nIn [31]: import datetime as dt\n\nIn [32]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [33]: pd.Series(data).apply(lambda x: dt.datetime.strptime(x, '%Y-%m-%d %H:%M:%S%z'))\nOut[33]: \n0    2020-01-01 00:00:00+06:00\n1    2020-01-01 00:00:00+01:00\ndtype: object \n```", "```py\npd.options.future.infer_string = True \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\nIn [2]: df.sum()\nOut[2]:\na    5\nb    9\ndtype: int64\nIn [3]: df = df.astype(\"int64[pyarrow]\")\nIn [4]: df.sum()\nOut[4]:\na    5\nb    9\ndtype: int64 \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\n\nIn [2]: df.sum()\nOut[2]: \na    5\nb    9\ndtype: Int64\n\nIn [3]: df = df.astype(\"int64[pyarrow]\")\n\nIn [4]: df.sum()\nOut[4]: \na    5\nb    9\ndtype: int64[pyarrow] \n```", "```py\nIn [1]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\nIn [2]: ser.map(str.upper, na_action=\"ignore\")\nNotImplementedError\nIn [3]: df = pd.DataFrame(ser)\nIn [4]: df.applymap(str.upper, na_action=\"ignore\")  # worked for DataFrame\n 0\n0    A\n1    B\n2  NaN\nIn [5]: idx = pd.Index(ser)\nIn [6]: idx.map(str.upper, na_action=\"ignore\")\nTypeError: CategoricalIndex.map() got an unexpected keyword argument 'na_action' \n```", "```py\nIn [5]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\n\nIn [6]: ser.map(str.upper, na_action=\"ignore\")\nOut[6]: \n0      A\n1      B\n2    NaN\ndtype: category\nCategories (2, object): ['A', 'B']\n\nIn [7]: df = pd.DataFrame(ser)\n\nIn [8]: df.map(str.upper, na_action=\"ignore\")\nOut[8]: \n 0\n0    A\n1    B\n2  NaN\n\nIn [9]: idx = pd.Index(ser)\n\nIn [10]: idx.map(str.upper, na_action=\"ignore\")\nOut[10]: CategoricalIndex(['A', 'B', nan], categories=['A', 'B'], ordered=False, dtype='category') \n```", "```py\nIn [11]: columns = pd.MultiIndex.from_tuples([(\"B\", \"d\"), (\"A\", \"c\")])\n\nIn [12]: df = pd.DataFrame([[0, 2], [1, 3]], index=[\"z\", \"y\"], columns=columns)\n\nIn [13]: df\nOut[13]: \n B  A\n d  c\nz  0  2\ny  1  3 \n```", "```py\nIn [14]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[14]: \nz  A  c    2.0\n B  d    0.0\ny  A  c    3.0\n B  d    1.0\ndtype: float64\n\nIn [15]: df.stack([0, 1], future_stack=True)\nOut[15]: \nz  B  d    0\n A  c    2\ny  B  d    1\n A  c    3\ndtype: int64 \n```", "```py\nIn [16]: df = pd.DataFrame([[0, 2], [np.nan, np.nan]], columns=columns)\n\nIn [17]: df\nOut[17]: \n B    A\n d    c\n0  0.0  2.0\n1  NaN  NaN\n\nIn [18]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[18]: \n0  A  c    2.0\n B  d    0.0\ndtype: float64\n\nIn [19]: df.stack([0, 1], future_stack=False, dropna=False)\nOut[19]: \n0  A  d    NaN\n c    2.0\n B  d    0.0\n c    NaN\n1  A  d    NaN\n c    NaN\n B  d    NaN\n c    NaN\ndtype: float64\n\nIn [20]: df.stack([0, 1], future_stack=True)\nOut[20]: \n0  B  d    0.0\n A  c    2.0\n1  B  d    NaN\n A  c    NaN\ndtype: float64 \n```", "```py\npd.options.future.infer_string = True \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\nIn [2]: df.sum()\nOut[2]:\na    5\nb    9\ndtype: int64\nIn [3]: df = df.astype(\"int64[pyarrow]\")\nIn [4]: df.sum()\nOut[4]:\na    5\nb    9\ndtype: int64 \n```", "```py\nIn [1]: df = pd.DataFrame({\"a\": [1, 1, 2, 1], \"b\": [np.nan, 2.0, 3.0, 4.0]}, dtype=\"Int64\")\n\nIn [2]: df.sum()\nOut[2]: \na    5\nb    9\ndtype: Int64\n\nIn [3]: df = df.astype(\"int64[pyarrow]\")\n\nIn [4]: df.sum()\nOut[4]: \na    5\nb    9\ndtype: int64[pyarrow] \n```", "```py\nIn [1]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\nIn [2]: ser.map(str.upper, na_action=\"ignore\")\nNotImplementedError\nIn [3]: df = pd.DataFrame(ser)\nIn [4]: df.applymap(str.upper, na_action=\"ignore\")  # worked for DataFrame\n 0\n0    A\n1    B\n2  NaN\nIn [5]: idx = pd.Index(ser)\nIn [6]: idx.map(str.upper, na_action=\"ignore\")\nTypeError: CategoricalIndex.map() got an unexpected keyword argument 'na_action' \n```", "```py\nIn [5]: ser = pd.Series([\"a\", \"b\", np.nan], dtype=\"category\")\n\nIn [6]: ser.map(str.upper, na_action=\"ignore\")\nOut[6]: \n0      A\n1      B\n2    NaN\ndtype: category\nCategories (2, object): ['A', 'B']\n\nIn [7]: df = pd.DataFrame(ser)\n\nIn [8]: df.map(str.upper, na_action=\"ignore\")\nOut[8]: \n 0\n0    A\n1    B\n2  NaN\n\nIn [9]: idx = pd.Index(ser)\n\nIn [10]: idx.map(str.upper, na_action=\"ignore\")\nOut[10]: CategoricalIndex(['A', 'B', nan], categories=['A', 'B'], ordered=False, dtype='category') \n```", "```py\nIn [11]: columns = pd.MultiIndex.from_tuples([(\"B\", \"d\"), (\"A\", \"c\")])\n\nIn [12]: df = pd.DataFrame([[0, 2], [1, 3]], index=[\"z\", \"y\"], columns=columns)\n\nIn [13]: df\nOut[13]: \n B  A\n d  c\nz  0  2\ny  1  3 \n```", "```py\nIn [14]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[14]: \nz  A  c    2.0\n B  d    0.0\ny  A  c    3.0\n B  d    1.0\ndtype: float64\n\nIn [15]: df.stack([0, 1], future_stack=True)\nOut[15]: \nz  B  d    0\n A  c    2\ny  B  d    1\n A  c    3\ndtype: int64 \n```", "```py\nIn [16]: df = pd.DataFrame([[0, 2], [np.nan, np.nan]], columns=columns)\n\nIn [17]: df\nOut[17]: \n B    A\n d    c\n0  0.0  2.0\n1  NaN  NaN\n\nIn [18]: df.stack([0, 1], future_stack=False, dropna=True)\nOut[18]: \n0  A  c    2.0\n B  d    0.0\ndtype: float64\n\nIn [19]: df.stack([0, 1], future_stack=False, dropna=False)\nOut[19]: \n0  A  d    NaN\n c    2.0\n B  d    0.0\n c    NaN\n1  A  d    NaN\n c    NaN\n B  d    NaN\n c    NaN\ndtype: float64\n\nIn [20]: df.stack([0, 1], future_stack=True)\nOut[20]: \n0  B  d    0.0\n A  c    2.0\n1  B  d    NaN\n A  c    NaN\ndtype: float64 \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\nFutureWarning:\n Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas.\n Value 'not an int64' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [21]: ser = pd.Series([1, 2, 3])\n\nIn [22]: ser = ser.astype('object')\n\nIn [23]: ser[0] = 'not an int64'\n\nIn [24]: ser\nOut[24]: \n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [25]: ser = pd.Series([1, 2, 3])\n\nIn [26]: ser = ser.astype('float64')\n\nIn [27]: ser[0] = 1.1\n\nIn [28]: ser\nOut[28]: \n0    1.1\n1    2.0\n2    3.0\ndtype: float64 \n```", "```py\nIn [7]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [8]:  pd.to_datetime(data, utc=False)\nOut[8]:\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [9]: pd.to_datetime(data, utc=False)\nFutureWarning:\n In a future version of pandas, parsing datetimes with mixed time zones will raise\n a warning unless `utc=True`. Please specify `utc=True` to opt in to the new behaviour\n and silence this warning. To create a `Series` with mixed offsets and `object` dtype,\n please use `apply` and `datetime.datetime.strptime`.\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [29]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [30]: pd.to_datetime(data, utc=True)\nOut[30]: DatetimeIndex(['2019-12-31 18:00:00+00:00', '2019-12-31 23:00:00+00:00'], dtype='datetime64[ns, UTC]', freq=None) \n```", "```py\nIn [31]: import datetime as dt\n\nIn [32]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [33]: pd.Series(data).apply(lambda x: dt.datetime.strptime(x, '%Y-%m-%d %H:%M:%S%z'))\nOut[33]: \n0    2020-01-01 00:00:00+06:00\n1    2020-01-01 00:00:00+01:00\ndtype: object \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [1]: ser = pd.Series([1, 2, 3])\n\nIn [2]: ser\nOut[2]:\n0    1\n1    2\n2    3\ndtype: int64\n\nIn [3]: ser[0] = 'not an int64'\nFutureWarning:\n Setting an item of incompatible dtype is deprecated and will raise an error in a future version of pandas.\n Value 'not an int64' has dtype incompatible with int64, please explicitly cast to a compatible dtype first.\n\nIn [4]: ser\nOut[4]:\n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [21]: ser = pd.Series([1, 2, 3])\n\nIn [22]: ser = ser.astype('object')\n\nIn [23]: ser[0] = 'not an int64'\n\nIn [24]: ser\nOut[24]: \n0    not an int64\n1               2\n2               3\ndtype: object \n```", "```py\nIn [25]: ser = pd.Series([1, 2, 3])\n\nIn [26]: ser = ser.astype('float64')\n\nIn [27]: ser[0] = 1.1\n\nIn [28]: ser\nOut[28]: \n0    1.1\n1    2.0\n2    3.0\ndtype: float64 \n```", "```py\nIn [7]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [8]:  pd.to_datetime(data, utc=False)\nOut[8]:\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [9]: pd.to_datetime(data, utc=False)\nFutureWarning:\n In a future version of pandas, parsing datetimes with mixed time zones will raise\n a warning unless `utc=True`. Please specify `utc=True` to opt in to the new behaviour\n and silence this warning. To create a `Series` with mixed offsets and `object` dtype,\n please use `apply` and `datetime.datetime.strptime`.\nIndex([2020-01-01 00:00:00+06:00, 2020-01-01 00:00:00+01:00], dtype='object') \n```", "```py\nIn [29]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [30]: pd.to_datetime(data, utc=True)\nOut[30]: DatetimeIndex(['2019-12-31 18:00:00+00:00', '2019-12-31 23:00:00+00:00'], dtype='datetime64[ns, UTC]', freq=None) \n```", "```py\nIn [31]: import datetime as dt\n\nIn [32]: data = [\"2020-01-01 00:00:00+06:00\", \"2020-01-01 00:00:00+01:00\"]\n\nIn [33]: pd.Series(data).apply(lambda x: dt.datetime.strptime(x, '%Y-%m-%d %H:%M:%S%z'))\nOut[33]: \n0    2020-01-01 00:00:00+06:00\n1    2020-01-01 00:00:00+01:00\ndtype: object \n```"]