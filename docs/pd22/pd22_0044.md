# 时间增量

> 原文：[`pandas.pydata.org/docs/user_guide/timedeltas.html`](https://pandas.pydata.org/docs/user_guide/timedeltas.html)

时间增量是时间之间的差异，以不同的单位表示，例如天、小时、分钟、秒。它们可以是正数也可以是负数。

`Timedelta`是`datetime.timedelta`的子类，并且行为类似，但也允许与`np.timedelta64`类型兼容，以及一系列自定义表示、解析和属性。

## 解析

您可以通过各种参数构造一个`Timedelta`标量，包括[ISO 8601 Duration](https://en.wikipedia.org/wiki/ISO_8601#Durations)字符串。

```py
In [1]: import datetime

# strings
In [2]: pd.Timedelta("1 days")
Out[2]: Timedelta('1 days 00:00:00')

In [3]: pd.Timedelta("1 days 00:00:00")
Out[3]: Timedelta('1 days 00:00:00')

In [4]: pd.Timedelta("1 days 2 hours")
Out[4]: Timedelta('1 days 02:00:00')

In [5]: pd.Timedelta("-1 days 2 min 3us")
Out[5]: Timedelta('-2 days +23:57:59.999997')

# like datetime.timedelta
# note: these MUST be specified as keyword arguments
In [6]: pd.Timedelta(days=1, seconds=1)
Out[6]: Timedelta('1 days 00:00:01')

# integers with a unit
In [7]: pd.Timedelta(1, unit="d")
Out[7]: Timedelta('1 days 00:00:00')

# from a datetime.timedelta/np.timedelta64
In [8]: pd.Timedelta(datetime.timedelta(days=1, seconds=1))
Out[8]: Timedelta('1 days 00:00:01')

In [9]: pd.Timedelta(np.timedelta64(1, "ms"))
Out[9]: Timedelta('0 days 00:00:00.001000')

# negative Timedeltas have this string repr
# to be more consistent with datetime.timedelta conventions
In [10]: pd.Timedelta("-1us")
Out[10]: Timedelta('-1 days +23:59:59.999999')

# a NaT
In [11]: pd.Timedelta("nan")
Out[11]: NaT

In [12]: pd.Timedelta("nat")
Out[12]: NaT

# ISO 8601 Duration strings
In [13]: pd.Timedelta("P0DT0H1M0S")
Out[13]: Timedelta('0 days 00:01:00')

In [14]: pd.Timedelta("P0DT0H0M0.000000123S")
Out[14]: Timedelta('0 days 00:00:00.000000123') 
```

日期偏移（`Day, Hour, Minute, Second, Milli, Micro, Nano`）也可以用于构建。

```py
In [15]: pd.Timedelta(pd.offsets.Second(2))
Out[15]: Timedelta('0 days 00:00:02') 
```

此外，标量与标量之间的操作将产生另一个标量`Timedelta`。

```py
In [16]: pd.Timedelta(pd.offsets.Day(2)) + pd.Timedelta(pd.offsets.Second(2)) + pd.Timedelta(
 ....:    "00:00:00.000123"
 ....: )
 ....: 
Out[16]: Timedelta('2 days 00:00:02.000123') 
```

### to_timedelta

使用顶级的 `pd.to_timedelta`，您可以将识别的时间增量格式/值的标量、数组、列表或序列转换为 `Timedelta` 类型。如果输入是序列，则将构造序列，如果输入类似于标量，则将输出标量，否则将输出 `TimedeltaIndex`。

您可以将单个字符串解析为一个时间增量：

```py
In [17]: pd.to_timedelta("1 days 06:05:01.00003")
Out[17]: Timedelta('1 days 06:05:01.000030')

In [18]: pd.to_timedelta("15.5us")
Out[18]: Timedelta('0 days 00:00:00.000015500') 
```

或者一个字符串的列表/数组：

```py
In [19]: pd.to_timedelta(["1 days 06:05:01.00003", "15.5us", "nan"])
Out[19]: TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015500', NaT], dtype='timedelta64[ns]', freq=None) 
```

`unit` 关键字参数指定了 Timedelta 的单位，如果输入是数字的话：

```py
In [20]: pd.to_timedelta(np.arange(5), unit="s")
Out[20]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 00:00:01', '0 days 00:00:02',
 '0 days 00:00:03', '0 days 00:00:04'],
 dtype='timedelta64[ns]', freq=None)

In [21]: pd.to_timedelta(np.arange(5), unit="d")
Out[21]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None) 
```

警告

如果将字符串或字符串数组作为输入传递，则将忽略`unit`关键字参数。如果传递没有单位的字符串，则假定默认单位为纳秒。

### 时间增量的限制

pandas 使用 64 位整数以纳秒分辨率表示`Timedeltas`。因此，64 位整数限制确定了`Timedelta`的限制。

```py
In [22]: pd.Timedelta.min
Out[22]: Timedelta('-106752 days +00:12:43.145224193')

In [23]: pd.Timedelta.max
Out[23]: Timedelta('106751 days 23:47:16.854775807') 
```  ## 操作

您可以对序列/数据框进行操作，并通过在`datetime64[ns]`序列或`Timestamps`上执行减法操作来构建`timedelta64[ns]`序列。

```py
In [24]: s = pd.Series(pd.date_range("2012-1-1", periods=3, freq="D"))

In [25]: td = pd.Series([pd.Timedelta(days=i) for i in range(3)])

In [26]: df = pd.DataFrame({"A": s, "B": td})

In [27]: df
Out[27]: 
 A      B
0 2012-01-01 0 days
1 2012-01-02 1 days
2 2012-01-03 2 days

In [28]: df["C"] = df["A"] + df["B"]

In [29]: df
Out[29]: 
 A      B          C
0 2012-01-01 0 days 2012-01-01
1 2012-01-02 1 days 2012-01-03
2 2012-01-03 2 days 2012-01-05

In [30]: df.dtypes
Out[30]: 
A     datetime64[ns]
B    timedelta64[ns]
C     datetime64[ns]
dtype: object

In [31]: s - s.max()
Out[31]: 
0   -2 days
1   -1 days
2    0 days
dtype: timedelta64[ns]

In [32]: s - datetime.datetime(2011, 1, 1, 3, 5)
Out[32]: 
0   364 days 20:55:00
1   365 days 20:55:00
2   366 days 20:55:00
dtype: timedelta64[ns]

In [33]: s + datetime.timedelta(minutes=5)
Out[33]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]

In [34]: s + pd.offsets.Minute(5)
Out[34]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]

In [35]: s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
Out[35]: 
0   2012-01-01 00:05:00.005
1   2012-01-02 00:05:00.005
2   2012-01-03 00:05:00.005
dtype: datetime64[ns] 
```

使用`timedelta64[ns]`序列的标量进行操作：

```py
In [36]: y = s - s[0]

In [37]: y
Out[37]: 
0   0 days
1   1 days
2   2 days
dtype: timedelta64[ns] 
```

支持带有`NaT`值的时间增量序列：

```py
In [38]: y = s - s.shift()

In [39]: y
Out[39]: 
0      NaT
1   1 days
2   1 days
dtype: timedelta64[ns] 
```

可以使用`np.nan`将元素设置为`NaT`，类似于日期时间：

```py
In [40]: y[1] = np.nan

In [41]: y
Out[41]: 
0      NaT
1      NaT
2   1 days
dtype: timedelta64[ns] 
```

操作数也可以以相反的顺序出现（一个对象与一个序列进行操作）：

```py
In [42]: s.max() - s
Out[42]: 
0   2 days
1   1 days
2   0 days
dtype: timedelta64[ns]

In [43]: datetime.datetime(2011, 1, 1, 3, 5) - s
Out[43]: 
0   -365 days +03:05:00
1   -366 days +03:05:00
2   -367 days +03:05:00
dtype: timedelta64[ns]

In [44]: datetime.timedelta(minutes=5) + s
Out[44]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns] 
```

`min, max` 和相应的 `idxmin, idxmax` 操作也适用于框架：

```py
In [45]: A = s - pd.Timestamp("20120101") - pd.Timedelta("00:05:05")

In [46]: B = s - pd.Series(pd.date_range("2012-1-2", periods=3, freq="D"))

In [47]: df = pd.DataFrame({"A": A, "B": B})

In [48]: df
Out[48]: 
 A       B
0 -1 days +23:54:55 -1 days
1   0 days 23:54:55 -1 days
2   1 days 23:54:55 -1 days

In [49]: df.min()
Out[49]: 
A   -1 days +23:54:55
B   -1 days +00:00:00
dtype: timedelta64[ns]

In [50]: df.min(axis=1)
Out[50]: 
0   -1 days
1   -1 days
2   -1 days
dtype: timedelta64[ns]

In [51]: df.idxmin()
Out[51]: 
A    0
B    0
dtype: int64

In [52]: df.idxmax()
Out[52]: 
A    2
B    0
dtype: int64 
```

`min, max, idxmin, idxmax` 操作也适用于序列。标量结果将是一个`Timedelta`。

```py
In [53]: df.min().max()
Out[53]: Timedelta('-1 days +23:54:55')

In [54]: df.min(axis=1).min()
Out[54]: Timedelta('-1 days +00:00:00')

In [55]: df.min().idxmax()
Out[55]: 'A'

In [56]: df.min(axis=1).idxmin()
Out[56]: 0 
```

您可以对时间增量进行填充，传递一个时间增量以获得特定值。

```py
In [57]: y.fillna(pd.Timedelta(0))
Out[57]: 
0   0 days
1   0 days
2   1 days
dtype: timedelta64[ns]

In [58]: y.fillna(pd.Timedelta(10, unit="s"))
Out[58]: 
0   0 days 00:00:10
1   0 days 00:00:10
2   1 days 00:00:00
dtype: timedelta64[ns]

In [59]: y.fillna(pd.Timedelta("-1 days, 00:00:05"))
Out[59]: 
0   -1 days +00:00:05
1   -1 days +00:00:05
2     1 days 00:00:00
dtype: timedelta64[ns] 
```

您还可以对`Timedeltas`进行取反、乘法和使用`abs`：

```py
In [60]: td1 = pd.Timedelta("-1 days 2 hours 3 seconds")

In [61]: td1
Out[61]: Timedelta('-2 days +21:59:57')

In [62]: -1 * td1
Out[62]: Timedelta('1 days 02:00:03')

In [63]: -td1
Out[63]: Timedelta('1 days 02:00:03')

In [64]: abs(td1)
Out[64]: Timedelta('1 days 02:00:03') 
```  ## 缩减

`timedelta64[ns]`的数值缩减操作将返回`Timedelta`对象。通常在评估过程中会跳过`NaT`。

```py
In [65]: y2 = pd.Series(
 ....:    pd.to_timedelta(["-1 days +00:00:05", "nat", "-1 days +00:00:05", "1 days"])
 ....: )
 ....: 

In [66]: y2
Out[66]: 
0   -1 days +00:00:05
1                 NaT
2   -1 days +00:00:05
3     1 days 00:00:00
dtype: timedelta64[ns]

In [67]: y2.mean()
Out[67]: Timedelta('-1 days +16:00:03.333333334')

In [68]: y2.median()
Out[68]: Timedelta('-1 days +00:00:05')

In [69]: y2.quantile(0.1)
Out[69]: Timedelta('-1 days +00:00:05')

In [70]: y2.sum()
Out[70]: Timedelta('-1 days +00:00:10') 
```  ## 频率转换

时间增量序列和 `TimedeltaIndex`，以及 `Timedelta` 可以通过转换为特定的时间增量数据类型来转换为其他频率。

```py
In [71]: december = pd.Series(pd.date_range("20121201", periods=4))

In [72]: january = pd.Series(pd.date_range("20130101", periods=4))

In [73]: td = january - december

In [74]: td[2] += datetime.timedelta(minutes=5, seconds=3)

In [75]: td[3] = np.nan

In [76]: td
Out[76]: 
0   31 days 00:00:00
1   31 days 00:00:00
2   31 days 00:05:03
3                NaT
dtype: timedelta64[ns]

# to seconds
In [77]: td.astype("timedelta64[s]")
Out[77]: 
0   31 days 00:00:00
1   31 days 00:00:00
2   31 days 00:05:03
3                NaT
dtype: timedelta64[s] 
```

对于除了支持的“s”、“ms”、“us”、“ns”之外的 timedelta64 分辨率，另一种方法是除以另一个 timedelta 对象。请注意，通过 NumPy 标量进行的除法是真除法，而 astyping 等同于 floor division。

```py
# to days
In [78]: td / np.timedelta64(1, "D")
Out[78]: 
0    31.000000
1    31.000000
2    31.003507
3          NaN
dtype: float64 
```

将`timedelta64[ns]` Series 除以整数或整数系列，或者乘以整数，会得到另一个`timedelta64[ns]` dtypes Series。

```py
In [79]: td * -1
Out[79]: 
0   -31 days +00:00:00
1   -31 days +00:00:00
2   -32 days +23:54:57
3                  NaT
dtype: timedelta64[ns]

In [80]: td * pd.Series([1, 2, 3, 4])
Out[80]: 
0   31 days 00:00:00
1   62 days 00:00:00
2   93 days 00:15:09
3                NaT
dtype: timedelta64[ns] 
```

对`timedelta64[ns]` Series 进行四舍五入除法（floor-division）得到一个整数系列。

```py
In [81]: td // pd.Timedelta(days=3, hours=4)
Out[81]: 
0    9.0
1    9.0
2    9.0
3    NaN
dtype: float64

In [82]: pd.Timedelta(days=3, hours=4) // td
Out[82]: 
0    0.0
1    0.0
2    0.0
3    NaN
dtype: float64 
```

当与另一个类似`timedelta`或数值参数操作时，`Timedelta`定义了 mod（%）和 divmod 操作。

```py
In [83]: pd.Timedelta(hours=37) % datetime.timedelta(hours=2)
Out[83]: Timedelta('0 days 01:00:00')

# divmod against a timedelta-like returns a pair (int, Timedelta)
In [84]: divmod(datetime.timedelta(hours=2), pd.Timedelta(minutes=11))
Out[84]: (10, Timedelta('0 days 00:10:00'))

# divmod against a numeric returns a pair (Timedelta, Timedelta)
In [85]: divmod(pd.Timedelta(hours=25), 86400000000000)
Out[85]: (Timedelta('0 days 00:00:00.000000001'), Timedelta('0 days 01:00:00')) 
```

## 属性

你可以直接使用`days,seconds,microseconds,nanoseconds`属性访问`Timedelta`或`TimedeltaIndex`的各个组件。这些与`datetime.timedelta`返回的值相同，例如，`.seconds`属性表示大于等于 0 且小于 1 天的秒数。这些值根据`Timedelta`是否有符号而有所不同。

这些操作也可以通过`Series`的`.dt`属性直接访问。

注意

注意，属性不是`Timedelta`的显示值。使用`.components`来检索显示值。

对于`Series`：

```py
In [86]: td.dt.days
Out[86]: 
0    31.0
1    31.0
2    31.0
3     NaN
dtype: float64

In [87]: td.dt.seconds
Out[87]: 
0      0.0
1      0.0
2    303.0
3      NaN
dtype: float64 
```

你可以直接访问标量`Timedelta`的字段值。

```py
In [88]: tds = pd.Timedelta("31 days 5 min 3 sec")

In [89]: tds.days
Out[89]: 31

In [90]: tds.seconds
Out[90]: 303

In [91]: (-tds).seconds
Out[91]: 86097 
```

你可以使用`.components`属性访问时间间隔的简化形式。这将返回一个类似于`Series`的索引的`DataFrame`。这些是`Timedelta`的*显示*值。

```py
In [92]: td.dt.components
Out[92]: 
 days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds
0  31.0    0.0      0.0      0.0           0.0           0.0          0.0
1  31.0    0.0      0.0      0.0           0.0           0.0          0.0
2  31.0    0.0      5.0      3.0           0.0           0.0          0.0
3   NaN    NaN      NaN      NaN           NaN           NaN          NaN

In [93]: td.dt.components.seconds
Out[93]: 
0    0.0
1    0.0
2    3.0
3    NaN
Name: seconds, dtype: float64 
```

你可以使用`.isoformat`方法将`Timedelta`转换为[ISO 8601 Duration](https://en.wikipedia.org/wiki/ISO_8601#Durations)字符串。

```py
In [94]: pd.Timedelta(
 ....:    days=6, minutes=50, seconds=3, milliseconds=10, microseconds=10, nanoseconds=12
 ....: ).isoformat()
 ....: 
Out[94]: 'P6DT0H50M3.010010012S' 
```

## TimedeltaIndex

要生成带有时间间隔的索引，可以使用`TimedeltaIndex`或`timedelta_range()`构造函数。

使用`TimedeltaIndex`可以传递类似字符串、`Timedelta`、`timedelta`或`np.timedelta64`的对象。传递`np.nan/pd.NaT/nat`将表示缺失值。

```py
In [95]: pd.TimedeltaIndex(
 ....:    [
 ....:        "1 days",
 ....:        "1 days, 00:00:05",
 ....:        np.timedelta64(2, "D"),
 ....:        datetime.timedelta(days=2, seconds=2),
 ....:    ]
 ....: )
 ....: 
Out[95]: 
TimedeltaIndex(['1 days 00:00:00', '1 days 00:00:05', '2 days 00:00:00',
 '2 days 00:00:02'],
 dtype='timedelta64[ns]', freq=None) 
```

字符串‘infer’可以传递以将索引的频率设置为创建时推断的频率：

```py
In [96]: pd.TimedeltaIndex(["0 days", "10 days", "20 days"], freq="infer")
Out[96]: TimedeltaIndex(['0 days', '10 days', '20 days'], dtype='timedelta64[ns]', freq='10D') 
```

### 生成时间间隔范围

类似于`date_range()`，你可以使用`timedelta_range()`构造`TimedeltaIndex`的常规范围。`timedelta_range`的默认频率是日历日：

```py
In [97]: pd.timedelta_range(start="1 days", periods=5)
Out[97]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D') 
```

可以使用`timedelta_range`与`start`、`end`和`periods`的各种组合：

```py
In [98]: pd.timedelta_range(start="1 days", end="5 days")
Out[98]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')

In [99]: pd.timedelta_range(end="10 days", periods=4)
Out[99]: TimedeltaIndex(['7 days', '8 days', '9 days', '10 days'], dtype='timedelta64[ns]', freq='D') 
```

`freq`参数可以传递各种 frequency aliases：

```py
In [100]: pd.timedelta_range(start="1 days", end="2 days", freq="30min")
Out[100]: 
TimedeltaIndex(['1 days 00:00:00', '1 days 00:30:00', '1 days 01:00:00',
 '1 days 01:30:00', '1 days 02:00:00', '1 days 02:30:00',
 '1 days 03:00:00', '1 days 03:30:00', '1 days 04:00:00',
 '1 days 04:30:00', '1 days 05:00:00', '1 days 05:30:00',
 '1 days 06:00:00', '1 days 06:30:00', '1 days 07:00:00',
 '1 days 07:30:00', '1 days 08:00:00', '1 days 08:30:00',
 '1 days 09:00:00', '1 days 09:30:00', '1 days 10:00:00',
 '1 days 10:30:00', '1 days 11:00:00', '1 days 11:30:00',
 '1 days 12:00:00', '1 days 12:30:00', '1 days 13:00:00',
 '1 days 13:30:00', '1 days 14:00:00', '1 days 14:30:00',
 '1 days 15:00:00', '1 days 15:30:00', '1 days 16:00:00',
 '1 days 16:30:00', '1 days 17:00:00', '1 days 17:30:00',
 '1 days 18:00:00', '1 days 18:30:00', '1 days 19:00:00',
 '1 days 19:30:00', '1 days 20:00:00', '1 days 20:30:00',
 '1 days 21:00:00', '1 days 21:30:00', '1 days 22:00:00',
 '1 days 22:30:00', '1 days 23:00:00', '1 days 23:30:00',
 '2 days 00:00:00'],
 dtype='timedelta64[ns]', freq='30min')

In [101]: pd.timedelta_range(start="1 days", periods=5, freq="2D5h")
Out[101]: 
TimedeltaIndex(['1 days 00:00:00', '3 days 05:00:00', '5 days 10:00:00',
 '7 days 15:00:00', '9 days 20:00:00'],
 dtype='timedelta64[ns]', freq='53h') 
```

指定 `start`、`end` 和 `periods` 将生成一系列从 `start` 到 `end` 的等间隔 timedeltas，其中结果 `TimedeltaIndex` 中的元素数为 `periods`：

```py
In [102]: pd.timedelta_range("0 days", "4 days", periods=5)
Out[102]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None)

In [103]: pd.timedelta_range("0 days", "4 days", periods=10)
Out[103]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 10:40:00', '0 days 21:20:00',
 '1 days 08:00:00', '1 days 18:40:00', '2 days 05:20:00',
 '2 days 16:00:00', '3 days 02:40:00', '3 days 13:20:00',
 '4 days 00:00:00'],
 dtype='timedelta64[ns]', freq=None) 
```

### 使用 TimedeltaIndex

类似于其他日期时间索引，`DatetimeIndex` 和 `PeriodIndex`，你可以将 `TimedeltaIndex` 用作 pandas 对象的索引。

```py
In [104]: s = pd.Series(
 .....:    np.arange(100),
 .....:    index=pd.timedelta_range("1 days", periods=100, freq="h"),
 .....: )
 .....: 

In [105]: s
Out[105]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
4 days 23:00:00    95
5 days 00:00:00    96
5 days 01:00:00    97
5 days 02:00:00    98
5 days 03:00:00    99
Freq: h, Length: 100, dtype: int64 
```

选择方式类似，对于字符串样式和切片都会进行强制转换：

```py
In [106]: s["1 day":"2 day"]
Out[106]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
2 days 19:00:00    43
2 days 20:00:00    44
2 days 21:00:00    45
2 days 22:00:00    46
2 days 23:00:00    47
Freq: h, Length: 48, dtype: int64

In [107]: s["1 day 01:00:00"]
Out[107]: 1

In [108]: s[pd.Timedelta("1 day 1h")]
Out[108]: 1 
```

此外，你可以使用部分字符串选择，范围将被推断：

```py
In [109]: s["1 day":"1 day 5 hours"]
Out[109]: 
1 days 00:00:00    0
1 days 01:00:00    1
1 days 02:00:00    2
1 days 03:00:00    3
1 days 04:00:00    4
1 days 05:00:00    5
Freq: h, dtype: int64 
```

### 操作

最后，`TimedeltaIndex` 与 `DatetimeIndex` 的组合允许保留某些组合操作的 NaT：

```py
In [110]: tdi = pd.TimedeltaIndex(["1 days", pd.NaT, "2 days"])

In [111]: tdi.to_list()
Out[111]: [Timedelta('1 days 00:00:00'), NaT, Timedelta('2 days 00:00:00')]

In [112]: dti = pd.date_range("20130101", periods=3)

In [113]: dti.to_list()
Out[113]: 
[Timestamp('2013-01-01 00:00:00'),
 Timestamp('2013-01-02 00:00:00'),
 Timestamp('2013-01-03 00:00:00')]

In [114]: (dti + tdi).to_list()
Out[114]: [Timestamp('2013-01-02 00:00:00'), NaT, Timestamp('2013-01-05 00:00:00')]

In [115]: (dti - tdi).to_list()
Out[115]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2013-01-01 00:00:00')] 
```

### 转换

类似于上面对`Series`进行的频率转换，你可以将这些索引转换为另一个索引。

```py
In [116]: tdi / np.timedelta64(1, "s")
Out[116]: Index([86400.0, nan, 172800.0], dtype='float64')

In [117]: tdi.astype("timedelta64[s]")
Out[117]: TimedeltaIndex(['1 days', NaT, '2 days'], dtype='timedelta64[s]', freq=None) 
```

标量类型操作也有效。这些可能返回一个*不同*类型的索引。

```py
# adding or timedelta and date -> datelike
In [118]: tdi + pd.Timestamp("20130101")
Out[118]: DatetimeIndex(['2013-01-02', 'NaT', '2013-01-03'], dtype='datetime64[ns]', freq=None)

# subtraction of a date and a timedelta -> datelike
# note that trying to subtract a date from a Timedelta will raise an exception
In [119]: (pd.Timestamp("20130101") - tdi).to_list()
Out[119]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2012-12-30 00:00:00')]

# timedelta + timedelta -> timedelta
In [120]: tdi + pd.Timedelta("10 days")
Out[120]: TimedeltaIndex(['11 days', NaT, '12 days'], dtype='timedelta64[ns]', freq=None)

# division can result in a Timedelta if the divisor is an integer
In [121]: tdi / 2
Out[121]: TimedeltaIndex(['0 days 12:00:00', NaT, '1 days 00:00:00'], dtype='timedelta64[ns]', freq=None)

# or a float64 Index if the divisor is a Timedelta
In [122]: tdi / tdi[0]
Out[122]: Index([1.0, nan, 2.0], dtype='float64') 
```  ## 重新采样

类似于时间序列重采样，我们可以使用 `TimedeltaIndex` 进行重新采样。

```py
In [123]: s.resample("D").mean()
Out[123]: 
1 days    11.5
2 days    35.5
3 days    59.5
4 days    83.5
5 days    97.5
Freq: D, dtype: float64 
```

## 解析

你可以通过各种参数构造一个 `Timedelta` 标量，包括[ISO 8601 Duration](https://en.wikipedia.org/wiki/ISO_8601#Durations)字符串。

```py
In [1]: import datetime

# strings
In [2]: pd.Timedelta("1 days")
Out[2]: Timedelta('1 days 00:00:00')

In [3]: pd.Timedelta("1 days 00:00:00")
Out[3]: Timedelta('1 days 00:00:00')

In [4]: pd.Timedelta("1 days 2 hours")
Out[4]: Timedelta('1 days 02:00:00')

In [5]: pd.Timedelta("-1 days 2 min 3us")
Out[5]: Timedelta('-2 days +23:57:59.999997')

# like datetime.timedelta
# note: these MUST be specified as keyword arguments
In [6]: pd.Timedelta(days=1, seconds=1)
Out[6]: Timedelta('1 days 00:00:01')

# integers with a unit
In [7]: pd.Timedelta(1, unit="d")
Out[7]: Timedelta('1 days 00:00:00')

# from a datetime.timedelta/np.timedelta64
In [8]: pd.Timedelta(datetime.timedelta(days=1, seconds=1))
Out[8]: Timedelta('1 days 00:00:01')

In [9]: pd.Timedelta(np.timedelta64(1, "ms"))
Out[9]: Timedelta('0 days 00:00:00.001000')

# negative Timedeltas have this string repr
# to be more consistent with datetime.timedelta conventions
In [10]: pd.Timedelta("-1us")
Out[10]: Timedelta('-1 days +23:59:59.999999')

# a NaT
In [11]: pd.Timedelta("nan")
Out[11]: NaT

In [12]: pd.Timedelta("nat")
Out[12]: NaT

# ISO 8601 Duration strings
In [13]: pd.Timedelta("P0DT0H1M0S")
Out[13]: Timedelta('0 days 00:01:00')

In [14]: pd.Timedelta("P0DT0H0M0.000000123S")
Out[14]: Timedelta('0 days 00:00:00.000000123') 
```

DateOffsets（`Day, Hour, Minute, Second, Milli, Micro, Nano`）也可以在构造中使用。

```py
In [15]: pd.Timedelta(pd.offsets.Second(2))
Out[15]: Timedelta('0 days 00:00:02') 
```

此外，标量之间的操作会产生另一个标量 `Timedelta`。

```py
In [16]: pd.Timedelta(pd.offsets.Day(2)) + pd.Timedelta(pd.offsets.Second(2)) + pd.Timedelta(
 ....:    "00:00:00.000123"
 ....: )
 ....: 
Out[16]: Timedelta('2 days 00:00:02.000123') 
```

### to_timedelta

使用顶层的 `pd.to_timedelta`，你可以将一个被识别的时间差格式/值的标量、数组、列表或 Series 转换为 `Timedelta` 类型。如果输入是 Series，则会构造 Series；如果输入类似于标量，则会构造标量，否则将输出一个 `TimedeltaIndex`。

你可以将单个字符串解析为 Timedelta：

```py
In [17]: pd.to_timedelta("1 days 06:05:01.00003")
Out[17]: Timedelta('1 days 06:05:01.000030')

In [18]: pd.to_timedelta("15.5us")
Out[18]: Timedelta('0 days 00:00:00.000015500') 
```

或者一个字符串列表/数组：

```py
In [19]: pd.to_timedelta(["1 days 06:05:01.00003", "15.5us", "nan"])
Out[19]: TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015500', NaT], dtype='timedelta64[ns]', freq=None) 
```

如果输入是数字，则`unit`关键字参数指定 Timedelta 的单位：

```py
In [20]: pd.to_timedelta(np.arange(5), unit="s")
Out[20]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 00:00:01', '0 days 00:00:02',
 '0 days 00:00:03', '0 days 00:00:04'],
 dtype='timedelta64[ns]', freq=None)

In [21]: pd.to_timedelta(np.arange(5), unit="d")
Out[21]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None) 
```

警告

如果作为输入传递了字符串或字符串数组，则`unit`关键字参数将被忽略。如果传递的是没有单位的字符串，则假定为默认单位为纳秒。

### Timedelta 的限制

pandas 使用 64 位整数以纳秒分辨率表示 `Timedeltas`。因此，64 位整数的限制确定了 `Timedelta` 的限制。

```py
In [22]: pd.Timedelta.min
Out[22]: Timedelta('-106752 days +00:12:43.145224193')

In [23]: pd.Timedelta.max
Out[23]: Timedelta('106751 days 23:47:16.854775807') 
```

### to_timedelta

使用顶层的 `pd.to_timedelta`，你可以将一个被识别的时间差格式/值的标量、数组、列表或 Series 转换为 `Timedelta` 类型。如果输入是 Series，则会构造 Series；如果输入类似于标量，则会构造标量，否则将输出一个 `TimedeltaIndex`。

你可以将单个字符串解析为 Timedelta：

```py
In [17]: pd.to_timedelta("1 days 06:05:01.00003")
Out[17]: Timedelta('1 days 06:05:01.000030')

In [18]: pd.to_timedelta("15.5us")
Out[18]: Timedelta('0 days 00:00:00.000015500') 
```

或者一个字符串列表/数组：

```py
In [19]: pd.to_timedelta(["1 days 06:05:01.00003", "15.5us", "nan"])
Out[19]: TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015500', NaT], dtype='timedelta64[ns]', freq=None) 
```

如果输入是数字，则`unit`关键字参数指定 Timedelta 的单位：

```py
In [20]: pd.to_timedelta(np.arange(5), unit="s")
Out[20]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 00:00:01', '0 days 00:00:02',
 '0 days 00:00:03', '0 days 00:00:04'],
 dtype='timedelta64[ns]', freq=None)

In [21]: pd.to_timedelta(np.arange(5), unit="d")
Out[21]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None) 
```

警告

如果作为输入传递了字符串或字符串数组，则`unit`关键字参数将被忽略。如果传递的是没有单位的字符串，则假定为默认单位为纳秒。

### Timedelta 的限制

pandas 使用 64 位整数以纳秒分辨率表示 `Timedeltas`。因此，64 位整数限制确定了 `Timedelta` 的限制。

```py
In [22]: pd.Timedelta.min
Out[22]: Timedelta('-106752 days +00:12:43.145224193')

In [23]: pd.Timedelta.max
Out[23]: Timedelta('106751 days 23:47:16.854775807') 
```

## 操作

您可以对 Series/DataFrames 进行操作，并通过减法操作在 `datetime64[ns]` Series 或 `Timestamps` 上构建 `timedelta64[ns]` Series。

```py
In [24]: s = pd.Series(pd.date_range("2012-1-1", periods=3, freq="D"))

In [25]: td = pd.Series([pd.Timedelta(days=i) for i in range(3)])

In [26]: df = pd.DataFrame({"A": s, "B": td})

In [27]: df
Out[27]: 
 A      B
0 2012-01-01 0 days
1 2012-01-02 1 days
2 2012-01-03 2 days

In [28]: df["C"] = df["A"] + df["B"]

In [29]: df
Out[29]: 
 A      B          C
0 2012-01-01 0 days 2012-01-01
1 2012-01-02 1 days 2012-01-03
2 2012-01-03 2 days 2012-01-05

In [30]: df.dtypes
Out[30]: 
A     datetime64[ns]
B    timedelta64[ns]
C     datetime64[ns]
dtype: object

In [31]: s - s.max()
Out[31]: 
0   -2 days
1   -1 days
2    0 days
dtype: timedelta64[ns]

In [32]: s - datetime.datetime(2011, 1, 1, 3, 5)
Out[32]: 
0   364 days 20:55:00
1   365 days 20:55:00
2   366 days 20:55:00
dtype: timedelta64[ns]

In [33]: s + datetime.timedelta(minutes=5)
Out[33]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]

In [34]: s + pd.offsets.Minute(5)
Out[34]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]

In [35]: s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
Out[35]: 
0   2012-01-01 00:05:00.005
1   2012-01-02 00:05:00.005
2   2012-01-03 00:05:00.005
dtype: datetime64[ns] 
```

从 `timedelta64[ns]` Series 中的标量进行操作：

```py
In [36]: y = s - s[0]

In [37]: y
Out[37]: 
0   0 days
1   1 days
2   2 days
dtype: timedelta64[ns] 
```

支持具有 `NaT` 值的时间增量 Series：

```py
In [38]: y = s - s.shift()

In [39]: y
Out[39]: 
0      NaT
1   1 days
2   1 days
dtype: timedelta64[ns] 
```

使用 `np.nan` 类似于日期时间可以将元素设置为 `NaT`：

```py
In [40]: y[1] = np.nan

In [41]: y
Out[41]: 
0      NaT
1      NaT
2   1 days
dtype: timedelta64[ns] 
```

操作数也可以以相反的顺序出现（一个对象与 Series 进行操作）：

```py
In [42]: s.max() - s
Out[42]: 
0   2 days
1   1 days
2   0 days
dtype: timedelta64[ns]

In [43]: datetime.datetime(2011, 1, 1, 3, 5) - s
Out[43]: 
0   -365 days +03:05:00
1   -366 days +03:05:00
2   -367 days +03:05:00
dtype: timedelta64[ns]

In [44]: datetime.timedelta(minutes=5) + s
Out[44]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns] 
```

在 frames 上支持 `min, max` 和相应的 `idxmin, idxmax` 操作：

```py
In [45]: A = s - pd.Timestamp("20120101") - pd.Timedelta("00:05:05")

In [46]: B = s - pd.Series(pd.date_range("2012-1-2", periods=3, freq="D"))

In [47]: df = pd.DataFrame({"A": A, "B": B})

In [48]: df
Out[48]: 
 A       B
0 -1 days +23:54:55 -1 days
1   0 days 23:54:55 -1 days
2   1 days 23:54:55 -1 days

In [49]: df.min()
Out[49]: 
A   -1 days +23:54:55
B   -1 days +00:00:00
dtype: timedelta64[ns]

In [50]: df.min(axis=1)
Out[50]: 
0   -1 days
1   -1 days
2   -1 days
dtype: timedelta64[ns]

In [51]: df.idxmin()
Out[51]: 
A    0
B    0
dtype: int64

In [52]: df.idxmax()
Out[52]: 
A    2
B    0
dtype: int64 
```

`min, max, idxmin, idxmax` 操作也支持在 Series 上。标量结果将是一个 `Timedelta`。

```py
In [53]: df.min().max()
Out[53]: Timedelta('-1 days +23:54:55')

In [54]: df.min(axis=1).min()
Out[54]: Timedelta('-1 days +00:00:00')

In [55]: df.min().idxmax()
Out[55]: 'A'

In [56]: df.min(axis=1).idxmin()
Out[56]: 0 
```

您可以在 timedeltas 上使用 fillna，传递一个 timedelta 以获取特定值。

```py
In [57]: y.fillna(pd.Timedelta(0))
Out[57]: 
0   0 days
1   0 days
2   1 days
dtype: timedelta64[ns]

In [58]: y.fillna(pd.Timedelta(10, unit="s"))
Out[58]: 
0   0 days 00:00:10
1   0 days 00:00:10
2   1 days 00:00:00
dtype: timedelta64[ns]

In [59]: y.fillna(pd.Timedelta("-1 days, 00:00:05"))
Out[59]: 
0   -1 days +00:00:05
1   -1 days +00:00:05
2     1 days 00:00:00
dtype: timedelta64[ns] 
```

您还可以对 `Timedeltas` 进行取反、乘法和使用 `abs`：

```py
In [60]: td1 = pd.Timedelta("-1 days 2 hours 3 seconds")

In [61]: td1
Out[61]: Timedelta('-2 days +21:59:57')

In [62]: -1 * td1
Out[62]: Timedelta('1 days 02:00:03')

In [63]: -td1
Out[63]: Timedelta('1 days 02:00:03')

In [64]: abs(td1)
Out[64]: Timedelta('1 days 02:00:03') 
```

## 缩减

对于 `timedelta64[ns]` 的数值缩减操作将返回 `Timedelta` 对象。通常在评估过程中跳过 `NaT`。

```py
In [65]: y2 = pd.Series(
 ....:    pd.to_timedelta(["-1 days +00:00:05", "nat", "-1 days +00:00:05", "1 days"])
 ....: )
 ....: 

In [66]: y2
Out[66]: 
0   -1 days +00:00:05
1                 NaT
2   -1 days +00:00:05
3     1 days 00:00:00
dtype: timedelta64[ns]

In [67]: y2.mean()
Out[67]: Timedelta('-1 days +16:00:03.333333334')

In [68]: y2.median()
Out[68]: Timedelta('-1 days +00:00:05')

In [69]: y2.quantile(0.1)
Out[69]: Timedelta('-1 days +00:00:05')

In [70]: y2.sum()
Out[70]: Timedelta('-1 days +00:00:10') 
```

## 频率转换

Timedelta Series 和 `TimedeltaIndex`，以及 `Timedelta` 可以通过转换为特定的 timedelta dtype 转换为其他频率。

```py
In [71]: december = pd.Series(pd.date_range("20121201", periods=4))

In [72]: january = pd.Series(pd.date_range("20130101", periods=4))

In [73]: td = january - december

In [74]: td[2] += datetime.timedelta(minutes=5, seconds=3)

In [75]: td[3] = np.nan

In [76]: td
Out[76]: 
0   31 days 00:00:00
1   31 days 00:00:00
2   31 days 00:05:03
3                NaT
dtype: timedelta64[ns]

# to seconds
In [77]: td.astype("timedelta64[s]")
Out[77]: 
0   31 days 00:00:00
1   31 days 00:00:00
2   31 days 00:05:03
3                NaT
dtype: timedelta64[s] 
```

对于不支持的“s”、“ms”、“us”、“ns” 的 timedelta64 分辨率，另一种方法是除以另一个 timedelta 对象。请注意，除以 NumPy 标量是真除法，而 astyping 相当于地板除法。

```py
# to days
In [78]: td / np.timedelta64(1, "D")
Out[78]: 
0    31.000000
1    31.000000
2    31.003507
3          NaN
dtype: float64 
```

将 `timedelta64[ns]` Series 除以整数或整数 Series，或乘以整数，将产生另一个 `timedelta64[ns]` dtypes Series。

```py
In [79]: td * -1
Out[79]: 
0   -31 days +00:00:00
1   -31 days +00:00:00
2   -32 days +23:54:57
3                  NaT
dtype: timedelta64[ns]

In [80]: td * pd.Series([1, 2, 3, 4])
Out[80]: 
0   31 days 00:00:00
1   62 days 00:00:00
2   93 days 00:15:09
3                NaT
dtype: timedelta64[ns] 
```

将 `timedelta64[ns]` Series 通过标量 `Timedelta` 进行四舍五入的除法运算将得到一个整数 Series。

```py
In [81]: td // pd.Timedelta(days=3, hours=4)
Out[81]: 
0    9.0
1    9.0
2    9.0
3    NaN
dtype: float64

In [82]: pd.Timedelta(days=3, hours=4) // td
Out[82]: 
0    0.0
1    0.0
2    0.0
3    NaN
dtype: float64 
```

当与另一个类似 timedelta 或数值参数进行操作时，`Timedelta` 定义了 mod (%) 和 divmod 操作。

```py
In [83]: pd.Timedelta(hours=37) % datetime.timedelta(hours=2)
Out[83]: Timedelta('0 days 01:00:00')

# divmod against a timedelta-like returns a pair (int, Timedelta)
In [84]: divmod(datetime.timedelta(hours=2), pd.Timedelta(minutes=11))
Out[84]: (10, Timedelta('0 days 00:10:00'))

# divmod against a numeric returns a pair (Timedelta, Timedelta)
In [85]: divmod(pd.Timedelta(hours=25), 86400000000000)
Out[85]: (Timedelta('0 days 00:00:00.000000001'), Timedelta('0 days 01:00:00')) 
```

## 属性

您可以直接使用属性 `days,seconds,microseconds,nanoseconds` 访问 `Timedelta` 或 `TimedeltaIndex` 的各个组件。这些与 `datetime.timedelta` 返回的值相同，例如，`.seconds` 属性表示大于等于 0 且小于 1 天的秒数。这些根据 `Timedelta` 是否有符号而有符号。

这些操作也可以通过 `Series` 的 `.dt` 属性直接访问。

注意

注意，属性不是 `Timedelta` 的显示值。使用 `.components` 检索显示值。

对于一个 `Series`：

```py
In [86]: td.dt.days
Out[86]: 
0    31.0
1    31.0
2    31.0
3     NaN
dtype: float64

In [87]: td.dt.seconds
Out[87]: 
0      0.0
1      0.0
2    303.0
3      NaN
dtype: float64 
```

您可以直接访问标量 `Timedelta` 的字段值。

```py
In [88]: tds = pd.Timedelta("31 days 5 min 3 sec")

In [89]: tds.days
Out[89]: 31

In [90]: tds.seconds
Out[90]: 303

In [91]: (-tds).seconds
Out[91]: 86097 
```

您可以使用 `.components` 属性访问时间增量的缩减形式。这将返回一个类似于 `Series` 的索引的 `DataFrame`。这些是 `Timedelta` 的*显示*值。

```py
In [92]: td.dt.components
Out[92]: 
 days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds
0  31.0    0.0      0.0      0.0           0.0           0.0          0.0
1  31.0    0.0      0.0      0.0           0.0           0.0          0.0
2  31.0    0.0      5.0      3.0           0.0           0.0          0.0
3   NaN    NaN      NaN      NaN           NaN           NaN          NaN

In [93]: td.dt.components.seconds
Out[93]: 
0    0.0
1    0.0
2    3.0
3    NaN
Name: seconds, dtype: float64 
```

您可以使用 `.isoformat` 方法将 `Timedelta` 转换为 [ISO 8601 Duration](https://en.wikipedia.org/wiki/ISO_8601#Durations) 字符串。

```py
In [94]: pd.Timedelta(
 ....:    days=6, minutes=50, seconds=3, milliseconds=10, microseconds=10, nanoseconds=12
 ....: ).isoformat()
 ....: 
Out[94]: 'P6DT0H50M3.010010012S' 
```

## TimedeltaIndex

要生成具有时间增量的索引，您可以使用`TimedeltaIndex`或`timedelta_range()`构造函数。

使用`TimedeltaIndex`，您可以传递类似字符串的、`Timedelta`、`timedelta`或`np.timedelta64`对象。传递`np.nan/pd.NaT/nat`将表示缺失值。

```py
In [95]: pd.TimedeltaIndex(
 ....:    [
 ....:        "1 days",
 ....:        "1 days, 00:00:05",
 ....:        np.timedelta64(2, "D"),
 ....:        datetime.timedelta(days=2, seconds=2),
 ....:    ]
 ....: )
 ....: 
Out[95]: 
TimedeltaIndex(['1 days 00:00:00', '1 days 00:00:05', '2 days 00:00:00',
 '2 days 00:00:02'],
 dtype='timedelta64[ns]', freq=None) 
```

字符串‘infer’可以传递以设置索引的频率为创建时推断的频率：

```py
In [96]: pd.TimedeltaIndex(["0 days", "10 days", "20 days"], freq="infer")
Out[96]: TimedeltaIndex(['0 days', '10 days', '20 days'], dtype='timedelta64[ns]', freq='10D') 
```

### 生成时间增量范围

类似于`date_range()`，您可以使用`timedelta_range()`构建`TimedeltaIndex`的常规范围。`timedelta_range`的默认频率是日历日：

```py
In [97]: pd.timedelta_range(start="1 days", periods=5)
Out[97]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D') 
```

可以使用`timedelta_range`的各种`start`、`end`和`periods`组合：

```py
In [98]: pd.timedelta_range(start="1 days", end="5 days")
Out[98]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')

In [99]: pd.timedelta_range(end="10 days", periods=4)
Out[99]: TimedeltaIndex(['7 days', '8 days', '9 days', '10 days'], dtype='timedelta64[ns]', freq='D') 
```

`freq`参数可以传递各种频率别名：

```py
In [100]: pd.timedelta_range(start="1 days", end="2 days", freq="30min")
Out[100]: 
TimedeltaIndex(['1 days 00:00:00', '1 days 00:30:00', '1 days 01:00:00',
 '1 days 01:30:00', '1 days 02:00:00', '1 days 02:30:00',
 '1 days 03:00:00', '1 days 03:30:00', '1 days 04:00:00',
 '1 days 04:30:00', '1 days 05:00:00', '1 days 05:30:00',
 '1 days 06:00:00', '1 days 06:30:00', '1 days 07:00:00',
 '1 days 07:30:00', '1 days 08:00:00', '1 days 08:30:00',
 '1 days 09:00:00', '1 days 09:30:00', '1 days 10:00:00',
 '1 days 10:30:00', '1 days 11:00:00', '1 days 11:30:00',
 '1 days 12:00:00', '1 days 12:30:00', '1 days 13:00:00',
 '1 days 13:30:00', '1 days 14:00:00', '1 days 14:30:00',
 '1 days 15:00:00', '1 days 15:30:00', '1 days 16:00:00',
 '1 days 16:30:00', '1 days 17:00:00', '1 days 17:30:00',
 '1 days 18:00:00', '1 days 18:30:00', '1 days 19:00:00',
 '1 days 19:30:00', '1 days 20:00:00', '1 days 20:30:00',
 '1 days 21:00:00', '1 days 21:30:00', '1 days 22:00:00',
 '1 days 22:30:00', '1 days 23:00:00', '1 days 23:30:00',
 '2 days 00:00:00'],
 dtype='timedelta64[ns]', freq='30min')

In [101]: pd.timedelta_range(start="1 days", periods=5, freq="2D5h")
Out[101]: 
TimedeltaIndex(['1 days 00:00:00', '3 days 05:00:00', '5 days 10:00:00',
 '7 days 15:00:00', '9 days 20:00:00'],
 dtype='timedelta64[ns]', freq='53h') 
```

指定`start`、`end`和`periods`将生成从`start`到`end`的一系列均匀间隔的时间增量，包括`start`和`end`，结果为`TimedeltaIndex`中的`periods`个元素：

```py
In [102]: pd.timedelta_range("0 days", "4 days", periods=5)
Out[102]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None)

In [103]: pd.timedelta_range("0 days", "4 days", periods=10)
Out[103]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 10:40:00', '0 days 21:20:00',
 '1 days 08:00:00', '1 days 18:40:00', '2 days 05:20:00',
 '2 days 16:00:00', '3 days 02:40:00', '3 days 13:20:00',
 '4 days 00:00:00'],
 dtype='timedelta64[ns]', freq=None) 
```

### 使用`TimedeltaIndex`

与其他类似日期时间索引，如`DatetimeIndex`和`PeriodIndex`，一样，您可以将`TimedeltaIndex`用作 pandas 对象的索引。

```py
In [104]: s = pd.Series(
 .....:    np.arange(100),
 .....:    index=pd.timedelta_range("1 days", periods=100, freq="h"),
 .....: )
 .....: 

In [105]: s
Out[105]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
4 days 23:00:00    95
5 days 00:00:00    96
5 days 01:00:00    97
5 days 02:00:00    98
5 days 03:00:00    99
Freq: h, Length: 100, dtype: int64 
```

选择工作方式类似，对于类似字符串和切片的强制转换：

```py
In [106]: s["1 day":"2 day"]
Out[106]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
2 days 19:00:00    43
2 days 20:00:00    44
2 days 21:00:00    45
2 days 22:00:00    46
2 days 23:00:00    47
Freq: h, Length: 48, dtype: int64

In [107]: s["1 day 01:00:00"]
Out[107]: 1

In [108]: s[pd.Timedelta("1 day 1h")]
Out[108]: 1 
```

此外，您可以使用部分字符串选择，范围将被推断：

```py
In [109]: s["1 day":"1 day 5 hours"]
Out[109]: 
1 days 00:00:00    0
1 days 01:00:00    1
1 days 02:00:00    2
1 days 03:00:00    3
1 days 04:00:00    4
1 days 05:00:00    5
Freq: h, dtype: int64 
```

### 操作

最后，`TimedeltaIndex`与`DatetimeIndex`的组合允许进行某些保留 NaT 的组合操作：

```py
In [110]: tdi = pd.TimedeltaIndex(["1 days", pd.NaT, "2 days"])

In [111]: tdi.to_list()
Out[111]: [Timedelta('1 days 00:00:00'), NaT, Timedelta('2 days 00:00:00')]

In [112]: dti = pd.date_range("20130101", periods=3)

In [113]: dti.to_list()
Out[113]: 
[Timestamp('2013-01-01 00:00:00'),
 Timestamp('2013-01-02 00:00:00'),
 Timestamp('2013-01-03 00:00:00')]

In [114]: (dti + tdi).to_list()
Out[114]: [Timestamp('2013-01-02 00:00:00'), NaT, Timestamp('2013-01-05 00:00:00')]

In [115]: (dti - tdi).to_list()
Out[115]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2013-01-01 00:00:00')] 
```

### 转换

与上面`Series`上的频率转换类似，您可以将这些索引转换为另一个索引。

```py
In [116]: tdi / np.timedelta64(1, "s")
Out[116]: Index([86400.0, nan, 172800.0], dtype='float64')

In [117]: tdi.astype("timedelta64[s]")
Out[117]: TimedeltaIndex(['1 days', NaT, '2 days'], dtype='timedelta64[s]', freq=None) 
```

标量类型操作也有效。这些可能返回*不同*类型的索引。

```py
# adding or timedelta and date -> datelike
In [118]: tdi + pd.Timestamp("20130101")
Out[118]: DatetimeIndex(['2013-01-02', 'NaT', '2013-01-03'], dtype='datetime64[ns]', freq=None)

# subtraction of a date and a timedelta -> datelike
# note that trying to subtract a date from a Timedelta will raise an exception
In [119]: (pd.Timestamp("20130101") - tdi).to_list()
Out[119]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2012-12-30 00:00:00')]

# timedelta + timedelta -> timedelta
In [120]: tdi + pd.Timedelta("10 days")
Out[120]: TimedeltaIndex(['11 days', NaT, '12 days'], dtype='timedelta64[ns]', freq=None)

# division can result in a Timedelta if the divisor is an integer
In [121]: tdi / 2
Out[121]: TimedeltaIndex(['0 days 12:00:00', NaT, '1 days 00:00:00'], dtype='timedelta64[ns]', freq=None)

# or a float64 Index if the divisor is a Timedelta
In [122]: tdi / tdi[0]
Out[122]: Index([1.0, nan, 2.0], dtype='float64') 
```

### 生成时间增量范围

类似于`date_range()`，您可以使用`timedelta_range()`构建`TimedeltaIndex`的常规范围。`timedelta_range`的默认频率是日历日：

```py
In [97]: pd.timedelta_range(start="1 days", periods=5)
Out[97]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D') 
```

可以使用`timedelta_range`的各种`start`、`end`和`periods`组合：

```py
In [98]: pd.timedelta_range(start="1 days", end="5 days")
Out[98]: TimedeltaIndex(['1 days', '2 days', '3 days', '4 days', '5 days'], dtype='timedelta64[ns]', freq='D')

In [99]: pd.timedelta_range(end="10 days", periods=4)
Out[99]: TimedeltaIndex(['7 days', '8 days', '9 days', '10 days'], dtype='timedelta64[ns]', freq='D') 
```

`freq`参数可以传递各种频率别名：

```py
In [100]: pd.timedelta_range(start="1 days", end="2 days", freq="30min")
Out[100]: 
TimedeltaIndex(['1 days 00:00:00', '1 days 00:30:00', '1 days 01:00:00',
 '1 days 01:30:00', '1 days 02:00:00', '1 days 02:30:00',
 '1 days 03:00:00', '1 days 03:30:00', '1 days 04:00:00',
 '1 days 04:30:00', '1 days 05:00:00', '1 days 05:30:00',
 '1 days 06:00:00', '1 days 06:30:00', '1 days 07:00:00',
 '1 days 07:30:00', '1 days 08:00:00', '1 days 08:30:00',
 '1 days 09:00:00', '1 days 09:30:00', '1 days 10:00:00',
 '1 days 10:30:00', '1 days 11:00:00', '1 days 11:30:00',
 '1 days 12:00:00', '1 days 12:30:00', '1 days 13:00:00',
 '1 days 13:30:00', '1 days 14:00:00', '1 days 14:30:00',
 '1 days 15:00:00', '1 days 15:30:00', '1 days 16:00:00',
 '1 days 16:30:00', '1 days 17:00:00', '1 days 17:30:00',
 '1 days 18:00:00', '1 days 18:30:00', '1 days 19:00:00',
 '1 days 19:30:00', '1 days 20:00:00', '1 days 20:30:00',
 '1 days 21:00:00', '1 days 21:30:00', '1 days 22:00:00',
 '1 days 22:30:00', '1 days 23:00:00', '1 days 23:30:00',
 '2 days 00:00:00'],
 dtype='timedelta64[ns]', freq='30min')

In [101]: pd.timedelta_range(start="1 days", periods=5, freq="2D5h")
Out[101]: 
TimedeltaIndex(['1 days 00:00:00', '3 days 05:00:00', '5 days 10:00:00',
 '7 days 15:00:00', '9 days 20:00:00'],
 dtype='timedelta64[ns]', freq='53h') 
```

指定`start`、`end`和`periods`将生成从`start`到`end`的一系列均匀间隔的时间增量，包括`start`和`end`，结果为`TimedeltaIndex`中的`periods`个元素：

```py
In [102]: pd.timedelta_range("0 days", "4 days", periods=5)
Out[102]: TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None)

In [103]: pd.timedelta_range("0 days", "4 days", periods=10)
Out[103]: 
TimedeltaIndex(['0 days 00:00:00', '0 days 10:40:00', '0 days 21:20:00',
 '1 days 08:00:00', '1 days 18:40:00', '2 days 05:20:00',
 '2 days 16:00:00', '3 days 02:40:00', '3 days 13:20:00',
 '4 days 00:00:00'],
 dtype='timedelta64[ns]', freq=None) 
```

### 使用`TimedeltaIndex`

与其他类似日期时间索引，如`DatetimeIndex`和`PeriodIndex`，一样，您可以将`TimedeltaIndex`用作 pandas 对象的索引。

```py
In [104]: s = pd.Series(
 .....:    np.arange(100),
 .....:    index=pd.timedelta_range("1 days", periods=100, freq="h"),
 .....: )
 .....: 

In [105]: s
Out[105]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
4 days 23:00:00    95
5 days 00:00:00    96
5 days 01:00:00    97
5 days 02:00:00    98
5 days 03:00:00    99
Freq: h, Length: 100, dtype: int64 
```

选择操作类似，对于类似字符串和切片的情况会进行强制转换：

```py
In [106]: s["1 day":"2 day"]
Out[106]: 
1 days 00:00:00     0
1 days 01:00:00     1
1 days 02:00:00     2
1 days 03:00:00     3
1 days 04:00:00     4
 ..
2 days 19:00:00    43
2 days 20:00:00    44
2 days 21:00:00    45
2 days 22:00:00    46
2 days 23:00:00    47
Freq: h, Length: 48, dtype: int64

In [107]: s["1 day 01:00:00"]
Out[107]: 1

In [108]: s[pd.Timedelta("1 day 1h")]
Out[108]: 1 
```

此外，您可以使用部分字符串选择，范围将被推断：

```py
In [109]: s["1 day":"1 day 5 hours"]
Out[109]: 
1 days 00:00:00    0
1 days 01:00:00    1
1 days 02:00:00    2
1 days 03:00:00    3
1 days 04:00:00    4
1 days 05:00:00    5
Freq: h, dtype: int64 
```

### 操作

最后，`TimedeltaIndex` 与 `DatetimeIndex` 的组合允许进行某些保留 NaT 的组合操作：

```py
In [110]: tdi = pd.TimedeltaIndex(["1 days", pd.NaT, "2 days"])

In [111]: tdi.to_list()
Out[111]: [Timedelta('1 days 00:00:00'), NaT, Timedelta('2 days 00:00:00')]

In [112]: dti = pd.date_range("20130101", periods=3)

In [113]: dti.to_list()
Out[113]: 
[Timestamp('2013-01-01 00:00:00'),
 Timestamp('2013-01-02 00:00:00'),
 Timestamp('2013-01-03 00:00:00')]

In [114]: (dti + tdi).to_list()
Out[114]: [Timestamp('2013-01-02 00:00:00'), NaT, Timestamp('2013-01-05 00:00:00')]

In [115]: (dti - tdi).to_list()
Out[115]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2013-01-01 00:00:00')] 
```

### 转换

类似于上面 `Series` 上的频率转换，您可以将这些索引转换为另一个索引。

```py
In [116]: tdi / np.timedelta64(1, "s")
Out[116]: Index([86400.0, nan, 172800.0], dtype='float64')

In [117]: tdi.astype("timedelta64[s]")
Out[117]: TimedeltaIndex(['1 days', NaT, '2 days'], dtype='timedelta64[s]', freq=None) 
```

标量类型的操作也可以正常工作。这些操作可能返回一个*不同*类型的索引。

```py
# adding or timedelta and date -> datelike
In [118]: tdi + pd.Timestamp("20130101")
Out[118]: DatetimeIndex(['2013-01-02', 'NaT', '2013-01-03'], dtype='datetime64[ns]', freq=None)

# subtraction of a date and a timedelta -> datelike
# note that trying to subtract a date from a Timedelta will raise an exception
In [119]: (pd.Timestamp("20130101") - tdi).to_list()
Out[119]: [Timestamp('2012-12-31 00:00:00'), NaT, Timestamp('2012-12-30 00:00:00')]

# timedelta + timedelta -> timedelta
In [120]: tdi + pd.Timedelta("10 days")
Out[120]: TimedeltaIndex(['11 days', NaT, '12 days'], dtype='timedelta64[ns]', freq=None)

# division can result in a Timedelta if the divisor is an integer
In [121]: tdi / 2
Out[121]: TimedeltaIndex(['0 days 12:00:00', NaT, '1 days 00:00:00'], dtype='timedelta64[ns]', freq=None)

# or a float64 Index if the divisor is a Timedelta
In [122]: tdi / tdi[0]
Out[122]: Index([1.0, nan, 2.0], dtype='float64') 
```

## 重采样

类似于时间序列重采样，我们可以使用 `TimedeltaIndex` 进行重采样。

```py
In [123]: s.resample("D").mean()
Out[123]: 
1 days    11.5
2 days    35.5
3 days    59.5
4 days    83.5
5 days    97.5
Freq: D, dtype: float64 
```
