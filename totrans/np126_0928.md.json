["```py\nclass numpy.lib.mixins.NDArrayOperatorsMixin\n```", "```py\nclass ArrayLike(np.lib.mixins.NDArrayOperatorsMixin):\n    def __init__(self, value):\n        self.value = np.asarray(value)\n\n    # One might also consider adding the built-in list type to this\n    # list, to support operations like np.add(array_like, list)\n    _HANDLED_TYPES = (np.ndarray, numbers.Number)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        out = kwargs.get('out', ())\n        for x in inputs + out:\n            # Only support operations with instances of _HANDLED_TYPES.\n            # Use ArrayLike instead of type(self) for isinstance to\n            # allow subclasses that don't override __array_ufunc__ to\n            # handle ArrayLike objects.\n            if not isinstance(x, self._HANDLED_TYPES + (ArrayLike,)):\n                return NotImplemented\n\n        # Defer to the implementation of the ufunc on unwrapped values.\n        inputs = tuple(x.value if isinstance(x, ArrayLike) else x\n                       for x in inputs)\n        if out:\n            kwargs['out'] = tuple(\n                x.value if isinstance(x, ArrayLike) else x\n                for x in out)\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        if type(result) is tuple:\n            # multiple return values\n            return tuple(type(self)(x) for x in result)\n        elif method == 'at':\n            # no return value\n            return None\n        else:\n            # one return value\n            return type(self)(result)\n\n    def __repr__(self):\n        return '%s(%r)' % (type(self).__name__, self.value) \n```", "```py\n>>> x = ArrayLike([1, 2, 3])\n>>> x - 1\nArrayLike(array([0, 1, 2]))\n>>> 1 - x\nArrayLike(array([ 0, -1, -2]))\n>>> np.arange(3) - x\nArrayLike(array([-1, -1, -1]))\n>>> x - np.arange(3)\nArrayLike(array([1, 1, 1])) \n```"]