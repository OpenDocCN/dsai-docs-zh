# 控制 API

> 原文：[https://docs.sympy.org/latest/modules/physics/control/lti.html](https://docs.sympy.org/latest/modules/physics/control/lti.html)

## lti

```py
class sympy.physics.control.lti.TransferFunction(num, den, var)
```

用于表示可以由拉普拉斯变换复数变量中的多项式比严格描述的LTI（线性、时不变）系统的类。参数包括 `num`、`den` 和 `var`，其中 `num` 和 `den` 分别是传递函数的分子和分母多项式，第三个参数是这些传递函数中使用的拉普拉斯变换的复数变量。`num` 和 `den` 可以是多项式或数字，而 `var` 必须是一个[`Symbol`](../../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")。

参数：

**num**：表达式，数值

> 传递函数的分子多项式。

**den**：表达式，数值

> 传递函数的分母多项式。

**var**：符号

> 传递函数的拉普拉斯变换中使用的复数变量。

引发：

**TypeError**

> 当 `var` 不是符号或 `num` 或 `den` 不是数字或多项式时。

**ValueError**

> 当 `den` 为零时。

解释

一般来说，表示物理模型的动态系统可以用线性常微分方程描述，如 -

> \(\small{b_{m}y^{\left(m\right)}+b_{m-1}y^{\left(m-1\right)}+\dots+b_{1}y^{\left(1\right)}+b_{0}y= a_{n}x^{\left(n\right)}+a_{n-1}x^{\left(n-1\right)}+\dots+a_{1}x^{\left(1\right)}+a_{0}x}\)

这里，\(x\) 是输入信号，\(y\) 是输出信号，两者上的上标表示导数的阶数（不是指数）。导数是相对于自变量 \(t\) 求取的。一般情况下，\(m\) 大于 \(n\)。

在其原生形式下分析这类系统的属性是不可行的，因此我们使用拉普拉斯变换等数学工具来获得更好的视角。在方程两边（在零初值条件下）进行拉普拉斯变换，我们得到 -

> \(\small{\mathcal{L}[b_{m}y^{\left(m\right)}+b_{m-1}y^{\left(m-1\right)}+\dots+b_{1}y^{\left(1\right)}+b_{0}y]= \mathcal{L}[a_{n}x^{\left(n\right)}+a_{n-1}x^{\left(n-1\right)}+\dots+a_{1}x^{\left(1\right)}+a_{0}x]}\)

利用拉普拉斯变换的线性性质，并考虑零初值条件（即 \(\small{y(0^{-}) = 0}\)，\(\small{y'(0^{-}) = 0}\) 等），上述方程可以转化为 -

> \(\small{b_{m}\mathcal{L}[y^{\left(m\right)}]+\dots+b_{1}\mathcal{L}[y^{\left(1\right)}]+b_{0}\mathcal{L}[y]= a_{n}\mathcal{L}[x^{\left(n\right)}]+\dots+a_{1}\mathcal{L}[x^{\left(1\right)}]+a_{0}\mathcal{L}[x]}\)

现在，应用拉普拉斯变换的导数性质，

> \(\small{b_{m}s^{m}\mathcal{L}[y]+\dots+b_{1}s\mathcal{L}[y]+b_{0}\mathcal{L}[y]= a_{n}s^{n}\mathcal{L}[x]+\dots+a_{1}s\mathcal{L}[x]+a_{0}\mathcal{L}[x]}\)

在这里，\(s\)上的上标是**指数**。请注意，上面提到的零初始条件假设非常重要，不能忽略，否则动态系统不能被视为时间独立，并且无法达到上述简化的方程。

从两边收集\(\mathcal{L}[y]\)和\(\mathcal{L}[x]\)项，并取比率\(\frac{ \mathcal{L}\left\{y\right\} }{ \mathcal{L}\left\{x\right\} }\)，我们得到传递函数的典型有理形式。

传递函数的分子因此是输出信号（信号表示为时间函数）的拉普拉斯变换，类似地，传递函数的分母是输入信号的拉普拉斯变换。如下所示，将输入和输出信号的拉普拉斯变换用大写字母表示也是一种约定。

> \(H(s) = \frac{Y(s)}{X(s)} = \frac{ \mathcal{L}\left\{y(t)\right\} }{ \mathcal{L}\left\{x(t)\right\} }\)

\(s\)，也称为复频率，在拉普拉斯域中是一个复变量。它对应于时间域中的等效变量\(t\)。传递函数有时也称为系统冲激响应的拉普拉斯变换。传递函数\(H\)在\(s\)中表示为一个有理函数，如下所示，

> \(H(s) =\ \frac{a_{n}s^{n}+a_{n-1}s^{n-1}+\dots+a_{1}s+a_{0}}{b_{m}s^{m}+b_{m-1}s^{m-1}+\dots+b_{1}s+b_{0}}\)

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction(s + a, s**2 + s + 1, s)
>>> tf1
TransferFunction(a + s, s**2 + s + 1, s)
>>> tf1.num
a + s
>>> tf1.den
s**2 + s + 1
>>> tf1.var
s
>>> tf1.args
(a + s, s**2 + s + 1, s) 
```

任何复变量都可以用于`var`。

```py
>>> tf2 = TransferFunction(a*p**3 - a*p**2 + s*p, p + a**2, p)
>>> tf2
TransferFunction(a*p**3 - a*p**2 + p*s, a**2 + p, p)
>>> tf3 = TransferFunction((p + 3)*(p - 1), (p - 1)*(p + 5), p)
>>> tf3
TransferFunction((p - 1)*(p + 3), (p - 1)*(p + 5), p) 
```

要对传递函数取反，可以在其前面加上`-`运算符：

```py
>>> tf4 = TransferFunction(-a + s, p**2 + s, p)
>>> -tf4
TransferFunction(a - s, p**2 + s, p)
>>> tf5 = TransferFunction(s**4 - 2*s**3 + 5*s + 4, s + 4, s)
>>> -tf5
TransferFunction(-s**4 + 2*s**3 - 5*s - 4, s + 4, s) 
```

您可以使用浮点数或整数（或其他常数）作为分子和分母：

```py
>>> tf6 = TransferFunction(1/2, 4, s)
>>> tf6.num
0.500000000000000
>>> tf6.den
4
>>> tf6.var
s
>>> tf6.args
(0.5, 4, s) 
```

您可以使用`**`运算符对传递函数进行整数幂运算：

```py
>>> tf7 = TransferFunction(s + a, s - a, s)
>>> tf7**3
TransferFunction((a + s)**3, (-a + s)**3, s)
>>> tf7**0
TransferFunction(1, 1, s)
>>> tf8 = TransferFunction(p + 4, p - 3, p)
>>> tf8**-1
TransferFunction(p - 3, p + 4, p) 
```

传递函数的加法、减法和乘法可以形成未计算的`Series`或`Parallel`对象。

```py
>>> tf9 = TransferFunction(s + 1, s**2 + s + 1, s)
>>> tf10 = TransferFunction(s - p, s + 3, s)
>>> tf11 = TransferFunction(4*s**2 + 2*s - 4, s - 1, s)
>>> tf12 = TransferFunction(1 - s, s**2 + 4, s)
>>> tf9 + tf10
Parallel(TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(-p + s, s + 3, s))
>>> tf10 - tf11
Parallel(TransferFunction(-p + s, s + 3, s), TransferFunction(-4*s**2 - 2*s + 4, s - 1, s))
>>> tf9 * tf10
Series(TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(-p + s, s + 3, s))
>>> tf10 - (tf9 + tf12)
Parallel(TransferFunction(-p + s, s + 3, s), TransferFunction(-s - 1, s**2 + s + 1, s), TransferFunction(s - 1, s**2 + 4, s))
>>> tf10 - (tf9 * tf12)
Parallel(TransferFunction(-p + s, s + 3, s), Series(TransferFunction(-1, 1, s), TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(1 - s, s**2 + 4, s)))
>>> tf11 * tf10 * tf9
Series(TransferFunction(4*s**2 + 2*s - 4, s - 1, s), TransferFunction(-p + s, s + 3, s), TransferFunction(s + 1, s**2 + s + 1, s))
>>> tf9 * tf11 + tf10 * tf12
Parallel(Series(TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(4*s**2 + 2*s - 4, s - 1, s)), Series(TransferFunction(-p + s, s + 3, s), TransferFunction(1 - s, s**2 + 4, s)))
>>> (tf9 + tf12) * (tf10 + tf11)
Series(Parallel(TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(1 - s, s**2 + 4, s)), Parallel(TransferFunction(-p + s, s + 3, s), TransferFunction(4*s**2 + 2*s - 4, s - 1, s))) 
```

这些未计算的`Series`或`Parallel`对象可以通过`.doit()`方法或`.rewrite(TransferFunction)`转换为最终的传递函数。

```py
>>> ((tf9 + tf10) * tf12).doit()
TransferFunction((1 - s)*((-p + s)*(s**2 + s + 1) + (s + 1)*(s + 3)), (s + 3)*(s**2 + 4)*(s**2 + s + 1), s)
>>> (tf9 * tf10 - tf11 * tf12).rewrite(TransferFunction)
TransferFunction(-(1 - s)*(s + 3)*(s**2 + s + 1)*(4*s**2 + 2*s - 4) + (-p + s)*(s - 1)*(s + 1)*(s**2 + 4), (s - 1)*(s + 3)*(s**2 + 4)*(s**2 + s + 1), s) 
```

另请参见

[`反馈`](#sympy.physics.control.lti.Feedback "sympy.physics.control.lti.Feedback"), [`串联`](#sympy.physics.control.lti.Series "sympy.physics.control.lti.Series"), [`并联`](#sympy.physics.control.lti.Parallel "sympy.physics.control.lti.Parallel")

参考文献

[[R734](#id1)]

[https://zh.wikipedia.org/wiki/传递函数](https://zh.wikipedia.org/wiki/传递函数)

[[R735](#id2)]

[https://zh.wikipedia.org/wiki/拉普拉斯变换](https://zh.wikipedia.org/wiki/拉普拉斯变换)

```py
dc_gain()
```

计算频率接近零时响应的增益。

对于纯积分器系统，直流增益是无穷大。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction(s + 3, s**2 - 9, s)
>>> tf1.dc_gain()
-1/3
>>> tf2 = TransferFunction(p**2, p - 3 + p**3, p)
>>> tf2.dc_gain()
0
>>> tf3 = TransferFunction(a*p**2 - b, s + b, s)
>>> tf3.dc_gain()
(a*p**2 - b)/b
>>> tf4 = TransferFunction(1, s, s)
>>> tf4.dc_gain()
oo 
```

```py
property den
```

返回传递函数的分母多项式。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction
>>> G1 = TransferFunction(s + 4, p**3 - 2*p + 4, s)
>>> G1.den
p**3 - 2*p + 4
>>> G2 = TransferFunction(3, 4, s)
>>> G2.den
4 
```

```py
eval_frequency(other)
```

返回在实数或复数平面上任意点的系统响应。

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy.physics.control.lti import TransferFunction
>>> from sympy import I
>>> tf1 = TransferFunction(1, s**2 + 2*s + 1, s)
>>> omega = 0.1
>>> tf1.eval_frequency(I*omega)
1/(0.99 + 0.2*I)
>>> tf2 = TransferFunction(s**2, a*s + p, s)
>>> tf2.eval_frequency(2)
4/(2*a + p)
>>> tf2.eval_frequency(I*2)
-4/(2*I*a + p) 
```

```py
expand()
```

返回展开形式中分子和分母的传递函数。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> G1 = TransferFunction((a - s)**2, (s**2 + a)**2, s)
>>> G1.expand()
TransferFunction(a**2 - 2*a*s + s**2, a**2 + 2*a*s**2 + s**4, s)
>>> G2 = TransferFunction((p + 3*b)*(p - b), (p - b)*(p + 2*b), p)
>>> G2.expand()
TransferFunction(-3*b**2 + 2*b*p + p**2, -2*b**2 + b*p + p**2, p) 
```

```py
classmethod from_coeff_lists(num_list, den_list, var)
```

从系数列表高效地创建新的`TransferFunction`。

参数：

**num_list** : 序列

> 组成分子系数的序列。

**den_list** : 序列

> 组成分母系数的序列。

**var** : 符号

> 传递函数多项式使用的复变量拉普拉斯变换。

抛出：

**ZeroDivisionError**

> 当构造的分母为零时。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction
>>> num = [1, 0, 2]
>>> den = [3, 2, 2, 1]
>>> tf = TransferFunction.from_coeff_lists(num, den, s)
>>> tf
TransferFunction(s**2 + 2, 3*s**3 + 2*s**2 + 2*s + 1, s) 
```

# 使用多个变量创建传递函数 >>> tf1 = TransferFunction.from_coeff_lists([p, 1], [2*p, 0, 4], s) >>> tf1 TransferFunction(p*s + 1, 2*p*s**2 + 4, s)

```py
classmethod from_rational_expression(expr, var=None)
```

从有理表达式有效地创建新的 `TransferFunction`。

参数：

**expr** : 表达式，数值

> 表示 `TransferFunction` 的有理表达式。

**var** : 符号，可选

> 传递函数多项式使用的复变量拉普拉斯变换。

抛出：

**ValueError**

> 当 `expr` 是 `Number` 类型且可选参数 `var` 未传递时。
> 
> 当 `expr` 包含多个变量且可选参数 `var` 未传递时。

**ZeroDivisionError**

> 当 `expr` 的分母为零或其分子中包含 `ComplexInfinity` 时。

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy.physics.control.lti import TransferFunction
>>> expr1 = (s + 5)/(3*s**2 + 2*s + 1)
>>> tf1 = TransferFunction.from_rational_expression(expr1)
>>> tf1
TransferFunction(s + 5, 3*s**2 + 2*s + 1, s)
>>> expr2 = (a*p**3 - a*p**2 + s*p)/(p + a**2)  # Expr with more than one variables
>>> tf2 = TransferFunction.from_rational_expression(expr2, p)
>>> tf2
TransferFunction(a*p**3 - a*p**2 + p*s, a**2 + p, p) 
```

如果在表达式中存在两个或多个变量的冲突，SymPy 将会抛出 `ValueError`，如果用户未传递 `var`。

```py
>>> tf = TransferFunction.from_rational_expression((a + a*s)/(s**2 + s + 1))
Traceback (most recent call last):
...
ValueError: Conflicting values found for positional argument `var` ({a, s}). Specify it manually. 
```

这可以通过手动指定 `var` 参数来纠正。

```py
>>> tf = TransferFunction.from_rational_expression((a + a*s)/(s**2 + s + 1), s)
>>> tf
TransferFunction(a*s + a, s**2 + s + 1, s) 
```

当 `expr` 是 `Number` 时，也需要指定 `var`。

```py
>>> tf3 = TransferFunction.from_rational_expression(10, s)
>>> tf3
TransferFunction(10, 1, s) 
```

```py
classmethod from_zpk(zeros, poles, gain, var)
```

从给定的零点、极点和增益创建新的 `TransferFunction`。

参数：

**zeros** : 序列

> 组成传递函数的零点序列。

**poles** : 序列

> 传递函数的极点序列。

**gain** : 数值，符号，表达式

> 指定模型增益的标量值。

**var** : 符号

> 传递函数多项式使用的复变量拉普拉斯变换。

示例

```py
>>> from sympy.abc import s, p, k
>>> from sympy.physics.control.lti import TransferFunction
>>> zeros = [1, 2, 3]
>>> poles = [6, 5, 4]
>>> gain = 7
>>> tf = TransferFunction.from_zpk(zeros, poles, gain, s)
>>> tf
TransferFunction(7*(s - 3)*(s - 2)*(s - 1), (s - 6)*(s - 5)*(s - 4), s) 
```

# 使用变量极点和零点创建传递函数 >>> tf1 = TransferFunction.from_zpk([p, k], [p + k, p - k], 2, s) >>> tf1 TransferFunction(2*(-k + s)*(-p + s), (-k - p + s)*(k - p + s), s)

# 复极点或零点都是可以接受的 >>> tf2 = TransferFunction.from_zpk([0], [1-1j, 1+1j, 2], -2, s) >>> tf2 TransferFunction(-2*s, (s - 2)*(s - 1.0 - 1.0*I)*(s - 1.0 + 1.0*I), s)

```py
property is_biproper
```

返回如果分子多项式的次数等于分母多项式的次数则为True，否则为False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf1.is_biproper
True
>>> tf2 = TransferFunction(p**2, p + a, p)
>>> tf2.is_biproper
False 
```

```py
property is_proper
```

返回如果分子多项式的次数小于或等于分母多项式的次数则为True，否则为False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)
>>> tf1.is_proper
False
>>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*p + 2, p)
>>> tf2.is_proper
True 
```

```py
is_stable()
```

返回如果传递函数是渐近稳定的则为True，否则为False。

这不会检查系统的边际或条件稳定性。

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy import symbols
>>> from sympy.physics.control.lti import TransferFunction
>>> q, r = symbols('q, r', negative=True)
>>> tf1 = TransferFunction((1 - s)**2, (s + 1)**2, s)
>>> tf1.is_stable()
True
>>> tf2 = TransferFunction((1 - p)**2, (s**2 + 1)**2, s)
>>> tf2.is_stable()
False
>>> tf3 = TransferFunction(4, q*s - r, s)
>>> tf3.is_stable()
False
>>> tf4 = TransferFunction(p + 1, a*p - s**2, p)
>>> tf4.is_stable() is None   # Not enough info about the symbols to determine stability
True 
```

```py
property is_strictly_proper
```

返回如果分子多项式的次数严格小于分母多项式的次数则为True，否则为False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf1.is_strictly_proper
False
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tf2.is_strictly_proper
True 
```

```py
property num
```

返回传递函数的分子多项式。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction
>>> G1 = TransferFunction(s**2 + p*s + 3, s - 4, s)
>>> G1.num
p*s + s**2 + 3
>>> G2 = TransferFunction((p + 5)*(p - 3), (p - 3)*(p + 1), p)
>>> G2.num
(p - 3)*(p + 5) 
```

```py
poles()
```

返回传递函数的极点。

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction((p + 3)*(p - 1), (p - 1)*(p + 5), p)
>>> tf1.poles()
[-5, 1]
>>> tf2 = TransferFunction((1 - s)**2, (s**2 + 1)**2, s)
>>> tf2.poles()
[I, I, -I, -I]
>>> tf3 = TransferFunction(s**2, a*s + p, s)
>>> tf3.poles()
[-p/a] 
```

```py
to_expr()
```

将 `TransferFunction` 对象转换为 SymPy 表达式。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction
>>> from sympy import Expr
>>> tf1 = TransferFunction(s, a*s**2 + 1, s)
>>> tf1.to_expr()
s/(a*s**2 + 1)
>>> isinstance(_, Expr)
True
>>> tf2 = TransferFunction(1, (p + 3*b)*(b - p), p)
>>> tf2.to_expr()
1/((b - p)*(3*b + p))
>>> tf3 = TransferFunction((s - 2)*(s - 3), (s - 1)*(s - 2)*(s - 3), s)
>>> tf3.to_expr()
((s - 3)*(s - 2))/(((s - 3)*(s - 2)*(s - 1))) 
```

```py
property var
```

返回传递函数多项式使用的复变量拉普拉斯变换。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G1.var
p
>>> G2 = TransferFunction(0, s - 5, s)
>>> G2.var
s 
```

```py
zeros()
```

返回传递函数的零点。

示例

```py
>>> from sympy.abc import s, p, a
>>> from sympy.physics.control.lti import TransferFunction
>>> tf1 = TransferFunction((p + 3)*(p - 1), (p - 1)*(p + 5), p)
>>> tf1.zeros()
[-3, 1]
>>> tf2 = TransferFunction((1 - s)**2, (s**2 + 1)**2, s)
>>> tf2.zeros()
[1, 1]
>>> tf3 = TransferFunction(s**2, a*s + p, s)
>>> tf3.zeros()
[0, 0] 
```

```py
class sympy.physics.control.lti.Series(*args, evaluate=False)
```

用于表示串联配置的 SISO 系统的类。

参数：

**args** : SISO 线性时不变

> 串联配置的 SISO 系统。

**评估** : 布尔值，关键字

> 当传递 `True` 时，返回等效于 `Series(*args).doit()`。 默认设置为 `False`。

引发：

**数值错误**

> 当没有传递参数时。
> 
> `var` 属性对每个系统不相同。

**类型错误**

> 任何传递的 `*args` 具有不支持的类型
> 
> 传递了 SISO 和 MIMO 系统的组合。 传递的系统类型应保持同质性，此处为 SISO。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Series, Parallel
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tf3 = TransferFunction(p**2, p + s, s)
>>> S1 = Series(tf1, tf2)
>>> S1
Series(TransferFunction(a*p**2 + b*s, -p + s, s), TransferFunction(s**3 - 2, s**4 + 5*s + 6, s))
>>> S1.var
s
>>> S2 = Series(tf2, Parallel(tf3, -tf1))
>>> S2
Series(TransferFunction(s**3 - 2, s**4 + 5*s + 6, s), Parallel(TransferFunction(p**2, p + s, s), TransferFunction(-a*p**2 - b*s, -p + s, s)))
>>> S2.var
s
>>> S3 = Series(Parallel(tf1, tf2), Parallel(tf2, tf3))
>>> S3
Series(Parallel(TransferFunction(a*p**2 + b*s, -p + s, s), TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)), Parallel(TransferFunction(s**3 - 2, s**4 + 5*s + 6, s), TransferFunction(p**2, p + s, s)))
>>> S3.var
s 
```

您可以通过使用 `.doit()` 方法获得结果传递函数：

```py
>>> S3 = Series(tf1, tf2, -tf3)
>>> S3.doit()
TransferFunction(-p**2*(s**3 - 2)*(a*p**2 + b*s), (-p + s)*(p + s)*(s**4 + 5*s + 6), s)
>>> S4 = Series(tf2, Parallel(tf1, -tf3))
>>> S4.doit()
TransferFunction((s**3 - 2)*(-p**2*(-p + s) + (p + s)*(a*p**2 + b*s)), (-p + s)*(p + s)*(s**4 + 5*s + 6), s) 
```

注意

所有传递函数应使用拉普拉斯变换的同一复变量 `var`。

参见

[`MIMO 串联`](#sympy.physics.control.lti.MIMOSeries "sympy.physics.control.lti.MIMOSeries"), [`并联`](#sympy.physics.control.lti.Parallel "sympy.physics.control.lti.Parallel"), [`传递函数`](#sympy.physics.control.lti.TransferFunction "sympy.physics.control.lti.TransferFunction"), [`反馈`](#sympy.physics.control.lti.Feedback "sympy.physics.control.lti.Feedback")

```py
doit(**hints)
```

返回在串联配置中评估传递函数后获得的结果传递函数。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Series
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> Series(tf2, tf1).doit()
TransferFunction((s**3 - 2)*(a*p**2 + b*s), (-p + s)*(s**4 + 5*s + 6), s)
>>> Series(-tf1, -tf2).doit()
TransferFunction((2 - s**3)*(-a*p**2 - b*s), (-p + s)*(s**4 + 5*s + 6), s) 
```

```py
property is_biproper
```

如果结果传递函数的分子多项式的度数等于相同分母多项式的度数，则返回 True，否则返回 False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Series
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(p, s**2, s)
>>> tf3 = TransferFunction(s**2, 1, s)
>>> S1 = Series(tf1, -tf2)
>>> S1.is_biproper
False
>>> S2 = Series(tf2, tf3)
>>> S2.is_biproper
True 
```

```py
property is_proper
```

如果结果传递函数的分子多项式的度数小于或等于相同分母多项式的度数，则返回 True，否则返回 False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Series
>>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)
>>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*s + 2, s)
>>> tf3 = TransferFunction(s, s**2 + s + 1, s)
>>> S1 = Series(-tf2, tf1)
>>> S1.is_proper
False
>>> S2 = Series(tf1, tf2, tf3)
>>> S2.is_proper
True 
```

```py
property is_strictly_proper
```

如果结果传递函数的分子多项式的度数严格小于相同分母多项式的度数，则返回 True，否则返回 False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Series
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**2 + 5*s + 6, s)
>>> tf3 = TransferFunction(1, s**2 + s + 1, s)
>>> S1 = Series(tf1, tf2)
>>> S1.is_strictly_proper
False
>>> S2 = Series(tf1, tf2, tf3)
>>> S2.is_strictly_proper
True 
```

```py
to_expr()
```

返回等效于 `Expr` 对象。

```py
property var
```

返回所有传递函数使用的复变量。

示例

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, Series, Parallel
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G2 = TransferFunction(p, 4 - p, p)
>>> G3 = TransferFunction(0, p**4 - 1, p)
>>> Series(G1, G2).var
p
>>> Series(-G3, Parallel(G1, G2)).var
p 
```

```py
class sympy.physics.control.lti.Parallel(*args, evaluate=False)
```

用于表示串联配置的 SISO 系统的类。

参数：

**args** : SISO 线性时不变

> 并联排列的 SISO 系统。

**评估** : 布尔值，关键字

> 当传递 `True` 时，返回等效于 `Parallel(*args).doit()`。 默认设置为 `False`。

引发：

**数值错误**

> 当没有传递参数时。
> 
> `var` 属性对每个系统不相同。

**类型错误**

> 任何传递的 `*args` 具有不支持的类型
> 
> 传递了 SISO 和 MIMO 系统的组合。 传递的系统类型应保持同质性。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Parallel, Series
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tf3 = TransferFunction(p**2, p + s, s)
>>> P1 = Parallel(tf1, tf2)
>>> P1
Parallel(TransferFunction(a*p**2 + b*s, -p + s, s), TransferFunction(s**3 - 2, s**4 + 5*s + 6, s))
>>> P1.var
s
>>> P2 = Parallel(tf2, Series(tf3, -tf1))
>>> P2
Parallel(TransferFunction(s**3 - 2, s**4 + 5*s + 6, s), Series(TransferFunction(p**2, p + s, s), TransferFunction(-a*p**2 - b*s, -p + s, s)))
>>> P2.var
s
>>> P3 = Parallel(Series(tf1, tf2), Series(tf2, tf3))
>>> P3
Parallel(Series(TransferFunction(a*p**2 + b*s, -p + s, s), TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)), Series(TransferFunction(s**3 - 2, s**4 + 5*s + 6, s), TransferFunction(p**2, p + s, s)))
>>> P3.var
s 
```

您可以通过使用 `.doit()` 方法获得结果传递函数：

```py
>>> Parallel(tf1, tf2, -tf3).doit()
TransferFunction(-p**2*(-p + s)*(s**4 + 5*s + 6) + (-p + s)*(p + s)*(s**3 - 2) + (p + s)*(a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(p + s)*(s**4 + 5*s + 6), s)
>>> Parallel(tf2, Series(tf1, -tf3)).doit()
TransferFunction(-p**2*(a*p**2 + b*s)*(s**4 + 5*s + 6) + (-p + s)*(p + s)*(s**3 - 2), (-p + s)*(p + s)*(s**4 + 5*s + 6), s) 
```

注意

所有传递函数应使用拉普拉斯变换的同一复变量 `var`。

参见

[`串联`](#sympy.physics.control.lti.Series "sympy.physics.control.lti.Series"), [`传递函数`](#sympy.physics.control.lti.TransferFunction "sympy.physics.control.lti.TransferFunction"), [`反馈`](#sympy.physics.control.lti.Feedback "sympy.physics.control.lti.Feedback")

```py
doit(**hints)
```

返回在并联配置中评估传递函数后获得的结果传递函数。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Parallel
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> Parallel(tf2, tf1).doit()
TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)
>>> Parallel(-tf1, -tf2).doit()
TransferFunction((2 - s**3)*(-p + s) + (-a*p**2 - b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s) 
```

```py
property is_biproper
```

如果结果传递函数的分子多项式的次数等于相同的分母多项式的次数，则返回True，否则返回False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Parallel
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(p**2, p + s, s)
>>> tf3 = TransferFunction(s, s**2 + s + 1, s)
>>> P1 = Parallel(tf1, -tf2)
>>> P1.is_biproper
True
>>> P2 = Parallel(tf2, tf3)
>>> P2.is_biproper
False 
```

```py
property is_proper
```

如果结果传递函数的分子多项式的次数小于或等于相同的分母多项式的次数，则返回True，否则返回False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Parallel
>>> tf1 = TransferFunction(b*s**2 + p**2 - a*p + s, b - p**2, s)
>>> tf2 = TransferFunction(p**2 - 4*p, p**3 + 3*s + 2, s)
>>> tf3 = TransferFunction(s, s**2 + s + 1, s)
>>> P1 = Parallel(-tf2, tf1)
>>> P1.is_proper
False
>>> P2 = Parallel(tf2, tf3)
>>> P2.is_proper
True 
```

```py
property is_strictly_proper
```

如果结果传递函数的分子多项式的次数严格小于分母多项式的次数，则返回True，否则返回False。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, Parallel
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tf3 = TransferFunction(s, s**2 + s + 1, s)
>>> P1 = Parallel(tf1, tf2)
>>> P1.is_strictly_proper
False
>>> P2 = Parallel(tf2, tf3)
>>> P2.is_strictly_proper
True 
```

```py
to_expr()
```

返回等效的`Expr`对象。

```py
property var
```

返回所有传递函数使用的复数变量。

示例

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, Parallel, Series
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G2 = TransferFunction(p, 4 - p, p)
>>> G3 = TransferFunction(0, p**4 - 1, p)
>>> Parallel(G1, G2).var
p
>>> Parallel(-G3, Series(G1, G2)).var
p 
```

```py
class sympy.physics.control.lti.Feedback(sys1, sys2=None, sign=-1)
```

一个用于表示两个SISO输入/输出系统之间闭环反馈互连的类。

第一个参数`sys1`是闭环系统的前馈部分，或者简单来说，是代表要控制的过程的动态模型。第二个参数`sys2`是反馈系统，并控制反馈信号到`sys1`。`sys1`和`sys2`都可以是`Series`或`TransferFunction`对象。

参数：

**sys1** : Series, TransferFunction

> 前馈路径系统。

**sys2** : Series, TransferFunction, optional

> 反馈路径系统（通常是反馈控制器）。它是位于反馈路径上的模型。
> 
> 如果未明确指定，假设`sys2`为单位（1.0）传递函数。

**sign** : int, optional

> 反馈的符号。可以是`1`（正反馈）或`-1`（负反馈）。默认值为\(-1\)。

抛出：

**ValueError**

> 当`sys1`和`sys2`没有使用相同的拉普拉斯变换复数变量时。
> 
> 当`sys1`和`sys2`的组合产生零分母时。

**TypeError**

> 当`sys1`或`sys2`不是`Series`或`TransferFunction`对象时。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> controller = TransferFunction(5*s - 10, s + 7, s)
>>> F1 = Feedback(plant, controller)
>>> F1
Feedback(TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s), TransferFunction(5*s - 10, s + 7, s), -1)
>>> F1.var
s
>>> F1.args
(TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s), TransferFunction(5*s - 10, s + 7, s), -1) 
```

你可以分别使用`.sys1`和`.sys2`获取前馈和反馈路径系统。

```py
>>> F1.sys1
TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> F1.sys2
TransferFunction(5*s - 10, s + 7, s) 
```

通过使用`.doit()`方法，你可以获得通过负反馈互连得到的结果闭环传递函数。

```py
>>> F1.doit()
TransferFunction((s + 7)*(s**2 - 4*s + 2)*(3*s**2 + 7*s - 3), ((s + 7)*(s**2 - 4*s + 2) + (5*s - 10)*(3*s**2 + 7*s - 3))*(s**2 - 4*s + 2), s)
>>> G = TransferFunction(2*s**2 + 5*s + 1, s**2 + 2*s + 3, s)
>>> C = TransferFunction(5*s + 10, s + 10, s)
>>> F2 = Feedback(G*C, TransferFunction(1, 1, s))
>>> F2.doit()
TransferFunction((s + 10)*(5*s + 10)*(s**2 + 2*s + 3)*(2*s**2 + 5*s + 1), (s + 10)*((s + 10)*(s**2 + 2*s + 3) + (5*s + 10)*(2*s**2 + 5*s + 1))*(s**2 + 2*s + 3), s) 
```

要否定`Feedback`对象，可以添加`-`运算符：

```py
>>> -F1
Feedback(TransferFunction(-3*s**2 - 7*s + 3, s**2 - 4*s + 2, s), TransferFunction(10 - 5*s, s + 7, s), -1)
>>> -F2
Feedback(Series(TransferFunction(-1, 1, s), TransferFunction(2*s**2 + 5*s + 1, s**2 + 2*s + 3, s), TransferFunction(5*s + 10, s + 10, s)), TransferFunction(-1, 1, s), -1) 
```

另见

[`MIMOFeedback`](#sympy.physics.control.lti.MIMOFeedback "sympy.physics.control.lti.MIMOFeedback"), [`Series`](#sympy.physics.control.lti.Series "sympy.physics.control.lti.Series"), [`Parallel`](#sympy.physics.control.lti.Parallel "sympy.physics.control.lti.Parallel")

```py
property den
```

返回闭环反馈模型的分母。

```py
doit(cancel=False, expand=False, **hints)
```

返回通过反馈互连得到的结果传递函数。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> controller = TransferFunction(5*s - 10, s + 7, s)
>>> F1 = Feedback(plant, controller)
>>> F1.doit()
TransferFunction((s + 7)*(s**2 - 4*s + 2)*(3*s**2 + 7*s - 3), ((s + 7)*(s**2 - 4*s + 2) + (5*s - 10)*(3*s**2 + 7*s - 3))*(s**2 - 4*s + 2), s)
>>> G = TransferFunction(2*s**2 + 5*s + 1, s**2 + 2*s + 3, s)
>>> F2 = Feedback(G, TransferFunction(1, 1, s))
>>> F2.doit()
TransferFunction((s**2 + 2*s + 3)*(2*s**2 + 5*s + 1), (s**2 + 2*s + 3)*(3*s**2 + 7*s + 4), s) 
```

使用关键字参数`expand=True`来展开结果传递函数。使用`cancel=True`来取消分子和分母中的公共项。

```py
>>> F2.doit(cancel=True, expand=True)
TransferFunction(2*s**2 + 5*s + 1, 3*s**2 + 7*s + 4, s)
>>> F2.doit(expand=True)
TransferFunction(2*s**4 + 9*s**3 + 17*s**2 + 17*s + 3, 3*s**4 + 13*s**3 + 27*s**2 + 29*s + 12, s) 
```

```py
property num
```

返回闭环反馈系统的分子。

```py
property sensitivity
```

返回反馈环路的灵敏度函数。

反馈系统的敏感性是开环增益变化与闭环增益变化的比率。

注意

此方法不会返回互补的敏感性函数。

例子

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> C = TransferFunction(5*p + 10, p + 10, p)
>>> P = TransferFunction(1 - p, p + 2, p)
>>> F_1 = Feedback(P, C)
>>> F_1.sensitivity
1/((1 - p)*(5*p + 10)/((p + 2)*(p + 10)) + 1) 
```

```py
property sign
```

返回MIMO反馈模型的类型。 `1`表示正反馈，`-1`表示负反馈。

```py
property sys1
```

返回反馈互联的前馈系统。

例子

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> controller = TransferFunction(5*s - 10, s + 7, s)
>>> F1 = Feedback(plant, controller)
>>> F1.sys1
TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)
>>> C = TransferFunction(5*p + 10, p + 10, p)
>>> P = TransferFunction(1 - s, p + 2, p)
>>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)
>>> F2.sys1
TransferFunction(1, 1, p) 
```

```py
property sys2
```

返回反馈互联的反馈控制器。

例子

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> controller = TransferFunction(5*s - 10, s + 7, s)
>>> F1 = Feedback(plant, controller)
>>> F1.sys2
TransferFunction(5*s - 10, s + 7, s)
>>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)
>>> C = TransferFunction(5*p + 10, p + 10, p)
>>> P = TransferFunction(1 - s, p + 2, p)
>>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)
>>> F2.sys2
Series(TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p), TransferFunction(5*p + 10, p + 10, p), TransferFunction(1 - s, p + 2, p)) 
```

```py
to_expr()
```

将`Feedback`对象转换为SymPy表达式。

例子

```py
>>> from sympy.abc import s, a, b
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> from sympy import Expr
>>> tf1 = TransferFunction(a+s, 1, s)
>>> tf2 = TransferFunction(b+s, 1, s)
>>> fd1 = Feedback(tf1, tf2)
>>> fd1.to_expr()
(a + s)/((a + s)*(b + s) + 1)
>>> isinstance(_, Expr)
True 
```

```py
property var
```

返回在反馈互联中涉及的所有传递函数使用的拉普拉斯变换的复变量。

例子

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction, Feedback
>>> plant = TransferFunction(3*s**2 + 7*s - 3, s**2 - 4*s + 2, s)
>>> controller = TransferFunction(5*s - 10, s + 7, s)
>>> F1 = Feedback(plant, controller)
>>> F1.var
s
>>> G = TransferFunction(2*s**2 + 5*s + 1, p**2 + 2*p + 3, p)
>>> C = TransferFunction(5*p + 10, p + 10, p)
>>> P = TransferFunction(1 - s, p + 2, p)
>>> F2 = Feedback(TransferFunction(1, 1, p), G*C*P)
>>> F2.var
p 
```

```py
class sympy.physics.control.lti.TransferFunctionMatrix(arg)
```

用于表示SISO（单输入单输出）传递函数的MIMO（多输入多输出）概括的类。

它是传递函数矩阵（`TransferFunction`，SISO-`Series`或SISO-`Parallel`）的矩阵。 只有一个参数，`arg`也是强制性参数。 期望`arg`严格为列表列表类型，其中包含传递函数或可化简为传递函数。

参数：

**arg**：嵌套的`List`（严格）。

> 用户预期输入`TransferFunction`，`Series`和/或`Parallel`对象的嵌套列表。

例子

注意

`pprint()`可用于更好地可视化`TransferFunctionMatrix`对象。

```py
>>> from sympy.abc import s, p, a
>>> from sympy import pprint
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, Series, Parallel
>>> tf_1 = TransferFunction(s + a, s**2 + s + 1, s)
>>> tf_2 = TransferFunction(p**4 - 3*p + 2, s + p, s)
>>> tf_3 = TransferFunction(3, s + 2, s)
>>> tf_4 = TransferFunction(-a + p, 9*s - 9, s)
>>> tfm_1 = TransferFunctionMatrix([[tf_1], [tf_2], [tf_3]])
>>> tfm_1
TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(3, s + 2, s),)))
>>> tfm_1.var
s
>>> tfm_1.num_inputs
1
>>> tfm_1.num_outputs
3
>>> tfm_1.shape
(3, 1)
>>> tfm_1.args
(((TransferFunction(a + s, s**2 + s + 1, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(3, s + 2, s),)),)
>>> tfm_2 = TransferFunctionMatrix([[tf_1, -tf_3], [tf_2, -tf_1], [tf_3, -tf_2]])
>>> tfm_2
TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s), TransferFunction(-3, s + 2, s)), (TransferFunction(p**4 - 3*p + 2, p + s, s), TransferFunction(-a - s, s**2 + s + 1, s)), (TransferFunction(3, s + 2, s), TransferFunction(-p**4 + 3*p - 2, p + s, s))))
>>> pprint(tfm_2, use_unicode=False)  # pretty-printing for better visualization
[   a + s           -3       ]
[ ----------       -----     ]
[  2               s + 2     ]
[ s  + s + 1                 ]
[                            ]
[ 4                          ]
[p  - 3*p + 2      -a - s    ]
[------------    ----------  ]
[   p + s         2          ]
[                s  + s + 1  ]
[                            ]
[                 4          ]
[     3        - p  + 3*p - 2]
[   -----      --------------]
[   s + 2          p + s     ]{t} 
```

如果用户希望切换输入和输出传递函数，可以对`TransferFunctionMatrix`进行转置。

```py
>>> tfm_2.transpose()
TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s), TransferFunction(p**4 - 3*p + 2, p + s, s), TransferFunction(3, s + 2, s)), (TransferFunction(-3, s + 2, s), TransferFunction(-a - s, s**2 + s + 1, s), TransferFunction(-p**4 + 3*p - 2, p + s, s))))
>>> pprint(_, use_unicode=False)
[             4                          ]
[  a + s     p  - 3*p + 2        3       ]
[----------  ------------      -----     ]
[ 2             p + s          s + 2     ]
[s  + s + 1                              ]
[                                        ]
[                             4          ]
[   -3          -a - s     - p  + 3*p - 2]
[  -----      ----------   --------------]
[  s + 2       2               p + s     ]
[             s  + s + 1                 ]{t} 
```

```py
>>> tf_5 = TransferFunction(5, s, s)
>>> tf_6 = TransferFunction(5*s, (2 + s**2), s)
>>> tf_7 = TransferFunction(5, (s*(2 + s**2)), s)
>>> tf_8 = TransferFunction(5, 1, s)
>>> tfm_3 = TransferFunctionMatrix([[tf_5, tf_6], [tf_7, tf_8]])
>>> tfm_3
TransferFunctionMatrix(((TransferFunction(5, s, s), TransferFunction(5*s, s**2 + 2, s)), (TransferFunction(5, s*(s**2 + 2), s), TransferFunction(5, 1, s))))
>>> pprint(tfm_3, use_unicode=False)
[    5        5*s  ]
[    -       ------]
[    s        2    ]
[            s  + 2]
[                  ]
[    5         5   ]
[----------    -   ]
[  / 2    \    1   ]
[s*\s  + 2/        ]{t}
>>> tfm_3.var
s
>>> tfm_3.shape
(2, 2)
>>> tfm_3.num_outputs
2
>>> tfm_3.num_inputs
2
>>> tfm_3.args
(((TransferFunction(5, s, s), TransferFunction(5*s, s**2 + 2, s)), (TransferFunction(5, s*(s**2 + 2), s), TransferFunction(5, 1, s))),) 
```

要访问`TransferFunctionMatrix`中任何索引处的`TransferFunction`，请使用索引表示法。

```py
>>> tfm_3[1, 0]  # gives the TransferFunction present at 2nd Row and 1st Col. Similar to that in Matrix classes
TransferFunction(5, s*(s**2 + 2), s)
>>> tfm_3[0, 0]  # gives the TransferFunction present at 1st Row and 1st Col.
TransferFunction(5, s, s)
>>> tfm_3[:, 0]  # gives the first column
TransferFunctionMatrix(((TransferFunction(5, s, s),), (TransferFunction(5, s*(s**2 + 2), s),)))
>>> pprint(_, use_unicode=False)
[    5     ]
[    -     ]
[    s     ]
[          ]
[    5     ]
[----------]
[  / 2    \]
[s*\s  + 2/]{t}
>>> tfm_3[0, :]  # gives the first row
TransferFunctionMatrix(((TransferFunction(5, s, s), TransferFunction(5*s, s**2 + 2, s)),))
>>> pprint(_, use_unicode=False)
[5   5*s  ]
[-  ------]
[s   2    ]
[   s  + 2]{t} 
```

要对传递函数矩阵取反，可以在其前面加上`-`运算符：

```py
>>> tfm_4 = TransferFunctionMatrix([[tf_2], [-tf_1], [tf_3]])
>>> -tfm_4
TransferFunctionMatrix(((TransferFunction(-p**4 + 3*p - 2, p + s, s),), (TransferFunction(a + s, s**2 + s + 1, s),), (TransferFunction(-3, s + 2, s),)))
>>> tfm_5 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, -tf_1]])
>>> -tfm_5
TransferFunctionMatrix(((TransferFunction(-a - s, s**2 + s + 1, s), TransferFunction(-p**4 + 3*p - 2, p + s, s)), (TransferFunction(-3, s + 2, s), TransferFunction(a + s, s**2 + s + 1, s)))) 
```

`subs()`返回替换为表达式中的值的`TransferFunctionMatrix`对象。 这不会改变您的原始`TransferFunctionMatrix`。

```py
>>> tfm_2.subs(p, 2)  #  substituting p everywhere in tfm_2 with 2.
TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s), TransferFunction(-3, s + 2, s)), (TransferFunction(12, s + 2, s), TransferFunction(-a - s, s**2 + s + 1, s)), (TransferFunction(3, s + 2, s), TransferFunction(-12, s + 2, s))))
>>> pprint(_, use_unicode=False)
[  a + s        -3     ]
[----------    -----   ]
[ 2            s + 2   ]
[s  + s + 1            ]
[                      ]
[    12        -a - s  ]
[  -----     ----------]
[  s + 2      2        ]
[            s  + s + 1]
[                      ]
[    3          -12    ]
[  -----       -----   ]
[  s + 2       s + 2   ]{t}
>>> pprint(tfm_2, use_unicode=False) # State of tfm_2 is unchanged after substitution
[   a + s           -3       ]
[ ----------       -----     ]
[  2               s + 2     ]
[ s  + s + 1                 ]
[                            ]
[ 4                          ]
[p  - 3*p + 2      -a - s    ]
[------------    ----------  ]
[   p + s         2          ]
[                s  + s + 1  ]
[                            ]
[                 4          ]
[     3        - p  + 3*p - 2]
[   -----      --------------]
[   s + 2          p + s     ]{t} 
```

`subs()`还支持多个替换。

```py
>>> tfm_2.subs({p: 2, a: 1})  # substituting p with 2 and a with 1
TransferFunctionMatrix(((TransferFunction(s + 1, s**2 + s + 1, s), TransferFunction(-3, s + 2, s)), (TransferFunction(12, s + 2, s), TransferFunction(-s - 1, s**2 + s + 1, s)), (TransferFunction(3, s + 2, s), TransferFunction(-12, s + 2, s))))
>>> pprint(_, use_unicode=False)
[  s + 1        -3     ]
[----------    -----   ]
[ 2            s + 2   ]
[s  + s + 1            ]
[                      ]
[    12        -s - 1  ]
[  -----     ----------]
[  s + 2      2        ]
[            s  + s + 1]
[                      ]
[    3          -12    ]
[  -----       -----   ]
[  s + 2       s + 2   ]{t} 
```

用户可以通过使用`doit()`将矩阵的`Series`和`Parallel`元素减少为`TransferFunction`。

```py
>>> tfm_6 = TransferFunctionMatrix([[Series(tf_3, tf_4), Parallel(tf_3, tf_4)]])
>>> tfm_6
TransferFunctionMatrix(((Series(TransferFunction(3, s + 2, s), TransferFunction(-a + p, 9*s - 9, s)), Parallel(TransferFunction(3, s + 2, s), TransferFunction(-a + p, 9*s - 9, s))),))
>>> pprint(tfm_6, use_unicode=False)
[-a + p    3    -a + p      3  ]
[-------*-----  ------- + -----]
[9*s - 9 s + 2  9*s - 9   s + 2]{t}
>>> tfm_6.doit()
TransferFunctionMatrix(((TransferFunction(-3*a + 3*p, (s + 2)*(9*s - 9), s), TransferFunction(27*s + (-a + p)*(s + 2) - 27, (s + 2)*(9*s - 9), s)),))
>>> pprint(_, use_unicode=False)
[    -3*a + 3*p     27*s + (-a + p)*(s + 2) - 27]
[-----------------  ----------------------------]
[(s + 2)*(9*s - 9)       (s + 2)*(9*s - 9)      ]{t}
>>> tf_9 = TransferFunction(1, s, s)
>>> tf_10 = TransferFunction(1, s**2, s)
>>> tfm_7 = TransferFunctionMatrix([[Series(tf_9, tf_10), tf_9], [tf_10, Parallel(tf_9, tf_10)]])
>>> tfm_7
TransferFunctionMatrix(((Series(TransferFunction(1, s, s), TransferFunction(1, s**2, s)), TransferFunction(1, s, s)), (TransferFunction(1, s**2, s), Parallel(TransferFunction(1, s, s), TransferFunction(1, s**2, s)))))
>>> pprint(tfm_7, use_unicode=False)
[ 1      1   ]
[----    -   ]
[   2    s   ]
[s*s         ]
[            ]
[ 1    1    1]
[ --   -- + -]
[  2    2   s]
[ s    s     ]{t}
>>> tfm_7.doit()
TransferFunctionMatrix(((TransferFunction(1, s**3, s), TransferFunction(1, s, s)), (TransferFunction(1, s**2, s), TransferFunction(s**2 + s, s**3, s))))
>>> pprint(_, use_unicode=False)
[1     1   ]
[--    -   ]
[ 3    s   ]
[s         ]
[          ]
[     2    ]
[1   s  + s]
[--  ------]
[ 2     3  ]
[s     s   ]{t} 
```

传递函数矩阵的加法、减法和乘法可以形成未评估的`Series`或`Parallel`对象。

+   对于加法和减法：所有传递函数矩阵必须具有相同的形状。

+   对于乘法（C = A * B）：第一个传递函数矩阵（A）的输入数量必须等于第二个传递函数矩阵（B）的输出数量。

还有，使用漂亮打印（`pprint`）来进行更好的分析。

```py
>>> tfm_8 = TransferFunctionMatrix([[tf_3], [tf_2], [-tf_1]])
>>> tfm_9 = TransferFunctionMatrix([[-tf_3]])
>>> tfm_10 = TransferFunctionMatrix([[tf_1], [tf_2], [tf_4]])
>>> tfm_11 = TransferFunctionMatrix([[tf_4], [-tf_1]])
>>> tfm_12 = TransferFunctionMatrix([[tf_4, -tf_1, tf_3], [-tf_2, -tf_4, -tf_3]])
>>> tfm_8 + tfm_10
MIMOParallel(TransferFunctionMatrix(((TransferFunction(3, s + 2, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a - s, s**2 + s + 1, s),))), TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a + p, 9*s - 9, s),))))
>>> pprint(_, use_unicode=False)
[     3      ]      [   a + s    ]
[   -----    ]      [ ---------- ]
[   s + 2    ]      [  2         ]
[            ]      [ s  + s + 1 ]
[ 4          ]      [            ]
[p  - 3*p + 2]      [ 4          ]
[------------]    + [p  - 3*p + 2]
[   p + s    ]      [------------]
[            ]      [   p + s    ]
[   -a - s   ]      [            ]
[ ---------- ]      [   -a + p   ]
[  2         ]      [  -------   ]
[ s  + s + 1 ]{t}   [  9*s - 9   ]{t}
>>> -tfm_10 - tfm_8
MIMOParallel(TransferFunctionMatrix(((TransferFunction(-a - s, s**2 + s + 1, s),), (TransferFunction(-p**4 + 3*p - 2, p + s, s),), (TransferFunction(a - p, 9*s - 9, s),))), TransferFunctionMatrix(((TransferFunction(-3, s + 2, s),), (TransferFunction(-p**4 + 3*p - 2, p + s, s),), (TransferFunction(a + s, s**2 + s + 1, s),))))
>>> pprint(_, use_unicode=False)
[    -a - s    ]      [     -3       ]
[  ----------  ]      [    -----     ]
[   2          ]      [    s + 2     ]
[  s  + s + 1  ]      [              ]
[              ]      [   4          ]
[   4          ]      [- p  + 3*p - 2]
[- p  + 3*p - 2]    + [--------------]
[--------------]      [    p + s     ]
[    p + s     ]      [              ]
[              ]      [    a + s     ]
[    a - p     ]      [  ----------  ]
[   -------    ]      [   2          ]
[   9*s - 9    ]{t}   [  s  + s + 1  ]{t}
>>> tfm_12 * tfm_8
MIMOSeries(TransferFunctionMatrix(((TransferFunction(3, s + 2, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a - s, s**2 + s + 1, s),))), TransferFunctionMatrix(((TransferFunction(-a + p, 9*s - 9, s), TransferFunction(-a - s, s**2 + s + 1, s), TransferFunction(3, s + 2, s)), (TransferFunction(-p**4 + 3*p - 2, p + s, s), TransferFunction(a - p, 9*s - 9, s), TransferFunction(-3, s + 2, s)))))
>>> pprint(_, use_unicode=False)
 [     3      ]
 [   -----    ]
[    -a + p        -a - s      3  ]    [   s + 2    ]
[   -------      ----------  -----]    [            ]
[   9*s - 9       2          s + 2]    [ 4          ]
[                s  + s + 1       ]    [p  - 3*p + 2]
[                                 ]   *[------------]
[   4                             ]    [   p + s    ]
[- p  + 3*p - 2    a - p      -3  ]    [            ]
[--------------   -------    -----]    [   -a - s   ]
[    p + s        9*s - 9    s + 2]{t} [ ---------- ]
 [  2         ]
 [ s  + s + 1 ]{t}
>>> tfm_12 * tfm_8 * tfm_9
MIMOSeries(TransferFunctionMatrix(((TransferFunction(-3, s + 2, s),),)), TransferFunctionMatrix(((TransferFunction(3, s + 2, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a - s, s**2 + s + 1, s),))), TransferFunctionMatrix(((TransferFunction(-a + p, 9*s - 9, s), TransferFunction(-a - s, s**2 + s + 1, s), TransferFunction(3, s + 2, s)), (TransferFunction(-p**4 + 3*p - 2, p + s, s), TransferFunction(a - p, 9*s - 9, s), TransferFunction(-3, s + 2, s)))))
>>> pprint(_, use_unicode=False)
 [     3      ]
 [   -----    ]
[    -a + p        -a - s      3  ]    [   s + 2    ]
[   -------      ----------  -----]    [            ]
[   9*s - 9       2          s + 2]    [ 4          ]
[                s  + s + 1       ]    [p  - 3*p + 2]    [ -3  ]
[                                 ]   *[------------]   *[-----]
[   4                             ]    [   p + s    ]    [s + 2]{t}
[- p  + 3*p - 2    a - p      -3  ]    [            ]
[--------------   -------    -----]    [   -a - s   ]
[    p + s        9*s - 9    s + 2]{t} [ ---------- ]
 [  2         ]
 [ s  + s + 1 ]{t}
>>> tfm_10 + tfm_8*tfm_9
MIMOParallel(TransferFunctionMatrix(((TransferFunction(a + s, s**2 + s + 1, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a + p, 9*s - 9, s),))), MIMOSeries(TransferFunctionMatrix(((TransferFunction(-3, s + 2, s),),)), TransferFunctionMatrix(((TransferFunction(3, s + 2, s),), (TransferFunction(p**4 - 3*p + 2, p + s, s),), (TransferFunction(-a - s, s**2 + s + 1, s),)))))
>>> pprint(_, use_unicode=False)
[   a + s    ]      [     3      ]
[ ---------- ]      [   -----    ]
[  2         ]      [   s + 2    ]
[ s  + s + 1 ]      [            ]
[            ]      [ 4          ]
[ 4          ]      [p  - 3*p + 2]    [ -3  ]
[p  - 3*p + 2]    + [------------]   *[-----]
[------------]      [   p + s    ]    [s + 2]{t}
[   p + s    ]      [            ]
[            ]      [   -a - s   ]
[   -a + p   ]      [ ---------- ]
[  -------   ]      [  2         ]
[  9*s - 9   ]{t}   [ s  + s + 1 ]{t} 
```

这些未评估的`Series`或`Parallel`对象可以通过`.doit()`方法或`.rewrite(TransferFunctionMatrix)`转换为结果传递函数矩阵。

```py
>>> (-tfm_8 + tfm_10 + tfm_8*tfm_9).doit()
TransferFunctionMatrix(((TransferFunction((a + s)*(s + 2)**3 - 3*(s + 2)**2*(s**2 + s + 1) - 9*(s + 2)*(s**2 + s + 1), (s + 2)**3*(s**2 + s + 1), s),), (TransferFunction((p + s)*(-3*p**4 + 9*p - 6), (p + s)**2*(s + 2), s),), (TransferFunction((-a + p)*(s + 2)*(s**2 + s + 1)**2 + (a + s)*(s + 2)*(9*s - 9)*(s**2 + s + 1) + (3*a + 3*s)*(9*s - 9)*(s**2 + s + 1), (s + 2)*(9*s - 9)*(s**2 + s + 1)**2, s),)))
>>> (-tfm_12 * -tfm_8 * -tfm_9).rewrite(TransferFunctionMatrix)
TransferFunctionMatrix(((TransferFunction(3*(-3*a + 3*p)*(p + s)*(s + 2)*(s**2 + s + 1)**2 + 3*(-3*a - 3*s)*(p + s)*(s + 2)*(9*s - 9)*(s**2 + s + 1) + 3*(a + s)*(s + 2)**2*(9*s - 9)*(-p**4 + 3*p - 2)*(s**2 + s + 1), (p + s)*(s + 2)**3*(9*s - 9)*(s**2 + s + 1)**2, s),), (TransferFunction(3*(-a + p)*(p + s)*(s + 2)**2*(-p**4 + 3*p - 2)*(s**2 + s + 1) + 3*(3*a + 3*s)*(p + s)**2*(s + 2)*(9*s - 9) + 3*(p + s)*(s + 2)*(9*s - 9)*(-3*p**4 + 9*p - 6)*(s**2 + s + 1), (p + s)**2*(s + 2)**3*(9*s - 9)*(s**2 + s + 1), s),))) 
```

另请参见

[`TransferFunction`](#sympy.physics.control.lti.TransferFunction "sympy.physics.control.lti.TransferFunction")，[`MIMOSeries`](#sympy.physics.control.lti.MIMOSeries "sympy.physics.control.lti.MIMOSeries")，[`MIMOParallel`](#sympy.physics.control.lti.MIMOParallel "sympy.physics.control.lti.MIMOParallel")，[`Feedback`](#sympy.physics.control.lti.Feedback "sympy.physics.control.lti.Feedback")

```py
elem_poles()
```

返回每个`TransferFunctionMatrix`元素的极点。

注意

MIMO系统的实际极点不是各个元素的极点。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
>>> tf_1 = TransferFunction(3, (s + 1), s)
>>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)
>>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)
>>> tf_4 = TransferFunction(s + 2, s**2 + 5*s - 10, s)
>>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])
>>> tfm_1
TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s + 2, s**2 + 5*s - 10, s))))
>>> tfm_1.elem_poles()
[[[-1], [-2, -1]], [[-2, -1], [-5/2 + sqrt(65)/2, -sqrt(65)/2 - 5/2]]] 
```

参见

[`elem_zeros`](#sympy.physics.control.lti.TransferFunctionMatrix.elem_zeros "sympy.physics.control.lti.TransferFunctionMatrix.elem_zeros")

```py
elem_zeros()
```

返回`TransferFunctionMatrix`的每个元素的零点。

注意

MIMO系统的实际零点不是各个元素的零点。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
>>> tf_1 = TransferFunction(3, (s + 1), s)
>>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)
>>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)
>>> tf_4 = TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s)
>>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])
>>> tfm_1
TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s))))
>>> tfm_1.elem_zeros()
[[[], [-6]], [[-3], [4, 5]]] 
```

参见

[`elem_poles`](#sympy.physics.control.lti.TransferFunctionMatrix.elem_poles "sympy.physics.control.lti.TransferFunctionMatrix.elem_poles")

```py
eval_frequency(other)
```

在实数或复数平面的任意点评估`TransferFunctionMatrix`中每个传输函数的系统响应。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
>>> from sympy import I
>>> tf_1 = TransferFunction(3, (s + 1), s)
>>> tf_2 = TransferFunction(s + 6, (s + 1)*(s + 2), s)
>>> tf_3 = TransferFunction(s + 3, s**2 + 3*s + 2, s)
>>> tf_4 = TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s)
>>> tfm_1 = TransferFunctionMatrix([[tf_1, tf_2], [tf_3, tf_4]])
>>> tfm_1
TransferFunctionMatrix(((TransferFunction(3, s + 1, s), TransferFunction(s + 6, (s + 1)*(s + 2), s)), (TransferFunction(s + 3, s**2 + 3*s + 2, s), TransferFunction(s**2 - 9*s + 20, s**2 + 5*s - 10, s))))
>>> tfm_1.eval_frequency(2)
Matrix([
[   1, 2/3],
[5/12, 3/2]])
>>> tfm_1.eval_frequency(I*2)
Matrix([
[   3/5 - 6*I/5,                -I],
[3/20 - 11*I/20, -101/74 + 23*I/74]]) 
```

```py
expand(**hints)
```

扩展传输函数矩阵

```py
classmethod from_Matrix(matrix, var)
```

有效地从SymPy矩阵的`Expr`对象创建新的`TransferFunctionMatrix`。

参数：

**matrix**：具有`Expr`/`Number`元素的`ImmutableMatrix`。

**var**：符号

> 拉普拉斯变换的复变量，将被`TransferFunctionMatrix`中所有`TransferFunction`对象使用。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunctionMatrix
>>> from sympy import Matrix, pprint
>>> M = Matrix([[s, 1/s], [1/(s+1), s]])
>>> M_tf = TransferFunctionMatrix.from_Matrix(M, s)
>>> pprint(M_tf, use_unicode=False)
[  s    1]
[  -    -]
[  1    s]
[        ]
[  1    s]
[-----  -]
[s + 1  1]{t}
>>> M_tf.elem_poles()
[[[], [0]], [[-1], []]]
>>> M_tf.elem_zeros()
[[[0], []], [[], [0]]] 
```

```py
property num_inputs
```

返回系统的输入数量。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
>>> G1 = TransferFunction(s + 3, s**2 - 3, s)
>>> G2 = TransferFunction(4, s**2, s)
>>> G3 = TransferFunction(p**2 + s**2, p - 3, s)
>>> tfm_1 = TransferFunctionMatrix([[G2, -G1, G3], [-G2, -G1, -G3]])
>>> tfm_1.num_inputs
3 
```

参见

[`num_outputs`](#sympy.physics.control.lti.TransferFunctionMatrix.num_outputs "sympy.physics.control.lti.TransferFunctionMatrix.num_outputs")

```py
property num_outputs
```

返回系统输出的数量。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunctionMatrix
>>> from sympy import Matrix
>>> M_1 = Matrix([[s], [1/s]])
>>> TFM = TransferFunctionMatrix.from_Matrix(M_1, s)
>>> print(TFM)
TransferFunctionMatrix(((TransferFunction(s, 1, s),), (TransferFunction(1, s, s),)))
>>> TFM.num_outputs
2 
```

参见

[`num_inputs`](#sympy.physics.control.lti.TransferFunctionMatrix.num_inputs "sympy.physics.control.lti.TransferFunctionMatrix.num_inputs")

```py
property shape
```

返回传输函数矩阵的形状，即`(# of outputs, # of inputs)`。

示例

```py
>>> from sympy.abc import s, p
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix
>>> tf1 = TransferFunction(p**2 - 1, s**4 + s**3 - p, p)
>>> tf2 = TransferFunction(1 - p, p**2 - 3*p + 7, p)
>>> tf3 = TransferFunction(3, 4, p)
>>> tfm1 = TransferFunctionMatrix([[tf1, -tf2]])
>>> tfm1.shape
(1, 2)
>>> tfm2 = TransferFunctionMatrix([[-tf2, tf3], [tf1, -tf1]])
>>> tfm2.shape
(2, 2) 
```

```py
transpose()
```

返回`TransferFunctionMatrix`的转置（交换输入和输出层）。

```py
property var
```

返回所有传输函数或`Series`/`Parallel`对象中使用的复变量。

示例

```py
>>> from sympy.abc import p, s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, Series, Parallel
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G2 = TransferFunction(p, 4 - p, p)
>>> G3 = TransferFunction(0, p**4 - 1, p)
>>> G4 = TransferFunction(s + 1, s**2 + s + 1, s)
>>> S1 = Series(G1, G2)
>>> S2 = Series(-G3, Parallel(G2, -G1))
>>> tfm1 = TransferFunctionMatrix([[G1], [G2], [G3]])
>>> tfm1.var
p
>>> tfm2 = TransferFunctionMatrix([[-S1, -S2], [S1, S2]])
>>> tfm2.var
p
>>> tfm3 = TransferFunctionMatrix([[G4]])
>>> tfm3.var
s 
```

```py
class sympy.physics.control.lti.MIMOSeries(*args, evaluate=False)
```

用于表示MIMO系统串联配置的类。

参数：

**args**：MIMOLinearTimeInvariant

> MIMO系统处于串联配置。

**evaluate**：布尔值，关键字

> 当传递`True`时，返回等效的`MIMOSeries(*args).doit()`。默认设置为`False`。

引发：

**ValueError**

> 当不传递任何参数时。
> 
> 对于每个系统，`var`属性并不相同。
> 
> MIMO系统的`num_outputs`不等于其相邻MIMO系统的`num_inputs`。（基本上是矩阵乘法约束）

**TypeError**

> 任何传递的`*args`具有不支持的类型
> 
> 将SISO和MIMO系统的组合传递。在传递的系统类型中应保持同质性，本例中是MIMO系统。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import MIMOSeries, TransferFunctionMatrix
>>> from sympy import Matrix, pprint
>>> mat_a = Matrix([[5*s], [5]])  # 2 Outputs 1 Input
>>> mat_b = Matrix([[5, 1/(6*s**2)]])  # 1 Output 2 Inputs
>>> mat_c = Matrix([[1, s], [5/s, 1]])  # 2 Outputs 2 Inputs
>>> tfm_a = TransferFunctionMatrix.from_Matrix(mat_a, s)
>>> tfm_b = TransferFunctionMatrix.from_Matrix(mat_b, s)
>>> tfm_c = TransferFunctionMatrix.from_Matrix(mat_c, s)
>>> MIMOSeries(tfm_c, tfm_b, tfm_a)
MIMOSeries(TransferFunctionMatrix(((TransferFunction(1, 1, s), TransferFunction(s, 1, s)), (TransferFunction(5, s, s), TransferFunction(1, 1, s)))), TransferFunctionMatrix(((TransferFunction(5, 1, s), TransferFunction(1, 6*s**2, s)),)), TransferFunctionMatrix(((TransferFunction(5*s, 1, s),), (TransferFunction(5, 1, s),))))
>>> pprint(_, use_unicode=False)  #  For Better Visualization
[5*s]                 [1  s]
[---]    [5   1  ]    [-  -]
[ 1 ]    [-  ----]    [1  1]
[   ]   *[1     2]   *[    ]
[ 5 ]    [   6*s ]{t} [5  1]
[ - ]                 [-  -]
[ 1 ]{t}              [s  1]{t}
>>> MIMOSeries(tfm_c, tfm_b, tfm_a).doit()
TransferFunctionMatrix(((TransferFunction(150*s**4 + 25*s, 6*s**3, s), TransferFunction(150*s**4 + 5*s, 6*s**2, s)), (TransferFunction(150*s**3 + 25, 6*s**3, s), TransferFunction(150*s**3 + 5, 6*s**2, s))))
>>> pprint(_, use_unicode=False)  # (2 Inputs -A-> 2 Outputs) -> (2 Inputs -B-> 1 Output) -> (1 Input -C-> 2 Outputs) is equivalent to (2 Inputs -Series Equivalent-> 2 Outputs).
[     4              4      ]
[150*s  + 25*s  150*s  + 5*s]
[-------------  ------------]
[        3             2    ]
[     6*s           6*s     ]
[                           ]
[      3              3     ]
[ 150*s  + 25    150*s  + 5 ]
[ -----------    ---------- ]
[        3             2    ]
[     6*s           6*s     ]{t} 
```

注意

所有传输函数矩阵应使用拉普拉斯变换的相同复变量`var`。

`MIMOSeries(A, B)`与`A*B`不等同。它总是以相反的顺序，即`B*A`。

参见

[`Series`](#sympy.physics.control.lti.Series "sympy.physics.control.lti.Series"), [`MIMOParallel`](#sympy.physics.control.lti.MIMOParallel "sympy.physics.control.lti.MIMOParallel")

```py
doit(cancel=False, **kwargs)
```

返回在串联配置的 MIMO 系统评估后获得的结果传递函数矩阵。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, MIMOSeries, TransferFunctionMatrix
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tfm1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf2]])
>>> tfm2 = TransferFunctionMatrix([[tf2, tf1], [tf1, tf1]])
>>> MIMOSeries(tfm2, tfm1).doit()
TransferFunctionMatrix(((TransferFunction(2*(-p + s)*(s**3 - 2)*(a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)**2*(s**4 + 5*s + 6)**2, s), TransferFunction((-p + s)**2*(s**3 - 2)*(a*p**2 + b*s) + (-p + s)*(a*p**2 + b*s)**2*(s**4 + 5*s + 6), (-p + s)**3*(s**4 + 5*s + 6), s)), (TransferFunction((-p + s)*(s**3 - 2)**2*(s**4 + 5*s + 6) + (s**3 - 2)*(a*p**2 + b*s)*(s**4 + 5*s + 6)**2, (-p + s)*(s**4 + 5*s + 6)**3, s), TransferFunction(2*(s**3 - 2)*(a*p**2 + b*s), (-p + s)*(s**4 + 5*s + 6), s)))) 
```

```py
property num_inputs
```

返回串联系统的输入信号数量。

```py
property num_outputs
```

返回串联系统的输出信号数量。

```py
property shape
```

返回等效 MIMO 系统的形状。

```py
property var
```

返回所有传递函数使用的复变量。

示例

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, MIMOSeries, TransferFunctionMatrix
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G2 = TransferFunction(p, 4 - p, p)
>>> G3 = TransferFunction(0, p**4 - 1, p)
>>> tfm_1 = TransferFunctionMatrix([[G1, G2, G3]])
>>> tfm_2 = TransferFunctionMatrix([[G1], [G2], [G3]])
>>> MIMOSeries(tfm_2, tfm_1).var
p 
```

```py
class sympy.physics.control.lti.MIMOParallel(*args, evaluate=False)
```

表示并联配置的 MIMO 系统的类。

参数:

**args**：MIMOLinearTimeInvariant

> 并联配置的 MIMO 系统。

**evaluate**：布尔值，关键字

> 当传递`True`时，返回等效的`MIMOParallel(*args).doit()`。默认为`False`。

Raises:

**数值错误**

> 当未传递参数时。
> 
> `var`属性在每个系统中不相同。
> 
> 所有传递的 MIMO 系统形状不同。

**类型错误**

> 传递的任何`*args`类型都不受支持。
> 
> 传递了一组 SISO 和 MIMO 系统。在这种情况下，传递的系统类型应该是同质的，即 MIMO。

示例

```py
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunctionMatrix, MIMOParallel
>>> from sympy import Matrix, pprint
>>> expr_1 = 1/s
>>> expr_2 = s/(s**2-1)
>>> expr_3 = (2 + s)/(s**2 - 1)
>>> expr_4 = 5
>>> tfm_a = TransferFunctionMatrix.from_Matrix(Matrix([[expr_1, expr_2], [expr_3, expr_4]]), s)
>>> tfm_b = TransferFunctionMatrix.from_Matrix(Matrix([[expr_2, expr_1], [expr_4, expr_3]]), s)
>>> tfm_c = TransferFunctionMatrix.from_Matrix(Matrix([[expr_3, expr_4], [expr_1, expr_2]]), s)
>>> MIMOParallel(tfm_a, tfm_b, tfm_c)
MIMOParallel(TransferFunctionMatrix(((TransferFunction(1, s, s), TransferFunction(s, s**2 - 1, s)), (TransferFunction(s + 2, s**2 - 1, s), TransferFunction(5, 1, s)))), TransferFunctionMatrix(((TransferFunction(s, s**2 - 1, s), TransferFunction(1, s, s)), (TransferFunction(5, 1, s), TransferFunction(s + 2, s**2 - 1, s)))), TransferFunctionMatrix(((TransferFunction(s + 2, s**2 - 1, s), TransferFunction(5, 1, s)), (TransferFunction(1, s, s), TransferFunction(s, s**2 - 1, s)))))
>>> pprint(_, use_unicode=False)  #  For Better Visualization
[  1       s   ]      [  s       1   ]      [s + 2     5   ]
[  -     ------]      [------    -   ]      [------    -   ]
[  s      2    ]      [ 2        s   ]      [ 2        1   ]
[        s  - 1]      [s  - 1        ]      [s  - 1        ]
[              ]    + [              ]    + [              ]
[s + 2     5   ]      [  5     s + 2 ]      [  1       s   ]
[------    -   ]      [  -     ------]      [  -     ------]
[ 2        1   ]      [  1      2    ]      [  s      2    ]
[s  - 1        ]{t}   [        s  - 1]{t}   [        s  - 1]{t}
>>> MIMOParallel(tfm_a, tfm_b, tfm_c).doit()
TransferFunctionMatrix(((TransferFunction(s**2 + s*(2*s + 2) - 1, s*(s**2 - 1), s), TransferFunction(2*s**2 + 5*s*(s**2 - 1) - 1, s*(s**2 - 1), s)), (TransferFunction(s**2 + s*(s + 2) + 5*s*(s**2 - 1) - 1, s*(s**2 - 1), s), TransferFunction(5*s**2 + 2*s - 3, s**2 - 1, s))))
>>> pprint(_, use_unicode=False)
[       2                              2       / 2    \    ]
[      s  + s*(2*s + 2) - 1         2*s  + 5*s*\s  - 1/ - 1]
[      --------------------         -----------------------]
[             / 2    \                       / 2    \      ]
[           s*\s  - 1/                     s*\s  - 1/      ]
[                                                          ]
[ 2                   / 2    \             2               ]
[s  + s*(s + 2) + 5*s*\s  - 1/ - 1      5*s  + 2*s - 3     ]
[---------------------------------      --------------     ]
[              / 2    \                      2             ]
[            s*\s  - 1/                     s  - 1         ]{t} 
```

注释

所有传递函数矩阵应使用拉普拉斯变换的相同复变量`var`。

另请参阅

[`Parallel`](#sympy.physics.control.lti.Parallel "sympy.physics.control.lti.Parallel"), [`MIMOSeries`](#sympy.physics.control.lti.MIMOSeries "sympy.physics.control.lti.MIMOSeries")

```py
doit(**hints)
```

返回在并联配置的 MIMO 系统评估后获得的结果传递函数矩阵。

示例

```py
>>> from sympy.abc import s, p, a, b
>>> from sympy.physics.control.lti import TransferFunction, MIMOParallel, TransferFunctionMatrix
>>> tf1 = TransferFunction(a*p**2 + b*s, s - p, s)
>>> tf2 = TransferFunction(s**3 - 2, s**4 + 5*s + 6, s)
>>> tfm_1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])
>>> tfm_2 = TransferFunctionMatrix([[tf2, tf1], [tf1, tf2]])
>>> MIMOParallel(tfm_1, tfm_2).doit()
TransferFunctionMatrix(((TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s), TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)), (TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s), TransferFunction((-p + s)*(s**3 - 2) + (a*p**2 + b*s)*(s**4 + 5*s + 6), (-p + s)*(s**4 + 5*s + 6), s)))) 
```

```py
property num_inputs
```

返回并联系统的输入信号数量。

```py
property num_outputs
```

返回并行系统的输出信号数量。

```py
property shape
```

返回等效 MIMO 系统的形状。

```py
property var
```

返回所有系统使用的复变量。

示例

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOParallel
>>> G1 = TransferFunction(p**2 + 2*p + 4, p - 6, p)
>>> G2 = TransferFunction(p, 4 - p, p)
>>> G3 = TransferFunction(0, p**4 - 1, p)
>>> G4 = TransferFunction(p**2, p**2 - 1, p)
>>> tfm_a = TransferFunctionMatrix([[G1, G2], [G3, G4]])
>>> tfm_b = TransferFunctionMatrix([[G2, G1], [G4, G3]])
>>> MIMOParallel(tfm_a, tfm_b).var
p 
```

```py
class sympy.physics.control.lti.MIMOFeedback(sys1, sys2, sign=-1)
```

表示两个 MIMO 输入/输出系统之间闭环反馈连接的类。

参数:

**sys1**：MIMOSeries，TransferFunctionMatrix

> 将 MIMO 系统放置在前馈路径上。

**sys2**：MIMOSeries，TransferFunctionMatrix

> 放置在反馈路径上的系统（通常是反馈控制器）。

**符号**：整数，可选

> 反馈的符号。可以是`1`（正反馈）或`-1`（负反馈）。默认值为\(-1\)。

Raises:

**数值错误**

> 当`sys1`和`sys2`没有使用拉普拉斯变换的相同复变量时。
> 
> 前向路径模型应具有与反馈路径输出/输入相等数量的输入/输出。
> 
> 当`sys1`和`sys2`的乘积不是方阵时。
> 
> 当等效 MIMO 系统不可逆时。

**类型错误**

> 当`sys1`或`sys2`不是`MIMOSeries`或`TransferFunctionMatrix`对象时。

示例

```py
>>> from sympy import Matrix, pprint
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunctionMatrix, MIMOFeedback
>>> plant_mat = Matrix([[1, 1/s], [0, 1]])
>>> controller_mat = Matrix([[10, 0], [0, 10]])  # Constant Gain
>>> plant = TransferFunctionMatrix.from_Matrix(plant_mat, s)
>>> controller = TransferFunctionMatrix.from_Matrix(controller_mat, s)
>>> feedback = MIMOFeedback(plant, controller)  # Negative Feedback (default)
>>> pprint(feedback, use_unicode=False)
/    [1  1]    [10  0 ]   \-1   [1  1]
|    [-  -]    [--  - ]   |     [-  -]
|    [1  s]    [1   1 ]   |     [1  s]
|I + [    ]   *[      ]   |   * [    ]
|    [0  1]    [0   10]   |     [0  1]
|    [-  -]    [-   --]   |     [-  -]
\    [1  1]{t} [1   1 ]{t}/     [1  1]{t} 
```

要获取等效系统矩阵，请使用`doit`或`rewrite`方法。

```py
>>> pprint(feedback.doit(), use_unicode=False)
[1     1  ]
[--  -----]
[11  121*s]
[         ]
[0    1   ]
[-    --  ]
[1    11  ]{t} 
```

要否定`MIMOFeedback`对象，请使用`-`运算符。

```py
>>> neg_feedback = -feedback
>>> pprint(neg_feedback.doit(), use_unicode=False)
[-1    -1  ]
[---  -----]
[11   121*s]
[          ]
[ 0    -1  ]
[ -    --- ]
[ 1    11  ]{t} 
```

另请参阅

[`Feedback`](#sympy.physics.control.lti.Feedback "sympy.physics.control.lti.Feedback"), [`MIMOSeries`](#sympy.physics.control.lti.MIMOSeries "sympy.physics.control.lti.MIMOSeries"), [`MIMOParallel`](#sympy.physics.control.lti.MIMOParallel "sympy.physics.control.lti.MIMOParallel")

```py
doit(cancel=True, expand=False, **hints)
```

返回通过反馈互连获得的结果传递函数矩阵。

示例

```py
>>> from sympy import pprint
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback
>>> tf1 = TransferFunction(s, 1 - s, s)
>>> tf2 = TransferFunction(1, s, s)
>>> tf3 = TransferFunction(5, 1, s)
>>> tf4 = TransferFunction(s - 1, s, s)
>>> tf5 = TransferFunction(0, 1, s)
>>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf3, tf4]])
>>> sys2 = TransferFunctionMatrix([[tf3, tf5], [tf5, tf5]])
>>> F_1 = MIMOFeedback(sys1, sys2, 1)
>>> pprint(F_1, use_unicode=False)
/    [  s      1  ]    [5  0]   \-1   [  s      1  ]
|    [-----    -  ]    [-  -]   |     [-----    -  ]
|    [1 - s    s  ]    [1  1]   |     [1 - s    s  ]
|I - [            ]   *[    ]   |   * [            ]
|    [  5    s - 1]    [0  0]   |     [  5    s - 1]
|    [  -    -----]    [-  -]   |     [  -    -----]
\    [  1      s  ]{t} [1  1]{t}/     [  1      s  ]{t}
>>> pprint(F_1.doit(), use_unicode=False)
[  -s           s - 1       ]
[-------     -----------    ]
[6*s - 1     s*(6*s - 1)    ]
[                           ]
[5*s - 5  (s - 1)*(6*s + 24)]
[-------  ------------------]
[6*s - 1     s*(6*s - 1)    ]{t} 
```

如果用户希望获得结果的`TransferFunctionMatrix`对象而不取消公共因子，则应将`cancel`参数传递为`False`。

```py
>>> pprint(F_1.doit(cancel=False), use_unicode=False)
[             s*(s - 1)                              s - 1               ]
[         -----------------                       -----------            ]
[         (1 - s)*(6*s - 1)                       s*(6*s - 1)            ]
[                                                                        ]
[s*(25*s - 25) + 5*(1 - s)*(6*s - 1)  s*(s - 1)*(6*s - 1) + s*(25*s - 25)]
[-----------------------------------  -----------------------------------]
[         (1 - s)*(6*s - 1)                        2                     ]
[                                                 s *(6*s - 1)           ]{t} 
```

如果用户希望获得结果传递函数矩阵的展开形式，则应将`expand`参数传递为`True`。

```py
>>> pprint(F_1.doit(expand=True), use_unicode=False)
[  -s          s - 1      ]
[-------      --------    ]
[6*s - 1         2        ]
[             6*s  - s    ]
[                         ]
[            2            ]
[5*s - 5  6*s  + 18*s - 24]
[-------  ----------------]
[6*s - 1         2        ]
[             6*s  - s    ]{t} 
```

```py
property sensitivity
```

返回反馈环路的灵敏度函数矩阵。

闭环系统的灵敏度是指开环增益变化与闭环增益变化的比率。

注意

此方法不会返回互补灵敏度函数。

示例

```py
>>> from sympy import pprint
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback
>>> tf1 = TransferFunction(p, 1 - p, p)
>>> tf2 = TransferFunction(1, p, p)
>>> tf3 = TransferFunction(1, 1, p)
>>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])
>>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])
>>> F_1 = MIMOFeedback(sys1, sys2, 1)  # Positive feedback
>>> F_2 = MIMOFeedback(sys1, sys2)  # Negative feedback
>>> pprint(F_1.sensitivity, use_unicode=False)
[   4      3      2               5      4      2           ]
[- p  + 3*p  - 4*p  + 3*p - 1    p  - 2*p  + 3*p  - 3*p + 1 ]
[----------------------------  -----------------------------]
[  4      3      2              5      4      3      2      ]
[ p  + 3*p  - 8*p  + 8*p - 3   p  + 3*p  - 8*p  + 8*p  - 3*p]
[                                                           ]
[       4    3    2                  3      2               ]
[      p  - p  - p  + p           3*p  - 6*p  + 4*p - 1     ]
[ --------------------------    --------------------------  ]
[  4      3      2               4      3      2            ]
[ p  + 3*p  - 8*p  + 8*p - 3    p  + 3*p  - 8*p  + 8*p - 3  ]
>>> pprint(F_2.sensitivity, use_unicode=False)
[ 4      3      2           5      4      2          ]
[p  - 3*p  + 2*p  + p - 1  p  - 2*p  + 3*p  - 3*p + 1]
[------------------------  --------------------------]
[   4      3                   5      4      2       ]
[  p  - 3*p  + 2*p - 1        p  - 3*p  + 2*p  - p   ]
[                                                    ]
[     4    3    2               4      3             ]
[    p  - p  - p  + p        2*p  - 3*p  + 2*p - 1   ]
[  -------------------       ---------------------   ]
[   4      3                   4      3              ]
[  p  - 3*p  + 2*p - 1        p  - 3*p  + 2*p - 1    ] 
```

```py
property sign
```

返回两个模型的反馈互连类型。正反馈返回`1`，负反馈返回`-1`。

```py
property sys1
```

返回放置在MIMO反馈互连的前馈路径上的系统。

示例

```py
>>> from sympy import pprint
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback
>>> tf1 = TransferFunction(s**2 + s + 1, s**2 - s + 1, s)
>>> tf2 = TransferFunction(1, s, s)
>>> tf3 = TransferFunction(1, 1, s)
>>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])
>>> sys2 = TransferFunctionMatrix([[tf3, tf3], [tf3, tf2]])
>>> F_1 = MIMOFeedback(sys1, sys2, 1)
>>> F_1.sys1
TransferFunctionMatrix(((TransferFunction(s**2 + s + 1, s**2 - s + 1, s), TransferFunction(1, s, s)), (TransferFunction(1, s, s), TransferFunction(s**2 + s + 1, s**2 - s + 1, s))))
>>> pprint(_, use_unicode=False)
[ 2                    ]
[s  + s + 1      1     ]
[----------      -     ]
[ 2              s     ]
[s  - s + 1            ]
[                      ]
[             2        ]
[    1       s  + s + 1]
[    -       ----------]
[    s        2        ]
[            s  - s + 1]{t} 
```

```py
property sys2
```

返回MIMO反馈互连的反馈控制器。

示例

```py
>>> from sympy import pprint
>>> from sympy.abc import s
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback
>>> tf1 = TransferFunction(s**2, s**3 - s + 1, s)
>>> tf2 = TransferFunction(1, s, s)
>>> tf3 = TransferFunction(1, 1, s)
>>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])
>>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])
>>> F_1 = MIMOFeedback(sys1, sys2)
>>> F_1.sys2
TransferFunctionMatrix(((TransferFunction(s**2, s**3 - s + 1, s), TransferFunction(1, 1, s)), (TransferFunction(1, 1, s), TransferFunction(1, s, s))))
>>> pprint(_, use_unicode=False)
[     2       ]
[    s       1]
[----------  -]
[ 3          1]
[s  - s + 1   ]
[             ]
[    1       1]
[    -       -]
[    1       s]{t} 
```

```py
property var
```

返回所有MIMO反馈环路中涉及的传递函数使用的拉普拉斯变换的复变量。

示例

```py
>>> from sympy.abc import p
>>> from sympy.physics.control.lti import TransferFunction, TransferFunctionMatrix, MIMOFeedback
>>> tf1 = TransferFunction(p, 1 - p, p)
>>> tf2 = TransferFunction(1, p, p)
>>> tf3 = TransferFunction(1, 1, p)
>>> sys1 = TransferFunctionMatrix([[tf1, tf2], [tf2, tf1]])
>>> sys2 = TransferFunctionMatrix([[tf1, tf3], [tf3, tf2]])
>>> F_1 = MIMOFeedback(sys1, sys2, 1)  # Positive feedback
>>> F_1.var
p 
```

```py
sympy.physics.control.lti.gbt(tf, sample_per, alpha)
```

返回 H(z) 的分子和分母的降序系数。

解释

其中 H(z) 是相应的离散化传递函数，使用广义双线性变换方法进行离散化。H(z) 是通过将 \(s(z) = \frac{z-1}{T(\alpha z + (1-\alpha))}\) 替换到 H(s) 中获得的，其中 T 是采样周期。系数是降序排列的，即 \(H(z) = \frac{az+b}{cz+d}\) 返回为 [a, b], [c, d]。

示例

```py
>>> from sympy.physics.control.lti import TransferFunction, gbt
>>> from sympy.abc import s, L, R, T 
```

```py
>>> tf = TransferFunction(1, s*L + R, s)
>>> numZ, denZ = gbt(tf, T, 0.5)
>>> numZ
[T/(2*(L + R*T/2)), T/(2*(L + R*T/2))]
>>> denZ
[1, (-L + R*T/2)/(L + R*T/2)] 
```

```py
>>> numZ, denZ = gbt(tf, T, 0)
>>> numZ
[T/L]
>>> denZ
[1, (-L + R*T)/L] 
```

```py
>>> numZ, denZ = gbt(tf, T, 1)
>>> numZ
[T/(L + R*T), 0]
>>> denZ
[1, -L/(L + R*T)] 
```

```py
>>> numZ, denZ = gbt(tf, T, 0.3)
>>> numZ
[3*T/(10*(L + 3*R*T/10)), 7*T/(10*(L + 3*R*T/10))]
>>> denZ
[1, (-L + 7*R*T/10)/(L + 3*R*T/10)] 
```

参考文献

[[R736](#id3)]

[https://www.polyu.edu.hk/ama/profile/gfzhang/Research/ZCC09_IJC.pdf](https://www.polyu.edu.hk/ama/profile/gfzhang/Research/ZCC09_IJC.pdf)

```py
sympy.physics.control.lti.bilinear(tf, sample_per)
```

返回 H(z) 的分子和分母的降序系数。

解释

其中 H(z) 是相应的离散化传递函数，使用双线性变换方法进行离散化。H(z) 是通过将 \(s(z) = \frac{2}{T}\frac{z-1}{z+1}\) 替换到 H(s) 中获得的，其中 T 是采样周期。系数是降序排列的，即 \(H(z) = \frac{az+b}{cz+d}\) 返回为 [a, b], [c, d]。

示例

```py
>>> from sympy.physics.control.lti import TransferFunction, bilinear
>>> from sympy.abc import s, L, R, T 
```

```py
>>> tf = TransferFunction(1, s*L + R, s)
>>> numZ, denZ = bilinear(tf, T)
>>> numZ
[T/(2*(L + R*T/2)), T/(2*(L + R*T/2))]
>>> denZ
[1, (-L + R*T/2)/(L + R*T/2)] 
```

```py
sympy.physics.control.lti.forward_diff(tf, sample_per)
```

返回 H(z) 的分子和分母的降序系数。

解释

其中 H(z) 是相应的离散化传递函数，使用前向差分变换方法进行离散化。H(z) 是通过将 \(s(z) = \frac{z-1}{T}\) 替换到 H(s) 中获得的，其中 T 是采样周期。系数是降序排列的，即 \(H(z) = \frac{az+b}{cz+d}\) 返回为 [a, b], [c, d]。

示例

```py
>>> from sympy.physics.control.lti import TransferFunction, forward_diff
>>> from sympy.abc import s, L, R, T 
```

```py
>>> tf = TransferFunction(1, s*L + R, s)
>>> numZ, denZ = forward_diff(tf, T)
>>> numZ
[T/L]
>>> denZ
[1, (-L + R*T)/L] 
```

```py
sympy.physics.control.lti.backward_diff(tf, sample_per)
```

返回 H(z) 的分子和分母的降序系数。

解释

其中，H(z) 是相应的离散化传递函数，使用后向差分变换方法离散化。H(z) 是从连续传递函数 H(s) 通过将 \(s(z) = \frac{z-1}{Tz}\) 代入 H(s) 而获得的，其中 T 是采样周期。系数在变小，即 \(H(z) = \frac{az+b}{cz+d}\) 被返回为 [a, b], [c, d]。

举例

```py
>>> from sympy.physics.control.lti import TransferFunction, backward_diff
>>> from sympy.abc import s, L, R, T 
```

```py
>>> tf = TransferFunction(1, s*L + R, s)
>>> numZ, denZ = backward_diff(tf, T)
>>> numZ
[T/(L + R*T), 0]
>>> denZ
[1, -L/(L + R*T)] 
```
