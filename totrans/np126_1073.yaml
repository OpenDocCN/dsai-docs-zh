- en: Array Iterator API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组迭代器API
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/iterator.html](https://numpy.org/doc/1.26/reference/c-api/iterator.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/c-api/iterator.html](https://numpy.org/doc/1.26/reference/c-api/iterator.html)
- en: New in version 1.6.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.6版中新增。
- en: Array Iterator
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组迭代器
- en: The array iterator encapsulates many of the key features in ufuncs, allowing
    user code to support features like output parameters, preservation of memory layouts,
    and buffering of data with the wrong alignment or type, without requiring difficult
    coding.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数组迭代器封装了通用函数中的许多关键功能，允许用户代码支持输出参数、保留内存布局和使用错误对齐或类型的数据缓冲，而无需进行困难的编码。
- en: This page documents the API for the iterator. The iterator is named `NpyIter`
    and functions are named `NpyIter_*`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本页记录了迭代器的API。迭代器命名为`NpyIter`，函数命名为`NpyIter_*`。
- en: There is an [introductory guide to array iteration](../arrays.nditer.html#arrays-nditer)
    which may be of interest for those using this C API. In many instances, testing
    out ideas by creating the iterator in Python is a good idea before writing the
    C iteration code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[数组迭代入门指南](../arrays.nditer.html#arrays-nditer)，对于使用这个C API的人可能会有所帮助。在许多情况下，通过在Python中创建迭代器来测试想法是一个好主意，然后再编写C迭代代码。
- en: '## Iteration Example'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 迭代示例'
- en: The best way to become familiar with the iterator is to look at its usage within
    the NumPy codebase itself. For example, here is a slightly tweaked version of
    the code for [`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero "PyArray_CountNonzero"),
    which counts the number of non-zero elements in an array.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉迭代器的最佳方法是查看其在NumPy代码库中的使用情况。例如，这里是稍微改进的[`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero
    "PyArray_CountNonzero")代码的版本，它计算数组中非零元素的数量。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Multi-Iteration Example
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重迭代示例
- en: Here is a copy function using the iterator. The `order` parameter is used to
    control the memory layout of the allocated result, typically [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is desired.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用迭代器的复制函数。`order`参数用于控制分配结果的内存布局，通常希望使用[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Multi Index Tracking Example
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多索引追踪示例
- en: This example shows you how to work with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag. For simplicity, we assume the argument is a two-dimensional
    array.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此例显示了如何使用[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")标志。为简单起见，我们假设参数是一个二维数组。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When called with a 2x3 array, the above example prints:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个2x3数组调用上述示例时，将打印：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Iterator Data Types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器数据类型
- en: The iterator layout is an internal detail, and user code only sees an incomplete
    struct.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器布局是一个内部细节，用户代码只看到一个不完整的结构。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is an opaque pointer type for the iterator. Access to its contents can
    only be done through the iterator API.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个迭代器的不透明指针类型。通过迭代器API才能访问其内容。
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the type which exposes the iterator to Python. Currently, no API is
    exposed which provides access to the values of a Python-created iterator. If an
    iterator is created in Python, it must be used in Python and vice versa. Such
    an API will likely be created in a future version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型向 Python 暴露了迭代器。目前，还没有暴露任何API来访问由 Python 创建的迭代器的值。如果在Python中创建了迭代器，必须在Python中使用，反之亦然。这样的API可能会在未来版本中创建。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a function pointer for the iteration loop, returned by [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext
    "NpyIter_GetIterNext").
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于迭代循环的函数指针，由[`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")返回。
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a function pointer for getting the current iterator multi-index, returned
    by [`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex "NpyIter_GetGetMultiIndex").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于获取当前迭代器多索引的函数指针，由[`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex
    "NpyIter_GetGetMultiIndex")返回。
- en: Construction and Destruction
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和销毁
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creates an iterator for the given numpy array object `op`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的numpy数组对象`op`创建一个迭代器。
- en: Flags that may be passed in `flags` are any combination of the global and per-operand
    flags documented in [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew"),
    except for [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`flags`中可能传递的标志是[`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew")中记录的全局和每个操作数标志的任意组合，除了[`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE
    "NPY_ITER_ALLOCATE")。
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将任何[`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER")枚举值传递给`order`。为了进行高效的迭代，[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")是最佳选项，其他顺序则需要特定的迭代模式。
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将任何[`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING")枚举值传递给`casting`。这些值包括[`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。为了允许发生转换，还必须启用复制或缓冲。
- en: If `dtype` isn’t `NULL`, then it requires that data type. If copying is allowed,
    it will make a temporary copy if the data is castable. If [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") is enabled, it will also copy the data back with another
    cast upon iterator destruction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dtype`不是`NULL`，则它需要那种数据类型。如果允许复制，则在数据可以转换时会进行临时复制。如果启用了[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY")，则在迭代器销毁时还会使用另一种转换方式将数据复制回去。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，则返回NULL，否则返回分配的迭代器。
- en: To make an iterator similar to the old iterator, this should work.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类似于旧迭代器的迭代器，可以使用以下方法。
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want to edit an array with aligned `double` code, but the order doesn’t
    matter, you would use this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用对齐的`double`代码编辑数组，但顺序无关���要，则应使用此选项。
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creates an iterator for broadcasting the `nop` array objects provided in `op`,
    using regular NumPy broadcasting rules.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于对提供给`op`的`nop`数组对象进行广播的迭代器，使用常规的NumPy广播规则。
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern. When using [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), if you also want to ensure that the iteration is not reversed
    along an axis, you should pass the flag [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES").
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将任何[`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER")枚举值传递给`order`。为了进行高效的迭代，[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")是最佳选项，其他顺序则需要特定的迭代模式。在使用[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")时，如果你还希望确保迭代沿轴不发生反转，则应该传递标志[`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES")。
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将任何[`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING")枚举值传递给`casting`。这些值包括[`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。为了允许发生转换，还必须启用复制或缓冲。
- en: If `op_dtypes` isn’t `NULL`, it specifies a data type or `NULL` for each `op[i]`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op_dtypes`不是`NULL`，则它为`op[i]`指定一个数据类型或`NULL`。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，则返回NULL，否则返回分配的迭代器。
- en: 'Flags that may be passed in `flags`, applying to the whole iterator, are:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递给 `flags` 的标志，应用于整个迭代器，包括：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Causes the iterator to track a raveled flat index matching C order. This option
    cannot be used with [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪与 C 顺序相匹配的展平索引。此选项不能与 [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    一起使用。
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Causes the iterator to track a raveled flat index matching Fortran order. This
    option cannot be used with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪与 Fortran 顺序相匹配的展平索引。此选项不能与 [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")
    一起使用。
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Causes the iterator to track a multi-index. This prevents the iterator from
    coalescing axes to produce bigger inner loops. If the loop is also not buffered
    and no index is being tracked (*NpyIter_RemoveAxis* can be called), then the iterator
    size can be `-1` to indicate that the iterator is too large. This can happen due
    to complex broadcasting and will result in errors being created when the setting
    the iterator range, removing the multi index, or getting the next function. However,
    it is possible to remove axes again and use the iterator normally if the size
    is small enough after removal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪多索引。这会防止迭代器将轴合并为生成更大的内部循环。如果循环也没有缓冲区，并且没有跟踪索引（*NpyIter_RemoveAxis* 可以被调用），则迭代器大小可以为
    `-1`，表示迭代器过大。这可能是由于复杂的广播而发生，并且将在设置迭代器范围、移除多索引或获取下一个函数时创建错误。但是，如果移除轴后大小足够小，则仍然可以再次移除轴并正常使用迭代器。
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Causes the iterator to skip iteration of the innermost loop, requiring the user
    of the iterator to handle it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跳过最内层循环的迭代，需要迭代器的使用者处理它。
- en: This flag is incompatible with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), and [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX").
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志与 [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")、[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX") 和 [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    不兼容。
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This only affects the iterator when [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is specified for the order parameter. By default with [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), the iterator reverses axes which have negative strides, so that
    memory is traversed in a forward direction. This disables this step. Use this
    flag if you want to use the underlying memory-ordering of the axes, but don’t
    want an axis reversed. This is the behavior of `numpy.ravel(a, order='K')`, for
    instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当为 order 参数指定 [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")
    时，此选项才会影响迭代器。默认情况下，使用 [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")
    时，迭代器会颠倒具有负步长的轴，以便以正向方向遍历内存。这会禁用此步骤。如果要使用轴的底层内存顺序但不想颠倒轴，则使用此标志。例如，`numpy.ravel(a,
    order='K')` 的行为就是这样的。
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Causes the iterator to convert all the operands to a common data type, calculated
    based on the ufunc type promotion rules. Copying or buffering must be enabled.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器将所有操作数转换为基于 ufunc 类型提升规则计算的公共数据类型。必须启用复制或缓冲区。
- en: If the common data type is known ahead of time, don’t use this flag. Instead,
    set the requested dtype for all the operands.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经预先知道公共数据类型，请不要使用此标志。而是为所有操作数设置请求的 dtype。
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indicates that arrays with reference types (object arrays or structured arrays
    containing an object type) may be accepted and used in the iterator. If this flag
    is enabled, the caller must be sure to check whether NpyIter_IterationNeedsAPI(iter)
    is true, in which case it may not release the GIL during iteration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表示可能接受并在迭代器中使用具有引用类型（对象数组或包含对象类型的结构化数组）的数组。如果启用了此标志，则调用者必须确保检查是否 NpyIter_IterationNeedsAPI(iter)
    为 true，在这种情况下，可能在迭代期间不释放 GIL。
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Indicates that arrays with a size of zero should be permitted. Since the typical
    iteration loop does not naturally work with zero-sized arrays, you must check
    that the IterSize is larger than zero before entering the iteration loop. Currently
    only the operands are checked, not a forced shape.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应允许大小为零的数组。由于典型的迭代循环不会自然地处理大小为零的数组，因此在进入迭代循环之前，必须检查 IterSize 是否大于零。当前仅检查操作数，而不是强制形状。
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Permits writeable operands with a dimension with zero stride and size greater
    than one. Note that such operands must be read/write.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 允许带有零步长和大小大于一的维度的可写操作数。请注意，此类操作数必须是可读/可写的。
- en: When buffering is enabled, this also switches to a special buffering mode which
    reduces the loop length as necessary to not trample on values being reduced.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缓冲处理时，这还切换到一种特殊的缓冲模式，根据需要减少循环长度，以避免对正在减少的值造成干扰。
- en: Note that if you want to do a reduction on an automatically allocated output,
    you must use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get its reference, then set every value to the reduction unit before doing
    the iteration loop. In the case of a buffered reduction, this means you must also
    specify the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    then reset the iterator after initializing the allocated operand to prepare the
    buffers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果要对自动分配的输出进行减少运算，必须使用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")获取其引用，然后在执行迭代循环之前将每个值设置为减少单位。在进行缓冲减少运算时，这意味着你还必须指定标志[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC")，然后在初始化分配的操作数以准备缓冲区后重置迭代器。
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enables support for iteration of sub-ranges of the full `iterindex` range `[0,
    NpyIter_IterSize(iter))`. Use the function [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") to specify a range for iteration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 启用对完整`iterindex`范围`[0, NpyIter_IterSize(iter))`的子范围进行迭代的支持。使用函数[`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange")来指定迭代范围。
- en: This flag can only be used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") when [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")
    is enabled. This is because without buffering, the inner loop is always the size
    of the innermost iteration dimension, and allowing it to get cut up would require
    special handling, effectively making it more like the buffered version.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在启用[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")时，此标志才能与[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")一起使用。这是因为没有缓冲处理时，内部循环总是最内部迭代维度的大小，并且允许它被切割需要特殊处理，实际上更像是缓冲版本。
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Causes the iterator to store buffering data, and use buffering to satisfy data
    type, alignment, and byte-order requirements. To buffer an operand, do not specify
    the [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") flags, because they will override buffering. Buffering
    is especially useful for Python code using the iterator, allowing for larger chunks
    of data at once to amortize the Python interpreter overhead.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器存储缓冲数据，并使用缓冲来满足数据类型、对齐和字节顺序要求。要对操作数进行缓冲处理，不要指定[`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY")或[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY")标志，因为它们会覆盖缓冲处理。缓冲对于使用迭代器的Python代码特别有用，允许一次处理更大块的数据，以分摊Python解释器的开销。
- en: If used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    the inner loop for the caller may get larger chunks than would be possible without
    buffering, because of how the strides are laid out.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")一起使用，调用者的内部循环可能会获得比没有缓冲更大的块，这是因为步幅的布局方式的原因。
- en: Note that if an operand is given the flag [`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY"),
    a copy will be made in preference to buffering. Buffering will still occur when
    the array was broadcast so elements need to be duplicated to get a constant stride.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果一个操作数被赋予标志[`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY")或[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY")，会首选进行复制而不是进行缓冲处理。当数组进行广播时，元素需要被复制以获得常量步幅，仍然会进行缓冲处理。
- en: In normal buffering, the size of each inner loop is equal to the buffer size,
    or possibly larger if [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")
    is specified. If [`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")
    is enabled and a reduction occurs, the inner loops may become smaller depending
    on the structure of the reduction.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ' 在正常的缓冲处理中，每个内部循环的大小等于缓冲区的大小，或者如果指定了[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER")，可能更大。如果启用了[`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")并且发生了减少，那么内部循环可能会因减少的结构而变小。'
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When buffering is enabled, this allows the size of the inner loop to grow when
    buffering isn’t necessary. This option is best used if you’re doing a straight
    pass through all the data, rather than anything with small cache-friendly arrays
    of temporary values for each inner loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用缓冲时，这允许内部循环的大小在不需要缓冲时增长。如果你正在直接通过所有数据，而不是任何具有小缓存友好的临时值数组的内部循环，则最好使用该选项。
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When buffering is enabled, this delays allocation of the buffers until [`NpyIter_Reset`](#c.NpyIter_Reset
    "NpyIter_Reset") or another reset function is called. This flag exists to avoid
    wasteful copying of buffer data when making multiple copies of a buffered iterator
    for multi-threaded iteration.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用缓冲时，这延迟缓冲区的分配，直到调用[`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")或另一个重置函数。该标志存在是为了在多线程迭代时避免多次复制缓冲区数据的浪费。
- en: Another use of this flag is for setting up reduction operations. After the iterator
    is created, and a reduction output is allocated automatically by the iterator
    (be sure to use READWRITE access), its value may be initialized to the reduction
    unit. Use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get the object. Then, call [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")
    to allocate and fill the buffers with their initial values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用该标志的方法是设置缩减操作。创建迭代器后，通过迭代器自动分配缩减输出（确保使用READWRITE访问），其值可以初始化为缩减单元。使用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")获取该对象。然后调用[`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")来分配并填充缓冲区的初始值。
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If any write operand has overlap with any read operand, eliminate all overlap
    by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary).
    A pair of operands has overlap if there is a memory address that contains data
    common to both arrays.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何写操作数与任何读操作数存在重叠，通过制作临时副本（必要时启用WRITEIFCOPY以避免重叠），消除所有重叠。如果有一个内存地址包含两个数组的共同数据，则一对操作数具有重叠。
- en: Because exact overlap detection has exponential runtime in the number of dimensions,
    the decision is made based on heuristics, which has false positives (needless
    copies in unusual cases) but has no false negatives.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精确的重叠检测在维度数量上具有指数级的运行时间，因此决策是基于启发式方法的，该方法具有假阳性（在不寻常的情况下产生不必要的副本），但没有假阴性。
- en: If any read/write overlap exists, this flag ensures the result of the operation
    is the same as if all operands were copied. In cases where copies would need to
    be made, **the result of the computation may be undefined without this flag!**
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在任何读/写重叠，此标志可确保操作的结果与所有操作数进行复制时的结果相同。在需要进行复制的情况下，**如果没有此标志，计算结果可能是不确定的！**
- en: 'Flags that may be passed in `op_flags[i]`, where `0 <= i < nop`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递到`op_flags[i]`的标志，其中`0 <= i < nop`：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Indicate how the user of the iterator will read or write to `op[i]`. Exactly
    one of these flags must be specified per operand. Using `NPY_ITER_READWRITE` or
    `NPY_ITER_WRITEONLY` for a user-provided operand may trigger *WRITEBACKIFCOPY`*
    semantics. The data will be written back to the original array when `NpyIter_Deallocate`
    is called.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 指示迭代器的使用者将如何对`op[i]`进行读取或写入。对于每个操作数，必须指定这些标志中的一个。对于用户提供的操作数，使用`NPY_ITER_READWRITE`或`NPY_ITER_WRITEONLY`可能会触发*WRITEBACKIFCOPY*语义。在调用`NpyIter_Deallocate`时，数据将被写回原始数组。
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Allow a copy of `op[i]` to be made if it does not meet the data type or alignment
    requirements as specified by the constructor flags and parameters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op[i]`的复制不符合构造函数的标志和参数指定的数据类型或对齐要求，则允许进行复制。
- en: '[PRE30]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Triggers [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY"), and when an array
    operand is flagged for writing and is copied, causes the data in a copy to be
    copied back to `op[i]` when `NpyIter_Deallocate` is called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 触发[`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY")，当数组操作数被标记为可写并进行复制时，在调用`NpyIter_Deallocate`时，会导致在副本中的数据被再次复制回`op[i]`。
- en: If the operand is flagged as write-only and a copy is needed, an uninitialized
    temporary array will be created and then copied to back to `op[i]` on calling
    `NpyIter_Deallocate`, instead of doing the unnecessary copy operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数被标记为仅写，并且需要复制，则将创建一个未初始化的临时数组，然后在调用`NpyIter_Deallocate`时复制回`op[i]`，而不是执行不必要的复制操作。
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Causes the iterator to provide data for `op[i]` that is in native byte order,
    aligned according to the dtype requirements, contiguous, or any combination.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 导致迭代器为`op[i]`提供原生字节顺序的数据，根据dtype要求对齐，连续，或任何组合。
- en: By default, the iterator produces pointers into the arrays provided, which may
    be aligned or unaligned, and with any byte order. If copying or buffering is not
    enabled and the operand data doesn’t satisfy the constraints, an error will be
    raised.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，迭代器生成指向提供的数组的指针，这些指针可以对齐或不对齐，并且具有任何字节顺序。如果未启用复制或缓冲，并且操作数数据不满足约束条件，则会引发错误。
- en: The contiguous constraint applies only to the inner loop, successive inner loops
    may have arbitrary pointer changes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 连续约束仅适用于内部循环，连续的内部循环可以具有任意的指针更改。
- en: If the requested data type is in non-native byte order, the NBO flag overrides
    it and the requested data type is converted to be in native byte order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的数据类型是非本机字节顺序，则 NBO 标志将其覆盖，并且请求的数据类型将转换为本机字节顺序。
- en: '[PRE34]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is for output arrays, and requires that the flag [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY") or [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    be set. If `op[i]` is NULL, creates a new array with the final broadcast dimensions,
    and a layout matching the iteration order of the iterator.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于输出数组的，并且需要设置标志[`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY")或[`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE
    "NPY_ITER_READWRITE")。如果 `op[i]` 为 NULL，则创建一个具有最终广播维度和与迭代器的迭代顺序匹配的布局的新数组。
- en: When `op[i]` is NULL, the requested data type `op_dtypes[i]` may be NULL as
    well, in which case it is automatically generated from the dtypes of the arrays
    which are flagged as readable. The rules for generating the dtype are the same
    is for UFuncs. Of special note is handling of byte order in the selected dtype.
    If there is exactly one input, the input’s dtype is used as is. Otherwise, if
    more than one input dtypes are combined together, the output will be in native
    byte order.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `op[i]` 为 NULL 时，请求的数据类型 `op_dtypes[i]` 也可以为 NULL，此时它将自动从标记为可读的数组的数据类型中生成。生成数据类型的规则与
    UFuncs 相同。特别注意的是选择的数据类型中的字节顺序处理。如果只有一个输入，则使用输入的数据类型。否则，如果将多个输入数据类型组合在一起，则输出将为本机字节顺序。
- en: After being allocated with this flag, the caller may retrieve the new array
    by calling [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    and getting the i-th object in the returned C array. The caller must call Py_INCREF
    on it to claim a reference to the array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 带有此标志分配后，调用者可以通过调用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")来检索新的数组，并获取返回的
    C 数组中的第 i 个对象。调用者必须调用 Py_INCREF 来声明对数组的引用。
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For use with [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE"),
    this flag disables allocating an array subtype for the output, forcing it to be
    a straight ndarray.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用于[`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")时，此标志禁用为输出分配数组子类型，强制其成为直接的
    ndarray。
- en: 'TODO: Maybe it would be better to introduce a function `NpyIter_GetWrappedOutput`
    and remove this flag?'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'TODO: 或许引入一个函数 `NpyIter_GetWrappedOutput` 并删除此标志会更好？'
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Ensures that the input or output matches the iteration dimensions exactly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确保输入或输出与迭代维度完全匹配。
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: New in version 1.7.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7 版本中的新功能。
- en: Indicates that this operand is the mask to use for selecting elements when writing
    to operands which have the [`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")
    flag applied to them. Only one operand may have [`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK") flag applied to it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表示这个操作数是在写入操作数时要使用的掩码。当应用了[`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")标志时，只能有一个操作数应用了[`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK")标志。
- en: The data type of an operand with this flag should be either [`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL
    "NPY_BOOL"), [`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK "NPY_MASK"), or a struct
    dtype whose fields are all valid mask dtypes. In the latter case, it must match
    up with a struct operand being WRITEMASKED, as it is specifying a mask for each
    field of that array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此标志的操作数的数据类型应为[`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL "NPY_BOOL")、[`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK
    "NPY_MASK")或所有字段都是有效掩码数据类型的结构 dtype。在后一种情况下，它必须与 WRITEMASKED 的结构操作数匹配，因为它在指定该数组的每个字段的掩码。
- en: This flag only affects writing from the buffer back to the array. This means
    that if the operand is also [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    or [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY"), code doing
    iteration can write to this operand to control which elements will be untouched
    and which ones will be modified. This is useful when the mask should be a combination
    of input masks.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志仅影响从缓冲区写回数组。这意味着如果操作数还是[`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")或[`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY")，执行迭代的代码可以写入此操作数以控制哪些元素将不被修改，哪些元素将被修改。当掩码应为输入掩码的组合时，这很有用。
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: New in version 1.7.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.7开始新增。
- en: This array is the mask for all [`writemasked`](../generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") operands. Code uses the `writemasked` flag which indicates that
    only elements where the chosen ARRAYMASK operand is True will be written to. In
    general, the iterator does not enforce this, it is up to the code doing the iteration
    to follow that promise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组是所有[`writemasked`](../generated/numpy.nditer.html#numpy.nditer "numpy.nditer")
    操作数的掩码。代码使用`writemasked`标志，指示只有选择的ARRAYMASK操作数为True的元素才会被写入。一般情况下，迭代器不会强制执行此操作，代码执行迭代时应遵循该约定。
- en: When `writemasked` flag is used, and this operand is buffered, this changes
    how data is copied from the buffer into the array. A masked copying routine is
    used, which only copies the elements in the buffer for which `writemasked` returns
    true from the corresponding element in the ARRAYMASK operand.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`writemasked`标志并且此操作数已缓冲时，这会改变从缓冲区复制数据到数组的方式。将使用掩码复制例程，该例程仅复制在数组掩码的相应元素中`writemasked`返回true的元素。
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In memory overlap checks, assume that operands with `NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`
    enabled are accessed only in the iterator order.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存重叠检查中，假设启用了`NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`的操作数仅按照迭代器顺序访问。
- en: This enables the iterator to reason about data dependency, possibly avoiding
    unnecessary copies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得迭代器能够推断数据依赖关系，可能避免不必要的复制。
- en: This flag has effect only if `NPY_ITER_COPY_IF_OVERLAP` is enabled on the iterator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志仅在迭代器上启用了`NPY_ITER_COPY_IF_OVERLAP`时才有效。
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Extends [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") with several
    advanced options providing more control over broadcasting and buffering.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几个高级选项扩展了[`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew")，提供了对广播和缓冲的更多控制。
- en: If -1/NULL values are passed to `oa_ndim`, `op_axes`, `itershape`, and `buffersize`,
    it is equivalent to [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将-1/NULL值传递给`oa_ndim`、`op_axes`、`itershape`和`buffersize`，则等效于[`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew")。
- en: The parameter `oa_ndim`, when not zero or -1, specifies the number of dimensions
    that will be iterated with customized broadcasting. If it is provided, `op_axes`
    must and `itershape` can also be provided. The `op_axes` parameter let you control
    in detail how the axes of the operand arrays get matched together and iterated.
    In `op_axes`, you must provide an array of `nop` pointers to `oa_ndim`-sized arrays
    of type `npy_intp`. If an entry in `op_axes` is NULL, normal broadcasting rules
    will apply. In `op_axes[j][i]` is stored either a valid axis of `op[j]`, or -1
    which means `newaxis`. Within each `op_axes[j]` array, axes may not be repeated.
    The following example is how normal broadcasting applies to a 3-D array, a 2-D
    array, a 1-D array and a scalar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数`oa_ndim`不为零或-1时，指定将使用自定义广播进行迭代的维数的数量。如果提供了它，`op_axes`必须提供，并且`itershape`也可以提供。`op_axes`参数让您可以详细控制操作数组的轴如何匹配在一起并进行迭代。在`op_axes`中，您必须提供一个指向大小为`oa_ndim`的数组的指针数组，其类型为`npy_intp`。如果`op_axes`中的条目为NULL，则将应用正常的广播规则。在`op_axes[j][i]`中存储的是`op[j]`的一个有效轴，或者是-1，表示`newaxis`。在每个`op_axes[j]`数组内，轴不得重复。以下示例是如何将正常的广播应用于三维数组、二维数组、一维数组和标量的。
- en: '**Note**: Before NumPy 1.8 `oa_ndim == 0` was used for signalling that ``op_axes`
    and `itershape` are unused. This is deprecated and should be replaced with -1\.
    Better backward compatibility may be achieved by using [`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew") for this case.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在NumPy 1.8之前，`oa_ndim == 0`用于表示`op_axes`和`itershape`未使用。这已被弃用，应替换为-1。可以通过使用[`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew")来获得更好的向后兼容性。'
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `itershape` parameter allows you to force the iterator to have a specific
    iteration shape. It is an array of length `oa_ndim`. When an entry is negative,
    its value is determined from the operands. This parameter allows automatically
    allocated outputs to get additional dimensions which don’t match up with any dimension
    of an input.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`itershape` 参数允许您强制迭代器具有特定的迭代形状。它是长度为 `oa_ndim` 的数组。当条目为负时，其值来自运算数。此参数允许自动分配输出获得额外的维度，这些维度与任何输入的维度不匹配。'
- en: If `buffersize` is zero, a default buffer size is used, otherwise it specifies
    how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192
    are recommended.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `buffersize` 是零，则使用默认的缓冲区大小，否则指定要使用多大的缓冲区。建议使用 4096 或 8192 等的 2 的幂大小的缓冲区。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，返回 NULL，否则返回分配的迭代器。
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Makes a copy of the given iterator. This function is provided primarily to enable
    multi-threaded iteration of the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 复制给定迭代器。此函数主要用于启用数据的多线程迭代。
- en: '*TODO*: Move this to a section about multithreaded iteration.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*TODO*：将此移到有关多线程迭代的部分。'
- en: The recommended approach to multithreaded iteration is to first create an iterator
    with the flags [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED"), [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED"), [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    and possibly [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER").
    Create a copy of this iterator for each thread (minus one for the first iterator).
    Then, take the iteration index range `[0, NpyIter_GetIterSize(iter))` and split
    it up into tasks, for example using a TBB parallel_for loop. When a thread gets
    a task to execute, it then uses its copy of the iterator by calling [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") and iterating over the full range.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的多线程迭代方法是首先使用标志 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")、[`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED")、[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")、[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") 和可能的 [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")
    创建一个迭代器。为每个线程创建此迭代器的副本（第一个迭代器除外）。然后，将迭代索引范围 `[0, NpyIter_GetIterSize(iter))` 分成任务进行处理，例如使用
    TBB 的 parallel_for 循环。当线程获得任务并执行时，它将使用自己的迭代器副本，通过调用 [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") 并对整个范围进行迭代。
- en: When using the iterator in multi-threaded code or in code not holding the Python
    GIL, care must be taken to only call functions which are safe in that context.
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") cannot be safely called without
    the Python GIL, because it increments Python references. The `Reset*` and some
    other functions may be safely called by passing in the `errmsg` parameter as non-NULL,
    so that the functions will pass back errors through it instead of setting a Python
    exception.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程代码中使用迭代器或在不持有 Python GIL 的代码中使用时，必须注意只调用在该上下文中安全的函数。不能在没有 Python GIL 的情况下安全调用
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy")，因为它会增加 Python 引用。通过将 `errmsg`
    参数传递为非 NULL，可以安全调用 `Reset*` 和一些其他函数，这样函数将通过它传回错误，而不是设置 Python 异常。
- en: '[`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate") must be
    called for each copy.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本都必须调用 [`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate")。
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Removes an axis from iteration. This requires that [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") was set for iterator creation, and does not work if buffering
    is enabled or an index is being tracked. This function also resets the iterator
    to its initial state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从迭代中移除一个轴。这要求在迭代器创建时设置了 [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")，并且如果启用了缓冲或正在跟踪索引，则不起作用。此函数还将迭代器重置到初始状态。
- en: This is useful for setting up an accumulation loop, for example. The iterator
    can first be created with all the dimensions, including the accumulation axis,
    so that the output gets created correctly. Then, the accumulation axis can be
    removed, and the calculation done in a nested fashion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于设置累加循环非常有用。迭代器可以首先使用包括累加轴在内的所有维度创建，以便输出正确创建。然后，累加轴可以被移除，并且计算以嵌套的方式进行。
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again! The
    iterator range will be reset as well.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数可能会改变迭代器的内部内存布局。必须重新获取迭代器的任何缓存函数或指针！迭代范围也将被重置。'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If the iterator is tracking a multi-index, this strips support for them, and
    does further iterator optimizations that are possible if multi-indices are not
    needed. This function also resets the iterator to its initial state.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器正在跟踪多索引，则取消对它们的支持，并进行进一步的迭代器优化，如果不需要多索引。此函数也会将迭代器重置回初始状态。
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again!'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数可能会改变迭代器的内部内存布局。必须重新获取迭代器的任何缓存函数或指针！'
- en: After calling this function, [NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex
    "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex "iter")) will return
    false.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数后，[NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex
    "iter")) 将返回 false。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    was called, you may want to enable the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP"). This flag is not permitted together with [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX"), so this function is provided to enable the feature after
    [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    is called. This function also resets the iterator to its initial state.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用了 [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    ，可能需要启用标志 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    。此标志与 [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    不允许同时存在，因此提供了这个函数在调用 [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex
    "NpyIter_RemoveMultiIndex") 后启用该功能。此函数也会将迭代器重置回初始状态。
- en: '**WARNING**: This function changes the internal logic of the iterator. Any
    cached functions or pointers from the iterator must be retrieved again!'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数更改了迭代器的内部逻辑。必须重新获取迭代器的任何缓存函数或指针！'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Deallocates the iterator object and resolves any needed writebacks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 释放迭代器对象并解决任何需要的写回。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Resets the iterator back to its initial state, at the beginning of the iteration
    range.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器重置为初始状态，在迭代范围的起始位置。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。如果 errmsg 非空，则在返回`NPY_FAIL`时不会设置 Python 异常。相反，*errmsg
    被设置为错误消息。当 errmsg 非空时，可以安全地调用该函数而不持有 Python GIL。
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Resets the iterator and restricts it to the `iterindex` range `[istart, iend)`.
    See [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") for an explanation of how
    to use this for multi-threaded iteration. This requires that the flag [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was passed to the iterator constructor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重置迭代器并将其限制为`iterindex`范围`[istart, iend)`。参见 [`NpyIter_Copy`](#c.NpyIter_Copy
    "NpyIter_Copy") 了解如何在多线程迭代中使用此功能。这要求在迭代器构造函数中传递了标志 [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED")。
- en: If you want to reset both the `iterindex` range and the base pointers at the
    same time, you can do the following to avoid extra buffer copying (be sure to
    add the return code error checks when you copy this code).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想同时重置`iterindex`范围和基本指针，可以按照以下方式操作以避免额外的缓冲区复制（在复制此代码时，请确保添加返回代码错误检查）。
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。如果 errmsg 非空，则在返回`NPY_FAIL`时不会设置 Python 异常。相反，*errmsg
    被设置为错误消息。当 errmsg 非空时，可以安全地调用该函数而不持有 Python GIL。
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Resets the iterator back to its initial state, but using the values in `baseptrs`
    for the data instead of the pointers from the arrays being iterated. This functions
    is intended to be used, together with the `op_axes` parameter, by nested iteration
    code with two or more iterators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器重置回初始状态，但使用`baseptrs`中的值作为数据而不是从正在迭代的数组的指针中获取。此函数预期与`op_axes`参数一起由具有两个或多个迭代器的嵌套迭代代码一起使用。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。如果`errmsg`非空，则在返回`NPY_FAIL`时不设置Python异常。相反，*errmsg*将设置为错误消息。当`errmsg`非空时，可以安全地调用该函数而不持有Python
    GIL。
- en: '*TODO*: Move the following into a special section on nested iterators.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*待办事项*：将以下内容移动到关于嵌套迭代的特殊部分。'
- en: Creating iterators for nested iteration requires some care. All the iterator
    operands must match exactly, or the calls to [`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers") will be invalid. This means that automatic copies
    and output allocation should not be used haphazardly. It is possible to still
    use the automatic data conversion and casting features of the iterator by creating
    one of the iterators with all the conversion parameters enabled, then grabbing
    the allocated operands with the [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray") function and passing them into the constructors for
    the rest of the iterators.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建嵌套迭代器需要一些小心。所有迭代器操作数必须完全匹配，否则调用[`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers")将无效。这意味着不能随意使用自动复制和输出分配。仍然可以通过启用所有转换参数创建迭代器之一，然后使用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")函数获取分配的操作数，并将它们传递给其他迭代器的构造函数来使用迭代器的自动数据转换和类型转换功能。
- en: '**WARNING**: When creating iterators for nested iteration, the code must not
    use a dimension more than once in the different iterators. If this is done, nested
    iteration will produce out-of-bounds pointers during iteration.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：在为嵌套迭代创建迭代器时，代码不能在不同的迭代器中重复使用维度。如果这样做，嵌套迭代将在迭代过程中产生越界指针。'
- en: '**WARNING**: When creating iterators for nested iteration, buffering can only
    be applied to the innermost iterator. If a buffered iterator is used as the source
    for `baseptrs`, it will point into a small buffer instead of the array and the
    inner iteration will be invalid.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：在为嵌套迭代创建迭代器时，只能将缓冲应用于最内部的迭代器。如果使用缓冲迭代器作为`baseptrs`的源，则它将指向一个小缓冲区而不是数组，内部迭代将无效。'
- en: The pattern for using nested iterators is as follows.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套迭代的模式如下。
- en: '[PRE51]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Adjusts the iterator to point to the `ndim` indices pointed to by `multi_index`.
    Returns an error if a multi-index is not being tracked, the indices are out of
    bounds, or inner loop iteration is disabled.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 调整迭代器以指向由`multi_index`指向的`ndim`索引。如果没有跟踪多索引、索引越界或禁用内部循环迭代，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adjusts the iterator to point to the `index` specified. If the iterator was
    constructed with the flag [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    `index` is the C-order index, and if the iterator was constructed with the flag
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), `index` is the Fortran-order
    index. Returns an error if there is no index being tracked, the index is out of
    bounds, or inner loop iteration is disabled.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调整迭代器以指向指定的`index`。如果迭代器是用标志[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")构造的，则`index`是C顺序索引；如果迭代器是用标志[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX")构造的，则`index`是Fortran顺序索引。如果没有正在跟踪索引、索引越界或禁用内部循环迭代，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Returns the number of elements being iterated. This is the product of all the
    dimensions in the shape. When a multi index is being tracked (and *NpyIter_RemoveAxis*
    may be called) the size may be `-1` to indicate an iterator is too large. Such
    an iterator is invalid, but may become valid after *NpyIter_RemoveAxis* is called.
    It is not necessary to check for this case.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 返回正在迭代的元素数量。这是形状中所有维度的乘积。当跟踪多索引（并且可能调用*NpyIter_RemoveAxis*）时，大小可能为`-1`，表示迭代器太大。这样的迭代器是无效的，但在调用*NpyIter_RemoveAxis*后可能变为有效。不需要检查这种情况。
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Gets the `iterindex` of the iterator, which is an index matching the iteration
    order of the iterator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 获取迭代器的`iterindex`，这是与迭代器的迭代顺序匹配的索引。
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Gets the `iterindex` sub-range that is being iterated. If [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was not specified, this always returns the range `[0, NpyIter_IterSize(iter))`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正在进行迭代的`iterindex`子范围。如果未指定[`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED")，则始终返回范围`[0,
    NpyIter_IterSize(iter))`。
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Adjusts the iterator to point to the `iterindex` specified. The IterIndex is
    an index matching the iteration order of the iterator. Returns an error if the
    `iterindex` is out of bounds, buffering is enabled, or inner loop iteration is
    disabled.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 调整迭代器以指向指定的`iterindex`。如果`iterindex`越界，启用了缓冲区或禁用内部循环迭代，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Returns 1 if the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was passed to the iterator constructor, and no call
    to one of the Reset functions has been done yet, 0 otherwise.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向迭代器构造器传递了标志[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC")，并且尚未调用Reset函数之一，返回1，否则返回0。
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Returns 1 if the caller needs to handle the inner-most 1-dimensional loop, or
    0 if the iterator handles all looping. This is controlled by the constructor flag
    [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    or [`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop "NpyIter_EnableExternalLoop").
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者需要处理最内层的1维循环，则返回1，如果迭代器处理所有循环，则返回0。这由构造函数标志[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")或[`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop
    "NpyIter_EnableExternalLoop")控制。
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag, 0 otherwise.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是用[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")标志创建的，则返回1，否则返回0。
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    flag, 0 otherwise.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是用[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")或[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX")标志创建的，则返回1，否则返回0。
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Returns 1 if the iterator requires buffering, which occurs when an operand needs
    conversion or alignment and so cannot be used directly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器需要缓冲，则返回1，这发生在操作数需要转换或对齐，因此无法直接使用。
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") flag, 0 otherwise.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是用[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")标志创建的，则返回1，否则返回0。
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER") flag, 0 otherwise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是用[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")标志创建的，则返回1，否则返回0。
- en: '[PRE65]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the iterator is buffered, returns the size of the buffer being used, otherwise
    returns 0.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器被缓冲，则返回正在使用的缓冲区的大小，否则返回0。
- en: '[PRE66]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Returns the number of dimensions being iterated. If a multi-index was not requested
    in the iterator constructor, this value may be smaller than the number of dimensions
    in the original objects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回正在进行迭代的维度数。如果在迭代器构造函数中未请求多索引，则此值可能小于原始对象中的维度数。
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Returns the number of operands in the iterator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 返回迭代器中的操作数数量。
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Gets the array of strides for the specified axis. Requires that the iterator
    be tracking a multi-index, and that buffering not be enabled.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 获取指定轴的步幅数组。要求迭代器跟踪多索引，并且未启用缓冲区。
- en: This may be used when you want to match up operand axes in some fashion, then
    remove them with [`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")
    to handle their processing manually. By calling this function before removing
    the axes, you can get the strides for the manual processing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想以某种方式匹配操作数轴然后使用[`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")手动处理它们时，可以使用此功能。在删除轴之前调用此函数，可以获取手动处理的步幅。
- en: Returns `NULL` on error.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 出现错误时返回`NULL`。
- en: '[PRE69]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Returns the broadcast shape of the iterator in `outshape`. This can only be
    called on an iterator which is tracking a multi-index.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`outshape`中迭代器的广播形状。这只能在正在跟踪多索引的迭代器上调用。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE70]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This gives back a pointer to the `nop` data type Descrs for the objects being
    iterated. The result points into `iter`, so the caller does not gain any references
    to the Descrs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回指向正在迭代的对象的`nop`数据类型Descrs的指针。结果指向`iter`，所以调用者不会获得对Descrs的任何引用。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代循环之前可以缓存此指针，调用`iternext`不会改变它。
- en: '[PRE71]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This gives back a pointer to the `nop` operand PyObjects that are being iterated.
    The result points into `iter`, so the caller does not gain any references to the
    PyObjects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回指向正在迭代的`nop`操作`PyObjects`的指针。结果指向`iter`，所以调用者不会获得对`PyObjects`的任何引用。
- en: '[PRE72]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This gives back a reference to a new ndarray view, which is a view into the
    i-th object in the array [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray"), whose dimensions and strides match the internal optimized
    iteration pattern. A C-order iteration of this view is equivalent to the iterator’s
    iteration order.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回对新的ndarray视图的引用，该视图是一个对数组[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")中第i个对象的视图，其维度和步幅与内部优化的迭代模式匹配。对此视图的C顺序迭代等同于迭代器的迭代顺序。
- en: For example, if an iterator was created with a single array as its input, and
    it was possible to rearrange all its axes and then collapse it into a single strided
    iteration, this would return a view that is a one-dimensional array.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果使用单个数组作为输入创建了迭代器，并且可以重排所有轴，然后将其折叠为单个分段迭代，那么这将返回一个视图，即一个一维数组。
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Fills `nop` flags. Sets `outreadflags[i]` to 1 if `op[i]` can be read from,
    and to 0 if not.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`nop`标志。如果可以从`op[i]`读取，则将`outreadflags[i]`设置为1，否则设置为0。
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Fills `nop` flags. Sets `outwriteflags[i]` to 1 if `op[i]` can be written to,
    and to 0 if not.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`nop`标志。如果可以写入`op[i]`，则将`outwriteflags[i]`设置为1，否则设置为0。
- en: '[PRE75]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Builds a set of strides which are the same as the strides of an output array
    created using the [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")
    flag, where NULL was passed for op_axes. This is for data packed contiguously,
    but not necessarily in C or Fortran order. This should be used together with [`NpyIter_GetShape`](#c.NpyIter_GetShape
    "NpyIter_GetShape") and [`NpyIter_GetNDim`](#c.NpyIter_GetNDim "NpyIter_GetNDim")
    with the flag [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    passed into the constructor.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的步幅集（strides）与使用[`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")标志创建的输出数组的步幅相同，其中对于`op_axes`传递的是NULL。这适用于数据按紧密方式打包，但未必按照C或Fortran顺序。这应与传入构造函数的标志[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX")一起使用[`NpyIter_GetShape`](#c.NpyIter_GetShape "NpyIter_GetShape")和[`NpyIter_GetNDim`](#c.NpyIter_GetNDim
    "NpyIter_GetNDim")。
- en: A use case for this function is to match the shape and layout of the iterator
    and tack on one or more dimensions. For example, in order to generate a vector
    per input value for a numerical gradient, you pass in ndim*itemsize for itemsize,
    then add another dimension to the end with size ndim and stride itemsize. To do
    the Hessian matrix, you do the same thing but add two dimensions, or take advantage
    of the symmetry and pack it into 1 dimension with a particular encoding.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的用例是匹配迭代器的形状和布局，并添加一个或多个维度。例如，为了为数值梯度生成每个输入值的向量，您传入`ndim*itemsize`用于`itemsize`，然后在末尾添加一个大小为`ndim`且步幅为`itemsize`的维度。要进行Hessian矩阵操作，您可以做同样的事情，但添加两个维度，或者利用对称性并使用特定编码将其打包为1个维度。
- en: This function may only be called if the iterator is tracking a multi-index and
    if [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES "NPY_ITER_DONT_NEGATE_STRIDES")
    was used to prevent an axis from being iterated in reverse order.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在迭代器跟踪多索引且使用[`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES")防止轴按相反顺序进行迭代时，才可以调用此函数。
- en: If an array is created with this method, simply adding ‘itemsize’ for each iteration
    will traverse the new array matching the iterator.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此方法创建数组，则每次迭代只需为`itemsize`添加即可遍历新数组与迭代器匹配。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE76]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: New in version 1.7.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中的新增内容。
- en: Checks to see whether this is the first time the elements of the specified reduction
    operand which the iterator points at are being seen for the first time. The function
    returns a reasonable answer for reduction operands and when buffering is disabled.
    The answer may be incorrect for buffered non-reduction operands.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 检查指定的缩减操作数的元素是否是第一次被迭代器指向的。该函数对于缩减操作数和禁用缓冲的情况下返回合理的答案。对于带有缓冲区的非缩减操作数，答案可能不正确。
- en: This function is intended to be used in EXTERNAL_LOOP mode only, and will produce
    some wrong answers when that mode is not enabled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅适用于EXTERNAL_LOOP模式，并且在未启用该模式时将产生一些错误答案。
- en: If this function returns true, the caller should also check the inner loop stride
    of the operand, because if that stride is 0, then only the first element of the
    innermost external loop is being visited for the first time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此函数返回true，则调用者还应检查操作数的内部循环跨度，因为如果该跨度为0，则只有第一个元素的内部最外部循环正在首次访问。
- en: '*WARNING*: For performance reasons, ‘iop’ is not bounds-checked, it is not
    confirmed that ‘iop’ is actually a reduction operand, and it is not confirmed
    that EXTERNAL_LOOP mode is enabled. These checks are the responsibility of the
    caller, and should be done outside of any inner loops.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告*：出于性能原因，‘iop’没有经过边界检查，没有确认‘iop’实际上是一个减少的操作数，并且没有确认已启用EXTERNAL_LOOP模式。这些检查是调用者的责任，并应在任何内部循环之外进行。'
- en: Functions For Iteration
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于迭代的函数
- en: '[PRE77]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Returns a function pointer for iteration. A specialized version of the function
    pointer may be calculated by this function instead of being stored in the iterator
    structure. Thus, to get good performance, it is required that the function pointer
    be saved in a variable rather than retrieved for each loop iteration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个迭代的函数指针。该函数的专门版本可以由这个函数计算而不是存储在迭代器结构中。因此，为了获得良好的性能，需要将函数指针保存在变量中，而不是在每次循环迭代中检索。
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，则返回NULL。如果errmsg非NULL，则在返回`NPY_FAIL`时不会设置Python异常。相反，*errmsg会设置为错误消息。当errmsg非NULL时，可以在不持有Python
    GIL的情况下安全调用该函数。
- en: The typical looping construct is as follows.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的循环构造如下。
- en: '[PRE78]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is specified, the typical inner loop construct is as follows.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")时，典型的内部循环结构如下。
- en: '[PRE79]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Observe that we are using the dataptr array inside the iterator, not copying
    the values to a local temporary. This is possible because when `iternext()` is
    called, these pointers will be overwritten with fresh values, not incrementally
    updated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在迭代器内部使用dataptr数组，而不是将值复制到本地临时位置。这是可能的，因为在调用`iternext()`时，这些指针将被覆盖为新值，而不是增量更新。
- en: If a compile-time fixed buffer is being used (both flags [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") and [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")), the inner size may be used as a signal as well. The
    size is guaranteed to become zero when `iternext()` returns false, enabling the
    following loop construct. Note that if you use this construct, you should not
    pass [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER") as a flag,
    because it will cause larger sizes under some circumstances.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用编译时固定缓冲区（两个标志[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")
    和 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")），则内部大小也可以用作信号。当`iternext()`返回false时保证大小将变为零，从而实现以下循环构造。请注意，如果使用此构造，则不应将[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER")作为标志传递，因为在某些情况下会导致更大的大小。
- en: '[PRE80]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Returns a function pointer for getting the current multi-index of the iterator.
    Returns NULL if the iterator is not tracking a multi-index. It is recommended
    that this function pointer be cached in a local variable before the iteration
    loop.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个函数指针以获取迭代器的当前多索引。如果迭代器没有跟踪多索引，则返回NULL。建议在迭代循环之前将该函数指针缓存到本地变量中。
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，则返回NULL。如果errmsg非NULL，则在返回`NPY_FAIL`时不会设置Python异常。相反，*errmsg会设置为错误消息。当errmsg非NULL时，可以在不持有Python
    GIL的情况下安全调用该函数。
- en: '[PRE82]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This gives back a pointer to the `nop` data pointers. If [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") was not specified, each data pointer points to the current
    data item of the iterator. If no inner iteration was specified, it points to the
    first data item of the inner loop.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回指向`nop`数据指针的指针。如果未指定[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")，则每个数据指针指向迭代器的当前数据项。如果未指定内部迭代，则指向内部循环的第一个数据项。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此指针可能在迭代循环之前被缓存，调用`iternext`不会改变它。此函数可以在不持有Python全局解释器锁（GIL）的情况下安全地调用。
- en: '[PRE83]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Gets the array of data pointers directly into the arrays (never into the buffers),
    corresponding to iteration index 0.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将数据指针数组放入数组中（而不是放入缓冲区），对应迭代索引0。
- en: These pointers are different from the pointers accepted by `NpyIter_ResetBasePointers`,
    because the direction along some axes may have been reversed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指针与`NpyIter_ResetBasePointers`接受的指针不同，因为沿某些轴的方向可能已经被颠倒。
- en: This function may be safely called without holding the Python GIL.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在不持有Python全局解释器锁（GIL）的情况下可以安全地调用。
- en: '[PRE84]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This gives back a pointer to the index being tracked, or NULL if no index is
    being tracked. It is only usable if one of the flags [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    were specified during construction.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回指向正在跟踪的索引的指针，如果没有正在跟踪的索引，则返回NULL。只有在构建过程中指定了标志[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX")或[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")之一时才能使用它。
- en: When the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is used, the code needs to know the parameters for doing the inner loop. These
    functions provide that information.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用标志[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")时，代码需要知道执行内部循环的参数。这些函数提供了这些信息。
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Returns a pointer to an array of the `nop` strides, one for each iterated object,
    to be used by the inner loop.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个指向`nop`步幅数组的指针，每个迭代对象使用一个步幅，以供内部循环使用。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此指针可能在迭代循环之前被缓存，调用`iternext`不会改变它。此函数可以在不持有Python全局解释器锁（GIL）的情况下安全地调用。
- en: '**WARNING**: While the pointer may be cached, its values may change if the
    iterator is buffered.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：虽然指针可能被缓存，但如果迭代器被缓冲，其值可能会发生变化。'
- en: '[PRE86]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Returns a pointer to the number of iterations the inner loop should execute.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个指向内部循环应执行的迭代次数的指针。
- en: This address may be cached before the iteration loop, calling `iternext` will
    not change it. The value itself may change during iteration, in particular if
    buffering is enabled. This function may be safely called without holding the Python
    GIL.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此地址可能在迭代循环之前被缓存，调用`iternext`不会改变它。值本身在迭代期间可能会发生变化，特别是如果启用了缓冲区。此函数可以在不持有Python全局解释器锁（GIL）的情况下安全地调用。
- en: '[PRE87]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Gets an array of strides which are fixed, or will not change during the entire
    iteration. For strides that may change, the value NPY_MAX_INTP is placed in the
    stride.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一组固定的或在整个迭代过程中不会改变的步幅。对于可能发生变化的步幅，位置`NPY_MAX_INTP`的值将被放置在步幅中。
- en: Once the iterator is prepared for iteration (after a reset if [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was used), call this to get the strides which may be
    used to select a fast inner loop function. For example, if the stride is 0, that
    means the inner loop can always load its value into a variable once, then use
    the variable throughout the loop, or if the stride equals the itemsize, a contiguous
    version for that operand may be used.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦迭代器准备好进行迭代（如果使用了[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC")，则在重置后），调用此函数以获取可用于选择快速内循环函数的步长。例如，如果步幅为0，这意味着内部循环总是可以将其值加载到变量中一次，然后在整个循环中使用变量，或者如果步幅等于项大小，则可以使用该操作数的连续版本。
- en: This function may be safely called without holding the Python GIL.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在不持有Python全局解释器锁（GIL）的情况下可以安全地调用。
- en: '## Converting from Previous NumPy Iterators'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '## 从以前的NumPy迭代器转换'
- en: The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter*
    and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast,
    and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality
    with a single object and associated API. One goal of the new API is that all uses
    of the existing iterator should be replaceable with the new iterator without significant
    effort. In 1.6, the major exception to this is the neighborhood iterator, which
    does not have corresponding features in this iterator.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的迭代器 API 包括 PyArrayIter_Check、PyArray_Iter* 和 PyArray_ITER_* 等函数。多迭代器数组包括 PyArray_MultiIter*、PyArray_Broadcast
    和 PyArray_RemoveSmallest。新的迭代器设计用单个对象和关联的 API 替换了所有这些功能。新 API 的一个目标是，现有迭代器的所有用法都应该能够毫不费力地替换为新迭代器。在
    1.6 版本中，唯一的例外是邻域迭代器，在这个迭代器中没有对应的功能。
- en: 'Here is a conversion table for which functions to use with the new iterator:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与新迭代器一起使用的函数的转换表：
- en: '| *Iterator Functions* |  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| *Iterator Functions* |  |'
- en: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
- en: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` parameter **or** Iterator
    flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` 参数 **或** 迭代器标志 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") |'
- en: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **NOT SUPPORTED** (Use the support for multiple operands instead.) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **NOT SUPPORTED** (Use the support for multiple operands instead.) |'
- en: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | Will need to add this in Python exposure |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | 将需要在 Python 暴露中添加此功能 |'
- en: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
- en: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext") 中的函数指针
    |'
- en: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
- en: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
- en: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") 或 [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
- en: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | Return value of `iternext` function pointer |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | `iternext` 函数指针的返回值 |'
- en: '| *Multi-iterator Functions* |  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| *多迭代器功能* |  |'
- en: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
- en: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
- en: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext") 中的函数指针
    |'
- en: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
- en: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **NOT SUPPORTED** (always lock-step iteration) |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **不支持**（始终为锁定步进迭代） |'
- en: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
- en: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex")或[`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
- en: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | Return value of `iternext` function pointer |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | `iternext`函数指针的返回值 |'
- en: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | Handled by [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | 由[`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew")处理 |'
- en: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | Iterator flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | 迭代器标志 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
- en: '| *Other Functions* |  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| *其他功能* | |'
- en: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | Iterator flag [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | 迭代器标志 [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
- en: Array Iterator
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组迭代器
- en: The array iterator encapsulates many of the key features in ufuncs, allowing
    user code to support features like output parameters, preservation of memory layouts,
    and buffering of data with the wrong alignment or type, without requiring difficult
    coding.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 数组迭代器封装了ufuncs中许多关键功能，允许用户代码支持功能，如输出参数、保留内存布局和缓冲具有错误对齐或类型的数据，而无需编写困难的编码。
- en: This page documents the API for the iterator. The iterator is named `NpyIter`
    and functions are named `NpyIter_*`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该页面记录了迭代器的API。该迭代器命名为`NpyIter`，函数命名为`NpyIter_*`。
- en: There is an [introductory guide to array iteration](../arrays.nditer.html#arrays-nditer)
    which may be of interest for those using this C API. In many instances, testing
    out ideas by creating the iterator in Python is a good idea before writing the
    C iteration code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[数组迭代介绍指南](../arrays.nditer.html#arrays-nditer)，对于使用该C API的人来说可能会感兴趣。在许多情况下，通过在Python中创建迭代器来尝试想法是一个好主意，然后再编写C迭代代码。
- en: '## Iteration Example'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '## 迭代示例'
- en: The best way to become familiar with the iterator is to look at its usage within
    the NumPy codebase itself. For example, here is a slightly tweaked version of
    the code for [`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero "PyArray_CountNonzero"),
    which counts the number of non-zero elements in an array.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉迭代器的最佳方法是查看其在NumPy代码库内部的使用情况。例如，这是对[`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero
    "PyArray_CountNonzero")的略微调整版本的代码，该版本计算数组中非零元素的数量。
- en: '[PRE88]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Multi-Iteration Example
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次迭代示例
- en: Here is a copy function using the iterator. The `order` parameter is used to
    control the memory layout of the allocated result, typically [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is desired.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用迭代器的复制函数。`order`参数用于控制已分配结果的内存布局，通常希望使用[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")。
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Multi Index Tracking Example
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多索引跟踪示例
- en: This example shows you how to work with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag. For simplicity, we assume the argument is a two-dimensional
    array.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例向您展示如何处理[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")标志。为简单起见，我们假设参数是二维数组。
- en: '[PRE90]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When called with a 2x3 array, the above example prints:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个2x3数组时，上面的示例会打印：
- en: '[PRE91]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Iterator Data Types
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器数据类型
- en: The iterator layout is an internal detail, and user code only sees an incomplete
    struct.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器布局是内部细节，用户代码只看到不完整的结构体。
- en: '[PRE92]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is an opaque pointer type for the iterator. Access to its contents can
    only be done through the iterator API.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迭代器的一个不透明指针类型。只能通过迭代器API访问其内容。
- en: '[PRE93]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is the type which exposes the iterator to Python. Currently, no API is
    exposed which provides access to the values of a Python-created iterator. If an
    iterator is created in Python, it must be used in Python and vice versa. Such
    an API will likely be created in a future version.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种类型，将迭代器暴露给Python。目前，没有暴露的API提供访问以Python创建的迭代器的值。如果在Python中创建迭代器，那么必须在Python中使用，反之亦然。这样的API可能会在将来的版本中创建。
- en: '[PRE94]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This is a function pointer for the iteration loop, returned by [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext
    "NpyIter_GetIterNext").
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个迭代循环的函数指针，由[`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")返回。
- en: '[PRE95]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This is a function pointer for getting the current iterator multi-index, returned
    by [`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex "NpyIter_GetGetMultiIndex").
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数指针，用于获取当前迭代器多重索引，由[`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex
    "NpyIter_GetGetMultiIndex")返回。
- en: Construction and Destruction
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造和销毁
- en: '[PRE96]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Creates an iterator for the given numpy array object `op`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的numpy数组对象`op`创建一个迭代器。
- en: Flags that may be passed in `flags` are any combination of the global and per-operand
    flags documented in [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew"),
    except for [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE").
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`flags`中传递的标志是[`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew")中记录的全局和每个操作数标志的任意组合，除了[`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE
    "NPY_ITER_ALLOCATE")。
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 任何[`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER")枚举值都可以传递给`order`。为了进行高效迭代，[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")是最佳选项，其他顺序强制执行特定的迭代模式。
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 任何[`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING")枚举值都可以传递给`casting`。这些值包括[`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。为了允许转换发生，还必须启用复制或缓冲。
- en: If `dtype` isn’t `NULL`, then it requires that data type. If copying is allowed,
    it will make a temporary copy if the data is castable. If [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") is enabled, it will also copy the data back with another
    cast upon iterator destruction.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dtype`不是`NULL`，则需要该数据类型。如果允许复制，则如果数据可转换，将进行临时复制。如果启用了[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY")，在迭代器销毁时也将使用另一种转换再次复制数据。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，则返回NULL，否则返回分配的迭代器。
- en: To make an iterator similar to the old iterator, this should work.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要使迭代器类似于旧迭代器，这样处理应该可以。
- en: '[PRE97]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: If you want to edit an array with aligned `double` code, but the order doesn’t
    matter, you would use this.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用对齐`double`代码编辑数组，但顺序无关紧要，你可以这样做。
- en: '[PRE98]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Creates an iterator for broadcasting the `nop` array objects provided in `op`,
    using regular NumPy broadcasting rules.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个迭代器，用于广播`op`中提供的`nop`数组对象，使用常规的NumPy广播规则。
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern. When using [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), if you also want to ensure that the iteration is not reversed
    along an axis, you should pass the flag [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES").
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`参数可以传递[`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") 枚举值中的任意一个。为了有效迭代，[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") 是最佳选项，其他顺序强制执行特定的迭代模式。当使用[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")时，如果您还希望确保迭代沿某个轴不被翻转，应该传递标志[`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES")。'
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`casting`参数可以传递[`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") 枚举值中的任意一个。这些值包括[`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。要允许进行强制转换，还必须启用复制或缓冲。'
- en: If `op_dtypes` isn’t `NULL`, it specifies a data type or `NULL` for each `op[i]`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op_dtypes`不是`NULL`，它为每个`op[i]`指定一个数据类型或`NULL`。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，则返回 NULL，否则返回分配的迭代器。
- en: 'Flags that may be passed in `flags`, applying to the whole iterator, are:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`flags`中传递的整个迭代器应用的标志有：
- en: '[PRE100]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Causes the iterator to track a raveled flat index matching C order. This option
    cannot be used with [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX").
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪匹配 C 顺序的展平索引。此选项不能与[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")一起使用。
- en: '[PRE101]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Causes the iterator to track a raveled flat index matching Fortran order. This
    option cannot be used with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX").
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪匹配 Fortran 顺序的展平索引。此选项不能与[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")一起使用。
- en: '[PRE102]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Causes the iterator to track a multi-index. This prevents the iterator from
    coalescing axes to produce bigger inner loops. If the loop is also not buffered
    and no index is being tracked (*NpyIter_RemoveAxis* can be called), then the iterator
    size can be `-1` to indicate that the iterator is too large. This can happen due
    to complex broadcasting and will result in errors being created when the setting
    the iterator range, removing the multi index, or getting the next function. However,
    it is possible to remove axes again and use the iterator normally if the size
    is small enough after removal.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跟踪多重索引。这会防止迭代器将轴合并为更大的内层循环。如果循环也没有被缓冲且未跟踪任何索引（可以调用*NpyIter_RemoveAxis*），则迭代器大小可以为`-1`，表示迭代器太大。这可能是由于复杂的广播导致的，将导致在设置迭代器范围、移除多重索引或获取下一个函数时创建错误。但是，如果在移除后大小足够小，则可以再次移除轴并正常使用迭代器。
- en: '[PRE103]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Causes the iterator to skip iteration of the innermost loop, requiring the user
    of the iterator to handle it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器跳过内层循环的迭代，需要迭代器使用者处理它。
- en: This flag is incompatible with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), and [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX").
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志与[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")、[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX")和[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")不兼容。
- en: '[PRE104]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This only affects the iterator when [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is specified for the order parameter. By default with [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), the iterator reverses axes which have negative strides, so that
    memory is traversed in a forward direction. This disables this step. Use this
    flag if you want to use the underlying memory-ordering of the axes, but don’t
    want an axis reversed. This is the behavior of `numpy.ravel(a, order='K')`, for
    instance.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定顺序参数为[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")时，这仅影响迭代器。默认情况下，使用[`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")时，迭代器颠倒具有负步幅的轴，以便内存以正向顺序遍历。这会禁用此步骤。如果要使用轴的底层内存顺序，但不希望反转轴，则使用此标志。例如，`numpy.ravel(a,
    order='K')`的行为。
- en: '[PRE105]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Causes the iterator to convert all the operands to a common data type, calculated
    based on the ufunc type promotion rules. Copying or buffering must be enabled.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器将所有操作数转换为一个共同的数据类型，根据ufunc类型提升规则计算。必须启用复制或缓冲。
- en: If the common data type is known ahead of time, don’t use this flag. Instead,
    set the requested dtype for all the operands.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经提前知道了共同的数据类型，请不要使用此标志。而是为所有操作数设置请求的dtype。
- en: '[PRE106]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Indicates that arrays with reference types (object arrays or structured arrays
    containing an object type) may be accepted and used in the iterator. If this flag
    is enabled, the caller must be sure to check whether NpyIter_IterationNeedsAPI(iter)
    is true, in which case it may not release the GIL during iteration.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 表示接受并在迭代器中使用具有引用类型（对象数组或包含对象类型的结构化数组）的数组。如果启用了此标志，则调用方必须确保检查是否在迭代期间需要API(iter)为真，这种情况下可能不会在迭代期间释放GIL。
- en: '[PRE107]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Indicates that arrays with a size of zero should be permitted. Since the typical
    iteration loop does not naturally work with zero-sized arrays, you must check
    that the IterSize is larger than zero before entering the iteration loop. Currently
    only the operands are checked, not a forced shape.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应允许大小为零的数组。由于典型的迭代循环不自然地适用于大小为零的数组，因此在进入迭代循环之前必须检查IterSize是否大于零。当前仅检查操作数，而不是强制形状。
- en: '[PRE108]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Permits writeable operands with a dimension with zero stride and size greater
    than one. Note that such operands must be read/write.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 允许具有零步幅和大小大于一的维度的可写操作数。注意，这样的操作数必须是可读/可写的。
- en: When buffering is enabled, this also switches to a special buffering mode which
    reduces the loop length as necessary to not trample on values being reduced.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缓冲时，这还会切换到一种特殊的缓冲模式，根据需要减少循环长度，以免踩到正在减少的值。
- en: Note that if you want to do a reduction on an automatically allocated output,
    you must use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get its reference, then set every value to the reduction unit before doing
    the iteration loop. In the case of a buffered reduction, this means you must also
    specify the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    then reset the iterator after initializing the allocated operand to prepare the
    buffers.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果要对自动分配的输出进行缩减，必须使用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")获取其引用，然后在执行迭代循环之前将每个值设置为缩减单元。对于缓冲缩减，这意味着您还必须指定标志[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC")，然后在初始化已分配操作数以准备缓冲区后重置迭代器。
- en: '[PRE109]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Enables support for iteration of sub-ranges of the full `iterindex` range `[0,
    NpyIter_IterSize(iter))`. Use the function [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") to specify a range for iteration.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 启用对完整`iterindex`范围`[0, NpyIter_IterSize(iter))`的子范围的迭代支持。使用函数[`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange")来指定迭代范围。
- en: This flag can only be used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") when [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")
    is enabled. This is because without buffering, the inner loop is always the size
    of the innermost iteration dimension, and allowing it to get cut up would require
    special handling, effectively making it more like the buffered version.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")时，此标志只能与[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")一起使用。这是因为如果没有缓冲，内部循环总是内层迭代维度的大小，并且允许它被分割将需要特殊处理，实际上使其更像缓冲版本。
- en: '[PRE110]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Causes the iterator to store buffering data, and use buffering to satisfy data
    type, alignment, and byte-order requirements. To buffer an operand, do not specify
    the [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") flags, because they will override buffering. Buffering
    is especially useful for Python code using the iterator, allowing for larger chunks
    of data at once to amortize the Python interpreter overhead.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 导致迭代器存储缓冲区数据，并使用缓冲来满足数据类型、对齐和字节顺序要求。 要缓冲操作数，请不要指定[`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY")或[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY")标志，因为它们会覆盖缓冲。
    对于使用迭代器的Python代码，缓冲特别有用，允许一次处理更大的数据块以摊销Python解释器的开销。
- en: If used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    the inner loop for the caller may get larger chunks than would be possible without
    buffering, because of how the strides are laid out.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")一起使用，则调用者的内部循环可能会比没有缓冲区时得到更大的块，这是因为步幅的布局方式。
- en: Note that if an operand is given the flag [`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY"),
    a copy will be made in preference to buffering. Buffering will still occur when
    the array was broadcast so elements need to be duplicated to get a constant stride.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果给一个操作数设置了标志[`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY")或[`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY")，则首选制作副本而不是缓冲。 当数组进行广播时仍然会发生缓冲，因此需要复制元素以获得常量步幅。
- en: In normal buffering, the size of each inner loop is equal to the buffer size,
    or possibly larger if [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")
    is specified. If [`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")
    is enabled and a reduction occurs, the inner loops may become smaller depending
    on the structure of the reduction.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常缓冲中，每个内部循环的大小等于缓冲区大小，如果指定了[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")，则可能更大。
    如果启用了[`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")并发生了减少，内部循环的大小可能会变小，具体取决于减少的结构。
- en: '[PRE111]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When buffering is enabled, this allows the size of the inner loop to grow when
    buffering isn’t necessary. This option is best used if you’re doing a straight
    pass through all the data, rather than anything with small cache-friendly arrays
    of temporary values for each inner loop.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用缓冲时，这允许内部循环的大小在不需要缓冲时增长。 如果您正在直接通过所有数据进行传递，而不是对每个内部循环进行小的缓存友好数组的任何操作，则最好使用此选项。
- en: '[PRE112]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: When buffering is enabled, this delays allocation of the buffers until [`NpyIter_Reset`](#c.NpyIter_Reset
    "NpyIter_Reset") or another reset function is called. This flag exists to avoid
    wasteful copying of buffer data when making multiple copies of a buffered iterator
    for multi-threaded iteration.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用缓冲时，这将延迟分配缓冲区，直到调用了[`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")或另一个重置函数。
    此标志存在是为了在多线程迭代中制作多个缓冲迭代器的多个副本时避免浪费缓冲区数据的复制。
- en: Another use of this flag is for setting up reduction operations. After the iterator
    is created, and a reduction output is allocated automatically by the iterator
    (be sure to use READWRITE access), its value may be initialized to the reduction
    unit. Use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get the object. Then, call [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")
    to allocate and fill the buffers with their initial values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志的另一个用途是设置减少操作。 创建迭代器后，迭代器会自动分配减少输出（确保使用READWRITE访问），其值可以初始化为减少单位。 使用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")获取对象。 然后，调用[`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")来分配并填充缓冲区的初始值。
- en: '[PRE113]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If any write operand has overlap with any read operand, eliminate all overlap
    by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary).
    A pair of operands has overlap if there is a memory address that contains data
    common to both arrays.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何写操作数与任何读操作数存在重叠，通过制作临时副本来消除所有重叠（如果需要，为写操作数启用UPDATEIFCOPY）。 如果一对操作数存在重叠，则存在包含两个数组共有数据的内存地址。
- en: Because exact overlap detection has exponential runtime in the number of dimensions,
    the decision is made based on heuristics, which has false positives (needless
    copies in unusual cases) but has no false negatives.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于精确的重叠检测在维数的指数运行时，决策是基于启发式方法的，它具有误报（在不寻常情况下不必要的副本），但没有误报。
- en: If any read/write overlap exists, this flag ensures the result of the operation
    is the same as if all operands were copied. In cases where copies would need to
    be made, **the result of the computation may be undefined without this flag!**
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在读/写重叠，此标志确保操作的结果与所有操作数都被复制时相同。在需要进行复制的情况下，**没有此标志可能导致计算结果是未定义的！**
- en: 'Flags that may be passed in `op_flags[i]`, where `0 <= i < nop`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 `op_flags[i]` 中传递的标志，其中 `0 <= i < nop`：
- en: '[PRE114]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Indicate how the user of the iterator will read or write to `op[i]`. Exactly
    one of these flags must be specified per operand. Using `NPY_ITER_READWRITE` or
    `NPY_ITER_WRITEONLY` for a user-provided operand may trigger *WRITEBACKIFCOPY`*
    semantics. The data will be written back to the original array when `NpyIter_Deallocate`
    is called.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 指示迭代器的用户如何读取或写入 `op[i]`。每个操作数都必须指定其中一个标志。使用`NPY_ITER_READWRITE`或`NPY_ITER_WRITEONLY`用于用户提供的操作数可能触发*WRITEBACKIFCOPY*语义。在调用
    `NpyIter_Deallocate` 时，数据将写回原始数组。
- en: '[PRE117]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Allow a copy of `op[i]` to be made if it does not meet the data type or alignment
    requirements as specified by the constructor flags and parameters.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `op[i]` 不符合构造函数标志和参数指定的数据类型或对齐要求，则允许对 `op[i]` 进行复制。
- en: '[PRE118]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Triggers [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY"), and when an array
    operand is flagged for writing and is copied, causes the data in a copy to be
    copied back to `op[i]` when `NpyIter_Deallocate` is called.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 触发 [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY")，当一个数组操作数被标记为写入并被复制时，在调用
    `NpyIter_Deallocate` 时导致副本中的数据被复制回 `op[i]`。
- en: If the operand is flagged as write-only and a copy is needed, an uninitialized
    temporary array will be created and then copied to back to `op[i]` on calling
    `NpyIter_Deallocate`, instead of doing the unnecessary copy operation.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数被标记为只写，并且需要复制，将创建一个未初始化的临时数组，然后在调用 `NpyIter_Deallocate` 时将其复制回 `op[i]`，而不是进行不必要的复制操作。
- en: '[PRE119]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Causes the iterator to provide data for `op[i]` that is in native byte order,
    aligned according to the dtype requirements, contiguous, or any combination.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使迭代器提供适配于`op[i]`的数据，其是按照本机字节顺序对齐，符合dtype要求，并且是连续的，或者任何组合。
- en: By default, the iterator produces pointers into the arrays provided, which may
    be aligned or unaligned, and with any byte order. If copying or buffering is not
    enabled and the operand data doesn’t satisfy the constraints, an error will be
    raised.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，迭代器生成指向所提供数组的指针，这些指针可能对齐或者不对齐，并且具有任何字节顺序。如果未启用复制或缓冲，并且操作数数据不满足约束条件，则会引发错误。
- en: The contiguous constraint applies only to the inner loop, successive inner loops
    may have arbitrary pointer changes.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 连续约束仅适用于内部循环，连续的内循环可能具有任意的指针变化。
- en: If the requested data type is in non-native byte order, the NBO flag overrides
    it and the requested data type is converted to be in native byte order.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所请求的数据类型为非本机字节顺序，则 NBO 标志将覆盖它，并将所请求的数据类型转换为本机字节顺序。
- en: '[PRE122]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This is for output arrays, and requires that the flag [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY") or [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    be set. If `op[i]` is NULL, creates a new array with the final broadcast dimensions,
    and a layout matching the iteration order of the iterator.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将用于输出数组，并要求设置标志[`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY")或[`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE
    "NPY_ITER_READWRITE")。如果 `op[i]` 为 NULL，则创建一个具有最终广播维度和与迭代器的迭代顺序相匹配的布局的新数组。
- en: When `op[i]` is NULL, the requested data type `op_dtypes[i]` may be NULL as
    well, in which case it is automatically generated from the dtypes of the arrays
    which are flagged as readable. The rules for generating the dtype are the same
    is for UFuncs. Of special note is handling of byte order in the selected dtype.
    If there is exactly one input, the input’s dtype is used as is. Otherwise, if
    more than one input dtypes are combined together, the output will be in native
    byte order.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `op[i]` 为 NULL 时，所请求的数据类型`op_dtypes[i]` 也可能为 NULL，这种情况下会自动生成它，其来自被标记为可读取的数组的数据类型。生成数据类型的规则与
    UFuncs 相同。特别需要注意的是所选数据类型的字节序处理方法。如果只有一个输入，将直接使用输入的数据类型。否则，如果将多个输入数据类型组合在一起，则输出将采用本机字节序。
- en: After being allocated with this flag, the caller may retrieve the new array
    by calling [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    and getting the i-th object in the returned C array. The caller must call Py_INCREF
    on it to claim a reference to the array.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此标志分配后，调用者可以通过调用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")并获取返回的C数组中的第i个对象来检索新数组。调用者必须调用Py_INCREF来声明对数组的引用。
- en: '[PRE123]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: For use with [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE"),
    this flag disables allocating an array subtype for the output, forcing it to be
    a straight ndarray.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 用于[`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")，此标志禁用为输出分配数组子类型，强制其为一维ndarray。
- en: 'TODO: Maybe it would be better to introduce a function `NpyIter_GetWrappedOutput`
    and remove this flag?'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: TODO：也许引入一个函数`NpyIter_GetWrappedOutput`并删除此标志会更好？
- en: '[PRE124]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Ensures that the input or output matches the iteration dimensions exactly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 确保输入或输出与迭代维度完全匹配。
- en: '[PRE125]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: New in version 1.7.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.7开始。
- en: Indicates that this operand is the mask to use for selecting elements when writing
    to operands which have the [`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")
    flag applied to them. Only one operand may have [`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK") flag applied to it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 指示这个操作数是用于在写入应用了[`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")标志的操作数时使用的掩码。只有一个操作数可以应用[`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK")标志。
- en: The data type of an operand with this flag should be either [`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL
    "NPY_BOOL"), [`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK "NPY_MASK"), or a struct
    dtype whose fields are all valid mask dtypes. In the latter case, it must match
    up with a struct operand being WRITEMASKED, as it is specifying a mask for each
    field of that array.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此标志的操作数的数据类型应为[`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL "NPY_BOOL")，[`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK
    "NPY_MASK")或其字段都是有效掩码数据类型的结构数据类型。在后一种情况下，它必须与被WRITEMASKED的结构操作数匹配，因为它指定了该数组每个字段的掩码。
- en: This flag only affects writing from the buffer back to the array. This means
    that if the operand is also [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    or [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY"), code doing
    iteration can write to this operand to control which elements will be untouched
    and which ones will be modified. This is useful when the mask should be a combination
    of input masks.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记仅影响从缓冲区回写到数组。这意味着，如果操作数还是[`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")或[`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY")，则进行迭代的代码可以写入此操作数以控制哪些元素将不受影响，哪些将被修改。当掩码应该是输入掩码的组合时，这是有用的。
- en: '[PRE126]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: New in version 1.7.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.7开始。
- en: This array is the mask for all [`writemasked`](../generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") operands. Code uses the `writemasked` flag which indicates that
    only elements where the chosen ARRAYMASK operand is True will be written to. In
    general, the iterator does not enforce this, it is up to the code doing the iteration
    to follow that promise.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组是所有[`writemasked`](../generated/numpy.nditer.html#numpy.nditer "numpy.nditer")操作数的掩码。代码使用`writemasked`标志，指示只会写入选择的ARRAYMASK操作数为True的元素。一般来说，迭代器并不强制这一点，迭代的代码应该遵循这个承诺。
- en: When `writemasked` flag is used, and this operand is buffered, this changes
    how data is copied from the buffer into the array. A masked copying routine is
    used, which only copies the elements in the buffer for which `writemasked` returns
    true from the corresponding element in the ARRAYMASK operand.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`writemasked`标志并且此操作数被缓冲时，这会改变数据从缓冲区复制到数组的方式。会使用一个带掩码的复制例程，仅复制缓冲区中`writemasked`从相应的ARRAYMASK操作数返回True的元素。
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In memory overlap checks, assume that operands with `NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`
    enabled are accessed only in the iterator order.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存重叠检查中，假设启用了`NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`的操作数只能按照迭代器顺序访问。
- en: This enables the iterator to reason about data dependency, possibly avoiding
    unnecessary copies.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得迭代器能够推理数据依赖性，可能避免不必要的复制。
- en: This flag has effect only if `NPY_ITER_COPY_IF_OVERLAP` is enabled on the iterator.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当迭代器上启用了`NPY_ITER_COPY_IF_OVERLAP`时，此标志生效。
- en: '[PRE128]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Extends [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") with several
    advanced options providing more control over broadcasting and buffering.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供几个高级选项，扩展了[`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") ，提供了更多对广播和缓冲的控制。
- en: If -1/NULL values are passed to `oa_ndim`, `op_axes`, `itershape`, and `buffersize`,
    it is equivalent to [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew").
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将-1/NULL值传递给`oa_ndim`、`op_axes`、`itershape`和`buffersize`，则相当于[`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew")。
- en: The parameter `oa_ndim`, when not zero or -1, specifies the number of dimensions
    that will be iterated with customized broadcasting. If it is provided, `op_axes`
    must and `itershape` can also be provided. The `op_axes` parameter let you control
    in detail how the axes of the operand arrays get matched together and iterated.
    In `op_axes`, you must provide an array of `nop` pointers to `oa_ndim`-sized arrays
    of type `npy_intp`. If an entry in `op_axes` is NULL, normal broadcasting rules
    will apply. In `op_axes[j][i]` is stored either a valid axis of `op[j]`, or -1
    which means `newaxis`. Within each `op_axes[j]` array, axes may not be repeated.
    The following example is how normal broadcasting applies to a 3-D array, a 2-D
    array, a 1-D array and a scalar.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数`oa_ndim`不为零或-1时，指定将使用定制广播迭代的维度数量。如果提供了`op_axes`，则必须提供`itershape`。`op_axes`参数允许您详细控制操作数数组的轴如何匹配在一起并进行迭代。在`op_axes`中，必须提供`nop`指针数组，指向大小为`oa_ndim`的`npy_intp`类型数组。如果`op_axes`中的条目为NULL，则将应用正常的广播规则。`op_axes[j][i]`中存储了`op[j]`的有效轴，或者是-1表示`newaxis`。在每个`op_axes[j]`数组中，轴不能重复。以下示例是正常广播应用到3D数组、2D数组、1D数组和标量的情况。
- en: '**Note**: Before NumPy 1.8 `oa_ndim == 0` was used for signalling that ``op_axes`
    and `itershape` are unused. This is deprecated and should be replaced with -1\.
    Better backward compatibility may be achieved by using [`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew") for this case.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在NumPy 1.8之前，`oa_ndim == 0`用于表示``op_axes`和`itershape`未使用。这已经不推荐使用，应替换为-1。最好使用[`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew")来实现更好的向后兼容性。'
- en: '[PRE129]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `itershape` parameter allows you to force the iterator to have a specific
    iteration shape. It is an array of length `oa_ndim`. When an entry is negative,
    its value is determined from the operands. This parameter allows automatically
    allocated outputs to get additional dimensions which don’t match up with any dimension
    of an input.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`itershape`参数允许您强制迭代器具有特定的迭代形状。它的长度为`oa_ndim`。当一个条目是负数时，它的值将根据操作数确定。此参数允许自动分配的输出获得与任何输入维度不匹配的附加维度。'
- en: If `buffersize` is zero, a default buffer size is used, otherwise it specifies
    how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192
    are recommended.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`buffersize`为零，则使用默认缓冲区大小，否则它指定要使用多大的缓冲区。建议使用2的幂大小的缓冲区，例如4096或8192。
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在错误则返回NULL，否则返回分配的迭代器。
- en: '[PRE130]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Makes a copy of the given iterator. This function is provided primarily to enable
    multi-threaded iteration of the data.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 复制给定迭代器。此函数主要用于使数据多线程迭代。
- en: '*TODO*: Move this to a section about multithreaded iteration.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*TODO*：将此内容移到关于多线程迭代的部分。'
- en: The recommended approach to multithreaded iteration is to first create an iterator
    with the flags [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED"), [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED"), [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    and possibly [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER").
    Create a copy of this iterator for each thread (minus one for the first iterator).
    Then, take the iteration index range `[0, NpyIter_GetIterSize(iter))` and split
    it up into tasks, for example using a TBB parallel_for loop. When a thread gets
    a task to execute, it then uses its copy of the iterator by calling [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") and iterating over the full range.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程迭代的推荐方法是首先使用标记[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")、[`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED")、[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")、[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC")，可能还有[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")创建一个迭代器。为每个线程创建此迭代器的副本（第一个迭代器减去一）。然后，将迭代索引范围`[0，NpyIter_GetIterSize(iter))`分割成任务，例如使用TBB
    parallel_for循环。当一个线程获得要执行的任务时，它将使用其迭代器的副本，通过调用[`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange")并迭代整个范围。
- en: When using the iterator in multi-threaded code or in code not holding the Python
    GIL, care must be taken to only call functions which are safe in that context.
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") cannot be safely called without
    the Python GIL, because it increments Python references. The `Reset*` and some
    other functions may be safely called by passing in the `errmsg` parameter as non-NULL,
    so that the functions will pass back errors through it instead of setting a Python
    exception.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程代码或不持有 Python GIL 的代码中使用迭代器时，必须小心地只调用在该上下文中安全的函数。不能在没有 Python GIL 的情况下安全调用
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy")，因为它会增加 Python 引用。`Reset*` 和一些其他函数可以安全调用，通过传递非
    NULL 的 `errmsg` 参数，这样函数将通过它传回错误，而不是设置 Python 异常。
- en: '[`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate") must be
    called for each copy.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 必须为每个副本调用 [`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate")。
- en: '[PRE131]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Removes an axis from iteration. This requires that [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") was set for iterator creation, and does not work if buffering
    is enabled or an index is being tracked. This function also resets the iterator
    to its initial state.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 从迭代中移除一个轴。这要求在迭代器创建时设置了 [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")，并且在启用缓冲或正在跟踪索引时无法工作。此函数还将迭代器重置回初始状态。
- en: This is useful for setting up an accumulation loop, for example. The iterator
    can first be created with all the dimensions, including the accumulation axis,
    so that the output gets created correctly. Then, the accumulation axis can be
    removed, and the calculation done in a nested fashion.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 例如用于设置累积循环很有用。迭代器可以首先使用所有维度创建，包括累积轴，以便正确创建输出。然后，可以移除累积轴，并采用嵌套的方式进行计算。
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again! The
    iterator range will be reset as well.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数可能会更改迭代器的内部内存布局。必须重新获取迭代器的任何缓存功能或指针！迭代范围也将被重置。'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE132]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: If the iterator is tracking a multi-index, this strips support for them, and
    does further iterator optimizations that are possible if multi-indices are not
    needed. This function also resets the iterator to its initial state.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器正在跟踪多重索引，则会取消对它们的支持，并对迭代器进行可能的进一步优化，如果不需要多重索引的话。此函数还将迭代器重置回初始状态。
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again!'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数可能会更改迭代器的内部内存布局。必须重新获取迭代器的任何缓存功能或指针！'
- en: After calling this function, [NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex
    "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex "iter")) will return
    false.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数后，[NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex
    "iter")) 将返回 false。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE133]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: If [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    was called, you may want to enable the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP"). This flag is not permitted together with [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX"), so this function is provided to enable the feature after
    [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    is called. This function also resets the iterator to its initial state.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用了 [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")，您可能希望启用标志
    [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")。这个标志与
    [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX") 不允许一起使用，因此在调用了
    [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    之后提供此函数以启用该功能。此函数还将迭代器重置回初始状态。
- en: '**WARNING**: This function changes the internal logic of the iterator. Any
    cached functions or pointers from the iterator must be retrieved again!'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：此函数更改了迭代器的内部逻辑。必须重新获取迭代器的任何缓存功能或指针！'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE134]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Deallocates the iterator object and resolves any needed writebacks.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 释放迭代器对象并解决任何需要的写回。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `NPY_SUCCEED` 或 `NPY_FAIL`。
- en: '[PRE135]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Resets the iterator back to its initial state, at the beginning of the iteration
    range.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器重置回初始状态，即迭代范围的开始处。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。如果 `errmsg` 非空，则当返回`NPY_FAIL`时不会设置任何 Python 异常。相反，*errmsg*
    会被设置为错误消息。当 `errmsg` 非空时，可以在不持有 Python GIL 的情况下安全地调用该函数。
- en: '[PRE136]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Resets the iterator and restricts it to the `iterindex` range `[istart, iend)`.
    See [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") for an explanation of how
    to use this for multi-threaded iteration. This requires that the flag [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was passed to the iterator constructor.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 重置迭代器并将其限制在`iterindex`范围`[istart, iend)`。有关如何在多线程迭代中使用此功能的解释，请参阅[`NpyIter_Copy`](#c.NpyIter_Copy
    "NpyIter_Copy")。这要求在迭代器构造函数中传递了标志[`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED")。
- en: If you want to reset both the `iterindex` range and the base pointers at the
    same time, you can do the following to avoid extra buffer copying (be sure to
    add the return code error checks when you copy this code).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要同时重置`iterindex`范围和基本指针，可以执行以下操作以避免额外的缓冲区复制（在复制此代码时，请务必添加返回码错误检查）。
- en: '[PRE137]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。如果 `errmsg` 非空，则当返回`NPY_FAIL`时不会设置任何 Python 异常。相反，*errmsg*
    会被设置为错误消息。当 `errmsg` 非空时，可以在不持有 Python GIL 的情况下安全地调用该函数。
- en: '[PRE138]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Resets the iterator back to its initial state, but using the values in `baseptrs`
    for the data instead of the pointers from the arrays being iterated. This functions
    is intended to be used, together with the `op_axes` parameter, by nested iteration
    code with two or more iterators.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器重置回初始状态，但使用`baseptrs`中的值作为数据，而不是被迭代的数组中的指针。这个函数有意与 `op_axes` 参数一起被嵌套迭代代码使用，其中有两个或更多个迭代器。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。如果 `errmsg` 非空，则当返回`NPY_FAIL`时不会设置任何 Python 异常。相反，*errmsg*
    会被设置为错误消息。当 `errmsg` 非空时，可以在不持有 Python GIL 的情况下安全地调用该函数。
- en: '*TODO*: Move the following into a special section on nested iterators.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*TODO*：将以下内容移入关于嵌套迭代器的特殊部分中。'
- en: Creating iterators for nested iteration requires some care. All the iterator
    operands must match exactly, or the calls to [`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers") will be invalid. This means that automatic copies
    and output allocation should not be used haphazardly. It is possible to still
    use the automatic data conversion and casting features of the iterator by creating
    one of the iterators with all the conversion parameters enabled, then grabbing
    the allocated operands with the [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray") function and passing them into the constructors for
    the rest of the iterators.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 创建嵌套迭代的迭代器需要一些注意。所有的迭代器操作数必须完全匹配，否则调用[`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers") 将无效。这意味着不应该随意使用自动复制和输出分配。仍然可以通过启用所有转换参数创建迭代器之一，然后用[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")函数获取分配的操作数，并将它们传递到其余迭代器的构造函数中来使用迭代器的自动数据转换和转换功能。
- en: '**WARNING**: When creating iterators for nested iteration, the code must not
    use a dimension more than once in the different iterators. If this is done, nested
    iteration will produce out-of-bounds pointers during iteration.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：在创建用于嵌套迭代的迭代器时，代码不能在不同的迭代器中多次使用相同的维度。如果这样做，嵌套迭代将在迭代期间产生越界指针。'
- en: '**WARNING**: When creating iterators for nested iteration, buffering can only
    be applied to the innermost iterator. If a buffered iterator is used as the source
    for `baseptrs`, it will point into a small buffer instead of the array and the
    inner iteration will be invalid.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：在创建用于嵌套迭代的迭代器时，缓冲区只能应用于最内部的迭代器。如果一个带有缓冲区的迭代器作为`baseptrs`的源，则它将指向一个小缓冲区，而不是数组，内部迭代将无效。'
- en: The pattern for using nested iterators is as follows.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套迭代器的模式如下。
- en: '[PRE139]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Adjusts the iterator to point to the `ndim` indices pointed to by `multi_index`.
    Returns an error if a multi-index is not being tracked, the indices are out of
    bounds, or inner loop iteration is disabled.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器调整到由`multi_index`指向的`ndim`索引。如果未正在追踪多索引，索引超出范围，或内部循环迭代被禁用，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE141]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Adjusts the iterator to point to the `index` specified. If the iterator was
    constructed with the flag [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    `index` is the C-order index, and if the iterator was constructed with the flag
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), `index` is the Fortran-order
    index. Returns an error if there is no index being tracked, the index is out of
    bounds, or inner loop iteration is disabled.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器调整到指定的`index`。如果迭代器是使用标记[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")构造的，则`index`是C顺序索引；如果迭代器是使用标记[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX")构造的，则`index`是Fortran顺序索引。如果没有正在追踪的索引，索引超出范围，或者内部循环迭代被禁用，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE142]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Returns the number of elements being iterated. This is the product of all the
    dimensions in the shape. When a multi index is being tracked (and *NpyIter_RemoveAxis*
    may be called) the size may be `-1` to indicate an iterator is too large. Such
    an iterator is invalid, but may become valid after *NpyIter_RemoveAxis* is called.
    It is not necessary to check for this case.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 返回正在迭代的元素数量。这是形状中所有维度的乘积。当正在追踪多个索引（并且可能调用*NpyIter_RemoveAxis*）时，大小可能为`-1`，表示迭代器过大。这样的迭代器无效，但在调用*NpyIter_RemoveAxis*后可能变为有效。不必检查这种情况。
- en: '[PRE143]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Gets the `iterindex` of the iterator, which is an index matching the iteration
    order of the iterator.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 获取迭代器的`iterindex`，即与迭代器的迭代顺序匹配的索引。
- en: '[PRE144]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Gets the `iterindex` sub-range that is being iterated. If [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was not specified, this always returns the range `[0, NpyIter_IterSize(iter))`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 获取正在迭代的`iterindex`子范围。如果未指定标记[`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED")，则始终返回范围`[0,
    NpyIter_IterSize(iter))`。
- en: '[PRE145]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Adjusts the iterator to point to the `iterindex` specified. The IterIndex is
    an index matching the iteration order of the iterator. Returns an error if the
    `iterindex` is out of bounds, buffering is enabled, or inner loop iteration is
    disabled.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 调整迭代器以指向指定的`iterindex`。IterIndex是将迭代器的迭代顺序匹配的索引。如果`iterindex`超出范围，启用了缓冲，或内部循环迭代被禁用，则返回错误。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE146]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Returns 1 if the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was passed to the iterator constructor, and no call
    to one of the Reset functions has been done yet, 0 otherwise.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标记[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC")被传递给迭代器构造函数，并且还没有调用其中一个Reset函数，则返回1；否则返回0。
- en: '[PRE147]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Returns 1 if the caller needs to handle the inner-most 1-dimensional loop, or
    0 if the iterator handles all looping. This is controlled by the constructor flag
    [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    or [`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop "NpyIter_EnableExternalLoop").
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 根据构造函数标记[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")或[`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop
    "NpyIter_EnableExternalLoop")，返回1表示调用者需要处理最内层的一维循环，返回0表示迭代器处理所有循环。
- en: '[PRE148]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag, 0 otherwise.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是使用标记[`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")创建的，则返回1，否则返回0。
- en: '[PRE149]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    flag, 0 otherwise.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是使用标记[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX")或[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX
    "NPY_ITER_F_INDEX")创建的，则返回1，否则返回0。
- en: '[PRE150]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Returns 1 if the iterator requires buffering, which occurs when an operand needs
    conversion or alignment and so cannot be used directly.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器需要缓冲，则返回1，即当操作数需要转换或对齐时无法直接使用。
- en: '[PRE151]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") flag, 0 otherwise.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是使用标记[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")创建的，则返回1，否则返回0。
- en: '[PRE152]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Returns 1 if the iterator was created with the [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER") flag, 0 otherwise.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器是使用标记[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")创建的，则返回1，否则返回0。
- en: '[PRE153]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: If the iterator is buffered, returns the size of the buffer being used, otherwise
    returns 0.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器已缓冲，则返回正在使用的缓冲区的大小，否则返回0。
- en: '[PRE154]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Returns the number of dimensions being iterated. If a multi-index was not requested
    in the iterator constructor, this value may be smaller than the number of dimensions
    in the original objects.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 返回正在迭代的维数。如果在迭代器构造函数中未请求多索引，则此值可能小于原始对象中的维数。
- en: '[PRE155]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Returns the number of operands in the iterator.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 返回迭代器中的操作数数量。
- en: '[PRE156]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Gets the array of strides for the specified axis. Requires that the iterator
    be tracking a multi-index, and that buffering not be enabled.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 获取指定轴的步幅数组。要求迭代器跟踪多索引，并且缓冲未启用。
- en: This may be used when you want to match up operand axes in some fashion, then
    remove them with [`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")
    to handle their processing manually. By calling this function before removing
    the axes, you can get the strides for the manual processing.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在您希望以某种方式匹配操作数轴，然后使用 [`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")
    手动处理它们时，可以使用此函数。在移除轴之前调用此函数，可以获取手动处理的步幅。
- en: Returns `NULL` on error.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 错误时返回`NULL`。
- en: '[PRE157]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Returns the broadcast shape of the iterator in `outshape`. This can only be
    called on an iterator which is tracking a multi-index.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在`outshape`中返回迭代器的广播形状。只能在跟踪多索引的迭代器上调用此函数。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE158]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This gives back a pointer to the `nop` data type Descrs for the objects being
    iterated. The result points into `iter`, so the caller does not gain any references
    to the Descrs.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这会返回正在迭代的对象的`nop`数据类型Descrs的指针。结果指向`iter`，因此调用者不会获得任何对Descrs的引用。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代循环之前，此指针可以被缓存，调用`iternext`不会更改它。
- en: '[PRE159]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This gives back a pointer to the `nop` operand PyObjects that are being iterated.
    The result points into `iter`, so the caller does not gain any references to the
    PyObjects.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将指针返回到正在迭代的`nop`操作数 PyObjects。结果指向`iter`，因此调用者不会获得任何对PyObjects的引用。
- en: '[PRE160]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This gives back a reference to a new ndarray view, which is a view into the
    i-th object in the array [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray"), whose dimensions and strides match the internal optimized
    iteration pattern. A C-order iteration of this view is equivalent to the iterator’s
    iteration order.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回一个新的ndarray视图的引用，该视图是数组[`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray")中第i个对象的视图，其维度和步幅与内部优化的迭代模式相匹配。此视图的C顺序迭代等同于迭代器的迭代顺序。
- en: For example, if an iterator was created with a single array as its input, and
    it was possible to rearrange all its axes and then collapse it into a single strided
    iteration, this would return a view that is a one-dimensional array.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果使用单个数组作为输入创建了迭代器，并且可能对其所有轴进行重排，然后将其合并为一个单一的跨度迭代，这将返回一个视图，即一维数组。
- en: '[PRE161]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Fills `nop` flags. Sets `outreadflags[i]` to 1 if `op[i]` can be read from,
    and to 0 if not.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`nop`标志。如果可以从`op[i]`读取，则将`outreadflags[i]`设置为1，否则设置为0。
- en: '[PRE162]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Fills `nop` flags. Sets `outwriteflags[i]` to 1 if `op[i]` can be written to,
    and to 0 if not.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`nop`标志。如果可以向`op[i]`写入，则将`outwriteflags[i]`设置为1，否则设置为0。
- en: '[PRE163]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Builds a set of strides which are the same as the strides of an output array
    created using the [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")
    flag, where NULL was passed for op_axes. This is for data packed contiguously,
    but not necessarily in C or Fortran order. This should be used together with [`NpyIter_GetShape`](#c.NpyIter_GetShape
    "NpyIter_GetShape") and [`NpyIter_GetNDim`](#c.NpyIter_GetNDim "NpyIter_GetNDim")
    with the flag [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    passed into the constructor.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 构建与使用 [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE") 标志创建的输出数组的步幅相同的步幅集，其中为op_axes传递了NULL。这用于连续打包的数据，但不一定按照C或Fortran顺序。这应该与传递到构造函数的标志
    [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX") 一起使用，以及
    [`NpyIter_GetShape`](#c.NpyIter_GetShape "NpyIter_GetShape") 和 [`NpyIter_GetNDim`](#c.NpyIter_GetNDim
    "NpyIter_GetNDim")。
- en: A use case for this function is to match the shape and layout of the iterator
    and tack on one or more dimensions. For example, in order to generate a vector
    per input value for a numerical gradient, you pass in ndim*itemsize for itemsize,
    then add another dimension to the end with size ndim and stride itemsize. To do
    the Hessian matrix, you do the same thing but add two dimensions, or take advantage
    of the symmetry and pack it into 1 dimension with a particular encoding.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的用例是匹配迭代器的形状和布局，并附加一个或多个维度。例如，为了为数值梯度每个输入值生成一个向量，您需要传入ndim*itemsize作为itemsize，然后在末尾添加另一个大小为ndim，步幅为itemsize的维度。对于Hessian矩阵，做同样的事情，但是增加两个维度，或者利用对称性并将其打包到一个特定编码的维度中。
- en: This function may only be called if the iterator is tracking a multi-index and
    if [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES "NPY_ITER_DONT_NEGATE_STRIDES")
    was used to prevent an axis from being iterated in reverse order.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在迭代器正在跟踪多索引并且使用了[`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES")以防止轴逆序迭代时，才能调用此函数。
- en: If an array is created with this method, simply adding ‘itemsize’ for each iteration
    will traverse the new array matching the iterator.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此方法创建数组，则仅需添加每次迭代的‘itemsize’即可遍历与迭代器匹配的新数组。
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`NPY_SUCCEED`或`NPY_FAIL`。
- en: '[PRE164]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: New in version 1.7.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中的新内容。
- en: Checks to see whether this is the first time the elements of the specified reduction
    operand which the iterator points at are being seen for the first time. The function
    returns a reasonable answer for reduction operands and when buffering is disabled.
    The answer may be incorrect for buffered non-reduction operands.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否是迭代器指向的指定减少操作数的元素第一次被看到。该函数对于减少操作数和禁用缓冲的情况会返回一个合理的答案。对于缓冲的非减少操作数，答案可能是不正确的。
- en: This function is intended to be used in EXTERNAL_LOOP mode only, and will produce
    some wrong answers when that mode is not enabled.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅用于EXTERNAL_LOOP模式，并且在未启用该模式时将产生一些错误的答案。
- en: If this function returns true, the caller should also check the inner loop stride
    of the operand, because if that stride is 0, then only the first element of the
    innermost external loop is being visited for the first time.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此函数返回true，则调用者还应检查操作数的内循环步幅，因为如果该步幅为0，则仅首次访问最内层外部循环的第一个元素。
- en: '*WARNING*: For performance reasons, ‘iop’ is not bounds-checked, it is not
    confirmed that ‘iop’ is actually a reduction operand, and it is not confirmed
    that EXTERNAL_LOOP mode is enabled. These checks are the responsibility of the
    caller, and should be done outside of any inner loops.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告*：出于性能原因，’iop’没有进行边界检查，没有确认‘iop’实际上是减少操作数，也没有确认是否启用了EXTERNAL_LOOP模式。这些检查是调用者的责任，并应在任何内部循环之外完成。'
- en: Functions For Iteration
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代函数
- en: '[PRE165]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Returns a function pointer for iteration. A specialized version of the function
    pointer may be calculated by this function instead of being stored in the iterator
    structure. Thus, to get good performance, it is required that the function pointer
    be saved in a variable rather than retrieved for each loop iteration.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个用于迭代的函数指针。这个函数计算了函数指针的专门版本，而不是将其存储在迭代器结构中。因此，为了获得良好的性能，必须将函数指针保存在变量中，而不是在每次循环迭代中获取它。
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误则返回NULL。如果errmsg非NULL，在返回`NPY_FAIL`时不会设置Python异常。相反，*errmsg会被设置为错误消息。当errmsg非NULL时，可以在不持有Python
    GIL的情况下安全地调用该函数。
- en: The typical looping construct is as follows.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的循环结构如下。
- en: '[PRE166]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: When [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is specified, the typical inner loop construct is as follows.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")时，典型的内部循环结构如下。
- en: '[PRE167]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Observe that we are using the dataptr array inside the iterator, not copying
    the values to a local temporary. This is possible because when `iternext()` is
    called, these pointers will be overwritten with fresh values, not incrementally
    updated.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在迭代器内部使用了dataptr数组，而不是将值复制到局部临时变量。这是因为当调用`iternext()`时，这些指针将被覆盖为新值，而不是逐渐更新。
- en: If a compile-time fixed buffer is being used (both flags [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") and [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")), the inner size may be used as a signal as well. The
    size is guaranteed to become zero when `iternext()` returns false, enabling the
    following loop construct. Note that if you use this construct, you should not
    pass [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER") as a flag,
    because it will cause larger sizes under some circumstances.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用编译时固定缓冲区（标志[`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")和[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")），则内部大小也可以用作信号。当`iternext()`返回false时，保证大小将变为零，从而启用以下循环结构。请注意，如果使用此结构，不应将[`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER")作为标志传递，因为在某些情况下会导致较大的大小。
- en: '[PRE168]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Returns a function pointer for getting the current multi-index of the iterator.
    Returns NULL if the iterator is not tracking a multi-index. It is recommended
    that this function pointer be cached in a local variable before the iteration
    loop.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 返回获取迭代器当前多索引的函数指针。如果迭代器未跟踪多索引，则返回NULL。建议在迭代循环之前将此函数指针缓存到一个本地变量中。
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，则返回NULL。如果`NPY_FAIL`返回，则不设置Python异常。相反，*errmsg* 被设置为错误消息。当*errmsg*非NULL时，可以安全地调用该函数，而无需持有Python
    GIL。
- en: '[PRE170]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This gives back a pointer to the `nop` data pointers. If [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") was not specified, each data pointer points to the current
    data item of the iterator. If no inner iteration was specified, it points to the
    first data item of the inner loop.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个指向`nop`数据指针的指针。如果未指定[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")，则每个数据指针指向迭代器的当前数据项。如果未指定内部迭代，则指向内部循环的第一个数据项。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 此指针可能在迭代循环之前被缓存，调用`iternext`不会改变它。此函数可在不持有Python GIL的情况下安全调用。
- en: '[PRE171]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Gets the array of data pointers directly into the arrays (never into the buffers),
    corresponding to iteration index 0.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 直接获取数据指针数组进入数组（永远不会进入缓冲区），对应于迭代索引0。
- en: These pointers are different from the pointers accepted by `NpyIter_ResetBasePointers`,
    because the direction along some axes may have been reversed.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指针与`NpyIter_ResetBasePointers`接受的指针不同，因为某些轴上的方向可能已被反转。
- en: This function may be safely called without holding the Python GIL.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可在不持有Python GIL的情况下安全调用。
- en: '[PRE172]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: This gives back a pointer to the index being tracked, or NULL if no index is
    being tracked. It is only usable if one of the flags [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    were specified during construction.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个指针，指向正在跟踪的索引，如果没有跟踪索引，则返回NULL。仅当在构造期间指定了标志[`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX")或[`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")之一时才可用。
- en: When the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is used, the code needs to know the parameters for doing the inner loop. These
    functions provide that information.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用标志[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")时，代码需要知道执行内部循环的参数。这些函数提供了该信息。
- en: '[PRE173]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Returns a pointer to an array of the `nop` strides, one for each iterated object,
    to be used by the inner loop.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向`nop`步长数组的指针，每个迭代对象一个，用于内部循环使用。
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 此指针可能在迭代循环之前被缓存，调用`iternext`不会改变它。此函数可在不持有Python GIL的情况下安全调用。
- en: '**WARNING**: While the pointer may be cached, its values may change if the
    iterator is buffered.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：虽然指针可能被缓存，但如果迭代器被缓冲，其值可能会发生变化。'
- en: '[PRE174]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Returns a pointer to the number of iterations the inner loop should execute.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指针，指向内部循环应执行的迭代次数。
- en: This address may be cached before the iteration loop, calling `iternext` will
    not change it. The value itself may change during iteration, in particular if
    buffering is enabled. This function may be safely called without holding the Python
    GIL.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 此地址可以在迭代循环之前进行缓存，调用`iternext`不会更改它。值本身可能会在迭代过程中更改，特别是如果启用了缓冲。可以在没有持有Python GIL的情况下安全调用此函数。
- en: '[PRE175]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Gets an array of strides which are fixed, or will not change during the entire
    iteration. For strides that may change, the value NPY_MAX_INTP is placed in the
    stride.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个在整个迭代过程中是固定或不会更改的步长数组。对于可能会更改的步长，会将值NPY_MAX_INTP放入步长中。
- en: Once the iterator is prepared for iteration (after a reset if [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was used), call this to get the strides which may be
    used to select a fast inner loop function. For example, if the stride is 0, that
    means the inner loop can always load its value into a variable once, then use
    the variable throughout the loop, or if the stride equals the itemsize, a contiguous
    version for that operand may be used.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦迭代器准备好进行迭代（如果使用了[`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC")后的重置），调用此函数以获取可用于选择快速内循环函数的步长。例如，如果步长为0，这意味着内循环总是可以将其值加载到变量中一次，然后在整个循环中使用该变量，或者如果步长等于项目大小，则该操作数的连续版本可能会被使用。
- en: This function may be safely called without holding the Python GIL.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在没有持有Python GIL的情况下安全调用此函数。
- en: '## Converting from Previous NumPy Iterators'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '## 从先前的NumPy迭代器进行转换'
- en: The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter*
    and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast,
    and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality
    with a single object and associated API. One goal of the new API is that all uses
    of the existing iterator should be replaceable with the new iterator without significant
    effort. In 1.6, the major exception to this is the neighborhood iterator, which
    does not have corresponding features in this iterator.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的迭代器API包括函数如PyArrayIter_Check，PyArray_Iter*和PyArray_ITER_*。多迭代器数组包括PyArray_MultiIter*，PyArray_Broadcast和PyArray_RemoveSmallest。新的迭代器设计将所有这些功能及其相关API替换为单个对象。新API的一个目标是，现有迭代器的所有用法都应该可以在不费力的情况下用新迭代器替代。在1.6中，对此的主要例外是邻域迭代器，在这个迭代器中没有相应的功能。
- en: 'Here is a conversion table for which functions to use with the new iterator:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于新迭代器的函数使用转换表：
- en: '| *Iterator Functions* |  |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| *迭代器函数* |  |'
- en: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
- en: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` parameter **or** Iterator
    flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` 参数**或**迭代器标志[`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") |'
- en: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **NOT SUPPORTED** (Use the support for multiple operands instead.) |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **不支持**（请改用多个操作数的支持） |'
- en: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | Will need to add this in Python exposure |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | 需要在Python公开中添加此内容 |'
- en: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
- en: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | 从[`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")得到的函数指针
    |'
- en: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
- en: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
- en: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") 或 [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
- en: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | Return value of `iternext` function pointer |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | `iternext` 函数指针的返回值 |'
- en: '| *Multi-iterator Functions* |  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| *多迭代器函数* |  |'
- en: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
- en: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
- en: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | 来自 [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext") 的函数指针
    |'
- en: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
- en: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **NOT SUPPORTED** (always lock-step iteration) |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **不支持**（总是锁步迭代）|'
- en: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
- en: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") 或 [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
- en: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | Return value of `iternext` function pointer |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | `iternext` 函数指针的返回值 |'
- en: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | Handled by [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | 由 [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") 处理 |'
- en: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | Iterator flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | 迭代器标记 [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
- en: '| *Other Functions* |  |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| *其他功能* |  |'
- en: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | Iterator flag [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | 迭代器标记 [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
