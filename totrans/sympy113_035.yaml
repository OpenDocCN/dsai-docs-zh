- en: Solve a Diophantine Equation Algebraically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/solve-diophantine-equation.html](https://docs.sympy.org/latest/guides/solving/solve-diophantine-equation.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use SymPy to solve a [Diophantine equation](https://en.wikipedia.org/wiki/Diophantine_equation)
    (find integer solutions to a polynomial equation) algebraically, returning a parameterized
    general solution if possible. For example, solving the [Pythagorean equation](https://en.wikipedia.org/wiki/Pythagorean_theorem)
    \(a^2 + b^2 = c^2\) yields \((a=2pq, b=p^2-q^2, c=p^2+q^2)\). Here, \(p\) and
    \(q\) are new parameters introduced in the solution. \(p\) and \(q\) can take
    on any integer value to parameterize the full set of solutions. More formally,
    \(p,q \in \mathbb{Z}\) parameterize the infinite set of [Pythagorean triples](https://en.wikipedia.org/wiki/Pythagorean_triple).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Consider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are few alternatives for finding a parameterized general solution a Diophantine
    equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerical alternatives:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sage’s EllipticCurve command](https://doc.sagemath.org/html/en/constructions/elliptic_curves.html)
    may be able to find a set of relative numerical values for each variable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can test explicit integer values, for example using a nested for loop of
    ranges of values. This is inefficient, but fine if you are only interested in
    solutions that are relatively small.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") treats the variables as real or complex numbers,
    and simply solves for one variable in terms of the others, which produces a different
    type of solution. For example, attempting to solve \(a^2 + b^2 = c^2\) for \(a\),
    \(b\), and \(c\) can only reveal that \(a = \pm \sqrt{c^2-b^2}\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example of Solving a Diophantine Equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of solving a Diophantine equation, specifically \(a^2 +
    b^2 = c^2\), using [`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Refer to the [Diophantine API reference](../../modules/solvers/diophantine.html)
    for more examples of solving various types of Diophantine equations.
  prefs: []
  type: TYPE_NORMAL
- en: Guidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Diophantine Equation Can be Expressed as Expression That Equals Zero
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you already have an expression that equals zero, you can solve that expression.
    For example, expressing the Pythagorean equation as \(a^2 + b^2 - c^2\) is also
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Specify the Order of Symbols in the Result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend you specify the order of symbols in the result to avoid confusion.
    Use the `syms` parameter and pass it a tuple or list of symbols to ensure the
    result will be in that order, for example `syms=my_syms`, as in the examples on
    this page.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, following five types of Diophantine equations can be solved using
    [`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine") and other helper functions
    of the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear Diophantine equations: \(a_1x_1 + a_2x_2 + \ldots + a_nx_n = b\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General binary quadratic equation: \(ax^2 + bxy + cy^2 + dx + ey + f = 0\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Homogeneous ternary quadratic equation: \(ax^2 + by^2 + cz^2 + dxy + eyz +
    fzx = 0\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extended Pythagorean equation: \(a_{1}x_{1}^2 + a_{2}x_{2}^2 + \ldots + a_{n}x_{n}^2
    = a_{n+1}x_{n+1}^2\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General sum of squares: \(x_{1}^2 + x_{2}^2 + \ldots + x_{n}^2 = k\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Solution Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract Expressions From the Result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine") returns results as a set
    of tuples, where each element in a tuple is an expression for a variable in your
    equation. For example, for the Pythogorean equation, the result is a set containing
    one tuple where the expressions correspond to (a, b, c). That is, the tuple represents
    `a = 2*p*q, b = p**2 - q**2, c = p**2-q**2`. Because you cannot extract an element
    (here, a tuple) from a set by subscripting the set, you can create a dictionary
    of symbol-expression pairs to extract an expression by its symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Less elegantly, you can convert the set to a list, and then subscript the list.
    It is a common mistake to forget the order of parameters, so this method is more
    prone to errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Work With Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can manipulate parameters such as `p` and `q`, which are generated automatically
    by [`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine"), by creating them as symbols.
    For example, to find a particular set of values that satisfies the Diophantine
    equation, you can substitute in values for the parameters by
  prefs: []
  type: TYPE_NORMAL
- en: creating the parameters as symbols
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: substituting in their values using [`subs()`](../../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we express the set of values as a dictionary to associate each variable
    (\(a, b, c\)) with its example value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need to include the `integer=True` assumption for the generated
    parameters (`p` and `q`) to substitute numerical values for them. Conversely,
    you do not need to include the `integer=True` assumption for the symbols in the
    original equation (`a`, `b`, and `c`), although it is a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate the set of solutions, you can iterate over value of the parameters
    (`p` and `q`) in a nested loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Verify a Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can verify a solution is correct by substituting its integer values back
    into the original equation (expression which equals zero) and checking that the
    result is zero, either by using the dictionary approach from [Work With Parameters](#work-with-parameters),
    or by manually substituting in values determined by any procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Programmatically Extract Parameter Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to programmatically obtain the set of auto-generated parameters
    for one solution, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Not All Equations Can Be Solved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equations With No Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some Diophantine equations have no solution, in which case [`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine") will return an empty set,
    `set()`. For example, in the expression \(2x + 4y - 3\) (which we will try to
    set to zero), the coefficients are both even (\(2\) and \(4\)), so the sum of
    the terms \((2x + 4y)\) can only be even. However, the constant \(3\) is odd,
    so there is no solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find a bug with [`diophantine()`](../../modules/solvers/diophantine.html#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine"), please post the problem
    on the [SymPy mailing list](https://groups.google.com/g/sympy). Until the issue
    is resolved, you can use a different method listed in [Alternatives to Consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
