- en: pandas.read_excel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html](https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Read an Excel file into a `pandas` `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: Supports xls, xlsx, xlsm, xlsb, odf, ods and odt file extensions read from a
    local filesystem or URL. Supports an option to read a single sheet or a list of
    sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**io**str, bytes, ExcelFile, xlrd.Book, path object, or file-like object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any valid string path is acceptable. The string could be a URL. Valid URL schemes
    include http, ftp, s3, and file. For file URLs, a host is expected. A local file
    could be: `file://localhost/path/to/table.xlsx`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass in a path object, pandas accepts any `os.PathLike`.
  prefs: []
  type: TYPE_NORMAL
- en: By file-like object, we refer to objects with a `read()` method, such as a file
    handle (e.g. via builtin `open` function) or `StringIO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.1.0: Passing byte strings is deprecated. To read
    from a byte string, wrap it in a `BytesIO` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**sheet_name**str, int, list, or None, default 0'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are used for sheet names. Integers are used in zero-indexed sheet positions
    (chart sheets do not count as a sheet position). Lists of strings/integers are
    used to request multiple sheets. Specify `None` to get all worksheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Available cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defaults to `0`: 1st sheet as a DataFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: 2nd sheet as a DataFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Sheet1"`: Load sheet with name “Sheet1”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[0, 1, "Sheet5"]`: Load first, second and sheet named “Sheet5” as a dict of
    DataFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None`: All worksheets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**header**int, list of int, default 0'
  prefs: []
  type: TYPE_NORMAL
- en: Row (0-indexed) to use for the column labels of the parsed DataFrame. If a list
    of integers is passed those row positions will be combined into a `MultiIndex`.
    Use None if there is no header.
  prefs: []
  type: TYPE_NORMAL
- en: '**names**array-like, default None'
  prefs: []
  type: TYPE_NORMAL
- en: List of column names to use. If file contains no header row, then you should
    explicitly pass header=None.
  prefs: []
  type: TYPE_NORMAL
- en: '**index_col**int, str, list of int, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Column (0-indexed) to use as the row labels of the DataFrame. Pass None if there
    is no such column. If a list is passed, those columns will be combined into a
    `MultiIndex`. If a subset of data is selected with `usecols`, index_col is based
    on the subset.
  prefs: []
  type: TYPE_NORMAL
- en: Missing values will be forward filled to allow roundtripping with `to_excel`
    for `merged_cells=True`. To avoid forward filling the missing values use `set_index`
    after reading the data instead of `index_col`.
  prefs: []
  type: TYPE_NORMAL
- en: '**usecols**str, list-like, or callable, default None'
  prefs: []
  type: TYPE_NORMAL
- en: If None, then parse all columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If str, then indicates comma separated list of Excel column letters and column
    ranges (e.g. “A:E” or “A,C,E:F”). Ranges are inclusive of both sides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If list of int, then indicates list of column numbers to be parsed (0-indexed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If list of string, then indicates list of column names to be parsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If callable, then evaluate each column name against it and parse the column
    if the callable returns `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a subset of the columns according to behavior above.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**Type name or dict of column -> type, default None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data type for data or columns. E.g. {‘a’: np.float64, ‘b’: np.int32} Use `object`
    to preserve data as stored in Excel and not interpret dtype, which will necessarily
    result in `object` dtype. If converters are specified, they will be applied INSTEAD
    of dtype conversion. If you use `None`, it will infer the dtype of each column
    based on the data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**engine**{‘openpyxl’, ‘calamine’, ‘odf’, ‘pyxlsb’, ‘xlrd’}, default None'
  prefs: []
  type: TYPE_NORMAL
- en: 'If io is not a buffer or path, this must be set to identify io. Engine compatibility
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '`openpyxl` supports newer Excel file formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calamine` supports Excel (.xls, .xlsx, .xlsm, .xlsb) and OpenDocument (.ods)
    file formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`odf` supports OpenDocument file formats (.odf, .ods, .odt).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyxlsb` supports Binary Excel files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xlrd` supports old-style Excel files (.xls).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `engine=None`, the following logic will be used to determine the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: If `path_or_buffer` is an OpenDocument format (.odf, .ods, .odt), then [odf](https://pypi.org/project/odfpy/)
    will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise if `path_or_buffer` is an xls format, `xlrd` will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise if `path_or_buffer` is in xlsb format, `pyxlsb` will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise `openpyxl` will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**converters**dict, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Dict of functions for converting values in certain columns. Keys can either
    be integers or column labels, values are functions that take one input argument,
    the Excel cell content, and return the transformed content.
  prefs: []
  type: TYPE_NORMAL
- en: '**true_values**list, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Values to consider as True.
  prefs: []
  type: TYPE_NORMAL
- en: '**false_values**list, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Values to consider as False.
  prefs: []
  type: TYPE_NORMAL
- en: '**skiprows**list-like, int, or callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line numbers to skip (0-indexed) or number of lines to skip (int) at the start
    of the file. If callable, the callable function will be evaluated against the
    row indices, returning True if the row should be skipped and False otherwise.
    An example of a valid callable argument would be `lambda x: x in [0, 2]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nrows**int, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Number of rows to parse.
  prefs: []
  type: TYPE_NORMAL
- en: '**na_values**scalar, str, list-like, or dict, default None'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional strings to recognize as NA/NaN. If dict passed, specific per-column
    NA values. By default the following values are interpreted as NaN: ‘’, ‘#N/A’,
    ‘#N/A N/A’, ‘#NA’, ‘-1.#IND’, ‘-1.#QNAN’, ‘-NaN’, ‘-nan’, ‘1.#IND’, ‘1.#QNAN’,
    ‘<NA>’, ‘N/A’, ‘NA’, ‘NULL’, ‘NaN’, ‘None’, ‘n/a’, ‘nan’, ‘null’.'
  prefs: []
  type: TYPE_NORMAL
- en: '**keep_default_na**bool, default True'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether or not to include the default NaN values when parsing the data. Depending
    on whether `na_values` is passed in, the behavior is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If `keep_default_na` is True, and `na_values` are specified, `na_values` is
    appended to the default NaN values used for parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `keep_default_na` is True, and `na_values` are not specified, only the default
    NaN values are used for parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `keep_default_na` is False, and `na_values` are specified, only the NaN values
    specified `na_values` are used for parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `keep_default_na` is False, and `na_values` are not specified, no strings
    will be parsed as NaN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if na_filter is passed in as False, the `keep_default_na` and `na_values`
    parameters will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**na_filter**bool, default True'
  prefs: []
  type: TYPE_NORMAL
- en: Detect missing value markers (empty strings and the value of na_values). In
    data without any NAs, passing `na_filter=False` can improve the performance of
    reading a large file.
  prefs: []
  type: TYPE_NORMAL
- en: '**verbose**bool, default False'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate number of NA values placed in non-numeric columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**parse_dates**bool, list-like, or dict, default False'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`. If True -> try parsing the index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` of int or names. e.g. If [1, 2, 3] -> try parsing columns 1, 2, 3 each
    as a separate date column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` of lists. e.g. If [[1, 3]] -> combine columns 1 and 3 and parse as a
    single date column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dict`, e.g. {‘foo’ : [1, 3]} -> parse columns 1, 3 as date and call result
    ‘foo’'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a column or index contains an unparsable date, the entire column or index
    will be returned unaltered as an object data type. If you don`t want to parse
    some cells as date just change their type in Excel to “Text”. For non-standard
    datetime parsing, use `pd.to_datetime` after `pd.read_excel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: A fast-path exists for iso8601-formatted dates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**date_parser**function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function to use for converting a sequence of string columns to an array of
    datetime instances. The default uses `dateutil.parser.parser` to do the conversion.
    Pandas will try to call date_parser in three different ways, advancing to the
    next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates)
    as arguments; 2) concatenate (row-wise) the string values from the columns defined
    by parse_dates into a single array and pass that; and 3) call date_parser once
    for each row using one or more strings (corresponding to the columns defined by
    parse_dates) as arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.0.0: Use `date_format` instead, or read in as `object`
    and then apply [`to_datetime()`](pandas.to_datetime.html#pandas.to_datetime "pandas.to_datetime")
    as-needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**date_format**str or dict of column -> format, default `None`'
  prefs: []
  type: TYPE_NORMAL
- en: If used in conjunction with `parse_dates`, will parse dates according to this
    format. For anything more complex, please read in as `object` and then apply [`to_datetime()`](pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") as-needed.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**thousands**str, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Thousands separator for parsing string columns to numeric. Note that this parameter
    is only necessary for columns stored as TEXT in Excel, any numeric columns will
    automatically be parsed, regardless of display format.
  prefs: []
  type: TYPE_NORMAL
- en: '**decimal**str, default ‘.’'
  prefs: []
  type: TYPE_NORMAL
- en: Character to recognize as decimal point for parsing string columns to numeric.
    Note that this parameter is only necessary for columns stored as TEXT in Excel,
    any numeric columns will automatically be parsed, regardless of display format.(e.g.
    use ‘,’ for European data).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**comment**str, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Comments out remainder of line. Pass a character or characters to this argument
    to indicate comments in the input file. Any data between the comment string and
    the end of the current line is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**skipfooter**int, default 0'
  prefs: []
  type: TYPE_NORMAL
- en: Rows at the end to skip (0-indexed).
  prefs: []
  type: TYPE_NORMAL
- en: '**storage_options**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra options that make sense for a particular storage connection, e.g. host,
    port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded
    to `urllib.request.Request` as header options. For other URLs (e.g. starting with
    “s3://”, and “gcs://”) the key-value pairs are forwarded to `fsspec.open`. Please
    see `fsspec` and `urllib` for more details, and for more examples on storage options
    refer [here](https://pandas.pydata.org/docs/user_guide/io.html?highlight=storage_options#reading-writing-remote-files).
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype_backend**{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back-end data type applied to the resultant [`DataFrame`](pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (still experimental). Behaviour is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"numpy_nullable"`: returns nullable-dtype-backed [`DataFrame`](pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"pyarrow"`: returns pyarrow-backed nullable [`ArrowDtype`](pandas.ArrowDtype.html#pandas.ArrowDtype
    "pandas.ArrowDtype") DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**engine_kwargs**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary keyword arguments passed to excel engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame or dict of DataFrames
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame from the passed in Excel file. See notes in sheet_name argument for
    more information on when a dict of DataFrames is returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.to_excel`](pandas.DataFrame.to_excel.html#pandas.DataFrame.to_excel
    "pandas.DataFrame.to_excel")'
  prefs: []
  type: TYPE_NORMAL
- en: Write DataFrame to an Excel file.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.to_csv`](pandas.DataFrame.to_csv.html#pandas.DataFrame.to_csv "pandas.DataFrame.to_csv")'
  prefs: []
  type: TYPE_NORMAL
- en: Write DataFrame to a comma-separated values (csv) file.
  prefs: []
  type: TYPE_NORMAL
- en: '[`read_csv`](pandas.read_csv.html#pandas.read_csv "pandas.read_csv")'
  prefs: []
  type: TYPE_NORMAL
- en: Read a comma-separated values (csv) file into DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[`read_fwf`](pandas.read_fwf.html#pandas.read_fwf "pandas.read_fwf")'
  prefs: []
  type: TYPE_NORMAL
- en: Read a table of fixed-width formatted lines into DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For specific information on the methods used for each Excel engine, refer to
    the pandas [user guide](../../user_guide/io.html#io-excel-reader)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'The file can be read using the file name as string or an open file object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Index and header can be specified via the index_col and header arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Column types are inferred but can be explicitly specified
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: True, False, and NA values, and thousands separators have defaults, but can
    be explicitly specified, too. Supply the values you would like as strings or lists
    of strings!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Comment lines in the excel input file can be skipped using the `comment` kwarg.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
