- en: ODE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ODE
- en: Original text：[https://docs.sympy.org/latest/modules/solvers/ode.html](https://docs.sympy.org/latest/modules/solvers/ode.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/solvers/ode.html](https://docs.sympy.org/latest/modules/solvers/ode.html)
- en: Note
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a beginner-friendly guide focused on solving ODEs, refer to [Solve an Ordinary
    Differential Equation (ODE) Algebraically](../../guides/solving/solve-ode.html#solving-guide-ode).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 针对解决ODE的初学者友好指南，请参阅[代数解法解普通微分方程（ODE）](../../guides/solving/solve-ode.html#solving-guide-ode)。
- en: '## User Functions'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '## 用户函数'
- en: These are functions that are imported into the global namespace with `from sympy
    import *`. These functions (unlike [Hint Functions](#hint-functions), below) are
    intended for use by ordinary users of SymPy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数被导入到全局命名空间中，使用 `from sympy import *`。这些函数（与下面的[提示函数](#hint-functions)不同）旨在供SymPy的普通用户使用。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Solves any (supported) kind of ordinary differential equation and system of
    ordinary differential equations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 解决任何（支持的）普通微分方程和普通微分方程组。
- en: For Single Ordinary Differential Equation
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 用于单个普通微分方程
- en: It is classified under this when number of equation in `eq` is one. **Usage**
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `eq` 中方程的数量为一时，它被归类为此类。**用法**
- en: '`dsolve(eq, f(x), hint)` -> Solve ordinary differential equation `eq` for function
    `f(x)`, using method `hint`.'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`dsolve(eq, f(x), hint)` -> 使用方法 `hint` 解决普通微分方程 `eq` 关于函数 `f(x)`。'
- en: '**Details**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细信息**'
- en: '`eq` can be any supported ordinary differential equation (see the'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`eq` 可以是任何支持的普通微分方程（请参见'
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") docstring for supported
    methods). This can either be an [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality"), or an expression, which is assumed to be equal
    to `0`.'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") 文档字符串中支持的方法）。这可以是一个[`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")，或者一个假定等于 `0` 的表达式。'
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`f(x)` is a function of one variable whose derivatives in that'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`f(x)` 是一个单变量函数，其在那个'
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: variable make up the ordinary differential equation `eq`. In many cases it is
    not necessary to provide this; it will be autodetected (and an error raised if
    it could not be detected).
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 变量组成普通微分方程 `eq`。在许多情况下，提供这些变量并非必要；它将被自动检测（如果无法检测到，则会引发错误）。
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`hint` is the solving method that you want dsolve to use. Use'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`hint` 是您希望 `dsolve` 使用的解法。使用'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`classify_ode(eq, f(x))` to get all of the possible hints for an ODE. The default
    hint, `default`, will use whatever hint is returned first by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode"). See Hints below for more options that you can
    use for hint.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`classify_ode(eq, f(x))` 可以获取ODE的所有可能的提示。默认提示 `default` 将使用 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 返回的第一个提示。有关更多选项，请参见下面的提示。'
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`simplify` enables simplification by'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`simplify` 通过'
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp").
    See its docstring for more information. Turn this off, for example, to disable
    solving of solutions for `func` or simplification of arbitrary constants. It will
    still integrate with this hint. Note that the solution may contain more arbitrary
    constants than the order of the ODE with this option enabled.'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    实现简化。查看其文档字符串以获取更多信息。例如，可以关闭此选项，以禁用对 `func` 的解或任意常数的简化。即使启用此选项，解可能包含比ODE阶数更多的任意常数。'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`xi` and `eta` are the infinitesimal functions of an ordinary'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`xi` 和 `eta` 是普通'
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: differential equation. They are the infinitesimals of the Lie group of point
    transformations for which the differential equation is invariant. The user can
    specify values for the infinitesimals. If nothing is specified, `xi` and `eta`
    are calculated using [`infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    with the help of various heuristics.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 微分方程。它们是使微分方程不变的点变换李群的无穷小量。用户可以指定无穷小量的值。如果未指定任何内容，则使用各种启发式方法使用 [`infinitesimals()`](#sympy.solvers.ode.infinitesimals
    "sympy.solvers.ode.infinitesimals") 计算 `xi` 和 `eta`。
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ics` is the set of initial/boundary conditions for the differential equation.'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ics` 是微分方程的初值/边界条件集合。'
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It should be given in the form of `{f(x0): x1, f(x).diff(x).subs(x, x2): x3}`
    and so on. For power series solutions, if no initial conditions are specified
    `f(0)` is assumed to be `C0` and the power series solution is calculated about
    0.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '它应该以`{f(x0): x1, f(x).diff(x).subs(x, x2): x3}`的形式给出，依此类推。对于未指定初始条件的幂级数解，假定
    `f(0)` 为 `C0` 并计算关于 0 的幂级数解。'
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`x0` is the point about which the power series solution of a differential'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`x0` 是微分方程的幂级数解的点。'
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: equation is to be evaluated.
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方程的解需要进行评估。
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`n` gives the exponent of the dependent variable up to which the power series'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n` 给出了依赖变量的指数，该指数是幂级数的上限。'
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: solution of a differential equation is to be evaluated.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 微分方程的解要进行评估。
- en: '**Hints**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'Aside from the various solving methods, there are also some meta-hints that
    you can pass to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"):'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了各种求解方法外，您还可以将一些元提示传递给 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")：
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`default`:'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`default`:'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This uses whatever hint is returned first by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode"). This is the default argument to [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使用由 [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    返回的第一个提示。这是 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    的默认参数。
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`all`:'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`all`:'
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To make [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    apply all relevant classification hints, use `dsolve(ODE, func, hint="all")`.
    This will return a dictionary of `hint:solution` terms. If a hint causes dsolve
    to raise the `NotImplementedError`, value of that hint’s key will be the exception
    object raised. The dictionary will also include some special keys:'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要使 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 应用所有相关的分类提示，请使用
    `dsolve(ODE, func, hint="all")`。这将返回一个 `hint:solution` 术语的字典。如果提示导致 `dsolve` 抛出
    `NotImplementedError`，则该提示键的值将是引发的异常对象。该字典还将包括一些特殊键：
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`order`: The order of the ODE. See also [`ode_order()`](solvers.html#sympy.solvers.deutils.ode_order
    "sympy.solvers.deutils.ode_order") in `deutils.py`.'
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order`: ODE 的阶数。参见 [`ode_order()`](solvers.html#sympy.solvers.deutils.ode_order
    "sympy.solvers.deutils.ode_order") 在 `deutils.py` 中的说明。'
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`best`: The simplest hint; what would be returned by `best` below.'
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`best`: 最简单的提示；`best` 下面将会返回。'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`best_hint`: The hint that would produce the solution given by `best`. If more
    than one hint produces the best solution, the first one in the tuple returned
    by [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    is chosen.'
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`best_hint`: 给出由 `best` 给出的解决方案的提示。如果有多个提示产生最佳解决方案，则选择 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 返回的元组中的第一个提示。'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`default`: The solution that would be returned by default. This is the one
    produced by the hint that appears first in the tuple returned by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode").'
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 默认情况下会返回的解决方案。这是由 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 返回的元组中首个提示生成的解决方案。'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`all_Integral`:'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`all_Integral`:'
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the same as `all`, except if a hint also has a corresponding `_Integral`
    hint, it only returns the `_Integral` hint. This is useful if `all` causes [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") to hang because of a difficult or impossible integral.
    This meta-hint will also be much faster than `all`, because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is an expensive routine.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与 `all` 相同，只是如果提示还有对应的 `_Integral` 提示，它只返回 `_Integral` 提示。如果由于困难或不可能的积分而导致
    [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 无法继续，这会非常有用。这种元提示还比
    `all` 要快得多，因为 [`integrate()`](../core.html#sympy.core.expr.Expr.integrate "sympy.core.expr.Expr.integrate")
    是一个昂贵的例程。
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`best`:'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`best`:'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To have [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") try
    all methods and return the simplest one. This takes into account whether the solution
    is solvable in the function, whether it contains any Integral classes (i.e. unevaluatable
    integrals), and which one is the shortest in size.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要让 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 尝试所有方法并返回最简单的方法。这考虑到解决方案是否可在函数中解决，是否包含任何积分类（即无法评估的积分），以及哪个解决方案尺寸最小。
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also the [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    docstring for more info on hints, and the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode")
    docstring for a list of all supported hints.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另请参阅 [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    的文档字符串，以获取有关提示的更多信息，以及 [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode")
    的文档字符串，以获取所有支持的提示列表。
- en: '**Tips**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: 'You can declare the derivative of an unknown function this way:'
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过以下方式声明未知函数的导数：
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: See `test_ode.py` for many tests, which serves also as a set of examples for
    how to use [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见 `test_ode.py` 中的多个测试，这些测试也用作如何使用 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    的示例集。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") always returns
    an [`Equality`](../core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    class (except for the case when the hint is `all` or `all_Integral`). If possible,
    it solves the solution explicitly for the function being solved for. Otherwise,
    it returns an implicit solution.'
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 总是返回一个 [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") 类（除非提示为 `all` 或 `all_Integral`）。如果可能，它会为正在解决的函数明确解出解。否则，它会返回一个隐式解。'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Arbitrary constants are symbols named `C1`, `C2`, and so on.
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意常数是以 `C1`，`C2` 等命名的符号。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Because all solutions should be mathematically equivalent, some hints may return
    the exact same result for an ODE. Often, though, two different hints will return
    the same solution formatted differently. The two should be equivalent. Also note
    that sometimes the values of the arbitrary constants in two different solutions
    may not be the same, because one constant may have “absorbed” other constants
    into it.
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为所有解应在数学上等价，某些提示可能会为ODE返回相同的结果。尽管如此，两种不同的提示通常会以不同的格式返回相同的解。还要注意，有时两个不同解中的任意常数值可能不相同，因为一个常数可能已经“吸收”了其他常数。
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Do `help(ode.ode_<hintname>)` to get help more information on a specific hint,
    where `<hintname>` is the name of a hint without `_Integral`.
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `help(ode.ode_<hintname>)` 以获取有关特定提示的更多信息，其中 `<hintname>` 是没有 `_Integral`
    的提示名称。
- en: For System Of Ordinary Differential Equations
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用于常规微分方程系统
- en: '**Usage**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: '`dsolve(eq, func)` -> Solve a system of ordinary differential equations `eq`
    for `func` being list of functions including \(x(t)\), \(y(t)\), \(z(t)\) where
    number of functions in the list depends upon the number of equations provided
    in `eq`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`dsolve(eq, func)` -> 解决常规微分方程系统 `eq`，其中 `func` 是包括 \(x(t)\), \(y(t)\), \(z(t)\)
    在内的函数列表，列表中的函数数量取决于 `eq` 中提供的方程数量。'
- en: '**Details**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细信息**'
- en: '`eq` can be any supported system of ordinary differential equations This can
    either be an [`Equality`](../core.html#sympy.core.relational.Equality "sympy.core.relational.Equality"),
    or an expression, which is assumed to be equal to `0`.'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`eq` 可以是任何支持的常规微分方程系统，可以是一个 [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") 或一个假定为等于 `0` 的表达式。'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`func` holds `x(t)` and `y(t)` being functions of one variable which together
    with some of their derivatives make up the system of ordinary differential equation
    `eq`. It is not necessary to provide this; it will be autodetected (and an error
    raised if it could not be detected).'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`func` 包含 `x(t)` 和 `y(t)` 作为一个变量函数，它们连同其一些导数组成常规微分方程系统 `eq`。不必提供这个；它将被自动检测（如果无法检测到，则引发错误）。'
- en: '**Hints**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: The hints are formed by parameters returned by classify_sysode, combining them
    give hints name used later for forming method name.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示由 classify_sysode 返回的参数组合形成，后续用于形成方法名称。
- en: Examples
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Solves any(supported) system of Ordinary Differential Equations
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解决任何支持的常规微分方程系统
- en: 'Parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**eqs** : List'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**eqs**：列表'
- en: system of ODEs to be solved
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要解决的常规微分方程系统
- en: '**funcs** : List or None'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**funcs**：列表或无'
- en: List of dependent variables that make up the system of ODEs
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 组成常规微分方程系统的依赖变量列表
- en: '**t** : Symbol or None'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**t**：符号或无'
- en: Independent variable in the system of ODEs
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 常规微分方程系统中的自变量
- en: '**ics** : Dict or None'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**ics**：字典或无'
- en: Set of initial boundary/conditions for the system of ODEs
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统的初始边界/条件集
- en: '**doit** : Boolean'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**doit**：布尔值'
- en: Evaluate the solutions if True. Default value is True. Can be set to false if
    the integral evaluation takes too much time and/or is not required.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为 True，则评估解。默认值为 True。如果积分评估花费太多时间和/或不是必需的，则可以设置为 false。
- en: '**simplify: Boolean**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**simplify: 布尔值**'
- en: Simplify the solutions for the systems. Default value is True. Can be set to
    false if simplification takes too much time and/or is not required.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简化系统的解。默认值为 True。如果简化花费太多时间和/或不是必需的，则可以设置为 false。
- en: 'Returns:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: List of List of Equations
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 方程的列表列表
- en: 'Raises:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**NotImplementedError**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedError**'
- en: When the system of ODEs is not solvable by this function.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当无法通过此函数解决常规微分方程系统时。
- en: '**ValueError**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: When the parameters passed are not in the required form.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当传递的参数不符合所需格式时。
- en: Explanation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This function takes a system of ODEs as an input, determines if the it is solvable
    by this function, and returns the solution if found any.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受常规微分方程系统作为输入，确定是否可以通过此函数解决，并在找到解决方案时返回。
- en: 'This function can handle: 1\. Linear, First Order, Constant coefficient homogeneous
    system of ODEs 2\. Linear, First Order, Constant coefficient non-homogeneous system
    of ODEs 3\. Linear, First Order, non-constant coefficient homogeneous system of
    ODEs 4\. Linear, First Order, non-constant coefficient non-homogeneous system
    of ODEs 5\. Any implicit system which can be divided into system of ODEs which
    is of the above 4 forms 6\. Any higher order linear system of ODEs that can be
    reduced to one of the 5 forms of systems described above.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以处理以下情况：1\. 线性、一阶、恒定系数齐次常微分方程组 2\. 线性、一阶、恒定系数非齐次常微分方程组 3\. 线性、一阶、非恒定系数齐次常微分方程组
    4\. 线性、一阶、非恒定系数非齐次常微分方程组 5\. 可以分解成上述四种形式的常微分方程系统的任意隐式系统 6\. 可以简化为上述五种系统形式之一的任意高阶线性常微分方程系统。
- en: The types of systems described above are not limited by the number of equations,
    i.e. this function can solve the above types irrespective of the number of equations
    in the system passed. But, the bigger the system, the more time it will take to
    solve the system.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述描述的系统类型不受方程数量限制，即此函数可以解决上述类型的系统，而不管系统中方程的数量如何。但是，系统越大，解决系统所需的时间就越长。
- en: This function returns a list of solutions. Each solution is a list of equations
    where LHS is the dependent variable and RHS is an expression in terms of the independent
    variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个解的列表。每个解都是一个方程列表，其中LHS是依赖变量，RHS是独立变量的表达式。
- en: Among the non constant coefficient types, not all the systems are solvable by
    this function. Only those which have either a coefficient matrix with a commutative
    antiderivative or those systems which may be divided further so that the divided
    systems may have coefficient matrix with commutative antiderivative.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在非恒定系数类型中，并非所有系统都可以通过此函数求解。只有具有具有可交换的反导数的系数矩阵或者可以进一步分解以便分割系统可能具有具有可交换的反导数的系数矩阵的系统才能被解决。
- en: Examples
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also pass the initial conditions for the system of ODEs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传递常微分方程系统的初始条件：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Optionally, you can pass the dependent variables and the independent variable
    for which the system is to be solved:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以传递依赖变量和要解决系统的自变量：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lets look at an implicit system of ODEs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个隐式的常微分方程系统：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Returns a tuple of possible [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    classifications for an ODE.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可能的[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")常微分方程的分类元组。
- en: The tuple is ordered so that first item is the classification that [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") uses to solve the ODE by default. In general, classifications
    at the near the beginning of the list will produce better solutions faster than
    those near the end, thought there are always exceptions. To make [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") use a different classification, use `dsolve(ODE, func,
    hint=<classification>)`. See also the [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    docstring for different meta-hints you can use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是有序的，以便第一项是[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")默认用于解决ODE的分类。一般来说，列表中靠近开头的分类比靠近末尾的分类更快地生成更好的解决方案，尽管总会有例外情况。要使[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")使用不同的分类，使用`dsolve(ODE, func, hint=<classification>)`。另请参阅[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")的文档字符串以了解可以使用的不同元提示。
- en: If `dict` is true, [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    will return a dictionary of `hint:match` expression terms. This is intended for
    internal use by [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    Note that because dictionaries are ordered arbitrarily, this will most likely
    not be in the same order as the tuple.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dict`为真，[`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")将返回`hint:match`表达式术语的字典。这是[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")内部使用的。请注意，由于字典的顺序是任意的，这可能与元组的顺序不同。
- en: You can get help on different hints by executing `help(ode.ode_hintname)`, where
    `hintname` is the name of the hint without `_Integral`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行`help(ode.ode_hintname)`获取关于不同提示的帮助，其中`hintname`是提示的名称，不包括`_Integral`。
- en: See [`allhints`](#sympy.solvers.ode.allhints "sympy.solvers.ode.allhints") or
    the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") docstring for a list
    of all supported hints that can be returned from [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [`allhints`](#sympy.solvers.ode.allhints "sympy.solvers.ode.allhints") 或
    [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") 的文档字符串，了解从 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 返回的所有支持的提示列表。
- en: Notes
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: These are remarks on hint names.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是关于提示名称的备注。
- en: '`_Integral`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`_Integral`'
- en: If a classification has `_Integral` at the end, it will return the expression
    with an unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") class in it. Note that a hint may do this
    anyway if [`integrate()`](../core.html#sympy.core.expr.Expr.integrate "sympy.core.expr.Expr.integrate")
    cannot do the integral, though just using an `_Integral` will do so much faster.
    Indeed, an `_Integral` hint will always be faster than its corresponding hint
    without `_Integral` because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is an expensive routine. If [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") hangs, it is probably because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is hanging on a tough or impossible integral.
    Try using an `_Integral` hint or `all_Integral` to get it return something.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个分类在末尾有 `_Integral`，它将返回一个表达式，其中包含一个未评估的 [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") 类。请注意，如果 [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") 无法进行积分，某些提示可能会这样做，尽管仅使用 `_Integral` 会更快。事实上，
    `_Integral` 提示总是比其对应的没有 `_Integral` 的提示更快，因为 [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") 是一个昂贵的例程。如果 [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") 卡住了，这可能是因为 [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") 在一个棘手或不可能的积分上卡住了。尝试使用 `_Integral` 提示或 `all_Integral`
    来使其返回结果。
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that some hints do not have `_Integral` counterparts. This is because [`integrate()`](../integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") is not used in solving the ODE for those
    method. For example, \(n\)th order linear homogeneous ODEs with constant coefficients
    do not require integration to solve, so there is no `nth_linear_homogeneous_constant_coeff_Integrate`
    hint. You can easily evaluate any unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s in an expression by doing `expr.doit()`.
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，一些提示没有 `_Integral` 对应项。这是因为在解决这些方法的 ODE 时没有使用 [`integrate()`](../integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate")。例如，具有恒定系数的 n 阶线性齐次 ODE 不需要积分来解决，因此没有 `nth_linear_homogeneous_constant_coeff_Integrate`
    提示。您可以通过执行 `expr.doit()` 轻松评估表达式中的任何未评估的 [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")。
- en: Ordinals
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 序数
- en: Some hints contain an ordinal such as `1st_linear`. This is to help differentiate
    them from other hints, as well as from other methods that may not be implemented
    yet. If a hint has `nth` in it, such as the `nth_linear` hints, this means that
    the method used to applies to ODEs of any order.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些提示包含序数，例如 `1st_linear`。这是为了帮助区分它们与尚未实现的其他提示及其他方法。如果一个提示中包含 `nth`，例如 `nth_linear`
    提示，则这意味着使用的方法适用于任意阶的 ODE。
- en: '`indep` and `dep`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`indep` 和 `dep`'
- en: Some hints contain the words `indep` or `dep`. These reference the independent
    variable and the dependent function, respectively. For example, if an ODE is in
    terms of \(f(x)\), then `indep` will refer to \(x\) and `dep` will refer to \(f\).
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些提示包含 `indep` 或 `dep` 一词。这些是指独立变量和依赖函数，分别。例如，如果一个 ODE 是关于 \(f(x)\) 的，则 `indep`
    将指 \(x\)，`dep` 将指 \(f\)。
- en: '`subs`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`subs`'
- en: If a hints has the word `subs` in it, it means that the ODE is solved by substituting
    the expression given after the word `subs` for a single dummy variable. This is
    usually in terms of `indep` and `dep` as above. The substituted expression will
    be written only in characters allowed for names of Python objects, meaning operators
    will be spelled out. For example, `indep`/`dep` will be written as `indep_div_dep`.
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果提示中有 `subs` 一词，这意味着通过将 `subs` 词后给出的表达式替换为单个虚拟变量来解决 ODE。这通常是在上述的 `indep` 和
    `dep` 的术语中。替换的表达式将仅使用允许作为 Python 对象名称的字符编写，这意味着操作符将被拼写出来。例如，`indep`/`dep` 将被写成
    `indep_div_dep`。
- en: '`coeff`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`coeff`'
- en: The word `coeff` in a hint refers to the coefficients of something in the ODE,
    usually of the derivative terms. See the docstring for the individual methods
    for more info (`help(ode)`). This is contrast to `coefficients`, as in `undetermined_coefficients`,
    which refers to the common name of a method.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示中的`coeff`一词指的是ODE中某物的系数，通常是导数项的系数。有关各个方法的更多信息，请参阅单个方法的文档字符串（`help(ode)`）。与`coefficients`相对应，如`undetermined_coefficients`，后者指的是一种方法的常见名称。
- en: '`_best`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`_best`'
- en: Methods that have more than one fundamental way to solve will have a hint for
    each sub-method and a `_best` meta-classification. This will evaluate all hints
    and return the best, using the same considerations as the normal `best` meta-hint.
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 具有多种基本解法的方法将为每种子方法提供提示和`_best`元分类。这将评估所有提示并返回最佳结果，使用与正常`best`元提示相同的考虑。
- en: Examples
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Substitutes `sol` into `ode` and checks that the result is `0`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 代入`sol`到`ode`并检查结果是否为`0`。
- en: This works when `func` is one function, like \(f(x)\) or a list of functions
    like \([f(x), g(x)]\) when \(ode\) is a system of ODEs. `sol` can be a single
    solution or a list of solutions. Each solution may be an [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") that the solution satisfies, e.g. `Eq(f(x),
    C1), Eq(f(x) + C1, 0)`; or simply an [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), e.g. `f(x) - C1`. In most cases it will not be necessary
    to explicitly identify the function, but if the function cannot be inferred from
    the original equation it can be supplied through the `func` argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当`func`是一个函数，如\(f(x)\)，或者函数列表，如\([f(x), g(x)]\)，当`ode`是ODE系统时，这将有效。`sol`可以是单个解或解列表。每个解可能是一个[`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")，表示解满足的等式，例如`Eq(f(x), C1), Eq(f(x) + C1, 0)`；或者简单地是[`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")，例如`f(x) - C1`。在大多数情况下，不需要显式地标识函数，但如果原方程中无法推断出函数，则可以通过`func`参数提供。
- en: If a sequence of solutions is passed, the same sort of container will be used
    to return the result for each solution.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了一系列解的序列，将使用相同类型的容器为每个解返回结果。
- en: 'It tries the following methods, in order, until it finds zero equivalence:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它尝试以下方法，按顺序执行，直到找到零等效：
- en: Substitute the solution for \(f\) in the original equation. This only works
    if `ode` is solved for \(f\). It will attempt to solve it first unless `solve_for_func
    == False`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原方程中用解代替\(f\)。这仅在为\(f\)解决`ode`时有效。它会首先尝试解决它，除非`solve_for_func == False`。
- en: Take \(n\) derivatives of the solution, where \(n\) is the order of `ode`, and
    check to see if that is equal to the solution. This only works on exact ODEs.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对解的\(n\)次导数，其中\(n\)是`ode`的阶数，进行检查，看看是否等于解。这仅适用于精确ODE。
- en: Take the 1st, 2nd, …, \(n\)th derivatives of the solution, each time solving
    for the derivative of \(f\) of that order (this will always be possible because
    \(f\) is a linear operator). Then back substitute each derivative into `ode` in
    reverse order.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对解的第1、第2、…、第\(n\)阶导数进行操作，每次解决该阶导数的\(f\)（这总是可能的，因为\(f\)是线性操作符）。然后将每个导数反向代入`ode`。
- en: This function returns a tuple. The first item in the tuple is `True` if the
    substitution results in `0`, and `False` otherwise. The second item in the tuple
    is what the substitution results in. It should always be `0` if the first item
    is `True`. Sometimes this function will return `False` even when an expression
    is identically equal to `0`. This happens when [`simplify()`](../simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") does not reduce the expression to `0`. If
    an expression returned by this function vanishes identically, then `sol` really
    is a solution to the `ode`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个元组。元组中的第一项为`True`，如果代换结果为`0`，则为`False`。元组中的第二项为代换结果。如果第一项为`True`，则它应始终为`0`。有时，即使表达式恰好等于`0`，该函数也会返回`False`。这是因为[`simplify()`](../simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify")无法将表达式简化为`0`。如果此函数返回的表达式在恒等时消失，则`sol`确实是ODE的解。
- en: If this function seems to hang, it is probably because of a hard simplification.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数似乎卡住了，很可能是因为难以简化。
- en: To use this function to test, test the first item of the tuple.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数来测试，测试元组的第一项。
- en: Examples
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Returns the order \(n\) if \(g\) is homogeneous and `None` if it is not homogeneous.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(g\)是齐次的，则返回阶数\(n\)，如果不是齐次的，则返回`None`。
- en: Determines if a function is homogeneous and if so of what order. A function
    \(f(x, y, \cdots)\) is homogeneous of order \(n\) if \(f(t x, t y, \cdots) = t^n
    f(x, y, \cdots)\).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 确定函数是否是齐次的，并确定其阶数。如果函数\(f(x, y, \cdots)\)是阶数为\(n\)的齐次函数，那么\(f(t x, t y, \cdots)
    = t^n f(x, y, \cdots)\)。
- en: If the function is of two variables, \(F(x, y)\), then \(f\) being homogeneous
    of any order is equivalent to being able to rewrite \(F(x, y)\) as \(G(x/y)\)
    or \(H(y/x)\). This fact is used to solve 1st order ordinary differential equations
    whose coefficients are homogeneous of the same order (see the docstrings of [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") and [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep")).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是两个变量的函数\(F(x, y)\)，那么\(f\)是任何阶齐次的等价于能够将\(F(x, y)\)重写为\(G(x/y)\)或\(H(y/x)\)。这个事实用于解决系数同阶齐次的一阶常微分方程（参见[`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep")和[`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep")的文档字符串）。
- en: Symbols can be functions, but every argument of the function must be a symbol,
    and the arguments of the function that appear in the expression must match those
    given in the list of symbols. If a declared function appears with different arguments
    than given in the list of symbols, `None` is returned.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 符号可以是函数，但函数的每个参数必须是符号，并且出现在表达式中的函数参数必须与符号列表中给出的参数匹配。如果声明的函数出现具有不同参数的情况，则返回`None`。
- en: Examples
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The infinitesimal functions of an ordinary differential equation, \(\xi(x,y)\)
    and \(\eta(x,y)\), are the infinitesimals of the Lie group of point transformations
    for which the differential equation is invariant. So, the ODE \(y'=f(x,y)\) would
    admit a Lie group \(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\), \(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)
    such that \((y^*)'=f(x^*, y^*)\). A change of coordinates, to \(r(x,y)\) and \(s(x,y)\),
    can be performed so this Lie group becomes the translation group, \(r^*=r\) and
    \(s^*=s+\varepsilon\). They are tangents to the coordinate curves of the new system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 普通微分方程的微小函数\(\xi(x,y)\)和\(\eta(x,y)\)是使得微分方程不变的点变换的Lie群的微小量。因此，ODE \(y'=f(x,y)\)将接受一个Lie群\(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\)，\(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)，使得\((y^*)'=f(x^*,
    y^*)\)。可以对新系统的坐标曲线\(r(x,y)\)和\(s(x,y)\)进行坐标变换，使得此Lie群变成平移群，\(r^*=r\)且\(s^*=s+\varepsilon\)。它们是新系统的坐标曲线的切线。
- en: Consider the transformation \((x, y) \to (X, Y)\) such that the differential
    equation remains invariant. \(\xi\) and \(\eta\) are the tangents to the transformed
    coordinates \(X\) and \(Y\), at \(\varepsilon=0\).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑变换\((x, y) \to (X, Y)\)，使得微分方程保持不变。\(\xi\)和\(\eta\)是变换坐标\(X\)和\(Y\)在\(\varepsilon=0\)时的切线。
- en: \[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \xi, \left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \eta,\]
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \xi, \left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \eta,\]
- en: 'The infinitesimals can be found by solving the following PDE:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过解以下PDE找到微小量：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Solving the above mentioned PDE is not trivial, and can be solved only by making
    intelligent assumptions for \(\xi\) and \(\eta\) (heuristics). Once an infinitesimal
    is found, the attempt to find more heuristics stops. This is done to optimise
    the speed of solving the differential equation. If a list of all the infinitesimals
    is needed, `hint` should be flagged as `all`, which gives the complete list of
    infinitesimals. If the infinitesimals for a particular heuristic needs to be found,
    it can be passed as a flag to `hint`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上述提到的偏微分方程并不是简单的事情，只能通过对\(\xi\)和\(\eta\)（启发式）做出智能假设来解决。一旦找到一个微小量，尝试找到更多启发式就会停止。这样做是为了优化求解微分方程的速度。如果需要所有微小量的列表，则应将`hint`标记为`all`，这将给出所有微小量的完整列表。如果需要找到特定启发式的微小量，则可以将其作为标志传递给`hint`。
- en: Examples
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: References
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Solving differential equations by Symmetry Groups, John Starrett, pp. 1 - pp.
    14
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对称群解微分方程，John Starrett，第1页 - 第14页
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This function is used to check if the given infinitesimals are the actual infinitesimals
    of the given first order differential equation. This method is specific to the
    Lie Group Solver of ODEs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于检查给定无穷小数是否是给定一阶微分方程的实际无穷小数。 此方法特定于ODE的李群解算器。
- en: As of now, it simply checks, by substituting the infinitesimals in the partial
    differential equation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它只是通过替换偏微分方程中的无穷小数来检查。
- en: \[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
    - \frac{\partial \xi}{\partial x}\right)*h - \frac{\partial \xi}{\partial y}*h^{2}
    - \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
    - \frac{\partial \xi}{\partial x}\right)*h - \frac{\partial \xi}{\partial y}*h^{2}
    - \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]
- en: where \(\eta\), and \(\xi\) are the infinitesimals and \(h(x,y) = \frac{dy}{dx}\)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(\eta\) 和 \(\xi\) 是无穷小数，而 \(h(x,y) = \frac{dy}{dx}\)
- en: 'The infinitesimals should be given in the form of a list of dicts `[{xi(x,
    y): inf, eta(x, y): inf}]`, corresponding to the output of the function infinitesimals.
    It returns a list of values of the form `[(True/False, sol)]` where `sol` is the
    value obtained after substituting the infinitesimals in the PDE. If it is `True`,
    then `sol` would be 0.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '无穷小数应以 `[{xi(x, y): inf, eta(x, y): inf}]` 的字典列表形式给出，对应于函数无穷小数的输出。 它返回形式为 `[(True/False,
    sol)]` 的值列表，其中 `sol` 是在偏微分方程中替换无穷小数后得到的值。 如果为 `True`，则 `sol` 将为 0。'
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Simplifies an expression with arbitrary constants in it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 简化带有任意常数的表达式。
- en: This function is written specifically to work with [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), and is not intended for general use.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数专门用于[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")，并不适用于一般用途。
- en: Simplification is done by “absorbing” the arbitrary constants into other arbitrary
    constants, numbers, and symbols that they are not independent of.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 简化是通过将任意常数“吸收”到其他任意常数、数字和它们不独立的符号中来完成的。
- en: The symbols must all have the same name with numbers after it, for example,
    `C1`, `C2`, `C3`. The `symbolname` here would be ‘`C`’, the `startnumber` would
    be 1, and the `endnumber` would be 3. If the arbitrary constants are independent
    of the variable `x`, then the independent symbol would be `x`. There is no need
    to specify the dependent function, such as `f(x)`, because it already has the
    independent symbol, `x`, in it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有符号必须以相同的名称并带有数字，例如 `C1`、`C2`、`C3`。 这里的 `symbolname` 将是 ‘`C`’，`startnumber`
    将是 1，`endnumber` 将是 3。 如果任意常数与变量 `x` 独立无关，则独立符号将是 `x`。 无需指定依赖函数，如 `f(x)`，因为它已经包含独立符号
    `x`。
- en: Because terms are “absorbed” into arbitrary constants and because constants
    are renumbered after simplifying, the arbitrary constants in expr are not necessarily
    equal to the ones of the same name in the returned result.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因为项被“吸收”到任意常数中，并且因为简化后常数被重新编号，所以表达式中的任意常数未必等于返回结果中同名的常数。
- en: If two or more arbitrary constants are added, multiplied, or raised to the power
    of each other, they are first absorbed together into a single arbitrary constant.
    Then the new constant is combined into other terms if necessary.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多的任意常数相加、相乘或互相提升到幂，则它们首先被一起吸收到单个任意常数中。 然后，如果必要，新常数将与其他项结合。
- en: 'Absorption of constants is done with limited assistance:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 常数的吸收是有限辅助完成的：
- en: terms of [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")s are
    collected to try join constants so \(e^x (C_1 \cos(x) + C_2 \cos(x))\) will simplify
    to \(e^x C_1 \cos(x)\);
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")项中收集了条款，以尝试合并常数，因此
    \(e^x (C_1 \cos(x) + C_2 \cos(x))\) 将简化为 \(e^x C_1 \cos(x)\)；
- en: powers with exponents that are [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")s
    are expanded so \(e^{C_1 + x}\) will be simplified to \(C_1 e^x\).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有指数为[`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")的幂会被展开，因此
    \(e^{C_1 + x}\) 将简化为 \(C_1 e^x\)。
- en: Use [`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")
    to renumber constants after simplification or else arbitrary numbers on constants
    may appear, e.g. \(C_1 + C_3 x\).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")在简化后重新编号常数，否则常数上可能出现任意数字，例如
    \(C_1 + C_3 x\)。
- en: In rare cases, a single constant can be “simplified” into two constants. Every
    differential equation solution should have as many arbitrary constants as the
    order of the differential equation. The result here will be technically correct,
    but it may, for example, have \(C_1\) and \(C_2\) in an expression, when \(C_1\)
    is actually equal to \(C_2\). Use your discretion in such situations, and also
    take advantage of the ability to use hints in [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见情况下，单个常量可以“简化”为两个常量。每个微分方程解应具有与微分方程阶数相同数量的任意常数。这里的结果在技术上是正确的，但例如在表达式中可能有\(C_1\)和\(C_2\)，而实际上\(C_1\)等于\(C_2\)。在这种情况下，请慎重使用，并利用在[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")中使用提示的能力。
- en: Examples
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE22]  ## Hint Functions'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE22]  ## 提示函数'
- en: These functions are intended for internal use by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") and others. Unlike [User Functions](#user-functions),
    above, these are not intended for every-day use by ordinary SymPy users. Instead,
    functions such as [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    should be used. Nonetheless, these functions contain useful information in their
    docstrings on the various ODE solving methods. For this reason, they are documented
    here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数是由[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")和其他函数内部使用的。与[用户函数](#user-functions)不同，上述函数不适用于普通SymPy用户的日常使用。相反，应该使用[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")等函数。尽管如此，这些函数在其文档字符串中包含有关各种ODE求解方法的有用信息。因此，它们在此处进行了文档化。
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Built-in immutable sequence.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 内置不可变序列。
- en: If no argument is given, the constructor returns an empty tuple. If iterable
    is specified the tuple is initialized from iterable’s items.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未给出参数，则构造函数返回一个空元组。如果指定了可迭代对象，则从可迭代对象的项目初始化元组。
- en: If the argument is a tuple, the return value is the same object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是一个元组，则返回的值是相同的对象。
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Simplifies solutions of ODEs, including trying to solve for `func` and running
    [`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp").
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 简化ODE的解，包括尝试解析`func`并运行[`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")。
- en: It may use knowledge of the type of solution that the hint returns to apply
    additional simplifications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能利用提示返回的解的类型知识来应用额外的简化。
- en: It also attempts to integrate any [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s in the expression, if the hint is not an
    `_Integral` hint.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 它还尝试在表达式中集成任何[`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")，如果提示不是`_Integral`提示。
- en: This function should have no effect on expressions returned by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), as [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    already calls [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp"),
    but the individual hint functions do not call [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") (because the [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") wrapper does). Therefore, this function is designed
    for mainly internal use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不应对[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")返回的表达式产生影响，因为[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")已调用[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")，但是单独的提示函数不调用[`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp")（因为[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")包装器不会）。因此，该函数主要设计用于内部使用。
- en: Examples
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Renumber arbitrary constants in `expr` to use the symbol names as given in `newconstants`.
    In the process, this reorders expression terms in a standard way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将`expr`中的任意常量重新编号，以使用`newconstants`中给定的符号名称。在此过程中，这将按标准方式重新排序表达式项。
- en: If `newconstants` is not provided then the new constant names will be `C1`,
    `C2` etc. Otherwise `newconstants` should be an iterable giving the new symbols
    to use for the constants in order.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`newconstants`，则新常量名称将为`C1`，`C2`等。否则，`newconstants`应为可迭代对象，按顺序给出用于常量的新符号。
- en: The `variables` argument is a list of non-constant symbols. All other free symbols
    found in `expr` are assumed to be constants and will be renumbered. If `variables`
    is not given then any numbered symbol beginning with `C` (e.g. `C1`) is assumed
    to be a constant.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables`参数是一个非常量符号的列表。假定`expr`中的所有其他自由符号都是常量，并且将进行重新编号。如果未提供`variables`，则假定以`C`开头的任何编号符号（例如`C1`）都是常量。'
- en: Symbols are renumbered based on `.sort_key()`, so they should be numbered roughly
    in the order that they appear in the final, printed expression. Note that this
    ordering is based in part on hashes, so it can produce different results on different
    machines.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`.sort_key()`对符号进行重新编号，因此它们应该按最终打印表达式中出现的顺序编号。请注意，此排序部分基于哈希，因此在不同机器上可能会产生不同的结果。
- en: The structure of this function is very similar to that of [`constantsimp()`](#sympy.solvers.ode.constantsimp
    "sympy.solvers.ode.constantsimp").
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的结构与[`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")非常相似。
- en: Examples
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `variables` argument specifies which are constants so that the other symbols
    will not be renumbered:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables`参数指定哪些是常数，以便其他符号不会重新编号：'
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `newconstants` argument is used to specify what symbols to use when replacing
    the constants:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`newconstants`参数用于指定在替换常数时使用哪些符号：'
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Returns an extended integer representing how simple a solution to an ODE is.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个扩展整数，表示ODE的解的简单程度。
- en: 'The following things are considered, in order from most simple to least:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 按从最简单到最不简单的顺序考虑以下事项：
- en: '`sol` is solved for `func`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sol`被解决为`func`。'
- en: '`sol` is not solved for `func`, but can be if passed to solve (e.g., a solution
    returned by `dsolve(ode, func, simplify=False`).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sol`未被解决为`func`，但如果传递给solve（例如，由`dsolve(ode, func, simplify=False`返回的解决方案）则可以。'
- en: If `sol` is not solved for `func`, then base the result on the length of `sol`,
    as computed by `len(str(sol))`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`sol`未被解决为`func`，则基于`sol`的长度进行结果计算，由`len(str(sol))`计算。
- en: If `sol` has any unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s, this will automatically be considered
    less simple than any of the above.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`sol`有任何未评估的[`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")，这将自动被认为比上述任何一种情况都不简单。
- en: This function returns an integer such that if solution A is simpler than solution
    B by above metric, then `ode_sol_simplicity(sola, func) < ode_sol_simplicity(solb,
    func)`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个整数，使得如果解A按上述度量标准比解B简单，则`ode_sol_simplicity(sola, func) < ode_sol_simplicity(solb,
    func)`。
- en: Currently, the following are the numbers returned, but if the heuristic is ever
    improved, this may change. Only the ordering is guaranteed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，以下是返回的数字，但如果启发式方法有所改进，可能会改变。仅保证排序。
- en: '| Simplicity | Return |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 简单性 | 返回 |'
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sol` solved for `func` | `-2` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `sol`解决为`func` | `-2` |'
- en: '| `sol` not solved for `func` but can be | `-1` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `sol`未解决为`func`但可解 | `-1` |'
- en: '| `sol` is not solved nor solvable for `func` | `len(str(sol))` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `sol`未解决也不可解决为`func` | `len(str(sol))` |'
- en: '| `sol` contains an [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") | `oo` |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `sol`包含[`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") | `oo` |'
- en: '`oo` here means the SymPy infinity, which should compare greater than any integer.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`oo`在这里表示SymPy的无穷大，应该比任何整数都要大。'
- en: If you already know [`solve()`](solvers.html#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    cannot solve `sol`, you can use `trysolving=False` to skip that step, which is
    the only potentially slow step. For example, [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") with the `simplify=False` flag should do this.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经知道[`solve()`](solvers.html#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")无法解决`sol`，则可以使用`trysolving=False`跳过该步骤，这是唯一可能比较慢的步骤。例如，带有`simplicity=False`标志的[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")应该会这样做。
- en: If `sol` is a list of solutions, if the worst solution in the list returns `oo`
    it returns that, otherwise it returns `len(str(sol))`, that is, the length of
    the string representation of the whole list.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sol`是解的列表，则如果列表中的最坏解返回`oo`，则返回该值，否则返回`len(str(sol))`，即整个列表的字符串表示的长度。
- en: Examples
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'This function is designed to be passed to `min` as the key argument, such as
    `min(listofsolutions, key=lambda i: ode_sol_simplicity(i, f(x)))`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '此函数旨在作为`min`的关键参数传递，例如`min(listofsolutions, key=lambda i: ode_sol_simplicity(i,
    f(x)))`。'
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Solves equations having a solvable factor.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 解决具有可解因子的方程。
- en: This function is used to solve the equation having factors. Factors may be of
    type algebraic or ode. It will try to solve each factor independently. Factors
    will be solved by calling dsolve. We will return the list of solutions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于解决具有因子的方程。因子可能是代数或ode类型。它将尝试独立解决每个因子。通过调用dsolve解决因子。我们将返回解的列表。
- en: Examples
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Solves 1st order exact ordinary differential equations.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一阶确切常微分方程。
- en: A 1st order differential equation is called exact if it is the total differential
    of a function. That is, the differential equation
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一阶微分方程如果是某个函数的全微分，则称为确切微分方程。也就是说，微分方程
- en: \[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: \[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]
- en: 'is exact if there is some function \(F(x, y)\) such that \(P(x, y) = \partial{}F/\partial{}x\)
    and \(Q(x, y) = \partial{}F/\partial{}y\). It can be shown that a necessary and
    sufficient condition for a first order ODE to be exact is that \(\partial{}P/\partial{}y
    = \partial{}Q/\partial{}x\). Then, the solution will be as given below:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在某个函数 \(F(x, y)\)，使得 \(P(x, y) = \partial{}F/\partial{}x\) 且 \(Q(x, y) =
    \partial{}F/\partial{}y\)，则此微分方程是确切的。可以证明，第一阶微分方程确切的必要和充分条件是 \(\partial{}P/\partial{}y
    = \partial{}Q/\partial{}x\)。此时，解将如下所示：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Where the first partials of \(P\) and \(Q\) exist and are continuous in a simply
    connected region.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第一偏导数的 \(P\) 和 \(Q\) 在单连通区域内存在且连续时。
- en: 'A note: SymPy currently has no way to represent inert substitution on an expression,
    so the hint `1st_exact_Integral` will return an integral with \(dy\). This is
    supposed to represent the function that you are solving for.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注：SymPy 目前无法表示对表达式的惰性替换，因此提示 `1st_exact_Integral` 将返回带有 \(dy\) 的积分。这应表示您正在解决的函数。
- en: Examples
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: References
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://en.wikipedia.org/wiki/Exact_differential_equation](https://en.wikipedia.org/wiki/Exact_differential_equation)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Exact_differential_equation](https://en.wikipedia.org/wiki/Exact_differential_equation)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    73
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    73
- en: indirect doctest
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接测试
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Returns the best solution to an ODE from the two hints `1st_homogeneous_coeff_subs_dep_div_indep`
    and `1st_homogeneous_coeff_subs_indep_div_dep`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从两个提示 `1st_homogeneous_coeff_subs_dep_div_indep` 和 `1st_homogeneous_coeff_subs_indep_div_dep`
    中得到的常微分方程的最佳解。
- en: This is as determined by [`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity
    "sympy.solvers.ode.ode.ode_sol_simplicity").
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由 [`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity "sympy.solvers.ode.ode.ode_sol_simplicity")
    决定的。
- en: See the [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep") and [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") docstrings for more
    information on these hints. Note that there is no `ode_1st_homogeneous_coeff_best_Integral`
    hint.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep") 和 [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") 的文档字符串，了解有关这些提示的更多信息。请注意，没有
    `ode_1st_homogeneous_coeff_best_Integral` 提示。
- en: Examples
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: References
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
- en: indirect doctest
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接测试
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Solves a 1st order differential equation with homogeneous coefficients using
    the substitution \(u_1 = \frac{\text{<dependent variable>}}{\text{<independent
    variable>}}\).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代换 \(u_1 = \frac{\text{<dependent variable>}}{\text{<independent variable>}}\)
    解决具有同次系数的一阶微分方程。
- en: This is a differential equation
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微分方程
- en: \[P(x, y) + Q(x, y) dy/dx = 0\]
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: \[P(x, y) + Q(x, y) dy/dx = 0\]
- en: such that \(P\) and \(Q\) are homogeneous and of the same order. A function
    \(F(x, y)\) is homogeneous of order \(n\) if \(F(x t, y t) = t^n F(x, y)\). Equivalently,
    \(F(x, y)\) can be rewritten as \(G(y/x)\) or \(H(x/y)\). See also the docstring
    of [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order").
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的 \(P\) 和 \(Q\) 是同次的，并且同一个顺序。如果函数 \(F(x, y)\) 是顺序为 \(n\) 的同次函数，那么 \(F(x t,
    y t) = t^n F(x, y)\)。等效地，\(F(x, y)\) 可以重写为 \(G(y/x)\) 或者 \(H(x/y)\)。详见 [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order
    "sympy.solvers.ode.homogeneous_order") 的文档字符串。
- en: 'If the coefficients \(P\) and \(Q\) in the differential equation above are
    homogeneous functions of the same order, then it can be shown that the substitution
    \(y = u_1 x\) (i.e. \(u_1 = y/x\)) will turn the differential equation into an
    equation separable in the variables \(x\) and \(u\). If \(h(u_1)\) is the function
    that results from making the substitution \(u_1 = f(x)/x\) on \(P(x, f(x))\) and
    \(g(u_2)\) is the function that results from the substitution on \(Q(x, f(x))\)
    in the differential equation \(P(x, f(x)) + Q(x, f(x)) f''(x) = 0\), then the
    general solution is:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述微分方程中的系数 \(P\) 和 \(Q\) 是同阶次的齐次函数，则可以证明将变量 \(x\) 和 \(u\) 分离的代换 \(y = u_1
    x\)（即 \(u_1 = y/x\)）将把微分方程变为关于变量 \(x\) 和 \(u\) 的可分离方程。如果 \(h(u_1)\) 是通过在 \(P(x,
    f(x))\) 上进行 \(u_1 = f(x)/x\) 替换得到的函数，\(g(u_2)\) 是在微分方程 \(P(x, f(x)) + Q(x, f(x))
    f'(x) = 0\) 中对 \(Q(x, f(x))\) 进行替换得到的函数，则一般解为：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Where \(u_1 h(u_1) + g(u_1) \ne 0\) and \(x \ne 0\).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(u_1 h(u_1) + g(u_1) \ne 0\)，且 \(x \ne 0\)。
- en: See also the docstrings of [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest") and [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep").
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest "sympy.solvers.ode.single.HomogeneousCoeffBest")
    和 [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep") 的文档字符串。
- en: Examples
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: References
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard，《普通微分方程》，多佛 1963 年，第 59 页
- en: indirect doctest
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接 doctest
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Solves a 1st order differential equation with homogeneous coefficients using
    the substitution \(u_2 = \frac{\text{<independent variable>}}{\text{<dependent
    variable>}}\).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换 \(u_2 = \frac{\text{独立变量}}{\text{因变量}}\) 解决具有齐次系数的一阶微分方程。
- en: This is a differential equation
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微分方程
- en: \[P(x, y) + Q(x, y) dy/dx = 0\]
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: \[P(x, y) + Q(x, y) dy/dx = 0\]
- en: such that \(P\) and \(Q\) are homogeneous and of the same order. A function
    \(F(x, y)\) is homogeneous of order \(n\) if \(F(x t, y t) = t^n F(x, y)\). Equivalently,
    \(F(x, y)\) can be rewritten as \(G(y/x)\) or \(H(x/y)\). See also the docstring
    of [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order").
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(P\) 和 \(Q\) 是同阶次的齐次函数。如果函数 \(F(x, y)\) 是阶次为 \(n\) 的齐次函数，则满足 \(F(x t, y
    t) = t^n F(x, y)\)。等价地，\(F(x, y)\) 可以重写为 \(G(y/x)\) 或 \(H(x/y)\)。参见 [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order
    "sympy.solvers.ode.homogeneous_order") 的文档字符串。
- en: 'If the coefficients \(P\) and \(Q\) in the differential equation above are
    homogeneous functions of the same order, then it can be shown that the substitution
    \(x = u_2 y\) (i.e. \(u_2 = x/y\)) will turn the differential equation into an
    equation separable in the variables \(y\) and \(u_2\). If \(h(u_2)\) is the function
    that results from making the substitution \(u_2 = x/f(x)\) on \(P(x, f(x))\) and
    \(g(u_2)\) is the function that results from the substitution on \(Q(x, f(x))\)
    in the differential equation \(P(x, f(x)) + Q(x, f(x)) f''(x) = 0\), then the
    general solution is:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述微分方程中的系数 \(P\) 和 \(Q\) 是同阶次的齐次函数，则可以证明将变量 \(y\) 和 \(u_2\) 分离的代换 \(x = u_2
    y\)（即 \(u_2 = x/y\)）将把微分方程变为关于变量 \(y\) 和 \(u_2\) 的可分离方程。如果 \(h(u_2)\) 是通过在 \(P(x,
    f(x))\) 上进行 \(u_2 = x/f(x)\) 替换得到的函数，\(g(u_2)\) 是在微分方程 \(P(x, f(x)) + Q(x, f(x))
    f'(x) = 0\) 中对 \(Q(x, f(x))\) 进行替换得到的函数，则一般解为：
- en: '[PRE46]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Where \(u_1 g(u_1) + h(u_1) \ne 0\) and \(f(x) \ne 0\).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(u_1 g(u_1) + h(u_1) \ne 0\)，且 \(f(x) \ne 0\)。
- en: See also the docstrings of [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest") and [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep").
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest "sympy.solvers.ode.single.HomogeneousCoeffBest")
    和 [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") 的文档字符串。
- en: Examples
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: References
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard，《普通微分方程》，多佛 1963 年，第 59 页
- en: indirect doctest
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接 doctest
- en: '[PRE48]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Solves 1st order linear differential equations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 解一阶线性微分方程。
- en: These are differential equations of the form
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是形如
- en: \[dy/dx + P(x) y = Q(x)\text{.}\]
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: \[dy/dx + P(x) y = Q(x)\text{。}\]
- en: 'These kinds of differential equations can be solved in a general way. The integrating
    factor \(e^{\int P(x) \,dx}\) will turn the equation into a separable equation.
    The general solution is:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这类微分方程可以一般地解出。积分因子 \(e^{\int P(x) \,dx}\) 将方程变成可分离方程。一般解为：
- en: '[PRE49]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Examples
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE50]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: References
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients](https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性微分方程#具有变系数的一阶方程](https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients)。'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    92
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    92
- en: indirect doctest
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接 doctest
- en: '[PRE51]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Gives general solutions to the first order Riccati differential equations that
    have atleast one rational particular solution.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 给出至少有一个有理特解的一阶里卡提微分方程的一般解。
- en: \[y' = b_0(x) + b_1(x) y + b_2(x) y^2\]
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: \[y' = b_0(x) + b_1(x) y + b_2(x) y^2\]
- en: where \(b_0\), \(b_1\) and \(b_2\) are rational functions of \(x\) with \(b_2
    \ne 0\) (\(b_2 = 0\) would make it a Bernoulli equation).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(b_0\)、\(b_1\) 和 \(b_2\) 是 \(x\) 的有理函数且 \(b_2 \ne 0\)（\(b_2 = 0\) 会使其成为贝努利方程）。
- en: Examples
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE52]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: References
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Riccati ODE: [https://en.wikipedia.org/wiki/Riccati_equation](https://en.wikipedia.org/wiki/Riccati_equation)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Riccati ODE: [里卡提方程](https://zh.wikipedia.org/wiki/%E9%87%8C%E5%8D%A1%E6%8F%90%E6%96%B9%E7%A8%8B)。'
- en: 'N. Thieu Vo - Rational and Algebraic Solutions of First-Order Algebraic ODEs:
    Algorithm 11, pp. 78 - [https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf](https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'N. Thieu Vo - Rational and Algebraic Solutions of First-Order Algebraic ODEs:
    Algorithm 11, pp. 78 - [https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf](https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf)'
- en: '[PRE54]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Gives solution of the Airy differential equation
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 给出 Airy 微分方程的解
- en: \[\frac{d^2y}{dx^2} + (a + b x) y(x) = 0\]
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{d^2y}{dx^2} + (a + b x) y(x) = 0\]
- en: in terms of Airy special functions airyai and airybi.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Airy 特殊函数 airyai 和 airybi 的问题。
- en: Examples
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE55]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Gives solution of the Bessel differential equation
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 给出贝塞尔微分方程的解
- en: \[x^2 \frac{d^2y}{dx^2} + x \frac{dy}{dx} y(x) + (x^2-n^2) y(x)\]
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: \[x^2 \frac{d^2y}{dx^2} + x \frac{dy}{dx} y(x) + (x^2-n^2) y(x)\]
- en: if \(n\) is integer then the solution is of the form `Eq(f(x), C0 besselj(n,x)
    + C1 bessely(n,x))` as both the solutions are linearly independent else if \(n\)
    is a fraction then the solution is of the form `Eq(f(x), C0 besselj(n,x) + C1
    besselj(-n,x))` which can also transform into `Eq(f(x), C0 besselj(n,x) + C1 bessely(n,x))`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 若 \(n\) 是整数，则解的形式为 `Eq(f(x), C0 besselj(n,x) + C1 bessely(n,x))`，因为这两个解是线性无关的；否则，若
    \(n\) 是分数，则解的形式为 `Eq(f(x), C0 besselj(n,x) + C1 besselj(-n,x))`，这也可以变形为 `Eq(f(x),
    C0 besselj(n,x) + C1 bessely(n,x))`。
- en: Examples
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE57]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: References
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://math24.net/bessel-differential-equation.html](https://math24.net/bessel-differential-equation.html)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[贝塞尔微分方程](https://math24.net/bessel-differential-equation.html)。'
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Solves Bernoulli differential equations.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 解贝努利微分方程。
- en: These are equations of the form
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是形如
- en: \[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: \[dy/dx + P(x) y = Q(x) y^n\text{，}n \ne 1`\text{。}\]
- en: 'The substitution \(w = 1/y^{1-n}\) will transform an equation of this form
    into one that is linear (see the docstring of [`FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear")). The general solution is:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 替换 \(w = 1/y^{1-n}\) 将这种类型的方程转化为线性方程（见 [`FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear") 的文档字符串）。一般解为：
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that the equation is separable when \(n = 1\) (see the docstring of [`Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable")).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 \(n = 1\) 时，方程是可分离的（见 [`Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable") 的文档字符串）。
- en: '[PRE60]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Examples
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: References
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Bernoulli_differential_equation](https://en.wikipedia.org/wiki/Bernoulli_differential_equation)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[贝努利微分方程](https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8A%AA%E5%88%A9%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B)。'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    95
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    95
- en: indirect doctest
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接 doctest
- en: '[PRE63]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Solves 2nd order Liouville differential equations.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 解二阶 Liouville 微分方程。
- en: The general form of a Liouville ODE is
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 里卡提 ODE 的一般形式是
- en: \[\frac{d^2 y}{dx^2} + g(y) \left(\! \frac{dy}{dx}\!\right)^2 + h(x) \frac{dy}{dx}\text{.}\]
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{d^2 y}{dx^2} + g(y) \left(\! \frac{dy}{dx}\!\right)^2 + h(x) \frac{dy}{dx}\text{.}\]
- en: 'The general solution is:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 一般解是：
- en: '[PRE64]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Examples
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: References
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: Goldstein and Braun, “Advanced Methods for the Solution of Differential Equations”,
    pp. 98
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goldstein and Braun, “Advanced Methods for the Solution of Differential Equations”,
    pp. 98
- en: '[https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Maple支持文档](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville)'
- en: indirect doctest
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接的doctest
- en: '[PRE66]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The general Riccati equation has the form
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的Riccati方程形式为
- en: \[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: \[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]
- en: While it does not have a general solution [1], the “special” form, \(dy/dx =
    a y^2 - b x^c\), does have solutions in many cases [2]. This routine returns a
    solution for \(a(dy/dx) = b y^2 + c y/x + d/x^2\) that is obtained by using a
    suitable change of variables to reduce it to the special form and is valid when
    neither \(a\) nor \(b\) are zero and either \(c\) or \(d\) is zero.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有通解 [1]，但“特殊”形式 \(dy/dx = a y^2 - b x^c\) 在许多情况下有解 [2]。此例程返回解 \(a(dy/dx)
    = b y^2 + c y/x + d/x^2\)，通过使用适当的变量变换将其化简为特殊形式，并在 \(a\) 和 \(b\) 都不为零且 \(c\) 或
    \(d\) 其中之一为零时有效。
- en: '[PRE67]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: References
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Maple支持文档](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati)'
- en: '[https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf](https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf)
    - [https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf](https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf)'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ODE解](https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf) - [ODE解](https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf)'
- en: '[PRE69]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Solves an \(n\)th order linear homogeneous differential equation with constant
    coefficients.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 解出具有常系数的第 \(n\) 阶线性齐次微分方程。
- en: This is an equation of the form
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种形式的方程。
- en: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = 0\text{.}\]
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = 0\text{.}\]
- en: These equations can be solved in a general manner, by taking the roots of the
    characteristic equation \(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m + a_0 = 0\).
    The solution will then be the sum of \(C_n x^i e^{r x}\) terms, for each where
    \(C_n\) is an arbitrary constant, \(r\) is a root of the characteristic equation
    and \(i\) is one of each from 0 to the multiplicity of the root - 1 (for example,
    a root 3 of multiplicity 2 would create the terms \(C_1 e^{3 x} + C_2 x e^{3 x}\)).
    The exponential is usually expanded for complex roots using Euler’s equation \(e^{I
    x} = \cos(x) + I \sin(x)\). Complex roots always come in conjugate pairs in polynomials
    with real coefficients, so the two roots will be represented (after simplifying
    the constants) as \(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程可以通过取特征方程的根来以一般方式解决，然后解将是每个根 \(r\) 的 \(C_n x^i e^{r x}\) 项的和，其中 \(C_n\)
    是任意常数，\(r\) 是特征方程的根，\(i\) 是从0到根的重数减1的每个值（例如，重数为2的根3将创建项 \(C_1 e^{3 x} + C_2 x
    e^{3 x}\)）。指数通常使用欧拉方程 \(e^{I x} = \cos(x) + I \sin(x)\) 来展开复根。在具有实系数的多项式中，复根总是成对共轭出现，因此两个根（在简化常数后）将表示为
    \(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\)。
- en: If SymPy cannot find exact roots to the characteristic equation, a [`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") instance will be return instead.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SymPy无法找到特征方程的确切根，将返回[`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")实例。
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that because this method does not involve integration, there is no `nth_linear_constant_coeff_homogeneous_Integral`
    hint.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于此方法不涉及积分，因此没有 `nth_linear_constant_coeff_homogeneous_Integral` 提示。
- en: Examples
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE71]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: References
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://en.wikipedia.org/wiki/Linear_differential_equation](https://en.wikipedia.org/wiki/Linear_differential_equation)
    section: Nonhomogeneous_equation_with_constant_coefficients'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性微分方程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B)部分：非齐次方程与恒定系数'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    211
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    211
- en: indirect doctest
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接的doctest
- en: '[PRE72]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Solves an \(n\)th order linear differential equation with constant coefficients
    using the method of undetermined coefficients.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特解法解决具有常系数的\( n \)阶线性微分方程。
- en: This method works on differential equations of the form
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法适用于形如
- en: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{,}\]
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{，}\]
- en: where \(P(x)\) is a function that has a finite number of linearly independent
    derivatives.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\( P(x) \)是一个具有有限个线性独立导数的函数。
- en: Functions that fit this requirement are finite sums functions of the form \(a
    x^i e^{b x} \sin(c x + d)\) or \(a x^i e^{b x} \cos(c x + d)\), where \(i\) is
    a non-negative integer and \(a\), \(b\), \(c\), and \(d\) are constants. For example
    any polynomial in \(x\), functions like \(x^2 e^{2 x}\), \(x \sin(x)\), and \(e^x
    \cos(x)\) can all be used. Products of \(\sin\)’s and \(\cos\)’s have a finite
    number of derivatives, because they can be expanded into \(\sin(a x)\) and \(\cos(b
    x)\) terms. However, SymPy currently cannot do that expansion, so you will need
    to manually rewrite the expression in terms of the above to use this method. So,
    for example, you will need to manually convert \(\sin^2(x)\) into \((1 + \cos(2
    x))/2\) to properly apply the method of undetermined coefficients on it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这一要求的函数是形如\( a x^i e^{b x} \sin(c x + d) \)或\( a x^i e^{b x} \cos(c x + d)
    \)的有限和函数，其中\( i \)是非负整数，\( a \)、\( b \)、\( c \)和\( d \)是常数。例如，任何\( x \)的多项式，像\(
    x^2 e^{2 x} \)、\( x \sin(x) \)和\( e^x \cos(x) \)等函数都可以使用。\( \sin \) 和 \( \cos
    \) 的乘积具有有限数量的导数，因为它们可以展开为\( \sin(a x) \)和\( \cos(b x) \)项。然而，SymPy目前无法执行该展开，因此您需要手动将表达式重写为以上形式才能使用此方法。因此，例如，您需要手动将\(
    \sin^2(x) \)转换为\( (1 + \cos(2 x))/2 \)才能正确地应用特解法。
- en: This method works by creating a trial function from the expression and all of
    its linear independent derivatives and substituting them into the original ODE.
    The coefficients for each term will be a system of linear equations, which are
    be solved for and substituted, giving the solution. If any of the trial functions
    are linearly dependent on the solution to the homogeneous equation, they are multiplied
    by sufficient \(x\) to make them linearly independent.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过从表达式及其所有线性独立导数创建试验函数，并将它们代入原始ODE中来工作。每个项的系数将成为一组线性方程，这些方程将被解出并代入，从而得到解。如果任何试验函数与齐次方程的解线性相关，则它们将乘以足够的\(
    x \)使它们线性无关。
- en: Examples
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE73]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: References
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients](https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients)'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/特解法](https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    221
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard，《Ordinary Differential Equations》，Dover 1963年，第221页
- en: indirect doctest
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接文档测试
- en: '[PRE74]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Solves an \(n\)th order linear differential equation with constant coefficients
    using the method of variation of parameters.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数变化法解决具有常系数的\( n \)阶线性微分方程。
- en: This method works on any differential equations of the form
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法适用于形如
- en: \[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{.}\]
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: \[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{。}\]
- en: This method works by assuming that the particular solution takes the form
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过假设特解的形式来工作
- en: \[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{x=1}^{n} c_i(x) y_i(x)\text{，}\]
- en: where \(y_i\) is the \(i\)th solution to the homogeneous equation. The solution
    is then solved using Wronskian’s and Cramer’s Rule. The particular solution is
    given by
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\( y_i \)是齐次方程的第\( i \)个解。然后使用朗斯基行列式和克莱姆法则解决方程。特解由以下给出
- en: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx \right) y_i(x) \text{,}\]
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx \right) y_i(x) \text{，}\]
- en: where \(W(x)\) is the Wronskian of the fundamental system (the system of \(n\)
    linearly independent solutions to the homogeneous equation), and \(W_i(x)\) is
    the Wronskian of the fundamental system with the \(i\)th column replaced with
    \([0, 0, \cdots, 0, P(x)]\).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\( W(x) \)是基础系统的朗斯基行列式（齐次方程的\( n \)个线性独立解的系统），\( W_i(x) \)是将第\( i \)列替换为\([0,
    0, \cdots, 0, P(x)]\)后的基础系统的朗斯基行列式。
- en: This method is general enough to solve any \(n\)th order inhomogeneous linear
    differential equation with constant coefficients, but sometimes SymPy cannot simplify
    the Wronskian well enough to integrate it. If this method hangs, try using the
    `nth_linear_constant_coeff_variation_of_parameters_Integral` hint and simplifying
    the integrals manually. Also, prefer using `nth_linear_constant_coeff_undetermined_coefficients`
    when it applies, because it does not use integration, making it faster and more
    reliable.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法足够通用，可解决任何具有常系数的 \(n\) 阶非齐次线性微分方程，但有时 SymPy 无法将朗斯基行列式简化到足够程度以进行积分。如果此方法挂起，请尝试使用
    `nth_linear_constant_coeff_variation_of_parameters_Integral` 提示并手动简化积分。此外，当适用时，最好使用
    `nth_linear_constant_coeff_undetermined_coefficients`，因为它不使用积分，速度更快且更可靠。
- en: Warning, using simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters’
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") may cause
    it to hang, because it will not attempt to simplify the Wronskian before integrating.
    It is recommended that you only use simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters_Integral’
    for this method, especially if the solution to the homogeneous equation has trigonometric
    functions in it.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 中使用
    `simplify=False` 和 ‘nth_linear_constant_coeff_variation_of_parameters’ 可能导致其挂起，因为它不会在积分之前尝试简化朗斯基行列式。建议您仅在该方法中使用
    `simplify=False` 和 ‘nth_linear_constant_coeff_variation_of_parameters_Integral’，特别是当齐次方程的解中包含三角函数时。
- en: Examples
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE75]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: References
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://en.wikipedia.org/wiki/Variation_of_parameters](https://en.wikipedia.org/wiki/Variation_of_parameters)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/参数变易法](https://zh.wikipedia.org/wiki/参数变易法)'
- en: '[https://planetmath.org/VariationOfParameters](https://planetmath.org/VariationOfParameters)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://zh.numberempire.com/参数变易法](https://zh.numberempire.com/参数变易法)'
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    233
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard，“Ordinary Differential Equations”，Dover 1963，pp. 233
- en: indirect doctest
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接的doctest
- en: '[PRE76]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Solves an \(n\)th order linear homogeneous variable-coefficient Cauchy-Euler
    equidimensional ordinary differential equation.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 \(n\) 阶线性齐次变系数欧拉－欧拉方程。
- en: This is an equation with form \(0 = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个形如 \(0 = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x) \cdots\) 的方程。
- en: These equations can be solved in a general manner, by substituting solutions
    of the form \(f(x) = x^r\), and deriving a characteristic equation for \(r\).
    When there are repeated roots, we include extra terms of the form \(C_{r k} \ln^k(x)
    x^r\), where \(C_{r k}\) is an arbitrary integration constant, \(r\) is a root
    of the characteristic equation, and \(k\) ranges over the multiplicity of \(r\).
    In the cases where the roots are complex, solutions of the form \(C_1 x^a \sin(b
    \log(x)) + C_2 x^a \cos(b \log(x))\) are returned, based on expansions with Euler’s
    formula. The general solution is the sum of the terms found. If SymPy cannot find
    exact roots to the characteristic equation, a [`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") instance will be returned instead.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程可以通过用 \(f(x) = x^r\) 形式的解代入，并为 \(r\) 派生特征方程得到一般解。当存在重根时，我们包括额外的形式为 \(C_{r
    k} \ln^k(x) x^r\) 的项，其中 \(C_{r k}\) 是任意积分常数，\(r\) 是特征方程的根，并且 \(k\) 取值范围包括 \(r\)
    的重数。在根为复数的情况下，根据欧拉公式的展开，返回形式为 \(C_1 x^a \sin(b \log(x)) + C_2 x^a \cos(b \log(x))\)
    的解。一般解是找到的各项之和。如果 SymPy 无法找到特征方程的确切根，则会返回 [`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") 实例。
- en: '[PRE77]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that because this method does not involve integration, there is no `nth_linear_euler_eq_homogeneous_Integral`
    hint.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为此方法不涉及积分，所以没有 `nth_linear_euler_eq_homogeneous_Integral` 提示。
- en: 'The following is for internal use:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容仅供内部使用：
- en: '`returns = ''sol''` returns the solution to the ODE.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returns = ''sol''` 返回常微分方程的解。'
- en: '`returns = ''list''` returns a list of linearly independent solutions, corresponding
    to the fundamental solution set, for use with non homogeneous solution methods
    like variation of parameters and undetermined coefficients. Note that, though
    the solutions should be linearly independent, this function does not explicitly
    check that. You can do `assert simplify(wronskian(sollist)) != 0` to check for
    linear independence. Also, `assert len(sollist) == order` will need to pass.'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returns = ''list''` 返回线性独立解的列表，对应于基本解集，用于非齐次解法如参数变化法和待定系数法。请注意，尽管解应该是线性独立的，但此函数并不显式检查。您可以使用`assert
    simplify(wronskian(sollist)) != 0`来检查线性独立性。还需要通过`assert len(sollist) == order`。'
- en: '`returns = ''both''`, return a dictionary `{''sol'': <solution to ODE>, ''list'':
    <list of linearly independent solutions>}`.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`returns = ''both''`，返回一个字典`{''sol'': <ODE的解>, ''list'': <线性独立解的列表>}`。'
- en: Examples
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE78]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: References
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation](https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/%E5%BD%93%E4%BB%A3%E6%95%B0](https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation)'
- en: C. Bender & S. Orszag, “Advanced Mathematical Methods for Scientists and Engineers”,
    Springer 1999, pp. 12
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C. Bender & S. Orszag, “Advanced Mathematical Methods for Scientists and Engineers”,
    Springer 1999, pp. 12
- en: indirect doctest
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接的doctest
- en: '[PRE79]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Solves an \(n\)th order linear non homogeneous Cauchy-Euler equidimensional
    ordinary differential equation using variation of parameters.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数变化法解\(n\)阶线性非齐次Cauchy-Euler等价普通微分方程。
- en: This is an equation with form \(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个形式为\(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x) \cdots\)的方程。
- en: This method works by assuming that the particular solution takes the form
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过假设特解采用以下形式运作
- en: \[\sum_{x=1}^{n} c_i(x) y_i(x) {a_n} {x^n} \text{, }\]
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{x=1}^{n} c_i(x) y_i(x) {a_n} {x^n} \text{, }\]
- en: where \(y_i\) is the \(i\)th solution to the homogeneous equation. The solution
    is then solved using Wronskian’s and Cramer’s Rule. The particular solution is
    given by multiplying eq given below with \(a_n x^{n}\)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(y_i\)是齐次方程的第\(i\)个解。然后使用Wronskian和Cramer法则解出解。特解由以下给定的方程乘以\(a_n x^{n}\)得到。
- en: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \, dx \right) y_i(x) \text{,
    }\]
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \, dx \right) y_i(x) \text{,
    }\]
- en: where \(W(x)\) is the Wronskian of the fundamental system (the system of \(n\)
    linearly independent solutions to the homogeneous equation), and \(W_i(x)\) is
    the Wronskian of the fundamental system with the \(i\)th column replaced with
    \([0, 0, \cdots, 0, \frac{x^{- n}}{a_n} g{\left(x \right)}]\).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(W(x)\)是基本系统的Wronskian（\(n\)个线性独立解组成的系统的Wronskian），\(W_i(x)\)是基本系统的Wronskian，其中第\(i\)列被替换为\([0,
    0, \cdots, 0, \frac{x^{- n}}{a_n} g{\left(x \right)}]\)。
- en: This method is general enough to solve any \(n\)th order inhomogeneous linear
    differential equation, but sometimes SymPy cannot simplify the Wronskian well
    enough to integrate it. If this method hangs, try using the `nth_linear_constant_coeff_variation_of_parameters_Integral`
    hint and simplifying the integrals manually. Also, prefer using `nth_linear_constant_coeff_undetermined_coefficients`
    when it applies, because it does not use integration, making it faster and more
    reliable.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法足够一般，可以解任意\(n\)阶非齐次线性微分方程，但有时SymPy无法将Wronskian简化到足够简单以进行积分。如果这种方法卡住，请尝试使用`nth_linear_constant_coeff_variation_of_parameters_Integral`提示，并手动简化积分。此外，当适用时优先使用`nth_linear_constant_coeff_undetermined_coefficients`，因为它不使用积分，更快速和可靠。
- en: Warning, using simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters’
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") may cause
    it to hang, because it will not attempt to simplify the Wronskian before integrating.
    It is recommended that you only use simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters_Integral’
    for this method, especially if the solution to the homogeneous equation has trigonometric
    functions in it.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")中与`nth_linear_constant_coeff_variation_of_parameters`一起使用`simplify=False`可能会导致卡住，因为在积分之前它不会尝试简化Wronskian。建议您仅在使用‘simplify=False’与‘nth_linear_constant_coeff_variation_of_parameters_Integral’时才使用此方法，特别是如果齐次方程的解中含有三角函数。
- en: Examples
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE80]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Solves an \(n\)th order linear non homogeneous Cauchy-Euler equidimensional
    ordinary differential equation using undetermined coefficients.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使用待定系数法解\(n\)阶线性非齐次Cauchy-Euler等价普通微分方程。
- en: This is an equation with form \(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个形如\( g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x) \cdots \)的方程。
- en: These equations can be solved in a general manner, by substituting solutions
    of the form \(x = exp(t)\), and deriving a characteristic equation of form \(g(exp(t))
    = b_0 f(t) + b_1 f'(t) + b_2 f''(t) \cdots\) which can be then solved by nth_linear_constant_coeff_undetermined_coefficients
    if g(exp(t)) has finite number of linearly independent derivatives.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程可以通过用\( x = exp(t) \)的形式的解来解决，然后推导形式为\( g(exp(t)) = b_0 f(t) + b_1 f'(t)
    + b_2 f''(t) \cdots \)的特征方程。如果\( g(exp(t)) \)有有限数量的线性独立导数，那么可以通过n次线性常系数特解法来解决。
- en: Functions that fit this requirement are finite sums functions of the form \(a
    x^i e^{b x} \sin(c x + d)\) or \(a x^i e^{b x} \cos(c x + d)\), where \(i\) is
    a non-negative integer and \(a\), \(b\), \(c\), and \(d\) are constants. For example
    any polynomial in \(x\), functions like \(x^2 e^{2 x}\), \(x \sin(x)\), and \(e^x
    \cos(x)\) can all be used. Products of \(\sin\)’s and \(\cos\)’s have a finite
    number of derivatives, because they can be expanded into \(\sin(a x)\) and \(\cos(b
    x)\) terms. However, SymPy currently cannot do that expansion, so you will need
    to manually rewrite the expression in terms of the above to use this method. So,
    for example, you will need to manually convert \(\sin^2(x)\) into \((1 + \cos(2
    x))/2\) to properly apply the method of undetermined coefficients on it.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 符合此要求的函数是形如\( a x^i e^{b x} \sin(c x + d) \)或\( a x^i e^{b x} \cos(c x + d)
    \)的有限和函数，其中\( i \)是非负整数，\( a \)，\( b \)，\( c \)，和\( d \)是常数。例如，任何关于\( x \)的多项式，如\(
    x^2 e^{2 x} \)，\( x \sin(x) \)，和\( e^x \cos(x) \)都可以使用。\( \sin \)和\( \cos \)的乘积具有有限数量的导数，因为它们可以展开为\(
    \sin(a x) \)和\( \cos(b x) \)的项。然而，SymPy目前无法执行这种展开，因此您需要手动将表达式转换为上述形式才能使用此方法。例如，您需要手动将\(
    \sin^2(x) \)正确转换为\( (1 + \cos(2 x))/2 \)以便适当地应用待定系数法。
- en: After replacement of x by exp(t), this method works by creating a trial function
    from the expression and all of its linear independent derivatives and substituting
    them into the original ODE. The coefficients for each term will be a system of
    linear equations, which are be solved for and substituted, giving the solution.
    If any of the trial functions are linearly dependent on the solution to the homogeneous
    equation, they are multiplied by sufficient \(x\) to make them linearly independent.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 将\( x \)替换为\( exp(t) \)后，此方法通过从表达式及其所有线性独立导数中创建一个试探函数，并将它们代入原始的ODE中来运行。每个项的系数将形成一组线性方程，可以解出并代入，从而得到解。如果任何试探函数线性依赖于齐次方程的解，则它们将乘以足够的\(
    x \)使它们线性独立。
- en: Examples
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE82]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Solves an \(n\)th order ordinary differential equation using algebra and integrals.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代数和积分解决n阶常微分方程。
- en: There is no general form for the kind of equation that this can solve. The the
    equation is solved algebraically treating differentiation as an invertible algebraic
    function.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 此类方程的一般形式不存在，这种方程通过将微分视为可逆的代数函数来代数求解。
- en: Examples
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE84]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that this solver can return algebraic solutions that do not have any integration
    constants (f(x) = 0 in the above example).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此求解器可以返回没有任何积分常数的代数解（例如在上面的例子中\( f(x) = 0 \)）。
- en: '[PRE85]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Solves ODEs that only involve derivatives of the dependent variable using a
    substitution of the form \(f^n(x) = g(x)\).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 解决仅涉及因变量导数的ODE，使用形式为\( f^n(x) = g(x) \)的替换。
- en: For example any second order ODE of the form \(f''(x) = h(f'(x), x)\) can be
    transformed into a pair of 1st order ODEs \(g'(x) = h(g(x), x)\) and \(f'(x) =
    g(x)\). Usually the 1st order ODE for \(g\) is easier to solve. If that gives
    an explicit solution for \(g\) then \(f\) is found simply by integration.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何形如\( f''(x) = h(f'(x), x) \)的二阶ODE可以转化为一对一阶ODEs \( g'(x) = h(g(x), x) \)
    和 \( f'(x) = g(x) \)。通常，\( g \)的一阶ODE更容易解决。如果给出了\( g \)的显式解，则通过积分即可找到\( f \)。
- en: Examples
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE86]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Solves separable 1st order differential equations.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 解决可分离的一阶微分方程。
- en: 'This is any differential equation that can be written as \(P(y) \tfrac{dy}{dx}
    = Q(x)\). The solution can then just be found by rearranging terms and integrating:
    \(\int P(y) \,dy = \int Q(x) \,dx\). This hint uses [`sympy.simplify.simplify.separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars") as its back end, so if a separable equation
    is not caught by this solver, it is most likely the fault of that function. [`separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars") is smart enough to do most expansion and
    factoring necessary to convert a separable equation \(F(x, y)\) into the proper
    form \(P(x)\cdot{}Q(y)\). The general solution is:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以写成\(P(y) \tfrac{dy}{dx} = Q(x)\)形式的任何微分方程。解决方案可以通过重新排列项并进行积分找到：\(\int P(y)
    \,dy = \int Q(x) \,dx\)。此提示使用[`sympy.simplify.simplify.separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars")作为其后端，因此如果分离方程不被该解算器捕捉到，很可能是该函数的错误。[`separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars")足够智能，能够执行大多数展开和因式分解操作，以将可分离方程\(F(x, y)\)转换为适当的形式\(P(x)\cdot{}Q(y)\)。一般解是：
- en: '[PRE88]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Examples
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE89]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: References
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    52
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: M. Tenenbaum & H. Pollard，《普通微分方程》，多佛出版社1963年，第52页
- en: indirect doctest
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 间接doctest
- en: '[PRE90]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Solves an almost-linear differential equation.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了一个几乎线性的微分方程。
- en: The general form of an almost linear differential equation is
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎线性微分方程的一般形式是
- en: \[a(x) g'(f(x)) f'(x) + b(x) g(f(x)) + c(x)\]
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: \[a(x) g'(f(x)) f'(x) + b(x) g(f(x)) + c(x)\]
- en: Here \(f(x)\) is the function to be solved for (the dependent variable). The
    substitution \(g(f(x)) = u(x)\) leads to a linear differential equation for \(u(x)\)
    of the form \(a(x) u' + b(x) u + c(x) = 0\). This can be solved for \(u(x)\) by
    the \(first_linear\) hint and then \(f(x)\) is found by solving \(g(f(x)) = u(x)\).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的\(f(x)\)是要求解的函数（因变量）。代换\(g(f(x)) = u(x)\)导致了\(u(x)\)的线性微分方程形式\(a(x) u' +
    b(x) u + c(x) = 0\)。通过`first_linear`提示可以解出\(u(x)\)，然后通过解\(g(f(x)) = u(x)\)找到\(f(x)\)。
- en: Examples
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE91]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: See also
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.solvers.ode.single.FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear")'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.solvers.ode.single.FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear")'
- en: References
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joel Moses，《符号积分 - 动荡的十年》，ACM通讯，第14卷，第8号，1971年8月，第558页
- en: '[PRE92]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Solves a differential equation with linear coefficients.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 解决具有线性系数的微分方程。
- en: The general form of a differential equation with linear coefficients is
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 具有线性系数的微分方程的一般形式是
- en: \[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y + c_2}\!\right) = 0\text{,}\]
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: \[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y + c_2}\!\right) = 0\text{,}\]
- en: where \(a_1\), \(b_1\), \(c_1\), \(a_2\), \(b_2\), \(c_2\) are constants and
    \(a_1 b_2 - a_2 b_1 \ne 0\).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(a_1\)、\(b_1\)、\(c_1\)、\(a_2\)、\(b_2\)、\(c_2\)是常数，且\(a_1 b_2 - a_2 b_1 \ne
    0\)。
- en: 'This can be solved by substituting:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过以下代换解决：
- en: \[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1
    b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1 b_2}\text{.}\end{aligned}\end{align}
    \]
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1
    b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1 b_2}\text{.}\end{aligned}\end{align}
    \]
- en: This substitution reduces the equation to a homogeneous differential equation.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 此代换将方程简化为齐次微分方程。
- en: Examples
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE93]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: See also
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.solvers.ode.single.HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest"), [`sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"), [`sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep")'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.solvers.ode.single.HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest")，[`sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep")，[`sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep")'
- en: References
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joel Moses，《符号积分 - 动荡的十年》，ACM通讯，第14卷，第8号，1971年8月，第558页
- en: '[PRE94]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Solves a differential equation that can be reduced to the separable form.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 解决可以化为可分离形式的微分方程。
- en: The general form of this equation is
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程的一般形式是
- en: \[y' + (y/x) H(x^n y) = 0\text{}.\]
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: \[y' + (y/x) H(x^n y) = 0\text{}.\]
- en: This can be solved by substituting \(u(y) = x^n y\). The equation then reduces
    to the separable form \(\frac{u'}{u (\mathrm{power} - H(u))} - \frac{1}{x} = 0\).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过代入 \(u(y) = x^n y\) 来解决。然后方程被化简为可分离形式 \(\frac{u'}{u (\mathrm{power} - H(u))}
    - \frac{1}{x} = 0\)。
- en: 'The general solution is:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 一般解是：
- en: '[PRE95]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Examples
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE96]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: See also
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`sympy.solvers.ode.single.Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable")'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.solvers.ode.single.Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable")'
- en: References
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joel Moses, “符号积分 - 动荡的十年”, ACM通信, 卷 14, 第8期, 1971年8月, 第558页
- en: '[PRE97]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This hint implements the Lie group method of solving first order differential
    equations. The aim is to convert the given differential equation from the given
    coordinate system into another coordinate system where it becomes invariant under
    the one-parameter Lie group of translations. The converted ODE can be easily solved
    by quadrature. It makes use of the [`sympy.solvers.ode.infinitesimals()`](#sympy.solvers.ode.infinitesimals
    "sympy.solvers.ode.infinitesimals") function which returns the infinitesimals
    of the transformation.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示实现了通过解第一阶微分方程的Lie群方法。其目的是将给定的微分方程从给定坐标系转换为另一个坐标系，在这个坐标系下它变成了一个参数Lie群的不变量。转换后的ODE可以很容易地通过积分求解。它利用了
    [`sympy.solvers.ode.infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    函数返回变换的无穷小量。
- en: The coordinates \(r\) and \(s\) can be found by solving the following Partial
    Differential Equations.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标 \(r\) 和 \(s\) 可以通过解以下偏微分方程来找到。
- en: \[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y} = 0\]\[\xi\frac{\partial
    s}{\partial x} + \eta\frac{\partial s}{\partial y} = 1\]
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: \[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y} = 0\]\[\xi\frac{\partial
    s}{\partial x} + \eta\frac{\partial s}{\partial y} = 1\]
- en: The differential equation becomes separable in the new coordinate system
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的坐标系中，微分方程变为可分离的形式
- en: \[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} + h(x, y)\frac{\partial
    s}{\partial y}}{ \frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial
    y}}\]
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} + h(x, y)\frac{\partial
    s}{\partial y}}{ \frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial
    y}}\]
- en: After finding the solution by integration, it is then converted back to the
    original coordinate system by substituting \(r\) and \(s\) in terms of \(x\) and
    \(y\) again.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 找到积分解后，再通过用 \(r\) 和 \(s\) 用 \(x\) 和 \(y\) 表示的原始坐标系转换回来。
- en: Examples
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE98]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: References
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Solving differential equations by Symmetry Groups, John Starrett, pp. 1 - pp.
    14
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对称群解微分方程，John Starrett, 第1页至第14页
- en: '[PRE99]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Solves 2nd order linear differential equations.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 解二阶线性微分方程。
- en: It computes special function solutions which can be expressed using the 2F1,
    1F1 or 0F1 hypergeometric functions.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算可以用 2F1, 1F1 或 0F1 超几何函数表示的特殊函数解。
- en: \[y'' + A(x) y' + B(x) y = 0\text{,}\]
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: \[y'' + A(x) y' + B(x) y = 0\text{,}\]
- en: where \(A\) and \(B\) are rational functions.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(A\) 和 \(B\) 是有理函数。
- en: These kinds of differential equations have solution of non-Liouvillian form.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这类微分方程的解是非李乌维尔形式的。
- en: Given linear ODE can be obtained from 2F1 given by
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 给定线性ODE可以从2F1给出
- en: \[(x^2 - x) y'' + ((a + b + 1) x - c) y' + b a y = 0\text{,}\]
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: \[(x^2 - x) y'' + ((a + b + 1) x - c) y' + b a y = 0\text{,}\]
- en: where {a, b, c} are arbitrary constants.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 {a, b, c} 是任意常数。
- en: Notes
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注记
- en: The algorithm should find any solution of the form
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 算法应该找到形式为
- en: \[y = P(x) _pF_q(..; ..;\frac{\alpha x^k + \beta}{\gamma x^k + \delta})\text{,}\]
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: \[y = P(x) _pF_q(..; ..;\frac{\alpha x^k + \beta}{\gamma x^k + \delta})\text{,}\]
- en: where pFq is any of 2F1, 1F1 or 0F1 and \(P\) is an “arbitrary function”. Currently
    only the 2F1 case is implemented in SymPy but the other cases are described in
    the paper and could be implemented in future (contributions welcome!).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 pFq 是 2F1, 1F1 或 0F1 中的任意一个，\(P\) 是“任意函数”。目前只有 SymPy 中实现了 2F1 的情况，但是其他情况在论文中有描述，可能在将来实现（欢迎贡献！）。
- en: Examples
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE100]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: References
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: “Non-Liouvillian solutions for second order linear ODEs” by L. Chan, E.S. Cheb-Terrab
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “非李乌维尔形式的二阶线性ODE解”由 L. Chan, E.S. Cheb-Terrab
- en: '[PRE101]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The power series solution is a method which gives the Taylor series expansion
    to the solution of a differential equation.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 幂级数解是一种方法，它给出了微分方程解的泰勒级数展开。
- en: For a first order differential equation \(\frac{dy}{dx} = h(x, y)\), a power
    series solution exists at a point \(x = x_{0}\) if \(h(x, y)\) is analytic at
    \(x_{0}\). The solution is given by
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一阶微分方程 \(\frac{dy}{dx} = h(x, y)\)，在点 \(x = x_{0}\) 处存在幂级数解，如果 \(h(x, y)\)
    在 \(x_{0}\) 处解析。解由以下公式给出
- en: \[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: \[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]
- en: where \(y(x_{0}) = b\) is the value of y at the initial value of \(x_{0}\).
    To compute the values of the \(F_{n}(x_{0},b)\) the following algorithm is followed,
    until the required number of terms are generated.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(y(x_{0}) = b\) 表示 \(x_{0}\) 初始值时的 \(y\) 值。为了计算 \(F_{n}(x_{0},b)\) 的值，遵循以下算法，直到生成所需的项数。
- en: \(F_1 = h(x_{0}, b)\)
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(F_1 = h(x_{0}, b)\)
- en: \(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial
    y}F_{1}\)
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial
    y}F_{1}\)
- en: Examples
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE102]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: References
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Travis W. Walker, Analytic power series technique for solving first-order differential
    equations, p.p 17, 18
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特拉维斯·W·沃克，《解决一阶微分方程的解析幂级数技术》，第17, 18页
- en: '[PRE103]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Gives a power series solution to a second order homogeneous differential equation
    with polynomial coefficients at an ordinary point. A homogeneous differential
    equation is of the form
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通点处，提供了具有多项式系数的二阶齐次微分方程的幂级数解。齐次微分方程的形式为
- en: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
- en: For simplicity it is assumed that \(P(x)\), \(Q(x)\) and \(R(x)\) are polynomials,
    it is sufficient that \(\frac{Q(x)}{P(x)}\) and \(\frac{R(x)}{P(x)}\) exists at
    \(x_{0}\). A recurrence relation is obtained by substituting \(y\) as \(\sum_{n=0}^\infty
    a_{n}x^{n}\), in the differential equation, and equating the nth term. Using this
    relation various terms can be generated.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 \(P(x)\), \(Q(x)\) 和 \(R(x)\) 都是多项式，只需在 \(x_{0}\) 处存在 \(\frac{Q(x)}{P(x)}\)
    和 \(\frac{R(x)}{P(x)}\) 即可。通过将 \(y\) 替换为 \(\sum_{n=0}^\infty a_{n}x^{n}\)，并在微分方程中等价于第
    \(n\) 项，得到递推关系。利用此关系可以生成各种项。
- en: Examples
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE104]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: References
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx](https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx)'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx](https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx)'
- en: George E. Simmons, “Differential Equations with Applications and Historical
    Notes”, p.p 176 - 184
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔治·E·西蒙斯，《应用与历史注解的微分方程》，第176 - 184页
- en: '[PRE105]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Gives a power series solution to a second order homogeneous differential equation
    with polynomial coefficients at a regular point. A second order homogeneous differential
    equation is of the form
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则点处，提供了具有多项式系数的二阶齐次微分方程的幂级数解。二阶齐次微分方程的形式为
- en: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
- en: 'A point is said to regular singular at \(x0\) if \(x - x0\frac{Q(x)}{P(x)}\)
    and \((x - x0)^{2}\frac{R(x)}{P(x)}\) are analytic at \(x0\). For simplicity \(P(x)\),
    \(Q(x)\) and \(R(x)\) are assumed to be polynomials. The algorithm for finding
    the power series solutions is:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(x - x0\frac{Q(x)}{P(x)}\) 和 \((x - x0)^{2}\frac{R(x)}{P(x)}\) 在 \(x0\)
    处解析，则称点在 \(x0\) 处正则奇异。为简单起见，假设 \(P(x)\), \(Q(x)\) 和 \(R(x)\) 是多项式。寻找幂级数解的算法如下：
- en: Try expressing \((x - x0)P(x)\) and \(((x - x0)^{2})Q(x)\) as power series solutions
    about x0\. Find \(p0\) and \(q0\) which are the constants of the power series
    expansions.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将 \((x - x0)P(x)\) 和 \(((x - x0)^{2})Q(x)\) 表达为关于 \(x0\) 的幂级数解。找到幂级数展开的常数
    \(p0\) 和 \(q0\)。
- en: Solve the indicial equation \(f(m) = m(m - 1) + m*p0 + q0\), to obtain the roots
    \(m1\) and \(m2\) of the indicial equation.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解指数方程 \(f(m) = m(m - 1) + m*p0 + q0\)，以获得指数方程的根 \(m1\) 和 \(m2\)。
- en: If \(m1 - m2\) is a non integer there exists two series solutions. If \(m1 =
    m2\), there exists only one solution. If \(m1 - m2\) is an integer, then the existence
    of one solution is confirmed. The other solution may or may not exist.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 \(m1 - m2\) 是非整数，则存在两个级数解。如果 \(m1 = m2\)，则只存在一个解。如果 \(m1 - m2\) 是整数，则确认存在一个解。另一个解可能存在也可能不存在。
- en: The power series solution is of the form \(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\).
    The coefficients are determined by the following recurrence relation. \(a_{n}
    = -\frac{\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\). For the case
    in which \(m1 - m2\) is an integer, it can be seen from the recurrence relation
    that for the lower root \(m\), when \(n\) equals the difference of both the roots,
    the denominator becomes zero. So if the numerator is not equal to zero, a second
    series solution exists.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 幂级数解的形式为\(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\)。 系数由以下递推关系确定。 \(a_{n} = -\frac{\sum_{k=0}^{n-1}
    q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\)。 如果\(m1 - m2\)是整数，则可以从递推关系中看出，对于较低的根\(m\)，当\(n\)等于两个根的差异时，分母变为零。
    因此，如果分子不等于零，则存在第二个级数解。
- en: Examples
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE106]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: References
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: George E. Simmons, “Differential Equations with Applications and Historical
    Notes”, p.p 176 - 184
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: George E. Simmons，“应用与历史注释的微分方程”，p.p 176 - 184
- en: Lie heuristics
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lie启发式
- en: These functions are intended for internal use of the Lie Group Solver. Nonetheless,
    they contain useful information in their docstrings on the algorithms implemented
    for the various heuristics.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数用于Lie群求解器的内部使用。 尽管如此，它们在算法文档字符串中包含了关于各种启发式的有用信息。
- en: '[PRE107]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first heuristic uses the following four sets of assumptions on \(\xi\) and
    \(\eta\)
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条启发式使用了对\(\xi\)和\(\eta\)的以下四组假设
- en: \[\xi = 0, \eta = f(x)\]\[\xi = 0, \eta = f(y)\]\[\xi = f(x), \eta = 0\]\[\xi
    = f(y), \eta = 0\]
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: \[\xi = 0, \eta = f(x)\]\[\xi = 0, \eta = f(y)\]\[\xi = f(x), \eta = 0\]\[\xi
    = f(y), \eta = 0\]
- en: The success of this heuristic is determined by algebraic factorisation. For
    the first assumption \(\xi = 0\) and \(\eta\) to be a function of \(x\), the PDE
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这一启发式的成功取决于代数因式分解。 对于第一个假设\(\xi = 0\)和\(\eta\)是\(x\)的函数，PDE
- en: \[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y} - \frac{\partial
    \xi}{\partial x})*h - \frac{\partial \xi}{\partial y}*h^{2} - \xi*\frac{\partial
    h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y} - \frac{\partial
    \xi}{\partial x})*h - \frac{\partial \xi}{\partial y}*h^{2} - \xi*\frac{\partial
    h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]
- en: reduces to \(f'(x) - f\frac{\partial h}{\partial y} = 0\) If \(\frac{\partial
    h}{\partial y}\) is a function of \(x\), then this can usually be integrated easily.
    A similar idea is applied to the other 3 assumptions as well.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 减少至\[f'(x) - f\frac{\partial h}{\partial y} = 0\] 如果\(\frac{\partial h}{\partial
    y}\)是\(x\)的函数，则通常可以轻松地进行积分。 对其他3个假设也采用了类似的想法。
- en: References
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra Solving
    of First Order ODEs Using Symmetry Methods, pp. 8
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, 使用对称方法的计算机代数解决一阶ODE，pp. 8
- en: '[PRE108]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The second heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条启发式使用了对\(\xi\)和\(\eta\)的以下两个假设
- en: \[\eta = 0, \xi = f(x)*g(y)\]\[\eta = f(x)*g(y), \xi = 0\]
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: \[\eta = 0, \xi = f(x)*g(y)\]\[\eta = f(x)*g(y), \xi = 0\]
- en: The first assumption of this heuristic holds good if \(\frac{1}{h^{2}}\frac{\partial^2}{\partial
    x \partial y}\log(h)\) is separable in \(x\) and \(y\), then the separated factors
    containing \(x\) is \(f(x)\), and \(g(y)\) is obtained by
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)\)在\(x\)和\(y\)中是可分的，则此启发式的第一个假设成立，其中包含\(x\)的分离因子是\(f(x)\)，\(g(y)\)由以下四个假设得到
- en: \[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: \[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]
- en: provided \(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\) is a function
    of \(y\) only.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 假设\[f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\)仅是\(y\)的函数。
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(y)\), the coordinates are
    again interchanged, to get \(\eta\) as \(f(x)*g(y)\)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(\frac{dy}{dx} = h(x, y)\)重写为\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)，并且第一个假设的相同特性得到满足，则第二个假设成立。
    获得\(f(x)\)和\(g(y)\)后，再次交换坐标，得到\(\eta\)为\(f(x)*g(y)\)
- en: References
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 7
    - pp. 8
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 7
    - pp. 8
- en: '[PRE109]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The third heuristic assumes the infinitesimals \(\xi\) and \(\eta\) to be bi-variate
    polynomials in \(x\) and \(y\). The assumption made here for the logic below is
    that \(h\) is a rational function in \(x\) and \(y\) though that may not be necessary
    for the infinitesimals to be bivariate polynomials. The coefficients of the infinitesimals
    are found out by substituting them in the PDE and grouping similar terms that
    are polynomials and since they form a linear system, solve and check for non trivial
    solutions. The degree of the assumed bivariates are increased till a certain maximum
    value.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个启发性假设假设 \(\xi\) 和 \(\eta\) 是 \(x\) 和 \(y\) 的双变量多项式。下面的逻辑假设是，为了使无穷小变量成为双变量多项式，\(h\)
    是 \(x\) 和 \(y\) 的有理函数，尽管这对于使无穷小变量成为双变量多项式并不是必要的。通过将它们代入偏微分方程中并分组相似项，可以找到无穷小的系数，这些系数是多项式，并且由于它们形成线性系统，可以解出并检查非平凡解。假设双变量的阶数增加直到某个最大值。
- en: References
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: Lie Groups and Differential Equations pp. 327 - pp. 329
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lie Groups and Differential Equations pp. 327 - pp. 329
- en: '[PRE110]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The aim of the fourth heuristic is to find the function \(\chi(x, y)\) that
    satisfies the PDE \(\frac{d\chi}{dx} + h\frac{d\chi}{dx} - \frac{\partial h}{\partial
    y}\chi = 0\).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个启发性的目标是找到满足偏微分方程 \(\frac{d\chi}{dx} + h\frac{d\chi}{dx} - \frac{\partial
    h}{\partial y}\chi = 0\) 的函数 \(\chi(x, y)\)。
- en: This assumes \(\chi\) to be a bivariate polynomial in \(x\) and \(y\). By intuition,
    \(h\) should be a rational function in \(x\) and \(y\). The method used here is
    to substitute a general binomial for \(\chi\) up to a certain maximum degree is
    reached. The coefficients of the polynomials, are calculated by by collecting
    terms of the same order in \(x\) and \(y\).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设 \(\chi\) 是 \(x\) 和 \(y\) 的双变量多项式。根据直觉，\(h\) 应该是 \(x\) 和 \(y\) 的有理函数。这里使用的方法是将
    \(\chi\) 替换为一个一般的二项式，直到达到某个最大阶数。通过收集相同阶数的 \(x\) 和 \(y\) 的项来计算多项式的系数。
- en: After finding \(\chi\), the next step is to use \(\eta = \xi*h + \chi\), to
    determine \(\xi\) and \(\eta\). This can be done by dividing \(\chi\) by \(h\)
    which would give \(-\xi\) as the quotient and \(\eta\) as the remainder.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 \(\chi\) 后，下一步是使用 \(\eta = \xi*h + \chi\) 来确定 \(\xi\) 和 \(\eta\)。这可以通过将 \(\chi\)
    除以 \(h\) 来完成，商是 \(-\xi\)，余数是 \(\eta\)。
- en: References
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra Solving
    of First Order ODEs Using Symmetry Methods, pp. 8
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra Solving
    of First Order ODEs Using Symmetry Methods, pp. 8
- en: '[PRE111]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式方法对 \(\xi\) 和 \(\eta\) 使用以下两个假设
- en: \[\eta = g(x), \xi = f(x)\]\[\eta = f(y), \xi = g(y)\]
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: \[\eta = g(x), \xi = f(x)\]\[\eta = f(y), \xi = g(y)\]
- en: For the first assumption,
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个假设，
- en: First \(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{ \partial
    yy}}\) is calculated. Let us say this value is A
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先计算 \(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{ \partial
    yy}}\)。假设这个值是 A
- en: If this is constant, then \(h\) is matched to the form \(A(x) + B(x)e^{ \frac{y}{C}}\)
    then, \(\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}\) gives \(f(x)\) and \(A(x)*f(x)\)
    gives \(g(x)\)
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是一个常数，那么 \(h\) 就匹配到形式 \(A(x) + B(x)e^{ \frac{y}{C}}\)，然后，\(\frac{e^{\int
    \frac{A(x)}{C} \,dx}}{B(x)}\) 给出 \(f(x)\)，\(A(x)*f(x)\) 给出 \(g(x)\)。
- en: Otherwise \(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{ \partial
    Y}} = \gamma\) is calculated. If
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则计算 \(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{ \partial Y}}
    = \gamma\)。如果
- en: a] \(\gamma\) is a function of \(x\) alone
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a] \(\gamma\) 是 \(x\) 的一个函数。
- en: b] \(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{ \partial
    h}{\partial x}}{h + \gamma} = G\) is a function of \(x\) alone. then, \(e^{\int
    G \,dx}\) gives \(f(x)\) and \(-\gamma*f(x)\) gives \(g(x)\)
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b] \(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{ \partial
    h}{\partial x}}{h + \gamma} = G\) 是 \(x\) 的一个函数。那么，\(e^{\int G \,dx}\) 给出 \(f(x)\)，\(-\gamma*f(x)\)
    给出 \(g(x)\)。
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(x)\), the coordinates are
    again interchanged, to get \(\xi\) as \(f(x^*)\) and \(\eta\) as \(g(y^*)\)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(\frac{dy}{dx} = h(x, y)\) 被重新写成 \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) 并且第一个假设的相同属性被满足。在获得
    \(f(x)\) 和 \(g(x)\) 后，再次交换坐标，得到 \(\xi\) 为 \(f(x^*)\) 和 \(\eta\) 为 \(g(y^*)\)。
- en: References
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
- en: '[PRE112]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式方法对 \(\xi\) 和 \(\eta\) 使用以下两个假设
- en: \[\eta = 0, \xi = f(x) + g(y)\]\[\eta = f(x) + g(y), \xi = 0\]
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: \[\eta = 0, \xi = f(x) + g(y)\]\[\eta = f(x) + g(y), \xi = 0\]
- en: The first assumption of this heuristic holds good if
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式的第一个假设成立，如果
- en: \[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{ \partial x^{2}}(h^{-1}))^{-1}]\]
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{ \partial x^{2}}(h^{-1}))^{-1}]\]
- en: is separable in \(x\) and \(y\),
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在\(x\)和\(y\)中分离，
- en: The separated factors containing \(y\) is \(\frac{\partial g}{\partial y}\).
    From this \(g(y)\) can be determined.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 含有\(y\)的分离因子是\(\frac{\partial g}{\partial y}\)。从中可以确定\(g(y)\)。
- en: The separated factors containing \(x\) is \(f''(x)\).
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 含有\(x\)的分离因子是\(f''(x)\)。
- en: \(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\) equals \(\frac{f''(x)}{f(x)
    + g(y)}\). From this \(f(x)\) can be determined.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\)等于\(\frac{f''(x)}{f(x) + g(y)}\)。从此可以确定\(f(x)\)。
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(y)\), the coordinates are
    again interchanged, to get \(\eta\) as \(f(x) + g(y)\).
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(\frac{dy}{dx} = h(x, y)\)被重写为\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)并且第一个假设的相同属性得到满足后，第二个假设成立。在获得\(f(x)\)和\(g(y)\)之后，坐标再次互换，得到\(\eta\)为\(f(x)
    + g(y)\)。
- en: For both assumptions, the constant factors are separated among \(g(y)\) and
    \(f''(x)\), such that \(f''(x)\) obtained from 3] is the same as that obtained
    from 2]. If not possible, then this heuristic fails.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两种假设，常数因子在\(g(y)\)和\(f''(x)\)之间分离，从而从第 3] 获得的\(f''(x)\)与从第 2] 获得的相同。如果不可能，则此启发式失败。
- en: References
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 7
    - pp. 8
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, 对称性和一阶常微分方程模式, 第 7 - 第 8 页
- en: '[PRE113]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This heuristic assumes the presence of unknown functions or known functions
    with non-integer powers.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式假设存在未知函数或具有非整数幂的已知函数。
- en: A list of all functions and non-integer powers containing x and y
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有包含\(x\)和\(y\)的函数和非整数幂的列表
- en: Loop over each element \(f\) in the list, find \(\frac{\frac{\partial f}{\partial
    x}}{ \frac{\partial f}{\partial x}} = R\)
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中循环每个元素\(f\)，找到\(\frac{\frac{\partial f}{\partial x}}{ \frac{\partial f}{\partial
    x}} = R\)
- en: If it is separable in \(x\) and \(y\), let \(X\) be the factors containing \(x\).
    Then
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它在\(x\)和\(y\)中是分离的，则让\(X\)是包含\(x\)的因子。然后
- en: a] Check if \(\xi = X\) and \(\eta = -\frac{X}{R}\) satisfy the PDE. If yes,
    then return
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a] 检查是否\(\xi = X\)和\(\eta = -\frac{X}{R}\)满足偏微分方程。如果是，则返回。
- en: \(\xi\) and \(\eta\)
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \(\xi\)和\(\eta\)
- en: b] Check if \(\xi = \frac{-R}{X}\) and \(\eta = -\frac{1}{X}\) satisfy the PDE.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b] 检查是否\(\xi = \frac{-R}{X}\)和\(\eta = -\frac{1}{X}\)满足偏微分方程。
- en: If yes, then return \(\xi\) and \(\eta\)
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果是，则返回\(\xi\)和\(\eta\)
- en: If not, then check if
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果不是，则检查是否
- en: a] \(\xi = -R,\eta = 1\)
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a] \(\xi = -R,\eta = 1\)
- en: b] \(\xi = 1, \eta = -\frac{1}{R}\)
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b] \(\xi = 1, \eta = -\frac{1}{R}\)
- en: are solutions.
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是解决方案。
- en: References
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, 对称性和一阶常微分方程模式, 第 10 - 第 12 页
- en: '[PRE114]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This heuristic finds if infinitesimals of the form \(\eta = f(x)\), \(\xi =
    g(y)\) without making any assumptions on \(h\).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式用于查找形式为\(\eta = f(x)\)，\(\xi = g(y)\)的无穷小量，而不对\(h\)做任何假设。
- en: The complete sequence of steps is given in the paper mentioned below.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了下面提到的论文的完整步骤序列。
- en: References
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, 对称性和一阶常微分方程模式, 第 10 - 第 12 页
- en: '[PRE115]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This heuristic assumes
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 此启发式假设
- en: \(\xi = ax + by + c\) and
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\xi = ax + by + c\) 和
- en: \(\eta = fx + gy + h\)
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(\eta = fx + gy + h\)
- en: After substituting the following assumptions in the determining PDE, it reduces
    to
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在将以下假设代入确定性偏微分方程中之后，它化简为
- en: \[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x} - (fx +
    gy + c)\frac{\partial h}{\partial y}\]
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: \[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x} - (fx +
    gy + c)\frac{\partial h}{\partial y}\]
- en: Solving the reduced PDE obtained, using the method of characteristics, becomes
    impractical. The method followed is grouping similar terms and solving the system
    of linear equations obtained. The difference between the bivariate heuristic is
    that \(h\) need not be a rational function in this case.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 解决简化的偏微分方程，使用特征线法，变得不切实际。所采用的方法是分组相似项并解决得到的线性方程组。与双变量启发式的区别在于在这种情况下\(h\)不必是有理函数。
- en: References
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E.S. Cheb-Terrab, A.D. Roche, 对称性和一阶常微分方程模式, 第 10 - 第 12 页
- en: Rational Riccati Solver
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有理里卡蒂求解器
- en: These functions are intended for internal use to solve a first order Riccati
    differential equation with atleast one rational particular solution.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数旨在内部用于解决至少具有一个有理特解的一阶里卡蒂微分方程。
- en: '[PRE116]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Given a solution \(w(x)\) to the equation
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 给定方程的解 \(w(x)\)
- en: \[w'(x) = b_0(x) + b_1(x)*w(x) + b_2(x)*w(x)^2\]
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: \[w'(x) = b_0(x) + b_1(x)*w(x) + b_2(x)*w(x)^2\]
- en: and rational function coefficients \(b_1(x)\) and \(b_2(x)\), this function
    transforms the solution to give a solution \(y(x)\) for its corresponding normal
    Riccati ODE
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 和有理函数系数 \(b_1(x)\) 和 \(b_2(x)\)，此函数转换解以给出其对应的正常 Riccati ODE 的解 \(y(x)\)
- en: \[y'(x) + y(x)^2 = a(x)\]
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: \[y'(x) + y(x)^2 = a(x)\]
- en: using the transformation
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变换
- en: \[y(x) = -b_2(x)*w(x) - b'_2(x)/(2*b_2(x)) - b_1(x)/2\]
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: \[y(x) = -b_2(x)*w(x) - b'_2(x)/(2*b_2(x)) - b_1(x)/2\]
- en: '[PRE117]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Inverse transforming the solution to the normal Riccati ODE to get the solution
    to the Riccati ODE.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 逆转换正常 Riccati ODE 的解以获取 Riccati ODE 的解。
- en: '[PRE118]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Convert a Riccati ODE into its corresponding normal Riccati ODE.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Riccati ODE 转换为其相应的正常 Riccati ODE。
- en: '[PRE119]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Helper function to calculate the coefficients in the c-vector for each pole.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数，根据每个极点上的函数估值计算 c 向量中的系数。
- en: '[PRE120]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Helper function to calculate the coefficients in the d-vector based on the valuation
    of the function at oo.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数，根据在 oo 处的函数估值计算 d 向量中的系数。
- en: '[PRE121]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The function computes the Laurent series coefficients of a rational function.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数计算有理函数的 Laurent 级数系数。
- en: 'Parameters:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**num: A Poly object that is the numerator of `f(x)`.**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**num：是 `f(x)` 的分子的 Poly 对象。**'
- en: '**den: A Poly object that is the denominator of `f(x)`.**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**den：是 `f(x)` 的分母的 Poly 对象。**'
- en: '**x: The variable of expansion of the series.**'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**x：级数展开的变量。**'
- en: '**r: The point of expansion of the series.**'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**r：级数展开的点。**'
- en: '**m: Multiplicity of r if r is a pole of `f(x)`. Should**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**m：如果 r 是 `f(x)` 的极点，则其重数应为零。**'
- en: '**be zero otherwise.**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**否则为零。**'
- en: '**n: Order of the term upto which the series is expanded.**'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '**n：扩展的术语的顺序。**'
- en: 'Returns:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: 'series: A dictionary that has power of the term as key'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: series：具有术语幂的字典作为键
- en: and coefficient of that term as value.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 并将该项的系数作为值。
- en: Below is a basic outline of how the Laurent series of a
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何计算的基本轮廓
- en: rational function \(f(x)\) about \(x_0\) is being calculated -
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在 \(x_0\) 处计算有理函数 \(f(x)\) -
- en: Substitute \(x + x_0\) in place of \(x\). If \(x_0\)
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \(x_0\) 放在 \(x\) 的位置。如果 \(x_0\)
- en: is a pole of \(f(x)\), multiply the expression by \(x^m\)
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: \(f(x)\) 的极点，将表达式乘以 \(x^m\)
- en: where \(m\) is the multiplicity of \(x_0\). Denote the
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(m\) 是 \(x_0\) 的重数。表示
- en: the resulting expression as g(x). We do this substitution
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 所得表达式作为 g(x)。我们通过这种替换
- en: so that we can now find the Laurent series of g(x) about
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们现在可以找到关于 g(x) 的 Laurent 级数
- en: \(x = 0\).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: \(x = 0\)。
- en: We can then assume that the Laurent series of \(g(x)\)
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以假设 \(g(x)\) 的 Laurent 级数
- en: takes the following form -
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下形式 -
- en: \[g(x) = \frac{num(x)}{den(x)} = \sum_{m = 0}^{\infty} a_m x^m\]
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: \[g(x) = \frac{num(x)}{den(x)} = \sum_{m = 0}^{\infty} a_m x^m\]
- en: where \(a_m\) denotes the Laurent series coefficients.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(a_m\) 表示 Laurent 级数系数。
- en: Multiply the denominator to the RHS of the equation
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分母乘以方程的 RHS
- en: and form a recurrence relation for the coefficients \(a_m\).
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 并形成系数 \(a_m\) 的递推关系。
- en: '[PRE122]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Helper function to calculate -
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数用于计算 -
- en: 1\. m - The degree bound for the polynomial solution that must be found for
    the auxiliary differential equation.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. m - 必须为辅助微分方程找到的多项式解的度数限制。
- en: 2\. ybar - Part of the solution which can be computed using the poles, c and
    d vectors.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. ybar - 可使用极点 c 和 d 向量计算的解的一部分。
- en: '[PRE123]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Helper function to find a polynomial solution of degree m for the auxiliary
    differential equation.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数，用于找到辅助微分方程的 m 阶多项式解。
- en: '[PRE124]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Helper function to remove redundant solutions to the differential equation.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数，用于移除微分方程的冗余解。
- en: '[PRE125]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: ” Helper function which computes the general solution for a Riccati ODE from
    its particular solutions.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: ” 从其特解计算 Riccati ODE 的一般解的辅助函数。
- en: There are 3 cases to find the general solution from the particular solutions
    for a Riccati ODE depending on the number of particular solution(s) we have -
    1, 2 or 3.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们具有的特解数（1、2或3），有三种情况可以从特解中找到 Riccati ODE 的一般解。
- en: For more information, see Section 6 of “Methods of Solution of the Riccati Differential
    Equation” by D. R. Haaheim and F. M. Stein
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参见 D. R. Haaheim 和 F. M. Stein 的《Riccati 微分方程的解法》第 6 节。
- en: '[PRE126]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The main function that gives particular/general solutions to Riccati ODEs that
    have atleast 1 rational particular solution.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 给出至少有一个有理特解的 Riccati ODE 的特解/一般解。
- en: System of ODEs
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ODE 系统
- en: These functions are intended for internal use by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") for system of differential equations.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数用于内部由[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")处理的常微分方程系统。
- en: '[PRE127]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The equations of this type of ode are .
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这类ODE的方程是。
- en: \[x' = f(t) x + g(t) y\]\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = f(t) x + g(t) y\]\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]
- en: This is solved by first multiplying the first equation by \(-a\) and adding
    it to the second equation to obtain
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将第一个方程乘以\(-a\)并加到第二个方程中得到解
- en: \[y' - a x' = -a h(t) (y - a x)\]
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: \[y' - a x' = -a h(t) (y - a x)\]
- en: Setting \(U = y - ax\) and integrating the equation we arrive at
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 设置\(U = y - ax\)并积分方程，我们得到
- en: \[y - ax = C_1 e^{-a \int h(t) \,dt}\]
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: \[y - ax = C_1 e^{-a \int h(t) \,dt}\]
- en: and on substituting the value of y in first equation give rise to first order
    ODEs. After solving for \(x\), we can obtain \(y\) by substituting the value of
    \(x\) in second equation.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在第一个方程中用y的值代替后产生了一阶常微分方程。解出\(x\)后，我们可以通过将\(x\)的值代入第二个方程中获得\(y\)。
- en: '[PRE128]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The equations of this type of ode are .
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这类ODE的方程是。
- en: \[x' = f(t) x + g(t) y\]\[y' = h(t) x + p(t) y\]
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = f(t) x + g(t) y\]\[y' = h(t) x + p(t) y\]
- en: Differentiating the first equation and substituting the value of \(y\) from
    second equation will give a second-order linear equation
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 对第一个方程进行微分并用第二个方程的值替换将得到一个二阶线性方程
- en: \[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: \[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]
- en: This above equation can be easily integrated if following conditions are satisfied.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足上述条件，则上述方程可以轻松积分。
- en: \(fgp - g^{2} h + f g' - f' g = 0\)
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(fgp - g^{2} h + f g' - f' g = 0\)
- en: \(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: \(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)
- en: If first condition is satisfied then it is solved by current dsolve solver and
    in second case it becomes a constant coefficient differential equation which is
    also solved by current solver.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足第一个条件，则通过当前的dsolve求解器解决，在第二种情况下它变为一个常系数微分方程，也由当前求解器解决。
- en: Otherwise if the above condition fails then, a particular solution is assumed
    as \(x = x_0(t)\) and \(y = y_0(t)\) Then the general solution is expressed as
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果上述条件不满足，则假定特解为\(x = x_0(t)\)和\(y = y_0(t)\)然后一般解表达为
- en: \[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]\[y
    = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)}
    \,dt]\]
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]\[y
    = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)}
    \,dt]\]
- en: where C1 and C2 are arbitrary constants and
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 其中C1和C2是任意常数和
- en: \[F(t) = e^{\int f(t) \,dt}, P(t) = e^{\int p(t) \,dt}\]
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: \[F(t) = e^{\int f(t) \,dt}, P(t) = e^{\int p(t) \,dt}\]
- en: '[PRE129]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Convert a linear system of ODEs to matrix form
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个线性常微分方程系统转换为矩阵形式
- en: 'Parameters:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**eqs** : list of SymPy expressions or equalities'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '**eqs** : SymPy表达式或等式的列表'
- en: The equations as expressions (assumed equal to zero).
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式形式的方程（假设为零）。
- en: '**funcs** : list of applied functions'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '**funcs** : 应用函数的列表'
- en: The dependent variables of the system of ODEs.
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方程系统的因变量。
- en: '**t** : symbol'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**t** : 符号'
- en: The independent variable.
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自变量。
- en: '**order** : int'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '**order** : 整数'
- en: The order of the system of ODEs.
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 常微分方程系统的阶数。
- en: 'Returns:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: The tuple `(As, b)` where `As` is a tuple of matrices and `b` is the
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 元组`(As, b)`，其中`As`是一组矩阵，`b`是
- en: the matrix representing the rhs of the matrix equation.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 表示矩阵方程的rhs矩阵。
- en: 'Raises:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ODEOrderError**'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '**ODEOrderError**'
- en: When the system of ODEs have an order greater than what was specified
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当常微分方程系统的阶数大于指定的阶数时
- en: '**ODENonlinearError**'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '**ODENonlinearError**'
- en: When the system of ODEs is nonlinear
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当常微分方程系统是非线性时
- en: Explanation
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Express a system of linear ordinary differential equations as a single matrix
    differential equation [1]. For example the system \(x' = x + y + 1\) and \(y'
    = x - y\) can be represented as
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组线性常微分方程表示为单个矩阵微分方程[1]。例如系统\(x' = x + y + 1\)和\(y' = x - y\)可以表示为
- en: \[A_1 X' = A_0 X + b\]
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_1 X' = A_0 X + b\]
- en: where \(A_1\) and \(A_0\) are \(2 \times 2\) matrices and \(b\), \(X\) and \(X'\)
    are \(2 \times 1\) matrices with \(X = [x, y]^T\).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(A_1\)和\(A_0\)是\(2 \times 2\)矩阵，\(b\)，\(X\)和\(X'\)是\(2 \times 1\)矩阵，其中\(X
    = [x, y]^T\)。
- en: Higher-order systems are represented with additional matrices e.g. a second-order
    system would look like
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶系统用额外的矩阵表示，例如二阶系统看起来像
- en: \[A_2 X'' = A_1 X' + A_0 X + b\]
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_2 X'' = A_1 X' + A_0 X + b\]
- en: Examples
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE130]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We can create a system of linear ODEs like
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建像
- en: '[PRE131]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now `linear_ode_to_matrix` can represent this as a matrix differential equation.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`linear_ode_to_matrix`可以表示这个矩阵微分方程。
- en: '[PRE132]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The original equations can be recovered from these matrices:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从这些矩阵中恢复原始方程：
- en: '[PRE133]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: If the system of equations has a maximum order greater than the order of the
    system specified, a ODEOrderError exception is raised.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程组的最大阶大于指定系统的阶数，则引发ODEOrderError异常。
- en: '[PRE134]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If the system of equations is nonlinear, then ODENonlinearError is raised.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程组是非线性的，则引发ODENonlinearError。
- en: '[PRE135]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: See also
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`linear_eq_to_matrix`](solveset.html#sympy.solvers.solveset.linear_eq_to_matrix
    "sympy.solvers.solveset.linear_eq_to_matrix")'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linear_eq_to_matrix`](solveset.html#sympy.solvers.solveset.linear_eq_to_matrix
    "sympy.solvers.solveset.linear_eq_to_matrix")'
- en: for systems of linear algebraic equations.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 用于线性代数方程组。
- en: References
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[R884](#id1)]'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R884](#id1)]'
- en: '[https://en.wikipedia.org/wiki/Matrix_differential_equation](https://en.wikipedia.org/wiki/Matrix_differential_equation)'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Matrix_differential_equation](https://en.wikipedia.org/wiki/Matrix_differential_equation)'
- en: '[PRE136]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Function that solves for highest order derivatives in a system
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 解决系统中最高阶导数的函数
- en: 'Parameters:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**eqs** : List'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**eqs** : 列表'
- en: List of the ODEs
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ODE列表
- en: '**funcs** : List'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '**funcs** : 列表'
- en: List of dependent variables
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖变量列表
- en: '**t** : Symbol'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '**t** : 符号'
- en: Independent variable
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自变量
- en: 'Returns:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: List
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: Explanation
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'This function inputs a system of ODEs and based on the system, the dependent
    variables and their highest order, returns the system in the following form:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数输入一组ODEs，并根据系统、依赖变量及其最高阶返回以下形式的系统：
- en: \[X'(t) = A(t) X(t) + b(t)\]
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: \[X'(t) = A(t) X(t) + b(t)\]
- en: Here, \(X(t)\) is the vector of dependent variables of lower order, \(A(t)\)
    is the coefficient matrix, \(b(t)\) is the non-homogeneous term and \(X'(t)\)
    is the vector of dependent variables in their respective highest order. We use
    the term canonical form to imply the system of ODEs which is of the above form.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，\(X(t)\) 是低阶依赖变量的向量，\(A(t)\) 是系数矩阵，\(b(t)\) 是非齐次项，\(X'(t)\) 是其各自最高阶依赖变量的向量。我们使用“规范形式”一词来暗示上述ODE系统。
- en: If the system passed has a non-linear term with multiple solutions, then a list
    of systems is returned in its canonical form.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的系统具有带有多个解的非线性项，则以其规范形式返回系统列表。
- en: Examples
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE137]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Helper function that determines the type of the system of ODEs for solving with
    [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve")
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 确定用于与[`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve")解决的ODE系统类型的辅助函数
- en: 'Parameters:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**A** : Matrix'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** : 矩阵'
- en: Coefficient matrix of the system of ODEs
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ODE系统的系数矩阵
- en: '**b** : Matrix or None'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**b** : 矩阵或None'
- en: Non-homogeneous term of the system. The default value is None. If this argument
    is None, then the system is assumed to be homogeneous.
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统的非齐次项。默认值为None。如果该参数为None，则假定系统为齐次的。
- en: 'Returns:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: Dict
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: 'Raises:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**NotImplementedError**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedError**'
- en: When the coefficient matrix does not have a commutative antiderivative
  id: totrans-839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当系数矩阵没有交换反导数时
- en: Explanation
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This function takes in the coefficient matrix and/or the non-homogeneous term
    and returns the type of the equation that can be solved by [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve").
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受系数矩阵和/或非齐次项，并返回可以由[`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve")解决的方程类型。
- en: If the system is constant coefficient homogeneous, then “type1” is returned
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统是常数系数齐次的，则返回“type1”
- en: If the system is constant coefficient non-homogeneous, then “type2” is returned
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统是常数系数非齐次的，则返回“type2”
- en: If the system is non-constant coefficient homogeneous, then “type3” is returned
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统是非常数系数的齐次方程组，则返回“type3”
- en: If the system is non-constant coefficient non-homogeneous, then “type4” is returned
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统是非常数系数非齐次的，则返回“type4”
- en: If the system has a non-constant coefficient matrix which can be factorized
    into constant coefficient matrix, then “type5” or “type6” is returned for when
    the system is homogeneous or non-homogeneous respectively.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统具有可以因式分解为常数系数矩阵的非常数系数矩阵，则分别针对系统是齐次或非齐次返回“type5”或“type6”。
- en: Note that, if the system of ODEs is of “type3” or “type4”, then along with the
    type, the commutative antiderivative of the coefficient matrix is also returned.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果常微分方程组是“type3”或“type4”，则还将返回系数矩阵的可交换反导数，以及类型。
- en: If the system cannot be solved by [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve"), then NotImplementedError is raised.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统不能通过 [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve") 解决，则会引发 NotImplementedError 异常。
- en: Examples
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE142]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: See also
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`linodesolve`](#sympy.solvers.ode.systems.linodesolve "sympy.solvers.ode.systems.linodesolve")'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linodesolve`](#sympy.solvers.ode.systems.linodesolve "sympy.solvers.ode.systems.linodesolve")'
- en: Function for which linodesolve_type gets the information
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: linodesolve_type 函数获取信息的函数
- en: '[PRE149]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Matrix exponential \(\exp(A*t)\) for the matrix *A* and scalar *t*.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵指数 \(\exp(A*t)\) 适用于矩阵 *A* 和标量 *t*。
- en: 'Parameters:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**A** : Matrix'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** : 矩阵'
- en: The matrix \(A\) in the expression \(\exp(A*t)\)
  id: totrans-864
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式 \(\exp(A*t)\) 中的矩阵 \(A\)
- en: '**t** : Symbol'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**t** : 符号'
- en: The independent variable
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自变量
- en: Explanation
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: 'Returns the Jordan form of the \(\exp(A*t)\) along with the matrix \(P\) such
    that:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 \(\exp(A*t)\) 的约当形式，以及矩阵 \(P\)，使得：
- en: \[\exp(A*t) = P * expJ * P^{-1}\]
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: \[\exp(A*t) = P * expJ * P^{-1}\]
- en: Examples
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE150]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: We will consider a 2x2 defective matrix. This shows that our method works even
    for defective matrices.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个 2x2 不完全矩阵。这表明我们的方法即使对于不完全矩阵也有效。
- en: '[PRE151]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It can be observed that this function gives us the Jordan normal form and the
    required invertible matrix P.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到这个函数给出了我们所需的约当标准型以及必要的可逆矩阵 \(P\)。
- en: '[PRE152]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Here, it is shown that P and expJ returned by this function is correct as they
    satisfy the formula: P * expJ * P_inverse = exp(A*t).'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，显示了此函数返回的 P 和 expJ 是正确的，因为它们满足公式：P * expJ * P_inverse = exp(A*t)。
- en: '[PRE153]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: References
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R885](#id2)]'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R885](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Defective_matrix](https://en.wikipedia.org/wiki/Defective_matrix)'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Defective_matrix](https://zh.wikipedia.org/wiki/Defective_matrix)'
- en: '[[R886](#id3)]'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R886](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Jordan_matrix](https://en.wikipedia.org/wiki/Jordan_matrix)'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Jordan_matrix](https://zh.wikipedia.org/wiki/Jordan_matrix)'
- en: '[[R887](#id4)]'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R887](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Jordan_normal_form](https://en.wikipedia.org/wiki/Jordan_normal_form)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Jordan_normal_form](https://zh.wikipedia.org/wiki/Jordan_normal_form)'
- en: '[PRE154]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Matrix exponential \(\exp(A*t)\) for the matrix `A` and scalar `t`.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵指数 \(\exp(A*t)\) 适用于矩阵 `A` 和标量 `t`。
- en: 'Parameters:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**A** : Matrix'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** : 矩阵'
- en: The matrix \(A\) in the expression \(\exp(A*t)\)
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式 \(\exp(A*t)\) 中的矩阵 \(A\)
- en: '**t** : Symbol'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '**t** : 符号'
- en: The independent variable
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自变量
- en: Explanation
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: 'This functions returns the \(\exp(A*t)\) by doing a simple matrix multiplication:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过简单的矩阵乘法返回了 \(\exp(A*t)\)：
- en: \[\exp(A*t) = P * expJ * P^{-1}\]
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: \[\exp(A*t) = P * expJ * P^{-1}\]
- en: 'where \(expJ\) is \(\exp(J*t)\). \(J\) is the Jordan normal form of \(A\) and
    \(P\) is matrix such that:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(expJ\) 是 \(\exp(J*t)\)。 \(J\) 是矩阵 \(A\) 的约当标准型，\(P\) 是使得以下等式成立的矩阵：
- en: \[A = P * J * P^{-1}\]
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: \[A = P * J * P^{-1}\]
- en: The matrix exponential \(\exp(A*t)\) appears in the solution of linear differential
    equations. For example if \(x\) is a vector and \(A\) is a matrix then the initial
    value problem
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵指数 \(\exp(A*t)\) 出现在线性微分方程的解中。例如，如果 \(x\) 是向量，\(A\) 是矩阵，则初始值问题
- en: \[\frac{dx(t)}{dt} = A \times x(t), x(0) = x0\]
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{dx(t)}{dt} = A \times x(t), x(0) = x0\]
- en: has the unique solution
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 有唯一解
- en: \[x(t) = \exp(A t) x0\]
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: \[x(t) = \exp(A t) x0\]
- en: Examples
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE155]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We will consider a 2x2 matrix for comupting the exponential
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个 2x2 矩阵来计算指数
- en: '[PRE156]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now, exp(A*t) is given as follows:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，exp(A*t) 给出如下：
- en: '[PRE157]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: See also
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`matrix_exp_jordan_form`](#sympy.solvers.ode.systems.matrix_exp_jordan_form
    "sympy.solvers.ode.systems.matrix_exp_jordan_form")'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '[`matrix_exp_jordan_form`](#sympy.solvers.ode.systems.matrix_exp_jordan_form
    "sympy.solvers.ode.systems.matrix_exp_jordan_form")'
- en: For exponential of Jordan normal form
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 对于约当标准形的指数
- en: References
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R888](#id5)]'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R888](#id5)]'
- en: '[https://en.wikipedia.org/wiki/Jordan_normal_form](https://en.wikipedia.org/wiki/Jordan_normal_form)'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Jordan_normal_form](https://zh.wikipedia.org/wiki/Jordan_normal_form)'
- en: '[[R889](#id6)]'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R889](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Matrix_exponential](https://en.wikipedia.org/wiki/Matrix_exponential)'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Matrix_exponential](https://zh.wikipedia.org/wiki/Matrix_exponential)'
- en: '[PRE158]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: System of n equations linear first-order differential equations
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 线性一阶微分方程组的 n 个方程
- en: 'Parameters:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**A** : Matrix'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** : 矩阵'
- en: Coefficient matrix of the system of linear first order ODEs.
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 线性一阶常微分方程组的系数矩阵。
- en: '**t** : Symbol'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '**t** : 符号'
- en: Independent variable in the system of ODEs.
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 常微分方程组中的自变量。
- en: '**b** : Matrix or None'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '**b**：矩阵或 None'
- en: Non-homogeneous term in the system of ODEs. If None is passed, a homogeneous
    system of ODEs is assumed.
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ODE 系统中的非齐次项。如果传递了 None，则假定是齐次的 ODE 系统。
- en: '**B** : Matrix or None'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**：矩阵或 None'
- en: Antiderivative of the coefficient matrix. If the antiderivative is not passed
    and the solution requires the term, then the solver would compute it internally.
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系数矩阵的反导数。如果未传递反导数且解决方案需要该项，则求解器将在内部计算它。
- en: '**type** : String'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '**type**：字符串'
- en: 'Type of the system of ODEs passed. Depending on the type, the solution is evaluated.
    The type values allowed and the corresponding system it solves are: “type1” for
    constant coefficient homogeneous “type2” for constant coefficient non-homogeneous,
    “type3” for non-constant coefficient homogeneous, “type4” for non-constant coefficient
    non-homogeneous, “type5” and “type6” for non-constant coefficient homogeneous
    and non-homogeneous systems respectively where the coefficient matrix can be factorized
    to a constant coefficient matrix. The default value is “auto” which will let the
    solver decide the correct type of the system passed.'
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传递的 ODE 系统的类型。根据类型评估解决方案。允许的类型值及其解决的对应系统是：“type1” 用于常系数齐次、“type2” 用于常系数非齐次、“type3”
    用于非常系数齐次、“type4” 用于非常系数非齐次，“type5” 和 “type6” 用于系数矩阵可分解为常系数矩阵的非常系数齐次和非齐次系统，分别。“auto”
    是默认值，让求解器决定传递系统的正确类型。
- en: '**doit** : Boolean'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**doit**：布尔值'
- en: Evaluate the solution if True, default value is False
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为 True，则评估解决方案，默认值为 False
- en: '**tau: Expression**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**tau: Expression**'
- en: Used to substitute for the value of \(t\) after we get the solution of the system.
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于在得到系统解的后替换 \(t\) 的值。
- en: 'Returns:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: List
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: 'Raises:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: This error is raised when the coefficient matrix, non-homogeneous term or the
    antiderivative, if passed, are not a matrix or do not have correct dimensions
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当系数矩阵、非齐次项或传递的反导数不是矩阵或没有正确维度时引发此错误
- en: '**NonSquareMatrixError**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**NonSquareMatrixError**'
- en: When the coefficient matrix or its antiderivative, if passed is not a square
    matrix
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当系数矩阵或其反导数传递的不是方阵时
- en: '**NotImplementedError**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedError**'
- en: If the coefficient matrix does not have a commutative antiderivative
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果系数矩阵没有可交换的反导数
- en: Explanation
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'This solver solves the system of ODEs of the following form:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 此求解器解决以下形式的 ODE 系统：
- en: \[X'(t) = A(t) X(t) + b(t)\]
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: \[X'(t) = A(t) X(t) + b(t)\]
- en: Here, \(A(t)\) is the coefficient matrix, \(X(t)\) is the vector of n independent
    variables, \(b(t)\) is the non-homogeneous term and \(X'(t)\) is the derivative
    of \(X(t)\)
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，\(A(t)\) 是系数矩阵，\(X(t)\) 是 n 个独立变量的向量，\(b(t)\) 是非齐次项，\(X'(t)\) 是 \(X(t)\)
    的导数
- en: Depending on the properties of \(A(t)\) and \(b(t)\), this solver evaluates
    the solution differently.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 \(A(t)\) 和 \(b(t)\) 的特性，此求解器以不同方式评估解决方案。
- en: 'When \(A(t)\) is constant coefficient matrix and \(b(t)\) is zero vector i.e.
    system is homogeneous, the system is “type1”. The solution is:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(A(t)\) 是常系数矩阵且 \(b(t)\) 是零向量即系统是齐次的时候，系统是“type1”。解决方案是：
- en: \[X(t) = \exp(A t) C\]
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: \[X(t) = \exp(A t) C\]
- en: Here, \(C\) is a vector of constants and \(A\) is the constant coefficient matrix.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，\(C\) 是常数向量，\(A\) 是常系数矩阵。
- en: 'When \(A(t)\) is constant coefficient matrix and \(b(t)\) is non-zero i.e.
    system is non-homogeneous, the system is “type2”. The solution is:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(A(t)\) 是常系数矩阵且 \(b(t)\) 是非零向量即系统是非齐次的时候，系统是“type2”。解决方案是：
- en: \[X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)\]
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: \[X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)\]
- en: 'When \(A(t)\) is coefficient matrix such that its commutative with its antiderivative
    \(B(t)\) and \(b(t)\) is a zero vector i.e. system is homogeneous, the system
    is “type3”. The solution is:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(A(t)\) 是系数矩阵且其可与其反导数 \(B(t)\) 交换且 \(b(t)\) 是零向量即系统是齐次的时候，系统是“type3”。解决方案是：
- en: \[X(t) = \exp(B(t)) C\]
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: \[X(t) = \exp(B(t)) C\]
- en: 'When \(A(t)\) is commutative with its antiderivative \(B(t)\) and \(b(t)\)
    is non-zero i.e. system is non-homogeneous, the system is “type4”. The solution
    is:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(A(t)\) 与其反导数 \(B(t)\) 可交换且 \(b(t)\) 是非零向量即系统是非齐次的时候，系统是“type4”。解决方案是：
- en: \[X(t) = e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)\]
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: \[X(t) = e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)\]
- en: 'When \(A(t)\) is a coefficient matrix such that it can be factorized into a
    scalar and a constant coefficient matrix:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(A(t)\) 是一个系数矩阵，可以分解为标量和常系数矩阵：
- en: \[A(t) = f(t) * A\]
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: \[A(t) = f(t) * A\]
- en: 'Where \(f(t)\) is a scalar expression in the independent variable \(t\) and
    \(A\) is a constant matrix, then we can do the following substitutions:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(f(t)\)是独立变量\(t\)的标量表达式，\(A\)是常数矩阵，然后我们可以进行以下替换：
- en: \[tau = \int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))\]
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: \[tau = \int f(t) dt, X(t) = Y(\tau), b(t) = b(f^{-1}(\tau))\]
- en: 'Here, the substitution for the non-homogeneous term is done only when its non-zero.
    Using these substitutions, our original system becomes:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 在非齐次项为非零时，仅执行对非齐次项的替换。通过这些替换，我们的原始系统变为：
- en: \[Y'(tau) = A * Y(tau) + b(tau)/f(tau)\]
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: \[Y'(\tau) = A * Y(\tau) + b(\tau)/f(\tau)\]
- en: The above system can be easily solved using the solution for “type1” or “type2”
    depending on the homogeneity of the system. After we get the solution for \(Y(tau)\),
    we substitute the solution for \(tau\) as \(t\) to get back \(X(t)\)
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 上述系统可以根据系统的齐次性使用“type1”或“type2”的解法轻松解决。在得到\(Y(\tau)\)的解后，我们将\(tau\)的解作为\(t\)进行替换，以得到\(X(t)\)。
- en: \[X(t) = Y(tau)\]
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: \[X(t) = Y(\tau)\]
- en: Systems of “type5” and “type6” have a commutative antiderivative but we use
    this solution because its faster to compute.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: “type5”和“type6”的系统具有可交换的反导数，但我们使用这个解决方案因为它计算速度更快。
- en: The final solution is the general solution for all the four equations since
    a constant coefficient matrix is always commutative with its antidervative.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的解是所有四个方程的一般解，因为常数系数矩阵始终与其反导数可交换。
- en: An additional feature of this function is, if someone wants to substitute for
    value of the independent variable, they can pass the substitution \(tau\) and
    the solution will have the independent variable substituted with the passed expression(\(tau\)).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的另一个特点是，如果有人想要替换独立变量的值，他们可以传递替换\(tau\)，解决方案将使用传递的表达式（\(tau\)）进行独立变量的替换。
- en: Examples
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: To solve the system of ODEs using this function directly, several things must
    be done in the right order. Wrong inputs to the function will lead to incorrect
    results.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接使用此函数解决ODE系统，必须按正确顺序执行几件事情。对函数的错误输入将导致不正确的结果。
- en: '[PRE159]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Here, it is important to note that before we derive the coefficient matrix,
    it is important to get the system of ODEs into the desired form. For that we will
    use [`sympy.solvers.ode.systems.canonical_odes()`](#sympy.solvers.ode.systems.canonical_odes
    "sympy.solvers.ode.systems.canonical_odes").
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们推导系数矩阵之前，重要的是将ODE系统转换为所需的形式。为此，我们将使用[`sympy.solvers.ode.systems.canonical_odes()`](#sympy.solvers.ode.systems.canonical_odes
    "sympy.solvers.ode.systems.canonical_odes")。
- en: '[PRE160]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Now, we will use [`sympy.solvers.ode.systems.linear_ode_to_matrix()`](#sympy.solvers.ode.systems.linear_ode_to_matrix
    "sympy.solvers.ode.systems.linear_ode_to_matrix") to get the coefficient matrix
    and the non-homogeneous term if it is there.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用[`sympy.solvers.ode.systems.linear_ode_to_matrix()`](#sympy.solvers.ode.systems.linear_ode_to_matrix
    "sympy.solvers.ode.systems.linear_ode_to_matrix")来获取系数矩阵和非齐次项（如果有的话）。
- en: '[PRE161]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We have the coefficient matrices and the non-homogeneous term ready. Now, we
    can use [`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type") to get the information for the system
    of ODEs to finally pass it to the solver.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好系数矩阵和非齐次项。现在，我们可以使用[`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type")来获取ODE系统的信息，最终将其传递给求解器。
- en: '[PRE162]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Now, we can prove if the solution is correct or not by using [`sympy.solvers.ode.checkodesol()`](#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol")
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用[`sympy.solvers.ode.checkodesol()`](#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol")来证明解是否正确。
- en: '[PRE163]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: We can also use the doit method to evaluate the solutions passed by the function.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用doit方法来评估函数传递的解决方案。
- en: '[PRE164]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Now, we will look at a system of ODEs which is non-constant.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看一个非恒定的ODE系统。
- en: '[PRE165]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The system defined above is already in the desired form, so we do not have to
    convert it.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 上面定义的系统已经处于所需形式，因此我们无需对其进行转换。
- en: '[PRE166]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: A user can also pass the commutative antiderivative required for type3 and type4
    system of ODEs. Passing an incorrect one will lead to incorrect results. If the
    coefficient matrix is not commutative with its antiderivative, then [`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type") raises a NotImplementedError. If
    it does have a commutative antiderivative, then the function just returns the
    information about the system.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以传递需要 type3 和 type4 ODEs 系统的可交换反导数。如果传递错误的反导数，将导致不正确的结果。如果系数矩阵与其反导数不可交换，则
    [`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type") 会引发 NotImplementedError。如果具有可交换的反导数，则函数只返回关于系统的信息。
- en: '[PRE167]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Now, we can pass the antiderivative as an argument to get the solution. If the
    system information is not passed, then the solver will compute the required arguments
    internally.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将反导数作为参数传递以获得解。如果未传递系统信息，则求解器将在内部计算所需的参数。
- en: '[PRE168]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Once again, we can verify the solution obtained.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以验证所得解。
- en: '[PRE169]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: See also
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`linear_ode_to_matrix`](#sympy.solvers.ode.systems.linear_ode_to_matrix "sympy.solvers.ode.systems.linear_ode_to_matrix")'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linear_ode_to_matrix`](#sympy.solvers.ode.systems.linear_ode_to_matrix "sympy.solvers.ode.systems.linear_ode_to_matrix")'
- en: Coefficient matrix computation function
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 系数矩阵计算函数
- en: '[`canonical_odes`](#sympy.solvers.ode.systems.canonical_odes "sympy.solvers.ode.systems.canonical_odes")'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '[`canonical_odes`](#sympy.solvers.ode.systems.canonical_odes "sympy.solvers.ode.systems.canonical_odes")'
- en: System of ODEs representation change
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: ODEs 系统表示更改
- en: '[`linodesolve_type`](#sympy.solvers.ode.systems.linodesolve_type "sympy.solvers.ode.systems.linodesolve_type")'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linodesolve_type`](#sympy.solvers.ode.systems.linodesolve_type "sympy.solvers.ode.systems.linodesolve_type")'
- en: Getting information about systems of ODEs to pass in this solver
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 获取关于 ODEs 系统的信息以在此求解器中传递
- en: '[PRE170]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Equations:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[x' = x^n F(x,y)\]\[y' = g(y) F(x,y)\]
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = x^n F(x,y)\]\[y' = g(y) F(x,y)\]
- en: 'Solution:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 解：
- en: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
- en: where
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: if \(n \neq 1\)
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(n \neq 1\)
- en: \[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: \[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]
- en: if \(n = 1\)
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(n = 1\)
- en: \[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: \[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]
- en: where \(C_1\) and \(C_2\) are arbitrary constants.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1\) 和 \(C_2\) 是任意常数。
- en: '[PRE171]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Equations:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[x' = e^{\lambda x} F(x,y)\]\[y' = g(y) F(x,y)\]
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = e^{\lambda x} F(x,y)\]\[y' = g(y) F(x,y)\]
- en: 'Solution:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 解：
- en: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
- en: where
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: if \(\lambda \neq 0\)
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(\lambda \neq 0\)
- en: \[\varphi = -\frac{1}{\lambda} log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: \[\varphi = -\frac{1}{\lambda} \log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]
- en: if \(\lambda = 0\)
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(\lambda = 0\)
- en: \[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: \[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]
- en: where \(C_1\) and \(C_2\) are arbitrary constants.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1\) 和 \(C_2\) 是任意常数。
- en: '[PRE172]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Autonomous system of general form
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 自主系统的一般形式
- en: \[x' = F(x,y)\]\[y' = G(x,y)\]
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = F(x,y)\]\[y' = G(x,y)\]
- en: Assuming \(y = y(x, C_1)\) where \(C_1\) is an arbitrary constant is the general
    solution of the first-order equation
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 \(y = y(x, C_1)\)，其中 \(C_1\) 是任意常数是一阶方程的一般解
- en: \[F(x,y) y'_x = G(x,y)\]
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: \[F(x,y) y'_x = G(x,y)\]
- en: Then the general solution of the original system of equations has the form
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，原方程组的一般解形式为
- en: \[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: \[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]
- en: '[PRE173]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Equation:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[x' = f_1(x) g_1(y) \phi(x,y,t)\]\[y' = f_2(x) g_2(y) \phi(x,y,t)\]
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = f_1(x) g_1(y) \phi(x,y,t)\]\[y' = f_2(x) g_2(y) \phi(x,y,t)\]
- en: 'First integral:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个积分：
- en: \[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: \[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]
- en: where \(C\) is an arbitrary constant.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C\) 是任意常数。
- en: On solving the first integral for \(x\) (resp., \(y\) ) and on substituting
    the resulting expression into either equation of the original solution, one arrives
    at a first-order equation for determining \(y\) (resp., \(x\) ).
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在解 \(x\)（或 \(y\)）的第一个积分和将得到的表达式代入原解的任一方程后，得到用于确定 \(y\)（或 \(x\)）的一阶方程。
- en: '[PRE174]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Clairaut system of ODEs
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: Clairaut ODEs 系统
- en: \[x = t x' + F(x',y')\]\[y = t y' + G(x',y')\]
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = t x' + F(x',y')\]\[y = t y' + G(x',y')\]
- en: The following are solutions of the system
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的解如下：
- en: '\((i)\) straight lines:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: \((i)\) 直线：
- en: \[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]
- en: where \(C_1\) and \(C_2\) are arbitrary constants;
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1\) 和 \(C_2\) 是任意常数；
- en: \((ii)\) envelopes of the above lines;
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: \((ii)\) 上述线条的包络；
- en: \((iii)\) continuously differentiable lines made up from segments of the lines
    \((i)\) and \((ii)\).
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: \((iii)\) 由直线 \((i)\) 和 \((ii)\) 的线段连续可微而成。
- en: '[PRE175]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Equations:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x
    y\]
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x
    y\]
- en: 'First Integrals:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 第一积分：
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
- en: where \(C_1\) and \(C_2\) are arbitrary constants. On solving the integrals
    for \(y\) and \(z\) and on substituting the resulting expressions into the first
    equation of the system, we arrives at a separable first-order equation on \(x\).
    Similarly doing that for other two equations, we will arrive at first order equation
    on \(y\) and \(z\) too.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1\) 和 \(C_2\) 是任意常数。通过解 \(y\) 和 \(z\) 的积分，并将得到的表达式代入系统的第一方程，我们得到关于 \(x\)
    的分离的一阶方程。类似地，对其他两个方程进行操作，我们也会得到关于 \(y\) 和 \(z\) 的一阶方程。
- en: References
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf)
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf)
- en: '[PRE176]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Equations:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[a x' = (b - c) y z f(x, y, z, t)\]\[b y' = (c - a) z x f(x, y, z, t)\]\[c
    z' = (a - b) x y f(x, y, z, t)\]
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x' = (b - c) y z f(x, y, z, t)\]\[b y' = (c - a) z x f(x, y, z, t)\]\[c
    z' = (a - b) x y f(x, y, z, t)\]
- en: 'First Integrals:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 第一积分：
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
- en: where \(C_1\) and \(C_2\) are arbitrary constants. On solving the integrals
    for \(y\) and \(z\) and on substituting the resulting expressions into the first
    equation of the system, we arrives at a first-order differential equations on
    \(x\). Similarly doing that for other two equations we will arrive at first order
    equation on \(y\) and \(z\).
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C_1\) 和 \(C_2\) 是任意常数。通过解 \(y\) 和 \(z\) 的积分，并将得到的表达式代入系统的第一方程，我们得到关于 \(x\)
    的一阶微分方程。同样地，对其他两个方程进行类似操作，我们会得到关于 \(y\) 和 \(z\) 的一阶方程。
- en: References
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料：
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf)
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf)
- en: '[PRE177]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Equations:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]
- en: where \(F_n = F_n(x, y, z, t)\).
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(F_n = F_n(x, y, z, t)\)。
- en: 'First Integral:'
  id: totrans-1061
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一积分：
- en: \[a x + b y + c z = C_1,\]
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x + b y + c z = C_1,\]
- en: where C is an arbitrary constant.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C\) 是任意常数。
- en: 2\. If we assume function \(F_n\) to be independent of \(t\),i.e, \(F_n\) =
    \(F_n (x, y, z)\) Then, on eliminating \(t\) and \(z\) from the first two equation
    of the system, one arrives at the first-order equation
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 如果我们假设函数 \(F_n\) 独立于 \(t\), 即 \(F_n = F_n (x, y, z)\)，那么在从系统的前两个方程中消除 \(t\)
    和 \(z\) 后，我们得到关于 \(x\) 的一阶方程。
- en: \[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
    b F_3 (x, y, z)}\]
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
    b F_3 (x, y, z)}\]
- en: where \(z = \frac{1}{c} (C_1 - a x - b y)\)
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(z = \frac{1}{c} (C_1 - a x - b y)\)
- en: References
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料：
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf)
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf)
- en: '[PRE178]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Equations:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 方程：
- en: \[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y
    F_1 - a x F_2\]
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y
    F_1 - a x F_2\]
- en: where \(F_n = F_n (x, y, z, t)\)
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(F_n = F_n (x, y, z, t)\)
- en: 'First integral:'
  id: totrans-1073
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一积分：
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: \[a x^{2} + b y^{2} + c z^{2} = C_1\]
- en: where \(C\) is an arbitrary constant.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C\) 是任意常数。
- en: '2\. Assuming the function \(F_n\) is independent of \(t\): \(F_n = F_n (x,
    y, z)\). Then on eliminating \(t\) and \(z\) from the first two equations of the
    system, one arrives at the first-order equation'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 假设函数 \(F_n\) 独立于 \(t\)：\(F_n = F_n (x, y, z)\)。然后，在从系统的前两个方程中消除 \(t\) 和
    \(z\) 后，我们得到一阶方程
- en: \[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)} {c z F_2 (x,
    y, z) - b y F_3 (x, y, z)}\]
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)} {c z F_2 (x,
    y, z) - b y F_3 (x, y, z)}\]
- en: where \(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)
- en: References
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料：
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf)
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf)
- en: '[PRE179]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: \[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b
    F_1 - a F_2)\]
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: \[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b
    F_1 - a F_2)\]
- en: where \(F_n = F_n (x, y, z, t)\) and are arbitrary functions.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(F_n = F_n (x, y, z, t)\) 且为任意函数。
- en: 'First Integral:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 第一积分：
- en: \[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]
- en: where \(C\) is an arbitrary constant. If the function \(F_n\) is independent
    of \(t\), then, by eliminating \(t\) and \(z\) from the first two equations of
    the system, one arrives at a first-order equation.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(C\) 是任意常数。如果函数 \(F_n\) 不依赖于 \(t\)，则通过从系统的前两个方程中消除 \(t\) 和 \(z\)，可以得到一个一阶方程。
- en: References
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf)
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf)
- en: '## Information on the ode module'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '## ode 模块信息'
- en: This module contains [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    and different helper functions that it uses.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块包含 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 和它使用的不同辅助函数。
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") solves ordinary
    differential equations. See the docstring on the various functions for their uses.
    Note that partial differential equations support is in `pde.py`. Note that hint
    functions have docstrings describing their various methods, but they are intended
    for internal use. Use `dsolve(ode, func, hint=hint)` to solve an ODE using a specific
    hint. See also the docstring on [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 解决普通微分方程。查看各个函数的文档字符串以了解它们的用途。注意，偏微分方程的支持在
    `pde.py` 中。注意，提示函数有描述其各种方法的文档字符串，但它们仅供内部使用。使用 `dsolve(ode, func, hint=hint)` 使用特定提示来解决ODE。另请参阅
    [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 的文档字符串。'
- en: '**Functions in this module**'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '**此模块中的函数**'
- en: 'These are the user functions in this module:'
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是此模块中的用户函数：
- en: ''
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") - Solves
    ODEs.'
  id: totrans-1095
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") - 解决ODE。'
- en: ''
  id: totrans-1096
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1097
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    - Classifies ODEs into possible hints for [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").'
  id: totrans-1098
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    - 将ODE分类为可能的提示供 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    使用。'
- en: ''
  id: totrans-1099
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`checkodesol()`](#sympy.solvers.ode.checkodesol "sympy.solvers.ode.checkodesol")
    - Checks if an equation is the solution to an ODE.'
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`checkodesol()`](#sympy.solvers.ode.checkodesol "sympy.solvers.ode.checkodesol")
    - 检查方程是否是ODE的解。'
- en: ''
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order")
    - Returns the homogeneous order of an expression.'
  id: totrans-1104
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order")
    - 返回表达式的齐次阶数。'
- en: ''
  id: totrans-1105
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    - Returns the infinitesimals of the Lie group of point transformations of an ODE,
    such that it is invariant.'
  id: totrans-1107
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    - 返回ODE的点变换Lie群的无穷小，使其保持不变。'
- en: ''
  id: totrans-1108
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`checkinfsol()`](#sympy.solvers.ode.checkinfsol "sympy.solvers.ode.checkinfsol")
    - Checks if the given infinitesimals are the actual infinitesimals of a first
    order ODE.'
  id: totrans-1110
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`checkinfsol()`](#sympy.solvers.ode.checkinfsol "sympy.solvers.ode.checkinfsol")
    - 检查给定的无穷小是否是一阶ODE的实际无穷小。'
- en: ''
  id: totrans-1111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'These are the non-solver helper functions that are for internal use. The user
    should use the various options to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    to obtain the functionality provided by these functions:'
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是用于内部使用的非解算器辅助函数。用户应使用 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    的各种选项来获得这些函数提供的功能：
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    - Does all forms of ODE simplification.'
  id: totrans-1116
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    - 进行所有形式的ODE简化。'
- en: ''
  id: totrans-1117
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity "sympy.solvers.ode.ode.ode_sol_simplicity")
    - A key function for comparing solutions by simplicity.'
  id: totrans-1119
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity "sympy.solvers.ode.ode.ode_sol_simplicity")
    - 用于比较解的简易性的关键函数。'
- en: ''
  id: totrans-1120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")
    - Simplifies arbitrary constants.'
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")
    - 简化任意常数。'
- en: ''
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")
    - Renumber arbitrary constants.'
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")
    - 重新编号任意常数。'
- en: ''
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral "sympy.solvers.ode.ode._handle_Integral")
    - Evaluate unevaluated Integrals.'
  id: totrans-1128
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral "sympy.solvers.ode.ode._handle_Integral")
    - 评估未评估的积分。'
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1130
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also the docstrings of these functions.
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见这些函数的文档字符串。
- en: '**Currently implemented solver methods**'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前实现的求解器方法**'
- en: 'The following methods are implemented for solving ordinary differential equations.
    See the docstrings of the various hint functions for more information on each
    (run `help(ode)`):'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 下列方法用于解决普通微分方程。更多信息请查看各种提示函数的文档字符串（运行 `help(ode)`）：
- en: 1st order separable differential equations.
  id: totrans-1135
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶可分离微分方程。
- en: ''
  id: totrans-1136
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1137
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order differential equations whose coefficients or \(dx\) and \(dy\) are
    functions homogeneous of the same order.
  id: totrans-1138
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系数或 $dx$ 和 $dy$ 为同阶函数的一阶微分方程。
- en: ''
  id: totrans-1139
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1140
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order exact differential equations.
  id: totrans-1141
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶精确微分方程。
- en: ''
  id: totrans-1142
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1143
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order linear differential equations.
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶线性微分方程。
- en: ''
  id: totrans-1145
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1146
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order Bernoulli differential equations.
  id: totrans-1147
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶 Bernoulli 微分方程。
- en: ''
  id: totrans-1148
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Power series solutions for first order differential equations.
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一阶微分方程的幂级数解法。
- en: ''
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Lie Group method of solving first order differential equations.
  id: totrans-1153
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 Lie Group 方法解决一阶微分方程。
- en: ''
  id: totrans-1154
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1155
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 2nd order Liouville differential equations.
  id: totrans-1156
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二阶 Liouville 微分方程。
- en: ''
  id: totrans-1157
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1158
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Power series solutions for second order differential equations at ordinary and
    regular singular points.
  id: totrans-1159
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二阶微分方程的幂级数解法，在普通和正则奇点处。
- en: ''
  id: totrans-1160
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1161
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order differential equation that can be solved with algebraic rearrangement
    and integration.
  id: totrans-1162
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过代数重排和积分解决的 $n$ 阶微分方程。
- en: ''
  id: totrans-1163
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear homogeneous differential equation with constant coefficients.
  id: totrans-1165
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有常系数的 $n$ 阶线性齐次微分方程。
- en: ''
  id: totrans-1166
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1167
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear inhomogeneous differential equation with constant coefficients
    using the method of undetermined coefficients.
  id: totrans-1168
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有常系数的 $n$ 阶线性非齐次微分方程，使用特解系数方法。
- en: ''
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear inhomogeneous differential equation with constant coefficients
    using the method of variation of parameters.
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有常系数的 $n$ 阶线性非齐次微分方程，使用参数变化法。
- en: '**Philosophy behind this module**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**该模块的理念**'
- en: This module is designed to make it easy to add new ODE solving methods without
    having to mess with the solving code for other methods. The idea is that there
    is a [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    function, which takes in an ODE and tells you what hints, if any, will solve the
    ODE. It does this without attempting to solve the ODE, so it is fast. Each solving
    method is a hint, and it has its own function, named `ode_<hint>`. That function
    takes in the ODE and any match expression gathered by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") and returns a solved result. If this result
    has any integrals in it, the hint function will return an unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") class. [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), which is the user wrapper function around all of
    this, will then call [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    on the result, which, among other things, will attempt to solve the equation for
    the dependent variable (the function we are solving for), simplify the arbitrary
    constants in the expression, and evaluate any integrals, if the hint allows it.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块设计用于简化添加新的 ODE 求解方法，无需干扰其他方法的求解代码。其思想在于有一个 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 函数，输入一个 ODE 并告诉您什么提示（如果有）可以解决该 ODE。它在不尝试解决 ODE
    的情况下执行此操作，因此速度很快。每个求解方法都是一个提示，并且有自己的函数，命名为 `ode_<hint>`。该函数接受 ODE 和由 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 收集的任何匹配表达式，并返回解决的结果。如果此结果中有任何积分，提示函数将返回一个未评估的
    [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral "sympy.integrals.integrals.Integral")
    类。[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 是用户包装器函数，将对结果调用
    [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")，它将尝试解决依赖变量（我们正在解决的函数）的方程，简化表达式中的任意常数，并评估任何积分，如果提示允许的话。
- en: '**How to add new solution methods**'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何添加新的解法方法**'
- en: If you have an ODE that you want [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    to be able to solve, try to avoid adding special case code here. Instead, try
    finding a general method that will solve your ODE, as well as others. This way,
    the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") module will become
    more robust, and unhindered by special case hacks. WolphramAlpha and Maple’s DETools[odeadvisor]
    function are two resources you can use to classify a specific ODE. It is also
    better for a method to work with an \(n\)th order ODE instead of only with specific
    orders, if possible.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个希望[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") 能够解决的ODE，请尽量避免在这里添加特殊情况的代码。相反，尝试找到一种通用的方法来解决你的ODE，以及其他的ODE。这样，[`ode`](#module-sympy.solvers.ode
    "sympy.solvers.ode") 模块将变得更加健壮，而且不受特殊情况的限制。WolphramAlpha 和 Maple 的 DETools[odeadvisor]
    函数是你可以用来分类特定ODE的两个资源。如果可能的话，一个方法最好是能处理一个\(n\)阶的ODE，而不仅仅是特定阶数的ODE。
- en: To add a new method, there are a few things that you need to do. First, you
    need a hint name for your method. Try to name your hint so that it is unambiguous
    with all other methods, including ones that may not be implemented yet. If your
    method uses integrals, also include a `hint_Integral` hint. If there is more than
    one way to solve ODEs with your method, include a hint for each one, as well as
    a `<hint>_best` hint. Your `ode_<hint>_best()` function should choose the best
    using min with `ode_sol_simplicity` as the key argument. See [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest"), for example. The function that
    uses your method will be called `ode_<hint>()`, so the hint must only use characters
    that are allowed in a Python function name (alphanumeric characters and the underscore
    ‘`_`’ character). Include a function for every hint, except for `_Integral` hints
    ([`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") takes care
    of those automatically). Hint names should be all lowercase, unless a word is
    commonly capitalized (such as Integral or Bernoulli). If you have a hint that
    you do not want to run with `all_Integral` that does not have an `_Integral` counterpart
    (such as a best hint that would defeat the purpose of `all_Integral`), you will
    need to remove it manually in the [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    code. See also the [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    docstring for guidelines on writing a hint name.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个新的方法，你需要做几件事情。首先，你需要为你的方法取一个提示名字。尽量命名你的提示，以便与所有其他方法都不会产生歧义，包括可能尚未实现的方法。如果你的方法使用积分，还要包括一个
    `hint_Integral` 提示。如果有多种方法可以解决ODE，那么每种方法都应包括一个提示，以及一个 `<hint>_best` 提示。你的 `ode_<hint>_best()`
    函数应该使用 `ode_sol_simplicity` 作为关键参数选择最佳方法。例如参见[`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest")。使用你的方法的函数将被称为 `ode_<hint>()`，因此提示必须仅使用Python函数名允许的字符（字母数字字符和下划线‘`_`’字符）。除了
    `_Integral` 提示（[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    会自动处理这些），每个提示都应包括一个函数。提示名应全部小写，除非是一个常见的大写单词（如Integral或Bernoulli）。如果你有一个不希望与 `all_Integral`
    一起运行的提示，没有 `_Integral` 对应项（例如会破坏 `all_Integral` 目的的最佳提示），你需要在 [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") 代码中手动移除它。另请参阅 [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") 的文档字符串，了解编写提示名称的指导方针。
- en: Determine *in general* how the solutions returned by your method compare with
    other methods that can potentially solve the same ODEs. Then, put your hints in
    the [`allhints`](#sympy.solvers.ode.allhints "sympy.solvers.ode.allhints") tuple
    in the order that they should be called. The ordering of this tuple determines
    which hints are default. Note that exceptions are ok, because it is easy for the
    user to choose individual hints with [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    In general, `_Integral` variants should go at the end of the list, and `_best`
    variants should go before the various hints they apply to. For example, the `undetermined_coefficients`
    hint comes before the `variation_of_parameters` hint because, even though variation
    of parameters is more general than undetermined coefficients, undetermined coefficients
    generally returns cleaner results for the ODEs that it can solve than variation
    of parameters does, and it does not require integration, so it is much faster.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '*总的来说*，要确定您的方法返回的解决方案与其他可能解决相同ODE的方法相比如何。然后，将您的提示放入[`allhints`](#sympy.solvers.ode.allhints
    "sympy.solvers.ode.allhints")元组中，以确定调用它们的顺序。此元组的排序决定了默认的提示顺序。请注意，异常是可以接受的，因为用户很容易使用[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")选择单个提示。一般来说，`_Integral`变体应放在列表的末尾，而`_best`变体应放在其适用的各种提示之前。例如，`undetermined_coefficients`提示在`variation_of_parameters`提示之前，因为虽然参数变化比不定系数更一般，但不定系数通常为其能解决的ODE生成更干净的结果，并且不需要积分，因此速度更快。'
- en: Next, you need to have a match expression or a function that matches the type
    of the ODE, which you should put in [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") (if the match function is more than just a few
    lines. It should match the ODE without solving for it as much as possible, so
    that [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    remains fast and is not hindered by bugs in solving code. Be sure to consider
    corner cases. For example, if your solution method involves dividing by something,
    make sure you exclude the case where that division will be 0.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要有一个匹配表达式或函数，匹配ODE的类型，你应该将其放在[`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode")中（如果匹配函数不止几行。应尽可能匹配ODE而不解决它，以便[`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode")保持快速，并且不受解决代码中错误的影响。务必考虑边界情况。例如，如果你的解决方法涉及除以某些东西，请确保排除除数为0的情况。
- en: In most cases, the matching of the ODE will also give you the various parts
    that you need to solve it. You should put that in a dictionary (`.match()` will
    do this for you), and add that as `matching_hints['hint'] = matchdict` in the
    relevant part of [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode").
    [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    will then send this to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"),
    which will send it to your function as the `match` argument. Your function should
    be named [PRE180] dictionary. For example, if you had to substitute in a dummy
    variable in [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    to match the ODE, you will need to pass it to your function using the \(match\)
    dict to access it. You can access the independent variable using `func.args[0]`,
    and the dependent variable (the function you are trying to solve for) as `func.func`.
    If, while trying to solve the ODE, you find that you cannot, raise `NotImplementedError`.
    [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") will catch
    this error with the `all` meta-hint, rather than causing the whole routine to
    fail.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，ODE的匹配还将为您提供解决它所需的各个部分。您应该将其放在一个字典中（`.match()`将为您执行此操作），并在[`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode")的相关部分中添加`matching_hints['hint'] = matchdict`。[`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode")然后会将此发送到[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")，后者将其作为`match`参数发送到您的函数。您的函数应命名为[PRE180]字典。例如，如果您必须在[`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode")中替换一个虚拟变量以匹配ODE，则需要使用\(match\)字典将其传递给您的函数。您可以使用`func.args[0]`访问自变量，使用`func.func`访问因变量（您试图解决的函数）。如果在试图解决ODE时发现无法解决，则引发`NotImplementedError`。[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")将使用`all`元提示捕获此错误，而不会导致整个例程失败。
- en: Add a docstring to your function that describes the method employed. Like with
    anything else in SymPy, you will need to add a doctest to the docstring, in addition
    to real tests in `test_ode.py`. Try to maintain consistency with the other hint
    functions’ docstrings. Add your method to the list at the top of this docstring.
    Also, add your method to `ode.rst` in the `docs/src` directory, so that the Sphinx
    docs will pull its docstring into the main SymPy documentation. Be sure to make
    the Sphinx documentation by running `make html` from within the doc directory
    to verify that the docstring formats correctly.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的函数添加一个描述所采用方法的文档字符串。与 SymPy 中的其他任何内容一样，你需要在文档字符串中添加一个 doctest，并在 `test_ode.py`
    中添加真实的测试。尽量保持与其他提示函数的文档字符串一致性。将你的方法添加到此文档字符串顶部的列表中。同时，将你的方法添加到 `docs/src` 目录中的
    `ode.rst` 中，以便 Sphinx 文档将其文档字符串引入主 SymPy 文档中。确保通过在文档目录中运行 `make html` 来生成 Sphinx
    文档，以验证文档字符串的格式是否正确。
- en: If your solution method involves integrating, use [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") instead of [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate"). This allows the user to bypass hard/slow integration
    by using the `_Integral` variant of your hint. In most cases, calling [`sympy.core.basic.Basic.doit()`](../core.html#sympy.core.basic.Basic.doit
    "sympy.core.basic.Basic.doit") will integrate your solution. If this is not the
    case, you will need to write special code in [`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral
    "sympy.solvers.ode.ode._handle_Integral"). Arbitrary constants should be symbols
    named `C1`, `C2`, and so on. All solution methods should return an equality instance.
    If you need an arbitrary number of arbitrary constants, you can use `constants
    = numbered_symbols(prefix='C', cls=Symbol, start=1)`. If it is possible to solve
    for the dependent function in a general way, do so. Otherwise, do as best as you
    can, but do not call solve in your `ode_<hint>()` function. [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") will attempt to solve the solution for you, so
    you do not need to do that. Lastly, if your ODE has a common simplification that
    can be applied to your solutions, you can add a special case in [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") for it. For example, solutions returned from
    the `1st_homogeneous_coeff` hints often have many [`log`](../functions/elementary.html#sympy.functions.elementary.exponential.log
    "sympy.functions.elementary.exponential.log") terms, so [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") calls [`logcombine()`](../simplify/simplify.html#sympy.simplify.simplify.logcombine
    "sympy.simplify.simplify.logcombine") on them (it also helps to write the arbitrary
    constant as `log(C1)` instead of `C1` in this case). Also consider common ways
    that you can rearrange your solution to have [`constantsimp()`](#sympy.solvers.ode.constantsimp
    "sympy.solvers.ode.constantsimp") take better advantage of it. It is better to
    put simplification in [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    than in your method, because it can then be turned off with the simplify flag
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"). If you
    have any extraneous simplification in your function, be sure to only run it using
    `if match.get('simplify', True):`, especially if it can be slow or if it can reduce
    the domain of the solution.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的解决方法涉及积分，请使用[`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")而不是[`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate")。这使用户可以通过使用你提示的 `_Integral` 变体来避开复杂/慢速的积分。在大多数情况下，调用[`sympy.core.basic.Basic.doit()`](../core.html#sympy.core.basic.Basic.doit
    "sympy.core.basic.Basic.doit")将对你的解决方案进行积分。如果不是这种情况，你需要在[`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral
    "sympy.solvers.ode.ode._handle_Integral")中编写特殊代码。任意常数应命名为`C1`、`C2`等符号。所有解决方法都应返回一个等式实例。如果需要任意数量的任意常数，可以使用`constants
    = numbered_symbols(prefix='C', cls=Symbol, start=1)`。如果可能以一般方式解决依赖函数，请这样做。否则，请尽力而为，但不要在你的
    `ode_<hint>()` 函数中调用 `solve`。[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")将尝试为你解决方案解决问题，因此你不需要这样做。最后，如果你的ODE有一个可以应用于解决方案的常见简化，可以在[`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp")中添加一个特殊情况。例如，从 `1st_homogeneous_coeff` 提示返回的解经常有许多[`log`](../functions/elementary.html#sympy.functions.elementary.exponential.log
    "sympy.functions.elementary.exponential.log")项，因此 [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") 在它们上调用 [`logcombine()`](../simplify/simplify.html#sympy.simplify.simplify.logcombine
    "sympy.simplify.simplify.logcombine")（在这种情况下，将任意常数写为 `log(C1)` 而不是 `C1` 也很有帮助）。还要考虑常见的解决方案重新排列的方法，以便
    [`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")
    更好地利用它。最好将简化放在 [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    中而不是在你的方法中，因为可以在 [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    的 `simplify` 标志中关闭它。如果在你的函数中有任何多余的简化，请确保只在 `if match.get('simplify', True):` 下运行它，特别是如果它可能很慢或者可能减少解决方案的域。
- en: Finally, as with every contribution to SymPy, your method will need to be tested.
    Add a test for each method in `test_ode.py`. Follow the conventions there, i.e.,
    test the solver using `dsolve(eq, f(x), hint=your_hint)`, and also test the solution
    using [`checkodesol()`](#sympy.solvers.ode.checkodesol "sympy.solvers.ode.checkodesol")
    (you can put these in a separate tests and skip/XFAIL if it runs too slow/does
    not work). Be sure to call your hint specifically in [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), that way the test will not be broken simply by the
    introduction of another matching hint. If your method works for higher order (>1)
    ODEs, you will need to run `sol = constant_renumber(sol, 'C', 1, order)` for each
    solution, where `order` is the order of the ODE. This is because `constant_renumber`
    renumbers the arbitrary constants by printing order, which is platform dependent.
    Try to test every corner case of your solver, including a range of orders if it
    is a \(n\)th order solver, but if your solver is slow, such as if it involves
    hard integration, try to keep the test run time down.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与对SymPy的每一次贡献一样，您的方法将需要进行测试。在`test_ode.py`中为每种方法添加一个测试。遵循那里的惯例，即使用`dsolve(eq,
    f(x), hint=your_hint)`测试求解器，并使用[`checkodesol()`](#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol")测试解决方案（如果运行过慢或者不起作用，可以将这些放在单独的测试中并跳过/XFAIL）。确保在[`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")中特别调用您的提示，这样测试不会仅仅因为引入另一个匹配提示而失败。如果您的方法适用于高阶（>1）ODEs，您将需要对每个解运行`sol
    = constant_renumber(sol, 'C', 1, order)`，其中`order`是ODE的阶数。这是因为`constant_renumber`通过打印顺序重新编号任意常数，这取决于平台。尽量测试您求解器的每个边界情况，包括一系列阶数，如果它是一个$n$阶求解器的话，但如果您的求解器运行速度较慢，比如涉及到复杂的积分，尽量保持测试运行时间短。
- en: Feel free to refactor existing hints to avoid duplicating code or creating inconsistencies.
    If you can show that your method exactly duplicates an existing method, including
    in the simplicity and speed of obtaining the solutions, then you can remove the
    old, less general method. The existing code is tested extensively in `test_ode.py`,
    so if anything is broken, one of those tests will surely fail.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 请随意重构现有提示，以避免重复代码或创建不一致。如果您能证明您的方法完全复制了现有方法，包括获取解决方案的简易性和速度，则可以删除旧的、不太普遍的方法。现有代码在`test_ode.py`中经过了广泛测试，因此如果有任何问题，其中的某个测试肯定会失败。
- en: These functions are not intended for end-user use.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数不适用于最终用户使用。
- en: '[PRE181]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Converts a solution with Integrals in it into an actual solution.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有积分的解转换为实际解决方案。
- en: For most hints, this simply runs `expr.doit()`.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数提示，这只是运行`expr.doit()`。
