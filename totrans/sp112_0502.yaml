- en: Signal processing (scipy.signal)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/signal.html](https://docs.scipy.org/doc/scipy-1.12.0/reference/signal.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Convolution'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`convolve`](generated/scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve")(in1, in2[, mode, method])
    | Convolve two N-dimensional arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`correlate`](generated/scipy.signal.correlate.html#scipy.signal.correlate
    "scipy.signal.correlate")(in1, in2[, mode, method]) | Cross-correlate two N-dimensional
    arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fftconvolve`](generated/scipy.signal.fftconvolve.html#scipy.signal.fftconvolve
    "scipy.signal.fftconvolve")(in1, in2[, mode, axes]) | Convolve two N-dimensional
    arrays using FFT. |'
  prefs: []
  type: TYPE_TB
- en: '| [`oaconvolve`](generated/scipy.signal.oaconvolve.html#scipy.signal.oaconvolve
    "scipy.signal.oaconvolve")(in1, in2[, mode, axes]) | Convolve two N-dimensional
    arrays using the overlap-add method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`convolve2d`](generated/scipy.signal.convolve2d.html#scipy.signal.convolve2d
    "scipy.signal.convolve2d")(in1, in2[, mode, boundary, fillvalue]) | Convolve two
    2-dimensional arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`correlate2d`](generated/scipy.signal.correlate2d.html#scipy.signal.correlate2d
    "scipy.signal.correlate2d")(in1, in2[, mode, boundary, ...]) | Cross-correlate
    two 2-dimensional arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sepfir2d`](generated/scipy.signal.sepfir2d.html#scipy.signal.sepfir2d "scipy.signal.sepfir2d")(input, hrow, hcol)
    | Convolve with a 2-D separable FIR filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`choose_conv_method`](generated/scipy.signal.choose_conv_method.html#scipy.signal.choose_conv_method
    "scipy.signal.choose_conv_method")(in1, in2[, mode, measure]) | Find the fastest
    convolution/correlation method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`correlation_lags`](generated/scipy.signal.correlation_lags.html#scipy.signal.correlation_lags
    "scipy.signal.correlation_lags")(in1_len, in2_len[, mode]) | Calculates the lag
    / displacement indices array for 1D cross-correlation. |'
  prefs: []
  type: TYPE_TB
- en: B-splines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`bspline`](generated/scipy.signal.bspline.html#scipy.signal.bspline "scipy.signal.bspline")(x, n)
    |'
  prefs: []
  type: TYPE_TB
- en: Deprecated since version 1.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`cubic`](generated/scipy.signal.cubic.html#scipy.signal.cubic "scipy.signal.cubic")(x)
    |'
  prefs: []
  type: TYPE_TB
- en: Deprecated since version 1.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`quadratic`](generated/scipy.signal.quadratic.html#scipy.signal.quadratic
    "scipy.signal.quadratic")(x) |'
  prefs: []
  type: TYPE_TB
- en: Deprecated since version 1.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`gauss_spline`](generated/scipy.signal.gauss_spline.html#scipy.signal.gauss_spline
    "scipy.signal.gauss_spline")(x, n) | Gaussian approximation to B-spline basis
    function of order n. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cspline1d`](generated/scipy.signal.cspline1d.html#scipy.signal.cspline1d
    "scipy.signal.cspline1d")(signal[, lamb]) | Compute cubic spline coefficients
    for rank-1 array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`qspline1d`](generated/scipy.signal.qspline1d.html#scipy.signal.qspline1d
    "scipy.signal.qspline1d")(signal[, lamb]) | Compute quadratic spline coefficients
    for rank-1 array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cspline2d`](generated/scipy.signal.cspline2d.html#scipy.signal.cspline2d
    "scipy.signal.cspline2d")(input[, lambda, precision]) | Coefficients for 2-D cubic
    (3rd order) B-spline. |'
  prefs: []
  type: TYPE_TB
- en: '| [`qspline2d`](generated/scipy.signal.qspline2d.html#scipy.signal.qspline2d
    "scipy.signal.qspline2d")(input[, lambda, precision]) | Coefficients for 2-D quadratic
    (2nd order) B-spline: |'
  prefs: []
  type: TYPE_TB
- en: '| [`cspline1d_eval`](generated/scipy.signal.cspline1d_eval.html#scipy.signal.cspline1d_eval
    "scipy.signal.cspline1d_eval")(cj, newx[, dx, x0]) | Evaluate a cubic spline at
    the new set of points. |'
  prefs: []
  type: TYPE_TB
- en: '| [`qspline1d_eval`](generated/scipy.signal.qspline1d_eval.html#scipy.signal.qspline1d_eval
    "scipy.signal.qspline1d_eval")(cj, newx[, dx, x0]) | Evaluate a quadratic spline
    at the new set of points. |'
  prefs: []
  type: TYPE_TB
- en: '| [`spline_filter`](generated/scipy.signal.spline_filter.html#scipy.signal.spline_filter
    "scipy.signal.spline_filter")(Iin[, lmbda]) | Smoothing spline (cubic) filtering
    of a rank-2 array. |'
  prefs: []
  type: TYPE_TB
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`order_filter`](generated/scipy.signal.order_filter.html#scipy.signal.order_filter
    "scipy.signal.order_filter")(a, domain, rank) | Perform an order filter on an
    N-D array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`medfilt`](generated/scipy.signal.medfilt.html#scipy.signal.medfilt "scipy.signal.medfilt")(volume[, kernel_size])
    | Perform a median filter on an N-dimensional array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`medfilt2d`](generated/scipy.signal.medfilt2d.html#scipy.signal.medfilt2d
    "scipy.signal.medfilt2d")(input[, kernel_size]) | Median filter a 2-dimensional
    array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`wiener`](generated/scipy.signal.wiener.html#scipy.signal.wiener "scipy.signal.wiener")(im[, mysize, noise])
    | Perform a Wiener filter on an N-dimensional array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`symiirorder1`](generated/scipy.signal.symiirorder1.html#scipy.signal.symiirorder1
    "scipy.signal.symiirorder1")(input, c0, z1[, precision]) | Implement a smoothing
    IIR filter with mirror-symmetric boundary conditions using a cascade of first-order
    sections. The second section uses a reversed sequence. This implements a system
    with the following transfer function and mirror-symmetric boundary conditions::.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`symiirorder2`](generated/scipy.signal.symiirorder2.html#scipy.signal.symiirorder2
    "scipy.signal.symiirorder2")(input, r, omega[, precision]) | Implement a smoothing
    IIR filter with mirror-symmetric boundary conditions using a cascade of second-order
    sections. The second section uses a reversed sequence. This implements the following
    transfer function::. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lfilter`](generated/scipy.signal.lfilter.html#scipy.signal.lfilter "scipy.signal.lfilter")(b, a, x[, axis, zi])
    | Filter data along one-dimension with an IIR or FIR filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lfiltic`](generated/scipy.signal.lfiltic.html#scipy.signal.lfiltic "scipy.signal.lfiltic")(b, a, y[, x])
    | Construct initial conditions for lfilter given input and output vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lfilter_zi`](generated/scipy.signal.lfilter_zi.html#scipy.signal.lfilter_zi
    "scipy.signal.lfilter_zi")(b, a) | Construct initial conditions for lfilter for
    step response steady-state. |'
  prefs: []
  type: TYPE_TB
- en: '| [`filtfilt`](generated/scipy.signal.filtfilt.html#scipy.signal.filtfilt "scipy.signal.filtfilt")(b, a, x[, axis, padtype, padlen, ...])
    | Apply a digital filter forward and backward to a signal. |'
  prefs: []
  type: TYPE_TB
- en: '| [`savgol_filter`](generated/scipy.signal.savgol_filter.html#scipy.signal.savgol_filter
    "scipy.signal.savgol_filter")(x, window_length, polyorder[, ...]) | Apply a Savitzky-Golay
    filter to an array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`deconvolve`](generated/scipy.signal.deconvolve.html#scipy.signal.deconvolve
    "scipy.signal.deconvolve")(signal, divisor) | Deconvolves `divisor` out of `signal`
    using inverse filtering. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sosfilt`](generated/scipy.signal.sosfilt.html#scipy.signal.sosfilt "scipy.signal.sosfilt")(sos, x[, axis, zi])
    | Filter data along one dimension using cascaded second-order sections. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sosfilt_zi`](generated/scipy.signal.sosfilt_zi.html#scipy.signal.sosfilt_zi
    "scipy.signal.sosfilt_zi")(sos) | Construct initial conditions for sosfilt for
    step response steady-state. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sosfiltfilt`](generated/scipy.signal.sosfiltfilt.html#scipy.signal.sosfiltfilt
    "scipy.signal.sosfiltfilt")(sos, x[, axis, padtype, padlen]) | A forward-backward
    digital filter using cascaded second-order sections. |'
  prefs: []
  type: TYPE_TB
- en: '| [`hilbert`](generated/scipy.signal.hilbert.html#scipy.signal.hilbert "scipy.signal.hilbert")(x[, N, axis])
    | Compute the analytic signal, using the Hilbert transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`hilbert2`](generated/scipy.signal.hilbert2.html#scipy.signal.hilbert2 "scipy.signal.hilbert2")(x[, N])
    | Compute the ''2-D'' analytic signal of *x* |'
  prefs: []
  type: TYPE_TB
- en: '| [`decimate`](generated/scipy.signal.decimate.html#scipy.signal.decimate "scipy.signal.decimate")(x, q[, n, ftype, axis, zero_phase])
    | Downsample the signal after applying an anti-aliasing filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`detrend`](generated/scipy.signal.detrend.html#scipy.signal.detrend "scipy.signal.detrend")(data[, axis, type, bp, overwrite_data])
    | Remove linear trend along axis from data. |'
  prefs: []
  type: TYPE_TB
- en: '| [`resample`](generated/scipy.signal.resample.html#scipy.signal.resample "scipy.signal.resample")(x, num[, t, axis, window, domain])
    | Resample *x* to *num* samples using Fourier method along the given axis. |'
  prefs: []
  type: TYPE_TB
- en: '| [`resample_poly`](generated/scipy.signal.resample_poly.html#scipy.signal.resample_poly
    "scipy.signal.resample_poly")(x, up, down[, axis, window, ...]) | Resample *x*
    along the given axis using polyphase filtering. |'
  prefs: []
  type: TYPE_TB
- en: '| [`upfirdn`](generated/scipy.signal.upfirdn.html#scipy.signal.upfirdn "scipy.signal.upfirdn")(h, x[, up, down, axis, mode, cval])
    | Upsample, FIR filter, and downsample. |'
  prefs: []
  type: TYPE_TB
- en: Filter design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`bilinear`](generated/scipy.signal.bilinear.html#scipy.signal.bilinear "scipy.signal.bilinear")(b, a[, fs])
    | Return a digital IIR filter from an analog one using a bilinear transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bilinear_zpk`](generated/scipy.signal.bilinear_zpk.html#scipy.signal.bilinear_zpk
    "scipy.signal.bilinear_zpk")(z, p, k, fs) | Return a digital IIR filter from an
    analog one using a bilinear transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`findfreqs`](generated/scipy.signal.findfreqs.html#scipy.signal.findfreqs
    "scipy.signal.findfreqs")(num, den, N[, kind]) | Find array of frequencies for
    computing the response of an analog filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`firls`](generated/scipy.signal.firls.html#scipy.signal.firls "scipy.signal.firls")(numtaps, bands, desired, *[, weight, ...])
    | FIR filter design using least-squares error minimization. |'
  prefs: []
  type: TYPE_TB
- en: '| [`firwin`](generated/scipy.signal.firwin.html#scipy.signal.firwin "scipy.signal.firwin")(numtaps, cutoff, *[, width, window, ...])
    | FIR filter design using the window method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`firwin2`](generated/scipy.signal.firwin2.html#scipy.signal.firwin2 "scipy.signal.firwin2")(numtaps, freq, gain, *[, nfreqs, ...])
    | FIR filter design using the window method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`freqs`](generated/scipy.signal.freqs.html#scipy.signal.freqs "scipy.signal.freqs")(b, a[, worN, plot])
    | Compute frequency response of analog filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`freqs_zpk`](generated/scipy.signal.freqs_zpk.html#scipy.signal.freqs_zpk
    "scipy.signal.freqs_zpk")(z, p, k[, worN]) | Compute frequency response of analog
    filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`freqz`](generated/scipy.signal.freqz.html#scipy.signal.freqz "scipy.signal.freqz")(b[, a, worN, whole, plot, fs, ...])
    | Compute the frequency response of a digital filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`freqz_zpk`](generated/scipy.signal.freqz_zpk.html#scipy.signal.freqz_zpk
    "scipy.signal.freqz_zpk")(z, p, k[, worN, whole, fs]) | Compute the frequency
    response of a digital filter in ZPK form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sosfreqz`](generated/scipy.signal.sosfreqz.html#scipy.signal.sosfreqz "scipy.signal.sosfreqz")(sos[, worN, whole, fs])
    | Compute the frequency response of a digital filter in SOS format. |'
  prefs: []
  type: TYPE_TB
- en: '| [`gammatone`](generated/scipy.signal.gammatone.html#scipy.signal.gammatone
    "scipy.signal.gammatone")(freq, ftype[, order, numtaps, fs]) | Gammatone filter
    design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`group_delay`](generated/scipy.signal.group_delay.html#scipy.signal.group_delay
    "scipy.signal.group_delay")(system[, w, whole, fs]) | Compute the group delay
    of a digital filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`iirdesign`](generated/scipy.signal.iirdesign.html#scipy.signal.iirdesign
    "scipy.signal.iirdesign")(wp, ws, gpass, gstop[, analog, ...]) | Complete IIR
    digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`iirfilter`](generated/scipy.signal.iirfilter.html#scipy.signal.iirfilter
    "scipy.signal.iirfilter")(N, Wn[, rp, rs, btype, analog, ...]) | IIR digital and
    analog filter design given order and critical points. |'
  prefs: []
  type: TYPE_TB
- en: '| [`kaiser_atten`](generated/scipy.signal.kaiser_atten.html#scipy.signal.kaiser_atten
    "scipy.signal.kaiser_atten")(numtaps, width) | Compute the attenuation of a Kaiser
    FIR filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`kaiser_beta`](generated/scipy.signal.kaiser_beta.html#scipy.signal.kaiser_beta
    "scipy.signal.kaiser_beta")(a) | Compute the Kaiser parameter *beta*, given the
    attenuation *a*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`kaiserord`](generated/scipy.signal.kaiserord.html#scipy.signal.kaiserord
    "scipy.signal.kaiserord")(ripple, width) | Determine the filter window parameters
    for the Kaiser window method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`minimum_phase`](generated/scipy.signal.minimum_phase.html#scipy.signal.minimum_phase
    "scipy.signal.minimum_phase")(h[, method, n_fft]) | Convert a linear-phase FIR
    filter to minimum phase |'
  prefs: []
  type: TYPE_TB
- en: '| [`savgol_coeffs`](generated/scipy.signal.savgol_coeffs.html#scipy.signal.savgol_coeffs
    "scipy.signal.savgol_coeffs")(window_length, polyorder[, ...]) | Compute the coefficients
    for a 1-D Savitzky-Golay FIR filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`remez`](generated/scipy.signal.remez.html#scipy.signal.remez "scipy.signal.remez")(numtaps, bands, desired, *[, weight, ...])
    | Calculate the minimax optimal filter using the Remez exchange algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`unique_roots`](generated/scipy.signal.unique_roots.html#scipy.signal.unique_roots
    "scipy.signal.unique_roots")(p[, tol, rtype]) | Determine unique roots and their
    multiplicities from a list of roots. |'
  prefs: []
  type: TYPE_TB
- en: '| [`residue`](generated/scipy.signal.residue.html#scipy.signal.residue "scipy.signal.residue")(b, a[, tol, rtype])
    | Compute partial-fraction expansion of b(s) / a(s). |'
  prefs: []
  type: TYPE_TB
- en: '| [`residuez`](generated/scipy.signal.residuez.html#scipy.signal.residuez "scipy.signal.residuez")(b, a[, tol, rtype])
    | Compute partial-fraction expansion of b(z) / a(z). |'
  prefs: []
  type: TYPE_TB
- en: '| [`invres`](generated/scipy.signal.invres.html#scipy.signal.invres "scipy.signal.invres")(r, p, k[, tol, rtype])
    | Compute b(s) and a(s) from partial fraction expansion. |'
  prefs: []
  type: TYPE_TB
- en: '| [`invresz`](generated/scipy.signal.invresz.html#scipy.signal.invresz "scipy.signal.invresz")(r, p, k[, tol, rtype])
    | Compute b(z) and a(z) from partial fraction expansion. |'
  prefs: []
  type: TYPE_TB
- en: '| [`BadCoefficients`](generated/scipy.signal.BadCoefficients.html#scipy.signal.BadCoefficients
    "scipy.signal.BadCoefficients") | Warning about badly conditioned filter coefficients
    |'
  prefs: []
  type: TYPE_TB
- en: 'Lower-level filter design functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`abcd_normalize`](generated/scipy.signal.abcd_normalize.html#scipy.signal.abcd_normalize
    "scipy.signal.abcd_normalize")([A, B, C, D]) | Check state-space matrices and
    ensure they are 2-D. |'
  prefs: []
  type: TYPE_TB
- en: '| [`band_stop_obj`](generated/scipy.signal.band_stop_obj.html#scipy.signal.band_stop_obj
    "scipy.signal.band_stop_obj")(wp, ind, passb, stopb, gpass, ...) | Band Stop Objective
    Function for order minimization. |'
  prefs: []
  type: TYPE_TB
- en: '| [`besselap`](generated/scipy.signal.besselap.html#scipy.signal.besselap "scipy.signal.besselap")(N[, norm])
    | Return (z,p,k) for analog prototype of an Nth-order Bessel filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`buttap`](generated/scipy.signal.buttap.html#scipy.signal.buttap "scipy.signal.buttap")(N)
    | Return (z,p,k) for analog prototype of Nth-order Butterworth filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheb1ap`](generated/scipy.signal.cheb1ap.html#scipy.signal.cheb1ap "scipy.signal.cheb1ap")(N, rp)
    | Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheb2ap`](generated/scipy.signal.cheb2ap.html#scipy.signal.cheb2ap "scipy.signal.cheb2ap")(N, rs)
    | Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cmplx_sort`](generated/scipy.signal.cmplx_sort.html#scipy.signal.cmplx_sort
    "scipy.signal.cmplx_sort")(p) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`ellipap`](generated/scipy.signal.ellipap.html#scipy.signal.ellipap "scipy.signal.ellipap")(N, rp, rs)
    | Return (z,p,k) of Nth-order elliptic analog lowpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2bp`](generated/scipy.signal.lp2bp.html#scipy.signal.lp2bp "scipy.signal.lp2bp")(b, a[, wo, bw])
    | Transform a lowpass filter prototype to a bandpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2bp_zpk`](generated/scipy.signal.lp2bp_zpk.html#scipy.signal.lp2bp_zpk
    "scipy.signal.lp2bp_zpk")(z, p, k[, wo, bw]) | Transform a lowpass filter prototype
    to a bandpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2bs`](generated/scipy.signal.lp2bs.html#scipy.signal.lp2bs "scipy.signal.lp2bs")(b, a[, wo, bw])
    | Transform a lowpass filter prototype to a bandstop filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2bs_zpk`](generated/scipy.signal.lp2bs_zpk.html#scipy.signal.lp2bs_zpk
    "scipy.signal.lp2bs_zpk")(z, p, k[, wo, bw]) | Transform a lowpass filter prototype
    to a bandstop filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2hp`](generated/scipy.signal.lp2hp.html#scipy.signal.lp2hp "scipy.signal.lp2hp")(b, a[, wo])
    | Transform a lowpass filter prototype to a highpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2hp_zpk`](generated/scipy.signal.lp2hp_zpk.html#scipy.signal.lp2hp_zpk
    "scipy.signal.lp2hp_zpk")(z, p, k[, wo]) | Transform a lowpass filter prototype
    to a highpass filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2lp`](generated/scipy.signal.lp2lp.html#scipy.signal.lp2lp "scipy.signal.lp2lp")(b, a[, wo])
    | Transform a lowpass filter prototype to a different frequency. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lp2lp_zpk`](generated/scipy.signal.lp2lp_zpk.html#scipy.signal.lp2lp_zpk
    "scipy.signal.lp2lp_zpk")(z, p, k[, wo]) | Transform a lowpass filter prototype
    to a different frequency. |'
  prefs: []
  type: TYPE_TB
- en: '| [`normalize`](generated/scipy.signal.normalize.html#scipy.signal.normalize
    "scipy.signal.normalize")(b, a) | Normalize numerator/denominator of a continuous-time
    transfer function. |'
  prefs: []
  type: TYPE_TB
- en: Matlab-style IIR filter design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`butter`](generated/scipy.signal.butter.html#scipy.signal.butter "scipy.signal.butter")(N, Wn[, btype, analog, output, fs])
    | Butterworth digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`buttord`](generated/scipy.signal.buttord.html#scipy.signal.buttord "scipy.signal.buttord")(wp, ws, gpass, gstop[, analog, fs])
    | Butterworth filter order selection. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheby1`](generated/scipy.signal.cheby1.html#scipy.signal.cheby1 "scipy.signal.cheby1")(N, rp, Wn[, btype, analog, output, fs])
    | Chebyshev type I digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheb1ord`](generated/scipy.signal.cheb1ord.html#scipy.signal.cheb1ord "scipy.signal.cheb1ord")(wp, ws, gpass, gstop[, analog, fs])
    | Chebyshev type I filter order selection. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheby2`](generated/scipy.signal.cheby2.html#scipy.signal.cheby2 "scipy.signal.cheby2")(N, rs, Wn[, btype, analog, output, fs])
    | Chebyshev type II digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`cheb2ord`](generated/scipy.signal.cheb2ord.html#scipy.signal.cheb2ord "scipy.signal.cheb2ord")(wp, ws, gpass, gstop[, analog, fs])
    | Chebyshev type II filter order selection. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ellip`](generated/scipy.signal.ellip.html#scipy.signal.ellip "scipy.signal.ellip")(N, rp, rs, Wn[, btype, analog, output, fs])
    | Elliptic (Cauer) digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ellipord`](generated/scipy.signal.ellipord.html#scipy.signal.ellipord "scipy.signal.ellipord")(wp, ws, gpass, gstop[, analog, fs])
    | Elliptic (Cauer) filter order selection. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bessel`](generated/scipy.signal.bessel.html#scipy.signal.bessel "scipy.signal.bessel")(N, Wn[, btype, analog, output, norm, fs])
    | Bessel/Thomson digital and analog filter design. |'
  prefs: []
  type: TYPE_TB
- en: '| [`iirnotch`](generated/scipy.signal.iirnotch.html#scipy.signal.iirnotch "scipy.signal.iirnotch")(w0, Q[, fs])
    | Design second-order IIR notch digital filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`iirpeak`](generated/scipy.signal.iirpeak.html#scipy.signal.iirpeak "scipy.signal.iirpeak")(w0, Q[, fs])
    | Design second-order IIR peak (resonant) digital filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`iircomb`](generated/scipy.signal.iircomb.html#scipy.signal.iircomb "scipy.signal.iircomb")(w0, Q[, ftype, fs, pass_zero])
    | Design IIR notching or peaking digital comb filter. |'
  prefs: []
  type: TYPE_TB
- en: Continuous-time linear systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`lti`](generated/scipy.signal.lti.html#scipy.signal.lti "scipy.signal.lti")(*system)
    | Continuous-time linear time invariant system base class. |'
  prefs: []
  type: TYPE_TB
- en: '| [`StateSpace`](generated/scipy.signal.StateSpace.html#scipy.signal.StateSpace
    "scipy.signal.StateSpace")(*system, **kwargs) | Linear Time Invariant system in
    state-space form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`TransferFunction`](generated/scipy.signal.TransferFunction.html#scipy.signal.TransferFunction
    "scipy.signal.TransferFunction")(*system, **kwargs) | Linear Time Invariant system
    class in transfer function form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ZerosPolesGain`](generated/scipy.signal.ZerosPolesGain.html#scipy.signal.ZerosPolesGain
    "scipy.signal.ZerosPolesGain")(*system, **kwargs) | Linear Time Invariant system
    class in zeros, poles, gain form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lsim`](generated/scipy.signal.lsim.html#scipy.signal.lsim "scipy.signal.lsim")(system, U, T[, X0, interp])
    | Simulate output of a continuous-time linear system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lsim2`](generated/scipy.signal.lsim2.html#scipy.signal.lsim2 "scipy.signal.lsim2")(system[, U, T, X0])
    | Simulate output of a continuous-time linear system, by using the ODE solver
    [`scipy.integrate.odeint`](generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`impulse`](generated/scipy.signal.impulse.html#scipy.signal.impulse "scipy.signal.impulse")(system[, X0, T, N])
    | Impulse response of continuous-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`impulse2`](generated/scipy.signal.impulse2.html#scipy.signal.impulse2 "scipy.signal.impulse2")(system[, X0, T, N])
    | Impulse response of a single-input, continuous-time linear system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`step`](generated/scipy.signal.step.html#scipy.signal.step "scipy.signal.step")(system[, X0, T, N])
    | Step response of continuous-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`step2`](generated/scipy.signal.step2.html#scipy.signal.step2 "scipy.signal.step2")(system[, X0, T, N])
    | Step response of continuous-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`freqresp`](generated/scipy.signal.freqresp.html#scipy.signal.freqresp "scipy.signal.freqresp")(system[, w, n])
    | Calculate the frequency response of a continuous-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bode`](generated/scipy.signal.bode.html#scipy.signal.bode "scipy.signal.bode")(system[, w, n])
    | Calculate Bode magnitude and phase data of a continuous-time system. |'
  prefs: []
  type: TYPE_TB
- en: Discrete-time linear systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`dlti`](generated/scipy.signal.dlti.html#scipy.signal.dlti "scipy.signal.dlti")(*system, **kwargs)
    | Discrete-time linear time invariant system base class. |'
  prefs: []
  type: TYPE_TB
- en: '| [`StateSpace`](generated/scipy.signal.StateSpace.html#scipy.signal.StateSpace
    "scipy.signal.StateSpace")(*system, **kwargs) | Linear Time Invariant system in
    state-space form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`TransferFunction`](generated/scipy.signal.TransferFunction.html#scipy.signal.TransferFunction
    "scipy.signal.TransferFunction")(*system, **kwargs) | Linear Time Invariant system
    class in transfer function form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ZerosPolesGain`](generated/scipy.signal.ZerosPolesGain.html#scipy.signal.ZerosPolesGain
    "scipy.signal.ZerosPolesGain")(*system, **kwargs) | Linear Time Invariant system
    class in zeros, poles, gain form. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dlsim`](generated/scipy.signal.dlsim.html#scipy.signal.dlsim "scipy.signal.dlsim")(system, u[, t, x0])
    | Simulate output of a discrete-time linear system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dimpulse`](generated/scipy.signal.dimpulse.html#scipy.signal.dimpulse "scipy.signal.dimpulse")(system[, x0, t, n])
    | Impulse response of discrete-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dstep`](generated/scipy.signal.dstep.html#scipy.signal.dstep "scipy.signal.dstep")(system[, x0, t, n])
    | Step response of discrete-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dfreqresp`](generated/scipy.signal.dfreqresp.html#scipy.signal.dfreqresp
    "scipy.signal.dfreqresp")(system[, w, n, whole]) | Calculate the frequency response
    of a discrete-time system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dbode`](generated/scipy.signal.dbode.html#scipy.signal.dbode "scipy.signal.dbode")(system[, w, n])
    | Calculate Bode magnitude and phase data of a discrete-time system. |'
  prefs: []
  type: TYPE_TB
- en: LTI representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`tf2zpk`](generated/scipy.signal.tf2zpk.html#scipy.signal.tf2zpk "scipy.signal.tf2zpk")(b, a)
    | Return zero, pole, gain (z, p, k) representation from a numerator, denominator
    representation of a linear filter. |'
  prefs: []
  type: TYPE_TB
- en: '| [`tf2sos`](generated/scipy.signal.tf2sos.html#scipy.signal.tf2sos "scipy.signal.tf2sos")(b, a[, pairing, analog])
    | Return second-order sections from transfer function representation |'
  prefs: []
  type: TYPE_TB
- en: '| [`tf2ss`](generated/scipy.signal.tf2ss.html#scipy.signal.tf2ss "scipy.signal.tf2ss")(num, den)
    | Transfer function to state-space representation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`zpk2tf`](generated/scipy.signal.zpk2tf.html#scipy.signal.zpk2tf "scipy.signal.zpk2tf")(z, p, k)
    | Return polynomial transfer function representation from zeros and poles |'
  prefs: []
  type: TYPE_TB
- en: '| [`zpk2sos`](generated/scipy.signal.zpk2sos.html#scipy.signal.zpk2sos "scipy.signal.zpk2sos")(z, p, k[, pairing, analog])
    | Return second-order sections from zeros, poles, and gain of a system |'
  prefs: []
  type: TYPE_TB
- en: '| [`zpk2ss`](generated/scipy.signal.zpk2ss.html#scipy.signal.zpk2ss "scipy.signal.zpk2ss")(z, p, k)
    | Zero-pole-gain representation to state-space representation |'
  prefs: []
  type: TYPE_TB
- en: '| [`ss2tf`](generated/scipy.signal.ss2tf.html#scipy.signal.ss2tf "scipy.signal.ss2tf")(A, B, C, D[, input])
    | State-space to transfer function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ss2zpk`](generated/scipy.signal.ss2zpk.html#scipy.signal.ss2zpk "scipy.signal.ss2zpk")(A, B, C, D[, input])
    | State-space representation to zero-pole-gain representation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sos2zpk`](generated/scipy.signal.sos2zpk.html#scipy.signal.sos2zpk "scipy.signal.sos2zpk")(sos)
    | Return zeros, poles, and gain of a series of second-order sections |'
  prefs: []
  type: TYPE_TB
- en: '| [`sos2tf`](generated/scipy.signal.sos2tf.html#scipy.signal.sos2tf "scipy.signal.sos2tf")(sos)
    | Return a single transfer function from a series of second-order sections |'
  prefs: []
  type: TYPE_TB
- en: '| [`cont2discrete`](generated/scipy.signal.cont2discrete.html#scipy.signal.cont2discrete
    "scipy.signal.cont2discrete")(system, dt[, method, alpha]) | Transform a continuous
    to a discrete state-space system. |'
  prefs: []
  type: TYPE_TB
- en: '| [`place_poles`](generated/scipy.signal.place_poles.html#scipy.signal.place_poles
    "scipy.signal.place_poles")(A, B, poles[, method, rtol, maxiter]) | Compute K
    such that eigenvalues (A - dot(B, K))=poles. |'
  prefs: []
  type: TYPE_TB
- en: Waveforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`chirp`](generated/scipy.signal.chirp.html#scipy.signal.chirp "scipy.signal.chirp")(t, f0, t1, f1[, method, phi, vertex_zero])
    | Frequency-swept cosine generator. |'
  prefs: []
  type: TYPE_TB
- en: '| [`gausspulse`](generated/scipy.signal.gausspulse.html#scipy.signal.gausspulse
    "scipy.signal.gausspulse")(t[, fc, bw, bwr, tpr, retquad, ...]) | Return a Gaussian
    modulated sinusoid: |'
  prefs: []
  type: TYPE_TB
- en: '| [`max_len_seq`](generated/scipy.signal.max_len_seq.html#scipy.signal.max_len_seq
    "scipy.signal.max_len_seq")(nbits[, state, length, taps]) | Maximum length sequence
    (MLS) generator. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sawtooth`](generated/scipy.signal.sawtooth.html#scipy.signal.sawtooth "scipy.signal.sawtooth")(t[, width])
    | Return a periodic sawtooth or triangle waveform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`square`](generated/scipy.signal.square.html#scipy.signal.square "scipy.signal.square")(t[, duty])
    | Return a periodic square-wave waveform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sweep_poly`](generated/scipy.signal.sweep_poly.html#scipy.signal.sweep_poly
    "scipy.signal.sweep_poly")(t, poly[, phi]) | Frequency-swept cosine generator,
    with a time-dependent frequency. |'
  prefs: []
  type: TYPE_TB
- en: '| [`unit_impulse`](generated/scipy.signal.unit_impulse.html#scipy.signal.unit_impulse
    "scipy.signal.unit_impulse")(shape[, idx, dtype]) | Unit impulse signal (discrete
    delta function) or unit basis vector. |'
  prefs: []
  type: TYPE_TB
- en: Window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For window functions, see the [`scipy.signal.windows`](signal.windows.html#module-scipy.signal.windows
    "scipy.signal.windows") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [`scipy.signal`](#module-scipy.signal "scipy.signal") namespace, there
    is a convenience function to obtain these windows by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`get_window`](generated/scipy.signal.get_window.html#scipy.signal.get_window
    "scipy.signal.get_window")(window, Nx[, fftbins]) | Return a window of a given
    length and type. |'
  prefs: []
  type: TYPE_TB
- en: Wavelets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`cascade`](generated/scipy.signal.cascade.html#scipy.signal.cascade "scipy.signal.cascade")(hk[, J])
    | Return (x, phi, psi) at dyadic points `K/2**J` from filter coefficients. |'
  prefs: []
  type: TYPE_TB
- en: '| [`daub`](generated/scipy.signal.daub.html#scipy.signal.daub "scipy.signal.daub")(p)
    | The coefficients for the FIR low-pass filter producing Daubechies wavelets.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`morlet`](generated/scipy.signal.morlet.html#scipy.signal.morlet "scipy.signal.morlet")(M[, w, s, complete])
    | Complex Morlet wavelet. |'
  prefs: []
  type: TYPE_TB
- en: '| [`qmf`](generated/scipy.signal.qmf.html#scipy.signal.qmf "scipy.signal.qmf")(hk)
    | Return high-pass qmf filter from low-pass |'
  prefs: []
  type: TYPE_TB
- en: '| [`ricker`](generated/scipy.signal.ricker.html#scipy.signal.ricker "scipy.signal.ricker")(points, a)
    | Return a Ricker wavelet, also known as the "Mexican hat wavelet". |'
  prefs: []
  type: TYPE_TB
- en: '| [`morlet2`](generated/scipy.signal.morlet2.html#scipy.signal.morlet2 "scipy.signal.morlet2")(M, s[, w])
    | Complex Morlet wavelet, designed to work with [`cwt`](generated/scipy.signal.cwt.html#scipy.signal.cwt
    "scipy.signal.cwt"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`cwt`](generated/scipy.signal.cwt.html#scipy.signal.cwt "scipy.signal.cwt")(data, wavelet, widths[, dtype])
    | Continuous wavelet transform. |'
  prefs: []
  type: TYPE_TB
- en: Peak finding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`argrelmin`](generated/scipy.signal.argrelmin.html#scipy.signal.argrelmin
    "scipy.signal.argrelmin")(data[, axis, order, mode]) | Calculate the relative
    minima of *data*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`argrelmax`](generated/scipy.signal.argrelmax.html#scipy.signal.argrelmax
    "scipy.signal.argrelmax")(data[, axis, order, mode]) | Calculate the relative
    maxima of *data*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`argrelextrema`](generated/scipy.signal.argrelextrema.html#scipy.signal.argrelextrema
    "scipy.signal.argrelextrema")(data, comparator[, axis, ...]) | Calculate the relative
    extrema of *data*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`find_peaks`](generated/scipy.signal.find_peaks.html#scipy.signal.find_peaks
    "scipy.signal.find_peaks")(x[, height, threshold, distance, ...]) | Find peaks
    inside a signal based on peak properties. |'
  prefs: []
  type: TYPE_TB
- en: '| [`find_peaks_cwt`](generated/scipy.signal.find_peaks_cwt.html#scipy.signal.find_peaks_cwt
    "scipy.signal.find_peaks_cwt")(vector, widths[, wavelet, ...]) | Find peaks in
    a 1-D array with wavelet transformation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`peak_prominences`](generated/scipy.signal.peak_prominences.html#scipy.signal.peak_prominences
    "scipy.signal.peak_prominences")(x, peaks[, wlen]) | Calculate the prominence
    of each peak in a signal. |'
  prefs: []
  type: TYPE_TB
- en: '| [`peak_widths`](generated/scipy.signal.peak_widths.html#scipy.signal.peak_widths
    "scipy.signal.peak_widths")(x, peaks[, rel_height, ...]) | Calculate the width
    of each peak in a signal. |'
  prefs: []
  type: TYPE_TB
- en: Spectral analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`periodogram`](generated/scipy.signal.periodogram.html#scipy.signal.periodogram
    "scipy.signal.periodogram")(x[, fs, window, nfft, detrend, ...]) | Estimate power
    spectral density using a periodogram. |'
  prefs: []
  type: TYPE_TB
- en: '| [`welch`](generated/scipy.signal.welch.html#scipy.signal.welch "scipy.signal.welch")(x[, fs, window, nperseg, noverlap, ...])
    | Estimate power spectral density using Welch''s method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`csd`](generated/scipy.signal.csd.html#scipy.signal.csd "scipy.signal.csd")(x, y[, fs, window, nperseg, noverlap, ...])
    | Estimate the cross power spectral density, Pxy, using Welch''s method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`coherence`](generated/scipy.signal.coherence.html#scipy.signal.coherence
    "scipy.signal.coherence")(x, y[, fs, window, nperseg, ...]) | Estimate the magnitude
    squared coherence estimate, Cxy, of discrete-time signals X and Y using Welch''s
    method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`spectrogram`](generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram
    "scipy.signal.spectrogram")(x[, fs, window, nperseg, ...]) | Compute a spectrogram
    with consecutive Fourier transforms. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lombscargle`](generated/scipy.signal.lombscargle.html#scipy.signal.lombscargle
    "scipy.signal.lombscargle")(x, y, freqs) | Computes the Lomb-Scargle periodogram.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`vectorstrength`](generated/scipy.signal.vectorstrength.html#scipy.signal.vectorstrength
    "scipy.signal.vectorstrength")(events, period) | Determine the vector strength
    of the events corresponding to the given period. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ShortTimeFFT`](generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT
    "scipy.signal.ShortTimeFFT")(win, hop, fs, *[, fft_mode, ...]) | Provide a parametrized
    discrete Short-time Fourier transform (stft) and its inverse (istft). |'
  prefs: []
  type: TYPE_TB
- en: '| [`stft`](generated/scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft")(x[, fs, window, nperseg, noverlap, ...])
    | Compute the Short Time Fourier Transform (STFT). |'
  prefs: []
  type: TYPE_TB
- en: '| [`istft`](generated/scipy.signal.istft.html#scipy.signal.istft "scipy.signal.istft")(Zxx[, fs, window, nperseg, noverlap, ...])
    | Perform the inverse Short Time Fourier transform (iSTFT). |'
  prefs: []
  type: TYPE_TB
- en: '| [`check_COLA`](generated/scipy.signal.check_COLA.html#scipy.signal.check_COLA
    "scipy.signal.check_COLA")(window, nperseg, noverlap[, tol]) | Check whether the
    Constant OverLap Add (COLA) constraint is met. |'
  prefs: []
  type: TYPE_TB
- en: '| [`check_NOLA`](generated/scipy.signal.check_NOLA.html#scipy.signal.check_NOLA
    "scipy.signal.check_NOLA")(window, nperseg, noverlap[, tol]) | Check whether the
    Nonzero Overlap Add (NOLA) constraint is met. |'
  prefs: []
  type: TYPE_TB
- en: Chirp Z-transform and Zoom FFT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`czt`](generated/czt-function.html#scipy.signal.czt "scipy.signal.czt")(x[, m, w, a, axis])
    | Compute the frequency response around a spiral in the Z plane. |'
  prefs: []
  type: TYPE_TB
- en: '| [`zoom_fft`](generated/scipy.signal.zoom_fft.html#scipy.signal.zoom_fft "scipy.signal.zoom_fft")(x, fn[, m, fs, endpoint, axis])
    | Compute the DFT of *x* only for frequencies in range *fn*. |'
  prefs: []
  type: TYPE_TB
- en: '| [`CZT`](generated/scipy.signal.CZT.html#scipy.signal.CZT "scipy.signal.CZT")(n[, m, w, a])
    | Create a callable chirp z-transform function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ZoomFFT`](generated/scipy.signal.ZoomFFT.html#scipy.signal.ZoomFFT "scipy.signal.ZoomFFT")(n, fn[, m, fs, endpoint])
    | Create a callable zoom FFT transform function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`czt_points`](generated/scipy.signal.czt_points.html#scipy.signal.czt_points
    "scipy.signal.czt_points")(m[, w, a]) | Return the points at which the chirp z-transform
    is computed. |'
  prefs: []
  type: TYPE_TB
- en: The functions are simpler to use than the classes, but are less efficient when
    using the same transform on many arrays of the same length, since they repeatedly
    generate the same chirp signal with every call. In these cases, use the classes
    to create a reusable function instead.
  prefs: []
  type: TYPE_NORMAL
