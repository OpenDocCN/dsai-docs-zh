- en: Writing Custom Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义函数
- en: Original text：[https://docs.sympy.org/latest/guides/custom-functions.html](https://docs.sympy.org/latest/guides/custom-functions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://docs.sympy.org/latest/guides/custom-functions.html](https://docs.sympy.org/latest/guides/custom-functions.html)'
- en: This guide will describe how to create custom function classes in SymPy. Custom
    user defined functions use the same mechanisms as the [functions](../modules/functions/index.html#functions)
    that are included with SymPy such as the common [elementary functions](../modules/functions/elementary.html#elementary-functions)
    like [`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp") or [`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin"), [special functions](../modules/functions/special.html#special-functions)
    like [`gamma()`](../modules/functions/special.html#sympy.functions.special.gamma_functions.gamma
    "sympy.functions.special.gamma_functions.gamma") or [`Si()`](../modules/functions/special.html#sympy.functions.special.error_functions.Si
    "sympy.functions.special.error_functions.Si"), and [combinatorial functions](../modules/functions/combinatorial.html#combinatorial-functions)
    and [number theory functions](../modules/ntheory.html#ntheory-module) like [`factorial()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.factorials.factorial
    "sympy.functions.combinatorial.factorials.factorial") or [`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi"). Consequently, this guide serves both as a guide
    to end users who want to define their own custom functions and to SymPy developers
    wishing to extend the functions included with SymPy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将描述如何在SymPy中创建自定义函数类。自定义用户定义函数使用与SymPy中包含的函数相同的机制，如[函数](../modules/functions/index.html#functions)中包含的常见[初等函数](../modules/functions/elementary.html#elementary-functions)，例如[`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp")或[`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin")，[特殊函数](../modules/functions/special.html#special-functions)如[`gamma()`](../modules/functions/special.html#sympy.functions.special.gamma_functions.gamma
    "sympy.functions.special.gamma_functions.gamma")或[`Si()`](../modules/functions/special.html#sympy.functions.special.error_functions.Si
    "sympy.functions.special.error_functions.Si")，以及[组合函数](../modules/functions/combinatorial.html#combinatorial-functions)和[数论函数](../modules/ntheory.html#ntheory-module)，如[`factorial()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.factorials.factorial
    "sympy.functions.combinatorial.factorials.factorial")或[`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi")。因此，本指南既是为希望定义自己自定义函数的最终用户提供指南，也是为希望扩展SymPy中包含的函数的SymPy开发人员提供指南。
- en: This guide describes how to define complex valued functions, that is functions
    that map a subset of \(\mathbb{C}^n\) to \(\mathbb{C}\). Functions that accept
    or return other kinds of objects than complex numbers should subclass another
    class, such as [`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean"),
    [`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr"), [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), or [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). Some of what is written here will apply to general
    [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    or [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    subclasses, but much of it only applies to [`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function") subclasses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南描述了如何定义复值函数，即将\(\mathbb{C}^n\)的子集映射到\(\mathbb{C}\)的函数。接受或返回复数以外对象的函数应该是另一个类的子类，比如[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean
    "sympy.logic.boolalg.Boolean")、[`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr")、[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")或[`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic")。这里写的一些内容适用于一般的[`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic")或[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")子类，但其中大部分仅适用于[`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function")子类。
- en: 'Easy Cases: Fully Symbolic or Fully Evaluated'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单情况：完全符号化或完全评估
- en: Before digging into the more advanced functionality for custom functions, we
    should mention two common cases, the case where the function is fully symbolic,
    and the case where the function is fully evaluated. Both of these cases have much
    simpler alternatives than the full mechanisms described in this guide.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究自定义函数的更高级功能之前，我们应该提到两种常见情况，一个是函数完全符号化的情况，另一个是函数完全评估的情况。这两种情况都有比本指南中描述的完整机制更简单的替代方法。
- en: '### The Fully Symbolic Case'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### 完全符号情况'
- en: If your function `f` has no mathematical properties you want to define on it,
    and should never evaluate on any arguments, you can create an undefined function
    using `Function('f')`
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的函数`f`没有您想要在其上定义的数学属性，并且不应在任何参数上进行评估，则可以使用`Function('f')`创建一个未定义的函数
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is useful, for instance, when solving [ODEs](../modules/solvers/ode.html#ode-docs).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这在解决[ODEs](../modules/solvers/ode.html#ode-docs)时非常有用。
- en: 'This is also useful if you only wish to create a symbol that depends on another
    symbol for the purposes of differentiation. By default, SymPy assumes all symbols
    are independent of one another:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只希望创建一个仅用于不同化目的依赖于另一个符号的符号，则这也是有用的。默认情况下，SymPy假设所有符号彼此独立：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To make a symbol that depends on another symbol, you can use a function that
    explicitly depends on that symbol.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个依赖于另一个符号的符号，您可以使用明确依赖于该符号的函数。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want your function to have additional behavior, for example, to have
    a custom derivative, or to evaluate on certain arguments, you should create a
    custom `Function` subclass as [described below](#custom-functions-function-subclass).
    However, undefined functions do support one additional feature, which is that
    assumptions can be defined on them, using the same syntax as used by symbols.
    This defines the assumptions of the output of the function, not the input (that
    is, it defines the function’s range, not its domain).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望函数具有其他行为，例如具有自定义导数或在某些参数上进行评估，则应创建一个自定义`Function`子类，如下所述。但是，未定义的函数确实支持一个附加功能，即可以使用与符号相同的语法来定义它们的假设。这定义了函数输出的假设，而不是输入（即定义了函数的范围，而不是定义其域）。
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make a function’s assumptions depend on its input in some way, you should
    create a custom `Function` subclass and define assumptions handlers as [described
    below](#custom-functions-assumptions).  ### The Fully Evaluated Case'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '要使函数的假设依赖于其输入方式，您应创建一个自定义的`Function`子类，并如下所述定义假设处理程序。 ### 完全评估情况'
- en: At the other end of the spectrum are functions that always evaluate to something
    no matter what their inputs are. These functions are never left in an unevaluated,
    symbolic form like `f(x)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端的函数是始终评估为某些内容的函数，无论其输入如何。这些函数从不以未评估的符号形式如`f(x)`留下。
- en: 'In this case, you should use a normal Python function using the `def` keyword:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您应该使用使用`def`关键字创建一个普通的Python函数：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you find yourself defining an [`eval()`](#custom-functions-eval) method on
    a `Function` subclass where you always return a value and never return `None`,
    you should consider just using a normal Python function instead, as there is no
    benefit to using a symbolic `Function` subclass in that case (see the [Best Practices
    for eval()](#custom-functions-eval-best-practices) section below)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己在`Function`子类上定义了一个[`eval()`](#custom-functions-eval)方法，其中您总是返回一个值，而不是返回`None`，那么考虑只是使用普通的Python函数，因为在这种情况下使用符号`Function`子类没有任何好处（参见下面的[eval()最佳实践](#custom-functions-eval-best-practices)部分）
- en: Note that in many cases, functions like these can be represented directly using
    SymPy classes. For example, the above function can be represented symbolically
    using [`Piecewise`](../modules/functions/elementary.html#sympy.functions.elementary.piecewise.Piecewise
    "sympy.functions.elementary.piecewise.Piecewise"). The `Piecewise` expression
    can be evaluated for specific values of `x` using [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在许多情况下，这些函数可以直接使用SymPy类表示。例如，上述函数可以使用[`Piecewise`](../modules/functions/elementary.html#sympy.functions.elementary.piecewise.Piecewise
    "sympy.functions.elementary.piecewise.Piecewise")进行符号表示。可以使用[`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs")对`Piecewise`表达式进行特定`x`值的评估。
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Fully symbolic representations like `Piecewise` have the advantage that they
    accurately represent symbolic values. For example, in the above Python `def` definition
    of `f`, `f(x)` implicitly assumes that `x` is nonzero. The `Piecewise` version
    handles this case correctly and won’t evaluate to the \(x \neq 0\) case unless
    `x` is known to not be zero.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `Piecewise` 这样的完全符号表示具有准确表示符号值的优势。例如，在上述 Python 的 `def` 定义 `f` 中，`f(x)` 隐式地假定
    `x` 是非零的。`Piecewise` 版本会正确处理这种情况，并且不会在 `x` 不为零时评估到 \(x \neq 0\) 的情况。
- en: Another option, if you want a function that not only evaluates, but always evaluates
    to a numerical value, is to use [`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify"). This will convert a SymPy expression into
    a function that can be evaluated using NumPy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望函数不仅进行评估，而且总是评估为数值，还有另一种选择，那就是使用[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")。这将把 SymPy 表达式转换为可以使用 NumPy 进行评估的函数。
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Ultimately, the correct tool for the job depends on what you are doing and
    what exact behavior you want.  ## Creating a Custom Function'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '最终，选择正确的工具取决于您要做什么以及您想要的确切行为。 ## 创建自定义函数'
- en: The first step to creating a custom function is to subclass [`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function"). The name of the subclass will be the name of
    the function. Different methods should then be defined on this subclass, depending
    on what functionality you want to provide.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义函数的第一步是子类化[`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function")。子类的名称将是函数的名称。然后，根据您想要提供的功能，应该在这个子类上定义不同的方法。
- en: As a motivating example for this document, let’s create a custom function class
    representing the [versine function](https://en.wikipedia.org/wiki/Versine). Versine
    is a trigonometric function which was used historically alongside some of the
    more familiar trigonometric functions like sine and cosine. It is rarely used
    today. Versine can be defined by the identity
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本文档的一个激励性例子，让我们创建一个表示[versine 函数](https://en.wikipedia.org/wiki/Versine)的自定义函数类。Versine
    是一个三角函数，历史上与更熟悉的正弦和余弦函数一起使用。今天很少使用。Versine 可以通过下面的恒等式来定义
- en: \[\operatorname{versin}(x) = 1 - \cos(x).\]
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: \[\operatorname{versin}(x) = 1 - \cos(x).\]
- en: SymPy does not already include versine because it is used so rarely in modern
    mathematics and because it is so easily defined in terms of the more familiar
    cosine.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 不包括 versine，因为它在现代数学中很少使用，而且可以很容易地用更熟悉的余弦来定义。
- en: Let us start by subclassing `Function`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从子类化 `Function` 开始。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, `versin` has no behaviors defined on it. It is very similar to
    the [undefined functions](#custom-functions-fully-symbolic) we discussed above.
    Note that `versin` is a class, and `versin(x)` is an instance of this class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`versin` 没有定义任何行为。它与我们上面讨论过的[未定义函数](#custom-functions-fully-symbolic)非常相似。请注意，`versin`
    是一个类，`versin(x)` 是这个类的一个实例。
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the methods described below are optional. They can be included if you want
    to define the given behavior, but if they are omitted, SymPy will default to leaving
    things unevaluated. For example, if you do not define [differentiation](#custom-functions-differentiation),
    [`diff()`](../modules/core.html#sympy.core.function.diff "sympy.core.function.diff")
    will just return an unevaluated [`Derivative`](../modules/core.html#sympy.core.function.Derivative
    "sympy.core.function.Derivative").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面描述的所有方法都是可选的。如果您希望定义特定的行为，可以包含它们，但如果省略它们，SymPy 将默认保持未评估状态。例如，如果您不定义[微分](#custom-functions-differentiation)，[`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff") 将只返回一个未评估的[`Derivative`](../modules/core.html#sympy.core.function.Derivative
    "sympy.core.function.Derivative")。
- en: '### Defining Automatic Evaluation with `eval()`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 `eval()` 定义自动评估'
- en: The first and most common thing we might want to define on our custom function
    is automatic evaluation, that is, the cases where it will return an actual value
    instead of just remaining unevaluated as-is.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在自定义函数上定义的第一件事情是自动评估，即在返回实际值而不是保持未评估状态时的情况。
- en: This is done by defining the class method `eval()`. `eval()` should take the
    arguments of the function and return either a value or `None`. If it returns `None`,
    the function will remain unevaluated in that case. This also serves to define
    the signature of the function (by default, without an `eval()` method, a `Function`
    subclass will accept any number of arguments).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过定义类方法`eval()`完成的。`eval()`应该接受函数的参数并返回一个值或`None`。如果返回`None`，则函数在那种情况下将保持未评估状态。这也有助于定义函数的签名（默认情况下，没有`eval()`方法，`Function`子类将接受任意数量的参数）。
- en: 'For our function `versin`, we might recall that \(\cos(n\pi) = (-1)^n\) for
    integer \(n\), so \(\operatorname{versin}(n\pi) = 1 - (-1)^n.\) We can make `versin`
    automatically evaluate to this value when passed an integer multiple of `pi`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的函数`versin`，我们可能会回忆起当整数`n`时，\(\cos(n\pi) = (-1)^n\)，因此\(\operatorname{versin}(n\pi)
    = 1 - (-1)^n.\) 当传递整数倍的`pi`时，我们可以使`versin`自动评估为这个值：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we make use of the fact that if a Python function does not explicitly return
    a value, it automatically returns `None`. So in the cases where the `if isinstance(n,
    Integer)` statement is not triggered, `eval()` returns `None` and `versin` remains
    unevaluated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了Python函数如果没有显式返回值，则自动返回`None`的事实。因此，在未触发`if isinstance(n, Integer)`语句的情况下，`eval()`返回`None`，并且`versin`保持未评估状态。
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Function` subclasses should not redefine `__new__` or `__init__`. If you want
    to implement behavior that isn’t possible with `eval()`, it might make more sense
    to subclass [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    rather than `Function`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`子类不应重新定义`__new__`或`__init__`。如果要实现`eval()`无法实现的行为，可能更合理的是子类化[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")而不是`Function`。'
- en: '`eval()` can take any number of arguments, including an arbitrary number with
    `*args` and optional keyword arguments. The `.args` of the function will always
    be the arguments that were passed in by the user. For example'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`可以接受任意数量的参数，包括带有`*args`和可选关键字参数的任意数量。函数的`.args`始终是用户传入的参数。例如'
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, note that automatic evaluation on floating-point inputs happens automatically
    once [`evalf()` is defined](#custom-functions-evalf), so you do not need to handle
    it explicitly in `eval()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，一旦定义了[`evalf()`](#custom-functions-evalf)，浮点输入的自动评估就会自动发生，因此你不需要在`eval()`中显式处理它。
- en: '#### Best Practices for `eval()`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `eval()`的最佳实践'
- en: Certain antipatterns are common when defining `eval()` methods and should be
    avoided.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`eval()`方法时，存在一些常见的反模式，应该避免。
- en: '**Don’t just return an expression.**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要只返回表达式。**'
- en: In the above example, we might have been tempted to write
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可能会被诱惑写
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, this would make it so that `versin(x)` would *always* return `1 - cos(x)`,
    regardless of what `x` is. If all you want is a quick shorthand to `1 - cos(x)`,
    that is fine, but would be much simpler and more explicit to just [use a Python
    function as described above](#custom-functions-fully-evaluated). If we defined
    `versin` like this, it would never actually be represented as `versin(x)`, and
    none of the other behavior we define below would matter, because the other behaviors
    we are going to define on the `versin` class only apply when the returned object
    is actually a `versin` instance. So for example, `versin(x).diff(x)` would actually
    just be `(1 - cos(x)).diff(x)`, instead of calling [the `fdiff()` method we define
    below](#custom-functions-differentiation).
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这将导致`versin(x)`始终返回`1 - cos(x)`，无论`x`是什么。如果你只想要一个快捷方式到`1 - cos(x)`，那没问题，但是更简单和更明确的方法是[像上面描述的使用Python函数](#custom-functions-fully-evaluated)。如果我们像这样定义`versin`，它实际上永远不会表示为`versin(x)`，并且我们在`versin`类下面定义的任何其他行为都不会起作用，因为只有当返回的对象实际上是`versin`实例时，我们定义的其他行为才适用。例如，`versin(x).diff(x)`实际上只是`(1
    - cos(x)).diff(x)`，而不是调用我们在下面定义的[fdiff()方法](#custom-functions-differentiation)。
- en: Key Point
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关键点
- en: '**The purpose of `eval()` is not to define what the function *is*, mathematically,
    but rather to specify on what inputs it should automatically evaluate.** The mathematical
    definition of a function is determined through the specification of various mathematical
    properties with the methods outlined below, like [numerical evaluation](#custom-functions-evalf),
    [differentiation](#custom-functions-differentiation), and so on.'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**`eval()`的目的不是数学上定义函数是什么，而是指定在哪些输入下它应该自动评估。** 函数的数学定义是通过下面概述的各种数学属性的规范来确定的，比如[numerical
    evaluation](#custom-functions-evalf)，[differentiation](#custom-functions-differentiation)等方法。'
- en: If you find yourself doing this, you should think about what you actually want
    to achieve. If you just want a shorthand function for an expression, it will be
    simpler to just [define a Python function](#custom-functions-fully-evaluated).
    If you really do want a symbolic function, think about when you want it to evaluate
    to something else and when you want it to stay unevaluated. One option is to make
    your function unevaluated in `eval()` and define a [`doit()` method](#custom-functions-doit)
    to evaluate it.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你发现自己在这样做，请考虑你实际想要达到的目标。如果你只想为一个表达式定义一个简短的函数，最简单的方法就是[定义一个 Python 函数](#custom-functions-fully-evaluated)。如果你真的想要一个符号函数，想一想你希望它在什么时候评估为其他值，以及什么时候保持不变。一种选择是在`eval()`中使你的函数保持未评估状态，并定义一个[`doit()`方法](#custom-functions-doit)来评估它。
- en: '**Avoid too much automatic evaluation.**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免过多的自动评估。**'
- en: It is recommended to minimize what is evaluated automatically by `eval()`. It
    is typically better to put more advanced simplifications in [other methods](#custom-functions-rewriting-and-simplification),
    like [`doit()`](#custom-functions-doit). Remember that whatever you define for
    automatic evaluation will *always* evaluate.[[1]](#evaluate-footnote) As in the
    previous point, if you evaluate every value, there is little point to even having
    a symbolic function in the first place. For example, we might be tempted to evaluate
    some trig identities on `versin` in `eval()`, but then these identities would
    always evaluate, and it wouldn’t be possible to represent one half of the identity.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议最小化`eval()`自动评估的内容。通常最好将更高级的简化放在[其他方法中](#custom-functions-rewriting-and-simplification)，如[`doit()`](#custom-functions-doit)。记住，无论你为自动评估定义什么，它都*总是*会进行评估。[[1]](#evaluate-footnote)
    如前一点所述，如果你评估每个值，那么首先拥有符号函数就没有多大意义。例如，我们可能会试图在`eval()`中对`versin`进行一些三角恒等式的评估，但这些恒等式将始终被评估，并且无法表示恒等式的一半。
- en: One should also avoid doing anything in `eval()` that is slow to compute. SymPy
    generally assumes that it is cheap to create expressions, and if this is not true,
    it can lead to performance issues.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还应避免在`eval()`中执行计算速度慢的操作。SymPy通常假设创建表达式是廉价的，如果不是这样，可能会导致性能问题。
- en: Finally, it is recommended to avoid performing automatic evaluation in `eval()`
    based on assumptions. Instead, `eval()` should typically only evaluate explicit
    numerical special values and return `None` for everything else. You might have
    noticed in [the example above](#custom-functions-versin-eval-example) that we
    used `isinstance(n, Integer)` instead of checking `n.is_integer` using the assumptions
    system. We could have done that instead, which would make `versin(n*pi)` evaluate
    even if `n = Symbol('n', integer=True)`. But this is a case where we might not
    always want evaluation to happen, and if `n` is a more complicated expression,
    `n.is_integer` might be more expensive to compute.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，建议避免根据假设在`eval()`中进行自动评估。相反，`eval()`通常只评估显式的数值特定值，并对其他情况返回`None`。你可能已经注意到在[上面的例子中](#custom-functions-versin-eval-example)我们使用了`isinstance(n,
    Integer)`而不是使用假设系统检查`n.is_integer`。我们本可以这样做，这样`versin(n*pi)`会被评估，即使`n = Symbol('n',
    integer=True)`。但这是一个情况，我们可能并不总是希望发生评估，如果`n`是一个更复杂的表达式，使用`n.is_integer`可能计算代价更高。
- en: Let’s consider an example. Using the identity \(\cos(x + y) = \cos(x)\cos(y)
    - \sin(x)\sin(y)\), we can derive the identity
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑一个例子。使用恒等式 \(\cos(x + y) = \cos(x)\cos(y) - \sin(x)\sin(y)\)，我们可以推导出以下恒等式
- en: \[\operatorname{versin}(x + y) = \operatorname{versin}(x)\operatorname{versin}(y)
    - \operatorname{versin}(x) - \operatorname{versin}(y) - \sin(x)\sin(y) + 1.\]
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[\operatorname{versin}(x + y) = \operatorname{versin}(x)\operatorname{versin}(y)
    - \operatorname{versin}(x) - \operatorname{versin}(y) - \sin(x)\sin(y) + 1.\]
- en: 'Suppose we decided to automatically expand this in `eval()`:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们决定在`eval()`中自动展开这个：
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method recursively splits `Add` terms into two parts and applies the above
    identity.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法递归地将`Add`项分为两部分，并应用上述恒等式。
- en: '[PRE20]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But now it’s impossible to represent `versin(x + y)` without it expanding.
    This will affect other methods too. For example, suppose we define [differentiation
    (see below)](#custom-functions-differentiation):'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但现在无法表示`versin(x + y)`而不进行展开。这也会影响其他方法。例如，假设我们定义了[微分（见下文）](#custom-functions-differentiation)：
- en: '[PRE21]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We would expect `versin(x + y).diff(x)` to return `sin(x + y)`, and indeed,
    if we hadn’t expanded this identity in `eval()`, [it would](#custom-functions-differentiation-examples).
    But with this version, `versin(x + y)` gets automatically expanded before `diff()`
    gets called, instead we get a more complicated expression:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们期望`versin(x + y).diff(x)`返回`sin(x + y)`，确实，如果我们没有在`eval()`中展开这个身份，[它会](#custom-functions-differentiation-examples)。但使用这个版本，`versin(x
    + y)`在调用`diff()`之前会自动展开，因此我们得到一个更复杂的表达式：
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And things are even worse than that. Let’s try an `Add` with three terms:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事情甚至比那更糟。让我们尝试一个有三项的`Add`：
- en: '[PRE23]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that things are getting out of control quite quickly. In fact, `versin(Add(*symbols('x:100')))`
    (`versin()` on an `Add` with 100 terms) takes over a second to evaluate, and that’s
    just to *create* the expression, without even doing anything with it yet.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到事情很快就变得失控。实际上，`versin(Add(*symbols('x:100')))`（在具有100个项的`Add`上的`versin()`）需要超过一秒的时间来评估，而这只是*创建*表达式，甚至还没有进行任何操作。
- en: Identities like this are better left out of `eval` and implemented in other
    methods instead (in the case of this identity, [`expand_trig()`](#custom-functions-expand)).
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像这样的身份识别最好不要包含在`eval`中，而是在其他方法中实现（在这种身份识别的情况下，[`expand_trig()`](#custom-functions-expand)）。
- en: '**When restricting the input domain: allow `None` input assumptions.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在限制输入域时：允许`None`输入假设。**'
- en: Our example function \(\operatorname{versin}(x)\) is a function from \(\mathbb{C}\)
    to \(\mathbb{C}\), so it can accept any input. But suppose we had a function that
    only made sense with certain inputs. As a second example, let’s define a function
    `divides` as
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的示例函数\(\operatorname{versin}(x)\)是从\(\mathbb{C}\)到\(\mathbb{C}\)的函数，因此它可以接受任何输入。但假设我们有一个只对某些输入有意义的函数。作为第二个示例，让我们定义一个函数`divides`如下：
- en: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{for}\:
    m \mid n \\ 0 & \text{for}\: m\not\mid n \end{cases}.\end{split}\]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{if}\:
    m \mid n \\ 0 & \text{if}\: m\not\mid n \end{cases}.\end{split}\]'
- en: That is, `divides(m, n)` will be `1` if `m` divides `n` and `0` otherwise. `divides`
    clearly only makes sense if `m` and `n` are integers.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，如果`m`能整除`n`，`divides(m, n)`将为`1`，否则为`0`。显然，`divides`只在`m`和`n`为整数时有意义。
- en: 'We might be tempted to define the `eval()` method for `divides` like this:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可能会尝试像这样定义`divides`的`eval()`方法：
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The problem here is that by using `if not m.is_integer`, we are requiring `m.is_integer`
    to be `True`. If it is `None`, it will fail (see the [guide on booleans and three-valued
    logic](booleans.html#booleans-guide) for details on what it means for an assumption
    to be `None`). This is problematic for two reasons. Firstly, it forces the user
    to define assumptions on any input variable. If the user omits them, it will fail:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题是，通过使用`if not m.is_integer`，我们要求`m.is_integer`必须为`True`。如果它是`None`，它将失败（有关假设为`None`的详细信息，请参见[布尔值和三值逻辑指南](booleans.html#booleans-guide)）。这有两个问题。首先，它强制用户对任何输入变量定义假设。如果用户省略它们，它将失败：
- en: '[PRE25]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Instead they have to write
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，他们必须编写
- en: '[PRE26]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This may seem like an acceptable restriction, but there is a bigger problem.
    Sometimes, SymPy’s assumptions system cannot deduce an assumption, even though
    it is mathematically true. In this case, it will give `None` (`None` means both
    “undefined” and “cannot compute” in SymPy’s assumptions). For example
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这似乎是一个可以接受的限制，但存在更大的问题。有时，SymPy的假设系统无法推导出一个假设，即使在数学上是正确的。在这种情况下，它会返回`None`（在SymPy的假设中，`None`表示“未定义”和“无法计算”）。例如
- en: '[PRE27]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here the expression `(m**2 + m)/2` is always an integer, but SymPy’s assumptions
    system is not able to deduce this:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，表达式`(m**2 + m)/2`始终是一个整数，但SymPy的假设系统无法推导出这一点：
- en: '[PRE28]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: SymPy’s assumptions system is always improving, but there will always be cases
    like this that it cannot deduce, due to the fundamental computational complexity
    of the problem, and the fact that the general problem is [often](https://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem)
    [undecidable](https://en.wikipedia.org/wiki/Richardson%27s_theorem).
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SymPy的假设系统在不断改进，但总会有这样的情况，它无法推导出，这是由于问题的基本计算复杂性，以及一般问题通常是[不可判定的](https://en.wikipedia.org/wiki/Richardson%27s_theorem)。
- en: Consequently, one should always test *negated* assumptions for input variables,
    that is, fail if the assumption is `False` but allow the assumption to be `None`.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，人们应该始终测试*否定*的输入变量假设，即，如果假设为`False`则失败，但允许假设为`None`。
- en: '[PRE29]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This still disallows non-integer inputs as desired:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这仍然不允许非整数输入，如期望的那样：
- en: '[PRE30]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But it does not fail in cases where the assumption is `None`:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但在假设为`None`的情况下并不会失败：
- en: '[PRE31]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'This rule of allowing `None` assumptions only applies to instances where an
    exception would be raised, such as type checking an input domain. In cases where
    simplifications or other operations are done, one should treat a `None` assumption
    as meaning “can be either `True` or `False`” and not perform an operation that
    might not be mathematically valid.  ### Assumptions'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '此规则仅适用于仅在引发异常时才会发生的情况，例如对输入域进行类型检查。在进行简化或其他操作的情况下，应将`None`假设视为“可以是`True`或`False`”，并且不要执行可能在数学上无效的操作。  ###
    假设'
- en: The next thing you might want to define are the assumptions on our function.
    The assumptions system allows defining what mathematical properties your function
    has given its inputs, for example, “\(f(x)\) is *positive* when \(x\) is *real*.”
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你可能想要定义的是我们函数的假设。假设系统允许根据其输入定义函数具有的数学属性，例如，“当\(x\)是*实数*时，\(f(x)\)是*正数*。”
- en: The [guide on the assumptions system](assumptions.html#assumptions-guide) goes
    into the assumptions system in great detail. It is recommended to read through
    that guide first to understand what the different assumptions mean and how the
    assumptions system works.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[假设系统指南](assumptions.html#assumptions-guide)详细介绍了假设系统。建议首先阅读该指南，以了解不同的假设含义以及假设系统的工作原理。'
- en: The simplest case is a function that always has a given assumption regardless
    of its input. In this case, you can define `is_*assumption*` directly on the class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是一个函数始终具有给定的假设，而不考虑其输入。在这种情况下，可以直接在类上定义`is_*assumption*`。
- en: 'For example, our [example `divides` function](#custom-functions-divides-definition)
    is always an integer, because its value is always either 0 or 1:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的[例子`divides`函数](#custom-functions-divides-definition)总是一个整数，因为它的值总是0或1：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In general, however, the assumptions of a function depend on the assumptions
    of its inputs. In this case, you should define an `_eval_*assumption*` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一般来说，函数的假设取决于其输入的假设。在这种情况下，应该定义一个`_eval_*assumption*`方法。
- en: For our [\(\operatorname{versin}(x)\) example](#custom-functions-versine-definition),
    the function is always in \([0, 2]\) when \(x\) is real, and it is 0 exactly when
    \(x\) is an even multiple of \(\pi\). So `versin(x)` should be *nonnegative* whenever
    `x` is *real* and *positive* whenever `x` is *real* and not an *even* multiple
    of π. Remember that by default, a function’s domain is all of \(\mathbb{C}\),
    and indeed `versin(x)` makes perfect sense with non-real `x`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的[\(\operatorname{versin}(x)\)示例](#custom-functions-versine-definition)，当\(x\)是实数时，该函数始终在\([0,
    2]\)内，并且当\(x\)是\(\pi\)的偶数倍时，它恰好为0。因此，无论`x`是*实数*还是*不是*π的*偶数*倍，`versin(x)`应该是*非负的*。记住，默认情况下，函数的定义域是\(\mathbb{C}\)的全体，实际上`versin(x)`对于非实数的`x`也是有意义的。
- en: To see if `x` is an even multiple of `pi`, we can use [`as_independent()`](../modules/core.html#sympy.core.expr.Expr.as_independent
    "sympy.core.expr.Expr.as_independent") to match `x` structurally as `coeff*pi`.
    Pulling apart subexpressions structurally like this in assumptions handlers is
    preferable to using something like `(x/pi).is_even`, because that will create
    a new expression `x/pi`. The creation of a new expression is much slower. Furthermore,
    whenever an expression is created, the constructors that are called when creating
    the expression will often themselves cause assumptions to be queried. If you are
    not careful, this can lead to infinite recursion. So a good general rule for assumptions
    handlers is, **never create a new expression in an assumptions handler**. Always
    pull apart the args of the function using structural methods like `as_independent`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`x`是否是\(\pi\)的偶数倍，我们可以使用[`as_independent()`](../modules/core.html#sympy.core.expr.Expr.as_independent
    "sympy.core.expr.Expr.as_independent")来将`x`结构化地匹配为`coeff*pi`。在假设处理程序中，像这样结构化地分解子表达式比使用`(x/pi).is_even`之类的方法更可取，因为后者会创建一个新的表达式`x/pi`，而创建新表达式会慢得多。此外，每当创建一个表达式时，构造函数通常会导致假设被查询。如果不小心，这可能导致无限递归。因此，假设处理程序的一个好的一般规则是，**永远不要在假设处理程序中创建新的表达式**。始终使用像`as_independent`这样的结构方法来分解函数的参数。
- en: 'Note that \(\operatorname{versin}(x)\) can be nonnegative for nonreal \(x\),
    for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意\(\operatorname{versin}(x)\)对于非实数\(x\)可以是非负的，例如：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So for the `_eval_is_nonnegative` handler, we want to return `True` if `x.is_real`
    is `True` but `None` if `x.is_real` is either `False` or `None`. It is left as
    an exercise to the reader to handle the cases for nonreal `x` that make `versin(x)`
    nonnegative, using similar logic from the `_eval_is_positive` handler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `_eval_is_nonnegative` 处理程序，如果 `x.is_real` 为 `True`，我们希望返回 `True`，但如果 `x.is_real`
    为 `False` 或 `None`，则返回 `None`。读者可以自行处理对于使 `versin(x)` 非负的非实数 `x` 的情况，使用类似于 `_eval_is_positive`
    处理程序的逻辑。
- en: In the assumptions handler methods, as in all methods, we can access the arguments
    of the function using `self.args`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设处理方法中，就像所有方法一样，我们可以使用 `self.args` 访问函数的参数。
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note the use of `fuzzy_` functions in the more complicated `_eval_is_positive()`
    handler, and the careful handling of the `if`/`elif`. It is important when working
    with assumptions to always be careful about [handling three-valued logic correctly](booleans.html#booleans-guide).
    This ensures that the method returns the correct answer when `x.is_real` or `coeff.is_even`
    are `None`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在更复杂的 `_eval_is_positive()` 处理程序中使用 `fuzzy_` 函数，并且对 `if`/`elif` 的谨慎处理很重要。在处理假设时，始终要小心[正确处理三值逻辑](booleans.html#booleans-guide)，以确保方法在
    `x.is_real` 或 `coeff.is_even` 为 `None` 时返回正确的答案。
- en: Warning
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Never define `is_*assumption*` as a `@property` method. Doing so will break
    the automatic deduction of other assumptions. `is_*assumption*` should only ever
    be defined as a class variable equal to `True` or `False`. If the assumption depends
    on the `.args` of the function somehow, define the `_eval_*assumption*` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将 `is_*assumption*` 定义为 `@property` 方法。这样做会破坏其他假设的自动推导。`is_*assumption*`
    应该只作为等于 `True` 或 `False` 的类变量定义。如果假设依赖于函数的 `.args`，则定义 `_eval_*assumption*` 方法。
- en: In this example, it is not necessary to define `_eval_is_real()` because it
    is deduced automatically from the other assumptions, since `nonnegative -> real`.
    In general, you should avoid defining assumptions that the assumptions system
    can deduce automatically given its [known facts](assumptions.html#assumptions-guide-predicates).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，不需要定义 `_eval_is_real()`，因为它可以从其他假设中自动推导出来，因为 `nonnegative -> real`。一般而言，应避免定义假设，假设系统可以根据其已知事实自动推导出的。
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The assumptions system is often able to deduce more than you might think. For
    example, from the above, it can deduce that `versin(2*n*pi)` is zero when `n`
    is an integer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统通常能够推导出比您认为的更多内容。例如，可以从上面的内容推导出当 `n` 是整数时，`versin(2*n*pi)` 为零。
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It’s always worth checking if the assumptions system can deduce something automatically
    before manually coding it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动编码之前，始终值得检查假设系统是否可以自动推导出某些内容。
- en: 'Finally, a word of warning: be very careful about correctness when coding assumptions.
    Make sure to use the exact [definitions](assumptions.html#assumptions-guide-predicates)
    of the various assumptions, and always check that you’re handling `None` cases
    correctly with the fuzzy three-valued logic functions. Incorrect or inconsistent
    assumptions can lead to subtle bugs. It’s recommended to use unit tests to check
    all the various cases whenever your function has a nontrivial assumption handler.
    All functions defined in SymPy itself are required to be extensively tested.  ###
    Numerical Evaluation with `evalf()`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个警告：在编写假设时，非常注意正确性。确保使用各种假设的确切[定义](assumptions.html#assumptions-guide-predicates)，并始终检查是否正确处理了模糊的三值逻辑函数的
    `None` 情况。不正确或不一致的假设可能导致微妙的错误。建议在函数具有非平凡假设处理程序时使用单元测试来检查所有不同的情况。SymPy 自身定义的所有函数都需要进行广泛测试。###
    使用 `evalf()` 进行数值评估
- en: Here we show how to define how a function should numerically evaluate to a floating
    point [`Float`](../modules/core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")
    value, for instance, via `evalf()`. Implementing numerical evaluation enables
    several behaviors in SymPy. For example, once `evalf()` is defined, you can plot
    your function, and things like inequalities can evaluate to explicit values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们展示了如何定义函数在数值上如何评估为浮点数 [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float") 值，例如通过 `evalf()`。实现数值评估可以在 SymPy 中启用多种行为。例如，一旦定义了
    `evalf()`，您可以绘制函数，并且不等式可以评估为显式值。
- en: If your function has the same name as a function in [mpmath](https://mpmath.org/doc/current/),
    which is the case for most functions included with SymPy, numerical evaluation
    will happen automatically and you do not need to do anything.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数与[mpmath](https://mpmath.org/doc/current/)中的函数同名（这是SymPy包含的大多数函数的情况），数值评估将自动发生，你不需要做任何操作。
- en: If this is not the case, numerical evaluation can be specified by defining the
    method `_eval_evalf(self, prec)`, where `prec` is the binary precision of the
    input. The method should return the expression evaluated to the given precision,
    or `None` if this is not possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这种情况，可以通过定义方法`_eval_evalf(self, prec)`来指定数值评估，其中`prec`是输入的二进制精度。该方法应返回按给定精度评估的表达式，如果不可能，则返回`None`。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `prec` argument to `_eval_evalf()` is the *binary* precision, that is, the
    number of bits in the floating-point representation. This differs from the first
    argument to the `evalf()` method, which is the *decimal* precision, or `dps`.
    For example, the default binary precision of `Float` is 53, corresponding to a
    decimal precision of 15\. Therefore, if your `_eval_evalf()` method recursively
    calls evalf on another expression, it should call `expr._eval_evalf(prec)` rather
    than `expr.evalf(prec)`, as the latter will incorrectly use `prec` as the decimal
    precision.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`_eval_evalf()`方法的`prec`参数是*二进制*精度，即浮点表示中的比特数。这与`evalf()`方法的第一个参数不同，后者是*十进制*精度，即`dps`。例如，`Float`的默认二进制精度是53，对应于十进制精度15。因此，如果你的`_eval_evalf()`方法递归地调用另一个表达式的evalf，应该调用`expr._eval_evalf(prec)`而不是`expr.evalf(prec)`，因为后者会错误地使用`prec`作为十进制精度。'
- en: We can define numerical evaluation for [our example \(\operatorname{versin}(x)\)
    function](#custom-functions-versine-definition) by recursively evaluating \(2\sin^2\left(\frac{x}{2}\right)\),
    which is a more numerically stable way of writing \(1 - \cos(x)\).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过递归评估\(2\sin^2\left(\frac{x}{2}\right)\)，为我们的示例\(\operatorname{versin}(x)\)函数定义数值评估，这是编写\(1
    - \cos(x)\)更为稳定的方法。
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once `_eval_evalf()` is defined, this enables the automatic evaluation of floating-point
    inputs. It is not required to implement this manually in [`eval()`](#custom-functions-eval).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了`_eval_evalf()`，就可以自动评估浮点输入。在[`eval()`](#custom-functions-eval)中手动实现这一点是不必要的。
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that `evalf()` may be passed any expression, not just one that can be evaluated
    numerically. In this case, it is expected that the numerical parts of an expression
    will be evaluated. A general pattern to follow is to recursively call `_eval_evalf(prec)`
    on the arguments of the function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`evalf()`可能会传递任何表达式，而不仅仅是可以数值化评估的表达式。在这种情况下，预计会对表达式的数值部分进行评估。一个常见的模式是在函数的参数上递归调用`_eval_evalf(prec)`。
- en: 'Whenever possible, it’s best to reuse the evalf functionality defined in existing
    SymPy functions. However, in some cases it will be necessary to use mpmath directly.  ###
    Rewriting and Simplification'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '在可能的情况下，最好重用现有SymPy函数中定义的evalf功能。但在某些情况下，需要直接使用mpmath。 ### 重写和简化'
- en: Various simplification functions and methods allow specifying their behavior
    on custom subclasses. Not every function in SymPy has such hooks. See the documentation
    of each individual function for details.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 各种简化函数和方法允许在自定义子类上指定它们的行为。并非每个SymPy函数都有这样的钩子。查看每个单独函数的文档以获取详细信息。
- en: '#### `rewrite()`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `rewrite()`'
- en: The [`rewrite()`](../modules/core.html#sympy.core.basic.Basic.rewrite "sympy.core.basic.Basic.rewrite")
    method allows rewriting an expression in terms of a specific function or rule.
    For example,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rewrite()`](../modules/core.html#sympy.core.basic.Basic.rewrite "sympy.core.basic.Basic.rewrite")方法允许根据特定函数或规则将表达式重写。例如，'
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To implement rewriting, define a method `_eval_rewrite(self, rule, args, **hints)`,
    where
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现重写，定义一个方法`_eval_rewrite(self, rule, args, **hints)`，其中
- en: '`rule` is the *rule* passed to the `rewrite()` method. Typically `rule` will
    be the class of the object to be rewritten to, although for more complex rewrites,
    it can be anything. Each object that defines `_eval_rewrite()` defines what rule(s)
    it supports. Many SymPy functions rewrite to common classes, like `expr.rewrite(Add)`,
    to perform simplifications or other computations.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rule`是传递给`rewrite()`方法的*规则*。通常`rule`将是要重写为的对象的类，尽管对于更复杂的重写，它可以是任何东西。定义`_eval_rewrite()`的每个对象都会定义它支持的规则。许多SymPy函数重写为常见类，例如`expr.rewrite(Add)`，以执行简化或其他计算。'
- en: '`args` are the arguments of the function to be used for rewriting. This should
    be used instead of `self.args` because any recursive expressions in the args will
    be rewritten in `args` (assuming the caller used `rewrite(deep=True)`, which is
    the default).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args` 是用于重写函数的参数。这应该使用 `self.args` 而不是 `self.args`，因为参数中的任何递归表达式将在 `args`
    中重写（假设调用者使用了 `rewrite(deep=True)`，这是默认值）。'
- en: '`**hints` are additional keyword arguments which may be used to specify the
    behavior of the rewrite. Unknown hints should be ignored as they may be passed
    to other `_eval_rewrite()` methods. If you recursively call rewrite, you should
    pass the `**hints` through.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**hints` 是额外的关键字参数，可能用于指定重写行为。未知的提示应该被忽略，因为它们可能传递给其他 `_eval_rewrite()` 方法。如果递归调用重写，应该通过传递
    `**hints`。'
- en: The method should return a rewritten expression, using `args` as the arguments
    to the function, or `None` if the expression should be unchanged.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应返回重写的表达式，使用 `args` 作为函数的参数，如果表达式不应更改，则返回 `None`。
- en: 'For our [`versin` example](#custom-functions-versine-definition), an obvious
    rewrite we can implement is rewriting `versin(x)` as `1 - cos(x)`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 [`versin` 示例](#custom-functions-versine-definition)，我们可以实现一个明显的重写，将 `versin(x)`
    重写为 `1 - cos(x)`：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once we’ve defined this, [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") is now able to simplify some expressions containing
    `versin`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这个，[`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify)
    现在可以简化一些包含 `versin` 的表达式：
- en: '[PRE44]  #### `doit()`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE44]  #### `doit()`'
- en: The [`doit()`](../modules/core.html#sympy.core.basic.Basic.doit "sympy.core.basic.Basic.doit")
    method is used to evaluate “unevaluated” functions. To define `doit()` implement
    `doit(self, deep=True, **hints)`. If `deep=True`, `doit()` should recursively
    call `doit()` on the arguments. `**hints` will be any other keyword arguments
    passed to the user, which should be passed to any recursive calls to `doit()`.
    You can use `hints` to allow the user to specify specific behavior for `doit()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[`doit()` 方法](../modules/core.html#sympy.core.basic.Basic.doit) 用于评估“未评估”的函数。要定义
    `doit()`，实现 `doit(self, deep=True, **hints)`。如果 `deep=True`，`doit()` 应递归调用参数的
    `doit()`。`**hints` 将是传递给用户的任何其他关键字参数，应该传递给 `doit()` 的任何递归调用。您可以使用 `hints` 允许用户指定
    `doit()` 的特定行为。'
- en: The typical usage of `doit()` in custom `Function` subclasses is to perform
    more advanced evaluation which is not performed in [`eval()`](#custom-functions-eval).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 `Function` 子类中 `doit()` 的典型用法是执行更高级的评估，这在 [`eval()`](#custom-functions-eval)
    中不执行。
- en: For example, for our [`divides` example](#custom-functions-divides-definition),
    there are several instances that could be simplified using some identities. For
    example, we defined `eval()` to evaluate on explicit integers, but we might also
    want to evaluate examples like `divides(k, k*n)` where the divisibility is symbolically
    true. One of the [best practices for `eval()`](#custom-functions-eval-best-practices)
    is to avoid too much automatic evaluation. Automatically evaluating in this case
    might be considered too much, as it would make use of the assumptions system,
    which could be expensive. Furthermore, we might want to be able to represent `divides(k,
    k*n)` without it always evaluating.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的 [`divides` 示例](#custom-functions-divides-definition)，有几个实例可以使用一些身份简化。例如，我们定义了
    `eval()` 来评估显式整数，但我们可能也希望评估类似 `divides(k, k*n)` 这样的例子，其中除法在符号上是真实的。[`eval()` 的最佳实践](#custom-functions-eval-best-practices)之一是避免过多的自动评估。在这种情况下自动评估可能被认为是过多的，因为它会使用假设系统，这可能是昂贵的。此外，我们可能希望能够表示
    `divides(k, k*n)` 而不总是评估它。
- en: 'The solution is to implement these more advanced evaluations in `doit()`. That
    way, we can explicitly perform them by calling `expr.doit()`, but they won’t happen
    by default. An example `doit()` for `divides` that performs this simplification
    (along with the [above definition of `eval()`](#custom-functions-divides-eval))
    might look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在 `doit()` 中实现这些更高级的评估。这样，我们可以通过调用 `expr.doit()` 显式执行它们，但默认情况下不会发生。例如，为
    `divides` 编写的 `doit()` 可以执行这种简化（与上述的 [`eval()` 定义](#custom-functions-divides-eval)）可能看起来像这样：
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If `doit()` returns a Python `int` literal, convert it to an `Integer` so that
    the returned object is a SymPy type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `doit()` 返回一个 Python `int` 文字，则将其转换为 `Integer`，以便返回的对象是 SymPy 类型。
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (Note that this uses the [convention](https://en.wikipedia.org/wiki/Divisor#Definition)
    that \(k \mid 0\) for all \(k\) so that we do not need to check if `m` or `n`
    are nonzero. If we used a different convention we would need to check if `m.is_zero`
    and `n.is_zero` before performing the simplification.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，这使用了 [约定](https://en.wikipedia.org/wiki/Divisor#Definition)，即 \(k \mid 0\)
    对于所有 \(k\)，因此我们无需检查 `m` 或 `n` 是否为非零。如果我们使用不同的约定，我们将需要在执行简化之前检查 `m.is_zero` 和 `n.is_zero`。）
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Another common way to implement `doit()` is for it to always return another
    expression. This effectively treats the function as an “unevaluated” form of another
    expression.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的 `doit()` 实现方式是始终返回另一个表达式。这实际上将函数视为另一个表达式的“未评估”形式。
- en: 'For example, let’s define a function for [fused multiply-add](https://en.wikipedia.org/w/index.php?title=Fused_multiply_add):
    \(\operatorname{FMA}(x, y, z) = xy + z\). It may be useful to express this function
    as a distinct function, e.g., for the purposes of code generation, but it would
    also be useful in some contexts to “evaluate” `FMA(x, y, z)` to `x*y + z` so that
    it can properly simplify with other expressions.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个 [融合乘加](https://en.wikipedia.org/w/index.php?title=Fused_multiply_add)
    的函数：\(\operatorname{FMA}(x, y, z) = xy + z\)。将此函数表达为一个独立的函数可能对代码生成有用，但在某些情况下，将
    `FMA(x, y, z)` “评估” 为 `x*y + z` 也可能很有用，以便能够与其他表达式正确简化。
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Most custom functions will not want to define `doit()` in this way. However,
    this can provide a happy medium between having a function that always evaluates
    and a function that never evaluates, producing a function that doesn’t evaluate
    by default but can be evaluated on demand (see the [discussion above](#custom-functions-eval-best-practices)).  ####
    `expand()`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '大多数自定义函数不希望以这种方式定义 `doit()`。然而，这可以在始终评估的函数和从不评估的函数之间提供一个折中，从而产生一个默认情况下不评估但可以按需评估的函数（参见上文的
    [讨论](#custom-functions-eval-best-practices)）。 #### `expand()`'
- en: The [`expand()`](../modules/core.html#sympy.core.function.expand "sympy.core.function.expand")
    function “expands” an expression in various ways. It is actually a wrapper around
    several sub-expansion hints. Each function corresponds to a hint to the `expand()`
    function/method. A specific expand *hint* can be defined in a custom function
    by defining `_eval_expand_*hint*(self, **hints)`. See the documentation of [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand") for details on which hints are defined and the documentation
    for each specific `expand_*hint*()` function (e.g., [`expand_trig()`](../modules/core.html#sympy.core.function.expand_trig
    "sympy.core.function.expand_trig")) for details on what each hint is designed
    to do.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[`expand()`](../modules/core.html#sympy.core.function.expand "sympy.core.function.expand")
    函数以各种方式“扩展”表达式。它实际上是几个子扩展提示的包装器。每个函数对应于 `expand()` 函数/方法的一个提示。可以通过定义 `_eval_expand_*hint*(self,
    **hints)` 在自定义函数中定义特定的扩展 *hint*。有关定义的提示以及每个特定 `expand_*hint*()` 函数的文档，请参阅 [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand") 的文档。'
- en: The `**hints` keyword arguments are additional hints that may be passed to the
    expand function to specify additional behavior (these are separate from the predefined
    *hints* described in the previous paragraph). Unknown hints should be ignored
    as they may apply to other functions’ custom `expand()` methods. A common hint
    to define is `force`, where `force=True` would force an expansion that might not
    be mathematically valid for all the given input assumptions. For example, `expand_log(log(x*y),
    force=True)` produces `log(x) + log(y)` even though this identity is not true
    for all complex `x` and `y` (typically `force=False` is the default).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`**hints` 关键字参数是可以传递给 expand 函数以指定额外行为的额外提示（这些与前一段描述的预定义 *hints* 是分开的）。未知的提示应该被忽略，因为它们可能适用于其他函数的自定义
    `expand()` 方法。定义一个常见的提示是 `force`，其中 `force=True` 将强制进行扩展，这可能对于所有给定的输入假设在数学上并不总是有效。例如，`expand_log(log(x*y),
    force=True)` 产生 `log(x) + log(y)`，尽管这个恒等式并不对所有复数 `x` 和 `y` 都成立（通常 `force=False`
    是默认值）。'
- en: Note that `expand()` automatically takes care of recursively expanding expressions
    using its own `deep` flag, so `_eval_expand_*` methods should not recursively
    call expand on the arguments of the function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`expand()` 方法会自动处理使用其自身 `deep` 标志递归扩展表达式，因此 `_eval_expand_*` 方法不应在函数的参数上递归调用
    expand。
- en: 'For our [`versin` example](#custom-functions-versine-definition), we can define
    rudimentary `trig` expansion by defining an `_eval_expand_trig` method, which
    recursively calls `expand_trig()` on `1 - cos(x)`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的[`versin`示例](#custom-functions-versine-definition)，我们可以通过定义一个`_eval_expand_trig`方法来定义`trig`的基本展开，该方法在`1
    - cos(x)`上递归调用`expand_trig()`：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A more sophisticated implementation might attempt to rewrite the result of
    `expand_trig(1 - cos(x))` back into `versin` functions. This is left as an exercise
    for the reader.  ### Differentiation'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的实现可能会尝试将`expand_trig(1 - cos(x))`的结果重新转换为`versin`函数。这留给读者作为一个练习。### 微分
- en: To define differentiation via [`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff"), define a method `fdiff(self, argindex)`. `fdiff()`
    should return the derivative of the function, without considering the chain rule,
    with respect to the `argindex`-th variable. `argindex` is indexed starting at
    `1`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过[`diff()`](../modules/core.html#sympy.core.function.diff "sympy.core.function.diff")定义微分，请定义一个方法`fdiff(self,
    argindex)`。`fdiff()`应该返回函数的导数，不考虑链式法则，关于第`argindex`个变量。`argindex`从`1`开始索引。
- en: That is, `f(x1, ..., xi, ..., xn).fdiff(i)` should return \(\frac{d}{d x_i}
    f(x_1, \ldots, x_i, \ldots, x_n)\), where \(x_k\) are independent of one another.
    `diff()` will automatically apply the chain rule using the result of `fdiff()`.
    User code should use `diff()` and not call `fdiff()` directly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`f(x1, ..., xi, ..., xn).fdiff(i)`应该返回\(\frac{d}{d x_i} f(x_1, \ldots,
    x_i, \ldots, x_n)\)，其中\(x_k\)彼此独立。`diff()`将自动使用`fdiff()`的结果应用链式法则。用户代码应该使用`diff()`，而不是直接调用`fdiff()`。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Function` subclasses should define differentiation using `fdiff()`. Subclasses
    of [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    that aren’t `Function` subclasses will need to define `_eval_derivative()` instead.
    It is not recommended to redefine `_eval_derivative()` on a `Function` subclass.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`子类应该使用`fdiff()`来定义微分。不是`Function`子类的[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")的子类需要定义`_eval_derivative()`。不建议在`Function`子类上重新定义`_eval_derivative()`。'
- en: For our [\(\operatorname{versin}\) example function](#custom-functions-versine-definition),
    the derivative is \(\sin(x)\).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的[\(\operatorname{versin}\)示例函数](#custom-functions-versine-definition)，导数是\(\sin(x)\)。
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As an example of a function that has multiple arguments, consider the [fused
    multiply-add (FMA) example](#custom-functions-fma-definition) defined above (\(\operatorname{FMA}(x,
    y, z) = xy + z\)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具有多个参数的函数的示例，考虑上述定义的[融合乘加（FMA）示例](#custom-functions-fma-definition)(\(\operatorname{FMA}(x,
    y, z) = xy + z\))。
- en: We have
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有
- en: \[\frac{d}{dx} \operatorname{FMA}(x, y, z) = y,\]\[\frac{d}{dy} \operatorname{FMA}(x,
    y, z) = x,\]\[\frac{d}{dz} \operatorname{FMA}(x, y, z) = 1.\]
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{d}{dx} \operatorname{FMA}(x, y, z) = y,\]\[\frac{d}{dy} \operatorname{FMA}(x,
    y, z) = x,\]\[\frac{d}{dz} \operatorname{FMA}(x, y, z) = 1.\]
- en: 'So the `fdiff()` method for `FMA` would look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`FMA`的`fdiff()`方法如下所示：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To leave a derivative unevaluated, raise `sympy.core.function.ArgumentIndexError(self,
    argindex)`. This is the default behavior if `fdiff()` is not defined. Here is
    an example function \(f(x, y)\) that is linear in the first argument and has an
    unevaluated derivative on the second argument.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要保留一个导数未求值，应该引发`sympy.core.function.ArgumentIndexError(self, argindex)`。如果没有定义`fdiff()`，这是默认行为。这里有一个在第二个参数上具有未求值导数的例子函数\(f(x,
    y)\)。
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Printing
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印
- en: You can define how a function prints itself with the varions [printers](../modules/printing.html#module-printing)
    such as the [`string printer`](../modules/printing.html#sympy.printing.str.StrPrinter
    "sympy.printing.str.StrPrinter"), [`pretty printers`](../modules/printing.html#sympy.printing.pretty.pretty.PrettyPrinter
    "sympy.printing.pretty.pretty.PrettyPrinter"), and [`LaTeX printer`](../modules/printing.html#sympy.printing.latex.LatexPrinter
    "sympy.printing.latex.LatexPrinter"), as well as code printers for various languages
    like [`C`](../modules/printing.html#sympy.printing.c.C99CodePrinter "sympy.printing.c.C99CodePrinter")
    and [`Fortran`](../modules/printing.html#sympy.printing.fortran.FCodePrinter "sympy.printing.fortran.FCodePrinter").
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用各种[打印机](../modules/printing.html#module-printing)来定义函数的打印方式，例如[`string
    printer`](../modules/printing.html#sympy.printing.str.StrPrinter "sympy.printing.str.StrPrinter")、[`pretty
    printers`](../modules/printing.html#sympy.printing.pretty.pretty.PrettyPrinter
    "sympy.printing.pretty.pretty.PrettyPrinter")和[`LaTeX printer`](../modules/printing.html#sympy.printing.latex.LatexPrinter
    "sympy.printing.latex.LatexPrinter")，以及各种语言的代码打印机，如[`C`](../modules/printing.html#sympy.printing.c.C99CodePrinter
    "sympy.printing.c.C99CodePrinter")和[`Fortran`](../modules/printing.html#sympy.printing.fortran.FCodePrinter
    "sympy.printing.fortran.FCodePrinter")。
- en: In most cases, you will not need to define any printing methods. The default
    behavior is to print functions using their name. However, in some cases we may
    want to define special printing for a function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不需要定义任何打印方法。默认行为是使用它们的名称打印函数。但是，在某些情况下，我们可能希望为函数定义特殊的打印方式。
- en: For example, for our [divides example above](#custom-functions-divides-definition),
    we may want the LaTeX printer to print a more mathematical expression. Let’s make
    the LaTeX printer represent `divides(m, n)` as `\left [ m \middle | n \right ]`,
    which looks like \(\left [ m \middle | n \right ]\) (here \([P]\) is the [Iverson
    bracket](https://en.wikipedia.org/wiki/Iverson_bracket), which is \(1\) if \(P\)
    is true and \(0\) if \(P\) is false).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们之前的[除法示例](#custom-functions-divides-definition)，我们可能希望 LaTeX 打印机打印更数学化的表达式。让我们让
    LaTeX 打印机表示 `divides(m, n)` 为 `\left [ m \middle | n \right ]`，看起来像是 \(\left [
    m \middle | n \right ]\)（这里 \([P]\) 是[Iverson括号](https://en.wikipedia.org/wiki/Iverson_bracket)，如果
    \(P\) 成立则为 \(1\)，否则为 \(0\)）。
- en: There are two primary ways to define printing for SymPy objects. One is to define
    a printer on the printer class. Most classes that are part of the SymPy library
    should use this method, by defining the printers on the respective classes in
    `sympy.printing`. For user code, this may be preferable if you are defining a
    custom printer, or if you have many custom functions that you want to define printing
    for. See [Example of Custom Printer](../modules/printing.html#printer-example)
    for an example of how to define a printer in this way.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 对象的打印方式有两种主要方法。一种是在打印机类上定义打印机。SymPy 库中的大多数类应该使用此方法，在 `sympy.printing`
    中的各个类上定义打印机。对于用户代码，如果您定义了自定义打印机或者您有许多自定义函数需要定义打印方式，则可能更可取。参见 [自定义打印机示例](../modules/printing.html#printer-example)
    了解如何以此方式定义打印机的示例。
- en: The other way is to define the printing as a method on the function class. To
    do this, first look up the `printmethod` attribute on the printer you want to
    define the printing for. This is the name of the method you should define for
    that printer. For the LaTeX printer, [`LatexPrinter.printmethod`](../modules/printing.html#sympy.printing.latex.LatexPrinter.printmethod
    "sympy.printing.latex.LatexPrinter.printmethod") is `'_latex'`. The print method
    always takes one argument, `printer`. `printer._print` should be used to recursively
    print any other expressions, including the arguments of the function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在函数类上定义打印方式。要做到这一点，首先查找要为其定义打印方式的打印机上的 `printmethod` 属性。这是您应该为该打印机定义的方法的名称。对于
    LaTeX 打印机，[`LatexPrinter.printmethod`](../modules/printing.html#sympy.printing.latex.LatexPrinter.printmethod
    "sympy.printing.latex.LatexPrinter.printmethod") 是 `'_latex'`。打印方法总是接受一个参数 `printer`。应使用
    `printer._print` 递归打印任何其他表达式，包括函数的参数。
- en: 'So to define our `divides` LaTeX printer, we will define the function `_latex(self,
    printer)` on the class, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要定义我们的 `divides` LaTeX 打印机，我们将在类上定义如下函数 `_latex(self, printer)`：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See [Example of Custom Printing Method](../modules/printing.html#printer-method-example)
    for more details on how to define printer methods and some pitfalls to avoid.
    Most importantly, you should always use `printer._print()` to recursively print
    the arguments of the function inside of a custom printer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何定义打印机方法及一些应避免的陷阱的更多详细信息，请参见 [自定义打印方法示例](../modules/printing.html#printer-method-example)。最重要的是，您应始终使用
    `printer._print()` 递归打印函数的参数，包括自定义打印机内部。
- en: Other Methods
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他方法
- en: Several other methods can be defined on custom functions to specify various
    behaviors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在自定义函数上定义几种其他方法以指定各种行为。
- en: '`inverse()`'
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`inverse()`'
- en: The `inverse(self, argindex=1)` method can be defined to specify the inverse
    of the function. This is used by [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset"). The `argindex` argument is the argument of
    the function, starting at 1 (similar to the same argument name for the [`fdiff()`
    method](#custom-functions-differentiation)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`inverse(self, argindex=1)` 方法可以被定义为指定函数的反函数。这由 [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 和 [`solveset()`](../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") 使用。`argindex` 参数是函数的参数，从 1 开始（类似于[`fdiff()`
    方法](#custom-functions-differentiation)的相同参数名称）。'
- en: '`inverse()` should return a function (not an expression) for the inverse. If
    the inverse is a larger expression than a single function, it can return a `lambda`
    function.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`inverse()` 应该返回一个函数（而不是一个表达式）作为其反函数。如果反函数比单个函数更大，则可以返回一个 `lambda` 函数。'
- en: '`inverse()` should only be defined for functions that are one-to-one. In other
    words, `f(x).inverse()` is the [left inverse](https://en.wikipedia.org/wiki/Inverse_function#Left_and_right_inverses)
    of `f(x)`. Defining `inverse()` on a function that is not one-to-one may result
    in `solve()` not giving all possible solutions to an expression containing the
    function.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`inverse()` 应该仅对一对一的函数进行定义。换句话说，`f(x).inverse()` 是 `f(x)` 的[左逆函数](https://en.wikipedia.org/wiki/Inverse_function#Left_and_right_inverses)。在非一对一的函数上定义
    `inverse()` 可能导致 `solve()` 不会给出包含该函数表达式的所有可能解。'
- en: 'Our [example versine function](#custom-functions-versine-definition) is not
    one-to-one (because cosine is not), but its inverse \(\operatorname{arcversin}\)
    is. We may define it as follows (using the same naming convention as other inverse
    trig functions in SymPy):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的[示例 versine 函数](#custom-functions-versine-definition)不是一对一的（因为余弦函数不是），但它的反函数
    \(\operatorname{arcversin}\) 是。我们可以定义它如下（使用与 SymPy 中其他反三角函数相同的命名约定）：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This makes `solve()` work on `aversin(x)`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `solve()` 在 `aversin(x)` 上工作：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`as_real_imag()`'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`as_real_imag()`'
- en: The method [`as_real_imag()`](../modules/core.html#sympy.core.expr.Expr.as_real_imag
    "sympy.core.expr.Expr.as_real_imag") method defines how to split a function into
    its real and imaginary parts. It is used by various SymPy functions that operate
    on the real and imaginary parts of an expression separately.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[`as_real_imag()`](../modules/core.html#sympy.core.expr.Expr.as_real_imag
    "sympy.core.expr.Expr.as_real_imag")定义如何将函数拆分为其实部和虚部。它被各种 SymPy 函数使用，这些函数分别在表达式的实部和虚部上操作。
- en: '`as_real_imag(self, deep=True, **hints)` should return a 2-tuple containing
    the real part and imaginary part of the function. That is `expr.as_real_imag()`
    returns `(re(expr), im(expr))`, where `expr == re(expr) + im(expr)*I`, and `re(expr)`
    and `im(expr)` are real.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_real_imag(self, deep=True, **hints)` 应该返回一个包含函数的实部和虚部的二元组。也就是说，`expr.as_real_imag()`
    返回 `(re(expr), im(expr))`，其中 `expr == re(expr) + im(expr)*I`，并且 `re(expr)` 和 `im(expr)`
    是实数。'
- en: If `deep=True`, it should recursively call `as_real_imag(deep=True, **hints)`
    on its arguments. As with [`doit()`](#custom-functions-doit) and [the `_eval_expand_*()`
    methods](#custom-functions-expand), `**hints` may be any hints to allow the user
    to specify the behavior of the method. Unknown hints should be ignored and passed
    through on any recursive calls in case they are meant for other `as_real_imag()`
    methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `deep=True`，它应该在其参数上递归调用 `as_real_imag(deep=True, **hints)`。与[`doit()`](#custom-functions-doit)和[_eval_expand_*()
    方法](#custom-functions-expand)类似，`**hints` 可以是任何提示，允许用户指定方法的行为。未知提示应在递归调用中传递，以防它们适用于其他
    `as_real_imag()` 方法。
- en: For our [`versin` example](#custom-functions-versine-definition), we can recursively
    use the `as_real_imag()` that is already defined for `1 - cos(x)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的[`versin` 示例](#custom-functions-versine-definition)，我们可以递归地使用已经定义在 `1 -
    cos(x)` 上的 `as_real_imag()`。
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Defining `as_real_imag()` also automatically makes [`expand_complex()`](../modules/core.html#sympy.core.function.expand_complex
    "sympy.core.function.expand_complex") work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `as_real_imag()` 也会自动使[`expand_complex()`](../modules/core.html#sympy.core.function.expand_complex
    "sympy.core.function.expand_complex")工作。
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Miscellaneous `_eval_*` methods
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 各种 `_eval_*` 方法
- en: 'There are many other functions in SymPy whose behavior can be defined on custom
    functions via a custom `_eval_*` method, analogous to the ones described above.
    See the documentation of the specific function for details on how to define each
    method.  ## Complete Examples'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 中还有许多其他函数，通过自定义 `_eval_*` 方法可以定义这些函数的行为，类似于上述描述的方法。有关如何定义每个方法的详细信息，请参阅特定函数的文档。##
    完整示例
- en: Here are complete examples for the example functions defined in this guide.
    See the above sections for details on each method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在本指南中定义的示例函数的完整示例。有关每个方法的详细信息，请参见上面的各节。
- en: '### Versine'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '### Versine'
- en: The versine (versed sine) function is defined as
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Versine（反正弦）函数定义为
- en: \[\operatorname{versin}(x) = 1 - \cos(x).\]
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: \[\operatorname{versin}(x) = 1 - \cos(x).\]
- en: Versine is an example of a simple function defined for all complex numbers.
    The mathematical definition is simple, which makes it straightforward to define
    all the above methods on it (in most cases we can just reuse the existing SymPy
    logic defined on `1 - cos(x)`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Versine 是一个为所有复数定义的简单函数的示例。数学定义很简单，这使得在其上定义所有上述方法变得简单（在大多数情况下，我们可以重用已定义在 `1
    - cos(x)` 上的现有 SymPy 逻辑）。
- en: Definition
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Examples
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: '**Evaluation:**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估：**'
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Assumptions:**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**假设：**'
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Simplification:**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化：**'
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Differentiation:**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**微分：**'
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**Solving:**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决：**'
- en: (a more general version of `aversin` would have all the above methods defined
    as well)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: （一个更一般的`aversin`版本将定义所有上述方法）
- en: '[PRE67]  ### divides'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE67]  ### divides'
- en: divides is a function defined by
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: divides是一个由以下函数定义的函数
- en: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{for}\:
    m \mid n \\ 0 & \text{for}\: m\not\mid n \end{cases},\end{split}\]'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{如果}\:
    m \mid n \\ 0 & \text{如果}\: m\not\mid n \end{cases},\end{split}\]'
- en: that is, `divides(m, n)` is 1 if `m` divides `n` and `0` if `m` does not divide
    `m`. It is only defined for integer `m` and `n`. For the sake of simplicity, we
    use the convention that \(m \mid 0\) for all integer \(m\).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`divides(m, n)`当`m`除以`n`时为1，否则为0。它仅对整数`m`和`n`定义。为了简单起见，我们使用约定\(m \mid 0\)对所有整数\(m\)成立。
- en: '`divides` is an example of a function that is only defined for certain input
    values (integers). `divides` also gives an example of defining a custom printer
    (`_latex()`).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`divides`是一个仅对某些输入值（整数）定义的函数的示例。`divides`还展示了如何定义自定义打印器（`_latex()`）的示例。'
- en: Definition
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Examples
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: '**Evaluation**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估**'
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Printing:**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**打印：**'
- en: '[PRE70]  ### Fused Multiply-Add (FMA)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE70]  ### 融合乘加（FMA）'
- en: '[Fused Multiply-Add (FMA)](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add)
    is a multiplication followed by an addition:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[融合乘加（FMA）](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add)是一种先乘后加：'
- en: \[\operatorname{FMA}(x, y, z) = xy + z.\]
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: \[\operatorname{FMA}(x, y, z) = xy + z.\]
- en: It is often implemented in hardware as a single floating-point operation that
    has better rounding and performance than the equivalent combination of multiplication
    and addition operations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常在硬件上实现为单一浮点操作，具有比乘法和加法组合更好的舍入和性能。
- en: FMA is an example of a custom function that is defined as an unevaluated “shorthand”
    to another function. This is because the [`doit()`](#custom-functions-doit) method
    is defined to return `x*y + z`, meaning the `FMA` function can easily be evaluated
    to the expression is represents, but the [`eval()`](#custom-functions-eval) method
    does *not* return anything (except when `x`, `y`, and `z` are all explicit numeric
    values), meaning that it stays unevaluated by default.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: FMA是一个自定义函数的示例，它被定义为另一个函数的未评估的“缩写”。这是因为[`doit()`](#custom-functions-doit)方法被定义为返回`x*y
    + z`，这意味着`FMA`函数可以轻松地评估为它代表的表达式，但[`eval()`](#custom-functions-eval)方法并不返回任何内容（除非`x`、`y`和`z`都是明确的数值），这意味着默认情况下它保持未评估状态。
- en: Contrast this with the [versine](#custom-functions-versine-full-example) example,
    which treats `versin` as a first-class function in its own regard. Even though
    `versin(x)` can be expressed in terms of other functions (`1 - cos(x)`) it does
    not evaluate on general symbolic inputs in `versin.eval()`, and `versin.doit()`
    is not defined at all.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与[versine](#custom-functions-versine-full-example)示例相比，它将`versin`视为自己的一级函数。尽管`versin(x)`可以用其他函数（`1
    - cos(x)`）来表达，但在`versin.eval()`中不会对一般的符号输入进行评估，而且`versin.doit()`根本没有定义。
- en: '`FMA` also represents an example of a continuous function defined on multiple
    variables, which demonstrates how `argindex` works in the [`fdiff`](#custom-functions-differentiation)
    example.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`FMA`也是一个在多个变量上定义的连续函数的示例，它展示了在[`fdiff`](#custom-functions-differentiation)示例中`argindex`的工作方式。'
- en: Finally, `FMA` shows an example of defining some code printers for `C` and `C++`
    (using the method names from [`C99CodePrinter.printmethod`](../modules/printing.html#sympy.printing.c.C99CodePrinter.printmethod
    "sympy.printing.c.C99CodePrinter.printmethod") and [`CXX11CodePrinter.printmethod`](../modules/printing.html#sympy.printing.cxx.CXX11CodePrinter.printmethod
    "sympy.printing.cxx.CXX11CodePrinter.printmethod")), since that is a typical use-case
    for this function.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`FMA`展示了为`C`和`C++`定义一些代码打印器的示例（使用来自[`C99CodePrinter.printmethod`](../modules/printing.html#sympy.printing.c.C99CodePrinter.printmethod
    "sympy.printing.c.C99CodePrinter.printmethod")和[`CXX11CodePrinter.printmethod`](../modules/printing.html#sympy.printing.cxx.CXX11CodePrinter.printmethod
    "sympy.printing.cxx.CXX11CodePrinter.printmethod")的方法名称），因为这是该函数的典型用例。
- en: The mathematical definition of FMA is very simple and it would be easy to define
    every method on it, but only a handful are shown here. The [versine](#custom-functions-versine-full-example)
    and [divides](#custom-functions-divides-full-example) examples show how to define
    the other important methods discussed in this guide.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: FMA的数学定义非常简单，定义每种方法都很容易，但这里只展示了少数几种。[正弦](#custom-functions-versine-full-example)和[除法](#custom-functions-divides-full-example)示例展示了如何定义本指南讨论的其他重要方法。
- en: Note that if you want to actually use fused-multiply add for code generation,
    there is already a version in SymPy `sympy.codegen.cfunctions.fma()` which is
    supported by the existing code printers. The version here is only designed to
    serve as an example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您想要实际在代码生成中使用融合乘加法，SymPy中已经有一个版本`sympy.codegen.cfunctions.fma()`，它受现有代码打印机的支持。这里的版本仅设计为示例。
- en: Definition
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Examples
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例
- en: '**Evaluation:**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**评估：**'
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**Differentiation**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**微分**'
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '**Code Printers**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码打印机**'
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Additional Tips
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加提示
- en: SymPy includes dozens of functions. These can serve as useful examples for how
    to write a custom function, especially if the function is similar to one that
    is already implemented. Remember that everything in this guide applies equally
    well to functions that are included with SymPy and user-defined functions. Indeed,
    this guide is designed to serve as both a developer guide for contributors to
    SymPy and a guide for end-users of SymPy.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy包含数十个函数。这些可以作为编写自定义函数的有用示例，特别是如果函数类似于已实现的函数。请记住，本指南中的所有内容同样适用于SymPy中包含的函数和用户定义的函数。实际上，本指南旨在既是SymPy贡献者的开发指南，也是SymPy最终用户的指南。
- en: If you have many custom functions that share common logic, you can use a common
    base class to contain this shared logic. For an example of this, see the [source
    code for the trigonometric functions in SymPy](https://github.com/sympy/sympy/blob/master/sympy/functions/elementary/trigonometric.py),
    which use `TrigonometricFunction`, `InverseTrigonometricFunction`, and `ReciprocalTrigonometricFunction`
    base classes with some shared logic.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有许多共享常规逻辑的自定义函数，可以使用一个通用的基类来包含这些共享逻辑。例如，请参阅[SymPy中三角函数的源代码](https://github.com/sympy/sympy/blob/master/sympy/functions/elementary/trigonometric.py)，其中使用了`TrigonometricFunction`、`InverseTrigonometricFunction`和`ReciprocalTrigonometricFunction`基类及其一些共享逻辑。
- en: As with any code, it is a good idea to write extensive tests for your function.
    The [SymPy test suite](https://github.com/sympy/sympy/tree/master/sympy/functions/elementary/tests)
    is a good resource for examples of how to write tests for such functions. All
    code included in SymPy itself is required to be tested. Functions included in
    SymPy should also always contain a docstring with references, a mathematical definition,
    and doctest examples.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与任何代码一样，为您的函数编写广泛的测试是一个好主意。[SymPy测试套件](https://github.com/sympy/sympy/tree/master/sympy/functions/elementary/tests)提供了有关如何为这些函数编写测试的示例。SymPy本身包含的所有代码都必须进行测试。SymPy包含的函数还应始终包含带有引用、数学定义和doctest示例的文档字符串。
- en: '* * *'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
