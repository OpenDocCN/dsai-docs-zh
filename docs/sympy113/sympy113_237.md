# 梁（文档字符串）

> 原始文本：[https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html](https://docs.sympy.org/latest/modules/physics/continuum_mechanics/beam.html)

该模块可用于解决力学中带有奇性函数的二维梁弯曲问题。

```py
class sympy.physics.continuum_mechanics.beam.Beam(length, elastic_modulus, second_moment, area=A, variable=x, base_char='C')
```

梁是一种通过抵抗弯曲主要承受载荷的结构元素。梁的特征在于其横截面轮廓（截面二阶矩）、长度和材料。

注意

在解决梁弯曲问题时必须使用一致的符号约定；结果将自动遵循所选择的符号约定。然而，所选择的符号约定必须遵守以下规则：在梁轴的正侧（相对于当前截面），给定正剪力的载荷力产生负弯矩，如下所示（弯曲箭头显示正弯矩和旋转）：

![../../../_images/allowed-sign-conventions.png](../Images/09403d8b67a9c7194953bc916710ce0e.png)

例子

有一根长度为 4 米的梁。从梁的中点到末端施加了一个恒定分布载荷 6 N/m。梁下面有两个简支，一个在起点，另一个在梁的终点。梁的末端受到限制。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols, Piecewise
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(4, E, I)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(6, 2, 0)
>>> b.apply_load(R2, 4, -1)
>>> b.bc_deflection = [(0, 0), (4, 0)]
>>> b.boundary_conditions
{'deflection': [(0, 0), (4, 0)], 'slope': []}
>>> b.load
R1*SingularityFunction(x, 0, -1) + R2*SingularityFunction(x, 4, -1) + 6*SingularityFunction(x, 2, 0)
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.load
-3*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 2, 0) - 9*SingularityFunction(x, 4, -1)
>>> b.shear_force()
3*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 2, 1) + 9*SingularityFunction(x, 4, 0)
>>> b.bending_moment()
3*SingularityFunction(x, 0, 1) - 3*SingularityFunction(x, 2, 2) + 9*SingularityFunction(x, 4, 1)
>>> b.slope()
(-3*SingularityFunction(x, 0, 2)/2 + SingularityFunction(x, 2, 3) - 9*SingularityFunction(x, 4, 2)/2 + 7)/(E*I)
>>> b.deflection()
(7*x - SingularityFunction(x, 0, 3)/2 + SingularityFunction(x, 2, 4)/4 - 3*SingularityFunction(x, 4, 3)/2)/(E*I)
>>> b.deflection().rewrite(Piecewise)
(7*x - Piecewise((x**3, x >= 0), (0, True))/2
 - 3*Piecewise(((x - 4)**3, x >= 4), (0, True))/2
 + Piecewise(((x - 2)**4, x >= 2), (0, True))/4)/(E*I) 
```

计算长度为 L 的完全符号梁的支反应。梁下面有两个简支，一个在起点，另一个在梁的终点。梁的末端受到限制。梁上载荷为：

+   一个向下的点载荷 P1，在 L/4 处施加

+   一个向上的点载荷 P2，在 L/8 处施加

+   一个逆时针力矩 M1，在 L/2 处施加

+   一个顺时针力矩 M2，在 3*L/4 处施加

+   一个分布恒定载荷 q1，向下施加，从 L/2 开始到 3*L/4

+   一个分布恒定载荷 q2，向上施加，从 3*L/4 开始到 L

不需要为符号负载做任何假设。但是，定义一个正长度将有助于算法计算解决方案。

```py
>>> E, I = symbols('E, I')
>>> L = symbols("L", positive=True)
>>> P1, P2, M1, M2, q1, q2 = symbols("P1, P2, M1, M2, q1, q2")
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(L, E, I)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, L, -1)
>>> b.apply_load(P1, L/4, -1)
>>> b.apply_load(-P2, L/8, -1)
>>> b.apply_load(M1, L/2, -2)
>>> b.apply_load(-M2, 3*L/4, -2)
>>> b.apply_load(q1, L/2, 0, 3*L/4)
>>> b.apply_load(-q2, 3*L/4, 0, L)
>>> b.bc_deflection = [(0, 0), (L, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> print(b.reaction_loads[R1])
(-3*L**2*q1 + L**2*q2 - 24*L*P1 + 28*L*P2 - 32*M1 + 32*M2)/(32*L)
>>> print(b.reaction_loads[R2])
(-5*L**2*q1 + 7*L**2*q2 - 8*L*P1 + 4*L*P2 + 32*M1 - 32*M2)/(32*L) 
```

```py
property applied_loads
```

返回施加在梁对象上的所有载荷的列表。列表中的每个载荷都是形式为（值，起始，顺序，结束）的元组。

例子

有一根长度为 4 米的梁。在梁的起点以顺时针方向施加了一个大小为 3 Nm 的力矩。从距离起点 2 米处梁顶部施加了大小为 4 N 的点载荷。另一个大小为 5 N 的点载荷在同一位置施加。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(4, E, I)
>>> b.apply_load(-3, 0, -2)
>>> b.apply_load(4, 2, -1)
>>> b.apply_load(5, 2, -1)
>>> b.load
-3*SingularityFunction(x, 0, -2) + 9*SingularityFunction(x, 2, -1)
>>> b.applied_loads
[(-3, 0, -2, None), (4, 2, -1, None), (5, 2, -1, None)] 
```

```py
apply_load(value, start, order, end=None)
```

此方法将所给定的载荷加到特定的梁对象上。

参数：

**value**：可符号化

> 插入的值应具有单位 [Force/(Distance**(n+1)]，其中 n 是施加载荷的顺序。施加载荷的单位：
> 
> > +   对于弯矩，单位 = kN*m
> > +   
> > +   对于点载荷，单位 = kN
> > +   
> > +   对于恒定分布载荷，单位 = kN/m
> > +   
> > +   对于坡道载荷，单位 = kN/m/m
> > +   
> > +   对于抛物线坡道载荷，单位 = kN/m/m/m
> > +   
> > +   … 等等。

**start**：可符号化

> 应用载荷的起始点。对于点力和点力矩，这是应用位置。

**order**：整数

> 应用载荷的顺序。
> 
> > +   对于力矩，order = -2
> > +   
> > +   对于点载荷，order = -1
> > +   
> > +   对于恒定分布载荷，order = 0
> > +   
> > +   对于坡道载荷，order = 1
> > +   
> > +   对于抛物线坡道载荷，order = 2
> > +   
> > +   …等等。

**end**：可符号化，可选

> 如果载荷在梁的长度内有一个端点，则可以使用的可选参数。

示例

有一根长度为4米的梁。在梁的起点顺时针方向施加一个大小为3 Nm的力矩。从梁的顶部在距起点2米处施加一个大小为4 N的点载荷，以及在距离梁起点2米到3米处施加一个大小为2 N/m的抛物线坡道载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(4, E, I)
>>> b.apply_load(-3, 0, -2)
>>> b.apply_load(4, 2, -1)
>>> b.apply_load(-2, 2, 2, end=3)
>>> b.load
-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2) 
```

```py
apply_support(loc, type='fixed')
```

此方法将支持应用于特定的梁对象，并返回未知反应载荷符号。

参数：

**loc**：可符号化的

> 支座应用位置的点位。

**type**：字符串

> 确定应用的梁支座类型。要应用零自由度的支座结构，type = “fixed”；要应用一个自由度的支座结构，type = “pin”；要应用两个自由度的支座结构，type = “roller”

返回：

符号或符号元组

> 未知反应载荷作为符号。- 如果type = “pin”或“roller”，则为Symbol(reaction_force)；如果type = “fixed”，则为Symbol(reaction_force)，Symbol(reaction_moment)

示例

有一根长度为20米的梁。在梁的末端顺时针方向施加一个大小为100 Nm的力矩。从梁的顶部在距起点10米处施加一个大小为8 N的点载荷。在梁的起点有一个固定支座，末端有一个滚动支座。

使用上升力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(20, E, I)
>>> p0, m0 = b.apply_support(0, 'fixed')
>>> p1 = b.apply_support(20, 'roller')
>>> b.apply_load(-8, 10, -1)
>>> b.apply_load(100, 20, -2)
>>> b.solve_for_reaction_loads(p0, m0, p1)
>>> b.reaction_loads
{M_0: 20, R_0: -2, R_20: 10}
>>> b.reaction_loads[p0]
-2
>>> b.load
20*SingularityFunction(x, 0, -2) - 2*SingularityFunction(x, 0, -1)
- 8*SingularityFunction(x, 10, -1) + 100*SingularityFunction(x, 20, -2)
+ 10*SingularityFunction(x, 20, -1) 
```

```py
property area
```

梁的横截面积。

```py
bending_moment()
```

返回一个Singularity Function表达式，表示Beam对象的弯矩曲线。

示例

有一根长度为30米的梁。在梁的末端顺时针方向施加一个大小为120 Nm的力矩。从梁的起点顶部施加一个大小为8 N的点载荷。梁下有两个简支。一个在末端，另一个距起点10米处。在两个支座处都限制挠度。

使用上升力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(30, E, I)
>>> b.apply_load(-8, 0, -1)
>>> b.apply_load(R1, 10, -1)
>>> b.apply_load(R2, 30, -1)
>>> b.apply_load(120, 30, -2)
>>> b.bc_deflection = [(10, 0), (30, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.bending_moment()
8*SingularityFunction(x, 0, 1) - 6*SingularityFunction(x, 10, 1) - 120*SingularityFunction(x, 30, 0) - 2*SingularityFunction(x, 30, 1) 
```

```py
property boundary_conditions
```

返回应用在梁上的边界条件字典。字典有三个关键词，分别是moment、slope和deflection。每个关键词的值是一个元组列表，每个元组以(location, value)的格式表示边界条件的位置和值。

示例

有一根长度为4米的梁。在0处的弯矩应为4，在4处应为0。梁在0处的斜率应为1。挠度在0处应为2。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(4, E, I)
>>> b.bc_deflection = [(0, 2)]
>>> b.bc_slope = [(0, 1)]
>>> b.boundary_conditions
{'deflection': [(0, 2)], 'slope': [(0, 1)]} 
```

这里梁的挠度应在`0`处为`2`。类似地，梁在`0`处的斜率应为`1`。

```py
property cross_section
```

梁的横截面

```py
deflection()
```

返回表示梁弹性曲线或挠度的奇异函数表达式。

示例

有一根长度为30米的梁。在梁的末端顺时针方向施加了120 Nm大小的弯矩。从梁的起点顶部施加了8 N大小的点载荷。梁下方有两个简支。一个在梁的末端，另一个距起点10米处。在两个支座处限制挠度。

使用上升力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(30, E, I)
>>> b.apply_load(-8, 0, -1)
>>> b.apply_load(R1, 10, -1)
>>> b.apply_load(R2, 30, -1)
>>> b.apply_load(120, 30, -2)
>>> b.bc_deflection = [(10, 0), (30, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.deflection()
(4000*x/3 - 4*SingularityFunction(x, 0, 3)/3 + SingularityFunction(x, 10, 3)
 + 60*SingularityFunction(x, 30, 2) + SingularityFunction(x, 30, 3)/3 - 12000)/(E*I) 
```

```py
draw(pictorial=True)
```

返回表示梁图的绘图对象。特别是，图表可能包括：

+   梁。

+   垂直黑箭头代表点载荷和支反力（如果已使用`apply_load`方法添加）。

+   圆形箭头表示弯矩。

+   阴影区域表示分布载荷。

+   如果`apply_support`已执行。

+   如果使用`join`方法创建了复合梁，并指定了铰链，它将显示为白色圆盘。

图表显示梁的上侧正载荷和下侧负载荷。如果两个或更多分布载荷沿相同区域的相同方向作用，则函数将将它们相加。

注意

用户在输入载荷值时必须小心。绘图函数假定一种符号约定，用于绘制载荷。给定右手坐标系与XYZ坐标，假定梁的长度沿正X轴。绘图函数将正载荷（带有n > -2）识别为沿负Y方向作用的载荷和正力矩作用的正Z方向。

参数：

**图解**：布尔值（默认=True）

> 设置`pictorial=True`将仅创建梁图的图解（按比例缩放）。另一方面，`pictorial=False`将在图表上创建具有精确尺寸的梁图。

示例

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> P1, P2, M = symbols('P1, P2, M')
>>> E, I = symbols('E, I')
>>> b = Beam(50, 20, 30)
>>> b.apply_load(-10, 2, -1)
>>> b.apply_load(15, 26, -1)
>>> b.apply_load(P1, 10, -1)
>>> b.apply_load(-P2, 40, -1)
>>> b.apply_load(90, 5, 0, 23)
>>> b.apply_load(10, 30, 1, 50)
>>> b.apply_load(M, 15, -2)
>>> b.apply_load(-M, 30, -2)
>>> p50 = b.apply_support(50, "pin")
>>> p0, m0 = b.apply_support(0, "fixed")
>>> p20 = b.apply_support(20, "roller")
>>> p = b.draw()  
>>> p  
Plot object containing:
[0]: cartesian line: 25*SingularityFunction(x, 5, 0) - 25*SingularityFunction(x, 23, 0)
+ SingularityFunction(x, 30, 1) - 20*SingularityFunction(x, 50, 0)
- SingularityFunction(x, 50, 1) + 5 for x over (0.0, 50.0)
[1]: cartesian line: 5 for x over (0.0, 50.0)
...
>>> p.show() 
```

([`png`](../../../_downloads/bda8f8d60633ec72f3551c29244f94d5/beam-1.png), [`hires.png`](../../../_downloads/3decd7120d816c8190c63dffb192484f/beam-1.hires.png), [`pdf`](../../../_downloads/0a5b397c3adc07987864b0441654dc1c/beam-1.pdf))

![../../../_images/beam-1.png](../Images/5b4d806f6a41edc308c1bae832b1bd69.png)

```py
property elastic_modulus
```

杨氏模量的梁。

```py
property ild_moment
```

返回I.L.D.弯矩方程。

```py
property ild_reactions
```

返回一个字典，表示I.L.D.反力。

```py
property ild_shear
```

返回I.L.D.剪切方程。

```py
join(beam, via='fixed')
```

此方法将两个梁连接以形成新的复合梁系统。传递的Beam类实例附加到调用对象的右端。此方法可用于形成具有弹性模量或二阶矩不连续值的梁。

参数：

**梁**：Beam类对象

> 将与调用对象右侧连接的Beam对象。

**通过**：字符串

> 说明两个梁对象如何连接 - 对于轴向固定的梁，通过=”fixed” - 对于通过铰链连接的梁，通过=”hinge”

示例

有一根长度为4米的悬臂梁。前2米的惯性矩为\(1.5*I\)，末端为\(I\)。在自由端施加一个大小为4 N的点载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b1 = Beam(2, E, 1.5*I)
>>> b2 = Beam(2, E, I)
>>> b = b1.join(b2, "fixed")
>>> b.apply_load(20, 4, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 0, -2)
>>> b.bc_slope = [(0, 0)]
>>> b.bc_deflection = [(0, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.load
80*SingularityFunction(x, 0, -2) - 20*SingularityFunction(x, 0, -1) + 20*SingularityFunction(x, 4, -1)
>>> b.slope()
(-((-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))/I + 120/I)/E + 80.0/(E*I))*SingularityFunction(x, 2, 0)
- 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 0, 0)/(E*I)
+ 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 2, 0)/(E*I) 
```

```py
property length
```

梁的长度。

```py
property load
```

返回表示梁对象载荷分布曲线的奇异函数表达式。

示例

有一根长度为4米的梁。在梁的起点顺时针方向施加一个大小为3 Nm的弯矩。从梁的起点2米处顶部施加一个4 N的点载荷，以及从梁的起点3米处开始施加大小为2 N/m的抛物线坡度载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(4, E, I)
>>> b.apply_load(-3, 0, -2)
>>> b.apply_load(4, 2, -1)
>>> b.apply_load(-2, 3, 2)
>>> b.load
-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 3, 2) 
```

```py
max_bmoment()
```

返回梁对象中最大剪力及其坐标。

```py
max_deflection()
```

返回梁对象中最大挠度点及其对应的挠度值。

```py
max_shear_force()
```

返回梁对象中最大剪力及其坐标。

```py
plot_bending_moment(subs=None)
```

返回梁对象中弯矩曲线的绘图。

参数：

**subs**：字典

> 包含符号作为键和相应值的 Python 字典。

示例

有一根长度为8米的梁。从梁的中点到末端施加一个10 KN/m的恒定分布载荷。梁下方有两个简支，一个在起点，另一个在终点。此外，从梁顶部距起点4米处施加一个5 KN的点载荷。取 E = 200 GPa 和 I = 400*(10**-6) 米**4。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6))
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.plot_bending_moment()
Plot object containing:
[0]: cartesian line: 13750*SingularityFunction(x, 0, 1) - 5000*SingularityFunction(x, 2, 1)
- 5000*SingularityFunction(x, 4, 2) + 31250*SingularityFunction(x, 8, 1)
+ 5000*SingularityFunction(x, 8, 2) for x over (0.0, 8.0) 
```

([`png`](../../../_downloads/4ae6d6df6c19a55651fc1c9ab59b5847/beam-2.png), [`hires.png`](../../../_downloads/e67019827ad24052c2db4c90881ab27c/beam-2.hires.png), [`pdf`](../../../_downloads/0249fb66c2fcb06b78bd6a84135be88a/beam-2.pdf))

![../../../_images/beam-2.png](../Images/680dff213700f06b205db3ec85170664.png)

```py
plot_deflection(subs=None)
```

返回梁对象挠曲线的绘图。

参数：

**subs**：字典

> 包含符号作为键和相应值的 Python 字典。

示例

有一根长度为8米的梁。从梁的中点到末端施加一个10 KN/m的恒定分布载荷。梁下方有两个简支，一个在起点，另一个在终点。此外，从梁顶部距起点4米处施加一个5 KN的点载荷。取 E = 200 GPa 和 I = 400*(10**-6) 米**4。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6))
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.plot_deflection()
Plot object containing:
[0]: cartesian line: 0.00138541666666667*x - 2.86458333333333e-5*SingularityFunction(x, 0, 3)
+ 1.04166666666667e-5*SingularityFunction(x, 2, 3) + 5.20833333333333e-6*SingularityFunction(x, 4, 4)
- 6.51041666666667e-5*SingularityFunction(x, 8, 3) - 5.20833333333333e-6*SingularityFunction(x, 8, 4)
for x over (0.0, 8.0) 
```

([`png`](../../../_downloads/07a7f8a32f3d02eb0e00c9556ef858c0/beam-3.png), [`hires.png`](../../../_downloads/5460f5631bdffd0dab4503851e760049/beam-3.hires.png), [`pdf`](../../../_downloads/a45cb86364a3602f7138b4466beb1097/beam-3.pdf))

![../../../_images/beam-3.png](../Images/08a1f605036b5f6b449806154f0ee11d.png)

```py
plot_ild_moment(subs=None)
```

在移动载荷的作用下，为弯矩作用线图绘制函数。此函数应在调用solve_for_ild_moment()后调用。

参数：

**subs**：字典

> 包含符号作为键和相应值的Python字典。

示例

有一根长度为12米的梁。梁下方有两个简支，一个在起点，另一个在8米处。在1kN移动载荷的作用下，在距离起点4米处的弯矩I.L.D.作图。

使用下行力的符号约定为正。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_8 = symbols('R_0, R_8')
>>> b = Beam(12, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p8 = b.apply_support(8, 'roller')
>>> b.solve_for_ild_reactions(1, R_0, R_8)
>>> b.solve_for_ild_moment(4, 1, R_0, R_8)
>>> b.ild_moment
Piecewise((-x/2, x < 4), (x/2 - 4, x > 4))
>>> b.plot_ild_moment()
Plot object containing:
[0]: cartesian line: Piecewise((-x/2, x < 4), (x/2 - 4, x > 4)) for x over (0.0, 12.0) 
```

([`png`](../../../_downloads/acfe5e933dd465aa78b8f547596a97df/beam-4.png), [`hires.png`](../../../_downloads/aec2a33160b26b078a19cc9d327d770a/beam-4.hires.png), [`pdf`](../../../_downloads/9659cd876877dfc4002fae48de3c98ae/beam-4.pdf))

![../../../_images/beam-4.png](../Images/3f8564eadd111fd10dad1c8a2e4782e8.png)

```py
plot_ild_reactions(subs=None)
```

在移动载荷的作用下，为反力作用线图绘制函数。此函数应在调用solve_for_ild_reactions()后调用。

参数：

**subs**：字典

> 包含符号作为键和相应值的Python字典。

示例

有一根长度为10米的梁。梁上还施加了一个大小为5KN的点载荷，距离起点4米处。梁下方有两个简支，一个位于起点，另一个距离起点7米处。在1kN移动载荷的作用下，在两个支点处的反应作用线方程作图。

使用下行力的符号约定为正。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_7 = symbols('R_0, R_7')
>>> b = Beam(10, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p7 = b.apply_support(7, 'roller')
>>> b.apply_load(5,4,-1)
>>> b.solve_for_ild_reactions(1,R_0,R_7)
>>> b.ild_reactions
{R_0: x/7 - 22/7, R_7: -x/7 - 20/7}
>>> b.plot_ild_reactions()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: x/7 - 22/7 for x over (0.0, 10.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -x/7 - 20/7 for x over (0.0, 10.0) 
```

([`png`](../../../_downloads/258db898b5fc9220e90f312b0d8a0664/beam-5.png), [`hires.png`](../../../_downloads/a71eb0ee4707422432421ddbe1edee79/beam-5.hires.png), [`pdf`](../../../_downloads/0c7c1262b6b611b1944eed12f33413fe/beam-5.pdf))

![../../../_images/beam-5.png](../Images/38c1301d6dfed92f4f6536b4a02efa87.png)

```py
plot_ild_shear(subs=None)
```

在移动载荷的作用下，为剪力作用线图绘制函数。此函数应在调用solve_for_ild_shear()后调用。

参数：

**subs**：字典

> 包含符号作为键和相应值的Python字典。

示例

有一根长度为12米的梁。梁下方有两个简支，一个在起点，另一个在8米处。在1kN移动载荷的作用下，在距离起点4米处的剪力I.L.D.作图。

使用下行力的符号约定为正。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_8 = symbols('R_0, R_8')
>>> b = Beam(12, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p8 = b.apply_support(8, 'roller')
>>> b.solve_for_ild_reactions(1, R_0, R_8)
>>> b.solve_for_ild_shear(4, 1, R_0, R_8)
>>> b.ild_shear
Piecewise((x/8, x < 4), (x/8 - 1, x > 4))
>>> b.plot_ild_shear()
Plot object containing:
[0]: cartesian line: Piecewise((x/8, x < 4), (x/8 - 1, x > 4)) for x over (0.0, 12.0) 
```

([`png`](../../../_downloads/bfaac27a6d72a14feb92ef0f9a15d3d4/beam-6.png), [`hires.png`](../../../_downloads/feff690e1386d08ec258b07f347d3f30/beam-6.hires.png), [`pdf`](../../../_downloads/d4935c2256660a8a33a7af58457af366/beam-6.pdf))

![../../../_images/beam-6.png](../Images/fa590fb262b771c2915c3311a296685a.png)

```py
plot_loading_results(subs=None)
```

返回梁对象的剪力、弯矩、斜率和挠度的子图。

参数：

**subs**：字典

> Python 字典包含符号作为键和其对应值。

示例

有一根长度为 8 米的梁。从梁的中点至末端施加均布的 10 千牛每米的恒定分布载荷。梁下有两个简支，一个在起点，另一个在终点。梁顶部还施加了一个距起点 4 米处的大小为 5 千牛的集中力。取 E = 200 GPa 和 I = 400*(10**-6) 米^4。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6))
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> axes = b.plot_loading_results() 
```

([`png`](../../../_downloads/c90a1eb2fa76fda9b5b587b918fd48a8/beam-7.png), [`hires.png`](../../../_downloads/09e45152596ec7e55d1cb03e11c54d18/beam-7.hires.png), [`pdf`](../../../_downloads/d2c03725fdbe7104e13f46e3798a03e1/beam-7.pdf))

![../../../_images/beam-7.png](../Images/87cd1f059d7ababb1c270f98db7233c2.png)

```py
plot_shear_force(subs=None)
```

返回梁对象中存在的剪力图。

参数：

**subs**：字典

> Python 字典包含符号作为键和其对应值。

示例

有一根长度为 8 米的梁。从梁的中点至末端施加均布的 10 千牛每米的恒定分布载荷。梁下有两个简支，一个在起点，另一个在终点。梁顶部还施加了一个距起点 4 米处的大小为 5 千牛的集中力。取 E = 200 GPa 和 I = 400*(10**-6) 米^4。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6))
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.plot_shear_force()
Plot object containing:
[0]: cartesian line: 13750*SingularityFunction(x, 0, 0) - 5000*SingularityFunction(x, 2, 0)
- 10000*SingularityFunction(x, 4, 1) + 31250*SingularityFunction(x, 8, 0)
+ 10000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0) 
```

([`png`](../../../_downloads/c9a747e63c5cb17f43298a8a4c18a7d3/beam-8.png), [`hires.png`](../../../_downloads/67b83f7e0b28d09822388cab13b932b6/beam-8.hires.png), [`pdf`](../../../_downloads/2454d35ad3fc284cb67b6c619b4246c1/beam-8.pdf))

![../../../_images/beam-8.png](../Images/fba24de75f86223713cdfa02ad7c004b.png)

```py
plot_shear_stress(subs=None)
```

返回梁对象中存在的剪切应力图。

参数：

**subs**：字典

> Python 字典包含符号作为键和其对应值。

示例

有一根长度为 8 米、横截面积为 2 平方米的梁。从梁的中点至末端施加均布的 10 千牛每米的恒定分布载荷。梁下有两个简支，一个在起点，另一个在终点。梁顶部还施加了一个距起点 4 米处的大小为 5 千牛的集中力。取 E = 200 GPa 和 I = 400*(10**-6) 米^4。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6), 2)
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.plot_shear_stress()
Plot object containing:
[0]: cartesian line: 6875*SingularityFunction(x, 0, 0) - 2500*SingularityFunction(x, 2, 0)
- 5000*SingularityFunction(x, 4, 1) + 15625*SingularityFunction(x, 8, 0)
+ 5000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0) 
```

([`png`](../../../_downloads/d24d261c7e3b75d40c063e2d9faa4e30/beam-9.png), [`hires.png`](../../../_downloads/e27d7a7b2ee984ae5bf136da868b5325/beam-9.hires.png), [`pdf`](../../../_downloads/e8a5010f49b1076156ddfe2fa5fe6189/beam-9.pdf))

![../../../_images/beam-9.png](../Images/20e68554368b095c2e1baffc327e8cf7.png)

```py
plot_slope(subs=None)
```

返回梁对象挠度曲线的斜率图。

参数：

**subs**：字典

> Python字典，包含符号作为键和相应值。

示例

有一根长度为8米的梁。从梁的中点到末端施加大小为10 KN/m的常分布载荷。梁下有两个简支，一个在起点，另一个在梁的末端。从梁顶部距离起点4米处施加大小为5 KN的点载荷。取 E = 200 GPa 和 I = 400*(10**-6) 米的四次方。

使用向下力为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(8, 200*(10**9), 400*(10**-6))
>>> b.apply_load(5000, 2, -1)
>>> b.apply_load(R1, 0, -1)
>>> b.apply_load(R2, 8, -1)
>>> b.apply_load(10000, 4, 0, end=8)
>>> b.bc_deflection = [(0, 0), (8, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.plot_slope()
Plot object containing:
[0]: cartesian line: -8.59375e-5*SingularityFunction(x, 0, 2) + 3.125e-5*SingularityFunction(x, 2, 2)
+ 2.08333333333333e-5*SingularityFunction(x, 4, 3) - 0.0001953125*SingularityFunction(x, 8, 2)
- 2.08333333333333e-5*SingularityFunction(x, 8, 3) + 0.00138541666666667 for x over (0.0, 8.0) 
```

([`png`](../../../_downloads/905e948ffb067b67d535661f122c209e/beam-10.png), [`hires.png`](../../../_downloads/7e5bc2616f03b7b7978deed1de8bf1d4/beam-10.hires.png), [`pdf`](../../../_downloads/ef1b602db6b31a5b8d8b9d20a2410f41/beam-10.pdf))

![../../../_images/beam-10.png](../Images/1190d03ceb189edb4441d18bd4a83422.png)

```py
point_cflexure()
```

返回具有零弯矩的点集，并且梁对象的弯矩曲线从负变为正或反之亦然。

示例

有一个长度为10米的悬臂梁。梁下方有两个简支。一个在起点，另一个距离起点6米处。点载荷大小分别为10KN和20KN施加在距离起点2米和4米处。还有一个均匀分布载荷，从距离起点6米处开始，大小为3KN/m。使用向上力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(10, E, I)
>>> b.apply_load(-4, 0, -1)
>>> b.apply_load(-46, 6, -1)
>>> b.apply_load(10, 2, -1)
>>> b.apply_load(20, 4, -1)
>>> b.apply_load(3, 6, 0)
>>> b.point_cflexure()
[10/3] 
```

```py
property reaction_loads
```

返回字典中的反应力。

```py
remove_load(value, start, order, end=None)
```

此方法移除梁对象上的特定负载。如果传递的负载作为参数不在梁上，则返回一个 ValueError。

参数：

**值**：可符号化

> 应用载荷的大小。

**开始**：可符号化

> 应用载荷的起始点。对于点力矩和点力，这是应用位置。

**顺序**：整数

> 应用载荷的顺序。- 对于力矩，顺序= -2 - 对于点载荷，顺序= -1 - 对于恒定分布载荷，顺序= 0 - 对于斜坡载荷，顺序= 1 - 对于抛物线斜坡载荷，顺序= 2 - ... 依此类推。

**结束**：可符号化，可选

> 如果负载在梁的长度内有一个端点，可以使用可选参数。

示例

有一根长度为4米的梁。以顺时针方向在梁的起点施加大小为3 Nm的力矩。从梁顶部距离起点2米处施加大小为4 N的点载荷，以及从梁下方施加的大小为2 N/m的抛物线斜坡载荷，从距离梁起点3米处开始，一直延伸到2米处。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> b = Beam(4, E, I)
>>> b.apply_load(-3, 0, -2)
>>> b.apply_load(4, 2, -1)
>>> b.apply_load(-2, 2, 2, end=3)
>>> b.load
-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)
>>> b.remove_load(-2, 2, 2, end = 3)
>>> b.load
-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) 
```

```py
property second_moment
```

梁的截面二阶矩。

```py
shear_force()
```

返回表示梁对象的剪力曲线的奇异函数表达式。

示例

长度为30米的梁上施加了120 Nm的顺时针方向力矩。起始点上从梁顶施加了8 N的点载荷。梁下有两个简支，一个在末端，另一个距起点10米处。在两个支座处都限制了挠度。

使用向上力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(30, E, I)
>>> b.apply_load(-8, 0, -1)
>>> b.apply_load(R1, 10, -1)
>>> b.apply_load(R2, 30, -1)
>>> b.apply_load(120, 30, -2)
>>> b.bc_deflection = [(10, 0), (30, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.shear_force()
8*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 10, 0) - 120*SingularityFunction(x, 30, -1) - 2*SingularityFunction(x, 30, 0) 
```

```py
shear_stress()
```

返回表示梁对象的剪切应力曲线的表达式。

```py
slope()
```

返回一个表示梁对象弹性曲线斜率的奇异函数表达式。

示例

长度为30米的梁上施加了120 Nm的顺时针方向力矩。起始点上从梁顶施加了8 N的点载荷。梁下有两个简支，一个在末端，另一个距起点10米处。在两个支座处都限制了挠度。

使用向上力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(30, E, I)
>>> b.apply_load(-8, 0, -1)
>>> b.apply_load(R1, 10, -1)
>>> b.apply_load(R2, 30, -1)
>>> b.apply_load(120, 30, -2)
>>> b.bc_deflection = [(10, 0), (30, 0)]
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.slope()
(-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)
 + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I) 
```

```py
solve_for_ild_moment(distance, value, *reactions)
```

确定受移动载荷影响下特定点处弯矩影响线图方程。

参数：

**距离**：整数

> 点距离梁起点的距离，用于确定方程。

**数值**：整数

> 移动载荷的大小

**反力：**

> 施加在梁上的反力。

示例

长度为12米的梁。梁下有两个简支，一个在起点，另一个在距离8米处。计算在1kN移动载荷作用下，距离4米处的弯矩的I.L.D.方程。

使用向下力为正的符号约定。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_8 = symbols('R_0, R_8')
>>> b = Beam(12, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p8 = b.apply_support(8, 'roller')
>>> b.solve_for_ild_reactions(1, R_0, R_8)
>>> b.solve_for_ild_moment(4, 1, R_0, R_8)
>>> b.ild_moment
Piecewise((-x/2, x < 4), (x/2 - 4, x > 4)) 
```

```py
solve_for_ild_reactions(value, *reactions)
```

确定受移动载荷影响下特定点处反力影响线图方程。

参数：

**数值**：整数

> 移动载荷的大小

**反力：**

> 施加在梁上的反力。

示例

长度为10米的梁。梁下有两个简支，一个在起点，另一个在梁的末端。计算在1kN移动载荷作用下的反力的I.L.D.方程。

使用向下力为正的符号约定。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_10 = symbols('R_0, R_10')
>>> b = Beam(10, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p10 = b.apply_support(10, 'roller')
>>> b.solve_for_ild_reactions(1,R_0,R_10)
>>> b.ild_reactions
{R_0: x/10 - 1, R_10: -x/10} 
```

```py
solve_for_ild_shear(distance, value, *reactions)
```

确定受移动载荷影响下特定点处剪力影响线图方程。

参数：

**距离**：整数

> 点距离梁起点的距离，用于确定方程。

**数值**：整数

> 移动载荷的大小

**反力：**

> 施加在梁上的反力。

示例

长度为12米的梁。梁下有两个简支，一个在起点，另一个在距离8米处。计算在1kN移动载荷作用下，距离4米处的剪力的I.L.D.方程。

使用向下力为正的符号约定。

```py
>>> from sympy import symbols
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> E, I = symbols('E, I')
>>> R_0, R_8 = symbols('R_0, R_8')
>>> b = Beam(12, E, I)
>>> p0 = b.apply_support(0, 'roller')
>>> p8 = b.apply_support(8, 'roller')
>>> b.solve_for_ild_reactions(1, R_0, R_8)
>>> b.solve_for_ild_shear(4, 1, R_0, R_8)
>>> b.ild_shear
Piecewise((x/8, x < 4), (x/8 - 1, x > 4)) 
```

```py
solve_for_reaction_loads(*reactions)
```

解算反力。

示例

一根长度为30米的梁。在梁的末端以顺时针方向施加了120 Nm的力矩。从梁的起点顶部施加了8 N的点载荷。梁下方有两个简支点。一个在末端，另一个距离起点10米处。在两个支点处梁的挠度被限制。

使用向上力和顺时针力矩为正的符号约定。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I = symbols('E, I')
>>> R1, R2 = symbols('R1, R2')
>>> b = Beam(30, E, I)
>>> b.apply_load(-8, 0, -1)
>>> b.apply_load(R1, 10, -1)  # Reaction force at x = 10
>>> b.apply_load(R2, 30, -1)  # Reaction force at x = 30
>>> b.apply_load(120, 30, -2)
>>> b.bc_deflection = [(10, 0), (30, 0)]
>>> b.load
R1*SingularityFunction(x, 10, -1) + R2*SingularityFunction(x, 30, -1)
 - 8*SingularityFunction(x, 0, -1) + 120*SingularityFunction(x, 30, -2)
>>> b.solve_for_reaction_loads(R1, R2)
>>> b.reaction_loads
{R1: 6, R2: 2}
>>> b.load
-8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)
 + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1) 
```

```py
property variable
```

一个符号，可用作沿梁长度表示载荷分布、剪力曲线、弯矩、斜率曲线和挠度曲线的变量。默认情况下设置为`Symbol('x')`，但此属性可变。

示例

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam
>>> from sympy import symbols
>>> E, I, A = symbols('E, I, A')
>>> x, y, z = symbols('x, y, z')
>>> b = Beam(4, E, I)
>>> b.variable
x
>>> b.variable = y
>>> b.variable
y
>>> b = Beam(4, E, I, A, z)
>>> b.variable
z 
```

```py
class sympy.physics.continuum_mechanics.beam.Beam3D(length, elastic_modulus, shear_modulus, second_moment, area, variable=x)
```

此类处理施加在3D空间任意方向的载荷，以及不同轴向的二阶矩值不等的情况。

注意

在解决梁弯曲问题时必须使用一致的符号约定；结果将自动遵循所选择的符号约定。此类假设任何类型的分布载荷/力矩都施加在梁的跨度上。

示例

一根长度为l米的梁。从起点到梁末端沿y轴施加了大小为q的恒定分布载荷。从起点到梁末端沿z轴施加了大小为m的恒定分布力矩。梁在两端固定，因此两端的挠度被限制。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols, simplify, collect, factor
>>> l, E, G, I, A = symbols('l, E, G, I, A')
>>> b = Beam3D(l, E, G, I, A)
>>> x, q, m = symbols('x, q, m')
>>> b.apply_load(q, 0, 0, dir="y")
>>> b.apply_moment_load(m, 0, -1, dir="z")
>>> b.shear_force()
[0, -q*x, 0]
>>> b.bending_moment()
[0, 0, -m*x + q*x**2/2]
>>> b.bc_slope = [(0, [0, 0, 0]), (l, [0, 0, 0])]
>>> b.bc_deflection = [(0, [0, 0, 0]), (l, [0, 0, 0])]
>>> b.solve_slope_deflection()
>>> factor(b.slope())
[0, 0, x*(-l + x)*(-A*G*l**3*q + 2*A*G*l**2*q*x - 12*E*I*l*q
 - 72*E*I*m + 24*E*I*q*x)/(12*E*I*(A*G*l**2 + 12*E*I))]
>>> dx, dy, dz = b.deflection()
>>> dy = collect(simplify(dy), x)
>>> dx == dz == 0
True
>>> dy == (x*(12*E*I*l*(A*G*l**2*q - 2*A*G*l*m + 12*E*I*q)
... + x*(A*G*l*(3*l*(A*G*l**2*q - 2*A*G*l*m + 12*E*I*q) + x*(-2*A*G*l**2*q + 4*A*G*l*m - 24*E*I*q))
... + A*G*(A*G*l**2 + 12*E*I)*(-2*l**2*q + 6*l*m - 4*m*x + q*x**2)
... - 12*E*I*q*(A*G*l**2 + 12*E*I)))/(24*A*E*G*I*(A*G*l**2 + 12*E*I)))
True 
```

参考资料

[[R729](#id1)]

[https://homes.civil.aau.dk/jc/FemteSemester/Beams3D.pdf](https://homes.civil.aau.dk/jc/FemteSemester/Beams3D.pdf)

```py
angular_deflection()
```

返回x的函数，描述由梁上x轴上的力矩引起的角偏转如何随x变化。

```py
apply_load(value, start, order, dir='y')
```

此方法将力载荷添加到特定的梁对象上。

参数：

**value** : 可用SymPy处理的类型

> 施加载荷的大小。

**dir** : 字符串

> 施加载荷的轴线。

**order** : 整数

> 施加载荷的顺序。- 对于点载荷，order=-1 - 对于恒定分布载荷，order=0 - 对于斜坡载荷，order=1 - 对于抛物线斜坡载荷，order=2 - ...以此类推。

```py
apply_moment_load(value, start, order, dir='y')
```

此方法将力矩载荷添加到特定的梁对象上。

参数：

**value** : 可用SymPy处理的类型

> 施加力矩的大小。

**dir** : 字符串

> 施加力矩的轴线。

**order** : 整数

> 施加载荷的顺序。- 对于点力矩，order=-2 - 对于恒定分布力矩，order=-1 - 对于斜坡力矩，order=0 - 对于抛物线斜坡力矩，order=1 - ...以此类推。

```py
property area
```

梁的横截面积。

```py
axial_force()
```

返回梁对象内部的轴向剪力表达式。

```py
axial_stress()
```

返回梁对象内部轴向应力的表达式。

```py
bending_moment()
```

返回三个表达式的列表，表示梁对象沿三个轴的弯矩曲线。

```py
property boundary_conditions
```

返回一个包含梁上应用的边界条件字典。字典有两个关键字，即斜率和挠度。每个关键字的值是一个元组列表，每个元组包含格式为（位置，值）的边界条件的位置和值。进一步，每个值都是对应于该位置处三个轴上的斜率或挠度值的列表。

示例

有一根长度为4米的梁。在x轴上，起点处的斜率应为4，其他轴上为0。在梁的另一端，沿着所有三个轴的挠度应为零。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(30, E, G, I, A, x)
>>> b.bc_slope = [(0, (4, 0, 0))]
>>> b.bc_deflection = [(4, [0, 0, 0])]
>>> b.boundary_conditions
{'deflection': [(4, [0, 0, 0])], 'slope': [(0, (4, 0, 0))]} 
```

在这里，梁的挠度应在`4`处沿着所有三个轴为`0`。类似地，梁在`0`处沿x轴的斜率应为`4`，y轴和z轴为`0`。

```py
deflection()
```

返回一个表示梁上挠曲线的三元素列表。

```py
property load_vector
```

返回一个包含载荷向量的三元素列表。

```py
max_bending_moment()
```

返回梁对象中所有方向上最大弯矩点及其对应的弯矩值，作为列表。必须在使用此函数之前调用solve_for_reaction_loads()。

示例

有一根长度为20米的梁。两端支承于滚轮上。沿y轴施加斜率为12的线性载荷。沿z轴从起点到终点施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.max_bending_moment()
[(0, 0), (20, 3000), (20, 16000)] 
```

```py
max_bmoment()
```

返回梁对象中所有方向上最大弯矩点及其对应的弯矩值，作为列表。必须在使用此函数之前调用solve_for_reaction_loads()。

示例

有一根长度为20米的梁。两端支承于滚轮上。沿y轴施加斜率为12的线性载荷。沿z轴从起点到终点施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.max_bending_moment()
[(0, 0), (20, 3000), (20, 16000)] 
```

```py
max_deflection()
```

返回梁对象中所有方向上最大挠度点及其对应的挠度值，作为列表。必须在使用此函数之前调用solve_for_reaction_loads()和solve_slope_deflection()。

示例

有一根长度为20米的梁。两端支承于滚轮上。沿y轴施加斜率为12的线性载荷。沿z轴从起点到终点施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.solve_slope_deflection()
>>> b.max_deflection()
[(0, 0), (10, 495/14), (-10 + 10*sqrt(10793)/43, (10 - 10*sqrt(10793)/43)**3/160 - 20/7 + (10 - 10*sqrt(10793)/43)**4/6400 + 20*sqrt(10793)/301 + 27*(10 - 10*sqrt(10793)/43)**2/560)] 
```

```py
max_shear_force()
```

返回梁对象中所有方向上最大剪力点及其对应的剪力值，作为列表。必须在使用此函数之前调用solve_for_reaction_loads()。

示例

有一根长度为20米的梁。两端支承于滚轮上。沿y轴施加斜率为12的线性载荷。沿z轴从起点到终点施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.max_shear_force()
[(0, 0), (20, 2400), (20, 300)] 
```

```py
property moment_load_vector
```

返回一个表示梁上弯矩载荷的三元素列表。

```py
plot_bending_moment(dir='all', subs=None)
```

返回一个图表，显示梁对象中所有三个方向的弯矩。

参数：

**dir** ：字符串（默认

> 需要绘制弯矩图的方向。如果未指定方向，则显示所有图。

**subs** : dictionary

> 包含符号及其对应值的Python字典。

示例

一根长度为20米的梁。两端支承有滚轮。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, E, G, I, A, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.plot_bending_moment()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: 0 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: 2*x**3 for x over (0.0, 20.0) 
```

([`png`](../../../_downloads/f0f8e1bdd031df00e30e0398a5989813/beam-18.png), [`hires.png`](../../../_downloads/5b33d9d1c0dc39267d71cf3c54eff656/beam-18.hires.png), [`pdf`](../../../_downloads/b0f2a5ef738f9e96458a670bdb264732/beam-18.pdf))

![../../../_images/beam-18.png](../Images/48e11d9791857a58df721ba385497333.png)

```py
plot_deflection(dir='all', subs=None)
```

返回Beam对象中所有三个方向的挠曲图。

参数：

**dir** : string (default

> 需要绘制挠曲图的方向。如果未指定方向，则显示所有图。

**subs** : dictionary

> 包含符号及其对应值的Python字典。

示例

一根长度为20米的梁。两端支承有滚轮。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.solve_slope_deflection()
>>> b.plot_deflection()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: 0 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: x**4/6400 - x**3/160 + 27*x**2/560 + 2*x/7 for x over (0.0, 20.0) 
```

([`png`](../../../_downloads/72e058a8f8ac3d2782cf90e5cee1d49f/beam-19.png), [`hires.png`](../../../_downloads/1efbffba563b43e22c5a8a1f937d89b0/beam-19.hires.png), [`pdf`](../../../_downloads/865dedeca3d1430244910d89d552e5ef/beam-19.pdf))

![../../../_images/beam-19.png](../Images/ec91174e85f26987e6c09cc65d0f6fd1.png)

```py
plot_loading_results(dir='x', subs=None)
```

返回Beam对象沿指定方向的剪力、弯矩、斜率和挠曲的子图。

参数：

**dir** : string (default

> 需要绘制的方向。如果未指定方向，则显示沿x轴的图。

**subs** : dictionary

> 包含符号及其对应值的Python字典。

示例

一根长度为20米的梁。两端支承有滚轮。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15N的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, E, G, I, A, x)
>>> subs = {E:40, G:21, I:100, A:25}
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.solve_slope_deflection()
>>> b.plot_loading_results('y',subs)
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: -6*x**2 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)
Plot[3]:Plot object containing:
[0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0) 
```

([`png`](../../../_downloads/b0eaa2041724c93b5d1b4fc993f5be6e/beam-20.png), [`hires.png`](../../../_downloads/6499c7fcbfc2016e85ffaeeea39453bf/beam-20.hires.png), [`pdf`](../../../_downloads/4d0c9c96647fc2441757598f44d4936b/beam-20.pdf))

![../../../_images/beam-20.png](../Images/3ecc9a3a681923b5e52e6769c32d6c7c.png)

```py
plot_shear_force(dir='all', subs=None)
```

返回Beam对象中所有三个方向的剪力图。

参数：

**dir** : string (default

> 需要绘制剪力图的方向。如果未指定方向，则显示所有图。

**subs** : dictionary

> 包含符号及其对应值的Python字典。

示例

钢筋束的长度为20米。它由两端的滚轮支撑。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15牛顿的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, E, G, I, A, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.plot_shear_force()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: 0 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -6*x**2 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: -15*x for x over (0.0, 20.0) 
```

（[`png`](../../../_downloads/ce016d9a29791a6a0c68e5bffb9e042f/beam-21.png), [`hires.png`](../../../_downloads/646c1f03e2807a3aaffb373d586a9347/beam-21.hires.png), [`pdf`](../../../_downloads/0eb265c8614c7bd3f16f6034d076f6d3/beam-21.pdf))

![../../../_images/beam-21.png](../Images/f0c48ac2a05d37bd5b7aed32f64c1655.png)

```py
plot_shear_stress(dir='all', subs=None)
```

返回表示钢束对象沿所有三个方向的剪切应力曲线的图。

参数：

**dir**：字符串（默认

> 需要绘制剪切应力图的方向。如果未指定方向，则显示所有图形。

**subs**：字典

> 包含符号作为键和相应值的Python字典。

示例

钢筋束的长度为20米，横截面积为2平方米。它由两端的滚轮支撑。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15牛顿的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, E, G, I, 2, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.plot_shear_stress()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: 0 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -3*x**2 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: -15*x/2 for x over (0.0, 20.0) 
```

（[`png`](../../../_downloads/af74c5e451b113ec2fc59b35465420c1/beam-22.png), [`hires.png`](../../../_downloads/1a7c38a11093c30e891b6402fda22ebc/beam-22.hires.png), [`pdf`](../../../_downloads/cc4619d4e67ea48ddf5026828b7569eb/beam-22.pdf))

![../../../_images/beam-22.png](../Images/766d196f4197d33cfe571b2d8886dc87.png)

```py
plot_slope(dir='all', subs=None)
```

返回一个表示钢束对象沿所有三个方向的斜率的图。

参数：

**dir**：字符串（默认

> 需要绘制斜率图的方向。如果未指定方向，则显示所有图形。

**subs**：字典

> 包含符号作为键和相应值的Python字典。

示例

钢筋束的长度为20米。它由两端的滚轮支撑。沿y轴施加斜率为12的线性载荷。从起点到终点沿z轴施加15牛顿的恒定分布载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, 40, 21, 100, 25, x)
>>> b.apply_load(15, start=0, order=0, dir="z")
>>> b.apply_load(12*x, start=0, order=0, dir="y")
>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="z")
>>> b.apply_load(R2, start=20, order=-1, dir="z")
>>> b.apply_load(R3, start=0, order=-1, dir="y")
>>> b.apply_load(R4, start=20, order=-1, dir="y")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.solve_slope_deflection()
>>> b.plot_slope()
PlotGrid object containing:
Plot[0]:Plot object containing:
[0]: cartesian line: 0 for x over (0.0, 20.0)
Plot[1]:Plot object containing:
[0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)
Plot[2]:Plot object containing:
[0]: cartesian line: x**4/8000 - 19*x**2/172 + 52*x/43 for x over (0.0, 20.0) 
```

（[`png`](../../../_downloads/c647bea81df614079a6b2268e44b9c52/beam-23.png), [`hires.png`](../../../_downloads/2fe42062c75a8d1a5eaa2492b7f6a6ed/beam-23.hires.png), [`pdf`](../../../_downloads/02f5470280a542a7c80635a082cb7e09/beam-23.pdf))

![../../../_images/beam-23.png](../Images/22559a71c33bcf5e21b5aaf717c1cbc2.png)

```py
polar_moment()
```

返回关于质心的X轴的钢筋的极点矩。

示例

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A = symbols('l, E, G, I, A')
>>> b = Beam3D(l, E, G, I, A)
>>> b.polar_moment()
2*I
>>> I1 = [9, 15]
>>> b = Beam3D(l, E, G, I1, A)
>>> b.polar_moment()
24 
```

```py
property second_moment
```

钢筋的截面惯性矩。

```py
shear_force()
```

返回表示钢束对象沿所有三个轴的剪切力曲线的三个表达式列表。

```py
property shear_modulus
```

钢筋的杨氏模量。

```py
shear_stress()
```

返回表示钢束对象沿所有三个轴的剪切应力曲线的三个表达式列表。

```py
slope()
```

返回表示钢束对象沿所有三个轴的挠度曲线斜率的三个元素列表。

```py
solve_for_reaction_loads(*reaction)
```

解决反应力问题。

示例

有一根长度为30米的梁。它在两端由滚轮支撑。从起点到终点沿着y轴施加8 N的恒定分布载荷。沿着z轴施加斜率为9的线性载荷。

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(30, E, G, I, A, x)
>>> b.apply_load(8, start=0, order=0, dir="y")
>>> b.apply_load(9*x, start=0, order=0, dir="z")
>>> b.bc_deflection = [(0, [0, 0, 0]), (30, [0, 0, 0])]
>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')
>>> b.apply_load(R1, start=0, order=-1, dir="y")
>>> b.apply_load(R2, start=30, order=-1, dir="y")
>>> b.apply_load(R3, start=0, order=-1, dir="z")
>>> b.apply_load(R4, start=30, order=-1, dir="z")
>>> b.solve_for_reaction_loads(R1, R2, R3, R4)
>>> b.reaction_loads
{R1: -120, R2: -120, R3: -1350, R4: -2700} 
```

```py
solve_for_torsion()
```

解决由于在x方向施加的扭转矩而导致的角偏转，即从梁内或外施加。

这里，正扭矩意味着扭矩方向为正，即沿着梁轴向外。同样，负扭矩表示扭矩进入梁截面。

示例

```py
>>> from sympy.physics.continuum_mechanics.beam import Beam3D
>>> from sympy import symbols
>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')
>>> b = Beam3D(20, E, G, I, A, x)
>>> b.apply_moment_load(4, 4, -2, dir='x')
>>> b.apply_moment_load(4, 8, -2, dir='x')
>>> b.apply_moment_load(4, 8, -2, dir='x')
>>> b.solve_for_torsion()
>>> b.angular_deflection().subs(x, 3)
18/(G*I) 
```

```py
torsional_moment()
```

返回梁对象内存在的扭转力矩表达式。
