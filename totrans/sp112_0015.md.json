["```py\n>>> from scipy.ndimage import correlate\n>>> import numpy as np\n>>> correlate(np.arange(10), [1, 2.5])\narray([ 0,  2,  6,  9, 13, 16, 20, 23, 27, 30])\n>>> correlate(np.arange(10), [1, 2.5], output=np.float64)\narray([  0\\. ,   2.5,   6\\. ,   9.5,  13\\. ,  16.5,  20\\. ,  23.5,  27\\. ,  30.5]) \n```", "```py\n>>> footprint = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n>>> footprint\narray([[0, 1, 0],\n [1, 1, 1],\n [0, 1, 0]]) \n```", "```py\n>>> from scipy.ndimage import correlate1d\n>>> a = [0, 0, 0, 1, 0, 0, 0]\n>>> correlate1d(a, [1, 1, 1])\narray([0, 0, 1, 1, 1, 0, 0]) \n```", "```py\n>>> a = [0, 0, 0, 1, 0, 0, 0]\n>>> correlate1d(a, [1, 1, 1], origin = -1)\narray([0, 1, 1, 1, 0, 0, 0]) \n```", "```py\n>>> a = [0, 0, 1, 1, 1, 0, 0]\n>>> correlate1d(a, [-1, 1])               # backward difference\narray([ 0,  0,  1,  0,  0, -1,  0])\n>>> correlate1d(a, [-1, 1], origin = -1)  # forward difference\narray([ 0,  1,  0,  0, -1,  0,  0]) \n```", "```py\n>>> correlate1d(a, [0, -1, 1])\narray([ 0,  1,  0,  0, -1,  0,  0]) \n```", "```py\n    derivative2(input, axis, output, mode, cval, *extra_arguments, **extra_keywords) \n    ```", "```py\n    >>> def d2(input, axis, output, mode, cval):\n    ...     return correlate1d(input, [1, -2, 1], axis, output, mode, cval, 0)\n    ...\n    >>> a = np.zeros((5, 5))\n    >>> a[2, 2] = 1\n    >>> from scipy.ndimage import generic_laplace\n    >>> generic_laplace(a, d2)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  1., -4.,  1.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  0.,  0.,  0.,  0.]]) \n    ```", "```py\n    >>> def d2(input, axis, output, mode, cval, weights):\n    ...     return correlate1d(input, weights, axis, output, mode, cval, 0,)\n    ...\n    >>> a = np.zeros((5, 5))\n    >>> a[2, 2] = 1\n    >>> generic_laplace(a, d2, extra_arguments = ([1, -2, 1],))\n    array([[ 0.,  0.,  0.,  0.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  1., -4.,  1.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  0.,  0.,  0.,  0.]]) \n    ```", "```py\n    >>> generic_laplace(a, d2, extra_keywords = {'weights': [1, -2, 1]})\n    array([[ 0.,  0.,  0.,  0.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  1., -4.,  1.,  0.],\n     [ 0.,  0.,  1.,  0.,  0.],\n     [ 0.,  0.,  0.,  0.,  0.]]) \n    ```", "```py\n    derivative(input, axis, output, mode, cval, *extra_arguments, **extra_keywords) \n    ```", "```py\n    >>> a = np.zeros((5, 5))\n    >>> a[2, 2] = 1\n    >>> from scipy.ndimage import sobel, generic_gradient_magnitude\n    >>> generic_gradient_magnitude(a, sobel)\n    array([[ 0\\.        ,  0\\.        ,  0\\.        ,  0\\.        ,  0\\.        ],\n     [ 0\\.        ,  1.41421356,  2\\.        ,  1.41421356,  0\\.        ],\n     [ 0\\.        ,  2\\.        ,  0\\.        ,  2\\.        ,  0\\.        ],\n     [ 0\\.        ,  1.41421356,  2\\.        ,  1.41421356,  0\\.        ],\n     [ 0\\.        ,  0\\.        ,  0\\.        ,  0\\.        ,  0\\.        ]]) \n    ```", "```py\n    >>> a = np.arange(12).reshape(3,4)\n    >>> correlate1d(a, [1, 2, 3])\n    array([[ 3,  8, 14, 17],\n     [27, 32, 38, 41],\n     [51, 56, 62, 65]]) \n    ```", "```py\n    >>> def fnc(iline, oline):\n    ...     oline[...] = iline[:-2] + 2 * iline[1:-1] + 3 * iline[2:]\n    ...\n    >>> from scipy.ndimage import generic_filter1d\n    >>> generic_filter1d(a, fnc, 3)\n    array([[ 3,  8, 14, 17],\n     [27, 32, 38, 41],\n     [51, 56, 62, 65]]) \n    ```", "```py\n    >>> def fnc(iline, oline, a, b):\n    ...     oline[...] = iline[:-2] + a * iline[1:-1] + b * iline[2:]\n    ...\n    >>> generic_filter1d(a, fnc, 3, extra_arguments = (2, 3))\n    array([[ 3,  8, 14, 17],\n     [27, 32, 38, 41],\n     [51, 56, 62, 65]]) \n    ```", "```py\n    >>> generic_filter1d(a, fnc, 3, extra_keywords = {'a':2, 'b':3})\n    array([[ 3,  8, 14, 17],\n     [27, 32, 38, 41],\n     [51, 56, 62, 65]]) \n    ```", "```py\n    >>> a = np.arange(12).reshape(3,4)\n    >>> correlate(a, [[1, 0], [0, 3]])\n    array([[ 0,  3,  7, 11],\n     [12, 15, 19, 23],\n     [28, 31, 35, 39]]) \n    ```", "```py\n    >>> def fnc(buffer):\n    ...     return (buffer * np.array([1, 3])).sum()\n    ...\n    >>> from scipy.ndimage import generic_filter\n    >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]])\n    array([[ 0,  3,  7, 11],\n     [12, 15, 19, 23],\n     [28, 31, 35, 39]]) \n    ```", "```py\n    >>> def fnc(buffer, weights):\n    ...     weights = np.asarray(weights)\n    ...     return (buffer * weights).sum()\n    ...\n    >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]], extra_arguments = ([1, 3],))\n    array([[ 0,  3,  7, 11],\n     [12, 15, 19, 23],\n     [28, 31, 35, 39]]) \n    ```", "```py\n    >>> generic_filter(a, fnc, footprint = [[1, 0], [0, 1]], extra_keywords= {'weights': [1, 3]})\n    array([[ 0,  3,  7, 11],\n     [12, 15, 19, 23],\n     [28, 31, 35, 39]]) \n    ```", "```py\n>>> a = np.arange(12).reshape(3,4)\n>>>\n>>> class fnc_class:\n...     def __init__(self, shape):\n...         # store the shape:\n...         self.shape = shape\n...         # initialize the coordinates:\n...         self.coordinates = [0] * len(shape)\n...\n...     def filter(self, buffer):\n...         result = (buffer * np.array([1, 3])).sum()\n...         print(self.coordinates)\n...         # calculate the next coordinates:\n...         axes = list(range(len(self.shape)))\n...         axes.reverse()\n...         for jj in axes:\n...             if self.coordinates[jj] < self.shape[jj] - 1:\n...                 self.coordinates[jj] += 1\n...                 break\n...             else:\n...                 self.coordinates[jj] = 0\n...         return result\n...\n>>> fnc = fnc_class(shape = (3,4))\n>>> generic_filter(a, fnc.filter, footprint = [[1, 0], [0, 1]])\n[0, 0]\n[0, 1]\n[0, 2]\n[0, 3]\n[1, 0]\n[1, 1]\n[1, 2]\n[1, 3]\n[2, 0]\n[2, 1]\n[2, 2]\n[2, 3]\narray([[ 0,  3,  7, 11],\n [12, 15, 19, 23],\n [28, 31, 35, 39]]) \n```", "```py\n>>> a = np.arange(12).reshape(3,4)\n>>>\n>>> class fnc1d_class:\n...     def __init__(self, shape, axis = -1):\n...         # store the filter axis:\n...         self.axis = axis\n...         # store the shape:\n...         self.shape = shape\n...         # initialize the coordinates:\n...         self.coordinates = [0] * len(shape)\n...\n...     def filter(self, iline, oline):\n...         oline[...] = iline[:-2] + 2 * iline[1:-1] + 3 * iline[2:]\n...         print(self.coordinates)\n...         # calculate the next coordinates:\n...         axes = list(range(len(self.shape)))\n...         # skip the filter axis:\n...         del axes[self.axis]\n...         axes.reverse()\n...         for jj in axes:\n...             if self.coordinates[jj] < self.shape[jj] - 1:\n...                 self.coordinates[jj] += 1\n...                 break\n...             else:\n...                 self.coordinates[jj] = 0\n...\n>>> fnc = fnc1d_class(shape = (3,4))\n>>> generic_filter1d(a, fnc.filter, 3)\n[0, 0]\n[1, 0]\n[2, 0]\narray([[ 3,  8, 14, 17],\n [27, 32, 38, 41],\n [51, 56, 62, 65]]) \n```", "```py\n    >>> a = np.arange(12).reshape(4,3).astype(np.float64)\n    >>> def shift_func(output_coordinates):\n    ...     return (output_coordinates[0] - 0.5, output_coordinates[1] - 0.5)\n    ...\n    >>> from scipy.ndimage import geometric_transform\n    >>> geometric_transform(a, shift_func)\n    array([[ 0\\.    ,  0\\.    ,  0\\.    ],\n     [ 0\\.    ,  1.3625,  2.7375],\n     [ 0\\.    ,  4.8125,  6.1875],\n     [ 0\\.    ,  8.2625,  9.6375]]) \n    ```", "```py\n    >>> def shift_func(output_coordinates, s0, s1):\n    ...     return (output_coordinates[0] - s0, output_coordinates[1] - s1)\n    ...\n    >>> geometric_transform(a, shift_func, extra_arguments = (0.5, 0.5))\n    array([[ 0\\.    ,  0\\.    ,  0\\.    ],\n     [ 0\\.    ,  1.3625,  2.7375],\n     [ 0\\.    ,  4.8125,  6.1875],\n     [ 0\\.    ,  8.2625,  9.6375]]) \n    ```", "```py\n    >>> geometric_transform(a, shift_func, extra_keywords = {'s0': 0.5, 's1': 0.5})\n    array([[ 0\\.    ,  0\\.    ,  0\\.    ],\n     [ 0\\.    ,  1.3625,  2.7375],\n     [ 0\\.    ,  4.8125,  6.1875],\n     [ 0\\.    ,  8.2625,  9.6375]]) \n    ```", "```py\n    >>> a = np.arange(12).reshape(4,3).astype(np.float64)\n    >>> a\n    array([[  0.,   1.,   2.],\n     [  3.,   4.,   5.],\n     [  6.,   7.,   8.],\n     [  9.,  10.,  11.]])\n    >>> from scipy.ndimage import map_coordinates\n    >>> map_coordinates(a, [[0.5, 2], [0.5, 1]])\n    array([ 1.3625,  7.]) \n    ```", "```py\n    >>> from scipy.ndimage import generate_binary_structure\n    >>> generate_binary_structure(2, 1)\n    array([[False,  True, False],\n     [ True,  True,  True],\n     [False,  True, False]], dtype=bool)\n    >>> generate_binary_structure(2, 2)\n    array([[ True,  True,  True],\n     [ True,  True,  True],\n     [ True,  True,  True]], dtype=bool) \n    ```", "```py\n>>> struct = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n>>> a = np.array([[1,0,0,0,0], [1,1,0,1,0], [0,0,1,1,0], [0,0,0,0,0]])\n>>> a\narray([[1, 0, 0, 0, 0],\n [1, 1, 0, 1, 0],\n [0, 0, 1, 1, 0],\n [0, 0, 0, 0, 0]])\n>>> from scipy.ndimage import binary_dilation\n>>> binary_dilation(np.zeros(a.shape), struct, -1, a, border_value=1)\narray([[ True, False, False, False, False],\n [ True,  True, False, False, False],\n [False, False, False, False, False],\n [False, False, False, False, False]], dtype=bool) \n```", "```py\n    >>> struct = generate_binary_structure(2, 1)\n    >>> struct\n    array([[False,  True, False],\n     [ True,  True,  True],\n     [False,  True, False]], dtype=bool)\n    >>> from scipy.ndimage import iterate_structure\n    >>> iterate_structure(struct, 2)\n    array([[False, False,  True, False, False],\n     [False,  True,  True,  True, False],\n     [ True,  True,  True,  True,  True],\n     [False,  True,  True,  True, False],\n     [False, False,  True, False, False]], dtype=bool)\n\n    If the origin of the original structure is equal to 0, then it is\n    also equal to 0 for the iterated structure. If not, the origin\n    must also be adapted if the equivalent of the *iterations*\n    erosions or dilations must be achieved with the iterated\n    structure. The adapted origin is simply obtained by multiplying\n    with the number of iterations. For convenience, the\n    :func:`iterate_structure` also returns the adapted origin if the\n    *origin* parameter is not ``None``:\n\n    .. code:: python\n\n     >>> iterate_structure(struct, 2, -1)\n     (array([[False, False,  True, False, False],\n     [False,  True,  True,  True, False],\n     [ True,  True,  True,  True,  True],\n     [False,  True,  True,  True, False],\n     [False, False,  True, False, False]], dtype=bool), [-2, -2]) \n    ```", "```py\n>>> a = np.array([[1,2,2,1,1,0],\n...               [0,2,3,1,2,0],\n...               [1,1,1,3,3,2],\n...               [1,1,1,1,2,1]])\n>>> np.where(a > 1, 1, 0)\narray([[0, 1, 1, 0, 0, 0],\n [0, 1, 1, 0, 1, 0],\n [0, 0, 0, 1, 1, 1],\n [0, 0, 0, 0, 1, 0]]) \n```", "```py\n    >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n    >>> s = [[0, 1, 0], [1,1,1], [0,1,0]]\n    >>> from scipy.ndimage import label\n    >>> label(a, s)\n    (array([[0, 1, 1, 0, 0, 0],\n     [0, 1, 1, 0, 2, 0],\n     [0, 0, 0, 2, 2, 2],\n     [0, 0, 0, 0, 2, 0]]), 2) \n    ```", "```py\n    >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n    >>> s = [[1,1,1], [1,1,1], [1,1,1]]\n    >>> label(a, s)[0]\n    array([[0, 1, 1, 0, 0, 0],\n     [0, 1, 1, 0, 1, 0],\n     [0, 0, 0, 1, 1, 1],\n     [0, 0, 0, 0, 1, 0]]) \n    ```", "```py\n    >>> l, n = label([1, 0, 1, 0, 1])\n    >>> l\n    array([1, 0, 2, 0, 3])\n    >>> l = np.where(l != 2, l, 0)\n    >>> l\n    array([1, 0, 0, 0, 3])\n    >>> label(l)[0]\n    array([1, 0, 0, 0, 2]) \n    ```", "```py\n    >>> input = np.array([[0, 0, 0, 0, 0, 0, 0],\n    ...                   [0, 1, 1, 1, 1, 1, 0],\n    ...                   [0, 1, 0, 0, 0, 1, 0],\n    ...                   [0, 1, 0, 0, 0, 1, 0],\n    ...                   [0, 1, 0, 0, 0, 1, 0],\n    ...                   [0, 1, 1, 1, 1, 1, 0],\n    ...                   [0, 0, 0, 0, 0, 0, 0]], np.uint8)\n    >>> markers = np.array([[1, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 2, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0]], np.int8)\n    >>> from scipy.ndimage import watershed_ift\n    >>> watershed_ift(input, markers)\n    array([[1, 1, 1, 1, 1, 1, 1],\n     [1, 1, 2, 2, 2, 1, 1],\n     [1, 2, 2, 2, 2, 2, 1],\n     [1, 2, 2, 2, 2, 2, 1],\n     [1, 2, 2, 2, 2, 2, 1],\n     [1, 1, 2, 2, 2, 1, 1],\n     [1, 1, 1, 1, 1, 1, 1]], dtype=int8) \n    ```", "```py\n    >>> markers = np.array([[0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 2, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 1]], np.int8)\n    >>> watershed_ift(input, markers)\n    array([[1, 1, 1, 1, 1, 1, 1],\n     [1, 1, 1, 1, 1, 1, 1],\n     [1, 1, 2, 2, 2, 1, 1],\n     [1, 1, 2, 2, 2, 1, 1],\n     [1, 1, 2, 2, 2, 1, 1],\n     [1, 1, 1, 1, 1, 1, 1],\n     [1, 1, 1, 1, 1, 1, 1]], dtype=int8) \n    ```", "```py\n    >>> markers = np.array([[0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 2, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, 0],\n    ...                     [0, 0, 0, 0, 0, 0, -1]], np.int8)\n    >>> watershed_ift(input, markers)\n    array([[-1, -1, -1, -1, -1, -1, -1],\n     [-1, -1,  2,  2,  2, -1, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1, -1,  2,  2,  2, -1, -1],\n     [-1, -1, -1, -1, -1, -1, -1]], dtype=int8) \n    ```", "```py\n    >>> watershed_ift(input, markers,\n    ...               structure = [[1,1,1], [1,1,1], [1,1,1]])\n    array([[-1, -1, -1, -1, -1, -1, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1,  2,  2,  2,  2,  2, -1],\n     [-1, -1, -1, -1, -1, -1, -1]], dtype=int8) \n    ```", "```py\n    >>> a = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n    >>> l, n = label(a)\n    >>> from scipy.ndimage import find_objects\n    >>> f = find_objects(l)\n    >>> a[f[0]]\n    array([[1, 1],\n     [1, 1]])\n    >>> a[f[1]]\n    array([[0, 1, 0],\n     [1, 1, 1],\n     [0, 1, 0]]) \n    ```", "```py\n    >>> from scipy.ndimage import find_objects\n    >>> find_objects([1, 0, 3, 4], max_label = 3)\n    [(slice(0, 1, None),), None, (slice(2, 3, None),)] \n    ```", "```py\n>>> image = np.arange(4 * 6).reshape(4, 6)\n>>> mask = np.array([[0,1,1,0,0,0],[0,1,1,0,1,0],[0,0,0,1,1,1],[0,0,0,0,1,0]])\n>>> labels = label(mask)[0]\n>>> slices = find_objects(labels) \n```", "```py\n>>> np.where(labels[slices[1]] == 2, image[slices[1]], 0).sum()\n80 \n```", "```py\n>>> from scipy.ndimage import sum as ndi_sum\n>>> ndi_sum(image, labels, 2)\n80 \n```", "```py\n>>> ndi_sum(image[slices[1]], labels[slices[1]], 2)\n80 \n```", "```py\n>>> ndi_sum(image, labels, [0, 2])\narray([178.0, 80.0]) \n```", "```py\nfrom scipy import ndimage\n\ndef transform(output_coordinates, shift):\n    input_coordinates = output_coordinates[0] - shift, output_coordinates[1] - shift\n    return input_coordinates\n\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nshift = 0.5\nprint(ndimage.geometric_transform(im, transform, extra_arguments=(shift,))) \n```", "```py\n/* example.c */\n\n#include  <Python.h>\n#include  <numpy/npy_common.h>\n\nstatic  int\n_transform(npy_intp  *output_coordinates,  double  *input_coordinates,\n  int  output_rank,  int  input_rank,  void  *user_data)\n{\n  npy_intp  i;\n  double  shift  =  *(double  *)user_data;\n\n  for  (i  =  0;  i  <  input_rank;  i++)  {\n  input_coordinates[i]  =  output_coordinates[i]  -  shift;\n  }\n  return  1;\n}\n\nstatic  char  *transform_signature  =  \"int (npy_intp *, double *, int, int, void *)\";\n\nstatic  PyObject  *\npy_get_transform(PyObject  *obj,  PyObject  *args)\n{\n  if  (!PyArg_ParseTuple(args,  \"\"))  return  NULL;\n  return  PyCapsule_New(_transform,  transform_signature,  NULL);\n}\n\nstatic  PyMethodDef  ExampleMethods[]  =  {\n  {\"get_transform\",  (PyCFunction)py_get_transform,  METH_VARARGS,  \"\"},\n  {NULL,  NULL,  0,  NULL}\n};\n\n/* Initialize the module */\nstatic  struct  PyModuleDef  example  =  {\n  PyModuleDef_HEAD_INIT,\n  \"example\",\n  NULL,\n  -1,\n  ExampleMethods,\n  NULL,\n  NULL,\n  NULL,\n  NULL\n};\n\nPyMODINIT_FUNC\nPyInit_example(void)\n{\n  return  PyModule_Create(&example);\n} \n```", "```py\nimport ctypes\nimport numpy as np\nfrom scipy import ndimage, LowLevelCallable\n\nfrom example import get_transform\n\nshift = 0.5\n\nuser_data = ctypes.c_double(shift)\nptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\ncallback = LowLevelCallable(get_transform(), ptr)\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nprint(ndimage.geometric_transform(im, callback)) \n```", "```py\n# example.py\nimport numpy as np\nimport ctypes\nfrom scipy import ndimage, LowLevelCallable\nfrom numba import cfunc, types, carray\n\n@cfunc(types.intc(types.CPointer(types.intp),\n                  types.CPointer(types.double),\n                  types.intc,\n                  types.intc,\n                  types.voidptr))\ndef transform(output_coordinates_ptr, input_coordinates_ptr,\n              output_rank, input_rank, user_data):\n    input_coordinates = carray(input_coordinates_ptr, (input_rank,))\n    output_coordinates = carray(output_coordinates_ptr, (output_rank,))\n    shift = carray(user_data, (1,), types.double)[0]\n\n    for i in range(input_rank):\n        input_coordinates[i] = output_coordinates[i] - shift\n\n    return 1\n\nshift = 0.5\n\n# Then call the function\nuser_data = ctypes.c_double(shift)\nptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\ncallback = LowLevelCallable(transform.ctypes, ptr)\n\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nprint(ndimage.geometric_transform(im, callback)) \n```", "```py\n# example.pyx\n\nfrom numpy cimport npy_intp as intp\n\ncdef api int transform(intp *output_coordinates, double *input_coordinates,\n                       int output_rank, int input_rank, void *user_data):\n    cdef intp i\n    cdef double shift = (<double *>user_data)[0]\n\n    for i in range(input_rank):\n        input_coordinates[i] = output_coordinates[i] - shift\n    return 1 \n```", "```py\n# script.py\n\nimport ctypes\nimport numpy as np\nfrom scipy import ndimage, LowLevelCallable\n\nimport example\n\nshift = 0.5\n\nuser_data = ctypes.c_double(shift)\nptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\ncallback = LowLevelCallable.from_cython(example, \"transform\", ptr)\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nprint(ndimage.geometric_transform(im, callback)) \n```", "```py\n/*\n example.c\n Needs to be compiled with \"gcc -std=c99 -shared -fPIC -o example.so example.c\"\n or similar\n */\n\n#include  <stdint.h>\n\nint\n_transform(intptr_t  *output_coordinates,  double  *input_coordinates,\n  int  output_rank,  int  input_rank,  void  *user_data)\n{\n  int  i;\n  double  shift  =  *(double  *)user_data;\n\n  for  (i  =  0;  i  <  input_rank;  i++)  {\n  input_coordinates[i]  =  output_coordinates[i]  -  shift;\n  }\n  return  1;\n} \n```", "```py\nimport os\nimport numpy as np\nfrom scipy import ndimage, LowLevelCallable\nimport cffi\n\n# Construct the FFI object, and copypaste the function declaration\nffi = cffi.FFI()\nffi.cdef(\"\"\"\nint _transform(intptr_t *output_coordinates, double *input_coordinates,\n int output_rank, int input_rank, void *user_data);\n\"\"\")\n\n# Open library\nlib = ffi.dlopen(os.path.abspath(\"example.so\"))\n\n# Do the function call\nuser_data = ffi.new('double *', 0.5)\ncallback = LowLevelCallable(lib._transform, user_data)\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nprint(ndimage.geometric_transform(im, callback)) \n```", "```py\n# script.py\n\nimport os\nimport ctypes\nimport numpy as np\nfrom scipy import ndimage, LowLevelCallable\n\nlib = ctypes.CDLL(os.path.abspath('example.so'))\n\nshift = 0.5\n\nuser_data = ctypes.c_double(shift)\nptr = ctypes.cast(ctypes.pointer(user_data), ctypes.c_void_p)\n\n# Ctypes has no built-in intptr type, so override the signature\n# instead of trying to get it via ctypes\ncallback = LowLevelCallable(lib._transform, ptr,\n    \"int _transform(intptr_t *, double *, int, int, void *)\")\n\n# Perform the call\nim = np.arange(12).reshape(4, 3).astype(np.float64)\nprint(ndimage.geometric_transform(im, callback)) \n```"]