- en: scipy.stats.fit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.fit.html#scipy.stats.fit](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.stats.fit.html#scipy.stats.fit)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fit a discrete or continuous distribution to data
  prefs: []
  type: TYPE_NORMAL
- en: Given a distribution, data, and bounds on the parameters of the distribution,
    return maximum likelihood estimates of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dist**[`scipy.stats.rv_continuous`](scipy.stats.rv_continuous.html#scipy.stats.rv_continuous
    "scipy.stats.rv_continuous") or [`scipy.stats.rv_discrete`](scipy.stats.rv_discrete.html#scipy.stats.rv_discrete
    "scipy.stats.rv_discrete")'
  prefs: []
  type: TYPE_NORMAL
- en: The object representing the distribution to be fit to the data.
  prefs: []
  type: TYPE_NORMAL
- en: '**data**1D array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The data to which the distribution is to be fit. If the data contain any of
    `np.nan`, `np.inf`, or -`np.inf`, the fit method will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**dict or sequence of tuples, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If a dictionary, each key is the name of a parameter of the distribution, and
    the corresponding value is a tuple containing the lower and upper bound on that
    parameter. If the distribution is defined only for a finite range of values of
    that parameter, no entry for that parameter is required; e.g., some distributions
    have parameters which must be on the interval [0, 1]. Bounds for parameters location
    (`loc`) and scale (`scale`) are optional; by default, they are fixed to 0 and
    1, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If a sequence, element *i* is a tuple containing the lower and upper bound on
    the *i*th parameter of the distribution. In this case, bounds for *all* distribution
    shape parameters must be provided. Optionally, bounds for location and scale may
    follow the distribution shape parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If a shape is to be held fixed (e.g. if it is known), the lower and upper bounds
    may be equal. If a user-provided lower or upper bound is beyond a bound of the
    domain for which the distribution is defined, the bound of the distribution’s
    domain will replace the user-provided value. Similarly, parameters which must
    be integral will be constrained to integral values within the user-provided bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**guess**dict or array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If a dictionary, each key is the name of a parameter of the distribution, and
    the corresponding value is a guess for the value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If a sequence, element *i* is a guess for the *i*th parameter of the distribution.
    In this case, guesses for *all* distribution shape parameters must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: If *guess* is not provided, guesses for the decision variables will not be passed
    to the optimizer. If *guess* is provided, guesses for any missing parameters will
    be set at the mean of the lower and upper bounds. Guesses for parameters which
    must be integral will be rounded to integral values, and guesses that lie outside
    the intersection of the user-provided bounds and the domain of the distribution
    will be clipped.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**{‘mle’, ‘mse’}'
  prefs: []
  type: TYPE_NORMAL
- en: With `method="mle"` (default), the fit is computed by minimizing the negative
    log-likelihood function. A large, finite penalty (rather than infinite negative
    log-likelihood) is applied for observations beyond the support of the distribution.
    With `method="mse"`, the fit is computed by minimizing the negative log-product
    spacing function. The same penalty is applied for observations beyond the support.
    We follow the approach of [[1]](#ra4db2bb0bf1d-1), which is generalized for samples
    with repeated observations.
  prefs: []
  type: TYPE_NORMAL
- en: '**optimizer**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: '*optimizer* is a callable that accepts the following positional argument.'
  prefs: []
  type: TYPE_NORMAL
- en: funcallable
  prefs: []
  type: TYPE_NORMAL
- en: The objective function to be optimized. *fun* accepts one argument `x`, candidate
    shape parameters of the distribution, and returns the objective function value
    given `x`, *dist*, and the provided *data*. The job of *optimizer* is to find
    values of the decision variables that minimizes *fun*.
  prefs: []
  type: TYPE_NORMAL
- en: '*optimizer* must also accept the following keyword argument.'
  prefs: []
  type: TYPE_NORMAL
- en: boundssequence of tuples
  prefs: []
  type: TYPE_NORMAL
- en: The bounds on values of the decision variables; each element will be a tuple
    containing the lower and upper bound on a decision variable.
  prefs: []
  type: TYPE_NORMAL
- en: If *guess* is provided, *optimizer* must also accept the following keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: x0array_like
  prefs: []
  type: TYPE_NORMAL
- en: The guesses for each decision variable.
  prefs: []
  type: TYPE_NORMAL
- en: If the distribution has any shape parameters that must be integral or if the
    distribution is discrete and the location parameter is not fixed, *optimizer*
    must also accept the following keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: integralityarray_like of bools
  prefs: []
  type: TYPE_NORMAL
- en: For each decision variable, True if the decision variable must be constrained
    to integer values and False if the decision variable is continuous.
  prefs: []
  type: TYPE_NORMAL
- en: '*optimizer* must return an object, such as an instance of [`scipy.optimize.OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult"), which holds the optimal values of the decision
    variables in an attribute `x`. If attributes `fun`, `status`, or `message` are
    provided, they will be included in the result object returned by [`fit`](#scipy.stats.fit
    "scipy.stats.fit").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**result**[`FitResult`](scipy.stats._result_classes.FitResult.html#scipy.stats._result_classes.FitResult
    "scipy.stats._result_classes.FitResult")'
  prefs: []
  type: TYPE_NORMAL
- en: An object with the following fields.
  prefs: []
  type: TYPE_NORMAL
- en: paramsnamedtuple
  prefs: []
  type: TYPE_NORMAL
- en: A namedtuple containing the maximum likelihood estimates of the shape parameters,
    location, and (if applicable) scale of the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: successbool or None
  prefs: []
  type: TYPE_NORMAL
- en: Whether the optimizer considered the optimization to terminate successfully
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: messagestr or None
  prefs: []
  type: TYPE_NORMAL
- en: Any status message provided by the optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object has the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: nllf(params=None, data=None)
  prefs: []
  type: TYPE_NORMAL
- en: By default, the negative log-likehood function at the fitted *params* for the
    given *data*. Accepts a tuple containing alternative shapes, location, and scale
    of the distribution and an array of alternative data.
  prefs: []
  type: TYPE_NORMAL
- en: plot(ax=None)
  prefs: []
  type: TYPE_NORMAL
- en: Superposes the PDF/PMF of the fitted distribution over a normalized histogram
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rv_continuous`](scipy.stats.rv_continuous.html#scipy.stats.rv_continuous
    "scipy.stats.rv_continuous"), [`rv_discrete`](scipy.stats.rv_discrete.html#scipy.stats.rv_discrete
    "scipy.stats.rv_discrete")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Optimization is more likely to converge to the maximum likelihood estimate when
    the user provides tight bounds containing the maximum likelihood estimate. For
    example, when fitting a binomial distribution to data, the number of experiments
    underlying each sample may be known, in which case the corresponding shape parameter
    `n` can be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shao, Yongzhao, and Marjorie G. Hahn. “Maximum product of spacings method:
    a unified formulation with illustration of strong consistency.” Illinois Journal
    of Mathematics 43.3 (1999): 489-499.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we wish to fit a distribution to the following data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we do not know how the data were generated, but we suspect that it follows
    a negative binomial distribution with parameters *n* and *p*. (See [`scipy.stats.nbinom`](scipy.stats.nbinom.html#scipy.stats.nbinom
    "scipy.stats.nbinom").) We believe that the parameter *n* was fewer than 30, and
    we know that the parameter *p* must lie on the interval [0, 1]. We record this
    information in a variable *bounds* and pass this information to [`fit`](#scipy.stats.fit
    "scipy.stats.fit").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[`fit`](#scipy.stats.fit "scipy.stats.fit") searches within the user-specified
    *bounds* for the values that best match the data (in the sense of maximum likelihood
    estimation). In this case, it found shape values similar to those from which the
    data were actually generated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can visualize the results by superposing the probability mass function of
    the distribution (with the shapes fit to the data) over a normalized histogram
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-stats-fit-1_00_00.png](../Images/77ecab0630e92f1c578c1556267effba.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the estimate for *n* was exactly integral; this is because the domain
    of the [`nbinom`](scipy.stats.nbinom.html#scipy.stats.nbinom "scipy.stats.nbinom")
    PMF includes only integral *n*, and the [`nbinom`](scipy.stats.nbinom.html#scipy.stats.nbinom
    "scipy.stats.nbinom") object “knows” that. [`nbinom`](scipy.stats.nbinom.html#scipy.stats.nbinom
    "scipy.stats.nbinom") also knows that the shape *p* must be a value between 0
    and 1\. In such a case - when the domain of the distribution with respect to a
    parameter is finite - we are not required to specify bounds for the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we wish to force the distribution to be fit with *n* fixed at 6, we can set
    both the lower and upper bounds on *n* to 6\. Note, however, that the value of
    the objective function being optimized is typically worse (higher) in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the numerical results of the previous examples are typical, but they
    may vary because the default optimizer used by [`fit`](#scipy.stats.fit "scipy.stats.fit"),
    [`scipy.optimize.differential_evolution`](scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution
    "scipy.optimize.differential_evolution"), is stochastic. However, we can customize
    the settings used by the optimizer to ensure reproducibility - or even use a different
    optimizer entirely - using the *optimizer* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
