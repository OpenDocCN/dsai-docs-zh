# 数组 API 标准兼容性

> 原文：[`numpy.org/doc/1.26/reference/array_api.html`](https://numpy.org/doc/1.26/reference/array_api.html)

注意

`numpy.array_api` 模块仍处于实验阶段。请参阅 [NEP 47](https://numpy.org/neps/nep-0047-array-api-standard.html)。

NumPy 在 `numpy.array_api` 中包含了 [array API standard](https://data-apis.org/array-api/latest/) 的参考实现。[NEP 47](https://numpy.org/neps/nep-0047-array-api-standard.html) 描述了在 NumPy 中��现数组 API 标准的动机和范围。

`numpy.array_api` 模块作为数组 API 标准的最小参考实现。作为最小实现，该模块仅实现了规范明确要求的内容。规范允许某些内容，但在 `numpy.array_api` 中明确禁止。这样，该模块可以作为数组 API 标准的用户的参考实现。任何使用数组 API 的用户都可以针对 `numpy.array_api` 测试其代码，并确保他们没有使用规范中未保证的功能，也可能不存在于其他符合规范的库中。

`numpy.array_api` 模块在此处未记录。要查看数组 API 规范中存在的函数列表，请参考 [array API standard](https://data-apis.org/array-api/latest/)。`numpy.array_api` 实现是功能完整的，因此实现了规范中描述的所有功能。

## `numpy.array_api` 与 `numpy` 之间的差异表

该表格概述了 `numpy.array_api` 与主 `numpy` 命名空间之间的主要差异。有三种类型的差异：

1.  **严格性**。仅为了使 `numpy.array_api` 成为严格的、最小的实现而执行的操作。实际上，这些操作并不是规范要求的，其他符合规范的库可能不会遵循它们。在大多数情况下，规范并未指定或要求给定域之外的任何行为。主 `numpy` 命名空间不需要做任何更改才能符合这些规范。

1.  **兼容**。可以添加到主 `numpy` 命名空间而不会破坏向后兼容性的内容。

1.  **破坏性**。如果在主 `numpy` 命名空间中实现，将会破坏向后兼容性的内容。

### 名称差异

许多函数在规范中从 NumPy 重命名。除非另有说明，否则这些函数在行为上是相同的，因此都是**兼容**的更改。

#### 函数名称更改

以下函数在数组 API 中具有不同的名称

| 数组 API 名称 | NumPy 命名空间名称 | 注释 |
| --- | --- | --- |
| `acos` | `arccos` |  |
| `acosh` | `arccosh` |  |
| `asin` | `arcsin` |  |
| `asinh` | `arcsinh` |  |
| `atan` | `arctan` |  |
| `atan2` | `arctan2` |  |
| `atanh` | `arctanh` |  |
| `bitwise_left_shift` | `left_shift` |  |
| `bitwise_invert` | `invert` |  |
| `bitwise_right_shift` | `right_shift` |  |
| `bool` | `bool_` | 这是**破坏性的**，因为 `np.bool` 目前是内置 `bool` 的已弃用别名。 |
| `concat` | `concatenate` |  |
| `matrix_norm` 和 `vector_norm` | `norm` | `matrix_norm` 和 `vector_norm` 每个只执行 `np.norm` 的有限子集。 |
| `permute_dims` | `transpose` | 与 `np.transpose` 不同，`permute_dims` 的 `axis` 关键字参数是必需的。 |
| `pow` | `power` |  |
| `unique_all`、`unique_counts`、`unique_inverse` 和 `unique_values` | `unique` | 每个等效于设置了特定标志的 `np.unique`。 |

#### 函数而非方法

+   `astype` 是数组 API 中的一个函数，而在 `numpy` 中是 `ndarray` 的方法。

#### `linalg` 命名空间差异

这些函数在数组 API 的 `linalg` 子命名空间中，但在 NumPy 中仅在顶层命名空间中：

+   `cross`

+   `diagonal`

+   `matmul` (*)

+   `outer`

+   `tensordot` (*)

+   `trace`

(*): 这些函数也在数组 API 的顶层命名空间中。

#### 关键字参数重命名

以下函数具有已重命名的关键字参数。除非另有说明，否则关键字参数的功能是相同的。具有相同语义定义的重命名关键字参数可能被视为**兼容**或**破坏性**，具体取决于更改的实现方式。

注意，本页面不列出主 `numpy` 命名空间中存在但不在数组 API 中的函数关键字参数。为了**严格性**，`numpy.array_api` 中省略了这些关键字参数，因为规范允许函数包含额外的关键字参数。

| 函数 | 数组 API 关键字名称 | NumPy 关键字名称 | 注释 |
| --- | --- | --- | --- |
| `argsort` 和 `sort` | `stable` | `kind` | `stable` 和 `kind` 的定义不同，默认值也不同。默认值的更改使得这是**破坏性的**。请参见集合函数差异。 |
| `matrix_rank` | `rtol` | `tol` | `rtol` 和 `tol` 的定义不同，默认值也不同。默认值的更改使得这是**破坏性的**。请参见线性代数差异。 |
| `pinv` | `rtol` | `rcond` | `rtol` 和 `rcond` 的定义相同，但它们的默认值不同，这是**破坏性的**。请参见线性代数差异。 |
| `std` 和 `var` | `correction` | `ddof` |  |
| `reshape` | `shape` | `newshape` | 该参数可以作为 NumPy 和数组 API 的位置参数或关键字参数传递。 |

### 类型提升差异

类型提升是 NumPy 与规范最大的不同之处。最显著的区别是 NumPy 在许多情况下进行基于值的转换。规范明确禁止基于值的转换。在数组 API 中，任何操作的结果类型始终完全由输入类型确定，与值或形状无关。

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 有限的数据类型集合。 | **严格性** | `numpy.array_api` 仅实现了规范所需的那些 [数据类型](https://data-apis.org/array-api/latest/API_specification/data_types.html)。 |
| 与 Python 标量一起使用的运算符（如 `+`）仅接受匹配的标量类型。 | **严格性** | 例如，`<int32 array> + 1.0` 是不允许的。请参见 [规范中有关混合数组和 Python 标量的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)。 |
| 与 Python 标量一起使用的运算符（如 `+`）始终返回与数组相同的数据类型。 | **突破** | 例如，`numpy.array_api.asarray(0., dtype=float32) + 1e64` 是一个 `float32` 数组。 |
| 当左侧操作数会被提升时，不允许原地操作符。 | **突破** | 例如：`a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`。规范明确禁止这种情况。 |
| 当右侧操作数无法广播到左侧操作数的形状时，不允许原地操作符。 | **严格性** | 这种所谓的“反向广播”不应该被允许。例如：`a = np.empty((2, 3, 4)); a += np.empty((3, 4))` 应该报错。参见 [`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| `int` 运算符的提升仅适用于数据类型范围内的整数。 | **严格性** | `numpy.array_api` 回退到 `np.ndarray` 的行为（要么转换，要么引发 `OverflowError`）。 |
| `__pow__` 和 `__rpow__` 不会对零维数组进行基于值的转换。 | **突破** | 例如，`np.array(0., dtype=float32)**np.array(0., dtype=float64)` 是 `float32`。请注意，这是针对零维数组的基于值的转换，而不是标量。 |
| 不允许跨类型转换。 | **严格性** | 即，布尔值、整数和浮点数数据类型不会相互转换，除非使用 `astype` 明确转换（这与与 Python 标量的行为是分开的）。 |
| 不允许将无符号整数数据类型转换为浮点数据类型（例如，`int64 + uint64 -> float64`）。 | **严格性** |  |
| `can_cast` 和 `result_type` 受限。 | **严格性** | `numpy.array_api` 实现不允许跨类型转换。 |
| 当 `dtype=None` 时，`sum` 和 `prod` 总是将 `float32` 上升为 `float64`。 | **突破** |  |

### 索引差异

规范要求仅支持索引的子集，但规范中的所有索引规则都与 NumPy 更广泛的索引规则兼容。

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 不允许隐式���略号（`...`）。 | **严格性** | 如果索引不包含省略号，则必须对所有轴进行索引。 |

| 切片的起始和结束位置不能超出边界。 | **严格性** | 对于切片 `i:j:k`，只允许以下情况：

+   `i` 或 `j` 被省略（`None`）。

+   `-n <= i <= max(0, n - 1)`。

+   对于 `k > 0` 或 `k` 被省略（`None`），`-n <= j <= n`。

+   对于 `k < 0`，`-n - 1 <= j <= max(0, n - 1)`。

|

| 布尔数组索引只允许作为唯一索引。 | **严格性** |  |
| --- | --- | --- |
| 整数数组索引根本不允许。 | **严格性** | 除了 0 维数组，它们被视为整数。 |

### 类型严格性

`numpy.array_api`中的函数将它们的输入限制为规范明确要求的数据类型，即使包装的对应 NumPy 函数允许更广泛的数据类型。在这里，我们列出每个函数及其在`numpy.array_api`中允许的数据类型。这些是**严格性**差异，因为规范并不要求其他数据类型会导致错误。这里的类别定义如下：

+   **浮点数**：`float32`或`float64`。

+   **整数**：任何有符号或无符号整数数据类型（`int8`、`int16`、`int32`、`int64`、`uint8`、`uint16`、`uint32`或`uint64`）。

+   **布尔值**：`bool`。

+   **整数或布尔值**：任何有符号或无符号整数数据类型，或`bool`。对于两个参数的函数，两个参数必须都是整数或都是`bool`。

+   **数值**：任何整数或浮点数数据类型。对于两个参数的函数，两个参数必须都是整数或都是浮点数。

+   **所有**：上述数据类型类别中的任何一种。对于两个参数的函数，两个参数必须是相同类型（整数、浮点数或布尔值）。

在所有情况下，返回的数据类型根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html)选择，并且对于任何允许的输入数据类型，与 NumPy 的返回数据类型没有区别，除非在下面的具体小节中明确提到的情况。

#### 逐元素函数

| 函数名称 | 数据类型 |
| --- | --- |
| `abs` | 数值 |
| `acos` | 浮点数 |
| `acosh` | 浮点数 |
| `add` | 数值 |
| `asin` (*) | 浮点数 |
| `asinh` (*) | 浮点数 |
| `atan` (*) | 浮点数 |
| `atan2` (*) | 浮点数 |
| `atanh` (*) | 浮点数 |
| `bitwise_and` | 整数或布尔值 |
| `bitwise_invert` | 整数或布尔值 |
| `bitwise_left_shift` (*) | 整数 |
| `bitwise_or` | 整数或布尔值 |
| `bitwise_right_shift` (*) | 整数 |
| `bitwise_xor` | 整数或布尔值 |
| `ceil` | 数值 |
| `cos` | 浮点数 |
| `cosh` | 浮点数 |
| `divide` | 浮点数 |
| `equal` | 所有 |
| `exp` | 浮点数 |
| `expm1` | 浮点数 |
| `floor` | 数值 |
| `floor_divide` | 数值 |
| `greater` | 数值 |
| `greater_equal` | 数值 |
| `isfinite` | 数值 |
| `isinf` | 数值 |
| `isnan` | 数值 |
| `less` | 数值 |
| `less_equal` | 数值 |
| `log` | 浮点数 |
| `logaddexp` | 浮点数 |
| `log10` | 浮点数 |
| `log1p` | 浮点数 |
| `log2` | 浮点数 |
| `logical_and` | 布尔值 |
| `logical_not` | 布尔值 |
| `logical_or` | 布尔值 |
| `logical_xor` | 布尔值 |
| `multiply` | ���值 |
| `negative` | 数值 |
| `not_equal` | 所有 |
| `positive` | 数值 |
| `pow` (*) | 数值 |
| `remainder` | 数值 |
| `round` | 数值 |
| `sign` | 数值 |
| `sin` | 浮点数 |
| `sinh` | 浮点数 |
| `sqrt` | 浮点数 |
| `square` | 数值 |
| `subtract` | 数值 |
| `tan` | 浮点数 |
| `tanh` | 浮点数 |
| `trunc` | 数值 |

(*) 这些函数与主`numpy`命名空间中的名称不同。请参阅函数名称更改。

#### 创建函数

| 函数名称 | 数据类型 |
| --- | --- |
| `meshgrid` | 任意（所有输入数据类型必须相同） |

#### 线性代数函数

| 函数名称 | 数据类型 |
| --- | --- |
| `cholesky` | 浮点数 |
| `cross` | 数值 |
| `det` | 浮点数 |
| `diagonal` | 任意 |
| `eigh` | 浮点数 |
| `eighvals` | 浮点数 |
| `inv` | 浮点数 |
| `matmul` | 数值 |
| `matrix_norm` (*) | 浮点数 |
| `matrix_power` | 浮点数 |
| `matrix_rank` | 浮点数 |
| `matrix_transpose` (**) | 任意 |
| `outer` | 数值 |
| `pinv` | 浮点数 |
| `qr` | 浮点数 |
| `slogdet` | 浮点数 |
| `solve` | 浮点数 |
| `svd` | 浮点数 |
| `svdvals` (**) | 浮点数 |
| `tensordot` | 数值 |
| `trace` | 数值 |
| `vecdot` (**) | 数值 |
| `vector_norm` (*) | 浮点数 |

(*) 这些函数是从主`numpy`命名空间的`norm`中拆分出来的。请参阅函数名称更改。

(**) 这些函数是数组 API 中的新功能，不在主`numpy`命名空间中。

#### 数组对象

数组对象上的所有特殊`__operator__`方法的行为与其对应的函数完全相同（请参阅[规范](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)以获取哪些方法对应哪些函数的列表）。唯一的例外是运算符根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)明确允许 Python 标量（请参阅类型提升差异）。

### 数组对象差异

| 特征 | 类型 | 注释 |
| --- | --- | --- |
| 没有数组标量 | **严格性** | 规范中没有数组标量，只有 0-D 数组。然而，除了类型提升差异中概述的提升差异外，标量在规范目的上作为 0-D 数组的鸭子类型。它们是不可变的，但规范[不要求可变性](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html)。 |
| `bool()`，`int()`和`float()`仅适用于 0-D 数组。 | **严格性** | 请参阅[`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| `__imatmul__` | **兼容性** | `np.ndarray`目前未实现`__imatmul__`。请注意，仅当`a @= b`不改变`a`的形状时才定义。 |
| `mT`属性用于矩阵转置。 | **兼容性更改** | 请参阅[mT 的规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html)。 |
| `T`属性应在输入不是二维时报错。 | **破坏性更改** | 请参阅[规范中的注释](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html)。 |
| 新方法`to_device`和属性`device` | **兼容性更改** | 这些方法实际上不会做任何事情，因为 NumPy 仅支持 CPU。 |

### 创建函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `asarray`的`copy`关键字参数 | **兼容性更改** |  |
| 所有数组创建函数（`asarray`、`arange`、`empty`、`empty_like`、`eye`、`full`、`full_like`、`linspace`、`ones`、`ones_like`、`zeros`和`zeros_like`）新增`device`关键字参数。 | **兼容性更改** | `device`实际上不会做任何事情，因为 NumPy 仅支持 CPU。 |

### 逐元素函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 各种函数已更名。 | **兼容性更改** | 请参阅函数名称更改。 |
| 逐元素函数仅针对给定的输入类型组合定义。 | **严格性** | 请参阅类型严格性。 |
| `bitwise_left_shift`和`bitwise_right_shift`仅对`x2`非负数定义。 | **严格性** |  |
| `ceil`、`floor`和`trunc`在整数输入时返回整数。 | **破坏性更改** | `np.ceil`、`np.floor`和`np.trunc`在整数 dtype 输入时返回浮点 dtype。 |

### 线性代数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `cholesky`包括一个`upper`关键字参数。 | **兼容性更改** |  |
| `cross`不允许大小为 2 的向量（仅允许大小为 3）。 | **破坏性更改** |  |
| `diagonal`作用于最后两个轴。 | **破坏性更改** | 严格来说这可以是**兼容性更改**，因为`diagonal`已移至`linalg`命名空间。 |
| `eigh`、`qr`、`slogdet`和`svd`返回一个命名元组。 | **兼容性更改** | 相应的`numpy`函数返回一个`tuple`，其中结果数组的顺序相同。 |
| 新函数`matrix_norm`和`vector_norm` | **兼容性更改** | `norm`函数已从数组 API 中省略，并分为`matrix_norm`用于矩阵范数和`vector_norm`用于向量范数。请注意，`vector_norm`支持任意数量的轴，而`np.linalg.norm`仅支持向量范数的单个轴。 |
| `matrix_rank` 使用 `rtol` 关键字参数代替 `tol`。 | **破坏性** | 在数组 API 中，`rtol` 用于过滤小于 `rtol * largest_singular_value` 的奇异值。在 `np.linalg.matrix_rank` 中，`tol` 用于过滤小于 `tol` 的奇异值。此外，`rtol` 的默认值为 `max(M, N) * eps`，而 `np.linalg.matrix_rank` 中 `tol` 的默认值为 `S.max() * max(M, N) * eps`，其中 `S` 是输入的奇异值。 新标志名称兼容，但默认更改是破坏性的。 |
| `matrix_rank` 不支持 1 维数组。 | **破坏性** |  |
| 新功能 `matrix_transpose`。 | **兼容性** | 与 `np.transpose` 不同，`matrix_transpose` 只转置最后两个轴。请参阅 [规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose) |
| `outer` 仅支持 1 维数组。 | **破坏性** | 规范目前仅指定了对 1-D 数组的行为，但未来的��为可能是广播，而不是展平，这是 `np.outer` 的行为。 |
| `pinv` 使用 `rtol` 关键字参数代替 `rcond` | **破坏性** | `rtol` 和 `rcond` 的含义相同，但 `rtol` 的默认值为 `max(M, N) * eps`，而 `rcond` 的默认值为 `1e-15`。 新标志名称兼容，但默认更改是破坏性的。 |
| `solve` 只在 `x2` 确切为 1 维时接受为向量。 | **破坏性** | `np.linalg.solve` 的行为模糊。有关更多详细信息，请参阅 [此 numpy 问题](https://github.com/numpy/numpy/issues/15349) 和 [此数组 API 规范问题](https://github.com/data-apis/array-api/issues/285)。 |
| 新功能 `svdvals`。 | **兼容性** | 等同于 `np.linalg.svd(compute_uv=False)`。 |
| `tensordot` 的 `axis` 关键字必须是元组。 | **兼容性** | 在 `np.tensordot` 中，也可以是数组或类似数组。 |
| `trace` 操作最后两个轴。 | **破坏性** | `np.trace` 默认操作前两个轴。请注意，数组 API 的 `trace` 不允许指定要操作的轴。 |

### 操作函数差异

| 特性 | 类型 | 备注 |
| --- | --- | --- |
| 多个函数已被重命名 | **兼容性** | 请参阅 函数名称更改。 |
| `concat` 的默认类型转换规则与 `np.concatenate` 不同 | **严格性** | 不允许跨类型转换。标量的值转换不适用（当 axis=None 时）。 |
| `stack` 的默认类型转换规则与 `np.stack` 不同 | **严格性** | 不允许跨类型转换。 |
| 新功能 `permute_dims`。 | **兼容性** | 与 `np.transpose` 不同，`permute_dims` 需要 `axis` 关键字参数。 |
| `reshape` 函数有一个 `copy` 关键字参数 | **兼容性** | 请参阅 [`github.com/numpy/numpy/issues/9818`](https://github.com/numpy/numpy/issues/9818)。 |

### 集合函数差异

| 功能 | 类型 | 注释 |
| --- | --- | --- |
| 新函数`unique_all`、`unique_counts`、`unique_inverse`和`unique_values`。 | **兼容性** | 请参见函数名称更改。 |
| 四个`unique_*`函数返回一个命名元组。 | **兼容性** |  |
| `unique_all`和`unique_indices`返回的索引与`x`具有相同的形状。 | **兼容性** | 请参见[`github.com/numpy/numpy/issues/20638`](https://github.com/numpy/numpy/issues/20638)。 |

### 集合函数差异

| 功能 | 类型 | 注释 |
| --- | --- | --- |
| `argsort`和`sort`具有`stable`关键字参数而不是`kind`。 | **破坏性** | `stable`是一个布尔关键字参数，默认为`True`。`kind`接受一个字符串，默认为`"quicksort"`。`stable=True`等同于`kind="stable"`，`kind=False`等同于`kind="quicksort"`，尽管规范允许在`stable=False`时使用任何排序算法。新标志名称是兼容的，但默认更改是破坏性的。 |
| `argsort`和`sort`具有`descending`关键字参数。 | **兼容性** |  |

### 统计函数差异

| 功能 | 类型 | 注释 |
| --- | --- | --- |
| `sum`和`prod`在`dtype=None`时总是将`float32`向上转换为`float64`。 | **破坏性** |  |
| `std`和`var`函数具有`correction`关键字参数而不是`ddof`。 | **兼容性** |  |

### 其他差异

| 功能 | 类型 | 注释 |
| --- | --- | --- |
| Dtypes 只能被拼写为 dtype 对象。 | **严格性** | 例如，`numpy.array_api.asarray([0], dtype='int32')`是不允许的。 |
| `asarray`不会在任何函数中隐式调用。 | **严格性** | 例外情况是 Python 运算符，在某些情况下接受 Python 标量（请参见类型提升差异）。 |
| `tril`和`triu`要求输入至少为 2-D。 | **严格性** |  |
| `finfo()`返回类型使用`float`作为各个属性。 | **严格性** | 规范允许鸭子类型，因此`finfo`返回 dtype 标量被认为与`float`兼容。 |

| 每个函数中的位置参数都是仅限位置的。 | **破坏性** | 请查看每个函数的确切签名规范。请注意，NumPy ufuncs 已经使用了仅限位置参数，但非 ufuncs 如`asarray`通常没有。 |  ## `numpy.array_api`和`numpy`之间的差异表

这个表格概述了`numpy.array_api`与主`numpy`命名空间之间的主要区别。有三种类型的差异：

1.  **严格性**。这些只是为了使`numpy.array_api`成为一个严格的、最小的实现而做的事情。它们实际上并不是规范所要求的，其他符合规范的库可能不会遵循它们。在大多数情况下，规范并不指定或要求给定域之外的任何行为。主`numpy`命名空间不需要做任何改变才能符合这些规范。

1.  **Compatible**。这些可能被添加到主 `numpy` 命名空间中而不会破坏向后兼容性的事物。

1.  **Breaking**。如果在主 `numpy` 命名空间中实现，可能会破坏向后兼容性的事物。

### 名称差异

规范中有许多函数从 NumPy 中被重命名。除非另有说明，否则这些函数在行为上是相同的，因此都是**兼容**的更改。

#### 函数名称更改

以下函数在数组 API 中的名称与 NumPy 中不同

| 数组 API 名称 | NumPy 命名空间名称 | 注释 |
| --- | --- | --- |
| `acos` | `arccos` |  |
| `acosh` | `arccosh` |  |
| `asin` | `arcsin` |  |
| `asinh` | `arcsinh` |  |
| `atan` | `arctan` |  |
| `atan2` | `arctan2` |  |
| `atanh` | `arctanh` |  |
| `bitwise_left_shift` | `left_shift` |  |
| `bitwise_invert` | `invert` |  |
| `bitwise_right_shift` | `right_shift` |  |
| `bool` | `bool_` | 这是**破坏性**的，因为 `np.bool` 目前是内置 `bool` 的已弃用别名。 |
| `concat` | `concatenate` |  |
| `matrix_norm` 和 `vector_norm` | `norm` | `matrix_norm` 和 `vector_norm` 分别只执行 `np.norm` 的有限子集。 |
| `permute_dims` | `transpose` | 与 `np.transpose` 不同，`permute_dims` 的 `axis` 关键字参数是必需的。 |
| `pow` | `power` |  |
| `unique_all`, `unique_counts`, `unique_inverse` 和 `unique_values` | `unique` | 每个都等同于设置了特定标志的 `np.unique`。 |

#### 函数而不是方法

+   `astype` 是数组 API 中的一个函数，而在 `numpy` 中是 `ndarray` 的一个方法。

#### `linalg` 命名空间差异

这些函数在数组 API 的 `linalg` 子命名空间中，但在 NumPy 中仅在顶层命名空间中：

+   `cross`

+   `diagonal`

+   `matmul` (*)

+   `outer`

+   `tensordot` (*)

+   `trace`

(*): 这些函数也在数组 API ���顶层命名空间中。

#### 关键字参数重命名

以下函数的关键字参数已被重命名。除非另有说明，否则关键字参数的功能是相同的。具有相同语义定义的重命名关键字参数可能被视为**兼容**或**破坏**，具体取决于更改的实现方式。

注意，此页面不列出主 `numpy` 命名空间中存在但不在数组 API 中的函数关键字参数。这些关键字参数在 `numpy.array_api` 中被省略，以确保**严格性**，因为规范允许函数包含额外的关键字参数，而不仅限于所需的参数。

| 函数 | 数组 API 关键字名称 | NumPy 关键字名称 | 注释 |
| --- | --- | --- | --- |
| `argsort` 和 `sort` | `stable` | `kind` | `stable` 和 `kind` 的定义不同，以及默认值也不同。默认值的更改使得这是一个**破坏性**的更改。参见集合函数差异。 |
| `matrix_rank` | `rtol` | `tol` | `rtol` 和 `tol` 的定义不同，而默认值也不同。默认值的更改造成了**变更**。请参阅线性代数差异。 |
| `pinv` | `rtol` | `rcond` | `rtol` 和 `rcond` 的定义相同，但默认值不同，造成了**变更**。请参阅线性代数差异。 |
| `std` 和 `var` | `correction` | `ddof` |  |
| `reshape` | `shape` | `newshape` | 该参数可以作为 NumPy 和数组 API 的位置参数或关键字参数传递。 |

### 类型提升差异

类型提升是 NumPy 与规范最大的不同之处。最显著的区别是 NumPy 在许多情况下进行基于值的转换。规范明确禁止基于值的转换。在数组 API 中，任何操作的结果类型始终完全由输入类型确定，与值或形状无关。

| 特征 | 类型 | 注释 |
| --- | --- | --- |
| 有限的数据类型集合。 | **严格性** | `numpy.array_api` 只实现了规范所需的那些[数据类型](https://data-apis.org/array-api/latest/API_specification/data_types.html)。 |
| 操作符（如 `+`）只接受与 Python 标量匹配的标量类型。 | **严格性** | 例如，`<int32 array> + 1.0` 是不允许的。请参阅[规范中有关混合数组和 Python 标量的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)。 |
| 与 Python 标量的操作符（如 `+`）始终返回与数组相同的数据类型。 | **变更** | 例如，`numpy.array_api.asarray(0., dtype=float32) + 1e64` 是一个 `float32` 数组。 |
| 当左操作数将被提升时，不允许原地操作符。 | **变更** | 例如：`a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`。规范明确禁止这种情况。 |
| 当右操作数无法广播到左操作数的形状时，就不允许原地操作符。 | **严格性** | 这种所谓的“反向广播”不应该被允许。例如：`a = np.empty((2, 3, 4)); a += np.empty((3, 4))` 应该报错。请参阅[`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| 对于操作符的 `int` 提升仅对数据类型范围内的整数指定。 | **严格性** | `numpy.array_api` 退回到 `np.ndarray` 的行为（要么转换，要么引发 `OverflowError`）。 |
| `__pow__` 和 `__rpow__` 不会对 0-D 数组进行基于值的转换。 | **变更** | 例如，`np.array(0., dtype=float32)**np.array(0., dtype=float64)` 是 `float32`。请注意，这是对 0-D 数组进行基于值的转换，而不是标量。 |
| 不允许跨类型转换。 | **严格性** | 即，布尔值、整数和浮点数数据类型不会相互转换，除非明确使用 `astype`（这与 Python 标量的行为是分开的）。 |
| 不允许将无符号整数类型转换为浮点类型（例如，`int64 + uint64 -> float64`）。 | **严格性** |  |
| `can_cast` 和 `result_type` 受限制。 | **严格性** | `numpy.array_api` 的实现不允许跨类型转换。 |
| `sum` 和 `prod` 在 `dtype=None` 时总是将 `float32` 向上转换为 `float64`。 | **变更** |  |

### 索引差异

规范仅要求一部分索引，但规范中的所有索引规则都与 NumPy 更广泛的索引规则兼容。

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 不允许隐式省略号 (`...`)。 | **严格性** | 如果索引不包括省略号，则所有轴必须被索引。 |

| 切片的起始和结束不能超出界限。 | **严格性** | 对于切片 `i:j:k`，只允许以下情况：

+   `i` 或 `j` 被省略 (`None`)。

+   `-n <= i <= max(0, n - 1)`。

+   对于 `k > 0` 或 `k` 被省略 (`None`)，`-n <= j <= n`。

+   对于 `k < 0`，`-n - 1 <= j <= max(0, n - 1)`。

|

| 布尔数组索引仅允许作为唯一索引。 | **严格性** |  |
| --- | --- | --- |
| 整数数组索引根本不被允许。 | **严格性** | 除了 0-D 数组，它们被视为整数。 |

### 类型严格性

`numpy.array_api` 中的函数限制其输入仅限于规范明确要求的数据类型，即使包装的对应 NumPy 函数允许更广泛的集合。在这里，我们列出每个函数及其在 `numpy.array_api` 中允许的数据类型。这些是**严格性**差异，因为规范不要求其他数据类型会导致错误。这里的类别定义如下：

+   **浮点数**：`float32` 或 `float64`。

+   **整数**：任何有符号或无符号整数类型 (`int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, 或 `uint64`)。

+   **布尔值**：`bool`。

+   **整数或布尔值**：任何有符号或无符号整数数据类型，或 `bool`。对于两个参数的函数，两个参数必须是整数或布尔值。

+   **数值**：任何整数或浮点数数据类型。对于两个参数的函数，两个参数必须是整数或浮点数。

+   **所有**：以上任何一种数据类型类别。对于两个参数的函数，两个参数必须是相同类型（整数、浮点数或布尔值）。

在所有情况下，返回的数据类型根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html)选择，并且对于任何允许的输入数据类型，与 NumPy 的返回数据类型没有区别，除非在下面的子节中明确提到的情况。

#### 逐元素函数

| 函数名称 | 数据类型 |
| --- | --- |
| `abs` | 数值 |
| `acos` | 浮点数 |
| `acosh` | 浮点数 |
| `add` | 数值 |
| `asin` (*) | 浮点数 |
| `asinh` (*) | 浮点数 |
| `atan` (*) | 浮点数 |
| `atan2` (*) | 浮点数 |
| `atanh` (*) | 浮点数 |
| `bitwise_and` | 整数或布尔值 |
| `bitwise_invert` | 整数或布尔值 |
| `bitwise_left_shift` (*) | 整数 |
| `bitwise_or` | 整数或布尔值 |
| `bitwise_right_shift` (*) | 整数 |
| `bitwise_xor` | 整数或布尔值 |
| `ceil` | 数值 |
| `cos` | 浮点数 |
| `cosh` | 浮点数 |
| `divide` | 浮点数 |
| `equal` | 所有 |
| `exp` | 浮点数 |
| `expm1` | 浮点数 |
| `floor` | 数值 |
| `floor_divide` | 数值 |
| `greater` | 数值 |
| `greater_equal` | 数值 |
| `isfinite` | 数值 |
| `isinf` | 数值 |
| `isnan` | 数值 |
| `less` | 数值 |
| `less_equal` | 数值 |
| `log` | 浮点数 |
| `logaddexp` | 浮点数 |
| `log10` | 浮点数 |
| `log1p` | 浮点数 |
| `log2` | 浮点数 |
| `logical_and` | 布尔值 |
| `logical_not` | 布尔值 |
| `logical_or` | 布尔值 |
| `logical_xor` | 布尔值 |
| `multiply` | 数值 |
| `negative` | 数值 |
| `not_equal` | 所有 |
| `positive` | 数值 |
| `pow` (*) | 数值 |
| `remainder` | 数值 |
| `round` | 数值 |
| `sign` | 数值 |
| `sin` | 浮点数 |
| `sinh` | 浮点数 |
| `sqrt` | 浮点数 |
| `square` | 数值 |
| `subtract` | 数值 |
| `tan` | 浮点数 |
| `tanh` | 浮点数 |
| `trunc` | 数值 |

(*) 这些函数与主`numpy`命名空间中的名称不同。请参阅函数名称更改。

#### 创建函数

| 函数名称 | 数据类型 |
| --- | --- |
| `meshgrid` | 任意（所有输入数据类型必须相同） |

#### 线性代数函数

| 函数名称 | 数据类型 |
| --- | --- |
| `cholesky` | 浮点数 |
| `cross` | 数值 |
| `det` | 浮点数 |
| `diagonal` | 任意 |
| `eigh` | 浮点数 |
| `eighvals` | 浮点数 |
| `inv` | 浮点数 |
| `matmul` | 数值 |
| `matrix_norm` (*) | 浮点数 |
| `matrix_power` | 浮点数 |
| `matrix_rank` | 浮点数 |
| `matrix_transpose` (**) | 任意 |
| `outer` | 数值 |
| `pinv` | 浮点数 |
| `qr` | 浮点数 |
| `slogdet` | 浮点数 |
| `solve` | 浮点数 |
| `svd` | 浮点数 |
| `svdvals` (**) | 浮点数 |
| `tensordot` | 数值 |
| `trace` | 数值 |
| `vecdot` (**) | 数值 |
| `vector_norm` (*) | 浮点数 |

(*) 这些函数从主`numpy`命名空间中的`norm`中拆分出来。请参阅函数名称更改。

(**) 这些函数是数组 API 中的新功能，不在主`numpy`命名空间中。

#### 数组对象

数组对象的所有特殊`__operator__`方法的行为与其对应的函数完全相同（参见[规范](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)以查看哪些方法对应哪些函数）。唯一的例外是，根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)（参见数组 API 类型提升差异），运算符明确允许 Python 标量。

### 数组对象的差异

| 特性 | 类型 | 注意事项 |
| --- | --- | --- |
| 没有数组标量 | **严格性** | 规范中没有数组标量，只有 0 维数组。然而，除了数组 API 类型提升差异中概述的提升差异外，标量在规范中作为 0 维数组进行鸭子类型。它们是不可变的，但规范[不要求可变性](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html)。 |
| `bool()`、`int()`和`float()`仅适用于 0 维数组。 | **严格性** | 参见[`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| `__imatmul__` | **兼容性** | `np.ndarray`目前不实现`__imatmul`。请注意，只有当`a`的形状不发生变化时，`a @= b`才会被定义。 |
| 用于矩阵转置的`mT`属性。 | **兼容性** | 参见[规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html)中的`mT`。 |
| 如果输入不是二维的，`T`属性应该报错。 | **破坏性** | 参见[规范中的注释](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html)。 |
| 新方法`to_device`和属性`device` | **兼容性** | 这些方法实际上不会做任何事情，因为 NumPy 仅支持 CPU。 |

### 创建函数差异

| 特性 | 类型 | 注意事项 |
| --- | --- | --- |
| `asarray`的`copy`关键字参数 | **兼容性** |  |
| 所有数组创建函数（`asarray`、`arange`、`empty`、`empty_like`、`eye`、`full`、`full_like`、`linspace`、`ones`、`ones_like`、`zeros`和`zeros_like`）都新增了`device`关键字参数。 | **兼容性** | `device`实际上不会起作用，因为 NumPy 仅支持 CPU。 |

### 元素级函数差异

| 特性 | 类型 | 注意事项 |
| --- | --- | --- |
| 各种函数已被重命名。 | **兼容性** | 参见函数名称更改。 |
| 元素级函数仅对给定的输入类型组合定义。 | **严格性** | 参见类型严格性。 |
| `bitwise_left_shift`和`bitwise_right_shift`仅对`x2`非负定义。 | **严格性** |  |
| `ceil`、`floor` 和 `trunc` 对整数输入返回整数。 | **破坏性更改** | `np.ceil`、`np.floor` 和 `np.trunc` 在整数类型输入时返回浮点数类型。 |

### 线性代数差异

| 特征 | 类型 | 备注 |
| --- | --- | --- |
| `cholesky` 包括一个 `upper` 关键字参数。 | **兼容的** |  |
| `cross` 不允许大小为 2 的向量（只允许大小为 3）。 | **破坏性更改** |  |
| `diagonal` 操作在最后两个轴上。 | **破坏性更改** | 严格来说这可能是**兼容的**，因为 `diagonal` 被移动到 `linalg` 命名空间中。 |
| `eigh`、`qr`、`slogdet` 和 `svd` 返回一个命名元组。 | **兼容的** | 相应的 `numpy` 函数返回一个 `tuple`，其中结果数组的顺序相同。 |
| 新函数 `matrix_norm` 和 `vector_norm`。 | **兼容的** | `norm` 函数已从数组 API 中省略，并分为 `matrix_norm` 用于矩阵范数和 `vector_norm` 用于向量范数。请注意，`vector_norm` 支持任意数量的轴，而 `np.linalg.norm` 仅支持向量范数的单个轴。 |
| `matrix_rank` 有一个 `rtol` 关键字参数，而不是 `tol`。 | **破坏性更改** | 在数组 API 中，`rtol` 用于过滤小于 `rtol * largest_singular_value` 的奇异值。在 `np.linalg.matrix_rank` 中，`tol` 用于过滤小于 `tol` 的奇异值。此外，`rtol` 的默认值是 `max(M, N) * eps`，而 `np.linalg.matrix_rank` 中 `tol` 的默认值是 `S.max() * max(M, N) * eps`，其中 `S` 是输入的奇异值。新标志名称是兼容的，但默认更改是破坏性的。 |
| `matrix_rank` 不支持一维数组。 | **破坏性更改** |  |
| 新函数 `matrix_transpose`。 | **兼容的** | 与 `np.transpose` 不同，`matrix_transpose` 只转置最后两个轴。请参阅[规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose)。 |
| `outer` 仅支持一维数组。 | **破坏性更改** | 规范目前仅指定了对 1-D 数组的行为，��未来的行为可能是广播，而不是展平，这是 `np.outer` 的行为。 |
| `pinv` 有一个 `rtol` 关键字参数，而不是 `rcond`。 | **破坏性更改** | `rtol` 和 `rcond` 的含义相同，但 `rtol` 的默认值是 `max(M, N) * eps`，而 `rcond` 的默认值是 `1e-15`。新标志名称是兼容的，但默认更改是破坏性的。 |
| `solve` 仅在 `x2` 作为一维向量时才接受。 | **破坏性更改** | `np.linalg.solve` 的行为是模棱两可的。更多细节请参阅[此 numpy 问题](https://github.com/numpy/numpy/issues/15349)和[此数组 API 规范问题](https://github.com/data-apis/array-api/issues/285)。 |
| 新函数 `svdvals`。 | **兼容的** | 等效于 `np.linalg.svd(compute_uv=False)`。 |
| `tensordot` 的 `axis` 关键字必须是一个元组。 | **Compatible** | 在 `np.tensordot` 中，它也可以是一个数组或类似数组。 |
| `trace` 在最后两个轴上操作。 | **Breaking** | `np.trace` 默认在前两个轴上操作。请注意，数组 API 的 `trace` 不允许指定要操作的轴。 |

### 操作函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 各种函数已被重命名 | **Compatible** | 参见 Function Name Changes。 |
| `concat` 与 `np.concatenate` 有不同的默认转换规则 | **Strictness** | 没有跨类型的转换。在标量上没有基于值的转换（当 axis=None 时）。 |
| `stack` 与 `np.stack` 有不同的默认转换规则 | **Strictness** | 没有跨类型的转换。 |
| 新函数 `permute_dims`。 | **Compatible** | 与 `np.transpose` 不同，`permute_dims` 的 `axis` 关键字参数是必需的。 |
| `reshape` 函数有一个 `copy` 关键字参数 | **Compatible** | 参见 [`github.com/numpy/numpy/issues/9818`](https://github.com/numpy/numpy/issues/9818)。 |

### 集合函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 新函数 `unique_all`、`unique_counts`、`unique_inverse` 和 `unique_values`。 | **Compatible** | 参见 Function Name Changes。 |
| 四个 `unique_*` 函数返回一个命名元组。 | **Compatible** |  |
| `unique_all` 和 `unique_indices` 返回与 `x` 相同形状的索引。 | **Compatible** | 参见 [`github.com/numpy/numpy/issues/20638`](https://github.com/numpy/numpy/issues/20638)。 |

### 集合函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `argsort` 和 `sort` 有一个 `stable` 关键字参数，而不是 `kind`。 | **Breaking** | `stable` 是一个布尔关键字参数，默认为 `True`。 `kind` 接受一个字符串，默认为 `"quicksort"`。 `stable=True` 等同于 `kind="stable"`，`kind=False` 等同于 `kind="quicksort"`，尽管规范允许任何排序算法当 `stable=False` 时。新的标志名称是兼容的，但默认更改是破坏性的。 |
| `argsort` 和 `sort` 有一个 `descending` 关键字参数。 | **Compatible** |  |

### 统计函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `sum` 和 `prod` 在 `dtype=None` 时总是将 `float32` 升级为 `float64`。 | **Breaking** |  |
| `std` 和 `var` 函数有一个 `correction` 关键字参数，而不是 `ddof`。 | **Compatible** |  |

### 其他差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| Dtypes 只能被拼写为 dtype 对象。 | **Strictness** | 例如，`numpy.array_api.asarray([0], dtype='int32')` 是不允许的。 |
| `asarray` 在任何函数中都不会被隐式调用。 | **Strictness** | 例外是 Python 运算符，在某些情况下接受 Python 标量（请参见 Type Promotion Differences）。 |
| `tril` 和 `triu` 要求输入至少为 2-D。 | **严格性** |  |
| finfo() 返回类型使用 `float` 作为各种属性。 | **严格性** | 规范允许鸭子类型，因此 `finfo` 返回 dtype 标量被视为与 `float` 兼容。 |
| 每个函数的位置参数都是仅限位置的。 | **破坏性的** | 查看每个函数的确切签名规范。请注意，NumPy 的通用函数已经使用了仅限位置的参数，但非通用函数如 `asarray` 通常不会使用。 |

### 名称差异

许多函数在规范中从 NumPy 中重命名。这些函数在行为上是相同的，因此除非另有说明，它们都是**兼容**的更改。

#### 函数名称更改

数组 API 中以下函数的命名不同

| 数组 API 名称 | NumPy 命名空间名称 | 注释 |
| --- | --- | --- |
| `acos` | `arccos` |  |
| `acosh` | `arccosh` |  |
| `asin` | `arcsin` |  |
| `asinh` | `arcsinh` |  |
| `atan` | `arctan` |  |
| `atan2` | `arctan2` |  |
| `atanh` | `arctanh` |  |
| `bitwise_left_shift` | `left_shift` |  |
| `bitwise_invert` | `invert` |  |
| `bitwise_right_shift` | `right_shift` |  |
| `bool` | `bool_` | 这是**破坏性的**，因为 `np.bool` 目前是内置 `bool` 的已弃用别名。 |
| `concat` | `concatenate` |  |
| `matrix_norm` 和 `vector_norm` | `norm` | `matrix_norm` 和 `vector_norm` 分别执行 `np.norm` 的有限子集。 |
| `permute_dims` | `transpose` | 与 `np.transpose` 不同，`permute_dims` 需要 `axis` 关键字参数。 |
| `pow` | `power` |  |
| `unique_all`, `unique_counts`, `unique_inverse` 和 `unique_values` | `unique` | 每个函数等同于设置了特定标志的 `np.unique`。 |

#### 函数而非方法

+   `astype` 是数组 API 中的函数，而在 `numpy` 中是 `ndarray` 的方法。

#### `linalg` 命名空间差异

这些函数在数组 API 的 `linalg` 子命名空间中，但在 NumPy 中仅在顶层命名空间中：

+   `cross`

+   `diagonal`

+   `matmul` (*)

+   `outer`

+   `tensordot` (*)

+   `trace`

(*): 这些函数也在数组 API 的顶层命名空间中。

#### 关键字参数重命名

以下函数的关键字参数已重命名。除非另有说明，关键字参数的功能是相同的。具有相同语义定义的重命名关键字参数可能被视为**兼容**或**破坏性**，具体取决于更改的实现方式。

请注意，此页面不列出主 `numpy` 命名空间中存在但不在数组 API 中的函数关键字参数。为了**严格性**，这些关键字参数在 `numpy.array_api` 中被省略，因为规范允许函数包含额外的关键字参数。

| 函数 | 数组 API 关键字名称 | NumPy 关键字名称 | 注释 |
| --- | --- | --- | --- |
| `argsort` 和 `sort` | `稳定` | `种类` | `稳` 和 `种类` 的定义不同，以及默认值。默认值的更改使得这是**破坏性的**。请参阅集函数差异。 |
| `矩阵秩` | `rtol` | `tol` | `linalg` 命名空间中 `rtol` 和 `tol` 的定义不同，以及  默认度  。默认值的更改使得这是**破坏的**。请参, 见数组, API 线性代数差, 异。 |
| `伪逆` | `rtol` | `rcond` | `rtol` 和 `rcond` 的定义相同，但它们的默认值不同，这是**破坏性的**。请参阅线性代数差异。 |
| `标准差` 和 `方差` | `校正` | `自由度` |  |
| `重塑` | `形状` | `新形状` | 参数可以作为 NumPy 和数组 API 的位置或关键字参数传递。 |

#### 函数名称更改

数组 API 中以下函数的名称不同

| 数组 API 名称 | NumPy 命名空间名称 | 注释 |
| --- | --- | --- |
| `acos` | `arccos` |  |
| `双曲余弦` | `反双曲余弦` |  |
| `asin` | `arcsin` |  |
| `反双曲正弦` | `反双曲正弦` |  |
| `atan` | `arctan` |  |
| `atan2` | `arctan2` |  |
| `反双曲正切` | `反双曲正切` |  |
| `按位左移` | `左移` |  |
| `按位取反` | `取反` |  |
| `按位右移` | `右移` |  |
| `布尔`` | `bool_` | 这是**破坏性的**，因为 `np.bool` 目前是内置, `bool` 的, 弃, 用别名。 |
| `连接` | `连接` |  |
| `矩阵范数` 和 `向量范数` | `范数` | `矩阵范数` 和 `向量范数` 仅执行 `np.norm` 的有限子集。 |
| `置换维度` | `转置` | 与 `np.transpose` 不同，`permute_dims` 需要 `axis` 关键字参数。 |
| `幂` | `幂` |  |
| `唯一全部`, `唯一计数`, `唯一逆`, 和 `唯一值` | `唯一` | 每个与设置特定标志的 `np.unique` 等效。 |

#### 函数而非方法

+   `astype` 是数组 API 中的��个函数，而在 `numpy` 中是 `ndarray` 的一个方法。

#### `linalg` 命名空间差异

这些函数在数组 API 的 `linalg` 子命名空间中，但只在 NumPy 的顶层命名空间中：

+   `叉积`

+   `对角线`

+   `矩阵乘法` (*)

+   `外积`

+   `张量点积` (*)

+   `跟踪`

(*): 这些函数也在数组 API 的顶层命名空间中。

#### 关键字参数重命名

数组 API 中以下函数具有已重命名的关键字参数。除非另有说明，否则关键字参数, 的功能是相同的。具有相同语义定义的重命名关键字参数可能被视为**兼容**或**破坏性**，具体取决于更改的实现方式。

请注意，此页面不列出主 `numpy` 命名空间中存在但不在数组 API 中的函数关键字参数。为了**严格性**，`numpy.array_api` 中省略了这些关键字参数，因为规范允许函数包括额外的关键字参数，而不是所, 需要的。

| 功能 | 数组 API 关键字名称 | NumPy 关键字名称 | 备注 |
| --- | --- | --- | --- |
| `argsort` 和 `sort` | `stable` | `kind` | `stable` 和 `kind` 的定义不同，默认值也不同。默认值的更改会导致**破坏**。参见 集合函数差异。 |
| `matrix_rank` | `rtol` | `tol` | `rtol` 和 `tol` 的定义不同，默认值也不同。默认值的更改会导致**破坏**。参见 线性代数差异。 |
| `pinv` | `rtol` | `rcond` | `rtol` 和 `rcond` 的定义相同，但默认值不同，这会导致**破坏**。参见 线性代数差异。 |
| `std` 和 `var` | `correction` | `ddof` |  |
| `reshape` | `shape` | `newshape` | 对于 NumPy 和数组 API，参数可以作为位置参数或关键字参数传递。 |

### 类型提升差异

类型提升是 NumPy 与规范最大的差异领域。最显著的区别是 NumPy 在许多情况下进行基于值的转换。规范明确禁止基于值的转换。在数组 API 中，任何操作的结果类型始终完全由输入类型确定，与值或形状无关。

| 特性 | 类型 | 备注 |
| --- | --- | --- |
| 有限的数据类型集合。 | **严格性** | `numpy.array_api` 仅实现了规范所需的那些[数据类型](https://data-apis.org/array-api/latest/API_specification/data_types.html)。 |
| 仅接受与 Python 标量匹配的标量类型的操作符（如 `+`）。 | **严格性** | 例如，`<int32 array> + 1.0` 是不允许的。参见 [混合数组和 Python 标量的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)。 |
| 与 Python 标量一起使用的操作符（如 `+`）始终返回与数组相同的 dtype。 | **破坏** | 例如，`numpy.array_api.asarray(0., dtype=float32) + 1e64` 是一个 `float32` 数组。 |
| 当左侧将被提升时，不允许原地操作符。 | **破坏** | 例如：`a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)`。规范明确禁止这种情况。 |
| 当右侧操作数无法广播到左侧操作数的形状时，不允许原地操作符。 | **严格性** | 这种所谓的“逆向广播”不应该被允许。例如：`a = np.empty((2, 3, 4)); a += np.empty((3, 4))` 应该报错。参见 [`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| 仅为在 dtype 范围内的整数指定运算符的`int`提升。 | **严格性** | `numpy.array_api` 回退到 `np.ndarray` 行为（要么转换，要么引发 `OverflowError`）。 |
| `__pow__` 和 `__rpow__` 不会对 0-D 数组进行基于值的转换。 | **破坏性** | 例如，`np.array(0., dtype=float32)**np.array(0., dtype=float64)` 是 `float32`。请注意，这是对 0-D 数组的基于值的转换，而不是标量。 |
| 不允许跨类型转换。 | **严格性** | 即，布尔值、整数和浮点数据类型不会相互转换，除非使用 `astype` 明确转换（这与 Python 标量的行为是分开的）。 |
| 不允许将无符号整数数据类型转换为浮点数据类型（例如，`int64 + uint64 -> float64`。 | **严格性** |  |
| `can_cast` 和 `result_type` 受限制。 | **严格性** | `numpy.array_api` 的实现不允许跨类型转换。 |
| 当 `dtype=None` 时，`sum` 和 `prod` 总是将 `float32` 向上转换为 `float64`。 | **破坏性** |  |

### 索引差异

规范仅要求一部分索引，但规范中的所有索引规则都与 NumPy 更广泛的索引规则兼容。

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 不允许隐式省略 (`...`)。 | **严格性** | 如果索引不包括省略号，则所有轴必须被索引。 |

| 切片的起始和结束不能超出边界。 | **严格性** | 对于切片 `i:j:k`，只允许以下情况：

+   `i` 或 `j` 被省略 (`None`)。

+   `-n <= i <= max(0, n - 1)`。

+   对于 `k > 0` 或 `k` 被省略 (`None`)，`-n <= j <= n`。

+   对于 `k < 0`，`-n - 1 <= j <= max(0, n - 1)`。

|

| 仅允许布尔数组索引作为唯一索引。 | **严格性** |  |
| --- | --- | --- |
| 完全不允许整数数组索引。 | **严格性** | 除了 0-D 数组，它们被视为整数。 |

### 类型严格性

`numpy.array_api` 中的函数将它们的输入限制为规范明确要求的数据类型，即使包装的对应 NumPy 函数允许更广泛的数据类型。在这里，我们列出每个函数以及在 `numpy.array_api` 中允许的数据类型。这些是**严格性**差异，因为规范不要求其他数据类型会导致错误。这里的类别定义如下：

+   **浮点数**: `float32` 或 `float64`。

+   **整数**: 任何有符号或无符号整数数据类型（`int8`、`int16`、`int32`、`int64`、`uint8`、`uint16`、`uint32` 或 `uint64`）。

+   **Boolean**: `bool`。

+   **整数或布尔值**: 任何有符号或无符号整数数据类型，或 `bool`。对于两个参数的函数，两个参数必须是整数或都是 `bool`。

+   **Numeric**: 任何整数或浮点数数据类型。对于两个参数的函数，两个参数必须都是整数或都是浮点数。

+   **全部**: 以上述数据类型类别中的任何一种。对于两个参数的函数，两个参数必须是相同类型（整数、浮点数或布尔值）。

在所有情况下，返回的数据类型根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html)选择，并且对于任何允许的输入数据类型，不会与 NumPy 的返回数据类型有所不同，除非在下面的子节中明确提到的情况。

#### 逐元素函数

| 函数名称 | 数据类型 |
| --- | --- |
| `abs` | 数值型 |
| `acos` | 浮点数 |
| `acosh` | 浮点数 |
| `add` | 数值型 |
| `asin` (*) | 浮点数 |
| `asinh` (*) | 浮点数 |
| `atan` (*) | 浮点数 |
| `atan2` (*) | 浮点数 |
| `atanh` (*) | 浮点数 |
| `bitwise_and` | 整数或布尔型 |
| `bitwise_invert` | 整数或布尔型 |
| `bitwise_left_shift` (*) | 整数 |
| `bitwise_or` | 整数或布尔型 |
| `bitwise_right_shift` (*) | 整数 |
| `bitwise_xor` | 整数或布尔型 |
| `ceil` | 数值型 |
| `cos` | 浮点数 |
| `cosh` | 浮点数 |
| `divide` | 浮点数 |
| `equal` | 所有 |
| `exp` | 浮点数 |
| `expm1` | 浮点数 |
| `floor` | 数值型 |
| `floor_divide` | 数值型 |
| `greater` | 数值型 |
| `greater_equal` | 数值型 |
| `isfinite` | 数值型 |
| `isinf` | 数值型 |
| `isnan` | 数值型 |
| `less` | 数值型 |
| `less_equal` | 数值型 |
| `log` | 浮点数 |
| `logaddexp` | 浮点数 |
| `log10` | 浮点数 |
| `log1p` | 浮点数 |
| `log2` | 浮点数 |
| `logical_and` | 布尔型 |
| `logical_not` | 布尔型 |
| `logical_or` | 布尔型 |
| `logical_xor` | 布尔型 |
| `multiply` | 数值型 |
| `negative` | 数值型 |
| `not_equal` | 所有 |
| `positive` | 数值型 |
| `pow` (*) | 数值型 |
| `remainder` | 数值型 |
| `round` | 数值型 |
| `sign` | 数值型 |
| `sin` | 浮点数 |
| `sinh` | 浮点数 |
| `sqrt` | 浮点数 |
| `square` | 数值型 |
| `subtract` | 数值型 |
| `tan` | 浮点数 |
| `tanh` | 浮点数 |
| `trunc` | 数值型 |

(*) 这些函数与主`numpy`命名空间中的名称不同。请参阅函数名称更改。

#### 创建函数

| 函数名称 | ��据类型 |
| --- | --- |
| `meshgrid` | 任意类型（所有输入数据类型必须相同） |

#### 线性代数函数

| 函数名称 | 数据类型 |
| --- | --- |
| `cholesky` | 浮点数 |
| `cross` | 数值型 |
| `det` | 浮点数 |
| `diagonal` | 任意类型 |
| `eigh` | 浮点数 |
| `eighvals` | 浮点数 |
| `inv` | 浮点数 |
| `matmul` | 数值型 |
| `matrix_norm` (*) | 浮点数 |
| `matrix_power` | 浮点数 |
| `matrix_rank` | 浮点数 |
| `matrix_transpose` (**) | 任意类型 |
| `outer` | 数值型 |
| `pinv` | 浮点数 |
| `qr` | 浮点数 |
| `slogdet` | 浮点数 |
| `solve` | 浮点数 |
| `svd` | 浮点数 |
| `svdvals` (**) | 浮点数 |
| `tensordot` | 数值型 |
| `trace` | 数值型 |
| `vecdot` (**) | 数值型 |
| `vector_norm` (*) | 浮点数 |

(*) 这些函数是从主`numpy`命名空间中的`norm`中拆分出来的。请参阅函数名称更改。

(**) 这些函数是数组 API 中的新功能，不在主`numpy`命名空间中。

#### 数组对象

所有数组对象上的特殊`__operator__`方法的行为与其对应的函数完全相同（请参阅[规范](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods)以获取哪些方法对应于哪些函数的列表）。唯一的例外是运算符明确允许根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)使用 Python 标量（请参阅类型提升差异）。

#### 逐元素函数

| 函数名称 | 数据类型 |
| --- | --- |
| `abs` | 数值 |
| `acos` | 浮点数 |
| `acosh` | 浮点数 |
| `add` | 数值 |
| `asin` (*) | 浮点数 |
| `asinh` (*) | 浮点数 |
| `atan` (*) | 浮点数 |
| `atan2` (*) | 浮点数 |
| `atanh` (*) | 浮点数 |
| `bitwise_and` | 整数或布尔值 |
| `bitwise_invert` | 整数或布尔值 |
| `bitwise_left_shift` (*) | 整数 |
| `bitwise_or` | 整数或布尔值 |
| `bitwise_right_shift` (*) | 整数 |
| `bitwise_xor` | 整数或布尔值 |
| `ceil` | 数值 |
| `cos` | 浮点数 |
| `cosh` | 浮点数 |
| `divide` | 浮点数 |
| `equal` | 所有 |
| `exp` | 浮点数 |
| `expm1` | 浮点数 |
| `floor` | 数值 |
| `floor_divide` | 数值 |
| `greater` | 数值 |
| `greater_equal` | 数值 |
| `isfinite` | 数值 |
| `isinf` | 数值 |
| `isnan` | 数值 |
| `less` | 数值 |
| `less_equal` | 数值 |
| `log` | 浮点数 |
| `logaddexp` | 浮点数 |
| `log10` | 浮点数 |
| `log1p` | 浮点数 |
| `log2` | 浮点数 |
| `logical_and` | 布尔值 |
| `logical_not` | 布尔值 |
| `logical_or` | 布尔值 |
| `logical_xor` | 布尔��� |
| `multiply` | 数值 |
| `negative` | 数值 |
| `not_equal` | 所有 |
| `positive` | 数值 |
| `pow` (*) | 数值 |
| `remainder` | 数值 |
| `round` | 数值 |
| `sign` | 数值 |
| `sin` | 浮点数 |
| `sinh` | 浮点数 |
| `sqrt` | 浮点数 |
| `square` | 数值 |
| `subtract` | 数值 |
| `tan` | 浮点数 |
| `tanh` | 浮点数 |
| `trunc` | 数值 |

(*) 这些函数与主`numpy`命名空间中的名称不同。请参阅函数名称更改。

#### 创建函数

| 函数名称 | 数据类型 |
| --- | --- |
| `meshgrid` | 任意（所有输入数据类型必须相同） |

#### 线性代数函数

| 函数名称 | 数据类型 |
| --- | --- |
| `cholesky` | 浮点数 |
| `cross` | 数值 |
| `det` | 浮点数 |
| `diagonal` | 任意 |
| `eigh` | 浮点数 |
| `eighvals` | 浮点数 |
| `inv` | 浮点数 |
| `matmul` | 数值 |
| `matrix_norm` (*) | 浮点数 |
| `matrix_power` | 浮点数 |
| `matrix_rank` | 浮点数 |
| `matrix_transpose` (**) | 任意 |
| `outer` | 数值型 |
| `pinv` | 浮点数 |
| `qr` | 浮点数 |
| `slogdet` | 浮点数 |
| `solve` | 浮点数 |
| `svd` | 浮点数 |
| `svdvals` (**) | 浮点数 |
| `tensordot` | 数值型 |
| `trace` | 数值型 |
| `vecdot` (**) | 数值型 |
| `vector_norm` (*) | 浮点数 |

(*) 这些函数从主 `numpy` 命名空间的 `norm` 中拆分出来。参见 函数名称更改。

(**) 这些函数是数组 API 中的新功能，不在主 `numpy` 命名空间中。

#### 数组对象

数组对象上的所有特殊 `__operator__` 方法的行为与其对应的函数完全相同（请参阅 [规范](https://data-apis.org/array-api/latest/API_specification/array_object.html#methods) 以查看哪些方法对应哪些函数）。唯一的例外是，根据[规范中概述的规则](https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars)（请参见 类型提升差异），运算符明确允许 Python 标量。

### 数组对象差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 没有数组标量 | **严格性** | 规范中没有数组标量，只有 0-D 数组。然而，除了在 类型提升差异 中概述的提升差异之外，标量在规范中作为 0-D 数组进行鸭子类型处理。它们是不可变的，但规范[不要求可变性](https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html)。 |
| `bool()`、`int()` 和 `float()` 仅适用于 0-D 数组。 | **严格性** | 参见 [`github.com/numpy/numpy/issues/10404`](https://github.com/numpy/numpy/issues/10404)。 |
| `__imatmul__` | **兼容性** | `np.ndarray` 目前未实现 `__imatmul__`。请注意，仅当它不改变 `a` 的形状时，`a @= b` 才应该被定义。 |
| 矩阵转置的 `mT` 属性。 | **兼容性** | 参见 [规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html) 中的 `mT`。 |
| ��果输入不是二维的，则 `T` 属性应该报错。 | **破坏性变更** | 参见 [规范中的注释](https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html)。 |
| 新方法 `to_device` 和属性 `device` | **兼容性** | 这些方法实际上不会做任何事情，因为 NumPy 只支持 CPU。 |

### 创建函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `asarray` 的 `copy` 关键字参数 | **兼容性** |  |
| 所有数组创建函数（`asarray`、`arange`、`empty`、`empty_like`、`eye`、`full`、`full_like`、`linspace`、`ones`、`ones_like`、`zeros`和`zeros_like`）新增`device`关键字参数。 | **兼容性** | `device`实际上不会起作用，因为 NumPy 仅支持 CPU。 |

### 逐元素函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 各种函数已更名。 | **兼容性** | 参见函数名称更改。 |
| 逐元素函数仅对给定的输入类型组合定义。 | **严格性** | 参见类型严格性。 |
| `bitwise_left_shift`和`bitwise_right_shift`仅对`x2`非负数定义。 | **严格性** |  |
| `ceil`、`floor`和`trunc`在整数输入时返回整数。 | **破坏性变化** | `np.ceil`、`np.floor`和`np.trunc`在整数 dtype 输入时返回浮点 dtype。 |

### 线性代数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `cholesky`包括一个`upper`关键字参数。 | **兼容性** |  |
| `cross`不允许大小为 2 的向量（仅允许大小为 3）。 | **破坏性变化** |  |
| `diagonal`在最后两个轴上操作。 | **破坏性变化** | 严格来说，这可能是**兼容的**，因为`diagonal`已移至`linalg`命名空间。 |
| `eigh`、`qr`、`slogdet`和`svd`返回一个命名元组。 | **兼容性** | 相应的`numpy`函数返回一个`tuple`，其中结果数组的顺序相同。 |
| 新函数`matrix_norm`和`vector_norm`。 | **兼容性** | `norm`函数已从数组 API 中省略，并分为矩阵范数`matrix_norm`和向量范数`vector_norm`。请注意，`vector_norm`支持任意���量的轴，而`np.linalg.norm`仅支持向量范数的单个轴。 |
| `matrix_rank`有一个`rtol`关键字参数，而不是`tol`。 | **破坏性变化** | 在数组 API 中，`rtol`过滤小于`rtol * largest_singular_value`的奇异值。在`np.linalg.matrix_rank`中，`tol`过滤小于`tol`的奇异值。此外，`rtol`的默认值是`max(M, N) * eps`，而`np.linalg.matrix_rank`中`tol`的默认值是`S.max() * max(M, N) * eps`，其中`S`是输入的奇异值。新标志名称是兼容的，但默认更改是破坏性的 |
| `matrix_rank`不支持 1 维数组。 | **破坏性变化** |  |
| 新函数`matrix_transpose`。 | **兼容性** | 与`np.transpose`不同，`matrix_transpose`仅转置最后两个轴。参见[规范定义](https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose) |
| `outer`仅支持 1 维数组。 | **破坏性变化** | 规范目前仅指定了对 1-D 数组的行为，但未来的行为可能是广播，而不是展平，这是`np.outer`的行为。 |
| `pinv`具有`rtol`关键字参数而不是`rcond` | **破坏性** | `rtol`和`rcond`的含义相同，但`rtol`的默认值为`max(M, N) * eps`，而`rcond`的默认值为`1e-15`。 新标志名称兼容，但默认更改是破坏性的。 |
| `solve`仅在`x2`恰好为 1 维时接受作为向量。 | **破坏性** | `np.linalg.solve`的行为是模棱两可的。有关更多详细信息，请参阅[此 numpy 问题](https://github.com/numpy/numpy/issues/15349)和[此数组 API 规范问题](https://github.com/data-apis/array-api/issues/285)。 |
| 新函数`svdvals`。 | **兼容** | 等同于`np.linalg.svd(compute_uv=False)`。 |
| `tensordot`的`axis`关键字必须是一个元组。 | **兼容** | 在`np.tensordot`中，也可以是数组或类似数组。 |
| `trace`在最后两个轴上操作。 | **破坏性** | `np.trace`默认在前两个轴上操作。请注意，数组 API 的`trace`不允许指定要操作的轴。 |

### 操作函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 各种函数已更名 | **兼容** | 参见函数名称更改。 |
| `concat`具有与`np.concatenate`不同的默认转换规则 | **严格性** | 不允许跨类型转换。���标量上没有基于值的转换（当 axis=None 时）。 |
| `stack`具有与`np.stack`不同的默认转换规则 | **严格性** | 不允许跨类型转换。 |
| 新函数`permute_dims`。 | **兼容** | 与`np.transpose`不同，`permute_dims`需要`axis`关键字参数。 |
| `reshape`函数具有`copy`关键字参数 | **兼容** | 参见[`github.com/numpy/numpy/issues/9818`](https://github.com/numpy/numpy/issues/9818)。 |

### 集合函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| 新函数`unique_all`、`unique_counts`、`unique_inverse`和`unique_values`。 | **兼容** | 参见函数名称更改。 |
| 四个`unique_*`函数返回一个命名元组。 | **兼容** |  |
| `unique_all`和`unique_indices`返回与`x`相同形状的索引。 | **兼容** | 参见[`github.com/numpy/numpy/issues/20638`](https://github.com/numpy/numpy/issues/20638)。 |

### 集合函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `argsort`和`sort`具有`stable`关键字参数而不是`kind`。 | **破坏性** | `stable`是一个布尔关键字参数，默认为`True`。 `kind`接受一个字符串，默认为`"quicksort"`。 `stable=True`等同于`kind="stable"`，`kind=False`等同于`kind="quicksort"`，尽管在`stable=False`时允许任何排序算法。 新标志名称兼容，但默认更改是破坏性的。 |
| `argsort`和`sort`具有`descending`关键字参数。 | **兼容** |  |

### 统计函数差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| `sum` 和 `prod` 在 `dtype=None` 时总是将 `float32` 上转型为 `float64`。 | **破坏性** |  |
| `std` 和 `var` 函数有一个 `correction` 关键字参数，而不是 `ddof`。 | **兼容性** |  |

### 其他差异

| 特性 | 类型 | 注释 |
| --- | --- | --- |
| Dtypes 只能以 dtype 对象的形式拼写。 | **严格性** | 例如，`numpy.array_api.asarray([0], dtype='int32')` 是不允许的。 |
| `asarray` 在任何函数中都不会被隐式调用。 | **严格性** | 例外情况是 Python 运算符，在某些情况下接受 Python 标量（参见类型提升差异）。 |
| `tril` 和 `triu` 要求输入至少为 2-D。 | **严格性** |  |
| finfo() 返回类型使用 `float` 作为各个属性。 | **严格性** | 规范允许鸭子类型，因此 `finfo` 返回 dtype 标量被认为与 `float` 兼容。 |
| 每个函数中的位置参数都是仅限位置的。 | **破坏性** | 查看每个函数的确切签名的规范。请注意，NumPy 的 ufuncs 已经使用了仅限位置的参数，但非 ufunc，如 `asarray` 通常不会。 |
