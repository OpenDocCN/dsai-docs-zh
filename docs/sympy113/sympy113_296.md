# 统计

> 原文：[`docs.sympy.org/latest/modules/stats.html`](https://docs.sympy.org/latest/modules/stats.html)

SymPy 统计模块

引入了一个随机变量类型到 SymPy 语言中。

可以使用预构建函数（如正态分布、指数分布、硬币、骰子等）声明随机变量，也可以使用函数（如 FiniteRV）构建随机变量。

可以使用函数查询随机表达式

| 表达式 | 含义 |
| --- | --- |
| `P(condition)` | 概率 |
| `E(expression)` | 期望值 |
| `H(expression)` | 熵 |
| `variance(expression)` | 方差 |
| `density(expression)` | 概率密度函数 |
| `sample(expression)` | 生成实现 |
| `where(condition)` | 条件为真时 |

## 示例

```py
>>> from sympy.stats import P, E, variance, Die, Normal
>>> from sympy import simplify
>>> X, Y = Die('X', 6), Die('Y', 6) # Define two six sided dice
>>> Z = Normal('Z', 0, 1) # Declare a Normal random variable with mean 0, std 1
>>> P(X>3) # Probability X is greater than 3
1/2
>>> E(X+Y) # Expectation of the sum of two dice
7
>>> variance(X+Y) # Variance of the sum of two dice
35/6
>>> simplify(P(Z>1)) # Probability of Z being greater than 1
1/2 - erf(sqrt(2)/2)/2 
```

您也可以创建自定义分布，并定义自定义随机变量，如下所示：

1.  如果您想创建连续随机变量：

```py
>>> from sympy.stats import ContinuousRV, P, E
>>> from sympy import exp, Symbol, Interval, oo
>>> x = Symbol('x')
>>> pdf = exp(-x) # pdf of the Continuous Distribution
>>> Z = ContinuousRV(x, pdf, set=Interval(0, oo))
>>> E(Z)
1
>>> P(Z > 5)
exp(-5) 
```

1.1 创建连续分布的实例：

```py
>>> from sympy.stats import ContinuousDistributionHandmade
>>> from sympy import Lambda
>>> dist = ContinuousDistributionHandmade(Lambda(x, pdf), set=Interval(0, oo))
>>> dist.pdf(x)
exp(-x) 
```

1.  如果您想创建离散随机变量：

```py
>>> from sympy.stats import DiscreteRV, P, E
>>> from sympy import Symbol, S
>>> p = S(1)/2
>>> x = Symbol('x', integer=True, positive=True)
>>> pdf = p*(1 - p)**(x - 1)
>>> D = DiscreteRV(x, pdf, set=S.Naturals)
>>> E(D)
2
>>> P(D > 3)
1/8 
```

2.1 创建离散分布的实例：

```py
>>> from sympy.stats import DiscreteDistributionHandmade
>>> from sympy import Lambda
>>> dist = DiscreteDistributionHandmade(Lambda(x, pdf), set=S.Naturals)
>>> dist.pdf(x)
2**(1 - x)/2 
```

1.  如果您想创建有限随机变量：

```py
>>> from sympy.stats import FiniteRV, P, E
>>> from sympy import Rational, Eq
>>> pmf = {1: Rational(1, 3), 2: Rational(1, 6), 3: Rational(1, 4), 4: Rational(1, 4)}
>>> X = FiniteRV('X', pmf)
>>> E(X)
29/12
>>> P(X > 3)
1/4 
```

3.1 创建有限分布的实例：

```py
>>> from sympy.stats import FiniteDistributionHandmade
>>> dist = FiniteDistributionHandmade(pmf)
>>> dist.pmf(x)
Lambda(x, Piecewise((1/3, Eq(x, 1)), (1/6, Eq(x, 2)), (1/4, Eq(x, 3) | Eq(x, 4)), (0, True))) 
```

## 随机变量类型

### 有限类型

```py
sympy.stats.DiscreteUniform(name, items)
```

创建一个表示输入集合上均匀分布的有限随机变量。

参数：

**items**：列表/元组

> 生成均匀分布的项目

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import DiscreteUniform, density
>>> from sympy import symbols 
```

```py
>>> X = DiscreteUniform('X', symbols('a b c')) # equally likely over a, b, c
>>> density(X).dict
{a: 1/3, b: 1/3, c: 1/3} 
```

```py
>>> Y = DiscreteUniform('Y', list(range(5))) # distribution over a range
>>> density(Y).dict
{0: 1/5, 1: 1/5, 2: 1/5, 3: 1/5, 4: 1/5} 
```

参考文献

[R896]

[`en.wikipedia.org/wiki/Discrete_uniform_distribution`](https://en.wikipedia.org/wiki/Discrete_uniform_distribution)

[R897]

[`mathworld.wolfram.com/DiscreteUniformDistribution.html`](https://mathworld.wolfram.com/DiscreteUniformDistribution.html)

```py
sympy.stats.Die(name, sides=6)
```

创建一个表示公平骰子的有限随机变量。

参数：

**sides**：整数

> 表示骰子的面数，默认为 6

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Die, density
>>> from sympy import Symbol 
```

```py
>>> D6 = Die('D6', 6) # Six sided Die
>>> density(D6).dict
{1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6} 
```

```py
>>> D4 = Die('D4', 4) # Four sided Die
>>> density(D4).dict
{1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4} 
```

```py
>>> n = Symbol('n', positive=True, integer=True)
>>> Dn = Die('Dn', n) # n sided Die
>>> density(Dn).dict
Density(DieDistribution(n))
>>> density(Dn).dict.subs(n, 4).doit()
{1: 1/4, 2: 1/4, 3: 1/4, 4: 1/4} 
```

```py
sympy.stats.Bernoulli(name, p, succ=1, fail=0)
```

创建一个表示伯努利过程的有限随机变量。

参数：

**p**：0 到 1 之间的有理数

> 表示成功的概率

**succ**：整数/符号/字符串

> 表示成功事件

**fail**：整数/符号/字符串

> 表示失败事件

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Bernoulli, density
>>> from sympy import S 
```

```py
>>> X = Bernoulli('X', S(3)/4) # 1-0 Bernoulli variable, probability = 3/4
>>> density(X).dict
{0: 1/4, 1: 3/4} 
```

```py
>>> X = Bernoulli('X', S.Half, 'Heads', 'Tails') # A fair coin toss
>>> density(X).dict
{Heads: 1/2, Tails: 1/2} 
```

参考文献

[R898]

[`en.wikipedia.org/wiki/Bernoulli_distribution`](https://en.wikipedia.org/wiki/Bernoulli_distribution)

[R899]

[`mathworld.wolfram.com/BernoulliDistribution.html`](https://mathworld.wolfram.com/BernoulliDistribution.html)

```py
sympy.stats.Coin(name, p=1 / 2)
```

创建一个表示抛硬币的有限随机变量。

参数：

**p**：0 到 1 之间的有理数

> 表示获得“正面”的概率，默认为一半

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Coin, density
>>> from sympy import Rational 
```

```py
>>> C = Coin('C') # A fair coin toss
>>> density(C).dict
{H: 1/2, T: 1/2} 
```

```py
>>> C2 = Coin('C2', Rational(3, 5)) # An unfair coin
>>> density(C2).dict
{H: 3/5, T: 2/5} 
```

另见

`sympy.stats.Binomial`

参考文献

[R900]

[`en.wikipedia.org/wiki/Coin_flipping`](https://en.wikipedia.org/wiki/Coin_flipping)

```py
sympy.stats.Binomial(name, n, p, succ=1, fail=0)
```

创建一个表示二项分布的有限随机变量。

参数：

**n**：正整数

> 表示试验次数

**p**：0 到 1 之间的有理数

> 表示成功的概率

**succ**：整数/符号/字符串

> 表示成功事件，默认为 1

**fail**：整数/符号/字符串

> 表示失败事件，默认为 0

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Binomial, density
>>> from sympy import S, Symbol 
```

```py
>>> X = Binomial('X', 4, S.Half) # Four "coin flips"
>>> density(X).dict
{0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16} 
```

```py
>>> n = Symbol('n', positive=True, integer=True)
>>> p = Symbol('p', positive=True)
>>> X = Binomial('X', n, S.Half) # n "coin flips"
>>> density(X).dict
Density(BinomialDistribution(n, 1/2, 1, 0))
>>> density(X).dict.subs(n, 4).doit()
{0: 1/16, 1: 1/4, 2: 3/8, 3: 1/4, 4: 1/16} 
```

参考

[R901]

[`en.wikipedia.org/wiki/Binomial_distribution`](https://en.wikipedia.org/wiki/Binomial_distribution)

[R902]

[`mathworld.wolfram.com/BinomialDistribution.html`](https://mathworld.wolfram.com/BinomialDistribution.html)

```py
sympy.stats.BetaBinomial(name, n, alpha, beta)
```

创建一个表示 Beta 二项分布的有限随机变量。

参数：

**n**：正整数

> 表示试验次数

**alpha**：实数正数

**beta**：实数正数

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import BetaBinomial, density 
```

```py
>>> X = BetaBinomial('X', 2, 1, 1)
>>> density(X).dict
{0: 1/3, 1: 2*beta(2, 2), 2: 1/3} 
```

参考

[R903]

[`en.wikipedia.org/wiki/Beta-binomial_distribution`](https://en.wikipedia.org/wiki/Beta-binomial_distribution)

[R904]

[`mathworld.wolfram.com/BetaBinomialDistribution.html`](https://mathworld.wolfram.com/BetaBinomialDistribution.html)

```py
sympy.stats.Hypergeometric(name, N, m, n)
```

创建一个表示超几何分布的有限随机变量。

参数：

**N**：正整数

> 表示大小为 N 的有限人口。

**m**：正整数

> 表示具有所需特征的试验次数。

**n**：正整数

> 表示抽取次数。

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Hypergeometric, density 
```

```py
>>> X = Hypergeometric('X', 10, 5, 3) # 10 marbles, 5 white (success), 3 draws
>>> density(X).dict
{0: 1/12, 1: 5/12, 2: 5/12, 3: 1/12} 
```

参考

[R905]

[`en.wikipedia.org/wiki/Hypergeometric_distribution`](https://en.wikipedia.org/wiki/Hypergeometric_distribution)

[R906]

[`mathworld.wolfram.com/HypergeometricDistribution.html`](https://mathworld.wolfram.com/HypergeometricDistribution.html)

```py
sympy.stats.FiniteRV(name, density, **kwargs)
```

创建一个给定表示密度的字典的有限随机变量。

参数：

**name**：符号

> 表示随机变量的名称。

**density**：字典

> 包含有限分布 pdf 的字典

**check**：布尔值

> 如果为 True，则检查给定密度是否在给定集合上积分为 1。如果为 False，则不执行此检查。默认为 False。

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import FiniteRV, P, E 
```

```py
>>> density = {0: .1, 1: .2, 2: .3, 3: .4}
>>> X = FiniteRV('X', density) 
```

```py
>>> E(X)
2.00000000000000
>>> P(X >= 2)
0.700000000000000 
```

```py
sympy.stats.Rademacher(name)
```

创建一个表示 Rademacher 分布的有限随机变量。

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Rademacher, density 
```

```py
>>> X = Rademacher('X')
>>> density(X).dict
{-1: 1/2, 1: 1/2} 
```

另见

`sympy.stats.Bernoulli`

参考

[R907]

[`en.wikipedia.org/wiki/Rademacher_distribution`](https://en.wikipedia.org/wiki/Rademacher_distribution)

### 离散类型

```py
sympy.stats.Geometric(name, p)
```

创建一个具有几何分布的离散随机变量。

参数：

**p**：介于 0 和 1 之间的概率

返回：

RandomSymbol

解释

几何分布的密度由以下给出

\[f(k) := p (1 - p)^{k - 1}\]

示例

```py
>>> from sympy.stats import Geometric, density, E, variance
>>> from sympy import Symbol, S 
```

```py
>>> p = S.One / 5
>>> z = Symbol("z") 
```

```py
>>> X = Geometric("x", p) 
```

```py
>>> density(X)(z)
(5/4)**(1 - z)/5 
```

```py
>>> E(X)
5 
```

```py
>>> variance(X)
20 
```

参考

[R908]

[`en.wikipedia.org/wiki/Geometric_distribution`](https://en.wikipedia.org/wiki/Geometric_distribution)

[R909]

[`mathworld.wolfram.com/GeometricDistribution.html`](https://mathworld.wolfram.com/GeometricDistribution.html)

```py
sympy.stats.Hermite(name, a1, a2)
```

创建一个具有 Hermite 分布的离散随机变量。

参数：

**a1**：大于等于 0 的正数。

**a2** ：一个大于等于 0 的正数

返回：

随机符号

解释

Hermite 分布的密度函数为

\[f(x):= e^{-a_1 -a_2}\sum_{j=0}^{\left \lfloor x/2 \right \rfloor} \frac{a_{1}^{x-2j}a_{2}^{j}}{(x-2j)!j!}\]

例子

```py
>>> from sympy.stats import Hermite, density, E, variance
>>> from sympy import Symbol 
```

```py
>>> a1 = Symbol("a1", positive=True)
>>> a2 = Symbol("a2", positive=True)
>>> x = Symbol("x") 
```

```py
>>> H = Hermite("H", a1=5, a2=4) 
```

```py
>>> density(H)(2)
33*exp(-9)/2 
```

```py
>>> E(H)
13 
```

```py
>>> variance(H)
21 
```

参考

[R910]

[`en.wikipedia.org/wiki/Hermite_distribution`](https://en.wikipedia.org/wiki/Hermite_distribution)

```py
sympy.stats.Poisson(name, lamda)
```

创建一个服从泊松分布的离散随机变量。

参数：

**lamda** ：一个正率值

返回：

随机符号

解释

Poisson 分布的密度函数为

\[f(k) := \frac{\lambda^{k} e^{- \lambda}}{k!}\]

例子

```py
>>> from sympy.stats import Poisson, density, E, variance
>>> from sympy import Symbol, simplify 
```

```py
>>> rate = Symbol("lambda", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Poisson("x", rate) 
```

```py
>>> density(X)(z)
lambda**z*exp(-lambda)/factorial(z) 
```

```py
>>> E(X)
lambda 
```

```py
>>> simplify(variance(X))
lambda 
```

参考

[R911]

[`en.wikipedia.org/wiki/Poisson_distribution`](https://en.wikipedia.org/wiki/Poisson_distribution)

[R912]

[`mathworld.wolfram.com/PoissonDistribution.html`](https://mathworld.wolfram.com/PoissonDistribution.html)

```py
sympy.stats.Logarithmic(name, p)
```

创建一个服从对数分布的离散随机变量。

参数：

**p** ：一个介于 0 和 1 之间的值

返回：

随机符号

解释

对数分布的密度函数为

\[f(k) := \frac{-p^k}{k \ln{(1 - p)}}\]

例子

```py
>>> from sympy.stats import Logarithmic, density, E, variance
>>> from sympy import Symbol, S 
```

```py
>>> p = S.One / 5
>>> z = Symbol("z") 
```

```py
>>> X = Logarithmic("x", p) 
```

```py
>>> density(X)(z)
-1/(5**z*z*log(4/5)) 
```

```py
>>> E(X)
-1/(-4*log(5) + 8*log(2)) 
```

```py
>>> variance(X)
-1/((-4*log(5) + 8*log(2))*(-2*log(5) + 4*log(2))) + 1/(-64*log(2)*log(5) + 64*log(2)**2 + 16*log(5)**2) - 10/(-32*log(5) + 64*log(2)) 
```

参考

[R913]

[`en.wikipedia.org/wiki/Logarithmic_distribution`](https://en.wikipedia.org/wiki/Logarithmic_distribution)

[R914]

[`mathworld.wolfram.com/LogarithmicDistribution.html`](https://mathworld.wolfram.com/LogarithmicDistribution.html)

```py
sympy.stats.NegativeBinomial(name, r, p)
```

创建一个服从负二项分布的离散随机变量。

参数：

**r** ：一个正数

**p** ：一个介于 0 和 1 之间的值

返回：

随机符号

解释

负二项分布的密度函数为

\[f(k) := \binom{k + r - 1}{k} (1 - p)^r p^k\]

例子

```py
>>> from sympy.stats import NegativeBinomial, density, E, variance
>>> from sympy import Symbol, S 
```

```py
>>> r = 5
>>> p = S.One / 5
>>> z = Symbol("z") 
```

```py
>>> X = NegativeBinomial("x", r, p) 
```

```py
>>> density(X)(z)
1024*binomial(z + 4, z)/(3125*5**z) 
```

```py
>>> E(X)
5/4 
```

```py
>>> variance(X)
25/16 
```

参考

[R915]

[`en.wikipedia.org/wiki/Negative_binomial_distribution`](https://en.wikipedia.org/wiki/Negative_binomial_distribution)

[R916]

[`mathworld.wolfram.com/NegativeBinomialDistribution.html`](https://mathworld.wolfram.com/NegativeBinomialDistribution.html)

```py
sympy.stats.Skellam(name, mu1, mu2)
```

创建一个服从 Skellam 分布的离散随机变量。

参数：

**mu1** ：一个非负值

**mu2** ：一个非负值

返回：

随机符号

解释

Skellam 分布是两个统计独立的泊松分布随机变量 N1 和 N2 差值 N1 - N2 的分布，其期望值分别为 mu1 和 mu2。

Skellam 分布的密度函数为

\[f(k) := e^{-(\mu_1+\mu_2)}(\frac{\mu_1}{\mu_2})^{k/2}I_k(2\sqrt{\mu_1\mu_2})\]

例子

```py
>>> from sympy.stats import Skellam, density, E, variance
>>> from sympy import Symbol, pprint 
```

```py
>>> z = Symbol("z", integer=True)
>>> mu1 = Symbol("mu1", positive=True)
>>> mu2 = Symbol("mu2", positive=True)
>>> X = Skellam("x", mu1, mu2) 
```

```py
>>> pprint(density(X)(z), use_unicode=False)
 z
 -
 2
/mu1\   -mu1 - mu2        /       _____   _____\
|---| *e          *besseli\z, 2*\/ mu1 *\/ mu2 /
\mu2/
>>> E(X)
mu1 - mu2
>>> variance(X).expand()
mu1 + mu2 
```

参考

[R917]

[`en.wikipedia.org/wiki/Skellam_distribution`](https://en.wikipedia.org/wiki/Skellam_distribution)

```py
sympy.stats.YuleSimon(name, rho)
```

创建一个服从 Yule-Simon 分布的离散随机变量。

参数：

**rho** ：一个正数

返回：

随机符号

解释

Yule-Simon 分布的密度函数为

\[f(k) := \rho B(k, \rho + 1)\]

例子

```py
>>> from sympy.stats import YuleSimon, density, E, variance
>>> from sympy import Symbol, simplify 
```

```py
>>> p = 5
>>> z = Symbol("z") 
```

```py
>>> X = YuleSimon("x", p) 
```

```py
>>> density(X)(z)
5*beta(z, 6) 
```

```py
>>> simplify(E(X))
5/4 
```

```py
>>> simplify(variance(X))
25/48 
```

参考

[R918]

[`en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution`](https://en.wikipedia.org/wiki/Yule%E2%80%93Simon_distribution)

```py
sympy.stats.Zeta(name, s)
```

使用 Zeta 分布创建离散随机变量。

参数：

**s**：大于 1 的值

返回：

随机符号

解释

Zeta 分布的密度函数为

\[f(k) := \frac{1}{k^s \zeta{(s)}}\]

示例

```py
>>> from sympy.stats import Zeta, density, E, variance
>>> from sympy import Symbol 
```

```py
>>> s = 5
>>> z = Symbol("z") 
```

```py
>>> X = Zeta("x", s) 
```

```py
>>> density(X)(z)
1/(z**5*zeta(5)) 
```

```py
>>> E(X)
pi**4/(90*zeta(5)) 
```

```py
>>> variance(X)
-pi**8/(8100*zeta(5)**2) + zeta(3)/zeta(5) 
```

参考文献

[R919]

[`en.wikipedia.org/wiki/Zeta_distribution`](https://en.wikipedia.org/wiki/Zeta_distribution)

### 连续类型

```py
sympy.stats.Arcsin(name, a=0, b=1)
```

使用 arcsin 分布创建连续随机变量。

arcsin 分布的密度函数为

\[f(x) := \frac{1}{\pi\sqrt{(x-a)(b-x)}}\]

对于 \(x \in (a,b)\)，必须满足 \(-\infty < a < b < \infty\)。

参数：

**a**：实数，左区间边界

**b**：实数，右区间边界

返回：

随机符号

示例

```py
>>> from sympy.stats import Arcsin, density, cdf
>>> from sympy import Symbol 
```

```py
>>> a = Symbol("a", real=True)
>>> b = Symbol("b", real=True)
>>> z = Symbol("z") 
```

```py
>>> X = Arcsin("x", a, b) 
```

```py
>>> density(X)(z)
1/(pi*sqrt((-a + z)*(b - z))) 
```

```py
>>> cdf(X)(z)
Piecewise((0, a > z),
 (2*asin(sqrt((-a + z)/(-a + b)))/pi, b >= z),
 (1, True)) 
```

参考文献

[R920]

[`en.wikipedia.org/wiki/Arcsine_distribution`](https://en.wikipedia.org/wiki/Arcsine_distribution)

```py
sympy.stats.Benini(name, alpha, beta, sigma)
```

使用 Benini 分布创建连续随机变量。

Benini 分布的密度函数为

\[f(x) := e^{-\alpha\log{\frac{x}{\sigma}} -\beta\log²\left[{\frac{x}{\sigma}}\right]} \left(\frac{\alpha}{x}+\frac{2\beta\log{\frac{x}{\sigma}}}{x}\right)\]

这是一个重尾分布，也称为对数瑞利分布。

参数：

**alpha**：实数，\(\alpha > 0\)，形状参数

**beta**：实数，\(\beta > 0\)，形状参数

**sigma**：实数，\(\sigma > 0\)，尺度参数

返回：

随机符号

示例

```py
>>> from sympy.stats import Benini, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> alpha = Symbol("alpha", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> sigma = Symbol("sigma", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Benini("x", alpha, beta, sigma) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
/                  /  z  \\             /  z  \            2/  z  \
|        2*beta*log|-----||  - alpha*log|-----| - beta*log  |-----|
|alpha             \sigma/|             \sigma/             \sigma/
|----- + -----------------|*e
\  z             z        / 
```

```py
>>> cdf(X)(z)
Piecewise((1 - exp(-alpha*log(z/sigma) - beta*log(z/sigma)**2), sigma <= z),
 (0, True)) 
```

参考文献

[R921]

[`en.wikipedia.org/wiki/Benini_distribution`](https://en.wikipedia.org/wiki/Benini_distribution)

[R922]

[`reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html`](https://reference.wolfram.com/legacy/v8/ref/BeniniDistribution.html)

```py
sympy.stats.Beta(name, alpha, beta)
```

使用 Beta 分布创建连续随机变量。

贝塔分布的密度函数为

\[f(x) := \frac{x^{\alpha-1}(1-x)^{\beta-1}} {\mathrm{B}(\alpha,\beta)}\]

对于 \(x \in [0,1]\)。

参数：

**alpha**：实数，\(\alpha > 0\)，形状参数

**beta**：实数，\(\beta > 0\)，形状参数

返回：

随机符号

示例

```py
>>> from sympy.stats import Beta, density, E, variance
>>> from sympy import Symbol, simplify, pprint, factor 
```

```py
>>> alpha = Symbol("alpha", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Beta("x", alpha, beta) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 alpha - 1        beta - 1
z         *(1 - z)
--------------------------
 B(alpha, beta) 
```

```py
>>> simplify(E(X))
alpha/(alpha + beta) 
```

```py
>>> factor(simplify(variance(X)))
alpha*beta/((alpha + beta)**2*(alpha + beta + 1)) 
```

参考文献

[R923]

[`en.wikipedia.org/wiki/Beta_distribution`](https://en.wikipedia.org/wiki/Beta_distribution)

[R924]

[`mathworld.wolfram.com/BetaDistribution.html`](https://mathworld.wolfram.com/BetaDistribution.html)

```py
sympy.stats.BetaNoncentral(name, alpha, beta, lamda)
```

使用 Type I 非中心贝塔分布创建连续随机变量。

非中心贝塔分布的密度函数为

\[f(x) := \sum_{k=0}^\infty e^{-\lambda/2}\frac{(\lambda/2)^k}{k!} \frac{x^{\alpha+k-1}(1-x)^{\beta-1}}{\mathrm{B}(\alpha+k,\beta)}\]

对于 \(x \in [0,1]\)。

参数：

**alpha**：实数，\(\alpha > 0\)，形状参数

**beta**：实数，\(\beta > 0\)，形状参数

**lamda**：实数，\(\lambda \geq 0\)，非中心参数

返回：

随机符号

示例

```py
>>> from sympy.stats import BetaNoncentral, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> alpha = Symbol("alpha", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> lamda = Symbol("lamda", nonnegative=True)
>>> z = Symbol("z") 
```

```py
>>> X = BetaNoncentral("x", alpha, beta, lamda) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 oo
_____
\    `
 \                                              -lamda
 \                          k                  -------
 \    k + alpha - 1 /lamda\         beta - 1     2
 )  z             *|-----| *(1 - z)        *e
 /                  \  2  /
 /    ------------------------------------------------
 /                  B(k + alpha, beta)*k!
/____,
k = 0 
```

使用特定的 'x', 'alpha', 'beta' 和 'lamda' 值计算累积分布函数如下：

```py
>>> cdf(BetaNoncentral("x", 1, 1, 1), evaluate=False)(2).doit()
2*exp(1/2) 
```

参数 evaluate=False 阻止在传递参数 2 之前对一般 x 进行求和的尝试。

参考文献

[R925]

[`en.wikipedia.org/wiki/Noncentral_beta_distribution`](https://en.wikipedia.org/wiki/Noncentral_beta_distribution)

[R926]

[`reference.wolfram.com/language/ref/NoncentralBetaDistribution.html`](https://reference.wolfram.com/language/ref/NoncentralBetaDistribution.html)

```py
sympy.stats.BetaPrime(name, alpha, beta)
```

创建一个具有 Beta prime 分布的连续随机变量。

Beta prime 分布的密度函数为

\[f(x) := \frac{x^{\alpha-1} (1+x)^{-\alpha -\beta}}{B(\alpha,\beta)}\]

当 \(x > 0\) 时。

参数：

**alpha** : 实数, \(\alpha > 0\), 一个形状

**beta** : 实数, \(\beta > 0\), 一个形状

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import BetaPrime, density
>>> from sympy import Symbol, pprint 
```

```py
>>> alpha = Symbol("alpha", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = BetaPrime("x", alpha, beta) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 alpha - 1        -alpha - beta
z         *(z + 1)
-------------------------------
 B(alpha, beta) 
```

参考文献

[R927]

[`en.wikipedia.org/wiki/Beta_prime_distribution`](https://en.wikipedia.org/wiki/Beta_prime_distribution)

[R928]

[`mathworld.wolfram.com/BetaPrimeDistribution.html`](https://mathworld.wolfram.com/BetaPrimeDistribution.html)

```py
sympy.stats.BoundedPareto(name, alpha, left, right)
```

创建一个具有 Bounded Pareto 分布的连续随机变量。

Bounded Pareto 分布的密度函数为

\[f(x) := \frac{\alpha L^{\alpha}x^{-\alpha-1}}{1-(\frac{L}{H})^{\alpha}}\]

参数：

**alpha** : 实数, \(\alpha > 0\)

> 形状参数

**left** : 实数, \(left > 0\)

> 位置参数

**right** : 实数, \(right > left\)

> 位置参数

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import BoundedPareto, density, cdf, E
>>> from sympy import symbols
>>> L, H = symbols('L, H', positive=True)
>>> X = BoundedPareto('X', 2, L, H)
>>> x = symbols('x')
>>> density(X)(x)
2*L**2/(x**3*(1 - L**2/H**2))
>>> cdf(X)(x)
Piecewise((-H**2*L**2/(x**2*(H**2 - L**2)) + H**2/(H**2 - L**2), L <= x), (0, True))
>>> E(X).simplify()
2*H*L/(H + L) 
```

参考文献

[R929]

[`en.wikipedia.org/wiki/Pareto_distribution#Bounded_Pareto_distribution`](https://en.wikipedia.org/wiki/Pareto_distribution#Bounded_Pareto_distribution)

```py
sympy.stats.Cauchy(name, x0, gamma)
```

创建一个具有 Cauchy 分布的连续随机变量。

Cauchy 分布的密度函数为

\[f(x) := \frac{1}{\pi \gamma [1 + {(\frac{x-x_0}{\gamma})}²]}\]

参数：

**x0** : 实数, 位置

**gamma** : 实数, \(\gamma > 0\), 一个尺度

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Cauchy, density
>>> from sympy import Symbol 
```

```py
>>> x0 = Symbol("x0")
>>> gamma = Symbol("gamma", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Cauchy("x", x0, gamma) 
```

```py
>>> density(X)(z)
1/(pi*gamma*(1 + (-x0 + z)**2/gamma**2)) 
```

参考文献

[R930]

[`en.wikipedia.org/wiki/Cauchy_distribution`](https://en.wikipedia.org/wiki/Cauchy_distribution)

[R931]

[`mathworld.wolfram.com/CauchyDistribution.html`](https://mathworld.wolfram.com/CauchyDistribution.html)

```py
sympy.stats.Chi(name, k)
```

创建一个具有 Chi 分布的连续随机变量。

Chi 分布的密度函数为

\[f(x) := \frac{2^{1-k/2}x^{k-1}e^{-x²/2}}{\Gamma(k/2)}\]

当 \(x \geq 0\) 时。

参数：

**k** : 正整数, 自由度数目

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import Chi, density, E
>>> from sympy import Symbol, simplify 
```

```py
>>> k = Symbol("k", integer=True)
>>> z = Symbol("z") 
```

```py
>>> X = Chi("x", k) 
```

```py
>>> density(X)(z)
2**(1 - k/2)*z**(k - 1)*exp(-z**2/2)/gamma(k/2) 
```

```py
>>> simplify(E(X))
sqrt(2)*gamma(k/2 + 1/2)/gamma(k/2) 
```

参考文献

[R932]

[`en.wikipedia.org/wiki/Chi_distribution`](https://en.wikipedia.org/wiki/Chi_distribution)

[R933]

[`mathworld.wolfram.com/ChiDistribution.html`](https://mathworld.wolfram.com/ChiDistribution.html)

```py
sympy.stats.ChiNoncentral(name, k, l)
```

创建一个具有非中心 Chi 分布的连续随机变量。

参数：

**k** : 正整数, \(k > 0\)

> 自由度数目。

**lambda** : 实数, \(\lambda > 0\)

> 移动参数。

返回:

RandomSymbol

解释

非中心卡方分布的密度由

\[f(x) := \frac{e^{-(x²+\lambda²)/2} x^k\lambda} {(\lambda x)^{k/2}} I_{k/2-1}(\lambda x)\]

其中 \(x \geq 0\). 这里，\(I_\nu (x)\) 是第一类修正贝塞尔函数。

例子

```py
>>> from sympy.stats import ChiNoncentral, density
>>> from sympy import Symbol 
```

```py
>>> k = Symbol("k", integer=True)
>>> l = Symbol("l")
>>> z = Symbol("z") 
```

```py
>>> X = ChiNoncentral("x", k, l) 
```

```py
>>> density(X)(z)
l*z**k*exp(-l**2/2 - z**2/2)*besseli(k/2 - 1, l*z)/(l*z)**(k/2) 
```

参考

[R934]

[`en.wikipedia.org/wiki/Noncentral_chi_distribution`](https://en.wikipedia.org/wiki/Noncentral_chi_distribution)是指非中心卡方分布。

```py
sympy.stats.ChiSquared(name, k)
```

创建一个具有卡方分布的连续随机变量。

参数:

**k** : 正整数

> 自由度的数量。

返回:

RandomSymbol

解释

卡方分布的密度由

\[f(x) := \frac{1}{2^{\frac{k}{2}}\Gamma\left(\frac{k}{2}\right)} x^{\frac{k}{2}-1} e^{-\frac{x}{2}}\]

其中 \(x \geq 0\).

例子

```py
>>> from sympy.stats import ChiSquared, density, E, variance, moment
>>> from sympy import Symbol 
```

```py
>>> k = Symbol("k", integer=True, positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = ChiSquared("x", k) 
```

```py
>>> density(X)(z)
z**(k/2 - 1)*exp(-z/2)/(2**(k/2)*gamma(k/2)) 
```

```py
>>> E(X)
k 
```

```py
>>> variance(X)
2*k 
```

```py
>>> moment(X, 3)
k**3 + 6*k**2 + 8*k 
```

参考

[R935]

[`en.wikipedia.org/wiki/Chi_squared_distribution`](https://en.wikipedia.org/wiki/Chi_squared_distribution)是指卡方分布。

[R936]给出。

[`mathworld.wolfram.com/Chi-SquaredDistribution.html`](https://mathworld.wolfram.com/Chi-SquaredDistribution.html)

```py
sympy.stats.Dagum(name, p, a, b)
```

创建一个具有 Dagum 分布的连续随机变量。

参数:

**p** : 实数

> \(p > 0\), 一种形状。

**a** : 实数

> \(a > 0\), 一种形状。

**b** : 实数

> \(b > 0\), 一个尺度。

返回:

RandomSymbol

解释

Dagum 分布的密度由

\[f(x) := \frac{a p}{x} \left( \frac{\left(\tfrac{x}{b}\right)^{a p}} {\left(\left(\tfrac{x}{b}\right)^a + 1 \right)^{p+1}} \right)\]

其中 \(x > 0\).

例子

```py
>>> from sympy.stats import Dagum, density, cdf
>>> from sympy import Symbol 
```

```py
>>> p = Symbol("p", positive=True)
>>> a = Symbol("a", positive=True)
>>> b = Symbol("b", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Dagum("x", p, a, b) 
```

```py
>>> density(X)(z)
a*p*(z/b)**(a*p)*((z/b)**a + 1)**(-p - 1)/z 
```

```py
>>> cdf(X)(z)
Piecewise(((1 + (z/b)**(-a))**(-p), z >= 0), (0, True)) 
```

参考

[R937]

[`en.wikipedia.org/wiki/Dagum_distribution`](https://en.wikipedia.org/wiki/Dagum_distribution)

```py
sympy.stats.Davis(name, b, n, mu)
```

创建一个具有 Davis 分布的连续随机变量。

参数:

**b** : 实数

> \(p > 0\), 一个尺度。

**n** : 实数

> \(n > 1\), 一种形状。

**mu** : 实数

> \(mu > 0\), 一个位置。

返回:

RandomSymbol

解释

Davis 分布的密度由

\[f(x; \mu; b, n) := \frac{b^{n}(x - \mu)^{1-n}}{ \left( e^{\frac{b}{x-\mu}} - 1 \right) \Gamma(n)\zeta(n)}\]

其中 \(x \in [0,\infty]\).

Davis 分布是来自统计物理学的普朗克辐射定律的一般化。用于建模收入分布。

例子

```py
>>> from sympy.stats import Davis, density
>>> from sympy import Symbol
>>> b = Symbol("b", positive=True)
>>> n = Symbol("n", positive=True)
>>> mu = Symbol("mu", positive=True)
>>> z = Symbol("z")
>>> X = Davis("x", b, n, mu)
>>> density(X)(z)
b**n*(-mu + z)**(-n - 1)/((exp(b/(-mu + z)) - 1)*gamma(n)*zeta(n)) 
```

参考

[R938]

[`en.wikipedia.org/wiki/Davis_distribution`](https://en.wikipedia.org/wiki/Davis_distribution)

[R939]

[`reference.wolfram.com/language/ref/DavisDistribution.html`](https://reference.wolfram.com/language/ref/DavisDistribution.html)

```py
sympy.stats.Erlang(name, k, l)
```

创建一个具有 Erlang 分布的连续随机变量。

参数:

**k** : 正整数

**l** : 实数, \(\lambda > 0\), 比率

返回:

RandomSymbol

解释

Erlang 分布的密度由

\[f(x) := \frac{\lambda^k x^{k-1} e^{-\lambda x}}{(k-1)!}\]

其中 \(x \in [0,\infty]\).

例子

```py
>>> from sympy.stats import Erlang, density, cdf, E, variance
>>> from sympy import Symbol, simplify, pprint 
```

```py
>>> k = Symbol("k", integer=True, positive=True)
>>> l = Symbol("l", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Erlang("x", k, l) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 k  k - 1  -l*z
l *z     *e
---------------
 Gamma(k) 
```

```py
>>> C = cdf(X)(z)
>>> pprint(C, use_unicode=False)
/lowergamma(k, l*z)
|------------------  for z > 0
<     Gamma(k)
|
\        0           otherwise 
```

```py
>>> E(X)
k/l 
```

```py
>>> simplify(variance(X))
k/l**2 
```

参考

[R940]

[`en.wikipedia.org/wiki/Erlang_distribution`](https://en.wikipedia.org/wiki/Erlang_distribution)

[R941]

[`mathworld.wolfram.com/ErlangDistribution.html`](https://mathworld.wolfram.com/ErlangDistribution.html)

```py
sympy.stats.ExGaussian(name, mean, std, rate)
```

创建一个连续随机变量，其服从指数修正高斯分布。

参数:

**name** : 字符串，给出此分布的名称

**mean** : 实数，高斯分布组分的均值

**std** : 正实数,

> 数学:
> 
> \(\sigma² > 0\)，高斯分布组分的方差

**rate** : 正实数,

> 数学:
> 
> \(\lambda > 0\)，指数分布组分的速率

返回:

RandomSymbol

说明

指数修正高斯分布的密度函数为

\[f(x) := \frac{\lambda}{2}e^{\frac{\lambda}{2}(2\mu+\lambda\sigma²-2x)} \text{erfc}(\frac{\mu + \lambda\sigma² - x}{\sqrt{2}\sigma})\]

对于 \(x > 0\)。注意期望值为 \(1/\lambda\)。

示例

```py
>>> from sympy.stats import ExGaussian, density, cdf, E
>>> from sympy.stats import variance, skewness
>>> from sympy import Symbol, pprint, simplify 
```

```py
>>> mean = Symbol("mu")
>>> std = Symbol("sigma", positive=True)
>>> rate = Symbol("lamda", positive=True)
>>> z = Symbol("z")
>>> X = ExGaussian("x", mean, std, rate) 
```

```py
>>> pprint(density(X)(z), use_unicode=False)
 /           2             \
 lamda*\lamda*sigma  + 2*mu - 2*z/
 ---------------------------------     /  ___ /           2         \\
 2                     |\/ 2 *\lamda*sigma  + mu - z/|
lamda*e                                 *erfc|-----------------------------|
 \           2*sigma           /
----------------------------------------------------------------------------
 2 
```

```py
>>> cdf(X)(z)
-(erf(sqrt(2)*(-lamda**2*sigma**2 + lamda*(-mu + z))/(2*lamda*sigma))/2 + 1/2)*exp(lamda**2*sigma**2/2 - lamda*(-mu + z)) + erf(sqrt(2)*(-mu + z)/(2*sigma))/2 + 1/2 
```

```py
>>> E(X)
(lamda*mu + 1)/lamda 
```

```py
>>> simplify(variance(X))
sigma**2 + lamda**(-2) 
```

```py
>>> simplify(skewness(X))
2/(lamda**2*sigma**2 + 1)**(3/2) 
```

参考文献

[R942]

[`en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution`](https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution)

```py
sympy.stats.Exponential(name, rate)
```

创建一个连续随机变量，其服从指数分布。

参数:

**rate** : 正实数，\(\lambda > 0\)，速率（或逆比例/逆均值）

返回:

RandomSymbol

说明

指数分布的密度函数为

\[f(x) := \lambda \exp(-\lambda x)\]

对于 \(x > 0\)。注意期望值为 \(1/\lambda\)。

示例

```py
>>> from sympy.stats import Exponential, density, cdf, E
>>> from sympy.stats import variance, std, skewness, quantile
>>> from sympy import Symbol 
```

```py
>>> l = Symbol("lambda", positive=True)
>>> z = Symbol("z")
>>> p = Symbol("p")
>>> X = Exponential("x", l) 
```

```py
>>> density(X)(z)
lambda*exp(-lambda*z) 
```

```py
>>> cdf(X)(z)
Piecewise((1 - exp(-lambda*z), z >= 0), (0, True)) 
```

```py
>>> quantile(X)(p)
-log(1 - p)/lambda 
```

```py
>>> E(X)
1/lambda 
```

```py
>>> variance(X)
lambda**(-2) 
```

```py
>>> skewness(X)
2 
```

```py
>>> X = Exponential('x', 10) 
```

```py
>>> density(X)(z)
10*exp(-10*z) 
```

```py
>>> E(X)
1/10 
```

```py
>>> std(X)
1/10 
```

参考文献

[R943]

[`en.wikipedia.org/wiki/Exponential_distribution`](https://en.wikipedia.org/wiki/Exponential_distribution)

[R944]

[`mathworld.wolfram.com/ExponentialDistribution.html`](https://mathworld.wolfram.com/ExponentialDistribution.html)

```py
sympy.stats.FDistribution(name, d1, d2)
```

创建一个连续随机变量，其服从 F 分布。

参数:

**d1** : \(d_1 > 0\)，其中 \(d_1\) 是自由度 (\(n_1 - 1\))

**d2** : \(d_2 > 0\)，其中 \(d_2\) 是自由度 (\(n_2 - 1\))

返回:

RandomSymbol

说明

F 分布的密度函数为

\[f(x) := \frac{\sqrt{\frac{(d_1 x)^{d_1} d_2^{d_2}} {(d_1 x + d_2)^{d_1 + d_2}}}} {x \mathrm{B} \left(\frac{d_1}{2}, \frac{d_2}{2}\right)}\]

对于 \(x > 0\)。

示例

```py
>>> from sympy.stats import FDistribution, density
>>> from sympy import Symbol, pprint 
```

```py
>>> d1 = Symbol("d1", positive=True)
>>> d2 = Symbol("d2", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = FDistribution("x", d1, d2) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 d2
 --    ______________________________
 2    /       d1            -d1 - d2
d2  *\/  (d1*z)  *(d1*z + d2)
--------------------------------------
 /d1  d2\
 z*B|--, --|
 \2   2 / 
```

参考文献

[R945]

[`en.wikipedia.org/wiki/F-distribution`](https://en.wikipedia.org/wiki/F-distribution)

[R946]

[`mathworld.wolfram.com/F-Distribution.html`](https://mathworld.wolfram.com/F-Distribution.html)

```py
sympy.stats.FisherZ(name, d1, d2)
```

创建一个连续随机变量，其服从 Fisher's Z 分布。

参数:

**d1** : \(d_1 > 0\)

> 自由度。

**d2** : \(d_2 > 0\)

> 自由度。

返回:

RandomSymbol

说明

Fisher's Z 分布的密度函数为

\[f(x) := \frac{2d_1^{d_1/2} d_2^{d_2/2}} {\mathrm{B}(d_1/2, d_2/2)} \frac{e^{d_1z}}{\left(d_1e^{2z}+d_2\right)^{\left(d_1+d_2\right)/2}}\]

示例

```py
>>> from sympy.stats import FisherZ, density
>>> from sympy import Symbol, pprint 
```

```py
>>> d1 = Symbol("d1", positive=True)
>>> d2 = Symbol("d2", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = FisherZ("x", d1, d2) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 d1   d2
 d1   d2               - -- - --
 --   --                 2    2
 2    2  /    2*z     \           d1*z
2*d1  *d2  *\d1*e    + d2/         *e
-----------------------------------------
 /d1  d2\
 B|--, --|
 \2   2 / 
```

参考文献

[R947]

[`zh.wikipedia.org/wiki/Fisher%E7%9A%84z%E5%88%86%E5%B8%83`](https://zh.wikipedia.org/wiki/Fisher%E7%9A%84z%E5%88%86%E5%B8%83)

[R948]

[`mathworld.wolfram.com/Fishersz-Distribution.html`](https://mathworld.wolfram.com/Fishersz-Distribution.html)

```py
sympy.stats.Frechet(name, a, s=1, m=0)
```

利用 Frechet 分布创建一个连续随机变量。

参数：

**a** : 实数，\(a \in \left(0, \infty\right)\)，一个形状

**s** : 实数，\(s \in \left(0, \infty\right)\)，一个尺度

**m** : 实数，\(m \in \left(-\infty, \infty\right)\)，最小值

返回：

随机符号

解释

Frechet 分布的密度为

\[f(x) := \frac{\alpha}{s} \left(\frac{x-m}{s}\right)^{-1-\alpha} e^{-(\frac{x-m}{s})^{-\alpha}}\]

对于 \(x \geq m\)。

例子

```py
>>> from sympy.stats import Frechet, density, cdf
>>> from sympy import Symbol 
```

```py
>>> a = Symbol("a", positive=True)
>>> s = Symbol("s", positive=True)
>>> m = Symbol("m", real=True)
>>> z = Symbol("z") 
```

```py
>>> X = Frechet("x", a, s, m) 
```

```py
>>> density(X)(z)
a*((-m + z)/s)**(-a - 1)*exp(-1/((-m + z)/s)**a)/s 
```

```py
>>> cdf(X)(z)
Piecewise((exp(-1/((-m + z)/s)**a), m <= z), (0, True)) 
```

参考文献

[R949]

[`zh.wikipedia.org/wiki/Fr%C3%A9chet%E5%88%86%E5%B8%83`](https://zh.wikipedia.org/wiki/Fr%C3%A9chet%E5%88%86%E5%B8%83)

```py
sympy.stats.Gamma(name, k, theta)
```

利用 Gamma 分布创建一个连续随机变量。

参数：

**k** : 实数，\(k > 0\)，一个形状

**theta** : 实数，\(\theta > 0\)，一个尺度

返回：

随机符号

解释

Gamma 分布的密度为

\[f(x) := \frac{1}{\Gamma(k) \theta^k} x^{k - 1} e^{-\frac{x}{\theta}}\]

对于 \(x \in [0,1]\)。

例子

```py
>>> from sympy.stats import Gamma, density, cdf, E, variance
>>> from sympy import Symbol, pprint, simplify 
```

```py
>>> k = Symbol("k", positive=True)
>>> theta = Symbol("theta", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Gamma("x", k, theta) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 -z
 -----
 -k  k - 1  theta
theta  *z     *e
---------------------
 Gamma(k) 
```

```py
>>> C = cdf(X, meijerg=True)(z)
>>> pprint(C, use_unicode=False)
/            /     z  \
|k*lowergamma|k, -----|
|            \   theta/
<----------------------  for z >= 0
|     Gamma(k + 1)
|
\          0             otherwise 
```

```py
>>> E(X)
k*theta 
```

```py
>>> V = simplify(variance(X))
>>> pprint(V, use_unicode=False)
 2
k*theta 
```

参考文献

[R950]

[`zh.wikipedia.org/wiki/Gamma%E5%88%86%E5%B8%83`](https://zh.wikipedia.org/wiki/Gamma%E5%88%86%E5%B8%83)

[R951]

[`mathworld.wolfram.com/GammaDistribution.html`](https://mathworld.wolfram.com/GammaDistribution.html)

```py
sympy.stats.GammaInverse(name, a, b)
```

利用逆 Gamma 分布创建一个连续随机变量。

参数：

**a** : 实数，\(a > 0\)，一个形状

**b** : 实数，\(b > 0\)，一个尺度

返回：

随机符号

解释

逆 Gamma 分布的密度为

\[f(x) := \frac{\beta^\alpha}{\Gamma(\alpha)} x^{-\alpha - 1} \exp\left(\frac{-\beta}{x}\right)\]

对于 \(x > 0\)。

例子

```py
>>> from sympy.stats import GammaInverse, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> a = Symbol("a", positive=True)
>>> b = Symbol("b", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = GammaInverse("x", a, b) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 -b
 ---
 a  -a - 1   z
b *z      *e
---------------
 Gamma(a) 
```

```py
>>> cdf(X)(z)
Piecewise((uppergamma(a, b/z)/gamma(a), z > 0), (0, True)) 
```

参考文献

[R952]

[`zh.wikipedia.org/wiki/%E5%80%92%E4%B8%B2%E5%88%86%E5%B8%83`](https://zh.wikipedia.org/wiki/%E5%80%92%E4%B8%B2%E5%88%86%E5%B8%83)

```py
sympy.stats.Gompertz(name, b, eta)
```

利用 Gompertz 分布创建一个连续随机变量。

参数：

**b** : 实数，\(b > 0\)，一个尺度

**eta** : 实数，\(\eta > 0\)，一个形状

返回：

随机符号

解释

Gompertz 分布的密度为

\[f(x) := b \eta e^{b x} e^{\eta} \exp \left(-\eta e^{bx} \right)\]

对于 \(x \in 0, \infty)\)。

例子

```py
>>> from sympy.stats import Gompertz, density
>>> from sympy import Symbol 
```

```py
>>> b = Symbol("b", positive=True)
>>> eta = Symbol("eta", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Gompertz("x", b, eta) 
```

```py
>>> density(X)(z)
b*eta*exp(eta)*exp(b*z)*exp(-eta*exp(b*z)) 
```

参考文献

[[R953]

[`zh.wikipedia.org/wiki/Gompertz%E5%88%86%E5%B8%83`](https://zh.wikipedia.org/wiki/Gompertz%E5%88%86%E5%B8%83)

```py
sympy.stats.Gumbel(name, beta, mu, minimum=False)
```

利用 Gumbel 分布创建一个连续随机变量。

参数：

**mu** : 实数，\(\mu\)，一个位置

**beta** : 实数，\(\beta > 0\)，一个尺度

**minimum** : 布尔值，默认为 `False`，设置为 `True` 以启用最小分布

返回：

随机符号

解释

Gumbel 分布的密度为

对于最大值

\[f(x) := \dfrac{1}{\beta} \exp \left( -\dfrac{x-\mu}{\beta} - \exp \left( -\dfrac{x - \mu}{\beta} \right) \right)\]

对于 \(x \in [ - \infty, \infty ]\)。

最小值

\[f(x) := \frac{e^{- e^{\frac{- \mu + x}{\beta}} + \frac{- \mu + x}{\beta}}}{\beta}\]

对于\(x \in [ - \infty, \infty ]\)。

示例

```py
>>> from sympy.stats import Gumbel, density, cdf
>>> from sympy import Symbol
>>> x = Symbol("x")
>>> mu = Symbol("mu")
>>> beta = Symbol("beta", positive=True)
>>> X = Gumbel("x", beta, mu)
>>> density(X)(x)
exp(-exp(-(-mu + x)/beta) - (-mu + x)/beta)/beta
>>> cdf(X)(x)
exp(-exp(-(-mu + x)/beta)) 
```

参考文献

[R954]

[`mathworld.wolfram.com/GumbelDistribution.html`](https://mathworld.wolfram.com/GumbelDistribution.html)

[R955]

[`zh.wikipedia.org/wiki/%E6%B3%BB%E5%8D%9C%E5%88%86%E5%B8%83`](https://en.wikipedia.org/wiki/Gumbel_distribution)

[R956]

[`web.archive.org/web/20200628222206/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_max.html`](https://web.archive.org/web/20200628222206/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_max.html)

[R957]

[`web.archive.org/web/20200628222212/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_min.html`](https://web.archive.org/web/20200628222212/http://www.mathwave.com/help/easyfit/html/analyses/distributions/gumbel_min.html)

```py
sympy.stats.Kumaraswamy(name, a, b)
```

使用 Kumaraswamy 分布创建连续随机变量。

参数：

**a**：实数，\(a > 0\)，一个形状

**b**：实数，\(b > 0\)，一个形状

返回：

随机符号

说明

Kumaraswamy 分布的密度由以下给出

\[f(x) := a b x^{a-1} (1-x^a)^{b-1}\]

对于\(x \in [0,1]\)。

示例

```py
>>> from sympy.stats import Kumaraswamy, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> a = Symbol("a", positive=True)
>>> b = Symbol("b", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Kumaraswamy("x", a, b) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 b - 1
 a - 1 /     a\
a*b*z     *\1 - z / 
```

```py
>>> cdf(X)(z)
Piecewise((0, z < 0), (1 - (1 - z**a)**b, z <= 1), (1, True)) 
```

参考文献

[R958]

[`zh.wikipedia.org/wiki/Kumaraswamy%E5%88%86%E5%B8%83`](https://en.wikipedia.org/wiki/Kumaraswamy_distribution)

```py
sympy.stats.Laplace(name, mu, b)
```

使用拉普拉斯分布创建连续随机变量。

参数：

**mu**：实数或列表/矩阵，位置（平均值）或

> 位置向量

**b**：实数或正定矩阵，表示一个比例

> 或协方差矩阵。

返回：

随机符号

说明

Logistic 分布的密度由以下给出

\[f(x) := \frac{1}{2 b} \exp \left(-\frac{|x-\mu|}b \right)\]

示例

```py
>>> from sympy.stats import Laplace, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> mu = Symbol("mu")
>>> b = Symbol("b", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Laplace("x", mu, b) 
```

```py
>>> density(X)(z)
exp(-Abs(mu - z)/b)/(2*b) 
```

```py
>>> cdf(X)(z)
Piecewise((exp((-mu + z)/b)/2, mu > z), (1 - exp((mu - z)/b)/2, True)) 
```

```py
>>> L = Laplace('L', [1, 2], [[1, 0], [0, 1]])
>>> pprint(density(L)(1, 2), use_unicode=False)
 5        /     ____\
e *besselk\0, \/ 35 /
---------------------
 pi 
```

参考文献

[R959]

[`en.wikipedia.org/wiki/Laplace_distribution`](https://en.wikipedia.org/wiki/Laplace_distribution)

[R960]

[`mathworld.wolfram.com/LaplaceDistribution.html`](https://mathworld.wolfram.com/LaplaceDistribution.html)

```py
sympy.stats.Levy(name, mu, c)
```

使用 Levy 分布创建连续随机变量。

Levy 分布的密度由以下给出

\[f(x) := \sqrt(\frac{c}{2 \pi}) \frac{\exp -\frac{c}{2 (x - \mu)}}{(x - \mu)^{3/2}}\]

参数：

**mu**：实数

> 位置参数。

**c**：实数，\(c > 0\)

> 一个比例参数。

返回：

随机符号

示例

```py
>>> from sympy.stats import Levy, density, cdf
>>> from sympy import Symbol 
```

```py
>>> mu = Symbol("mu", real=True)
>>> c = Symbol("c", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Levy("x", mu, c) 
```

```py
>>> density(X)(z)
sqrt(2)*sqrt(c)*exp(-c/(-2*mu + 2*z))/(2*sqrt(pi)*(-mu + z)**(3/2)) 
```

```py
>>> cdf(X)(z)
erfc(sqrt(c)*sqrt(1/(-2*mu + 2*z))) 
```

参考文献

[R961]

[`zh.wikipedia.org/wiki/L%C3%A9vy%E5%88%86%E5%B8%83`](https://en.wikipedia.org/wiki/L%C3%A9vy_distribution)

[R962]

[`mathworld.wolfram.com/LevyDistribution.html`](https://mathworld.wolfram.com/LevyDistribution.html)

```py
sympy.stats.Logistic(name, mu, s)
```

使用 Logistic 分布创建连续随机变量。

参数：

**mu**：实数，位置（平均值）

**s**：实数，\(s > 0\)，一个比例

返回：

随机符号

说明

Laplace 分布的密度由以下给出

\[f(x) := \frac{e^{-(x-\mu)/s}} {s\left(1+e^{-(x-\mu)/s}\right)²}\]

示例

```py
>>> from sympy.stats import Logistic, density, cdf
>>> from sympy import Symbol 
```

```py
>>> mu = Symbol("mu", real=True)
>>> s = Symbol("s", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Logistic("x", mu, s) 
```

```py
>>> density(X)(z)
exp((mu - z)/s)/(s*(exp((mu - z)/s) + 1)**2) 
```

```py
>>> cdf(X)(z)
1/(exp((mu - z)/s) + 1) 
```

参考文献

[R963]

[`en.wikipedia.org/wiki/Logistic_distribution`](https://en.wikipedia.org/wiki/Logistic_distribution)

[R964]

[`mathworld.wolfram.com/LogisticDistribution.html`](https://mathworld.wolfram.com/LogisticDistribution.html)

```py
sympy.stats.LogLogistic(name, alpha, beta)
```

创建一个带有对数-逻辑分布的连续随机变量。当 `beta > 1` 时，分布是单峰的。

参数：

**alpha**：实数，\(\alpha > 0\)，尺度参数和分布的中位数

**beta**：实数，\(\beta > 0\)，为形状参数

返回：

随机符号

解释

对数-逻辑分布的密度由以下给出

\[f(x) := \frac{(\frac{\beta}{\alpha})(\frac{x}{\alpha})^{\beta - 1}} {(1 + (\frac{x}{\alpha})^{\beta})²}\]

示例

```py
>>> from sympy.stats import LogLogistic, density, cdf, quantile
>>> from sympy import Symbol, pprint 
```

```py
>>> alpha = Symbol("alpha", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> p = Symbol("p")
>>> z = Symbol("z", positive=True) 
```

```py
>>> X = LogLogistic("x", alpha, beta) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 beta - 1
 /  z  \
 beta*|-----|
 \alpha/
------------------------
 2
 /       beta    \
 |/  z  \        |
alpha*||-----|     + 1|
 \\alpha/        / 
```

```py
>>> cdf(X)(z)
1/(1 + (z/alpha)**(-beta)) 
```

```py
>>> quantile(X)(p)
alpha*(p/(1 - p))**(1/beta) 
```

参考文献

[R965]

[`en.wikipedia.org/wiki/Log-logistic_distribution`](https://en.wikipedia.org/wiki/Log-logistic_distribution)

```py
sympy.stats.LogNormal(name, mean, std)
```

创建一个带有对数正态分布的连续随机变量。

参数：

**mu**：实数

> 对数尺度。

**sigma**：实数

> 一个形状。（\(\sigma² > 0\)）

返回：

随机符号

解释

对数正态分布的密度由以下给出

\[f(x) := \frac{1}{x\sqrt{2\pi\sigma²}} e^{-\frac{\left(\ln x-\mu\right)²}{2\sigma²}}\]

当 \(x \geq 0\) 时。

示例

```py
>>> from sympy.stats import LogNormal, density
>>> from sympy import Symbol, pprint 
```

```py
>>> mu = Symbol("mu", real=True)
>>> sigma = Symbol("sigma", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = LogNormal("x", mu, sigma) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 2
 -(-mu + log(z))
 -----------------
 2
 ___      2*sigma
\/ 2 *e
------------------------
 ____
 2*\/ pi *sigma*z 
```

```py
>>> X = LogNormal('x', 0, 1) # Mean 0, standard deviation 1 
```

```py
>>> density(X)(z)
sqrt(2)*exp(-log(z)**2/2)/(2*sqrt(pi)*z) 
```

参考文献

[R966]

[`en.wikipedia.org/wiki/Lognormal`](https://en.wikipedia.org/wiki/Lognormal)

[R967]

[`mathworld.wolfram.com/LogNormalDistribution.html`](https://mathworld.wolfram.com/LogNormalDistribution.html)

```py
sympy.stats.Lomax(name, alpha, lamda)
```

创建一个带有 Lomax 分布的连续随机变量。

参数：

**alpha**：实数，\(\alpha > 0\)

> 形状参数

**lamda**：实数，\(\lambda > 0\)

> 尺度参数

返回：

随机符号

解释

Lomax 分布的密度由以下给出

\[f(x) := \frac{\alpha}{\lambda}\left[1+\frac{x}{\lambda}\right]^{-(\alpha+1)}\]

示例

```py
>>> from sympy.stats import Lomax, density, cdf, E
>>> from sympy import symbols
>>> a, l = symbols('a, l', positive=True)
>>> X = Lomax('X', a, l)
>>> x = symbols('x')
>>> density(X)(x)
a*(1 + x/l)**(-a - 1)/l
>>> cdf(X)(x)
Piecewise((1 - 1/(1 + x/l)**a, x >= 0), (0, True))
>>> a = 2
>>> X = Lomax('X', a, l)
>>> E(X)
l 
```

参考文献

[R968]

[`en.wikipedia.org/wiki/Lomax_distribution`](https://en.wikipedia.org/wiki/Lomax_distribution)

```py
sympy.stats.Maxwell(name, a)
```

创建一个带有 Maxwell 分布的连续随机变量。

参数：

**a**：实数，\(a > 0\)

返回：

随机符号

解释

Maxwell 分布的密度由以下给出

\[f(x) := \sqrt{\frac{2}{\pi}} \frac{x² e^{-x²/(2a²)}}{a³}\]

当 \(x \geq 0\) 时。

示例

```py
>>> from sympy.stats import Maxwell, density, E, variance
>>> from sympy import Symbol, simplify 
```

```py
>>> a = Symbol("a", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Maxwell("x", a) 
```

```py
>>> density(X)(z)
sqrt(2)*z**2*exp(-z**2/(2*a**2))/(sqrt(pi)*a**3) 
```

```py
>>> E(X)
2*sqrt(2)*a/sqrt(pi) 
```

```py
>>> simplify(variance(X))
a**2*(-8 + 3*pi)/pi 
```

参考文献

[R969]

[`en.wikipedia.org/wiki/Maxwell_distribution`](https://en.wikipedia.org/wiki/Maxwell_distribution)

[R970]

[`mathworld.wolfram.com/MaxwellDistribution.html`](https://mathworld.wolfram.com/MaxwellDistribution.html)

```py
sympy.stats.Moyal(name, mu, sigma)
```

创建一个带有 Moyal 分布的连续随机变量。

参数：

**mu**：实数

> 位置参数

**sigma**：实数正数

> 尺度参数

返回：

随机符号

解释

Moyal 分布的密度由以下给出

\[f(x) := \frac{\exp-\frac{1}{2}\exp-\frac{x-\mu}{\sigma}-\frac{x-\mu}{2\sigma}}{\sqrt{2\pi}\sigma}\]

其中 \(x \in \mathbb{R}\)。

示例

```py
>>> from sympy.stats import Moyal, density, cdf
>>> from sympy import Symbol, simplify
>>> mu = Symbol("mu", real=True)
>>> sigma = Symbol("sigma", positive=True, real=True)
>>> z = Symbol("z")
>>> X = Moyal("x", mu, sigma)
>>> density(X)(z)
sqrt(2)*exp(-exp((mu - z)/sigma)/2 - (-mu + z)/(2*sigma))/(2*sqrt(pi)*sigma)
>>> simplify(cdf(X)(z))
1 - erf(sqrt(2)*exp((mu - z)/(2*sigma))/2) 
```

参考文献

[R971]

[`reference.wolfram.com/language/ref/MoyalDistribution.html`](https://reference.wolfram.com/language/ref/MoyalDistribution.html)

[R972]

[`www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf`](https://www.stat.rice.edu/~dobelman/textfiles/DistributionsHandbook.pdf)

```py
sympy.stats.Nakagami(name, mu, omega)
```

创建一个带有 Nakagami 分布的连续随机变量。

参数：

**mu**：实数，\(\mu \geq \frac{1}{2}\)，形状

**omega**：实数，\(\omega > 0\)，扩散

返回：

RandomSymbol

解释

Nakagami 分布的密度由以下公式给出

\[f(x) := \frac{2\mu^\mu}{\Gamma(\mu)\omega^\mu} x^{2\mu-1} \exp\left(-\frac{\mu}{\omega}x² \right)\]

在\(x > 0\)的条件下。

示例

```py
>>> from sympy.stats import Nakagami, density, E, variance, cdf
>>> from sympy import Symbol, simplify, pprint 
```

```py
>>> mu = Symbol("mu", positive=True)
>>> omega = Symbol("omega", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Nakagami("x", mu, omega) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 2
 -mu*z
 -------
 mu      -mu  2*mu - 1  omega
2*mu  *omega   *z        *e
----------------------------------
 Gamma(mu) 
```

```py
>>> simplify(E(X))
sqrt(mu)*sqrt(omega)*gamma(mu + 1/2)/gamma(mu + 1) 
```

```py
>>> V = simplify(variance(X))
>>> pprint(V, use_unicode=False)
 2
 omega*Gamma (mu + 1/2)
omega - -----------------------
 Gamma(mu)*Gamma(mu + 1) 
```

```py
>>> cdf(X)(z)
Piecewise((lowergamma(mu, mu*z**2/omega)/gamma(mu), z > 0),
 (0, True)) 
```

参考

[R973]

[`en.wikipedia.org/wiki/Nakagami_distribution`](https://en.wikipedia.org/wiki/Nakagami_distribution)

```py
sympy.stats.Normal(name, mean, std)
```

创建一个带有正态分布的连续随机变量。

参数：

**mu**：实数或表示均值或均值向量的列表

**sigma**：实数或正定方阵，

> \(\sigma² > 0\)，方差

返回：

RandomSymbol

解释

正态分布的密度由以下公式给出

\[f(x) := \frac{1}{\sigma\sqrt{2\pi}} e^{ -\frac{(x-\mu)²}{2\sigma²} }\]

示例

```py
>>> from sympy.stats import Normal, density, E, std, cdf, skewness, quantile, marginal_distribution
>>> from sympy import Symbol, simplify, pprint 
```

```py
>>> mu = Symbol("mu")
>>> sigma = Symbol("sigma", positive=True)
>>> z = Symbol("z")
>>> y = Symbol("y")
>>> p = Symbol("p")
>>> X = Normal("x", mu, sigma) 
```

```py
>>> density(X)(z)
sqrt(2)*exp(-(-mu + z)**2/(2*sigma**2))/(2*sqrt(pi)*sigma) 
```

```py
>>> C = simplify(cdf(X))(z) # it needs a little more help...
>>> pprint(C, use_unicode=False)
 /  ___          \
 |\/ 2 *(-mu + z)|
erf|---------------|
 \    2*sigma    /   1
-------------------- + -
 2             2 
```

```py
>>> quantile(X)(p)
mu + sqrt(2)*sigma*erfinv(2*p - 1) 
```

```py
>>> simplify(skewness(X))
0 
```

```py
>>> X = Normal("x", 0, 1) # Mean 0, standard deviation 1
>>> density(X)(z)
sqrt(2)*exp(-z**2/2)/(2*sqrt(pi)) 
```

```py
>>> E(2*X + 1)
1 
```

```py
>>> simplify(std(2*X + 1))
2 
```

```py
>>> m = Normal('X', [1, 2], [[2, 1], [1, 2]])
>>> pprint(density(m)(y, z), use_unicode=False)
 2          2
 y    y*z   z
 - -- + --- - -- + z - 1
 ___    3     3    3
\/ 3 *e
------------------------------
 6*pi 
```

```py
>>> marginal_distribution(m, m[0])(1)
 1/(2*sqrt(pi)) 
```

参考

[R974]

[`en.wikipedia.org/wiki/Normal_distribution`](https://en.wikipedia.org/wiki/Normal_distribution)

[R975]

[`mathworld.wolfram.com/NormalDistributionFunction.html`](https://mathworld.wolfram.com/NormalDistributionFunction.html)

```py
sympy.stats.Pareto(name, xm, alpha)
```

创建一个带有 Pareto 分布的连续随机变量。

参数：

**xm**：实数，\(x_m > 0\)，尺度

**alpha**：实数，\(\alpha > 0\)，形状

返回：

RandomSymbol

解释

Pareto 分布的密度由以下公式给出

\[f(x) := \frac{\alpha\,x_m^\alpha}{x^{\alpha+1}}\]

在\(x \in [x_m,\infty]\)的条件下。

示例

```py
>>> from sympy.stats import Pareto, density
>>> from sympy import Symbol 
```

```py
>>> xm = Symbol("xm", positive=True)
>>> beta = Symbol("beta", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Pareto("x", xm, beta) 
```

```py
>>> density(X)(z)
beta*xm**beta*z**(-beta - 1) 
```

参考

[R976]

[`en.wikipedia.org/wiki/Pareto_distribution`](https://en.wikipedia.org/wiki/Pareto_distribution)

[R977]

[`mathworld.wolfram.com/ParetoDistribution.html`](https://mathworld.wolfram.com/ParetoDistribution.html)

```py
sympy.stats.PowerFunction(name, alpha, a, b)
```

创建一个带有 Power Function Distribution 的连续随机变量。

参数：

**alpha**：正数，\(0 < \alpha\)，形状参数

**a**：实数，\(-\infty < a\)，左边界

**b**：实数，\(a < b < \infty\)，右边界

返回：

RandomSymbol

解释

PowerFunction 分布的密度由以下公式给出

\[f(x) := \frac{{\alpha}(x - a)^{\alpha - 1}}{(b - a)^{\alpha}}\]

在\(x \in [a,b]\)的条件下。

示例

```py
>>> from sympy.stats import PowerFunction, density, cdf, E, variance
>>> from sympy import Symbol
>>> alpha = Symbol("alpha", positive=True)
>>> a = Symbol("a", real=True)
>>> b = Symbol("b", real=True)
>>> z = Symbol("z") 
```

```py
>>> X = PowerFunction("X", 2, a, b) 
```

```py
>>> density(X)(z)
(-2*a + 2*z)/(-a + b)**2 
```

```py
>>> cdf(X)(z)
Piecewise((a**2/(a**2 - 2*a*b + b**2) - 2*a*z/(a**2 - 2*a*b + b**2) +
z**2/(a**2 - 2*a*b + b**2), a <= z), (0, True)) 
```

```py
>>> alpha = 2
>>> a = 0
>>> b = 1
>>> Y = PowerFunction("Y", alpha, a, b) 
```

```py
>>> E(Y)
2/3 
```

```py
>>> variance(Y)
1/18 
```

参考

[R978]

[`web.archive.org/web/20200204081320/http://www.mathwave.com/help/easyfit/html/analyses/distributions/power_func.html`](https://web.archive.org/web/20200204081320/http://www.mathwave.com/help/easyfit/html/analyses/distributions/power_func.html)

```py
sympy.stats.QuadraticU(name, a, b)
```

创建一个带有 U-二次分布的连续随机变量。

参数：

**a**：实数

**b**：实数，\(a < b\)

返回：

RandomSymbol

说明

U-二次分布的密度由下式给出：

\[f(x) := \alpha (x-\beta)²\]

当 \(x \in [a,b]\) 时。

示例

```py
>>> from sympy.stats import QuadraticU, density
>>> from sympy import Symbol, pprint 
```

```py
>>> a = Symbol("a", real=True)
>>> b = Symbol("b", real=True)
>>> z = Symbol("z") 
```

```py
>>> X = QuadraticU("x", a, b) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
/                2
|   /  a   b    \
|12*|- - - - + z|
|   \  2   2    /
<-----------------  for And(b >= z, a <= z)
|            3
|    (-a + b)
|
\        0                 otherwise 
```

参考文献

[R979]

[`en.wikipedia.org/wiki/U-quadratic_distribution`](https://en.wikipedia.org/wiki/U-quadratic_distribution)

```py
sympy.stats.RaisedCosine(name, mu, s)
```

使用提升余弦分布创建连续随机变量。

参数：

**mu**：实数

**s**：实数，\(s > 0\)

返回：

随机符号

说明

提升余弦分布的密度由下式给出：

\[f(x) := \frac{1}{2s}\left(1+\cos\left(\frac{x-\mu}{s}\pi\right)\right)\]

当 \(x \in [\mu-s,\mu+s]\) 时。

示例

```py
>>> from sympy.stats import RaisedCosine, density
>>> from sympy import Symbol, pprint 
```

```py
>>> mu = Symbol("mu", real=True)
>>> s = Symbol("s", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = RaisedCosine("x", mu, s) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
/   /pi*(-mu + z)\
|cos|------------| + 1
|   \     s      /
<---------------------  for And(z >= mu - s, z <= mu + s)
|         2*s
|
\          0                        otherwise 
```

参考文献

[R980]

[`en.wikipedia.org/wiki/Raised_cosine_distribution`](https://en.wikipedia.org/wiki/Raised_cosine_distribution)

```py
sympy.stats.Rayleigh(name, sigma)
```

使用雷利分布创建连续随机变量。

参数：

**sigma**：实数，\(\sigma > 0\)

返回：

随机符号

说明

雷利分布的密度由下式给出：

\[f(x) := \frac{x}{\sigma²} e^{-x²/2\sigma²}\]

当 \(x > 0\) 时。

示例

```py
>>> from sympy.stats import Rayleigh, density, E, variance
>>> from sympy import Symbol 
```

```py
>>> sigma = Symbol("sigma", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Rayleigh("x", sigma) 
```

```py
>>> density(X)(z)
z*exp(-z**2/(2*sigma**2))/sigma**2 
```

```py
>>> E(X)
sqrt(2)*sqrt(pi)*sigma/2 
```

```py
>>> variance(X)
-pi*sigma**2/2 + 2*sigma**2 
```

参考

[R981]

[`en.wikipedia.org/wiki/Rayleigh_distribution`](https://en.wikipedia.org/wiki/Rayleigh_distribution)

[R982]

[`mathworld.wolfram.com/RayleighDistribution.html`](https://mathworld.wolfram.com/RayleighDistribution.html)

```py
sympy.stats.Reciprocal(name, a, b)
```

使用倒数分布创建连续随机变量。

参数：

**a**：实数，\(0 < a\)

**b**：实数，\(a < b\)

返回：

随机符号

示例

```py
>>> from sympy.stats import Reciprocal, density, cdf
>>> from sympy import symbols
>>> a, b, x = symbols('a, b, x', positive=True)
>>> R = Reciprocal('R', a, b) 
```

```py
>>> density(R)(x)
1/(x*(-log(a) + log(b)))
>>> cdf(R)(x)
Piecewise((log(a)/(log(a) - log(b)) - log(x)/(log(a) - log(b)), a <= x), (0, True)) 
```

参考

[R983]

[`en.wikipedia.org/wiki/Reciprocal_distribution`](https://en.wikipedia.org/wiki/Reciprocal_distribution)

```py
sympy.stats.StudentT(name, nu)
```

使用学生 t 分布创建连续随机变量。

参数：

**nu**：实数，\(\nu > 0\)，自由度

返回：

随机符号

说明

学生 t 分布的密度由下式给出：

\[f(x) := \frac{\Gamma \left(\frac{\nu+1}{2} \right)} {\sqrt{\nu\pi}\Gamma \left(\frac{\nu}{2} \right)} \left(1+\frac{x²}{\nu} \right)^{-\frac{\nu+1}{2}}\]

示例

```py
>>> from sympy.stats import StudentT, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> nu = Symbol("nu", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = StudentT("x", nu) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 nu   1
 - -- - -
 2    2
 /     2\
 |    z |
 |1 + --|
 \    nu/
-----------------
 ____  /     nu\
\/ nu *B|1/2, --|
 \     2 / 
```

```py
>>> cdf(X)(z)
1/2 + z*gamma(nu/2 + 1/2)*hyper((1/2, nu/2 + 1/2), (3/2,),
 -z**2/nu)/(sqrt(pi)*sqrt(nu)*gamma(nu/2)) 
```

参考

[R984]

[`en.wikipedia.org/wiki/Student_t-distribution`](https://en.wikipedia.org/wiki/Student_t-distribution)

[R985]

[`mathworld.wolfram.com/Studentst-Distribution.html`](https://mathworld.wolfram.com/Studentst-Distribution.html)

```py
sympy.stats.ShiftedGompertz(name, b, eta)
```

使用移位戈姆佩尔茨分布创建连续随机变量。

参数：

**b**：实数，\(b > 0\)，一个尺度

**eta**：实数，\(\eta > 0\)，一个形状

返回：

随机符号

说明

移位戈姆佩尔茨分布的密度由下式给出：

\[f(x) := b e^{-b x} e^{-\eta \exp(-b x)} \left[1 + \eta(1 - e^(-bx)) \right]\]

当 \(x \in 0, \infty)\) 时。

示例

```py
>>> from sympy.stats import ShiftedGompertz, density
>>> from sympy import Symbol 
```

```py
>>> b = Symbol("b", positive=True)
>>> eta = Symbol("eta", positive=True)
>>> x = Symbol("x") 
```

```py
>>> X = ShiftedGompertz("x", b, eta) 
```

```py
>>> density(X)(x)
b*(eta*(1 - exp(-b*x)) + 1)*exp(-b*x)*exp(-eta*exp(-b*x)) 
```

参考文献

[[R986]

[`en.wikipedia.org/wiki/Shifted_Gompertz_distribution`](https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution)

```py
sympy.stats.Trapezoidal(name, a, b, c, d)
```

使用梯形分布创建连续随机变量。

参数：

**a**：实数，\(a < d\)

**b**：实数，\(a \le b < c\)

**c**：实数，\(b < c \le d\)

**d** : 实数

返回：

RandomSymbol

解释

梯形分布的密度由以下给出

\[\begin{split}f(x) := \begin{cases} 0 & \mathrm{对于\ } x < a, \\ \frac{2(x-a)}{(b-a)(d+c-a-b)} & \mathrm{对于\ } a \le x < b, \\ \frac{2}{d+c-a-b} & \mathrm{对于\ } b \le x < c, \\ \frac{2(d-x)}{(d-c)(d+c-a-b)} & \mathrm{对于\ } c \le x < d, \\ 0 & \mathrm{对于\ } d < x. \end{cases}\end{split}\]

示例

```py
>>> from sympy.stats import Trapezoidal, density
>>> from sympy import Symbol, pprint 
```

```py
>>> a = Symbol("a")
>>> b = Symbol("b")
>>> c = Symbol("c")
>>> d = Symbol("d")
>>> z = Symbol("z") 
```

```py
>>> X = Trapezoidal("x", a,b,c,d) 
```

```py
>>> pprint(density(X)(z), use_unicode=False)
/        -2*a + 2*z
|-------------------------  for And(a <= z, b > z)
|(-a + b)*(-a - b + c + d)
|
|           2
|     --------------        for And(b <= z, c > z)
<     -a - b + c + d
|
|        2*d - 2*z
|-------------------------  for And(d >= z, c <= z)
|(-c + d)*(-a - b + c + d)
|
\            0                     otherwise 
```

参考

[R987]

[`zh.wikipedia.org/wiki/梯形分布`](https://zh.wikipedia.org/wiki/梯形分布)

```py
sympy.stats.Triangular(name, a, b, c)
```

创建一个具有三角分布的连续随机变量。

参数：

**a** : 实数，\(a \in \left(-\infty, \infty\right)\)，左边界

**b** : 实数，\(a < b\)

**c** : 实数，\(a \leq c \leq b\)

返回：

RandomSymbol

解释

三角分布的密度由以下给出

\[\begin{split}f(x) := \begin{cases} 0 & \mathrm{对于\ } x < a, \\ \frac{2(x-a)}{(b-a)(c-a)} & \mathrm{对于\ } a \le x < c, \\ \frac{2}{b-a} & \mathrm{对于\ } x = c, \\ \frac{2(b-x)}{(b-a)(b-c)} & \mathrm{对于\ } c < x \le b, \\ 0 & \mathrm{对于\ } b < x. \end{cases}\end{split}\]

示例

```py
>>> from sympy.stats import Triangular, density
>>> from sympy import Symbol, pprint 
```

```py
>>> a = Symbol("a")
>>> b = Symbol("b")
>>> c = Symbol("c")
>>> z = Symbol("z") 
```

```py
>>> X = Triangular("x", a,b,c) 
```

```py
>>> pprint(density(X)(z), use_unicode=False)
/    -2*a + 2*z
|-----------------  for And(a <= z, c > z)
|(-a + b)*(-a + c)
|
|       2
|     ------              for c = z
<     -a + b
|
|   2*b - 2*z
|----------------   for And(b >= z, c < z)
|(-a + b)*(b - c)
|
\        0                otherwise 
```

参考

[R988]

[`zh.wikipedia.org/wiki/三角分布`](https://zh.wikipedia.org/wiki/三角分布)

[R989]

[`mathworld.wolfram.com/TriangularDistribution.html`](https://mathworld.wolfram.com/TriangularDistribution.html)

```py
sympy.stats.Uniform(name, left, right)
```

创建一个具有均匀分布的连续随机变量。

参数：

**a** : 实数，\(-\infty < a\)，左边界

**b** : 实数，\(a < b < \infty\)，右边界

返回：

RandomSymbol

解释

一致分布的密度由以下给出

\[\begin{split}f(x) := \begin{cases} \frac{1}{b - a} & \text{对于 } x \in [a,b] \\ 0 & \text{其他情况} \end{cases}\end{split}\]

其中 \(x \in [a,b]\).

示例

```py
>>> from sympy.stats import Uniform, density, cdf, E, variance
>>> from sympy import Symbol, simplify 
```

```py
>>> a = Symbol("a", negative=True)
>>> b = Symbol("b", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Uniform("x", a, b) 
```

```py
>>> density(X)(z)
Piecewise((1/(-a + b), (b >= z) & (a <= z)), (0, True)) 
```

```py
>>> cdf(X)(z)
Piecewise((0, a > z), ((-a + z)/(-a + b), b >= z), (1, True)) 
```

```py
>>> E(X)
a/2 + b/2 
```

```py
>>> simplify(variance(X))
a**2/12 - a*b/6 + b**2/12 
```

参考

[R990]

[`zh.wikipedia.org/wiki/连续均匀分布`](https://zh.wikipedia.org/wiki/连续均匀分布)

[R991]

[`mathworld.wolfram.com/UniformDistribution.html`](https://mathworld.wolfram.com/UniformDistribution.html)

```py
sympy.stats.UniformSum(name, n)
```

创建一个具有 Irwin-Hall 分布的连续随机变量。

参数：

**n** : 正整数，\(n > 0\)

返回：

RandomSymbol

解释

概率分布函数依赖于一个整数参数 \(n\)。

Irwin-Hall 分布的密度由以下给出

\[f(x) := \frac{1}{(n-1)!}\sum_{k=0}^{\left\lfloor x\right\rfloor}(-1)^k \binom{n}{k}(x-k)^{n-1}\]

示例

```py
>>> from sympy.stats import UniformSum, density, cdf
>>> from sympy import Symbol, pprint 
```

```py
>>> n = Symbol("n", integer=True)
>>> z = Symbol("z") 
```

```py
>>> X = UniformSum("x", n) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
floor(z)
 ___
 \  `
 \         k         n - 1 /n\
 )    (-1) *(-k + z)     *| |
 /                         \k/
 /__,
 k = 0
--------------------------------
 (n - 1)! 
```

```py
>>> cdf(X)(z)
Piecewise((0, z < 0), (Sum((-1)**_k*(-_k + z)**n*binomial(n, _k),
 (_k, 0, floor(z)))/factorial(n), n >= z), (1, True)) 
```

用特定的‘x’和‘n’值计算 cdf 如下： >>> cdf(UniformSum(“x”, 5), evaluate=False)(2).doit() 9/40

参数 evaluate=False 阻止了在传递参数 2 之前尝试对一般 n 的求和的评估。

参考

[R992]

[`zh.wikipedia.org/wiki/均匀和分布`](https://zh.wikipedia.org/wiki/均匀和分布)

[R993]

[`mathworld.wolfram.com/UniformSumDistribution.html`](https://mathworld.wolfram.com/UniformSumDistribution.html)

```py
sympy.stats.VonMises(name, mu, k)
```

创建一个具有 von Mises 分布的连续随机变量。

参数：

**mu**：实数

> 位置度量。

**k**：实数

> 集中度量。

返回：

RandomSymbol

解释

von Mises 分布的密度函数为

\[f(x) := \frac{e^{\kappa\cos(x-\mu)}}{2\pi I_0(\kappa)}\]

其中 \(x \in [0,2\pi]\)。

示例

```py
>>> from sympy.stats import VonMises, density
>>> from sympy import Symbol, pprint 
```

```py
>>> mu = Symbol("mu")
>>> k = Symbol("k", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = VonMises("x", mu, k) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 k*cos(mu - z)
 e
------------------
2*pi*besseli(0, k) 
```

参考文献

[R994]

[`en.wikipedia.org/wiki/Von_Mises_distribution`](https://en.wikipedia.org/wiki/Von_Mises_distribution)

[R995]

[`mathworld.wolfram.com/vonMisesDistribution.html`](https://mathworld.wolfram.com/vonMisesDistribution.html)

```py
sympy.stats.Wald(name, mean, shape)
```

创建一个具有逆高斯分布的连续随机变量。逆高斯分布也称为 Wald 分布。

参数：

**mu：**

> 正数，表示平均数。

**lambda：**

> 正数，表示形状参数。

返回：

RandomSymbol

解释

逆高斯分布的密度函数为

\[f(x) := \sqrt{\frac{\lambda}{2\pi x³}} e^{-\frac{\lambda(x-\mu)²}{2x\mu²}}\]

示例

```py
>>> from sympy.stats import GaussianInverse, density, E, std, skewness
>>> from sympy import Symbol, pprint 
```

```py
>>> mu = Symbol("mu", positive=True)
>>> lamda = Symbol("lambda", positive=True)
>>> z = Symbol("z", positive=True)
>>> X = GaussianInverse("x", mu, lamda) 
```

```py
>>> D = density(X)(z)
>>> pprint(D, use_unicode=False)
 2
 -lambda*(-mu + z)
 -------------------
 2
 ___   ________        2*mu *z
\/ 2 *\/ lambda *e
-------------------------------------
 ____  3/2
 2*\/ pi *z 
```

```py
>>> E(X)
mu 
```

```py
>>> std(X).expand()
mu**(3/2)/sqrt(lambda) 
```

```py
>>> skewness(X).expand()
3*sqrt(mu)/sqrt(lambda) 
```

参考文献

[R996]

[`en.wikipedia.org/wiki/Inverse_Gaussian_distribution`](https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution)

[R997]

[`mathworld.wolfram.com/InverseGaussianDistribution.html`](https://mathworld.wolfram.com/InverseGaussianDistribution.html)

```py
sympy.stats.Weibull(name, alpha, beta)
```

创建一个具有 Weibull 分布的连续随机变量。

参数：

**lambda**：实数，\(\lambda > 0\)，表示尺度

**k**：实数，\(k > 0\)，表示形状

返回：

RandomSymbol

解释

Weibull 分布的密度函数为

\[\begin{split}f(x) := \begin{cases} \frac{k}{\lambda}\left(\frac{x}{\lambda}\right)^{k-1} e^{-(x/\lambda)^{k}} & x\geq0\\ 0 & x<0 \end{cases}\end{split}\]

示例

```py
>>> from sympy.stats import Weibull, density, E, variance
>>> from sympy import Symbol, simplify 
```

```py
>>> l = Symbol("lambda", positive=True)
>>> k = Symbol("k", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = Weibull("x", l, k) 
```

```py
>>> density(X)(z)
k*(z/lambda)**(k - 1)*exp(-(z/lambda)**k)/lambda 
```

```py
>>> simplify(E(X))
lambda*gamma(1 + 1/k) 
```

```py
>>> simplify(variance(X))
lambda**2*(-gamma(1 + 1/k)**2 + gamma(1 + 2/k)) 
```

参考文献

[R998]

[`en.wikipedia.org/wiki/Weibull_distribution`](https://en.wikipedia.org/wiki/Weibull_distribution)

[R999]

[`mathworld.wolfram.com/WeibullDistribution.html`](https://mathworld.wolfram.com/WeibullDistribution.html)

```py
sympy.stats.WignerSemicircle(name, R)
```

创建一个具有 Wigner 半圆分布的连续随机变量。

参数：

**R**：实数，\(R > 0\)，表示半径

返回：

一个 RandomSymbol。

解释

Wigner 半圆分布的密度函数为

\[f(x) := \frac2{\pi R²}\,\sqrt{R²-x²}\]

其中 \(x \in [-R,R]\)。

示例

```py
>>> from sympy.stats import WignerSemicircle, density, E
>>> from sympy import Symbol 
```

```py
>>> R = Symbol("R", positive=True)
>>> z = Symbol("z") 
```

```py
>>> X = WignerSemicircle("x", R) 
```

```py
>>> density(X)(z)
2*sqrt(R**2 - z**2)/(pi*R**2) 
```

```py
>>> E(X)
0 
```

参考文献

[R1000]

[`en.wikipedia.org/wiki/Wigner_semicircle_distribution`](https://en.wikipedia.org/wiki/Wigner_semicircle_distribution)

[R1001]

[`mathworld.wolfram.com/WignersSemicircleLaw.html`](https://mathworld.wolfram.com/WignersSemicircleLaw.html)

```py
sympy.stats.ContinuousRV(symbol, density, set=Interval(-oo, oo), **kwargs)
```

创建一个给定以下内容的连续随机变量：

参数：

**symbol**：符号

> 表示随机变量的名称。

**density**：包含符号的表达式

> 表示概率密度函数。

**set**：集合/区间

> 默认情况下，表示 pdf 有效的区域是实线。

**check**：布尔值

> 如果为 True，则检查给定密度是否在给定集合上积分为 1。如果为 False，则不执行此检查。默认为 False。

返回：

随机符号

许多常见的连续随机变量类型已经实现。

这个函数只在非常罕见的情况下需要。

示例

```py
>>> from sympy import Symbol, sqrt, exp, pi
>>> from sympy.stats import ContinuousRV, P, E 
```

```py
>>> x = Symbol("x") 
```

```py
>>> pdf = sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) # Normal distribution
>>> X = ContinuousRV(x, pdf) 
```

```py
>>> E(X)
0
>>> P(X>0)
1/2 
```

### 联合类型

```py
sympy.stats.JointRV(symbol, pdf, _set=None)
```

创建一个联合随机变量，其中每个组件都是连续的，给定以下内容：

参数：

**symbol**：符号

> 表示随机变量的名称。

**pdf**：关于给定符号的索引符号的概率密度函数

> 作为第一个参数

返回：

随机符号

注意

到目前为止，每个组件对于`JointRV`的集合等于所有整数的集合，这不能改变。

示例

```py
>>> from sympy import exp, pi, Indexed, S
>>> from sympy.stats import density, JointRV
>>> x1, x2 = (Indexed('x', i) for i in (1, 2))
>>> pdf = exp(-x1**2/2 + x1 - x2**2/2 - S(1)/2)/(2*pi)
>>> N1 = JointRV('x', pdf) #Multivariate Normal distribution
>>> density(N1)(1, 2)
exp(-2)/(2*pi) 
```

```py
sympy.stats.marginal_distribution(rv, *indices)
```

联合随机变量的边际分布函数。

参数：

**rv**：具有联合概率分布的随机变量。

**indices**：组件索引或索引的随机符号

> 用于计算联合分布

返回：

\(sym\)中的 Lambda 表达式。

示例

```py
>>> from sympy.stats import MultivariateNormal, marginal_distribution
>>> m = MultivariateNormal('X', [1, 2], [[2, 1], [1, 2]])
>>> marginal_distribution(m, m[0])(1)
1/(2*sqrt(pi)) 
```

```py
sympy.stats.MultivariateNormal(name, mu, sigma)
```

创建具有多元正态分布的连续随机变量。

可以在[1]找到多元正态分布的密度。

参数：

**mu**：表示均值或均值向量的列表

**sigma**：正半定方阵

> 表示协方差矩阵。如果 \(\sigma\) 是不可逆的，则目前仅支持抽样

返回：

随机符号

示例

```py
>>> from sympy.stats import MultivariateNormal, density, marginal_distribution
>>> from sympy import symbols, MatrixSymbol
>>> X = MultivariateNormal('X', [3, 4], [[2, 1], [1, 2]])
>>> y, z = symbols('y z')
>>> density(X)(y, z)
sqrt(3)*exp(-y**2/3 + y*z/3 + 2*y/3 - z**2/3 + 5*z/3 - 13/3)/(6*pi)
>>> density(X)(1, 2)
sqrt(3)*exp(-4/3)/(6*pi)
>>> marginal_distribution(X, X[1])(y)
exp(-(y - 4)**2/4)/(2*sqrt(pi))
>>> marginal_distribution(X, X[0])(y)
exp(-(y - 3)**2/4)/(2*sqrt(pi)) 
```

下面的示例显示，也可以使用符号参数来定义 MultivariateNormal 类。

```py
>>> n = symbols('n', integer=True, positive=True)
>>> Sg = MatrixSymbol('Sg', n, n)
>>> mu = MatrixSymbol('mu', n, 1)
>>> obs = MatrixSymbol('obs', n, 1)
>>> X = MultivariateNormal('X', mu, Sg) 
```

可以使用矩阵参数计算多元正态分布的密度，如下所示。

```py
>>> density(X)(obs)
(exp(((1/2)*mu.T - (1/2)*obs.T)*Sg**(-1)*(-mu + obs))/sqrt((2*pi)**n*Determinant(Sg)))[0, 0] 
```

参考文献

[R1002]

[`en.wikipedia.org/wiki/Multivariate_normal_distribution`](https://en.wikipedia.org/wiki/Multivariate_normal_distribution)

```py
sympy.stats.MultivariateLaplace(name, mu, sigma)
```

创建具有多元拉普拉斯分布的连续随机变量。

可以在[1]找到多元拉普拉斯分布的密度。

参数：

**mu**：表示均值或均值向量的列表

**sigma**：正定方阵

> 表示协方差矩阵

返回：

随机符号

示例

```py
>>> from sympy.stats import MultivariateLaplace, density
>>> from sympy import symbols
>>> y, z = symbols('y z')
>>> X = MultivariateLaplace('X', [2, 4], [[3, 1], [1, 3]])
>>> density(X)(y, z)
sqrt(2)*exp(y/4 + 5*z/4)*besselk(0, sqrt(15*y*(3*y/8 - z/8)/2 + 15*z*(-y/8 + 3*z/8)/2))/(4*pi)
>>> density(X)(1, 2)
sqrt(2)*exp(11/4)*besselk(0, sqrt(165)/4)/(4*pi) 
```

参考文献

[R1003]

[`en.wikipedia.org/wiki/Multivariate_Laplace_distribution`](https://en.wikipedia.org/wiki/Multivariate_Laplace_distribution)

```py
sympy.stats.GeneralizedMultivariateLogGamma(syms, delta, v, lamda, mu)
```

使用广义多元对数伽玛分布创建联合随机变量。

可以在[1]找到联合概率密度函数。

参数：

**syms**：用于识别每个组件的符号列表/元组/集合

**delta**：介于 \([0, 1]\) 范围内的常数

**v**：正实数

**lamda**：正实数列表

**mu**：正实数列表

返回：

随机符号

示例

```py
>>> from sympy.stats import density
>>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGamma
>>> from sympy import symbols, S
>>> v = 1
>>> l, mu = [1, 1, 1], [1, 1, 1]
>>> d = S.Half
>>> y = symbols('y_1:4', positive=True)
>>> Gd = GeneralizedMultivariateLogGamma('G', d, v, l, mu)
>>> density(Gd)(y[0], y[1], y[2])
Sum(exp((n + 1)*(y_1 + y_2 + y_3) - exp(y_1) - exp(y_2) -
exp(y_3))/(2**n*gamma(n + 1)**3), (n, 0, oo))/2 
```

注意

如果 GeneralizedMultivariateLogGamma 太长无法输入，请使用，

```py
>>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGamma as GMVLG
>>> Gd = GMVLG('G', d, v, l, mu) 
```

如果要传递矩阵 omega 而不是常数 delta，则使用`GeneralizedMultivariateLogGammaOmega`。

参考文献

[R1004]

[`en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution`](https://en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution)

[R1005]

[`www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis`](https://www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis)

```py
sympy.stats.GeneralizedMultivariateLogGammaOmega(syms, omega, v, lamda, mu)
```

扩展 GeneralizedMultivariateLogGamma。

参数：

**syms**：符号的列表/元组/集合

> 用于识别每个组件

**omega**：方阵

> 方阵的每个元素必须是相关系数的平方根的绝对值

**v**：正实数

**lamda**：正实数列表

**mu**：正实数列表

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import density
>>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGammaOmega
>>> from sympy import Matrix, symbols, S
>>> omega = Matrix([[1, S.Half, S.Half], [S.Half, 1, S.Half], [S.Half, S.Half, 1]])
>>> v = 1
>>> l, mu = [1, 1, 1], [1, 1, 1]
>>> G = GeneralizedMultivariateLogGammaOmega('G', omega, v, l, mu)
>>> y = symbols('y_1:4', positive=True)
>>> density(G)(y[0], y[1], y[2])
sqrt(2)*Sum((1 - sqrt(2)/2)**n*exp((n + 1)*(y_1 + y_2 + y_3) - exp(y_1) -
exp(y_2) - exp(y_3))/gamma(n + 1)**3, (n, 0, oo))/2 
```

注意

如果 GeneralizedMultivariateLogGammaOmega 过长无法输入，请使用以下符号，

```py
>>> from sympy.stats.joint_rv_types import GeneralizedMultivariateLogGammaOmega as GMVLGO
>>> G = GMVLGO('G', omega, v, l, mu) 
```

参考文献

[R1006]

[`en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution`](https://en.wikipedia.org/wiki/Generalized_multivariate_log-gamma_distribution)

[R1007]

[`www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis`](https://www.researchgate.net/publication/234137346_On_a_multivariate_log-gamma_distribution_and_the_use_of_the_distribution_in_the_Bayesian_analysis)

```py
sympy.stats.Multinomial(syms, n, *p)
```

创建具有多项分布的离散随机变量。

该分布的密度可以在[1]处找到。

参数：

**n**：正整数

> 表示试验次数

**p**：事件概率列表

> 必须在[0, 1]范围内。

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import density, Multinomial, marginal_distribution
>>> from sympy import symbols
>>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
>>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
>>> M = Multinomial('M', 3, p1, p2, p3)
>>> density(M)(x1, x2, x3)
Piecewise((6*p1**x1*p2**x2*p3**x3/(factorial(x1)*factorial(x2)*factorial(x3)),
Eq(x1 + x2 + x3, 3)), (0, True))
>>> marginal_distribution(M, M[0])(x1).subs(x1, 1)
3*p1*p2**2 + 6*p1*p2*p3 + 3*p1*p3**2 
```

参考文献

[R1008]

[`en.wikipedia.org/wiki/Multinomial_distribution`](https://en.wikipedia.org/wiki/Multinomial_distribution)

[R1009]

[`mathworld.wolfram.com/MultinomialDistribution.html`](https://mathworld.wolfram.com/MultinomialDistribution.html)

```py
sympy.stats.MultivariateBeta(syms, *alpha)
```

创建具有 Dirichlet/多变量贝塔分布的连续随机变量。

Dirichlet 分布的密度可以在[1]处找到。

参数：

**alpha**：正实数列表

> 表示浓度数字。

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import density, MultivariateBeta, marginal_distribution
>>> from sympy import Symbol
>>> a1 = Symbol('a1', positive=True)
>>> a2 = Symbol('a2', positive=True)
>>> B = MultivariateBeta('B', [a1, a2])
>>> C = MultivariateBeta('C', a1, a2)
>>> x = Symbol('x')
>>> y = Symbol('y')
>>> density(B)(x, y)
x**(a1 - 1)*y**(a2 - 1)*gamma(a1 + a2)/(gamma(a1)*gamma(a2))
>>> marginal_distribution(C, C[0])(x)
x**(a1 - 1)*gamma(a1 + a2)/(a2*gamma(a1)*gamma(a2)) 
```

参考文献

[R1010]

[`en.wikipedia.org/wiki/Dirichlet_distribution`](https://en.wikipedia.org/wiki/Dirichlet_distribution)

[R1011]

[`mathworld.wolfram.com/DirichletDistribution.html`](https://mathworld.wolfram.com/DirichletDistribution.html)

```py
sympy.stats.MultivariateEwens(syms, n, theta)
```

创建具有多变量 Ewens 分布的离散随机变量。

该分布的密度可以在[1]处找到。

参数：

**n**：正整数

> 样本的大小或者考虑的整数的分区

**theta**：正实数

> 表示突变率

返回：

RandomSymbol

示例

```py
>>> from sympy.stats import density, marginal_distribution, MultivariateEwens
>>> from sympy import Symbol
>>> a1 = Symbol('a1', positive=True)
>>> a2 = Symbol('a2', positive=True)
>>> ed = MultivariateEwens('E', 2, 1)
>>> density(ed)(a1, a2)
Piecewise((1/(2**a2*factorial(a1)*factorial(a2)), Eq(a1 + 2*a2, 2)), (0, True))
>>> marginal_distribution(ed, ed[0])(a1)
Piecewise((1/factorial(a1), Eq(a1, 2)), (0, True)) 
```

参考文献

[R1012]

[`en.wikipedia.org/wiki/Ewens%27s_sampling_formula`](https://en.wikipedia.org/wiki/Ewens%27s_sampling_formula)

[R1013]

[`www.jstor.org/stable/24780825`](https://www.jstor.org/stable/24780825)

```py
sympy.stats.MultivariateT(syms, mu, sigma, v)
```

创建具有多元 T 分布的联合随机变量。

参数：

**syms**：符号/字符串

> 用于识别随机变量。

**mu**：列表/矩阵

> 表示位置向量

**sigma**：分布的形状矩阵

返回：

随机符号

示例

```py
>>> from sympy.stats import density, MultivariateT
>>> from sympy import Symbol 
```

```py
>>> x = Symbol("x")
>>> X = MultivariateT("x", [1, 1], [[1, 0], [0, 1]], 2) 
```

```py
>>> density(X)(1, 2)
2/(9*pi) 
```

```py
sympy.stats.NegativeMultinomial(syms, k0, *p)
```

创建具有负多项分布的离散随机变量。

所述分布的密度可以在[1]处找到。

参数：

**k0**：正整数

> 表示实验停止前的失败次数

**p**：事件概率列表

> 必须在\([0, 1]\)范围内

返回：

随机符号

示例

```py
>>> from sympy.stats import density, NegativeMultinomial, marginal_distribution
>>> from sympy import symbols
>>> x1, x2, x3 = symbols('x1, x2, x3', nonnegative=True, integer=True)
>>> p1, p2, p3 = symbols('p1, p2, p3', positive=True)
>>> N = NegativeMultinomial('M', 3, p1, p2, p3)
>>> N_c = NegativeMultinomial('M', 3, 0.1, 0.1, 0.1)
>>> density(N)(x1, x2, x3)
p1**x1*p2**x2*p3**x3*(-p1 - p2 - p3 + 1)**3*gamma(x1 + x2 +
x3 + 3)/(2*factorial(x1)*factorial(x2)*factorial(x3))
>>> marginal_distribution(N_c, N_c[0])(1).evalf().round(2)
0.25 
```

参考文献

[R1014]

[`en.wikipedia.org/wiki/Negative_multinomial_distribution`](https://en.wikipedia.org/wiki/Negative_multinomial_distribution)

[R1015]

[`mathworld.wolfram.com/NegativeBinomialDistribution.html`](https://mathworld.wolfram.com/NegativeBinomialDistribution.html)

```py
sympy.stats.NormalGamma(sym, mu, lamda, alpha, beta)
```

创建具有多元正态伽玛分布的双变量联合随机变量。

参数：

**sym**：符号/字符串

> 用于识别随机变量。

**mu**：实数

> 正态分布的均值

**lamda**：正整数

> 联合分布的参数

**alpha**：正整数

> 联合分布的参数

**beta**：正整数

> 联合分布的参数

返回：

随机符号

示例

```py
>>> from sympy.stats import density, NormalGamma
>>> from sympy import symbols 
```

```py
>>> X = NormalGamma('x', 0, 1, 2, 3)
>>> y, z = symbols('y z') 
```

```py
>>> density(X)(y, z)
9*sqrt(2)*z**(3/2)*exp(-3*z)*exp(-y**2*z/2)/(2*sqrt(pi)) 
```

参考文献

[R1016]

[`en.wikipedia.org/wiki/Normal-gamma_distribution`](https://en.wikipedia.org/wiki/Normal-gamma_distribution)

### 随机过程

```py
class sympy.stats.DiscreteMarkovChain(sym, state_space=None, trans_probs=None)
```

表示有限离散时间同质马尔可夫链。

这种马尔可夫链可以通过其（有序的）状态空间和其一步转移概率矩阵唯一地描述。

参数：

**sym:**

> 马尔可夫链的命名

**state_space:**

> 可选，默认为 Range(n)

**trans_probs:**

> 可选，默认为 MatrixSymbol(‘_T’, n, n)

示例

```py
>>> from sympy.stats import DiscreteMarkovChain, TransitionMatrixOf, P, E
>>> from sympy import Matrix, MatrixSymbol, Eq, symbols
>>> T = Matrix([[0.5, 0.2, 0.3],[0.2, 0.5, 0.3],[0.2, 0.3, 0.5]])
>>> Y = DiscreteMarkovChain("Y", [0, 1, 2], T)
>>> YS = DiscreteMarkovChain("Y") 
```

```py
>>> Y.state_space
{0, 1, 2}
>>> Y.transition_probabilities
Matrix([
[0.5, 0.2, 0.3],
[0.2, 0.5, 0.3],
[0.2, 0.3, 0.5]])
>>> TS = MatrixSymbol('T', 3, 3)
>>> P(Eq(YS[3], 2), Eq(YS[1], 1) & TransitionMatrixOf(YS, TS))
T[0, 2]*T[1, 0] + T[1, 1]*T[1, 2] + T[1, 2]*T[2, 2]
>>> P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2)
0.36 
```

概率将基于索引而不是状态名称计算。例如，对于具有字符串状态名称的晴天-多云-雨天模型：

```py
>>> from sympy.core.symbol import Str
>>> Y = DiscreteMarkovChain("Y", [Str('Sunny'), Str('Cloudy'), Str('Rainy')], T)
>>> P(Eq(Y[3], 2), Eq(Y[1], 1)).round(2)
0.36 
```

这与`[0, 1, 2]`状态空间给出的答案相同。当前不支持概率和期望语句中的状态名称。以下是使用`Str`的解决方法：

```py
>>> P(Eq(Str('Rainy'), Y[3]), Eq(Y[1], Str('Cloudy'))).round(2)
0.36 
```

也可以使用符号状态名称：

```py
>>> sunny, cloudy, rainy = symbols('Sunny, Cloudy, Rainy')
>>> Y = DiscreteMarkovChain("Y", [sunny, cloudy, rainy], T)
>>> P(Eq(Y[3], rainy), Eq(Y[1], cloudy)).round(2)
0.36 
```

期望将按以下方式计算：

```py
>>> E(Y[3], Eq(Y[1], cloudy))
0.38*Cloudy + 0.36*Rainy + 0.26*Sunny 
```

可以计算具有多个 RandomIndexedSymbols 的表达式的概率，前提是给定条件中只有 1 个 RandomIndexedSymbol。在转移矩阵中，最好使用有理数而不是浮点数作为概率，以避免错误。

```py
>>> from sympy import Gt, Le, Rational
>>> T = Matrix([[Rational(5, 10), Rational(3, 10), Rational(2, 10)], [Rational(2, 10), Rational(7, 10), Rational(1, 10)], [Rational(3, 10), Rational(3, 10), Rational(4, 10)]])
>>> Y = DiscreteMarkovChain("Y", [0, 1, 2], T)
>>> P(Eq(Y[3], Y[1]), Eq(Y[0], 0)).round(3)
0.409
>>> P(Gt(Y[3], Y[1]), Eq(Y[0], 0)).round(2)
0.36
>>> P(Le(Y[15], Y[10]), Eq(Y[8], 2)).round(7)
0.6963328 
```

也支持符号概率查询

```py
>>> a, b, c, d = symbols('a b c d')
>>> T = Matrix([[Rational(1, 10), Rational(4, 10), Rational(5, 10)], [Rational(3, 10), Rational(4, 10), Rational(3, 10)], [Rational(7, 10), Rational(2, 10), Rational(1, 10)]])
>>> Y = DiscreteMarkovChain("Y", [0, 1, 2], T)
>>> query = P(Eq(Y[a], b), Eq(Y[c], d))
>>> query.subs({a:10, b:2, c:5, d:1}).round(4)
0.3096
>>> P(Eq(Y[10], 2), Eq(Y[5], 1)).evalf().round(4)
0.3096
>>> query_gt = P(Gt(Y[a], b), Eq(Y[c], d))
>>> query_gt.subs({a:21, b:0, c:5, d:0}).evalf().round(5)
0.64705
>>> P(Gt(Y[21], 0), Eq(Y[5], 0)).round(5)
0.64705 
```

支持任意大小的状态有限。

```py
>>> n = symbols('n', nonnegative=True, integer=True)
>>> T = MatrixSymbol('T', n, n)
>>> Y = DiscreteMarkovChain("Y", trans_probs=T)
>>> Y.state_space
Range(0, n, 1)
>>> query = P(Eq(Y[a], b), Eq(Y[c], d))
>>> query.subs({a:10, b:2, c:5, d:1})
(T**5)[1, 2] 
```

参考文献

[R1017]

[`en.wikipedia.org/wiki/Markov_chain#Discrete-time_Markov_chain`](https://en.wikipedia.org/wiki/Markov_chain#Discrete-time_Markov_chain)

[R1018]

[`web.archive.org/web/20201230182007/https://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/Chapter11.pdf`](https://web.archive.org/web/20201230182007/https://www.dartmouth.edu/~chance/teaching_aids/books_articles/probability_book/Chapter11.pdf)

```py
absorbing_probabilities()
```

计算吸收概率，即矩阵的 ij-th 条目表示从状态 i 开始到状态 j 吸收马尔可夫链的概率。

```py
canonical_form() → Tuple[List[Basic], ImmutableDenseMatrix]
```

重新排列一步转移矩阵，使得经常性状态先出现，瞬态状态最后出现。其他表示包括先插入瞬态状态，后插入经常性状态。

返回：

states, P_new

> `states`是描述矩阵中新状态顺序的列表，因此`states`中的第 i 个元素是 A 矩阵的第 i 行的状态。`P_new`是规范形式中的新转移矩阵。

示例

```py
>>> from sympy.stats import DiscreteMarkovChain
>>> from sympy import Matrix, S 
```

您可以将您的链转换为规范形式：

```py
>>> T = Matrix([[S(1)/2, S(1)/2, 0,      0,      0],
...             [S(2)/5, S(1)/5, S(2)/5, 0,      0],
...             [0,      0,      1,      0,      0],
...             [0,      0,      S(1)/2, S(1)/2, 0],
...             [S(1)/2, 0,      0,      0, S(1)/2]])
>>> X = DiscreteMarkovChain('X', list(range(1, 6)), trans_probs=T)
>>> states, new_matrix = X.canonical_form()
>>> states
[3, 1, 2, 4, 5] 
```

```py
>>> new_matrix
Matrix([
[  1,   0,   0,   0,   0],
[  0, 1/2, 1/2,   0,   0],
[2/5, 2/5, 1/5,   0,   0],
[1/2,   0,   0, 1/2,   0],
[  0, 1/2,   0,   0, 1/2]]) 
```

新的状态是[3, 1, 2, 4, 5]，你可以用这些状态创建一个新的链，其规范形式将保持不变（因为它已经处于规范形式）。

```py
>>> X = DiscreteMarkovChain('X', states, new_matrix)
>>> states, new_matrix = X.canonical_form()
>>> states
[3, 1, 2, 4, 5] 
```

```py
>>> new_matrix
Matrix([
[  1,   0,   0,   0,   0],
[  0, 1/2, 1/2,   0,   0],
[2/5, 2/5, 1/5,   0,   0],
[1/2,   0,   0, 1/2,   0],
[  0, 1/2,   0,   0, 1/2]]) 
```

这不仅限于吸收链：

```py
>>> T = Matrix([[0, 5,  5, 0,  0],
...             [0, 0,  0, 10, 0],
...             [5, 0,  5, 0,  0],
...             [0, 10, 0, 0,  0],
...             [0, 3,  0, 3,  4]])/10
>>> X = DiscreteMarkovChain('X', trans_probs=T)
>>> states, new_matrix = X.canonical_form()
>>> states
[1, 3, 0, 2, 4] 
```

```py
>>> new_matrix
Matrix([
[   0,    1,   0,   0,   0],
[   1,    0,   0,   0,   0],
[ 1/2,    0,   0, 1/2,   0],
[   0,    0, 1/2, 1/2,   0],
[3/10, 3/10,   0,   0, 2/5]]) 
```

参见

`sympy.stats.DiscreteMarkovChain.communication_classes`，`sympy.stats.DiscreteMarkovChain.decompose`

参考文献

[R1019]

[`onlinelibrary.wiley.com/doi/pdf/10.1002/9780470316887.app1`](https://onlinelibrary.wiley.com/doi/pdf/10.1002/9780470316887.app1)

[R1020]

[`www.columbia.edu/~ww2040/6711F12/lect1023big.pdf`](http://www.columbia.edu/~ww2040/6711F12/lect1023big.pdf)

```py
communication_classes() → List[Tuple[List[Basic], Boolean, Integer]]
```

返回马尔可夫链状态分割的通信类列表。

通信类被定义为一组状态，使得该集合中的每个状态都可以从该集合中的任何其他状态到达。由于其属性，这在数学上形成一个类。通信类也称为循环类。

返回：

类

> `classes`是一个元组列表。每个元组表示一个通信类及其属性。元组中的第一个元素是该类中的状态列表，第二个元素是该类是否是经常性的，第三个元素是通信类的周期。

示例

```py
>>> from sympy.stats import DiscreteMarkovChain
>>> from sympy import Matrix
>>> T = Matrix([[0, 1, 0],
...             [1, 0, 0],
...             [1, 0, 0]])
>>> X = DiscreteMarkovChain('X', [1, 2, 3], T)
>>> classes = X.communication_classes()
>>> for states, is_recurrent, period in classes:
...     states, is_recurrent, period
([1, 2], True, 2)
([3], False, 1) 
```

从这里我们可以看到状态`1`和`2`是通信的，是经常性的，并且周期为 2。我们也可以看到状态`3`是瞬态的，周期为 1。

注意事项

使用的算法是`O(n**2)`阶的，其中`n`是马尔可夫链中的状态数。它使用 Tarjan 算法找到类本身，然后使用广度优先搜索算法找到每个类的周期性。随着矩阵变得越来越稀疏，算法的大部分组件趋近于`O(n)`。

参考文献

[R1021]

[`web.archive.org/web/20220207032113/https://www.columbia.edu/~ww2040/4701Sum07/4701-06-Notes-MCII.pdf`](https://web.archive.org/web/20220207032113/https://www.columbia.edu/~ww2040/4701Sum07/4701-06-Notes-MCII.pdf)

[R1022]

[`cecas.clemson.edu/~shierd/Shier/markov.pdf`](https://cecas.clemson.edu/~shierd/Shier/markov.pdf)

[R1023]

[`www.proquest.com/openview/4adc6a51d8371be5b0e4c7dff287fc70/1?pq-origsite=gscholar&cbl=2026366&diss=y`](https://www.proquest.com/openview/4adc6a51d8371be5b0e4c7dff287fc70/1?pq-origsite=gscholar&cbl=2026366&diss=y)

[R1024]

[`www.mathworks.com/help/econ/dtmc.classify.html`](https://www.mathworks.com/help/econ/dtmc.classify.html)

```py
decompose() → Tuple[List[Basic], ImmutableDenseMatrix, ImmutableDenseMatrix, ImmutableDenseMatrix]
```

将过渡矩阵分解为具有特殊属性的子矩阵。

过渡矩阵可以分解为 4 个子矩阵： - A - 从复发状态到复发状态的子矩阵。 - B - 从瞬态到复发状态的子矩阵。 - C - 从瞬态到瞬态状态的子矩阵。 - O - 用于复发到瞬态状态的零子矩阵。

返回：

状态，A，B，C

> `states` - 状态名称列表，第一个是复发状态，最后一个是按 A 和 C 行名顺序的瞬态状态。 `A` - 从复发状态到复发状态的子矩阵。 `B` - 从瞬态到复发状态的子矩阵。 `C` - 从瞬态到瞬态状态的子矩阵。

示例

```py
>>> from sympy.stats import DiscreteMarkovChain
>>> from sympy import Matrix, S 
```

例如，可以将此链分解为：

```py
>>> T = Matrix([[S(1)/2, S(1)/2, 0,      0,      0],
...             [S(2)/5, S(1)/5, S(2)/5, 0,      0],
...             [0,      0,      1,      0,      0],
...             [0,      0,      S(1)/2, S(1)/2, 0],
...             [S(1)/2, 0,      0,      0, S(1)/2]])
>>> X = DiscreteMarkovChain('X', trans_probs=T)
>>> states, A, B, C = X.decompose()
>>> states
[2, 0, 1, 3, 4] 
```

```py
>>> A   # recurrent to recurrent
Matrix([[1]]) 
```

```py
>>> B  # transient to recurrent
Matrix([
[  0],
[2/5],
[1/2],
[  0]]) 
```

```py
>>> C  # transient to transient
Matrix([
[1/2, 1/2,   0,   0],
[2/5, 1/5,   0,   0],
[  0,   0, 1/2,   0],
[1/2,   0,   0, 1/2]]) 
```

这意味着状态 2 是唯一的吸收状态（因为 A 是一个 1x1 的矩阵）。B 是一个 4x1 的矩阵，因为剩余的 4 个瞬态状态都合并到复发状态 2。C 是一个 4x4 的矩阵，显示了瞬态状态 0, 1, 3, 4 如何互动。

另请参阅

`sympy.stats.DiscreteMarkovChain.communication_classes`, `sympy.stats.DiscreteMarkovChain.canonical_form`

参考文献

[R1025]

[`en.wikipedia.org/wiki/Absorbing_Markov_chain`](https://en.wikipedia.org/wiki/Absorbing_Markov_chain)

[R1026]

[`people.brandeis.edu/~igusa/Math56aS08/Math56a_S08_notes015.pdf`](https://people.brandeis.edu/~igusa/Math56aS08/Math56a_S08_notes015.pdf)

```py
fixed_row_vector()
```

`stationary_distribution()`的包装器。

```py
fundamental_matrix()
```

每个基本矩阵条目可以解释为如果以状态 i 开始，则链条处于状态 j 的预期次数。

参考文献

[R1027]

[`lips.cs.princeton.edu/the-fundamental-matrix-of-a-finite-markov-chain/`](https://lips.cs.princeton.edu/the-fundamental-matrix-of-a-finite-markov-chain/)

```py
property limiting_distribution
```

固定的行向量是离散马尔可夫链的极限分布。

```py
sample()
```

返回：

样本：迭代对象

> 包含样本的迭代对象

```py
stationary_distribution(condition_set=False) → ImmutableDenseMatrix | ConditionSet | Lambda
```

静止分布是任何解 p = pP 的行向量 p，它是行随机的，p 中的每个元素必须是非负的。这意味着在矩阵形式中：\((P-I)^T p^T = 0\)，且 \((1, \dots, 1) p = 1\)，其中 `P` 是一步转移矩阵。

所有有限状态空间的时齐马尔可夫链至少有一个静止分布。此外，如果一个有限时齐马尔可夫链是不可约的，则静止分布是唯一的。

参数：

**condition_set** ：bool

> 如果链具有符号大小或转移矩阵，则返回 `Lambda`（若为 `False`）或返回 `ConditionSet`（若为 `True`）。

示例

```py
>>> from sympy.stats import DiscreteMarkovChain
>>> from sympy import Matrix, S 
```

不可约马尔可夫链

```py
>>> T = Matrix([[S(1)/2, S(1)/2, 0],
...             [S(4)/5, S(1)/5, 0],
...             [1, 0, 0]])
>>> X = DiscreteMarkovChain('X', trans_probs=T)
>>> X.stationary_distribution()
Matrix([[8/13, 5/13, 0]]) 
```

可约马尔可夫链

```py
>>> T = Matrix([[S(1)/2, S(1)/2, 0],
...             [S(4)/5, S(1)/5, 0],
...             [0, 0, 1]])
>>> X = DiscreteMarkovChain('X', trans_probs=T)
>>> X.stationary_distribution()
Matrix([[8/13 - 8*tau0/13, 5/13 - 5*tau0/13, tau0]]) 
```

```py
>>> Y = DiscreteMarkovChain('Y')
>>> Y.stationary_distribution()
Lambda((wm, _T), Eq(wm*_T, wm)) 
```

```py
>>> Y.stationary_distribution(condition_set=True)
ConditionSet(wm, Eq(wm*_T, wm)) 
```

参见

`sympy.stats.DiscreteMarkovChain.limiting_distribution`

参考文献

[R1028]

[`www.probabilitycourse.com/chapter11/11_2_6_stationary_and_limiting_distributions.php`](https://www.probabilitycourse.com/chapter11/11_2_6_stationary_and_limiting_distributions.php)

[R1029]

[`web.archive.org/web/20210508104430/https://galton.uchicago.edu/~yibi/teaching/stat317/2014/Lectures/Lecture4_6up.pdf`](https://web.archive.org/web/20210508104430/https://galton.uchicago.edu/~yibi/teaching/stat317/2014/Lectures/Lecture4_6up.pdf)

```py
property transition_probabilities
```

离散马尔可夫链的转移概率，可以是 Matrix 的实例或 MatrixSymbol。

```py
class sympy.stats.ContinuousMarkovChain(sym, state_space=None, gen_mat=None)
```

表示连续时间马尔可夫链。

参数：

**sym** ：Symbol/str

**state_space** ：集合

> 可选项，默认为 S.Reals

**gen_mat** ：Matrix/ImmutableMatrix/MatrixSymbol

> 可选项，默认为 None

示例

```py
>>> from sympy.stats import ContinuousMarkovChain, P
>>> from sympy import Matrix, S, Eq, Gt
>>> G = Matrix([[-S(1), S(1)], [S(1), -S(1)]])
>>> C = ContinuousMarkovChain('C', state_space=[0, 1], gen_mat=G)
>>> C.limiting_distribution()
Matrix([[1/2, 1/2]])
>>> C.state_space
{0, 1}
>>> C.generator_matrix
Matrix([
[-1,  1],
[ 1, -1]]) 
```

支持概率查询

```py
>>> P(Eq(C(1.96), 0), Eq(C(0.78), 1)).round(5)
0.45279
>>> P(Gt(C(1.7), 0), Eq(C(0.82), 1)).round(5)
0.58602 
```

可以计算具有多个 RandomIndexedSymbols 的表达式的概率，前提是给定条件中只有 1 个 RandomIndexedSymbol。在生成矩阵中，最好始终使用 Rational 而不是浮点数来表示概率，以避免错误。

```py
>>> from sympy import Gt, Le, Rational
>>> G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])
>>> C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)
>>> P(Eq(C(3.92), C(1.75)), Eq(C(0.46), 0)).round(5)
0.37933
>>> P(Gt(C(3.92), C(1.75)), Eq(C(0.46), 0)).round(5)
0.34211
>>> P(Le(C(1.57), C(3.14)), Eq(C(1.22), 1)).round(4)
0.7143 
```

还支持符号概率查询

```py
>>> from sympy import symbols
>>> a,b,c,d = symbols('a b c d')
>>> G = Matrix([[-S(1), Rational(1, 10), Rational(9, 10)], [Rational(2, 5), -S(1), Rational(3, 5)], [Rational(1, 2), Rational(1, 2), -S(1)]])
>>> C = ContinuousMarkovChain('C', state_space=[0, 1, 2], gen_mat=G)
>>> query = P(Eq(C(a), b), Eq(C(c), d))
>>> query.subs({a:3.65, b:2, c:1.78, d:1}).evalf().round(10)
0.4002723175
>>> P(Eq(C(3.65), 2), Eq(C(1.78), 1)).round(10)
0.4002723175
>>> query_gt = P(Gt(C(a), b), Eq(C(c), d))
>>> query_gt.subs({a:43.2, b:0, c:3.29, d:2}).evalf().round(10)
0.6832579186
>>> P(Gt(C(43.2), 0), Eq(C(3.29), 2)).round(10)
0.6832579186 
```

参考文献

[R1030]

[`en.wikipedia.org/wiki/Markov_chain#Continuous-time_Markov_chain`](https://en.wikipedia.org/wiki/Markov_chain#Continuous-time_Markov_chain)

[R1031]

[`u.math.biu.ac.il/~amirgi/CTMCnotes.pdf`](https://u.math.biu.ac.il/~amirgi/CTMCnotes.pdf)

```py
class sympy.stats.BernoulliProcess(sym, p, success=1, failure=0)
```

伯努利过程由重复独立的伯努利试验组成，这些试验具有相同的参数 \(p\)。假定概率 \(p\) 适用于每个试验，并且每次试验的结果都与其余所有试验独立。因此，伯努利过程是离散状态和离散时间随机过程。

参数：

**sym** ：Symbol/str

**success**：整数/字符串

> 被认为是成功的事件。默认值：1。

**failure: 整数/字符串**

> 被认为是失败的事件。默认值：0。

**p**：0 到 1 之间的实数

> 表示成功的概率。

示例

```py
>>> from sympy.stats import BernoulliProcess, P, E
>>> from sympy import Eq, Gt
>>> B = BernoulliProcess("B", p=0.7, success=1, failure=0)
>>> B.state_space
{0, 1}
>>> B.p.round(2)
0.70
>>> B.success
1
>>> B.failure
0
>>> X = B[1] + B[2] + B[3]
>>> P(Eq(X, 0)).round(2)
0.03
>>> P(Eq(X, 2)).round(2)
0.44
>>> P(Eq(X, 4)).round(2)
0
>>> P(Gt(X, 1)).round(2)
0.78
>>> P(Eq(B[1], 0) & Eq(B[2], 1) & Eq(B[3], 0) & Eq(B[4], 1)).round(2)
0.04
>>> B.joint_distribution(B[1], B[2])
JointDistributionHandmade(Lambda((B[1], B[2]), Piecewise((0.7, Eq(B[1], 1)),
(0.3, Eq(B[1], 0)), (0, True))*Piecewise((0.7, Eq(B[2], 1)), (0.3, Eq(B[2], 0)),
(0, True))))
>>> E(2*B[1] + B[2]).round(2)
2.10
>>> P(B[1] < 1).round(2)
0.30 
```

参考文献

[R1032]

[`en.wikipedia.org/wiki/Bernoulli_process`](https://en.wikipedia.org/wiki/Bernoulli_process)

[R1033]

[`mathcs.clarku.edu/~djoyce/ma217/bernoulli.pdf`](https://mathcs.clarku.edu/~djoyce/ma217/bernoulli.pdf)

```py
expectation(expr, condition=None, evaluate=True, **kwargs)
```

计算期望。

参数：

**expr**：随机索引符号、关系、逻辑

> 必须包含过程的随机索引符号的条件，计算期望的条件。

**condition**：关系、逻辑

> 应进行计算的给定条件。

返回：

随机索引符号的期望。

```py
probability(condition, given_condition=None, evaluate=True, **kwargs)
```

计算概率。

参数：

**condition**：关系

> 计算概率的条件。必须包含过程的随机索引符号。

**given_condition**：关系、逻辑

> 应进行计算的给定条件。

返回：

条件的概率。

```py
class sympy.stats.PoissonProcess(sym, lamda)
```

泊松过程是一个计数过程。通常用于我们计算出现在某一特定速率下似乎完全随机发生的某些事件的发生次数的场景中。

参数：

**sym**：符号/字符串

**lamda**：正数

> 进程的速率，`lambda > 0`

示例

```py
>>> from sympy.stats import PoissonProcess, P, E
>>> from sympy import symbols, Eq, Ne, Contains, Interval
>>> X = PoissonProcess("X", lamda=3)
>>> X.state_space
Naturals0
>>> X.lamda
3
>>> t1, t2 = symbols('t1 t2', positive=True)
>>> P(X(t1) < 4)
(9*t1**3/2 + 9*t1**2/2 + 3*t1 + 1)*exp(-3*t1)
>>> P(Eq(X(t1), 2) | Ne(X(t1), 4), Contains(t1, Interval.Ropen(2, 4)))
1 - 36*exp(-6)
>>> P(Eq(X(t1), 2) & Eq(X(t2), 3), Contains(t1, Interval.Lopen(0, 2))
... & Contains(t2, Interval.Lopen(2, 4)))
648*exp(-12)
>>> E(X(t1))
3*t1
>>> E(X(t1)**2 + 2*X(t2),  Contains(t1, Interval.Lopen(0, 1))
... & Contains(t2, Interval.Lopen(1, 2)))
18
>>> P(X(3) < 1, Eq(X(1), 0))
exp(-6)
>>> P(Eq(X(4), 3), Eq(X(2), 3))
exp(-6)
>>> P(X(2) <= 3, X(1) > 1)
5*exp(-3) 
```

合并两个泊松过程

```py
>>> Y = PoissonProcess("Y", lamda=4)
>>> Z = X + Y
>>> Z.lamda
7 
```

将泊松过程分割为两个独立的泊松过程

```py
>>> N, M = Z.split(l1=2, l2=5)
>>> N.lamda, M.lamda
(2, 5) 
```

参考文献

[R1034]

[`www.probabilitycourse.com/chapter11/11_0_0_intro.php`](https://www.probabilitycourse.com/chapter11/11_0_0_intro.php)

[R1035]

[`en.wikipedia.org/wiki/Poisson_point_process`](https://en.wikipedia.org/wiki/Poisson_point_process)

```py
class sympy.stats.WienerProcess(sym)
```

Wiener 过程是一个实值连续时间随机过程。在物理学中，它用于研究布朗运动，由于其与最初由苏格兰植物学家罗伯特·布朗观察到的同名物理过程的历史联系，通常也被称为布朗运动。

参数：

**sym**：符号/字符串

示例

```py
>>> from sympy.stats import WienerProcess, P, E
>>> from sympy import symbols, Contains, Interval
>>> X = WienerProcess("X")
>>> X.state_space
Reals
>>> t1, t2 = symbols('t1 t2', positive=True)
>>> P(X(t1) < 7).simplify()
erf(7*sqrt(2)/(2*sqrt(t1)))/2 + 1/2
>>> P((X(t1) > 2) | (X(t1) < 4), Contains(t1, Interval.Ropen(2, 4))).simplify()
-erf(1)/2 + erf(2)/2 + 1
>>> E(X(t1))
0
>>> E(X(t1) + 2*X(t2),  Contains(t1, Interval.Lopen(0, 1))
... & Contains(t2, Interval.Lopen(1, 2)))
0 
```

参考文献

[R1036]

[`www.probabilitycourse.com/chapter11/11_4_0_brownian_motion_wiener_process.php`](https://www.probabilitycourse.com/chapter11/11_4_0_brownian_motion_wiener_process.php)

[R1037]

[`en.wikipedia.org/wiki/Wiener_process`](https://en.wikipedia.org/wiki/Wiener_process)

```py
class sympy.stats.GammaProcess(sym, lamda, gamma)
```

伽玛过程是一个具有独立伽玛分布增量的随机过程。它是一个纯跳跃递增的列维过程。

参数：

**sym**：符号/字符串

**lamda**：正数

> 过程的跳跃大小，`lamda > 0`

**gamma**：正数

> 跳跃到达的速率，\(\gamma > 0\)

示例

```py
>>> from sympy.stats import GammaProcess, E, P, variance
>>> from sympy import symbols, Contains, Interval, Not
>>> t, d, x, l, g = symbols('t d x l g', positive=True)
>>> X = GammaProcess("X", l, g)
>>> E(X(t))
g*t/l
>>> variance(X(t)).simplify()
g*t/l**2
>>> X = GammaProcess('X', 1, 2)
>>> P(X(t) < 1).simplify()
lowergamma(2*t, 1)/gamma(2*t)
>>> P(Not((X(t) < 5) & (X(d) > 3)), Contains(t, Interval.Ropen(2, 4)) &
... Contains(d, Interval.Lopen(7, 8))).simplify()
-4*exp(-3) + 472*exp(-8)/3 + 1
>>> E(X(2) + x*E(X(5)))
10*x + 4 
```

参考文献

[R1038]

[`en.wikipedia.org/wiki/Gamma_process`](https://en.wikipedia.org/wiki/Gamma_process)

### 矩阵分布

```py
sympy.stats.MatrixGamma(symbol, alpha, beta, scale_matrix)
```

创建具有矩阵伽玛分布的随机变量。

所述分布的密度可在[1]找到。

参数：

**alpha: 正实数**

> 形状参数

**beta: 正实数**

> 规模参数

**scale_matrix: 正定实数方阵**

> 规模矩阵

返回：

随机符号

示例

```py
>>> from sympy.stats import density, MatrixGamma
>>> from sympy import MatrixSymbol, symbols
>>> a, b = symbols('a b', positive=True)
>>> M = MatrixGamma('M', a, b, [[2, 1], [1, 2]])
>>> X = MatrixSymbol('X', 2, 2)
>>> density(M)(X).doit()
exp(Trace(Matrix([
[-2/3,  1/3],
[ 1/3, -2/3]])*X)/b)*Determinant(X)**(a - 3/2)/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2))
>>> density(M)([[1, 0], [0, 1]]).doit()
exp(-4/(3*b))/(3**a*sqrt(pi)*b**(2*a)*gamma(a)*gamma(a - 1/2)) 
```

参考资料

[R1039]

[`zh.wikipedia.org/wiki/矩阵伽马分布`](https://en.wikipedia.org/wiki/Matrix_gamma_distribution)

```py
sympy.stats.Wishart(symbol, n, scale_matrix)
```

创建具有 Wishart 分布的随机变量。

所述分布的密度可在[1]找到。

参数：

**n: 正实数**

> 代表自由度

**scale_matrix: 正定实数方阵**

> 规模矩阵

返回：

随机符号

示例

```py
>>> from sympy.stats import density, Wishart
>>> from sympy import MatrixSymbol, symbols
>>> n = symbols('n', positive=True)
>>> W = Wishart('W', n, [[2, 1], [1, 2]])
>>> X = MatrixSymbol('X', 2, 2)
>>> density(W)(X).doit()
exp(Trace(Matrix([
[-1/3,  1/6],
[ 1/6, -1/3]])*X))*Determinant(X)**(n/2 - 3/2)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2))
>>> density(W)([[1, 0], [0, 1]]).doit()
exp(-2/3)/(2**n*3**(n/2)*sqrt(pi)*gamma(n/2)*gamma(n/2 - 1/2)) 
```

参考资料

[R1040]

[`zh.wikipedia.org/wiki/Wishart 分布`](https://en.wikipedia.org/wiki/Wishart_distribution)

```py
sympy.stats.MatrixNormal(symbol, location_matrix, scale_matrix_1, scale_matrix_2)
```

创建具有矩阵正态分布的随机变量。

所述分布的密度可在[1]找到。

参数：

**location_matrix: 实数 ``n x p`` 矩阵**

> 代表自由度

**scale_matrix_1: 正定矩阵**

> 形状 `n x n` 的规模矩阵

**scale_matrix_2: 正定矩阵**

> 形状 `p x p` 的规模矩阵

返回：

随机符号

示例

```py
>>> from sympy import MatrixSymbol
>>> from sympy.stats import density, MatrixNormal
>>> M = MatrixNormal('M', [[1, 2]], [1], [[1, 0], [0, 1]])
>>> X = MatrixSymbol('X', 1, 2)
>>> density(M)(X).doit()
exp(-Trace((Matrix([
[-1],
[-2]]) + X.T)*(Matrix([[-1, -2]]) + X))/2)/(2*pi)
>>> density(M)([[3, 4]]).doit()
exp(-4)/(2*pi) 
```

参考资料

[R1041]

[`zh.wikipedia.org/wiki/矩阵正态分布`](https://en.wikipedia.org/wiki/Matrix_normal_distribution)

### 复合分布

```py
class sympy.stats.compound_rv.CompoundDistribution(dist)
```

复合分布类。

参数：

**dist** : 分布

> 分布必须包含随机参数

示例

```py
>>> from sympy.stats.compound_rv import CompoundDistribution
>>> from sympy.stats.crv_types import NormalDistribution
>>> from sympy.stats import Normal
>>> from sympy.abc import x
>>> X = Normal('X', 2, 4)
>>> N = NormalDistribution(X, 4)
>>> C = CompoundDistribution(N)
>>> C.set
Interval(-oo, oo)
>>> C.pdf(x, evaluate=True).simplify()
exp(-x**2/64 + x/16 - 1/16)/(8*sqrt(pi)) 
```

参考资料

[R1042]

[`zh.wikipedia.org/wiki/复合概率分布`](https://en.wikipedia.org/wiki/Compound_probability_distribution)

## 接口

```py
sympy.stats.P(condition, given_condition=None, numsamples=None, evaluate=True, **kwargs)
```

一个条件为真的概率，可选地给出第二个条件。

参数：

**condition** : 包含随机符号的关系组合

> 要计算概率的条件

**given_condition** : 包含随机符号的关系组合

> 一个条件表达式。P(X > 1, X > 0) 是给定 X > 0 的期望 X > 1

**numsamples** : 整数

> 启用抽样并使用这么多样本近似概率

**evaluate** : 布尔值（默认为真）

> 对于连续系统返回未评估的积分

示例

```py
>>> from sympy.stats import P, Die
>>> from sympy import Eq
>>> X, Y = Die('X', 6), Die('Y', 6)
>>> P(X > 3)
1/2
>>> P(Eq(X, 5), X > 2) # Probability that X == 5 given that X > 2
1/4
>>> P(X > Y)
5/12 
```

```py
class sympy.stats.Probability(prob, condition=None, **kwargs)
```

概率的符号表达式。

示例

```py
>>> from sympy.stats import Probability, Normal
>>> from sympy import Integral
>>> X = Normal("X", 0, 1)
>>> prob = Probability(X > 1)
>>> prob
Probability(X > 1) 
```

积分表示：

```py
>>> prob.rewrite(Integral)
Integral(sqrt(2)*exp(-_z**2/2)/(2*sqrt(pi)), (_z, 1, oo)) 
```

积分的评估：

```py
>>> prob.evaluate_integral()
sqrt(2)*(-sqrt(2)*sqrt(pi)*erf(sqrt(2)/2) + sqrt(2)*sqrt(pi))/(4*sqrt(pi)) 
```

```py
sympy.stats.E(expr, condition=None, numsamples=None, evaluate=True, **kwargs)
```

返回随机表达式的期望值。

参数：

**expr** : 包含随机符号的表达式

> 您希望计算期望值的表达式

**given** : 包含随机符号的表达式

> 一个条件表达式。E(X, X>0) 是给定 X > 0 的期望

**numsamples** : 整数

> 启用抽样并使用这么多样本近似期望

**evalf** : 布尔值（默认为真）

> 如果抽样返回一个数字而不是一个复杂的表达式

**evaluate** : 布尔值（默认为真）

> 对于连续系统返回未评估的积分

示例

```py
>>> from sympy.stats import E, Die
>>> X = Die('X', 6)
>>> E(X)
7/2
>>> E(2*X + 1)
8 
```

```py
>>> E(X, X > 3) # Expectation of X given that it is above 3
5 
```

```py
class sympy.stats.Expectation(expr, condition=None, **kwargs)
```

期望的符号表达式。

示例

```py
>>> from sympy.stats import Expectation, Normal, Probability, Poisson
>>> from sympy import symbols, Integral, Sum
>>> mu = symbols("mu")
>>> sigma = symbols("sigma", positive=True)
>>> X = Normal("X", mu, sigma)
>>> Expectation(X)
Expectation(X)
>>> Expectation(X).evaluate_integral().simplify()
mu 
```

要获得期望的积分表达式：

```py
>>> Expectation(X).rewrite(Integral)
Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)) 
```

更抽象术语中相同的积分表达式：

```py
>>> Expectation(X).rewrite(Probability)
Integral(x*Probability(Eq(X, x)), (x, -oo, oo)) 
```

对于离散随机变量，要获得期望的求和表达式：

```py
>>> lamda = symbols('lamda', positive=True)
>>> Z = Poisson('Z', lamda)
>>> Expectation(Z).rewrite(Sum)
Sum(Z*lamda**Z*exp(-lamda)/factorial(Z), (Z, 0, oo)) 
```

该类意识到期望的某些属性：

```py
>>> from sympy.abc import a
>>> Expectation(a*X)
Expectation(a*X)
>>> Y = Normal("Y", 1, 2)
>>> Expectation(X + Y)
Expectation(X + Y) 
```

要扩展`Expectation`为其表达式，请使用`expand()`：

```py
>>> Expectation(X + Y).expand()
Expectation(X) + Expectation(Y)
>>> Expectation(a*X + Y).expand()
a*Expectation(X) + Expectation(Y)
>>> Expectation(a*X + Y)
Expectation(a*X + Y)
>>> Expectation((X + Y)*(X - Y)).expand()
Expectation(X**2) - Expectation(Y**2) 
```

要评估`Expectation`，请使用`doit()`：

```py
>>> Expectation(X + Y).doit()
mu + 1
>>> Expectation(X + Expectation(Y + Expectation(2*X))).doit()
3*mu + 1 
```

要防止评估嵌套的`Expectation`，请使用`doit(deep=False)`

```py
>>> Expectation(X + Expectation(Y)).doit(deep=False)
mu + Expectation(Expectation(Y))
>>> Expectation(X + Expectation(Y + Expectation(2*X))).doit(deep=False)
mu + Expectation(Expectation(Expectation(2*X) + Y)) 
```

```py
sympy.stats.density(expr, condition=None, evaluate=True, numsamples=None, **kwargs)
```

随机表达式的概率密度，可选给定第二个条件。

参数：

**expr**：包含随机符号的表达式

> 您想要计算其密度值的表达式

**condition**：包含随机符号的关系

> 一个条件表达式。density(X > 1, X > 0) 是给定 X > 0 的情况下 X > 1 的密度

**numsamples**：整数

> 启用抽样并使用这么多样本来近似密度

说明

对于不同类型的概率空间，该密度将采取不同的形式。离散变量产生字典，连续变量产生 Lambda 函数。

示例

```py
>>> from sympy.stats import density, Die, Normal
>>> from sympy import Symbol 
```

```py
>>> x = Symbol('x')
>>> D = Die('D', 6)
>>> X = Normal(x, 0, 1) 
```

```py
>>> density(D).dict
{1: 1/6, 2: 1/6, 3: 1/6, 4: 1/6, 5: 1/6, 6: 1/6}
>>> density(2*D).dict
{2: 1/6, 4: 1/6, 6: 1/6, 8: 1/6, 10: 1/6, 12: 1/6}
>>> density(X)(x)
sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)) 
```

```py
sympy.stats.entropy(expr, condition=None, **kwargs)
```

计算概率分布的熵。

参数：

**expression**：要计算熵的随机表达式

**condition**：可选项，用于指定随机表达式的条件

**b：对数的底数，可选**

> 默认情况下，它被视为欧拉数

返回：

**result**：表达式的熵，一个常数

示例

```py
>>> from sympy.stats import Normal, Die, entropy
>>> X = Normal('X', 0, 1)
>>> entropy(X)
log(2)/2 + 1/2 + log(pi)/2 
```

```py
>>> D = Die('D', 4)
>>> entropy(D)
log(4) 
```

参考

[R1043]

[`en.wikipedia.org/wiki/Entropy_%28information_theory%29`](https://en.wikipedia.org/wiki/Entropy_%28information_theory%29)

[R1044]

[`www.crmarsh.com/static/pdf/Charles_Marsh_Continuous_Entropy.pdf`](https://www.crmarsh.com/static/pdf/Charles_Marsh_Continuous_Entropy.pdf)

[R1045]

[`kconrad.math.uconn.edu/blurbs/analysis/entropypost.pdf`](https://kconrad.math.uconn.edu/blurbs/analysis/entropypost.pdf)

```py
sympy.stats.given(expr, condition=None, **kwargs)
```

条件随机表达式。

说明

从随机表达式和表达式条件创建一个新的概率空间，基于该条件返回同一表达式在该条件概率空间中的结果。

示例

```py
>>> from sympy.stats import given, density, Die
>>> X = Die('X', 6)
>>> Y = given(X, X > 3)
>>> density(Y).dict
{4: 1/3, 5: 1/3, 6: 1/3} 
```

遵循惯例，如果条件是一个随机符号，则认为该符号是固定的。

```py
>>> from sympy.stats import Normal
>>> from sympy import pprint
>>> from sympy.abc import z 
```

```py
>>> X = Normal('X', 0, 1)
>>> Y = Normal('Y', 0, 1)
>>> pprint(density(X + Y, Y)(z), use_unicode=False)
 2
 -(-Y + z)
 -----------
 ___       2
\/ 2 *e
------------------
 ____
 2*\/ pi 
```

```py
sympy.stats.where(condition, given_condition=None, **kwargs)
```

返回条件为 True 的域。

示例

```py
>>> from sympy.stats import where, Die, Normal
>>> from sympy import And 
```

```py
>>> D1, D2 = Die('a', 6), Die('b', 6)
>>> a, b = D1.symbol, D2.symbol
>>> X = Normal('x', 0, 1) 
```

```py
>>> where(X**2<1)
Domain: (-1 < x) & (x < 1) 
```

```py
>>> where(X**2<1).set
Interval.open(-1, 1) 
```

```py
>>> where(And(D1<=D2, D2<3))
Domain: (Eq(a, 1) & Eq(b, 1)) | (Eq(a, 1) & Eq(b, 2)) | (Eq(a, 2) & Eq(b, 2)) 
```

```py
sympy.stats.variance(X, condition=None, **kwargs)
```

随机表达式的方差。

\[variance(X) = E((X-E(X))^{2})\]

示例

```py
>>> from sympy.stats import Die, Bernoulli, variance
>>> from sympy import simplify, Symbol 
```

```py
>>> X = Die('X', 6)
>>> p = Symbol('p')
>>> B = Bernoulli('B', p, 1, 0) 
```

```py
>>> variance(2*X)
35/3 
```

```py
>>> simplify(variance(B))
p*(1 - p) 
```

```py
class sympy.stats.Variance(arg, condition=None, **kwargs)
```

协方差的符号表达式。

示例

```py
>>> from sympy import symbols, Integral
>>> from sympy.stats import Normal, Expectation, Variance, Probability
>>> mu = symbols("mu", positive=True)
>>> sigma = symbols("sigma", positive=True)
>>> X = Normal("X", mu, sigma)
>>> Variance(X)
Variance(X)
>>> Variance(X).evaluate_integral()
sigma**2 
```

底层计算的积分表示：

```py
>>> Variance(X).rewrite(Integral)
Integral(sqrt(2)*(X - Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)))**2*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)) 
```

积分表示，不扩展 PDF：

```py
>>> Variance(X).rewrite(Probability)
-Integral(x*Probability(Eq(X, x)), (x, -oo, oo))**2 + Integral(x**2*Probability(Eq(X, x)), (x, -oo, oo)) 
```

重写期望的方差

```py
>>> Variance(X).rewrite(Expectation)
-Expectation(X)**2 + Expectation(X**2) 
```

可能基于方差属性的某些转换会发生：

```py
>>> from sympy.abc import a
>>> Y = Normal("Y", 0, 1)
>>> Variance(a*X)
Variance(a*X) 
```

要展开方差为其表达式，请使用`expand()`：

```py
>>> Variance(a*X).expand()
a**2*Variance(X)
>>> Variance(X + Y)
Variance(X + Y)
>>> Variance(X + Y).expand()
2*Covariance(X, Y) + Variance(X) + Variance(Y) 
```

```py
sympy.stats.covariance(X, Y, condition=None, **kwargs)
```

两个随机表达式的协方差。

说明

预期这两个变量将共同上升和下降

\[covariance(X,Y) = E((X-E(X)) (Y-E(Y)))\]

示例

```py
>>> from sympy.stats import Exponential, covariance
>>> from sympy import Symbol 
```

```py
>>> rate = Symbol('lambda', positive=True, real=True)
>>> X = Exponential('X', rate)
>>> Y = Exponential('Y', rate) 
```

```py
>>> covariance(X, X)
lambda**(-2)
>>> covariance(X, Y)
0
>>> covariance(X, Y + rate*X)
1/lambda 
```

```py
class sympy.stats.Covariance(arg1, arg2, condition=None, **kwargs)
```

协方差的符号表达式。

示例

```py
>>> from sympy.stats import Covariance
>>> from sympy.stats import Normal
>>> X = Normal("X", 3, 2)
>>> Y = Normal("Y", 0, 1)
>>> Z = Normal("Z", 0, 1)
>>> W = Normal("W", 0, 1)
>>> cexpr = Covariance(X, Y)
>>> cexpr
Covariance(X, Y) 
```

评估协方差，\(X\) 和 \(Y\) 是独立的，因此结果为零：

```py
>>> cexpr.evaluate_integral()
0 
```

重新用期望表达协方差表达式：

```py
>>> from sympy.stats import Expectation
>>> cexpr.rewrite(Expectation)
Expectation(X*Y) - Expectation(X)*Expectation(Y) 
```

为了扩展参数，请使用`expand()`：

```py
>>> from sympy.abc import a, b, c, d
>>> Covariance(a*X + b*Y, c*Z + d*W)
Covariance(a*X + b*Y, c*Z + d*W)
>>> Covariance(a*X + b*Y, c*Z + d*W).expand()
a*c*Covariance(X, Z) + a*d*Covariance(W, X) + b*c*Covariance(Y, Z) + b*d*Covariance(W, Y) 
```

此类别知晓协方差的一些属性：

```py
>>> Covariance(X, X).expand()
Variance(X)
>>> Covariance(a*X, b*Y).expand()
a*b*Covariance(X, Y) 
```

```py
sympy.stats.coskewness(X, Y, Z, condition=None, **kwargs)
```

计算三个随机变量的共偏度。

参数：

**X**：RandomSymbol

> 用于计算共偏度的随机变量

**Y**：RandomSymbol

> 用于计算共偏度的随机变量

**Z**：RandomSymbol

> 用于计算共偏度的随机变量

**condition**：包含 RandomSymbols 的表达式

> 条件表达式

返回：

**coskewness**：三个随机变量的共偏度

解释

在数学上，共偏度定义为

\[coskewness(X,Y,Z)=\frac{E[(X-E[X]) * (Y-E[Y]) * (Z-E[Z])]} {\sigma_{X}\sigma_{Y}\sigma_{Z}}\]

示例

```py
>>> from sympy.stats import coskewness, Exponential, skewness
>>> from sympy import symbols
>>> p = symbols('p', positive=True)
>>> X = Exponential('X', p)
>>> Y = Exponential('Y', 2*p)
>>> coskewness(X, Y, Y)
0
>>> coskewness(X, Y + X, Y + 2*X)
16*sqrt(85)/85
>>> coskewness(X + 2*Y, Y + X, Y + 2*X, X > 3)
9*sqrt(170)/85
>>> coskewness(Y, Y, Y) == skewness(Y)
True
>>> coskewness(X, Y + p*X, Y + 2*p*X)
4/(sqrt(1 + 1/(4*p**2))*sqrt(4 + 1/(4*p**2))) 
```

参考

[R1046]

[`zh.wikipedia.org/wiki/Coskewness`](https://zh.wikipedia.org/wiki/Coskewness)

```py
sympy.stats.median(X, evaluate=True, **kwargs)
```

计算概率分布的中位数。

参数：

**X：要计算中位数的随机表达式。**

返回：

包含中位数的 FiniteSet 或 Interval

随机表达式。

解释

在数学上，概率分布的中位数定义为所有满足以下条件的值\(m\)：

\[P(X\leq m) \geq \frac{1}{2} \text{ and} \text{ } P(X\geq m)\geq \frac{1}{2}\]

示例

```py
>>> from sympy.stats import Normal, Die, median
>>> N = Normal('N', 3, 1)
>>> median(N)
{3}
>>> D = Die('D')
>>> median(D)
{3, 4} 
```

参考

[R1047]

[`zh.wikipedia.org/wiki/Median#Probability_distributions`](https://zh.wikipedia.org/wiki/Median#Probability_distributions)

```py
sympy.stats.std(X, condition=None, **kwargs)
```

随机表达式的标准差

\[std(X) = \sqrt(E((X-E(X))^{2}))\]

示例

```py
>>> from sympy.stats import Bernoulli, std
>>> from sympy import Symbol, simplify 
```

```py
>>> p = Symbol('p')
>>> B = Bernoulli('B', p, 1, 0) 
```

```py
>>> simplify(std(B))
sqrt(p*(1 - p)) 
```

```py
sympy.stats.quantile(expr, evaluate=True, **kwargs)
```

返回概率分布的第 \(p^{th}\) 阶分位数。

解释

分位数被定义为随机变量概率小于或等于给定概率的值。

\[Q(p) = \inf\{x \in (-\infty, \infty) : p \le F(x)\}\]

示例

```py
>>> from sympy.stats import quantile, Die, Exponential
>>> from sympy import Symbol, pprint
>>> p = Symbol("p") 
```

```py
>>> l = Symbol("lambda", positive=True)
>>> X = Exponential("x", l)
>>> quantile(X)(p)
-log(1 - p)/lambda 
```

```py
>>> D = Die("d", 6)
>>> pprint(quantile(D)(p), use_unicode=False)
/nan  for Or(p > 1, p < 0)
|
| 1       for p <= 1/6
|
| 2       for p <= 1/3
|
< 3       for p <= 1/2
|
| 4       for p <= 2/3
|
| 5       for p <= 5/6
|
\ 6        for p <= 1 
```

```py
sympy.stats.sample(expr, condition=None, size=(), library='scipy', numsamples=1, seed=None, **kwargs)
```

随机表达式的实现。

参数：

**expr**：随机变量的表达式

> 从中提取样本的表达式

**condition**：包含 RandomSymbols 的表达式

> 条件表达式

**size**：整数，元组

> 表示每个样本在`numsamples`中的大小

**library**：字符串

> +   ‘scipy’：使用 scipy 进行示例
> +   
> +   ‘numpy’：使用 numpy 进行示例
> +   
> +   ‘pymc’：使用 PyMC 进行抽样
> +   
> 选择任一可用选项作为字符串进行抽样，默认为‘scipy’

**numsamples**：整数

> 样本数量，每个大小为`size`。
> 
> 自版本 1.9 起已弃用。
> 
> `numsamples`参数已弃用，仅为与 v1.8 兼容性而提供。请改用列表推导或在`size`中添加额外维度。有关详细信息，请参阅 sympy.stats.sample(numsamples=n)。

**seed：**

> 作为给定外部库的种子使用的对象，用于采样\(expr\)。以下是支持库的可能对象类型列表，
> 
> +   ‘scipy’：整数，numpy.random.RandomState，numpy.random.Generator
> +   
> +   ‘numpy’：整数，numpy.random.RandomState，numpy.random.Generator
> +   
> +   ‘pymc’：整数
> +   
> 可选，默认为 None，在这种情况下，将使用与给定库相关的种子设置。此参数不会对环境的全局种子设置进行修改。

返回：

sample: 浮点数/列表/numpy.ndarray

> 一个样本或随机表达式的一组样本。
> 
> +   sample(X) 返回浮点数/numpy.float64/numpy.int64 对象。
> +   
> +   sample(X, size=int/tuple) 返回 numpy.ndarray 对象。

示例

```py
>>> from sympy.stats import Die, sample, Normal, Geometric
>>> X, Y, Z = Die('X', 6), Die('Y', 6), Die('Z', 6) # Finite Random Variable
>>> die_roll = sample(X + Y + Z)
>>> die_roll 
3
>>> N = Normal('N', 3, 4) # Continuous Random Variable
>>> samp = sample(N)
>>> samp in N.pspace.domain.set
True
>>> samp = sample(N, N>0)
>>> samp > 0
True
>>> samp_list = sample(N, size=4)
>>> [sam in N.pspace.domain.set for sam in samp_list]
[True, True, True, True]
>>> sample(N, size = (2,3)) 
array([[5.42519758, 6.40207856, 4.94991743],
 [1.85819627, 6.83403519, 1.9412172 ]])
>>> G = Geometric('G', 0.5) # Discrete Random Variable
>>> samp_list = sample(G, size=3)
>>> samp_list 
[1, 3, 2]
>>> [sam in G.pspace.domain.set for sam in samp_list]
[True, True, True]
>>> MN = Normal("MN", [3, 4], [[2, 1], [1, 2]]) # Joint Random Variable
>>> samp_list = sample(MN, size=4)
>>> samp_list 
[array([2.85768055, 3.38954165]),
 array([4.11163337, 4.3176591 ]),
 array([0.79115232, 1.63232916]),
 array([4.01747268, 3.96716083])]
>>> [tuple(sam) in MN.pspace.domain.set for sam in samp_list]
[True, True, True, True] 
```

在版本 1.7.0 中更改：sample 用于返回包含样本的迭代器而不是值。

在版本 1.9.0 中更改：sample 返回值或值数组而不是迭代器，并且 numsamples 已弃用。

```py
sympy.stats.sample_iter(expr, condition=None, size=(), library='scipy', numsamples=oo, seed=None, **kwargs)
```

在给定条件下从表达式返回实现的迭代器。

参数：

**expr: Expr**

> 要实现的随机表达式

**condition: Expr, optional**

> 一个条件表达式

**size** : 整数，元组

> 表示 numsamples 中每个样本的大小

**numsamples: 整数，可选**

> 迭代器的长度（默认为无穷大）

**seed :**

> 一个用于由给定外部库进行抽样\(expr\)的种子对象。以下是支持库的可能对象类型列表，
> 
> +   ‘scipy’: 整数, numpy.random.RandomState, numpy.random.Generator
> +   
> +   ‘numpy’: 整数, numpy.random.RandomState, numpy.random.Generator
> +   
> +   ‘pymc’: int
> +   
> 可选，默认为 None，在这种情况下，将使用与给定库相关的种子设置。此参数不会对环境的全局种子设置进行修改。

返回：

sample_iter: 迭代器对象

> 包含给定表达式样本/样本的迭代器对象

示例

```py
>>> from sympy.stats import Normal, sample_iter
>>> X = Normal('X', 0, 1)
>>> expr = X*X + 3
>>> iterator = sample_iter(expr, numsamples=3) 
>>> list(iterator) 
[12, 4, 7] 
```

另见

`sample`, `sampling_P`, `sampling_E`

```py
sympy.stats.factorial_moment(X, n, condition=None, **kwargs)
```

阶乘矩是数学量，定义为随机变量的下降阶乘的期望或平均值。

\[factorial-moment(X, n) = E(X(X - 1)(X - 2)...(X - n + 1))\]

参数：

**n: 自然数，n 阶阶乘矩。**

**condition** : 包含随机符号的表达式

> 一个条件表达式。

示例

```py
>>> from sympy.stats import factorial_moment, Poisson, Binomial
>>> from sympy import Symbol, S
>>> lamda = Symbol('lamda')
>>> X = Poisson('X', lamda)
>>> factorial_moment(X, 2)
lamda**2
>>> Y = Binomial('Y', 2, S.Half)
>>> factorial_moment(Y, 2)
1/2
>>> factorial_moment(Y, 2, Y > 1) # find factorial moment for Y > 1
2 
```

参考

[R1048]

[`en.wikipedia.org/wiki/Factorial_moment`](https://en.wikipedia.org/wiki/Factorial_moment)

[R1049]

[`mathworld.wolfram.com/FactorialMoment.html`](https://mathworld.wolfram.com/FactorialMoment.html)

```py
sympy.stats.kurtosis(X, condition=None, **kwargs)
```

描述概率分布的尾部/异常值。

参数：

**condition** : 包含随机符号的表达式

> 一个条件表达式。kurtosis(X, X>0) 是给定 X > 0 的 kurtosis

解释

任何一元正态分布的峰度为 3。峰度小于 3 表示该分布产生的异常值较少且不那么极端。

\[kurtosis(X) = E(((X - E(X))/\sigma_X)^{4})\]

示例

```py
>>> from sympy.stats import kurtosis, Exponential, Normal
>>> from sympy import Symbol
>>> X = Normal('X', 0, 1)
>>> kurtosis(X)
3
>>> kurtosis(X, X > 0) # find kurtosis given X > 0
(-4/pi - 12/pi**2 + 3)/(1 - 2/pi)**2 
```

```py
>>> rate = Symbol('lamda', positive=True, real=True)
>>> Y = Exponential('Y', rate)
>>> kurtosis(Y)
9 
```

参考文献

[R1050]

[`en.wikipedia.org/wiki/Kurtosis`](https://en.wikipedia.org/wiki/Kurtosis)

[R1051]

[`mathworld.wolfram.com/Kurtosis.html`](https://mathworld.wolfram.com/Kurtosis.html)

```py
sympy.stats.skewness(X, condition=None, **kwargs)
```

概率分布不对称度的度量。

参数：

**condition**：包含随机符号的表达式

> 一个条件表达式。skewness(X, X>0)是在给定 X > 0 时 X 的偏度。

解释

正偏表示大多数值位于均值右侧。

\[偏度(X) = E(((X - E(X))/\sigma_X)^{3})\]

示例

```py
>>> from sympy.stats import skewness, Exponential, Normal
>>> from sympy import Symbol
>>> X = Normal('X', 0, 1)
>>> skewness(X)
0
>>> skewness(X, X > 0) # find skewness given X > 0
(-sqrt(2)/sqrt(pi) + 4*sqrt(2)/pi**(3/2))/(1 - 2/pi)**(3/2) 
```

```py
>>> rate = Symbol('lambda', positive=True, real=True)
>>> Y = Exponential('Y', rate)
>>> skewness(Y)
2 
```

```py
sympy.stats.correlation(X, Y, condition=None, **kwargs)
```

两个随机表达式的相关性，也称为相关系数或 Pearson 相关系数。

解释

两个变量共同上升和下降的归一化期望

\[相关性(X,Y) = E((X-E(X))(Y-E(Y)) / (\sigma_x \sigma_y))\]

示例

```py
>>> from sympy.stats import Exponential, correlation
>>> from sympy import Symbol 
```

```py
>>> rate = Symbol('lambda', positive=True, real=True)
>>> X = Exponential('X', rate)
>>> Y = Exponential('Y', rate) 
```

```py
>>> correlation(X, X)
1
>>> correlation(X, Y)
0
>>> correlation(X, Y + rate*X)
1/sqrt(1 + lambda**(-2)) 
```

```py
sympy.stats.rv.sampling_density(expr, given_condition=None, library='scipy', numsamples=1, seed=None, **kwargs)
```

密度的抽样版本。

另请参阅

`density`, `sampling_P`, `sampling_E`

```py
sympy.stats.rv.sampling_P(condition, given_condition=None, library='scipy', numsamples=1, evalf=True, seed=None, **kwargs)
```

P 的抽样版本。

另请参阅

`P`, `sampling_E`, `sampling_density`

```py
sympy.stats.rv.sampling_E(expr, given_condition=None, library='scipy', numsamples=1, evalf=True, seed=None, **kwargs)
```

E 的抽样版本。

另请参阅

`P`, `sampling_P`, `sampling_density`

```py
class sympy.stats.Moment(X, n, c=0, condition=None, **kwargs)
```

用于 Moment 的符号类

示例

```py
>>> from sympy import Symbol, Integral
>>> from sympy.stats import Normal, Expectation, Probability, Moment
>>> mu = Symbol('mu', real=True)
>>> sigma = Symbol('sigma', positive=True)
>>> X = Normal('X', mu, sigma)
>>> M = Moment(X, 3, 1) 
```

要评估`Moment`的结果，请使用\(doit\)：

```py
>>> M.doit()
mu**3 - 3*mu**2 + 3*mu*sigma**2 + 3*mu - 3*sigma**2 - 1 
```

将`Moment`表达式重写为期望的形式：

```py
>>> M.rewrite(Expectation)
Expectation((X - 1)**3) 
```

将`Moment`表达式重写为概率的形式：

```py
>>> M.rewrite(Probability)
Integral((x - 1)**3*Probability(Eq(X, x)), (x, -oo, oo)) 
```

将`Moment`表达式重写为积分的形式：

```py
>>> M.rewrite(Integral)
Integral(sqrt(2)*(X - 1)**3*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)) 
```

```py
sympy.stats.moment(X, n, c=0, condition=None, *, evaluate=True, **kwargs)
```

返回关于随机表达式的第 n 阶矩，关于 c。

\[moment(X, c, n) = E((X-c)^{n})\]

c 的默认值为 0。

示例

```py
>>> from sympy.stats import Die, moment, E
>>> X = Die('X', 6)
>>> moment(X, 1, 6)
-5/2
>>> moment(X, 2)
91/6
>>> moment(X, 1) == E(X)
True 
```

```py
class sympy.stats.CentralMoment(X, n, condition=None, **kwargs)
```

中心矩的符号类

示例

```py
>>> from sympy import Symbol, Integral
>>> from sympy.stats import Normal, Expectation, Probability, CentralMoment
>>> mu = Symbol('mu', real=True)
>>> sigma = Symbol('sigma', positive=True)
>>> X = Normal('X', mu, sigma)
>>> CM = CentralMoment(X, 4) 
```

要评估`CentralMoment`的结果，请使用\(doit\)：

```py
>>> CM.doit().simplify()
3*sigma**4 
```

将`CentralMoment`表达式重写为期望的形式：

```py
>>> CM.rewrite(Expectation)
Expectation((-Expectation(X) + X)**4) 
```

将`CentralMoment`表达式重写为概率的形式：

```py
>>> CM.rewrite(Probability)
Integral((x - Integral(x*Probability(True), (x, -oo, oo)))**4*Probability(Eq(X, x)), (x, -oo, oo)) 
```

将`CentralMoment`表达式重写为积分的形式：

```py
>>> CM.rewrite(Integral)
Integral(sqrt(2)*(X - Integral(sqrt(2)*X*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)))**4*exp(-(X - mu)**2/(2*sigma**2))/(2*sqrt(pi)*sigma), (X, -oo, oo)) 
```

```py
sympy.stats.cmoment(X, n, condition=None, *, evaluate=True, **kwargs)
```

返回关于其均值的随机表达式的第 n 阶中心矩。

\[cmoment(X, n) = E((X - E(X))^{n})\]

示例

```py
>>> from sympy.stats import Die, cmoment, variance
>>> X = Die('X', 6)
>>> cmoment(X, 3)
0
>>> cmoment(X, 2)
35/12
>>> cmoment(X, 2) == variance(X)
True 
```

```py
class sympy.stats.ExpectationMatrix(expr, condition=None)
```

随机矩阵表达式的期望。

示例

```py
>>> from sympy.stats import ExpectationMatrix, Normal
>>> from sympy.stats.rv import RandomMatrixSymbol
>>> from sympy import symbols, MatrixSymbol, Matrix
>>> k = symbols("k")
>>> A, B = MatrixSymbol("A", k, k), MatrixSymbol("B", k, k)
>>> X, Y = RandomMatrixSymbol("X", k, 1), RandomMatrixSymbol("Y", k, 1)
>>> ExpectationMatrix(X)
ExpectationMatrix(X)
>>> ExpectationMatrix(A*X).shape
(k, 1) 
```

要展开期望表达式，请使用`expand()`：

```py
>>> ExpectationMatrix(A*X + B*Y).expand()
A*ExpectationMatrix(X) + B*ExpectationMatrix(Y)
>>> ExpectationMatrix((X + Y)*(X - Y).T).expand()
ExpectationMatrix(X*X.T) - ExpectationMatrix(X*Y.T) + ExpectationMatrix(Y*X.T) - ExpectationMatrix(Y*Y.T) 
```

要评估`ExpectationMatrix`，请使用`doit()`：

```py
>>> N11, N12 = Normal('N11', 11, 1), Normal('N12', 12, 1)
>>> N21, N22 = Normal('N21', 21, 1), Normal('N22', 22, 1)
>>> M11, M12 = Normal('M11', 1, 1), Normal('M12', 2, 1)
>>> M21, M22 = Normal('M21', 3, 1), Normal('M22', 4, 1)
>>> x1 = Matrix([[N11, N12], [N21, N22]])
>>> x2 = Matrix([[M11, M12], [M21, M22]])
>>> ExpectationMatrix(x1 + x2).doit()
Matrix([
[12, 14],
[24, 26]]) 
```

```py
class sympy.stats.VarianceMatrix(arg, condition=None)
```

随机矩阵概率表达式的方差。也称为协方差矩阵、自协方差矩阵、离散矩阵或方差-协方差矩阵。

示例

```py
>>> from sympy.stats import VarianceMatrix
>>> from sympy.stats.rv import RandomMatrixSymbol
>>> from sympy import symbols, MatrixSymbol
>>> k = symbols("k")
>>> A, B = MatrixSymbol("A", k, k), MatrixSymbol("B", k, k)
>>> X, Y = RandomMatrixSymbol("X", k, 1), RandomMatrixSymbol("Y", k, 1)
>>> VarianceMatrix(X)
VarianceMatrix(X)
>>> VarianceMatrix(X).shape
(k, k) 
```

要展开方差表达式，请使用`expand()`：

```py
>>> VarianceMatrix(A*X).expand()
A*VarianceMatrix(X)*A.T
>>> VarianceMatrix(A*X + B*Y).expand()
2*A*CrossCovarianceMatrix(X, Y)*B.T + A*VarianceMatrix(X)*A.T + B*VarianceMatrix(Y)*B.T 
```

```py
class sympy.stats.CrossCovarianceMatrix(arg1, arg2, condition=None)
```

随机矩阵概率表达式的协方差。

示例

```py
>>> from sympy.stats import CrossCovarianceMatrix
>>> from sympy.stats.rv import RandomMatrixSymbol
>>> from sympy import symbols, MatrixSymbol
>>> k = symbols("k")
>>> A, B = MatrixSymbol("A", k, k), MatrixSymbol("B", k, k)
>>> C, D = MatrixSymbol("C", k, k), MatrixSymbol("D", k, k)
>>> X, Y = RandomMatrixSymbol("X", k, 1), RandomMatrixSymbol("Y", k, 1)
>>> Z, W = RandomMatrixSymbol("Z", k, 1), RandomMatrixSymbol("W", k, 1)
>>> CrossCovarianceMatrix(X, Y)
CrossCovarianceMatrix(X, Y)
>>> CrossCovarianceMatrix(X, Y).shape
(k, k) 
```

要展开协方差表达式，请使用`expand()`：

```py
>>> CrossCovarianceMatrix(X + Y, Z).expand()
CrossCovarianceMatrix(X, Z) + CrossCovarianceMatrix(Y, Z)
>>> CrossCovarianceMatrix(A*X, Y).expand()
A*CrossCovarianceMatrix(X, Y)
>>> CrossCovarianceMatrix(A*X, B.T*Y).expand()
A*CrossCovarianceMatrix(X, Y)*B
>>> CrossCovarianceMatrix(A*X + B*Y, C.T*Z + D.T*W).expand()
A*CrossCovarianceMatrix(X, W)*D + A*CrossCovarianceMatrix(X, Z)*C + B*CrossCovarianceMatrix(Y, W)*D + B*CrossCovarianceMatrix(Y, Z)*C 
```

## 机制

SymPy Stats 使用相对复杂的类层次结构。

`RandomDomain`是变量到可能值的映射。例如，我们可以说符号`Symbol('x')`可以取值\(\{1,2,3,4,5,6\}\)。

```py
class sympy.stats.rv.RandomDomain
```

`PSpace` 或概率空间将 `RandomDomain` 与密度结合起来，提供概率信息。例如，上述域可以通过有限密度 `{1:1/6, 2:1/6, 3:1/6, 4:1/6, 5:1/6, 6:1/6}` 来完整定义名为 `x` 的公平骰子的投掷结果。

```py
class sympy.stats.rv.PSpace
```

`RandomSymbol` 在 `SymPy` 表达式中表示 `PSpace` 的符号 `x`。

```py
class sympy.stats.rv.RandomSymbol
```

`RandomDomain` 和 `PSpace` 类几乎从不直接实例化。而是为各种情况进行子类化。

`RandomDomains` 和 `PSpaces` 必须足够通用，以表示具有任意复杂密度的多个变量的域和空间。这种普遍性通常是不必要的。相反，我们经常构建 `SingleDomains` 和 `SinglePSpaces` 来表示单一的单变量事件和过程，例如单个骰子或单个正态变量。

```py
class sympy.stats.rv.SinglePSpace
```

```py
class sympy.stats.rv.SingleDomain
```

另一个常见情况是将一组这样的单变量随机变量聚集在一起。可以将独立的 `SinglePSpaces` 或 `SingleDomains` 集合在一起，形成 `ProductDomain` 或 `ProductPSpace`。例如，这些对象在表示三个同时掷的骰子时非常有用。

```py
class sympy.stats.rv.ProductDomain
```

```py
class sympy.stats.rv.ProductPSpace
```

当我们向随机域或概率空间添加全局条件时，需要添加条件形容词。一个常见的例子是三个独立的骰子，我们知道它们的总和大于 12。

```py
class sympy.stats.rv.ConditionalDomain
```

我们进一步专门化这些类的有限版本和连续版本，以表示有限（例如骰子）和连续（例如正态分布）的随机变量。

```py
class sympy.stats.frv.FiniteDomain
```

```py
class sympy.stats.frv.FinitePSpace
```

```py
class sympy.stats.crv.ContinuousDomain
```

```py
class sympy.stats.crv.ContinuousPSpace
```

另外还有一些专门的类，实现了某些常见的随机变量类型。例如，`DiePSpace` 实现了 `SingleFinitePSpace`，而 `NormalPSpace` 实现了 `SingleContinuousPSpace`。

```py
class sympy.stats.frv_types.DiePSpace
```

```py
class sympy.stats.crv_types.NormalPSpace
```

可以使用 `PSpace.values` 方法从这些对象中提取随机变量。

正如之前提到的，`SymPy` 统计模块采用了相对复杂的类结构。继承广泛用于实现末级类。这种策略被选择来在允许 `SymPy` 表示任意定义的随机变量和优化常见情况之间取得平衡。这增加了代码复杂性，但结构化得仅对于那些在将 `SymPy` 统计扩展到其他随机变量类型上工作的人员是重要的。

用户不会直接使用这种类结构。相反，这些机制通过变量创建函数 `Die`、`Coin`、`FiniteRV`、`Normal`、`Exponential` 等暴露出来。这些函数构建适当的 `SinglePSpaces` 并返回相应的 `RandomVariable`。条件空间和乘积空间在 `SymPy` 表达式的自然构造中形成，并使用接口函数 `E`、`Given`、`Density` 等。

```py
sympy.stats.Die()
```

```py
sympy.stats.Normal()
```

还有一些可能有用的额外函数。它们主要用于内部使用。

```py
sympy.stats.rv.random_symbols(expr)
```

返回 `SymPy` 表达式中的所有 `RandomSymbol`。

```py
sympy.stats.rv.pspace(expr)
```

返回随机表达式的基础概率空间。

供内部使用。

示例

```py
>>> from sympy.stats import pspace, Normal
>>> X = Normal('X', 0, 1)
>>> pspace(2*X + 1) == X.pspace
True 
```

```py
sympy.stats.rv.rs_swap(a, b)
```

构建一个字典，根据它们的基础符号来交换 `RandomSymbol`。

输出：将集合 a 中的随机变量映射到集合 b 中的随机变量的字典

输入：随机变量集合 a 和 b，它们共享相同的符号
