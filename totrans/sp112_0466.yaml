- en: scipy.optimize.linear_sum_assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solve the linear sum assignment problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cost_matrix**array'
  prefs: []
  type: TYPE_NORMAL
- en: The cost matrix of the bipartite graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**maximize**bool (default: False)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculates a maximum weight matching if true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**row_ind, col_ind**array'
  prefs: []
  type: TYPE_NORMAL
- en: An array of row indices and one of corresponding column indices giving the optimal
    assignment. The cost of the assignment can be computed as `cost_matrix[row_ind,
    col_ind].sum()`. The row indices will be sorted; in the case of a square cost
    matrix they will be equal to `numpy.arange(cost_matrix.shape[0])`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.sparse.csgraph.min_weight_full_bipartite_matching`](scipy.sparse.csgraph.min_weight_full_bipartite_matching.html#scipy.sparse.csgraph.min_weight_full_bipartite_matching
    "scipy.sparse.csgraph.min_weight_full_bipartite_matching")'
  prefs: []
  type: TYPE_NORMAL
- en: for sparse inputs
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The linear sum assignment problem [[1]](#rc35ed51944ec-1) is also known as minimum
    weight matching in bipartite graphs. A problem instance is described by a matrix
    C, where each C[i,j] is the cost of matching vertex i of the first partite set
    (a ‘worker’) and vertex j of the second set (a ‘job’). The goal is to find a complete
    assignment of workers to jobs of minimal cost.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, let X be a boolean matrix where \(X[i,j] = 1\) iff row i is assigned
    to column j. Then the optimal assignment has cost
  prefs: []
  type: TYPE_NORMAL
- en: \[\min \sum_i \sum_j C_{i,j} X_{i,j}\]
  prefs: []
  type: TYPE_NORMAL
- en: where, in the case where the matrix X is square, each row is assigned to exactly
    one column, and each column to exactly one row.
  prefs: []
  type: TYPE_NORMAL
- en: This function can also solve a generalization of the classic assignment problem
    where the cost matrix is rectangular. If it has more rows than columns, then not
    every row needs to be assigned to a column, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is a modified Jonker-Volgenant algorithm with no initialization,
    described in ref. [[2]](#rc35ed51944ec-2).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.17.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Assignment_problem](https://en.wikipedia.org/wiki/Assignment_problem)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: DF Crouse. On implementing 2D rectangular assignment algorithms. *IEEE Transactions
    on Aerospace and Electronic Systems*, 52(4):1679-1696, August 2016, [DOI:10.1109/TAES.2016.140952](https://doi.org/10.1109/TAES.2016.140952)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
