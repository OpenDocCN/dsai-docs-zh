- en: Tensor Canonicalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html](https://docs.sympy.org/latest/modules/combinatorics/tensor_can.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: canonicalize tensor formed by tensors
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**g** : permutation representing the tensor'
  prefs: []
  type: TYPE_NORMAL
- en: '**dummies** : list representing the dummy indices'
  prefs: []
  type: TYPE_NORMAL
- en: it can be a list of dummy indices of the same type or a list of lists of dummy
    indices, one list for each type of index; the dummy indices must come after the
    free indices, and put in order contravariant, covariant [d0, -d0, d1,-d1,…]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**msym** : symmetry of the metric(s)'
  prefs: []
  type: TYPE_NORMAL
- en: it can be an integer or a list; in the first case it is the symmetry of the
    dummy index metric; in the second case it is the list of the symmetries of the
    index metric for each type
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**v** : list, (base_i, gens_i, n_i, sym_i) for tensors of type \(i\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**base_i, gens_i** : BSGS for tensors of this type.'
  prefs: []
  type: TYPE_NORMAL
- en: The BSGS should have minimal base under lexicographic ordering; if not, an attempt
    is made do get the minimal BSGS; in case of failure, canonicalize_naive is used,
    which is much slower.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_i** : number of tensors of type \(i\).'
  prefs: []
  type: TYPE_NORMAL
- en: '**sym_i** : symmetry under exchange of component tensors of type \(i\).'
  prefs: []
  type: TYPE_NORMAL
- en: Both for msym and sym_i the cases are
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: None no symmetry
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 commuting
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 anticommuting
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the tensor is zero, else return the array form of
  prefs: []
  type: TYPE_NORMAL
- en: the permutation representing the canonical form of the tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  prefs: []
  type: TYPE_NORMAL
- en: First one uses canonical_free to get the minimum tensor under lexicographic
    order, using only the slot symmetries. If the component tensors have not minimal
    BSGS, it is attempted to find it; if the attempt fails canonicalize_naive is used
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Compute the residual slot symmetry keeping fixed the free indices using tensor_gens(base,
    gens, list_free_indices, sym).
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the problem eliminating the free indices.
  prefs: []
  type: TYPE_NORMAL
- en: Then use double_coset_can_rep and lift back the result reintroducing the free
    indices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: one type of index with commuting metric;
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{a b}\) and \(B_{a b}\) antisymmetric and commuting
  prefs: []
  type: TYPE_NORMAL
- en: \(T = A_{d0 d1} * B^{d0}{}_{d2} * B^{d2 d1}\)
  prefs: []
  type: TYPE_NORMAL
- en: \(ord = [d0,-d0,d1,-d1,d2,-d2]\) order of the indices
  prefs: []
  type: TYPE_NORMAL
- en: g = [1, 3, 0, 5, 4, 2, 6, 7]
  prefs: []
  type: TYPE_NORMAL
- en: \(T_c = 0\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: same as above, but with \(B_{a b}\) anticommuting
  prefs: []
  type: TYPE_NORMAL
- en: \(T_c = -A^{d0 d1} * B_{d0}{}^{d2} * B_{d1 d2}\)
  prefs: []
  type: TYPE_NORMAL
- en: can = [0,2,1,4,3,5,7,6]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: two types of indices \([a,b,c,d,e,f]\) and \([m,n]\), in this order, both with
    commuting metric
  prefs: []
  type: TYPE_NORMAL
- en: \(f^{a b c}\) antisymmetric, commuting
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{m a}\) no symmetry, commuting
  prefs: []
  type: TYPE_NORMAL
- en: \(T = f^c{}_{d a} * f^f{}_{e b} * A_m{}^d * A^{m b} * A_n{}^a * A^{n e}\)
  prefs: []
  type: TYPE_NORMAL
- en: ord = [c,f,a,-a,b,-b,d,-d,e,-e,m,-m,n,-n]
  prefs: []
  type: TYPE_NORMAL
- en: g = [0,7,3, 1,9,5, 11,6, 10,4, 13,2, 12,8, 14,15]
  prefs: []
  type: TYPE_NORMAL
- en: The canonical tensor is \(T_c = -f^{c a b} * f^{f d e} * A^m{}_a * A_{m d} *
    A^n{}_b * A_{n e}\)
  prefs: []
  type: TYPE_NORMAL
- en: can = [0,2,4, 1,6,8, 10,3, 11,7, 12,5, 13,9, 15,14]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Butler-Portugal algorithm for tensor canonicalization with dummy indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dummies**'
  prefs: []
  type: TYPE_NORMAL
- en: list of lists of dummy indices, one list for each type of index; the dummy indices
    are put in order contravariant, covariant [d0, -d0, d1, -d1, …].
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sym
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: list of the symmetries of the index metric for each type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: possible symmetries of the metrics
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0 symmetric
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 antisymmetric
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None no symmetry
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b_S
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: base of a minimal slot symmetry BSGS.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sgens
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: generators of the slot symmetry BSGS.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: S_transversals
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: transversals for the slot BSGS.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: g
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: permutation representing the tensor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Return 0 if the tensor is zero, else return the array form of
  prefs: []
  type: TYPE_NORMAL
- en: the permutation representing the canonical form of the tensor.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: A tensor with dummy indices can be represented in a number of equivalent ways
    which typically grows exponentially with the number of indices. To be able to
    establish if two tensors with many indices are equal becomes computationally very
    slow in absence of an efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The Butler-Portugal algorithm [3] is an efficient algorithm to put tensors in
    canonical form, solving the above problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Portugal observed that a tensor can be represented by a permutation, and that
    the class of tensors equivalent to it under slot and dummy symmetries is equivalent
    to the double coset \(D*g*S\) (Note: in this documentation we use the conventions
    for multiplication of permutations p, q with (p*q)(i) = p[q[i]] which is opposite
    to the one used in the Permutation class)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the algorithm by Butler to find a representative of the double coset one
    can find a canonical form for the tensor.
  prefs: []
  type: TYPE_NORMAL
- en: To see this correspondence, let \(g\) be a permutation in array form; a tensor
    with indices \(ind\) (the indices including both the contravariant and the covariant
    ones) can be written as
  prefs: []
  type: TYPE_NORMAL
- en: \(t = T(ind[g[0]], \dots, ind[g[n-1]])\),
  prefs: []
  type: TYPE_NORMAL
- en: where \(n = len(ind)\); \(g\) has size \(n + 2\), the last two indices for the
    sign of the tensor (trick introduced in [4]).
  prefs: []
  type: TYPE_NORMAL
- en: A slot symmetry transformation \(s\) is a permutation acting on the slots \(t
    \rightarrow T(ind[(g*s)[0]], \dots, ind[(g*s)[n-1]])\)
  prefs: []
  type: TYPE_NORMAL
- en: A dummy symmetry transformation acts on \(ind\) \(t \rightarrow T(ind[(d*g)[0]],
    \dots, ind[(d*g)[n-1]])\)
  prefs: []
  type: TYPE_NORMAL
- en: Being interested only in the transformations of the tensor under these symmetries,
    one can represent the tensor by \(g\), which transforms as
  prefs: []
  type: TYPE_NORMAL
- en: \(g -> d*g*s\), so it belongs to the coset \(D*g*S\), or in other words to the
    set of all permutations allowed by the slot and dummy symmetries.
  prefs: []
  type: TYPE_NORMAL
- en: Let us explain the conventions by an example.
  prefs: []
  type: TYPE_NORMAL
- en: Given a tensor \(T^{d3 d2 d1}{}_{d1 d2 d3}\) with the slot symmetries
  prefs: []
  type: TYPE_NORMAL
- en: \(T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}\)
  prefs: []
  type: TYPE_NORMAL
- en: \(T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1 a2 a3 a0 a5}\)
  prefs: []
  type: TYPE_NORMAL
- en: 'and symmetric metric, find the tensor equivalent to it which is the lowest
    under the ordering of indices: lexicographic ordering \(d1, d2, d3\) and then
    contravariant before covariant index; that is the canonical form of the tensor.'
  prefs: []
  type: TYPE_NORMAL
- en: The canonical form is \(-T^{d1 d2 d3}{}_{d1 d2 d3}\) obtained using \(T^{a0
    a1 a2 a3 a4 a5} = -T^{a2 a1 a0 a3 a4 a5}\).
  prefs: []
  type: TYPE_NORMAL
- en: To convert this problem in the input for this function, use the following ordering
    of the index names (- for covariant for short) \(d1, -d1, d2, -d2, d3, -d3\)
  prefs: []
  type: TYPE_NORMAL
- en: \(T^{d3 d2 d1}{}_{d1 d2 d3}\) corresponds to \(g = [4, 2, 0, 1, 3, 5, 6, 7]\)
    where the last two indices are for the sign
  prefs: []
  type: TYPE_NORMAL
- en: \(sgens = [Permutation(0, 2)(6, 7), Permutation(0, 4)(6, 7)]\)
  prefs: []
  type: TYPE_NORMAL
- en: sgens[0] is the slot symmetry \(-(0, 2)\) \(T^{a0 a1 a2 a3 a4 a5} = -T^{a2 a1
    a0 a3 a4 a5}\)
  prefs: []
  type: TYPE_NORMAL
- en: sgens[1] is the slot symmetry \(-(0, 4)\) \(T^{a0 a1 a2 a3 a4 a5} = -T^{a4 a1
    a2 a3 a0 a5}\)
  prefs: []
  type: TYPE_NORMAL
- en: The dummy symmetry group D is generated by the strong base generators \([(0,
    1), (2, 3), (4, 5), (0, 2)(1, 3), (0, 4)(1, 5)]\) where the first three interchange
    covariant and contravariant positions of the same index (d1 <-> -d1) and the last
    two interchange the dummy indices themselves (d1 <-> d2).
  prefs: []
  type: TYPE_NORMAL
- en: The dummy symmetry acts from the left \(d = [1, 0, 2, 3, 4, 5, 6, 7]\) exchange
    \(d1 \leftrightarrow -d1\) \(T^{d3 d2 d1}{}_{d1 d2 d3} == T^{d3 d2}{}_{d1}{}^{d1}{}_{d2
    d3}\)
  prefs: []
  type: TYPE_NORMAL
- en: \(g=[4, 2, 0, 1, 3, 5, 6, 7] -> [4, 2, 1, 0, 3, 5, 6, 7] = _af_rmul(d, g)\)
    which differs from \(_af_rmul(g, d)\).
  prefs: []
  type: TYPE_NORMAL
- en: The slot symmetry acts from the right \(s = [2, 1, 0, 3, 4, 5, 7, 6]\) exchanges
    slots 0 and 2 and changes sign \(T^{d3 d2 d1}{}_{d1 d2 d3} == -T^{d1 d2 d3}{}_{d1
    d2 d3}\)
  prefs: []
  type: TYPE_NORMAL
- en: \(g=[4,2,0,1,3,5,6,7] -> [0, 2, 4, 1, 3, 5, 7, 6] = _af_rmul(g, s)\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example in which the tensor is zero, same slot symmetries as above: \(T^{d2}{}_{d1
    d3}{}^{d1 d3}{}_{d2}\)'
  prefs: []
  type: TYPE_NORMAL
- en: \(= -T^{d3}{}_{d1 d3}{}^{d1 d2}{}_{d2}\) under slot symmetry \(-(0,4)\);
  prefs: []
  type: TYPE_NORMAL
- en: \(= T_{d3 d1}{}^{d3}{}^{d1 d2}{}_{d2}\) under slot symmetry \(-(0,2)\);
  prefs: []
  type: TYPE_NORMAL
- en: \(= T^{d3}{}_{d1 d3}{}^{d1 d2}{}_{d2}\) symmetric metric;
  prefs: []
  type: TYPE_NORMAL
- en: \(= 0\) since two of these lines have tensors differ only for the sign.
  prefs: []
  type: TYPE_NORMAL
- en: The double coset D*g*S consists of permutations \(h = d*g*s\) corresponding
    to equivalent tensors; if there are two \(h\) which are the same apart from the
    sign, return zero; otherwise choose as representative the tensor with indices
    ordered lexicographically according to \([d1, -d1, d2, -d2, d3, -d3]\) that is
    `rep = min(D*g*S) = min([d*g*s for d in D for s in S])`
  prefs: []
  type: TYPE_NORMAL
- en: The indices are fixed one by one; first choose the lowest index for slot 0,
    then the lowest remaining index for slot 1, etc. Doing this one obtains a chain
    of stabilizers
  prefs: []
  type: TYPE_NORMAL
- en: \(S \rightarrow S_{b0} \rightarrow S_{b0,b1} \rightarrow \dots\) and \(D \rightarrow
    D_{p0} \rightarrow D_{p0,p1} \rightarrow \dots\)
  prefs: []
  type: TYPE_NORMAL
- en: where `[b0, b1, ...] = range(b)` is a base of the symmetric group; the strong
    base \(b_S\) of S is an ordered sublist of it; therefore it is sufficient to compute
    once the strong base generators of S using the Schreier-Sims algorithm; the stabilizers
    of the strong base generators are the strong base generators of the stabilizer
    subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '`dbase = [p0, p1, ...]` is not in general in lexicographic order, so that one
    must recompute the strong base generators each time; however this is trivial,
    there is no need to use the Schreier-Sims algorithm for D.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm keeps a TAB of elements \((s_i, d_i, h_i)\) where \(h_i = d_i
    \times g \times s_i\) satisfying \(h_i[j] = p_j\) for \(0 \le j < i\) starting
    from \(s_0 = id, d_0 = id, h_0 = g\).
  prefs: []
  type: TYPE_NORMAL
- en: The equations \(h_0[0] = p_0, h_1[1] = p_1, \dots\) are solved in this order,
    choosing each time the lowest possible value of p_i
  prefs: []
  type: TYPE_NORMAL
- en: For \(j < i\) \(d_i*g*s_i*S_{b_0, \dots, b_{i-1}}*b_j = D_{p_0, \dots, p_{i-1}}*p_j\)
    so that for dx in \(D_{p_0,\dots,p_{i-1}}\) and sx in \(S_{base[0], \dots, base[i-1]}\)
    one has \(dx*d_i*g*s_i*sx*b_j = p_j\)
  prefs: []
  type: TYPE_NORMAL
- en: Search for dx, sx such that this equation holds for \(j = i\); it can be written
    as \(s_i*sx*b_j = J, dx*d_i*g*J = p_j\) \(sx*b_j = s_i**-1*J; sx = trace(s_i**-1,
    S_{b_0,...,b_{i-1}})\) \(dx**-1*p_j = d_i*g*J; dx = trace(d_i*g*J, D_{p_0,...,p_{i-1}})\)
  prefs: []
  type: TYPE_NORMAL
- en: \(s_{i+1} = s_i*trace(s_i**-1*J, S_{b_0,...,b_{i-1}})\) \(d_{i+1} = trace(d_i*g*J,
    D_{p_0,...,p_{i-1}})**-1*d_i\) \(h_{i+1}*b_i = d_{i+1}*g*s_{i+1}*b_i = p_i\)
  prefs: []
  type: TYPE_NORMAL
- en: \(h_n*b_j = p_j\) for all j, so that \(h_n\) is the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Add the found \((s, d, h)\) to TAB1.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the iteration sort TAB1 with respect to the \(h\); if there are
    two consecutive \(h\) in TAB1 which differ only for the sign, the tensor is zero,
    so return 0; if there are two consecutive \(h\) which are equal, keep only one.
  prefs: []
  type: TYPE_NORMAL
- en: Then stabilize the slot generators under \(i\) and the dummy generators under
    \(p_i\).
  prefs: []
  type: TYPE_NORMAL
- en: Assign \(TAB = TAB1\) at the end of the iteration step.
  prefs: []
  type: TYPE_NORMAL
- en: At the end \(TAB\) contains a unique \((s, d, h)\), since all the slots of the
    tensor \(h\) have been fixed to have the minimum value according to the symmetries.
    The algorithm returns \(h\).
  prefs: []
  type: TYPE_NORMAL
- en: It is important that the slot BSGS has lexicographic minimal base, otherwise
    there is an \(i\) which does not belong to the slot base for which \(p_i\) is
    fixed by the dummy symmetry only, while \(i\) is not invariant from the slot stabilizer,
    so \(p_i\) is not in general the minimal value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm differs slightly from the original algorithm [3]:'
  prefs: []
  type: TYPE_NORMAL
- en: the canonical form is minimal lexicographically, and the BSGS has minimal base
    under lexicographic order. Equal tensors \(h\) are eliminated from TAB.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Return base, gens of the minimal BSGS for (anti)symmetric tensor
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : rank of the tensor'
  prefs: []
  type: TYPE_NORMAL
- en: '**antisym** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: '`antisym = False` symmetric tensor `antisym = True` antisymmetric tensor'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Direct product of two BSGS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base1** : base of the first BSGS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**gens1** : strong generating sequence of the first BSGS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**base2, gens2** : similarly for the second BSGS.'
  prefs: []
  type: TYPE_NORMAL
- en: '**signed** : flag for signed permutations.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
