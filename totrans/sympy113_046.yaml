- en: Glossary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语表
- en: 原文：[https://docs.sympy.org/latest/explanation/glossary.html](https://docs.sympy.org/latest/explanation/glossary.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/explanation/glossary.html](https://docs.sympy.org/latest/explanation/glossary.html)
- en: This page is a glossary for various terms used throughout the SymPy documentation.
    This glossary is primarily for terms that are specific to SymPy. For more general
    Python terms, refer to the [Python glossary](https://docs.python.org/3/glossary.html).
    Mathematical terms are only included here if they have a specific meaning in SymPy.
    For general mathematical definitions, refer to other sources such as [Wikipedia](https://www.wikipedia.org/)
    or [MathWorld](https://mathworld.wolfram.com/), as well as the references in the
    documentation for the specific SymPy functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一页是 SymPy 文档中使用的各种术语的术语表。该术语表主要用于特定于 SymPy 的术语。有关更一般的 Python 术语，请参阅[Python
    术语表](https://docs.python.org/3/glossary.html)。数学术语仅在 SymPy 中具有特定含义时包含在此处。有关一般数学定义，请参考其他来源，如[Wikipedia](https://www.wikipedia.org/)或[MathWorld](https://mathworld.wolfram.com/)，以及特定
    SymPy 函数文档中的参考资料。
- en: Antiderivative
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 反导数
- en: An *antiderivative* of a function \(f(x)\) with respect to \(x\) is a function
    \(F(x)\) such that \(\frac{d}{dx}F(x) = f(x).\) It is also sometimes called an
    “indefinite integral” of \(f(x)\), and written as \(\int f(x)\,dx.\) Antiderivatives
    in SymPy can be computed with [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate"). Note some sources call this the “primitive”
    of \(f(x)\), but this terminology is not used in SymPy because it is not as universally
    used as “antiderivative”, and because “primitive” has other meanings in mathematics
    and in [`SymPy`](../modules/polys/reference.html#sympy.polys.polytools.primitive
    "sympy.polys.polytools.primitive").
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 \(f(x)\) 关于 \(x\) 的一个*反导数*是一个函数 \(F(x)\)，使得 \(\frac{d}{dx}F(x) = f(x).\)
    有时也称为 \(f(x)\) 的“不定积分”，并写作 \(\int f(x)\,dx.\) 在 SymPy 中，可以用[`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate")计算反导数。请注意，某些来源称之为 \(f(x)\) 的“原函数”，但 SymPy
    中不使用此术语，因为它不像“反导数”一样被普遍使用，并且“原函数”在数学和[`SymPy`](../modules/polys/reference.html#sympy.polys.polytools.primitive
    "sympy.polys.polytools.primitive")中有其他含义。
- en: '`args`'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`args`'
- en: The *`args`* property of a SymPy [expression](#term-Expression) is a tuple of
    the top-level [subexpressions](#term-Subexpression) used to create it. They are
    the arguments to the class used to create the expression. The args of any expression
    can be obtained by the `.args` attribute. For example, `(1 + x*y).args` is `(1,
    x*y)`, because it equals `Add(1, x*y)`. The `args` together with [func](#term-func)
    completely define an expression. It is always possible to walk the [expression
    tree](#term-Expression-Tree) and extract any subexpression of a SymPy expression
    by repeated use of `.args`. Every SymPy expression can be rebuilt exactly with
    `func` and `args`, that is, `expr.func(*expr.args) == expr` will always be true
    of any SymPy expression `expr`. The args of an expression may be the empty tuple
    `()`, meaning the expression is an [atom](#term-Atom).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy [表达式](#term-Expression)的*`args`* 属性是用于创建它的顶级[子表达式](#term-Subexpression)的元组。它们是用于创建表达式的类的参数。任何表达式的
    `args` 可以通过 `.args` 属性获取。例如，`(1 + x*y).args` 是 `(1, x*y)`，因为它等于 `Add(1, x*y)`。`args`
    与[func](#term-func)一起完全定义了一个表达式。可以通过反复使用 `.args` 来遍历[表达式树](#term-Expression-Tree)并提取
    SymPy 表达式的任何子表达式。通过 `func` 和 `args`，始终可以准确重建任何 SymPy 表达式，即 `expr.func(*expr.args)
    == expr` 对于任何 SymPy 表达式 `expr` 都是真实的。一个表达式的 `args` 可能是空元组 `()`，这意味着表达式是一个[原子](#term-Atom)。
- en: Assumptions
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Assumptions
- en: '*Assumptions* are a set of predicates on a [symbol](#term-Symbol) or [expression](#term-Expression)
    that define the set of possible values it can take. Some examples of assumptions
    are `positive`, `real`, and `integer`. Assumptions are related to one another
    logically, for example, an assumption of `integer` automatically implies `real`.
    Assumptions use a [three-valued logic](#term-Three-valued-logic) system where
    predicates are either `True`, `False`, or `None`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*Assumptions* 是对[符号](#term-Symbol)或[表达式](#term-Expression)的一组谓词，定义其可以取的可能值集合。一些假设的示例包括
    `positive`、`real` 和 `integer`。假设在逻辑上相互关联，例如，一个 `integer` 的假设自动意味着 `real`。假设使用[三值逻辑](#term-Three-valued-logic)系统，其中谓词可以是
    `True`、`False` 或 `None`。'
- en: Assumptions are either *assumed* or *queried*. For example, a symbol `x` might
    be *assumed* to be positive by defining it as `x = symbols('x', positive=True)`.
    Then an assumption might be *queried* on the expression containing this symbol,
    like `(x + 1).is_real`, which in this case would return `True`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设可以是*假设*或*查询*。例如，一个符号 `x` 可能通过将其定义为 `x = symbols('x', positive=True)` 来*假设*为正数。然后可以在包含此符号的表达式上*查询*一个假设，如
    `(x + 1).is_real`，在这种情况下将返回 `True`。
- en: If no assumptions are assumed on a symbol, then by default symbols are assumed
    to be general complex numbers. Setting assumptions is important because certain
    simplifications are only mathematically true in a restricted domain, for example,
    \(\sqrt{x^2} = x\) is not true for general complex \(x\) but it is true when \(x\)
    is positive. SymPy functions will never perform an operation on an expression
    unless it is true for all values allowed by its assumptions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在符号上没有假设，则默认情况下假设符号是一般复数。设置假设是重要的，因为某些简化只在受限域内数学上成立，例如，\(\sqrt{x^2} = x\)
    对一般复数 \(x\) 不成立，但当 \(x\) 是正数时成立。除非表达式的所有允许值都符合其假设，否则SymPy函数不会对表达式执行操作。
- en: SymPy has two separate assumptions systems, which are closely related to one
    another. In the first, which is sometimes called the “old assumptions” because
    it is older, assumptions are assumed on [Symbol](#term-Symbol) objects and queried
    with [is_*](#term-is_) attributes. In the second, which is sometimes called the
    “new assumptions”, assumptions are assumed using separate predicate objects like
    `Q.positive` and queried using the [`ask()`](../modules/assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask") function. The newer assumptions system is able to
    support more complex queries, but is also not as well developed as the older one.
    Most users of SymPy should prefer the older assumptions system at this time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy有两个独立的假设系统，它们彼此紧密相关。在第一个系统中，有时被称为“旧假设”，因为它更老，假设是在[符号](#term-Symbol)对象上假设并使用[is_*](#term-is_)属性查询。在第二个系统中，有时被称为“新假设”，假设是使用像`Q.positive`这样的单独谓词对象假设的，并使用[`ask()`](../modules/assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask")函数查询。较新的假设系统能够支持更复杂的查询，但也不像较旧的那样发展得好。目前大多数SymPy用户应该偏好较旧的假设系统。
- en: See the [assumptions guide](../guides/assumptions.html#assumptions-guide) for
    more details on assumptions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[假设指南](../guides/assumptions.html#assumptions-guide)了解更多关于假设的细节。
- en: Atom
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 原子
- en: An *atom* is an expression whose [args](#term-args) is the empty tuple `()`.
    Atoms are the leaves of the [expression tree](#term-Expression-Tree). For example,
    if a function uses recursion to walk an expression tree using `args`, the atomic
    expressions will be the base case of the recursion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*原子*是一个表达式，其[args](#term-args)是空元组`()`。原子是[表达式树](#term-Expression-Tree)的叶子节点。例如，如果一个函数使用递归来遍历表达式树使用`args`，那么原子表达式将是递归的基本情况。
- en: Note that the class [`Atom`](../modules/core.html#sympy.core.basic.Atom "sympy.core.basic.Atom")
    is sometimes used as the base class of atomic expressions, but it is not a requirement
    for atomic expressions to subclass this class. The only requirement for an expression
    to be atomic is for its [args](#term-args) to be empty.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类[`Atom`](../modules/core.html#sympy.core.basic.Atom "sympy.core.basic.Atom")有时被用作原子表达式的基类，但不要求原子表达式必须是这个类的子类。表达式要成为原子表达式的唯一要求是它的[args](#term-args)为空。
- en: Automatic Simplification
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动简化
- en: '*Automatic Simplification* refers to any simplification that happens automatically
    inside of a class constructor. For example, `x + x` is automatically simplified
    to `2*x` in the [`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add")
    constructor. Unlike manual [simplification](#term-Simplification), automatic simplification
    can only be disabled by setting `evaluate=False` (see [Unevaluated](#term-Unevaluated)).
    Automatic simplification is often done so that expressions become [canonicalized](#term-Canonicalize).
    Excessive automatic simplification is discouraged, as it makes it impossible to
    represent the non-simplified form of the expression without using tricks like
    `evaluate=False`, and it can often be an expensive thing to do in a class constructor.
    Instead, manual [simplification](#term-Simplification)/[canonicalization](#term-Canonicalize)
    is generally preferred.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动简化* 指的是在类构造函数内部自动进行的任何简化。例如，在 [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") 构造函数中，`x + x` 会自动简化为 `2*x`。与手动 [简化](#term-Simplification)
    不同，自动简化只能通过设置 `evaluate=False` 来禁用 (参见 [未评估](#term-Unevaluated))。通常进行自动简化是为了使表达式
    [规范化](#term-Canonicalize)。过度的自动简化是不鼓励的，因为这样做会使表达式无法表示为非简化形式，除非使用 `evaluate=False`
    等技巧，而且在类构造函数中这样做通常是一件昂贵的事情。相比之下，通常更倾向于进行手动 [简化](#term-Simplification)/[规范化](#term-Canonicalize)。'
- en: '[`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[`基本`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")'
- en: '*[`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")*
    is the superclass of all SymPy expressions. It defines the basic methods required
    for a SymPy expression, such as [args](#term-args), [func](#term-func), [equality](#term-Structural-Equality),
    [immutability](#term-Immutable), and some useful expression manipulation functions
    such as [substitution](#term-Substitution). Most SymPy classes will subclass a
    more specific `Basic` subclass such as [Boolean](#term-Boolean), [Expr](#term-Expr),
    [Function](#term-Function-class), or [Matrix](#term-Matrix). An object that is
    not a `Basic` instance typically cannot be used in SymPy functions, unless it
    can be turned into one via [sympify()](#term-sympify).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`基本`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")*
    是所有 SymPy 表达式的超类。它定义了SymPy表达式所需的基本方法，比如 [args](#term-args)，[func](#term-func)，[equality](#term-Structural-Equality)，[immutability](#term-Immutable)，以及一些有用的表达式操作函数，比如
    [替换](#term-Substitution)。大多数SymPy类将会作为更具体的 `Basic` 子类，比如 [布尔](#term-Boolean)，[表达式](#term-Expr)，[函数](#term-Function-class)，或
    [矩阵](#term-Matrix) 进行子类化。通常情况下，如果一个对象不是 `Basic` 实例，它就不能在SymPy函数中使用，除非可以通过 [sympify()](#term-sympify)
    转换为一个。'
- en: '[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`布尔`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")'
- en: '*[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")*
    is the base class for the classes in the [`logic`](../modules/logic.html#module-sympy.logic
    "sympy.logic") module. `Boolean` instances represent logical predicates that are
    elements of a [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra)
    and can be thought of as having a “true” or “false” value (note that `Boolean`
    objects do not use the [three-valued logic](#term-Three-valued-logic) used by
    the [assumptions](#term-Assumptions)).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`布尔`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")*
    是 [`logic`](../modules/logic.html#module-sympy.logic "sympy.logic") 模块中类的基类。`Boolean`
    实例代表布尔代数中的逻辑谓词，并且可以被视为具有“真”或“假”值 (注意 `Boolean` 对象不使用 [三值逻辑](#term-Three-valued-logic)，而是使用
    [假设](#term-Assumptions)）。'
- en: Bound symbols
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定符号
- en: A [symbol](#term-Symbol) in an expression is *bound* if it is not [free](#term-Free-symbols).
    A bound symbol can be replaced everywhere with new symbol and the resulting expression
    will still be mathematically equivalent. Examples of bound symbols are integration
    variables in definite integrals and substituted variables in a [`Subs`](../modules/core.html#sympy.core.function.Subs
    "sympy.core.function.Subs"). Bound symbols are sometimes represented by [dummy](#term-Dummy)
    symbols, but the are not always [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy") objects, and [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy") objects are not always bound symbols.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的一个[symbol](#term-Symbol)如果是*bound*，则表示它不是[free](#term-Free-symbols)。一个bound符号可以被新符号替换，得到的表达式仍然在数学上等价。例子包括定积分中的积分变量和[`Subs`](../modules/core.html#sympy.core.function.Subs
    "sympy.core.function.Subs")中的替换变量。有时用[dummy](#term-Dummy)符号表示bound符号，但它们不总是[`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy")对象，而[`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy")对象也不总是bound符号。
- en: Canonical Form
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 规范形式
- en: Canonicalize
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化
- en: Often expressions can be written in multiple, mathematically equivalent ways.
    A *canonical form* is a single way of writing an expression, which all equivalent
    expressions can be transformed to. An expression that is put into a canonical
    form is said to be *canonicalized*. Often canonical forms are unique and have
    properties that make them easier to work with. For example, a common canonical
    form used for rational functions is \(\frac{p}{q}\), where \(p\) and \(q\) are
    expanded polynomials with no common factors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式通常可以用多种数学等价的方式写出。*规范形式*是表达式的一种单一写法，所有等价的表达式都可以转换为这种形式。将表达式放入规范形式称为*规范化*。通常规范形式是唯一的，并具有使其更易于处理的属性。例如，有理函数的常见规范形式是\(\frac{p}{q}\)，其中\(p\)和\(q\)是无公因式的展开多项式。
- en: Code Generation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成
- en: '*Code generation* refers to the process of taking a SymPy expression and converting
    it into code for a language or library so that it can be evaluated numerically.
    SymPy supports code generation for [dozens of languages](../reference/public/codegeneration/index.html#codegen-module)
    and libraries including C, C++, Fortran, and NumPy.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码生成*指的是将SymPy表达式转换为特定语言或库的代码，以便进行数值评估的过程。SymPy支持[几十种语言](../reference/public/codegeneration/index.html#codegen-module)和库的代码生成，包括C、C++、Fortran和NumPy。'
- en: Core
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 核心
- en: The [*core*](../modules/core.html#core-module) is the submodule that contains
    the important functionality used by all SymPy objects. This includes the [Basic](#term-Basic)
    and [Expr](#term-Expr) base classes, classes like [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add"), [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    and [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow"),
    and the [assumptions](#term-Assumptions).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[*核心*](../modules/core.html#core-module)是包含所有SymPy对象使用的重要功能的子模块。这包括[Basic](#term-Basic)和[Expr](#term-Expr)基类，如[`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add")、[`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul")和[`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow")等类，以及[假设](#term-Assumptions)。'
- en: Dummy
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 哑元
- en: A *dummy* [symbol](#term-Symbol) is a symbol that is automatically unequal to
    any other dummy symbol other than itself, even if it has the same name. Dummy
    symbols are used when a function needs to return an expression with a new symbol,
    so that it cannot accidentally clash with a [symbol](#term-Symbol) of the same
    name. Dummy symbols can be created with [`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy").
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*dummy* [symbol](#term-Symbol)是一个符号，即使它与同名的其他dummy符号不相等，也会自动返回其自身。dummy符号用于当函数需要返回带有新符号的表达式时，以避免意外与同名的[symbol](#term-Symbol)冲突。可以使用[`Dummy`](../modules/core.html#sympy.core.symbol.Dummy
    "sympy.core.symbol.Dummy")创建dummy符号。'
- en: Equation
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 方程
- en: An *equation* is an [expression](#term-Expression) that has an equals sign \(=\).
    Equations in SymPy are represented using the [`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") class. Equations are **not** created using the
    `==` operator. The `==` operator does a [structural equality](#term-Structural-Equality)
    check between two expressions, and always returns `True` or `False`. To contrast,
    a symbolic equation may be [unevaluated](#term-Unevaluated). Equations are considered
    [booleans](#term-Boolean) since they mathematically represent a predicate value
    that is either true or false.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*方程*是具有等号 \(=\) 的[expression](#term-Expression)。在SymPy中，方程使用[`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")类表示。方程不是使用`==`运算符创建的。`==`运算符执行两个表达式之间的[结构相等性](#term-Structural-Equality)检查，并始终返回`True`或`False`。相比之下，符号方程可能是[unevaluated](#term-Unevaluated)的。方程被视为[booleans](#term-Boolean)，因为它们在数学上表示一个谓词值，即真或假。'
- en: '`_eval_*`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`_eval_*`'
- en: Various methods on [Basic](#term-Basic) and [Expr](#term-Expr) can be defined
    on subclasses using special *`_eval_*`* methods. For example, an object can define
    how it will be processed by the [`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff") function by defining a `_eval_derivative` method.
    `_eval_*` methods used are instead of overriding the method itself so that the
    method defined on the base class can do pre-processing before dispatching to the
    `_eval_*` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[Basic](#term-Basic)和[Expr](#term-Expr)上的各种方法可以通过特殊的*`_eval_*`*方法在子类中定义。例如，对象可以通过定义`_eval_derivative`方法来定义在[`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff")函数中如何处理它。使用的`_eval_*`方法是替代重写方法本身，以便在基类上定义的方法在调度到`_eval_*`方法之前进行预处理。'
- en: '`evalf`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`evalf`'
- en: '[*`evalf`*](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")
    is the method present on every [Expr](#term-Expr) object that evaluates it to
    a floating-point numerical value, or converts the constant parts of the expression
    to a numerical value if it contains [symbols](#term-Symbol). The [`.n()`](../modules/core.html#sympy.core.evalf.EvalfMixin.n
    "sympy.core.evalf.EvalfMixin.n") method and [`N()`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N") function are both shorthands for `evalf`. “evalf” stands
    for “evaluate floating-point”. `evalf` uses [mpmath](#term-mpmath) under the hood
    to evaluate expressions to arbitrary precision.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[*`evalf`*](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")是每个[Expr](#term-Expr)对象上的方法，用于将其评估为浮点数值，或者如果表达式包含[symbols](#term-Symbol)，则将表达式的常数部分转换为数值。[`.n()`](../modules/core.html#sympy.core.evalf.EvalfMixin.n
    "sympy.core.evalf.EvalfMixin.n")方法和[`N()`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N")函数都是`evalf`的简写。 “evalf”代表“evaluate floating-point”。 `evalf`在内部使用[mpmath](#term-mpmath)来对表达式进行任意精度评估。'
- en: Evaluate
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: '*Evaluate* can refer to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*评估*可以指：'
- en: The process of converting an [expression](#term-Expression) into a numerical
    value (see [evalf](#term-evalf)).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将[expression](#term-Expression)转换为数值的过程（见[evalf](#term-evalf))
- en: The process of [automatic simplification](#term-Automatic-Simplification) that
    occurs when creating an expression (see [Unevaluated](#term-Unevaluated)).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表达式时发生的[自动简化](#term-Automatic-Simplification)过程（参见[Unevaluated](#term-Unevaluated)）。
- en: The process of replacing one or more [symbols](#term-Symbol) in an expression
    with numeric values or with other expressions using [substitution](#term-Substitution).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表达式中的一个或多个[symbols](#term-Symbol)用数值或使用[substitution](#term-Substitution)替换的过程。
- en: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
- en: '*[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")*
    is the superclass of all algebraic SymPy expressions. It is itself a subclass
    of [Basic](#term-Basic). SymPy expressions that can be in an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add"), [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    or [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow") should
    be `Expr` subclasses. Not all SymPy classes are subclasses of `Expr`, for example,
    [Boolean](#term-Boolean) objects are [Basic](#term-Basic) but not `Expr`, because
    boolean expressions do not make mathematical sense in classes like [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") or [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul").'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")*是所有代数SymPy表达式的超类。它本身是[Basic](#term-Basic)的子类。可以在[`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add")、[`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul")或[`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow")中的SymPy表达式应该是`Expr`的子类。并非所有SymPy类都是`Expr`的子类，例如，[布尔](#term-Boolean)对象是[Basic](#term-Basic)，但不是`Expr`，因为布尔表达式在像[`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add")或[`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul")这样的类中没有数学意义。'
- en: Expression
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式
- en: Any SymPy object, that is, any instance of [Basic](#term-Basic), may be called
    an *expression*. Sometimes, the term “expression” is reserved for [Expr](#term-Expr)
    objects, which are algebraic expressions. Expressions are not to be confused with
    [equations](#term-Equation), which are a specific types of expressions that represents
    mathematical equalities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何SymPy对象，即任何[Basic](#term-Basic)的实例，都可以称为*表达式*。有时，“表达式”一词保留给[Expr](#term-Expr)对象，这些是代数表达式。表达式不应与[方程](#term-Equation)混淆，后者是表示数学等式的特定类型的表达式。
- en: Expression Tree
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表达树
- en: An *expression tree* is a [tree](https://en.wikipedia.org/wiki/Tree_(data_structure))
    of [expressions](#term-Expression). Every expression is built up from smaller
    expressions as a tree. The nodes of an expression tree are expressions and the
    children of each node are the direct [subexpressions](#term-Subexpression) that
    constitute that expression. Alternatively, one can view an expression tree as
    a tree where the non-leaf nodes are [funcs](#term-func) and the leaf nodes are
    [atoms](#term-Atom). An example expression tree is shown in the [tutorial](../tutorials/intro-tutorial/manipulation.html#tutorial-expression-trees).
    The expression tree of any SymPy expression can be obtained by recursing through
    [args](#term-args). Note that because SymPy expressions are [immutable](#term-Immutable)
    and are treated equal strictly by [structural equality](#term-Structural-Equality),
    one may also think of an expression tree as being a [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph),
    where identical subexpressions are only represented in the graph once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达树*是[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))的[表达式](#term-Expression)。每个表达式都是从较小的表达式构建而成的树。表达树的节点是表达式，每个节点的子节点是构成该表达式的直接[子表达式](#term-Subexpression)。或者，可以将表达树视为一棵树，其中非叶节点是[函数](#term-func)，叶节点是[原子](#term-Atom)。例如，[教程](../tutorials/intro-tutorial/manipulation.html#tutorial-expression-trees)中展示了一个表达式树的示例。通过递归遍历[args](#term-args)，可以获得任何SymPy表达式的表达树。请注意，由于SymPy表达式是[不可变](#term-Immutable)的，并且严格按照[结构相等性](#term-Structural-Equality)处理，因此也可以将表达树视为是[DAG](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%9C%AC%E4%BD%93%E7%9A%84%E7%9B%B8%E7%AD%89%E7%BB%93%E6%9E%84)，其中相同的子表达式在图中只表示一次。'
- en: Free symbols
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自由符号
- en: A [symbol](#term-Symbol) in an expression is *free* if the expression mathematically
    depends on the value of that symbol. That is, if the symbol were replaced with
    a new symbol, the result would be a different expression. Symbols that are not
    free are [bound](#term-Bound-symbols). The free symbols of an expression can be
    accessed with the [`free_symbols`](../modules/core.html#sympy.core.basic.Basic.free_symbols
    "sympy.core.basic.Basic.free_symbols") attribute.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的[符号](#term-Symbol)如果数学上依赖于该符号的值，则为*自由*。也就是说，如果该符号被替换为一个新符号，结果将是不同的表达式。不是自由的符号是[绑定](#term-Bound-symbols)的。可以通过[`free_symbols`](../modules/core.html#sympy.core.basic.Basic.free_symbols
    "sympy.core.basic.Basic.free_symbols")属性访问表达式的自由符号。
- en: '`func`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`'
- en: The *`func`* property is the function of an [expression](#term-Expression),
    which can be obtained by `expr.func`. This is usually the same as `type(expr)`,
    but may differ in some cases, so it should be preferred to use `expr.func` instead
    of `type(expr)` when rebuilding expressions with [args](#term-args). Every SymPy
    expression can be rebuilt exactly with `func` and `args`, that is, `expr.func(*expr.args)
    == expr` will always be true of any SymPy expression `expr`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*`func`*属性是[expression](#term-Expression)的函数，可以通过`expr.func`获取。这通常与`type(expr)`相同，但在某些情况下可能会有所不同，因此在重建具有[args](#term-args)的表达式时，应优先使用`expr.func`而不是`type(expr)`。每个SymPy表达式都可以使用`func`和`args`完全重建，即`expr.func(*expr.args)
    == expr`对于任何SymPy表达式`expr`都将始终为真。'
- en: Function
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: '*Function* may refer to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*可能指：'
- en: A mathematical function, that is, something which maps values from a domain
    to a range. Sometimes an [expression](#term-Expression) containing a [symbol](#term-Symbol)
    is colloquially called a “function” because the symbol can be replaced with a
    value using [substitution](#term-Substitution), [evaluating](#term-Evaluate) the
    expression. This usage is colloquial because one must use the [`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs") method to do this rather than the typical Python
    function calling syntax, and because it is not specific about what variable(s)
    the expression is a function of, so generally the term “expression” should be
    preferred unless something is an actual function. An expression can be converted
    into a function object that can be called using the Python `f(x)` syntax using
    [`Lambda`](../modules/core.html#sympy.core.function.Lambda "sympy.core.function.Lambda").
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学函数，即将域中的值映射到范围中的某些内容。有时，包含[symbol](#term-Symbol)的[expression](#term-Expression)在口语上称为“函数”，因为该符号可以使用[substitution](#term-Substitution)替换为值，从而[evaluating](#term-Evaluate)表达式。这种用法是口语化的，因为必须使用[`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs")方法来执行替换，而不是典型的Python函数调用语法，并且它不具体说明表达式是哪些变量的函数，因此通常应优先使用术语“expression”，除非某些内容确实是函数。可以使用[`Lambda`](../modules/core.html#sympy.core.function.Lambda
    "sympy.core.function.Lambda")将表达式转换为可以使用Python `f(x)`语法调用的函数对象。
- en: An instance of the SymPy [Function](#term-Function-class) class.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy [Function](#term-Function-class)类的一个实例。
- en: A Python function, i.e., a function defined using the `def` keyword. Python
    functions are not [symbolic](#term-Symbolic), since they must always return a
    value and thus cannot be [unevaluated](#term-Unevaluated).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 函数，即使用`def`关键字定义的函数。 Python 函数不是[symbolic](#term-Symbolic)，因为它们必须始终返回一个值，因此不能是[unevaluated](#term-Unevaluated)。
- en: '[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")
    (class)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")（类）'
- en: '*[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")*
    is the base class of symbolic functions in SymPy. This includes common functions
    like [`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin") and [`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp"), special functions like [`zeta()`](../modules/functions/special.html#sympy.functions.special.zeta_functions.zeta
    "sympy.functions.special.zeta_functions.zeta") and [`hyper()`](../modules/functions/special.html#sympy.functions.special.hyper.hyper
    "sympy.functions.special.hyper.hyper"), and integral functions like [`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi") and [`divisor_sigma()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma"). Function classes are always
    [symbolic](#term-Symbolic), meaning that they typically remain [unevaluated](#term-Unevaluated)
    when passed a [symbol](#term-Symbol), like `f(x)`. Not every symbolic [expression](#term-Expression)
    class is a `Function` subclass, for example, [core](#term-Core) classes like `Add`
    and `Mul` are not `Function` subclasses.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")*是SymPy中符号函数的基类。这包括常见函数如[`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin")和[`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp")，特殊函数如[`zeta()`](../modules/functions/special.html#sympy.functions.special.zeta_functions.zeta
    "sympy.functions.special.zeta_functions.zeta")和[`hyper()`](../modules/functions/special.html#sympy.functions.special.hyper.hyper
    "sympy.functions.special.hyper.hyper")，以及积分函数如[`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi")和[`divisor_sigma()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma
    "sympy.functions.combinatorial.numbers.divisor_sigma")。函数类总是[符号化](#term-Symbolic)，这意味着当传递一个[符号](#term-Symbol)，如`f(x)`时，它们通常保持[未评估状态](#term-Unevaluated)。并非所有符号[表达式](#term-Expression)类都是`Function`子类，例如，像`Add`和`Mul`这样的[核心](#term-Core)类不是`Function`子类。'
- en: '`Function` may also be used to create an [undefined function](#term-Undefined-Function)
    by passing it a string name for the function, like `Function(''f'')`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`也可以用于通过传递函数的字符串名称（如`Function(''f'')`）创建一个[未定义函数](#term-Undefined-Function)。'
- en: Not every function in SymPy is a symbolic `Function` class; some are just Python
    functions which always return a value. For example, most simplification functions
    like [simplify()](#term-Simplification) cannot be represented symbolically.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有SymPy中的函数都是符号`Function`类；有些只是始终返回值的Python函数。例如，大多数简化函数（如[simplify()](#term-Simplification)）无法以符号形式表示。
- en: Immutable
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Immutable
- en: In Python, objects are *immutable* if they can not be modified in-place. In
    order to change an immutable object, a new object must be created. In SymPy, all
    [Basic](#term-Basic) objects are immutable. This means that all functions that
    operate on [expressions](#term-Expression) will return a new expression and leave
    the original unchanged. Performing an operation on an expression will never change
    other objects or expressions that reference that expression. This also means that
    any two objects that are [equal](#term-Structural-Equality) are completely interchangeable
    and may be thought of as being the same object, even if they happen to be two
    different objects in memory. Immutability makes it easier to maintain a mental
    model of code, because there is no hidden state. SymPy objects being immutable
    also means that they are hashable, which allows them to be used as dictionary
    keys.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，如果对象无法原地修改，则称其为*不可变*。为了改变一个不可变对象，必须创建一个新的对象。在SymPy中，所有的[基础对象](#term-Basic)都是不可变的。这意味着所有操作[表达式](#term-Expression)的函数都会返回一个新的表达式，并且不会改变原始对象。对表达式进行操作不会改变引用该表达式的其他对象或表达式。这也意味着任何两个相等的对象完全可以互换，并且可以被视为同一个对象，即使它们在内存中是两个不同的对象。不可变性使得更容易维护代码的心智模型，因为没有隐藏状态。SymPy对象的不可变性也意味着它们是可哈希的，可以用作字典键。
- en: Interactive
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式
- en: '*Interactive* usage refers to using SymPy in an interactive REPL environment
    such as the Python prompt, [isympy](#term-isympy), [IPython](https://ipython.org/),
    or the [Jupyter notebook](https://jupyter.org/). When using SymPy interactively,
    all commands are typed in real time by the user and all intermediate results are
    shown. *Interactive* use is in contrast with *programmatic* use, which is where
    the code is written in a file which is either executed as a script or is part
    of a larger Python library. Some SymPy idioms are only recommended for interactive
    use and are considered anti-patterns when used programmatically. For example,
    running `from sympy import *` is convenient when using SymPy interactively, but
    is generally frowned upon for programmatic usage, where importing names explicitly
    just using `import sympy` is preferred.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*交互* 使用指的是在交互式 REPL 环境中使用 SymPy，例如 Python 提示符、[isympy](#term-isympy)、[IPython](https://ipython.org/)
    或 [Jupyter 笔记本](https://jupyter.org/)。在交互式使用 SymPy 时，所有命令由用户实时输入，并显示所有中间结果。*交互*
    使用与*程序化* 使用相对应，后者是指代码写入文件，然后作为脚本执行或作为较大 Python 库的一部分。一些 SymPy 习惯用法仅推荐在交互式使用时使用，当在程序化使用时被视为反模式。例如，在交互式使用
    SymPy 时运行 `from sympy import *` 是方便的，但在程序化使用时通常不建议，应优先显式导入名称 `import sympy`。'
- en: '`is_*`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_*`'
- en: 'Attributes in SymPy that start with *`is_`* and use a *lowercase* name query
    the given [assumption](#term-Assumptions) on that object (note: there are a few
    properties that are an exception to this because they do not use the assumptions
    system, see [the assumptions guide](../guides/assumptions.html#assumptions-guide-other-is-properties)).
    For example, `x.is_integer` will query the `integer` assumption on `x`. `is_*`
    attributes that use a *Capitalized* name test if an object is an instance of the
    given class. Sometimes the same name will exist for both the lowercase and Capitalized
    property, but they are different things. For example, `x.is_Integer` is only `True`
    if `x` is an instance of [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), whereas `x.is_integer` is `True` if `x` is `integer`
    in the assumptions system, such as `x = symbols(''x'', integer=True)`. In general,
    it is recommended to not use `is_Capitalized` properties. They exist for historical
    purposes, but they are unneeded because the same thing can be achieved with `isinstance()`.
    See also [Number](#term-Number).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中以 *`is_`* 开头并使用*小写*名称的属性查询对象的给定[假设](#term-Assumptions)（注意：有少数属性是例外，因为它们不使用假设系统，请参阅[假设指南](../guides/assumptions.html#assumptions-guide-other-is-properties)）。例如，`x.is_integer`
    将查询 `x` 的 `integer` 假设。使用*大写*名称的 `is_*` 属性测试对象是否是给定类的实例。有时相同名称将同时存在于小写和大写属性中，但它们代表不同的事物。例如，只有当
    `x` 是 [`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer")
    的实例时，`x.is_Integer` 才为 `True`，而 `x.is_integer` 只有在 `x` 是假设系统中的 `integer` 时才为 `True`，如
    `x = symbols('x', integer=True)`。一般建议不使用 `is_Capitalized` 属性。它们存在是为了历史目的，但是使用
    `isinstance()` 可以达到同样的效果。另请参阅[Number](#term-Number)。
- en: '`isympy`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`isympy`'
- en: '*`isympy`* is a command that ships with SymPy that starts an [interactive](#term-Interactive)
    session on the command line with all SymPy names imported and [printing](#term-Printing)
    enabled. It uses [IPython](https://ipython.org/) by default when it is installed.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*`isympy`* 是一个与 SymPy 一起提供的命令，它在命令行上启动一个[交互](#term-Interactive)会话，导入所有 SymPy
    名称并启用[打印](#term-Printing)功能。默认情况下，安装时使用 [IPython](https://ipython.org/)。'
- en: Kind
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类型
- en: The *kind* of a SymPy object represents what sort of mathematical object it
    represents. The kind of an object can be accessed with the `kind` attribute. Example
    kinds are [`NumberKind`](../modules/core.html#sympy.core.kind.NumberKind "sympy.core.kind.NumberKind"),
    which represents complex numbers, [`MatrixKind`](../modules/matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind"), which represents matrices of some other kind,
    and [`BooleanKind`](../modules/core.html#sympy.core.kind.BooleanKind "sympy.core.kind.BooleanKind"),
    which represents boolean predicates. The kind of a SymPy object is distinct from
    its Python type, since sometimes a single Python type may represent many different
    kinds of objects. For example, `Matrix` could be a matrix of complex numbers or
    a matrix of objects from some other ring of values. See [the classification of
    SymPy objects](special_topics/classification.html#kind-classification) page for
    more details about kinds in SymPy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 对象的*类型*表示其代表的数学对象的种类。对象的类型可以通过 `kind` 属性访问。例如，[`NumberKind`](../modules/core.html#sympy.core.kind.NumberKind
    "sympy.core.kind.NumberKind") 代表复数，[`MatrixKind`](../modules/matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind") 代表其他某种矩阵，以及 [`BooleanKind`](../modules/core.html#sympy.core.kind.BooleanKind
    "sympy.core.kind.BooleanKind") 代表布尔谓词。SymPy 对象的类型与其 Python 类型不同，因为有时一个单一的 Python
    类型可能代表许多不同种类的对象。例如，`Matrix` 可能是复数矩阵，也可能是某些其他值环中的对象矩阵。详见 SymPy 对象的分类页面[关于类型的分类](special_topics/classification.html#kind-classification)了解更多详情。
- en: lamda
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: lamda
- en: “*Lamda*” is just an alternate spelling of the Greek letter “lambda”. It is
    used sometimes in SymPy because `lambda` is a reserved keyword in Python, so a
    symbol representing λ must be named something else.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “*Lamda*” 只是希腊字母“lambda”的另一种拼写方式。在 SymPy 中有时会使用这个拼写，因为在 Python 中 `lambda` 是一个保留关键字，所以表示
    λ 的符号必须取别的名字。
- en: '[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")'
- en: '*[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")* is a function that converts a SymPy expression
    into a Python function that can be evaluated numerically, typically making use
    of a [numeric](#term-Numeric) library such as NumPy.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")* 是一个函数，将 SymPy 表达式转换为可以进行数值评估的 Python 函数，通常使用类似
    NumPy 的[数值](#term-Numeric)库。'
- en: Matrix
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵
- en: '*Matrix* refers to the set of classes used by SymPy to represent matrices.
    SymPy has several internal classes to represent matrices, depending on whether
    the matrix is symbolic ([`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr")) or explicit, mutable or immutable, dense
    or sparse, and what type the underlying elements are, but these are often all
    just called “Matrix”.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩阵* 是 SymPy 用于表示矩阵的一组类。SymPy 有几个内部类用于表示矩阵，取决于矩阵是否是符号化的（[`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr")）、显式的、可变的或不可变的、稠密的或稀疏的，以及底层元素的类型是什么，但通常统称为“矩阵”。'
- en: mpmath
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: mpmath
- en: '[*mpmath*](https://mpmath.org/) is a pure Python library for arbitrary precision
    numerics. It is a [hard dependency](../contributing/dependencies.html#dependencies-mpmath)
    of SymPy. mpmath is capable of computing [numerical](#term-Numeric) functions
    to any given number of digits. mpmath is used under the hood whenever SymPy evaluates
    an expression numerically, such as when using [evalf](#term-evalf).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[*mpmath*](https://mpmath.org/) 是一个纯 Python 库，用于任意精度数值计算。它是 SymPy 的一个[硬依赖](../contributing/dependencies.html#dependencies-mpmath)。mpmath
    能够计算[数值](#term-Numeric)函数至任意精度位数。每当 SymPy 对表达式进行数值评估时（例如使用 [evalf](#term-evalf)），mpmath
    就在幕后发挥作用。'
- en: Numeric
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数值
- en: A *numeric* representation or algorithm is one that operates directly on numeric
    inputs. It is in contrast with a *[symbolic](#term-Symbolic)* representation or
    algorithm, which can work with objects in an unevaluated form. Often a numerical
    algorithm is quite different from a symbolic one. For example, numerically solving
    an ODE typically means evaluating the ODE using an algorithm like [Runge–Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods)
    to find a set of numeric points given an initial condition, whereas symbolically
    solving an ODE (such as with SymPy’s [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve")) means mathematically manipulating the ODE to produce
    a [symbolic](#term-Symbolic) [equation](#term-Equation) that represents the solution.
    A symbolic ODE solution may including symbolic constants which can represent any
    numerical value. Numeric algorithms are typically designed around issues caused
    by floating-point numbers such as loss of precision and numerical stability, whereas
    symbolic algorithms are not concerned with these things because they compute things
    exactly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值* 表示或算法直接操作数值输入。它与 *[符号](#term-Symbolic)* 表示或算法相对，后者可以处理未求值形式的对象。通常数值算法与符号算法有很大不同。例如，数值求解常微分方程通常意味着使用像
    [Runge–Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) 这样的算法来在给定初始条件下找到一组数值点，而符号求解常微分方程（例如使用
    SymPy 的 [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")）意味着数学上操纵常微分方程以生成一个
    [符号](#term-Symbolic) [方程](#term-Equation)，该方程表示解。符号常微分方程的解可能包含符号常数，这些符号常数可以表示任何数值。数值算法通常围绕浮点数引起的问题设计，如精度损失和数值稳定性，而符号算法则不涉及这些问题，因为它们可以精确计算。'
- en: Most scientific libraries other than SymPy, such as NumPy or SciPy, are strictly
    numerical, meaning the functions in those libraries can only operate on specific
    numeric inputs. They will not work with SymPy expressions, because their algorithms
    are not designed to work with symbolic inputs. SymPy focuses on symbolic functions,
    leaving purely numerical code to other tools like NumPy. However, SymPy does interface
    with numerical libraries via tools like [code generation](#term-Code-Generation)
    and [lambdify()](#term-lambdify).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数科学库，如 NumPy 或 SciPy，严格是数值的，意味着这些库中的函数只能操作特定的数值输入。它们无法处理 SymPy 表达式，因为它们的算法不是设计用于符号输入。SymPy
    主要关注符号函数，将纯数值代码留给像 NumPy 这样的其他工具。然而，SymPy 通过工具如 [代码生成](#term-Code-Generation)
    和 [lambdify()](#term-lambdify) 与数值库进行接口。
- en: Number
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Number
- en: '*Number* can refer to two things in SymPy:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Number* 可以指 SymPy 中的两种东西：'
- en: The class [`Number`](../modules/core.html#sympy.core.numbers.Number "sympy.core.numbers.Number"),
    which is the base class for explicit numbers ([`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational"), and [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float")). Symbolic numeric constants like [`pi`](../modules/core.html#sympy.core.numbers.Pi
    "sympy.core.numbers.Pi") are not instances of `Number`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类 [`Number`](../modules/core.html#sympy.core.numbers.Number "sympy.core.numbers.Number")
    是显式数值（[`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer")、[`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") 和 [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float")）的基类。符号数值常量如 [`pi`](../modules/core.html#sympy.core.numbers.Pi
    "sympy.core.numbers.Pi") 不是 `Number` 的实例。
- en: Lowercase “*number*”, as in the `is_number` property, refers to any [expression](#term-Expression)
    that can be [evalfed](#term-evalf) into an explicit `Number`. This includes symbolic
    constants like [`pi`](../modules/core.html#sympy.core.numbers.Pi "sympy.core.numbers.Pi").
    Note that `is_number` is not part of the [assumptions](#term-Assumptions) system.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写的 "*number*"，例如 `is_number` 属性，指的是可以 [evalfed](#term-evalf) 成显式 `Number` 的任何
    [表达式](#term-Expression)。这包括像 [`pi`](../modules/core.html#sympy.core.numbers.Pi
    "sympy.core.numbers.Pi") 这样的符号常数。注意，`is_number` 不是 [假设](#term-Assumptions) 系统的一部分。
- en: This distinction is important for the `is_Number` and `is_number` properties.
    `x.is_Number` will check if `x` is an instance of the class [`Number`](../modules/core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `is_Number` 和 `is_number` 属性，这种区别非常重要。`x.is_Number` 将检查 `x` 是否是 [`Number`](../modules/core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number") 类的一个实例。
- en: '[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
- en: '*[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")*
    is the SymPy object representing positive infinity. It is spelled this way, as
    two lower case letter Os, because it resembles the symbol \(\infty\) and is easy
    to type. See also [zoo](#term-zoo).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`oo`](../modules/core.html#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")*是SymPy表示正无穷大的对象。它以这种方式拼写，作为两个小写字母O，因为它类似于符号\(\infty\)且易于输入。另见[zoo](#term-zoo)。'
- en: Polys
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Polys
- en: The *polys* refers to the [`sympy.polys`](../modules/polys/reference.html#module-sympy.polys
    "sympy.polys") submodule, which implements the basic data structures and algorithms
    for polynomial manipulation. The polys are a key part of SymPy (though not typically
    considered part of the [core](#term-Core)), because many basic symbolic manipulations
    can be represented as manipulations on polynomials. Many algorithms in SymPy make
    use of the polys under the hood. For example, [`factor()`](../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") is a wrapper around the polynomial factorization
    algorithms that are implemented in the polys. The classes in the polys are implemented
    using efficient data structures, and are not subclasses of [Basic](#term-Basic)
    like the other classes in SymPy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*polys*指的是[`sympy.polys`](../modules/polys/reference.html#module-sympy.polys
    "sympy.polys")子模块，它实现了多项式操作的基本数据结构和算法。polys是SymPy的关键部分（虽然通常不被认为是[核心](#term-Core)的一部分），因为许多基本的符号操作可以表示为对多项式的操作。SymPy中的许多算法在内部使用多项式。例如，[`factor()`](../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor")是对多项式因式分解算法的一种封装，这些算法在多项式中实现。polys中的类使用高效的数据结构实现，并且不像SymPy中的其他类一样，不是[Basic](#term-Basic)的子类。'
- en: Printing
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '*Printing* refers to the act of taking an [expression](#term-Expression) and
    converting it into a form that can be viewed on screen. Printing is also often
    used to refer to [code generation](#term-Code-Generation). SymPy has several printers
    which represent expressions using different formats. Some of the more common printers
    are the string printer (`str()`), the pretty printer ([`pprint()`](../modules/printing.html#sympy.printing.pretty.pretty.pretty_print
    "sympy.printing.pretty.pretty.pretty_print")) the LaTeX printer ([`latex()`](../modules/printing.html#sympy.printing.latex.latex
    "sympy.printing.latex.latex")), and code printers.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*打印*指的是将一个[表达式](#term-Expression)转换为可以在屏幕上查看的形式。打印通常也用于指代[代码生成](#term-Code-Generation)。SymPy有几个打印机，可以使用不同格式表示表达式。一些更常见的打印机是字符串打印机（`str()`），漂亮的打印机([`pprint()`](../modules/printing.html#sympy.printing.pretty.pretty.pretty_print
    "sympy.printing.pretty.pretty.pretty_print"))，LaTeX打印机([`latex()`](../modules/printing.html#sympy.printing.latex.latex
    "sympy.printing.latex.latex"))和代码打印机。'
- en: Relational
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关系
- en: A *relational* is an [expression](#term-Expression) that is a [symbolic](#term-Symbolic)
    [equality](#term-Equation) (like \(a=b\)), or a symbolic inequality like “less
    than” (\(a<b\)). Equality (\(=\)) and non-equality (\(\neq\)) relationals are
    created with [`Eq`](../modules/core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    and [`Ne`](../modules/core.html#sympy.core.relational.Unequality "sympy.core.relational.Unequality"),
    respectively. For example, `Eq(x, 0)` represents \(x=0\). These should be used
    instead of `==` or `!=`, as these are used for [structural](#term-Structural-Equality)
    rather than symbolic equality. Inequality relationals can be created directly
    using `<`, `<=`, `>`, and `>=`, like `x < 0`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系*是一个[表达式](#term-Expression)，它是[符号](#term-Symbolic) [等式](#term-Equation)（比如\(a=b\)），或者一个象征着“小于”（\(a<b\)）的符号不等式。等式（\(=\)）和不等式（\(\neq\)）的关系是用[`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")和[`Ne`](../modules/core.html#sympy.core.relational.Unequality
    "sympy.core.relational.Unequality")创建的。例如，`Eq(x, 0)`表示\(x=0\)。这些应该用于代替`==`或`!=`，因为这些用于[结构](#term-Structural-Equality)而不是象征性的相等。不等关系可以直接使用`<`，`<=`，`>`和`>=`来创建，比如`x
    < 0`。'
- en: '[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")'
- en: 'The *[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")*
    object in SymPy has two purposes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的*[`S`](../modules/core.html#sympy.core.singleton.Singleton "sympy.core.singleton.Singleton")*对象有两个用途：
- en: It holds all singleton classes as attributes. Some special classes in SymPy
    are singletonized, meaning that there is always exactly one instance of them.
    This is an optimization that allows saving memory. For instance, there is only
    ever one instance of `Integer(0)`, which is available as `S.Zero`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将所有单例类作为属性保存。SymPy 中的一些特殊类被设计为单例化，意味着它们始终只有一个实例。这是一种优化方法，可以节省内存。例如，`Integer(0)`
    只有一个实例，可以通过 `S.Zero` 获取。
- en: It serves as a shorthand for [sympify()](#term-sympify), that is `S(a)` is the
    same as `sympify(a)`. This is useful for converting integers to SymPy Integers
    in expressions to avoid dividing Python ints (see [the gotchas section of the
    tutorial](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当 [sympify()](#term-sympify) 的缩写，即 `S(a)` 等同于 `sympify(a)`。这在将整数转换为 SymPy
    整数以避免在表达式中使用 Python 整数进行除法时非常有用（参见 [教程的注意事项部分](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)）。
- en: Simplification
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简化
- en: '*Simplification* (not to be confused with [sympify](#term-sympify)) refers
    to the process of taking an [expression](#term-Expression) and transforming it
    into another expression that is mathematically equivalent but which is somehow
    “simpler”. The adjective “simple” is actually not very well-defined. What counts
    as simpler depends on the specific use-case and personal aesthetics.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*简化*（不要与 [sympify](#term-sympify) 混淆）指的是将一个 [表达式](#term-Expression) 转换为另一个在数学上等价但在某种意义上“更简单”的表达式的过程。“简单”的形容词实际上并不十分明确。什么算简单取决于具体的用例和个人审美观。'
- en: The SymPy function [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") heuristically tries various simplification
    algorithms to try to find a “simpler” form of an expression. If you aren’t particular
    about what you want from “simplify”, it may be a good fit. But if you have an
    idea about what sort of simplification you want to apply, it is generally better
    to use one or more of targeted [simplification functions](../modules/simplify/simplify.html#simplify-docs)
    which apply very specific mathematical manipulations to an expression.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 函数 [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") 根据启发式方法尝试各种简化算法，以找到表达式的“更简单”形式。如果你对“简化”想要什么并不是特别确定，它可能是一个不错的选择。但如果你对想要应用的简化有一个具体的想法，通常最好使用一个或多个目标化的
    [简化函数](../modules/simplify/simplify.html#simplify-docs)，这些函数对表达式应用非常具体的数学操作。
- en: Solve
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决
- en: Solvers
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器
- en: To *solve* an [equation](#term-Equation) or system of equations means to find
    a set of [expressions](#term-Expression) that make the equation(s) true when the
    given [symbol(s)](#term-Symbol) are [substituted](#term-Substitution) with them.
    For example, the solution to the equation \(x^2 = 1\) with respect to \(x\) would
    be the set \(\{-1, 1\}\). Different types of equations can be solved by SymPy
    using different [*solvers*](../guides/solving/index.html#solving-guide) functions.
    For instance, algebraic equations can be solved with [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"), differential equations can be solved with [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *解* 一个 [方程](#term-Equation) 或方程组意味着找到一组 [表达式](#term-Expression)，当给定的 [符号](#term-Symbol)
    被它们替换时，方程（们）为真。例如，对于方程 \(x^2 = 1\) 关于 \(x\) 的解是集合 \(\{-1, 1\}\)。SymPy 可以使用不同的
    [*求解器*](../guides/solving/index.html#solving-guide) 函数来解决不同类型的方程。例如，代数方程可以用 [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 解决，微分方程可以用 [`dsolve()`](../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") 解决，等等。
- en: SymPy generally uses the word “solve” and “solvers” to mean equation solving
    in this sense. It is not used in the sense of “solving a problem”. For instance,
    one would generally prefer to say “compute an integral” or “evaluate an integral”
    rather than “solve an integral” to refer to symbolic integration using the function
    [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 通常使用“solve”和“solvers”来表示这种意义上的方程求解。它不用于“解决问题”的意义。例如，通常会更倾向于说“计算一个积分”或“评估一个积分”，而不是“解决一个积分”，来表示使用函数
    [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") 进行符号积分。
- en: Structural Equality
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结构相等性
- en: Two SymPy objects are *structurally equal* if they are equal as [expressions](#term-Expression),
    that is, they have the same [expression trees](#term-Expression-Tree). Two structurally
    equal expressions are considered to be identical by SymPy, since all SymPy expressions
    are [immutable](#term-Immutable). Structural equality can be checked with the
    `==` operator, which always returns `True` or `False`. Symbolic [equality](#term-Equation)
    can be represented using [`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 两个SymPy对象如果作为[表达式](#term-Expression)相等，则它们被认为是*结构相等*的，即它们具有相同的[表达式树](#term-Expression-Tree)。在SymPy中，两个结构相等的表达式被认为是相同的，因为所有SymPy表达式都是[不可变](#term-Immutable)的。结构相等可以通过`==`操作符来检查，它总是返回`True`或`False`。符号[等式](#term-Equation)可以用[`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")来表示。
- en: Typically, two expressions are structurally equal if they are the same class
    and (recursively) have the same [args](#term-args). Two expressions may be mathematically
    identical but not structurally equal. For example, `(x + 1)**2` and `x**2 + 2*x
    + 1` are mathematically equal, but they are not structurally equal, because the
    first is a [`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow")
    whose [args](#term-args) consist of an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") and an [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), and the second is an [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") whose [args](#term-args) consist of a [`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow"), a [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    and an [`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer").
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果两个表达式是相同的类，并且（递归地）具有相同的[args](#term-args)，那么它们就是结构相等的。两个表达式可能在数学上是相同的，但在结构上不相等。例如，`(x
    + 1)**2` 和 `x**2 + 2*x + 1` 在数学上是相等的，但它们在结构上不相等，因为前者是一个 [`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow")，其[args](#term-args)包括一个[`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") 和一个[`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer")，而后者是一个[`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add")，其[args](#term-args)包括一个[`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow")，一个[`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul")
    和一个[`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer")。
- en: Two apparently different expressions may be structurally equal if they are [canonicalized](#term-Canonicalize)
    to the same thing by [automatic simplification](#term-Automatic-Simplification).
    For example, `x + y` and `y + x` are structurally equal because the [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") constructor automatically sorts its arguments, making them
    both the same.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表面上不同的表达式，如果它们经过[规范化](#term-Canonicalize)后变成相同的形式，那么它们就是结构相等的。例如，`x + y` 和
    `y + x` 结构上是相等的，因为[`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add")
    构造器会自动排序其参数，使它们变成相同的形式。
- en: Subexpression
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 子表达式
- en: A *subexpression* is an [expression](#term-Expression) that is contained within
    a larger expression. A subexpression appears somewhere in the [expression tree](#term-Expression-Tree).
    For `Add` and `Mul` terms, commutative and associative laws may be taken into
    account when determining what is a subexpression. For instance, `x + y` may sometimes
    be considered a subexpression of `x + y + z`, even though the expression tree
    for `Add(x, y)` is not a direct child of the expression tree for `Add(x, y, z)`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*子表达式* 是一个包含在较大表达式中的[表达式](#term-Expression)。子表达式出现在[表达式树](#term-Expression-Tree)的某处。对于`Add`和`Mul`项，当确定什么是子表达式时，可以考虑交换律和结合律。例如，`x
    + y` 有时可能被认为是 `x + y + z` 的子表达式，即使`Add(x, y)`的表达式树不是`Add(x, y, z)`的直接子节点。'
- en: Substitution
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 替换
- en: '*Substitution* refers to the act of replacing a [symbol](#term-Symbol) or [subexpression](#term-Subexpression)
    inside of an [expression](#term-Expression) with another expression. There are
    different methods in SymPy for performing substitution, including [`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs"), [`replace`](../modules/core.html#sympy.core.basic.Basic.replace
    "sympy.core.basic.Basic.replace"), and [`xreplace`](../modules/core.html#sympy.core.basic.Basic.xreplace
    "sympy.core.basic.Basic.xreplace"). The methods may differ depending on whether
    they perform substitution using only strict [structural equality](#term-Structural-Equality)
    or by making use of mathematical knowledge when determining where a subexpression
    appears in an expression. Substitution is the standard way to treat an expression
    as a mathematical [function](#term-Function) and evaluate it at a point.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换*是指用另一个表达式替换[expression](#term-Expression)内部的[symbol](#term-Symbol)或[subexpression](#term-Subexpression)的行为。在SymPy中有不同的方法执行替换，包括[`subs`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs")、[`replace`](../modules/core.html#sympy.core.basic.Basic.replace
    "sympy.core.basic.Basic.replace")和[`xreplace`](../modules/core.html#sympy.core.basic.Basic.xreplace
    "sympy.core.basic.Basic.xreplace")。这些方法可能因是否只使用严格的[structural equality](#term-Structural-Equality)或在确定子表达式在表达式中出现的位置时利用数学知识而有所不同。替换是将表达式视为数学[function](#term-Function)并在某点评估的标准方法。'
- en: Symbolic
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 符号
- en: A *symbolic* representation of a mathematical object is a representation that
    is partially or completely unevaluated at runtime. It may include named [symbolic
    constants](#term-Symbol) in place of explicit numeric values. A symbolic representation
    is often contrasted with a [numeric](#term-Numeric) one. Symbolic representations
    are mathematically exact, to contrast with numeric representations which are typically
    rounded so they can fit within a floating-point value. Symbolic [expressions](#term-Expression)
    representing mathematical objects may be aware of mathematical properties of these
    objects and be able to [simplify](#term-Simplification) to equivalent symbolic
    expressions using those properties. The goal of SymPy is to represent and manipulate
    symbolic expressions representing various mathematical objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号*表示一个数学对象的表示，在运行时部分或完全未评估。它可能包括以命名的[symbolic constants](#term-Symbol)代替显式数值。符号表示通常与[numeric](#term-Numeric)表示形成对比。符号表达是数学上精确的，与通常舍入以适应浮点值的数值表示相对。符号表示数学对象的表达可能意识到这些对象的数学属性，并能够利用这些属性简化为等效的符号表达式。SymPy的目标是表示和操作代表各种数学对象的符号表达式。'
- en: Some sources use the phrases “analytic solution” or “closed-form” to refer to
    the concept of “symbolic”, but this terminology is not used in SymPy. If used
    in SymPy, “analytic” would refer to the property of being [an analytic function](https://en.wikipedia.org/wiki/Analytic_function),
    and in SymPy [solve](#term-Solve) refers only to a certain type of symbolic operation.
    “Closed-form” in SymPy would typically refer to the mathematical sense of the
    term, whereas “symbolic” would generally refer to the implementation detail of
    how a mathematical concept is implemented, and be in contrast with a [numeric](#term-Numeric)
    implementation of the same mathematical concept.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些来源使用术语“分析解”或“闭合形式”来指代“符号”的概念，但这种术语在SymPy中不使用。如果在SymPy中使用，“分析”将指代[解析函数](https://en.wikipedia.org/wiki/Analytic_function)的特性，在SymPy中[solve](#term-Solve)仅指特定类型的符号操作。“闭合形式”在SymPy中通常指数学上的意义，而“符号”通常指的是数学概念如何实现的实现细节，并与相同数学概念的[numeric](#term-Numeric)实现形成对比。
- en: '[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")'
- en: '*[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")*
    is the class for symbol objects. A symbol represents a single mathematical variable
    in an expression. The [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") class is a subclass of [Expr](#term-Expr) and is [atomic](#term-Atom).
    A `Symbol` contains a name, which is any string, and [assumptions](#term-Assumptions).
    Symbols are typically defined with the `Symbol` constructor or the [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols") function. Two Symbols with the same name and assumptions
    are considered [equal](#term-Structural-Equality). Symbols are implicitly assumed
    to be independent or constant with respect to one another. Constants, variables,
    and parameters are all represented by Symbols. The distinction is generally made
    in the way the Symbols are used in a given SymPy function.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")*是符号对象的类。符号代表表达式中的单个数学变量。[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol")类是[Expr](#term-Expr)的子类，是[atomic](#term-Atom)的。一个`Symbol`包含一个名称，可以是任何字符串，以及[assumptions](#term-Assumptions)。符号通常使用`Symbol`构造函数或[`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols")函数定义。具有相同名称和假设的两个Symbols被认为是[equal](#term-Structural-Equality)的。Symbols通常被隐式地假设是彼此独立或常数。常量、变量和参数都由Symbols表示。在给定的SymPy函数中，通常通过Symbols的使用方式来区分它们。'
- en: '[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")'
- en: '*[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")*
    (not to be confused with *[simplify()](#term-Simplification)*) is a function that
    converts non-SymPy objects into SymPy objects. The result of `sympify()` will
    be an instance of [Basic](#term-Basic). Objects that can be *sympified* include
    native Python numeric types such as `int` and `float`, strings that are parsable
    as SymPy [expressions](#term-Expression), and iterables containing *sympifiable*
    objects (see the documentation for [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") for more information).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")*（不要与*[simplify()](#term-Simplification)*混淆）是将非SymPy对象转换为SymPy对象的函数。`sympify()`的结果将是[Basic](#term-Basic)的一个实例。可以被*sympified*的对象包括本地Python数值类型如`int`和`float`，可以解析为SymPy表达式的字符串以及包含*sympifiable*对象的可迭代对象（详见[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")的文档了解更多信息）。'
- en: Since all SymPy [expressions](#term-Expression) must be instances of [Basic](#term-Basic),
    all SymPy functions and operations will implicitly call `sympify()` on their inputs.
    For example, `x + 1` implicitly calls `sympify(1)` to convert the `1` that is
    a Python `int` into a SymPy [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"). Functions that accept SymPy expressions should
    typically call `sympify()` on their arguments so that they work even when the
    input is not a SymPy type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有SymPy表达式必须是[Basic](#term-Basic)的实例，所有SymPy函数和操作在其输入上会隐式调用`sympify()`。例如，`x
    + 1`会隐式调用`sympify(1)`将Python `int`类型的`1`转换为SymPy的[`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer")。接受SymPy表达式的函数通常应该在其参数上调用`sympify()`，以确保它们在输入不是SymPy类型时也能正常工作。
- en: Three-valued logic
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 三值逻辑
- en: '*Three-valued logic* is a logic with three values, `True`, `False`, and `None`.
    It is also sometimes called *fuzzy logic*, although this term also has different
    meanings in the mathematical literature, so “three-valued logic” is preferred.
    `True` and `False` work the same as in the usual two-valued predicate logic. `None`
    is an additional term that represents “unknown”, “noncomputable”, or “could be
    either True or False” (philosophically these are distinct concepts, but logically
    they all function identically). The semantics of `None` are that it absorbs other
    terms in logical operations whenever the result would differ if it were replaced
    with `True` or `False`. For example, `None OR False` is `None`, but `None OR True`
    is `True` because the predicate is `True` whether the `None` “really” represents
    a value of `True` or `False`. One must be careful when using the usual Python
    logical operators like `and`, `or` and `not` on three-valued logic, since `None`
    is false. See [the guide for symbolic and fuzzy booleans](../guides/booleans.html#booleans-guide)
    for more details on how to code with three-valued logic.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*三值逻辑*是一种具有三个值 `True`、`False` 和 `None` 的逻辑。有时它也被称为*模糊逻辑*，尽管在数学文献中这个术语也有不同的含义，因此“三值逻辑”更受推荐。`True`
    和 `False` 的作用与通常的二值谓词逻辑相同。`None` 是一个额外的术语，表示“未知”、“不可计算”或“可以是 True 或 False”（从哲学上讲这些是不同的概念，但逻辑上它们完全相同）。`None`
    的语义是在逻辑操作中吸收其他术语，每当如果将其替换为 `True` 或 `False` 结果将会不同时。例如，`None OR False` 是 `None`，但
    `None OR True` 是 `True`，因为谓词是 `True`，无论 `None` “实际上”代表 `True` 还是 `False`。在使用通常的
    Python 逻辑运算符如 `and`、`or` 和 `not` 时，必须小心处理三值逻辑，因为 `None` 为假。有关如何使用三值逻辑编码的更多详细信息，请参阅[符号和模糊布尔值指南](../guides/booleans.html#booleans-guide)。'
- en: Three-valued logic is used by the [assumptions](#term-Assumptions) system to
    represent assumptions that are not known. For instance, `x.is_positive` might
    be `None` if `x` could be positive or negative under its given assumptions. Note
    that the predicate logic defined by [Boolean](#term-Boolean) subclasses represents
    a standard two-valued logic, not three-valued logic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[假设](#term-Assumptions)系统使用三值逻辑表示未知的假设。例如，如果在给定的假设下 `x.is_positive` 可能是 `None`，因为
    `x` 可以是正数或负数。请注意，由[布尔](#term-Boolean)子类定义的谓词逻辑表示标准的二值逻辑，而不是三值逻辑。'
- en: Undefined Function
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义函数
- en: An *undefined function* is a [Function](#term-Function-class) that has no mathematical
    properties defined on it. It always remains [unevaluated](#term-Unevaluated),
    like `f(x)`. An undefined function can be created by passing a string name of
    the function to `Function`, like `f = Function('f')`. Undefined functions are
    commonly used when working with [ODEs](../modules/solvers/ode.html#ode-docs).
    Undefined functions are also the easiest way to make [symbols](#term-Symbol) that
    mathematically depend on other symbols. For example, if `f = Function('f')` and
    `x = Symbol('x')`, then SymPy will know that `f(x)` depends on `x`, meaning, for
    instance, that the derivative `diff(f(x), x)` will not be evaluated to `0`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*未定义函数*是[函数](#term-Function-class)的一种，在其上没有定义数学属性。它始终保持[未评估](#term-Unevaluated)，例如
    `f(x)`。通过将函数的字符串名称传递给 `Function`，例如 `f = Function(''f'')`，可以创建未定义函数。在处理[ODEs](../modules/solvers/ode.html#ode-docs)时，通常使用未定义函数。未定义函数还是制造[符号](#term-Symbol)的最简单方法，这些符号在数学上依赖于其他符号。例如，如果
    `f = Function(''f'')` 和 `x = Symbol(''x'')`，那么 SymPy 将知道 `f(x)` 取决于 `x`，这意味着例如导数
    `diff(f(x), x)` 不会被评估为 `0`。'
- en: Unevaluated
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 未评估
- en: An expression is *unevaluated* if the [automatic simplification](#term-Automatic-Simplification)
    that typically occurs when the expression is created is disabled. This is typically
    done by setting `evaluate=False`, using `with evaluate(False)`, or using [`UnevaluatedExpr`](../modules/core.html#sympy.core.expr.UnevaluatedExpr
    "sympy.core.expr.UnevaluatedExpr"). While unevaluated expressions are supported,
    they can sometimes lead to surprising behavior because the expressions are not
    properly [canonicalized](#term-Canonicalize).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[自动化简](#term-Automatic-Simplification)在创建表达式时被禁用，则表达式是*未评估*的。通常通过设置 `evaluate=False`，使用
    `with evaluate(False)` 或使用 [`UnevaluatedExpr`](../modules/core.html#sympy.core.expr.UnevaluatedExpr
    "sympy.core.expr.UnevaluatedExpr") 来完成这一点。虽然支持未评估表达式，但有时会导致意外行为，因为表达式未正确[规范化](#term-Canonicalize)。
- en: The term *unevaluated* is also sometimes used to denote the fact that an expression
    does not [evaluate](#term-Evaluate) to a specific value when its arguments are
    [symbolic](#term-Symbolic).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*未评估*有时也用来表示当其参数是[符号的](#term-Symbolic)时，表达式不会[评估](#term-Evaluate)为特定值。
- en: '[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")'
- en: '*[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")*
    represents [complex infinity](https://mathworld.wolfram.com/ComplexInfinity.html),
    i.e., the north pole of the [Riemann sphere](https://en.wikipedia.org/wiki/Riemann_sphere).
    The reason it is spelled this way is that it is “z-oo”, where “z” is the symbol
    commonly used for complex variables, and [oo](#term-oo) is the symbol SymPy uses
    for real positive infinity.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*[`zoo`](../modules/core.html#sympy.core.numbers.ComplexInfinity "sympy.core.numbers.ComplexInfinity")*
    代表[复无穷](https://mathworld.wolfram.com/ComplexInfinity.html)，即[Riemann 球面](https://en.wikipedia.org/wiki/Riemann_sphere)的北极。它这样拼写的原因是，“z-oo”，其中“z”通常用于复变量的符号，而[oo](#term-oo)则是
    SymPy 用于正无穷的符号。'
