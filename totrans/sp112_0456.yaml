- en: scipy.optimize.ridder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.ridder.html#scipy.optimize.ridder](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.ridder.html#scipy.optimize.ridder)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of a function in an interval using Ridder’s method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f**function'
  prefs: []
  type: TYPE_NORMAL
- en: Python function returning a number. f must be continuous, and f(a) and f(b)
    must have opposite signs.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**scalar'
  prefs: []
  type: TYPE_NORMAL
- en: One end of the bracketing interval [a,b].
  prefs: []
  type: TYPE_NORMAL
- en: '**b**scalar'
  prefs: []
  type: TYPE_NORMAL
- en: The other end of the bracketing interval [a,b].
  prefs: []
  type: TYPE_NORMAL
- en: '**xtol**number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root. The parameter must be positive.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol**number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root. The parameter cannot be smaller than its default
    value of `4*np.finfo(float).eps`.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If convergence is not achieved in *maxiter* iterations, an error is raised.
    Must be >= 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Containing extra arguments for the function *f*. *f* is called by `apply(f,
    (x)+args)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *full_output* is False, the root is returned. If *full_output* is True, the
    return value is `(x, r)`, where *x* is the root, and *r* is a [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, raise RuntimeError if the algorithm didn’t converge. Otherwise, the
    convergence status is recorded in any [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") return object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**root**float'
  prefs: []
  type: TYPE_NORMAL
- en: Root of *f* between *a* and *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") (present if `full_output = True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Object containing information about the convergence. In particular, `r.converged`
    is True if the routine converged.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`brentq`](scipy.optimize.brentq.html#scipy.optimize.brentq "scipy.optimize.brentq"),
    [`brenth`](scipy.optimize.brenth.html#scipy.optimize.brenth "scipy.optimize.brenth"),
    [`bisect`](scipy.optimize.bisect.html#scipy.optimize.bisect "scipy.optimize.bisect"),
    [`newton`](scipy.optimize.newton.html#scipy.optimize.newton "scipy.optimize.newton")'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D root-finding
  prefs: []
  type: TYPE_NORMAL
- en: '[`fixed_point`](scipy.optimize.fixed_point.html#scipy.optimize.fixed_point
    "scipy.optimize.fixed_point")'
  prefs: []
  type: TYPE_NORMAL
- en: scalar fixed-point finder
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Uses [[Ridders1979]](#rb24f4e0f7574-ridders1979) method to find a root of the
    function *f* between the arguments *a* and *b*. Ridders’ method is faster than
    bisection, but not generally as fast as the Brent routines. [[Ridders1979]](#rb24f4e0f7574-ridders1979)
    provides the classic description and source of the algorithm. A description can
    also be found in any recent edition of Numerical Recipes.
  prefs: []
  type: TYPE_NORMAL
- en: The routine used here diverges slightly from standard presentations in order
    to be a bit more careful of tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[Ridders1979] ([1](#id1),[2](#id2))'
  prefs: []
  type: TYPE_NORMAL
- en: Ridders, C. F. J. “A New Algorithm for Computing a Single Root of a Real Continuous
    Function.” IEEE Trans. Circuits Systems 26, 979-980, 1979.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
