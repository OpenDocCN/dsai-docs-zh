- en: UFunc API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/ufunc.html](https://numpy.org/doc/1.26/reference/c-api/ufunc.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Constants'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFUNC_ERR_{HANDLER}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`UFUNC_{THING}_{ERR}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`PyUFunc_{VALUE}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Used in universal function code to only release the Python GIL if loop->obj
    is not true (*i.e.* this is not an OBJECT array loop). Requires use of [`NPY_BEGIN_THREADS_DEF`](array.html#c.NPY_BEGIN_THREADS_DEF
    "NPY_BEGIN_THREADS_DEF") in variable declaration area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Used in universal function code to re-acquire the Python GIL if it was released
    (because loop->obj was not true).
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointers to functions that actually implement the underlying (element-by-element)
    function \(N\) times with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*args*'
  prefs: []
  type: TYPE_NORMAL
- en: An array of pointers to the actual data for the input and output arrays. The
    input arguments are given first followed by the output arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*dimensions*'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the size of the dimension over which this function is looping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*steps*'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the number of bytes to jump to get to the next element in this
    dimension for each of the input and output arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*data*'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary data (extra arguments, function names, *etc.* ) that can be stored
    with the ufunc and will be passed in when it is called. May be `NULL`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Changed in version 1.23.0: Accepts `NULL` *data* in addition to array of `NULL`
    values.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is an example of a func specialized for addition of doubles returning doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Create a new broadcasting universal function from required variables. Each ufunc
    builds around the notion of an element-by-element operation. Each ufunc object
    contains pointers to 1-d loops implementing the basic functionality for each supported
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The *func*, *data*, *types*, *name*, and *doc* arguments are not copied by [`PyUFunc_FromFuncAndData`](#c.PyUFunc_FromFuncAndData
    "PyUFunc_FromFuncAndData"). The caller must ensure that the memory used by these
    arrays is not freed as long as the ufunc object is alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func** – Must point to an array containing *ntypes* [`PyUFuncGenericFunction`](#c.PyUFuncGenericFunction
    "PyUFuncGenericFunction") elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**data** – Should be `NULL` or a pointer to an array of size *ntypes*. This
    array may contain arbitrary extra-data to be passed to the corresponding loop
    function in the func array, including `NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**types** –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length `(nin + nout) * ntypes` array of `char` encoding the [`numpy.dtype.num`](../generated/numpy.dtype.num.html#numpy.dtype.num
    "numpy.dtype.num") (built-in only) that the corresponding function in the `func`
    array accepts. For instance, for a comparison ufunc with three `ntypes`, two `nin`
    and one `nout`, where the first function accepts [`numpy.int32`](../arrays.scalars.html#numpy.int32
    "numpy.int32") and the second [`numpy.int64`](../arrays.scalars.html#numpy.int64
    "numpy.int64"), with both returning [`numpy.bool_`](../arrays.scalars.html#numpy.bool_
    "numpy.bool_"), `types` would be `(char[]) {5, 5, 0, 7, 7, 0}` since `NPY_INT32`
    is 5, `NPY_INT64` is 7, and `NPY_BOOL` is 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The bit-width names can also be used (e.g. [`NPY_INT32`](dtype.html#c.NPY_TYPES.NPY_INT32
    "NPY_INT32"), [`NPY_COMPLEX128`](dtype.html#c.NPY_TYPES.NPY_COMPLEX128 "NPY_COMPLEX128")
    ) if desired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Type casting rules](../../user/basics.ufuncs.html#ufuncs-casting) will be
    used at runtime to find the first `func` callable by the input/output provided.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ntypes** – How many different data-type-specific functions the ufunc has
    implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nin** – The number of inputs to this operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nout** – The number of outputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**identity** – Either [`PyUFunc_One`](#c.PyUFunc_One "PyUFunc_One"), [`PyUFunc_Zero`](#c.PyUFunc_Zero
    "PyUFunc_Zero"), [`PyUFunc_MinusOne`](#c.PyUFunc_MinusOne "PyUFunc_MinusOne"),
    or [`PyUFunc_None`](#c.PyUFunc_None "PyUFunc_None"). This specifies what should
    be returned when an empty array is passed to the reduce method of the ufunc. The
    special value [`PyUFunc_IdentityValue`](#c.PyUFunc_IdentityValue "PyUFunc_IdentityValue")
    may only be used with the [`PyUFunc_FromFuncAndDataAndSignatureAndIdentity`](#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity
    "PyUFunc_FromFuncAndDataAndSignatureAndIdentity") method, to allow an arbitrary
    python object to be used as the identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name** – The name for the ufunc as a `NULL` terminated string. Specifying
    a name of ‘add’ or ‘multiply’ enables a special behavior for integer-typed reductions
    when no dtype is given. If the input type is an integer (or boolean) data type
    smaller than the size of the [`numpy.int_`](../arrays.scalars.html#numpy.int_
    "numpy.int_") data type, it will be internally upcast to the [`numpy.int_`](../arrays.scalars.html#numpy.int_
    "numpy.int_") (or [`numpy.uint`](../arrays.scalars.html#numpy.uint "numpy.uint"))
    data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**doc** – Allows passing in a documentation string to be stored with the ufunc.
    The documentation string should not contain the name of the function or the calling
    signature as that will be dynamically determined from the object and available
    when accessing the **__doc__** attribute of the ufunc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unused** – Unused and present for backwards compatibility of the C-API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function is very similar to PyUFunc_FromFuncAndData above, but has an extra
    *signature* argument, to define a [generalized universal functions](generalized-ufuncs.html#c-api-generalized-ufuncs).
    Similarly to how ufuncs are built around an element-by-element operation, gufuncs
    are around subarray-by-subarray operations, the [signature](generalized-ufuncs.html#details-of-signature)
    defining the subarrays to operate on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**signature** – The signature for the new gufunc. Setting it to NULL is equivalent
    to calling PyUFunc_FromFuncAndData. A copy of the string is made, so the passed
    in buffer can be freed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This function is very similar to *PyUFunc_FromFuncAndDataAndSignature* above,
    but has an extra *identity_value* argument, to define an arbitrary identity for
    the ufunc when `identity` is passed as `PyUFunc_IdentityValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**identity_value** – The identity for the new gufunc. Must be passed as `NULL`
    unless the `identity` argument is `PyUFunc_IdentityValue`. Setting it to NULL
    is equivalent to calling PyUFunc_FromFuncAndDataAndSignature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function allows the user to register a 1-d loop with an already- created
    ufunc to be used whenever the ufunc is called with any of its input arguments
    as the user-defined data-type. This is needed in order to make ufuncs work with
    built-in data-types. The data-type must have been previously registered with the
    numpy system. The loop is passed in as *function*. This loop can take arbitrary
    data which should be passed in as *data*. The data-types the loop requires are
    passed in as *arg_types* which must be a pointer to memory at least as large as
    ufunc->nargs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function behaves like PyUFunc_RegisterLoopForType above, except that it
    allows the user to register a 1-d loop using PyArray_Descr objects instead of
    dtype type num values. This allows a 1-d loop to be registered for structured
    array data-dtypes and custom data-types instead of scalar data-types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Replace a 1-d loop matching the given *signature* in the already-created *ufunc*
    with the new 1-d loop newfunc. Return the old 1-d loop function in *oldfunc*.
    Return 0 on success and -1 on failure. This function works only with built-in
    types (use [`PyUFunc_RegisterLoopForType`](#c.PyUFunc_RegisterLoopForType "PyUFunc_RegisterLoopForType")
    for user-defined types). A signature is an array of data-type numbers indicating
    the inputs followed by the outputs assumed by the 1-d loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple interface to the IEEE error-flag checking support. The *errmask* argument
    is a mask of `UFUNC_MASK_{ERR}` bitmasks indicating which errors to check for
    (and how to check for them). The *errobj* must be a Python tuple with two elements:
    a string containing the name which will be used in any communication of error
    and either a callable Python object (call-back function) or [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)"). The callable object will only be used if [`UFUNC_ERR_CALL`](#c.UFUNC_ERR_CALL
    "UFUNC_ERR_CALL") is set as the desired error checking method. This routine manages
    the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible
    hardware is determined a -1 is returned, otherwise a 0 is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Clear the IEEE error flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Get the Python values used for ufunc processing from the thread-local storage
    area unless the defaults have been set in which case the name lookup is bypassed.
    The name is placed as a string in the first element of **errobj*. The second element
    is the looked-up function to call on error callback. The value of the looked-up
    buffer-size to use is passed into *bufsize*, and the value of the error mask is
    placed into *errmask*.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the core of every ufunc is a collection of type-specific functions that defines
    the basic functionality for each of the supported types. These functions must
    evaluate the underlying function \(N\geq1\) times. Extra-data may be passed in
    that may be used during the calculation. This feature allows some general functions
    to be used as these basic looping functions. The general function has all the
    code needed to point variables to the right place and set up a function call.
    The general function assumes that the actual function to call is passed in as
    the extra data and calls it with the correct values. All of these functions are
    suitable for placing directly in the array of functions stored in the functions
    member of the PyUFuncObject structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Type specific, core 1-d functions for ufuncs where each calculation is obtained
    by calling a function taking one input argument and returning one output. This
    function is passed in `func`. The letters correspond to dtypechar’s of the supported
    data types ( `e` - half, `f` - float, `d` - double, `g` - long double, `F` - cfloat,
    `D` - cdouble, `G` - clongdouble). The argument *func* must support the same signature.
    The _As_X_X variants assume ndarray’s of one data type but cast the values to
    use an underlying function that takes a different data type. Thus, [`PyUFunc_f_f_As_d_d`](#c.PyUFunc_f_f_As_d_d
    "PyUFunc_f_f_As_d_d") uses ndarrays of data type [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") but calls out to a C-function that takes double and returns double.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Type specific, core 1-d functions for ufuncs where each calculation is obtained
    by calling a function taking two input arguments and returning one output. The
    underlying function to call is passed in as *func*. The letters correspond to
    dtypechar’s of the specific data type supported by the general-purpose function.
    The argument `func` must support the corresponding signature. The `_As_XX_X` variants
    assume ndarrays of one data type but cast the values at each iteration of the
    loop to use the underlying function that takes a different data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: One-input, one-output, and two-input, one-output core 1-d functions for the
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") data type. These
    functions handle reference count issues and return early on error. The actual
    function to call is *func* and it must accept calls with the signature `(PyObject*)
    (PyObject*)` for [`PyUFunc_O_O`](#c.PyUFunc_O_O "PyUFunc_O_O") or `(PyObject*)(PyObject
    *, PyObject *)` for [`PyUFunc_OO_O`](#c.PyUFunc_OO_O "PyUFunc_OO_O").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This general purpose 1-d core function assumes that *func* is a string representing
    a method of the input object. For each iteration of the loop, the Python object
    is extracted from the array and its *func* method is called returning the result
    to the output array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This general purpose 1-d core function assumes that *func* is a string representing
    a method of the input object that takes one argument. The first argument in *args*
    is the method whose function is called, the second argument in *args* is the argument
    passed to the function. The output of the function is stored in the third entry
    of *args*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function,
    nin, nout). In this case *func* is a pointer to a [`PyUFunc_PyFuncData`](#c.PyUFunc_On_Om.PyUFunc_PyFuncData
    "PyUFunc_PyFuncData") structure which has definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: At each iteration of the loop, the *nin* input objects are extracted from their
    object arrays and placed into an argument tuple, the Python *callable* is called
    with the input arguments, and the nout outputs are placed into their object arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These are the constants and functions for accessing the ufunc C-API from extension
    modules in precisely the same way as the array C-API can be accessed. The `import_ufunc`
    () function must always be called (in the initialization subroutine of the extension
    module). If your extension module is in one file then that is all that is required.
    The other two constants are useful if your extension module makes use of multiple
    files. In that case, define [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL
    "PY_UFUNC_UNIQUE_SYMBOL") to something unique to your code and then in source
    files that do not contain the module initialization function but still need access
    to the UFUNC API, define [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL
    "PY_UFUNC_UNIQUE_SYMBOL") to the same name used previously and also define [`NO_IMPORT_UFUNC`](#c.NO_IMPORT_UFUNC
    "NO_IMPORT_UFUNC").
  prefs: []
  type: TYPE_NORMAL
- en: The C-API is actually an array of function pointers. This array is created (and
    pointed to by a global variable) by import_ufunc. The global variable is either
    statically defined or allowed to be seen by other files depending on the state
    of [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL "PY_UFUNC_UNIQUE_SYMBOL")
    and [`NO_IMPORT_UFUNC`](#c.NO_IMPORT_UFUNC "NO_IMPORT_UFUNC").
  prefs: []
  type: TYPE_NORMAL
- en: '## Constants'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFUNC_ERR_{HANDLER}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`UFUNC_{THING}_{ERR}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`PyUFunc_{VALUE}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Used in universal function code to only release the Python GIL if loop->obj
    is not true (*i.e.* this is not an OBJECT array loop). Requires use of [`NPY_BEGIN_THREADS_DEF`](array.html#c.NPY_BEGIN_THREADS_DEF
    "NPY_BEGIN_THREADS_DEF") in variable declaration area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Used in universal function code to re-acquire the Python GIL if it was released
    (because loop->obj was not true).
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointers to functions that actually implement the underlying (element-by-element)
    function \(N\) times with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '*args*'
  prefs: []
  type: TYPE_NORMAL
- en: An array of pointers to the actual data for the input and output arrays. The
    input arguments are given first followed by the output arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*dimensions*'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the size of the dimension over which this function is looping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*steps*'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the number of bytes to jump to get to the next element in this
    dimension for each of the input and output arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*data*'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary data (extra arguments, function names, *etc.* ) that can be stored
    with the ufunc and will be passed in when it is called. May be `NULL`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Changed in version 1.23.0: Accepts `NULL` *data* in addition to array of `NULL`
    values.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is an example of a func specialized for addition of doubles returning doubles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Create a new broadcasting universal function from required variables. Each ufunc
    builds around the notion of an element-by-element operation. Each ufunc object
    contains pointers to 1-d loops implementing the basic functionality for each supported
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The *func*, *data*, *types*, *name*, and *doc* arguments are not copied by [`PyUFunc_FromFuncAndData`](#c.PyUFunc_FromFuncAndData
    "PyUFunc_FromFuncAndData"). The caller must ensure that the memory used by these
    arrays is not freed as long as the ufunc object is alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func** – Must point to an array containing *ntypes* [`PyUFuncGenericFunction`](#c.PyUFuncGenericFunction
    "PyUFuncGenericFunction") elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**data** – Should be `NULL` or a pointer to an array of size *ntypes*. This
    array may contain arbitrary extra-data to be passed to the corresponding loop
    function in the func array, including `NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**types** –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length `(nin + nout) * ntypes` array of `char` encoding the [`numpy.dtype.num`](../generated/numpy.dtype.num.html#numpy.dtype.num
    "numpy.dtype.num") (built-in only) that the corresponding function in the `func`
    array accepts. For instance, for a comparison ufunc with three `ntypes`, two `nin`
    and one `nout`, where the first function accepts [`numpy.int32`](../arrays.scalars.html#numpy.int32
    "numpy.int32") and the second [`numpy.int64`](../arrays.scalars.html#numpy.int64
    "numpy.int64"), with both returning [`numpy.bool_`](../arrays.scalars.html#numpy.bool_
    "numpy.bool_"), `types` would be `(char[]) {5, 5, 0, 7, 7, 0}` since `NPY_INT32`
    is 5, `NPY_INT64` is 7, and `NPY_BOOL` is 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The bit-width names can also be used (e.g. [`NPY_INT32`](dtype.html#c.NPY_TYPES.NPY_INT32
    "NPY_INT32"), [`NPY_COMPLEX128`](dtype.html#c.NPY_TYPES.NPY_COMPLEX128 "NPY_COMPLEX128")
    ) if desired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Type casting rules](../../user/basics.ufuncs.html#ufuncs-casting) will be
    used at runtime to find the first `func` callable by the input/output provided.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ntypes** – How many different data-type-specific functions the ufunc has
    implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nin** – The number of inputs to this operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nout** – The number of outputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**identity** – Either [`PyUFunc_One`](#c.PyUFunc_One "PyUFunc_One"), [`PyUFunc_Zero`](#c.PyUFunc_Zero
    "PyUFunc_Zero"), [`PyUFunc_MinusOne`](#c.PyUFunc_MinusOne "PyUFunc_MinusOne"),
    or [`PyUFunc_None`](#c.PyUFunc_None "PyUFunc_None"). This specifies what should
    be returned when an empty array is passed to the reduce method of the ufunc. The
    special value [`PyUFunc_IdentityValue`](#c.PyUFunc_IdentityValue "PyUFunc_IdentityValue")
    may only be used with the [`PyUFunc_FromFuncAndDataAndSignatureAndIdentity`](#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity
    "PyUFunc_FromFuncAndDataAndSignatureAndIdentity") method, to allow an arbitrary
    python object to be used as the identity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name** – The name for the ufunc as a `NULL` terminated string. Specifying
    a name of ‘add’ or ‘multiply’ enables a special behavior for integer-typed reductions
    when no dtype is given. If the input type is an integer (or boolean) data type
    smaller than the size of the [`numpy.int_`](../arrays.scalars.html#numpy.int_
    "numpy.int_") data type, it will be internally upcast to the [`numpy.int_`](../arrays.scalars.html#numpy.int_
    "numpy.int_") (or [`numpy.uint`](../arrays.scalars.html#numpy.uint "numpy.uint"))
    data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**doc** – Allows passing in a documentation string to be stored with the ufunc.
    The documentation string should not contain the name of the function or the calling
    signature as that will be dynamically determined from the object and available
    when accessing the **__doc__** attribute of the ufunc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unused** – Unused and present for backwards compatibility of the C-API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This function is very similar to PyUFunc_FromFuncAndData above, but has an extra
    *signature* argument, to define a [generalized universal functions](generalized-ufuncs.html#c-api-generalized-ufuncs).
    Similarly to how ufuncs are built around an element-by-element operation, gufuncs
    are around subarray-by-subarray operations, the [signature](generalized-ufuncs.html#details-of-signature)
    defining the subarrays to operate on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**signature** – The signature for the new gufunc. Setting it to NULL is equivalent
    to calling PyUFunc_FromFuncAndData. A copy of the string is made, so the passed
    in buffer can be freed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This function is very similar to *PyUFunc_FromFuncAndDataAndSignature* above,
    but has an extra *identity_value* argument, to define an arbitrary identity for
    the ufunc when `identity` is passed as `PyUFunc_IdentityValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**identity_value** – The identity for the new gufunc. Must be passed as `NULL`
    unless the `identity` argument is `PyUFunc_IdentityValue`. Setting it to NULL
    is equivalent to calling PyUFunc_FromFuncAndDataAndSignature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This function allows the user to register a 1-d loop with an already- created
    ufunc to be used whenever the ufunc is called with any of its input arguments
    as the user-defined data-type. This is needed in order to make ufuncs work with
    built-in data-types. The data-type must have been previously registered with the
    numpy system. The loop is passed in as *function*. This loop can take arbitrary
    data which should be passed in as *data*. The data-types the loop requires are
    passed in as *arg_types* which must be a pointer to memory at least as large as
    ufunc->nargs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This function behaves like PyUFunc_RegisterLoopForType above, except that it
    allows the user to register a 1-d loop using PyArray_Descr objects instead of
    dtype type num values. This allows a 1-d loop to be registered for structured
    array data-dtypes and custom data-types instead of scalar data-types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Replace a 1-d loop matching the given *signature* in the already-created *ufunc*
    with the new 1-d loop newfunc. Return the old 1-d loop function in *oldfunc*.
    Return 0 on success and -1 on failure. This function works only with built-in
    types (use [`PyUFunc_RegisterLoopForType`](#c.PyUFunc_RegisterLoopForType "PyUFunc_RegisterLoopForType")
    for user-defined types). A signature is an array of data-type numbers indicating
    the inputs followed by the outputs assumed by the 1-d loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple interface to the IEEE error-flag checking support. The *errmask* argument
    is a mask of `UFUNC_MASK_{ERR}` bitmasks indicating which errors to check for
    (and how to check for them). The *errobj* must be a Python tuple with two elements:
    a string containing the name which will be used in any communication of error
    and either a callable Python object (call-back function) or [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)"). The callable object will only be used if [`UFUNC_ERR_CALL`](#c.UFUNC_ERR_CALL
    "UFUNC_ERR_CALL") is set as the desired error checking method. This routine manages
    the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible
    hardware is determined a -1 is returned, otherwise a 0 is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Clear the IEEE error flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Get the Python values used for ufunc processing from the thread-local storage
    area unless the defaults have been set in which case the name lookup is bypassed.
    The name is placed as a string in the first element of **errobj*. The second element
    is the looked-up function to call on error callback. The value of the looked-up
    buffer-size to use is passed into *bufsize*, and the value of the error mask is
    placed into *errmask*.
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the core of every ufunc is a collection of type-specific functions that defines
    the basic functionality for each of the supported types. These functions must
    evaluate the underlying function \(N\geq1\) times. Extra-data may be passed in
    that may be used during the calculation. This feature allows some general functions
    to be used as these basic looping functions. The general function has all the
    code needed to point variables to the right place and set up a function call.
    The general function assumes that the actual function to call is passed in as
    the extra data and calls it with the correct values. All of these functions are
    suitable for placing directly in the array of functions stored in the functions
    member of the PyUFuncObject structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Type specific, core 1-d functions for ufuncs where each calculation is obtained
    by calling a function taking one input argument and returning one output. This
    function is passed in `func`. The letters correspond to dtypechar’s of the supported
    data types ( `e` - half, `f` - float, `d` - double, `g` - long double, `F` - cfloat,
    `D` - cdouble, `G` - clongdouble). The argument *func* must support the same signature.
    The _As_X_X variants assume ndarray’s of one data type but cast the values to
    use an underlying function that takes a different data type. Thus, [`PyUFunc_f_f_As_d_d`](#c.PyUFunc_f_f_As_d_d
    "PyUFunc_f_f_As_d_d") uses ndarrays of data type [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") but calls out to a C-function that takes double and returns double.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Type specific, core 1-d functions for ufuncs where each calculation is obtained
    by calling a function taking two input arguments and returning one output. The
    underlying function to call is passed in as *func*. The letters correspond to
    dtypechar’s of the specific data type supported by the general-purpose function.
    The argument `func` must support the corresponding signature. The `_As_XX_X` variants
    assume ndarrays of one data type but cast the values at each iteration of the
    loop to use the underlying function that takes a different data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: One-input, one-output, and two-input, one-output core 1-d functions for the
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") data type. These
    functions handle reference count issues and return early on error. The actual
    function to call is *func* and it must accept calls with the signature `(PyObject*)
    (PyObject*)` for [`PyUFunc_O_O`](#c.PyUFunc_O_O "PyUFunc_O_O") or `(PyObject*)(PyObject
    *, PyObject *)` for [`PyUFunc_OO_O`](#c.PyUFunc_OO_O "PyUFunc_OO_O").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This general purpose 1-d core function assumes that *func* is a string representing
    a method of the input object. For each iteration of the loop, the Python object
    is extracted from the array and its *func* method is called returning the result
    to the output array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This general purpose 1-d core function assumes that *func* is a string representing
    a method of the input object that takes one argument. The first argument in *args*
    is the method whose function is called, the second argument in *args* is the argument
    passed to the function. The output of the function is stored in the third entry
    of *args*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function,
    nin, nout). In this case *func* is a pointer to a [`PyUFunc_PyFuncData`](#c.PyUFunc_On_Om.PyUFunc_PyFuncData
    "PyUFunc_PyFuncData") structure which has definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: At each iteration of the loop, the *nin* input objects are extracted from their
    object arrays and placed into an argument tuple, the Python *callable* is called
    with the input arguments, and the nout outputs are placed into their object arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: These are the constants and functions for accessing the ufunc C-API from extension
    modules in precisely the same way as the array C-API can be accessed. The `import_ufunc`
    () function must always be called (in the initialization subroutine of the extension
    module). If your extension module is in one file then that is all that is required.
    The other two constants are useful if your extension module makes use of multiple
    files. In that case, define [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL
    "PY_UFUNC_UNIQUE_SYMBOL") to something unique to your code and then in source
    files that do not contain the module initialization function but still need access
    to the UFUNC API, define [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL
    "PY_UFUNC_UNIQUE_SYMBOL") to the same name used previously and also define [`NO_IMPORT_UFUNC`](#c.NO_IMPORT_UFUNC
    "NO_IMPORT_UFUNC").
  prefs: []
  type: TYPE_NORMAL
- en: The C-API is actually an array of function pointers. This array is created (and
    pointed to by a global variable) by import_ufunc. The global variable is either
    statically defined or allowed to be seen by other files depending on the state
    of [`PY_UFUNC_UNIQUE_SYMBOL`](#c.PY_UFUNC_UNIQUE_SYMBOL "PY_UFUNC_UNIQUE_SYMBOL")
    and [`NO_IMPORT_UFUNC`](#c.NO_IMPORT_UFUNC "NO_IMPORT_UFUNC").
  prefs: []
  type: TYPE_NORMAL
