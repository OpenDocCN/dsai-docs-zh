- en: Nullable Boolean data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/boolean.html](https://pandas.pydata.org/docs/user_guide/boolean.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: BooleanArray is currently experimental. Its API or implementation may change
    without warning.
  prefs: []
  type: TYPE_NORMAL
- en: '## Indexing with NA values'
  prefs: []
  type: TYPE_NORMAL
- en: pandas allows indexing with `NA` values in a boolean array, which are treated
    as `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you would prefer to keep the `NA` values you can manually fill them with
    `fillna(True)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]  ## Kleene logical operations'
  prefs: []
  type: TYPE_NORMAL
- en: '[`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") implements [Kleene Logic](https://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics)
    (sometimes called three-value logic) for logical operations like `&` (and), `|`
    (or) and `^` (exclusive-or).'
  prefs: []
  type: TYPE_NORMAL
- en: This table demonstrates the results for every combination. These operations
    are symmetrical, so flipping the left- and right-hand side makes no difference
    in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `True & True` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True & False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `True & NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `False & False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False & NA` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA & NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; True` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; False` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; NA` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `False &#124; False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False &#124; NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA &#124; NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ True` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ False` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `False ^ False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: When an `NA` is present in an operation, the output value is `NA` only if the
    result cannot be determined solely based on the other input. For example, `True
    | NA` is `True`, because both `True | True` and `True | False` are `True`. In
    that case, we don’t actually need to consider the value of the `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `True & NA` is `NA`. The result depends on whether the `NA`
    really is `True` or `False`, since `True & True` is `True`, but `True & False`
    is `False`, so we can’t determine the output.
  prefs: []
  type: TYPE_NORMAL
- en: This differs from how `np.nan` behaves in logical operations. pandas treated
    `np.nan` is *always false in the output*.
  prefs: []
  type: TYPE_NORMAL
- en: In `or`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In `and`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]  ## Indexing with NA values'
  prefs: []
  type: TYPE_NORMAL
- en: pandas allows indexing with `NA` values in a boolean array, which are treated
    as `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you would prefer to keep the `NA` values you can manually fill them with
    `fillna(True)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '## Kleene logical operations'
  prefs: []
  type: TYPE_NORMAL
- en: '[`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") implements [Kleene Logic](https://en.wikipedia.org/wiki/Three-valued_logic#Kleene_and_Priest_logics)
    (sometimes called three-value logic) for logical operations like `&` (and), `|`
    (or) and `^` (exclusive-or).'
  prefs: []
  type: TYPE_NORMAL
- en: This table demonstrates the results for every combination. These operations
    are symmetrical, so flipping the left- and right-hand side makes no difference
    in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `True & True` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True & False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `True & NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `False & False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False & NA` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA & NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; True` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; False` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True &#124; NA` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `False &#124; False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False &#124; NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA &#124; NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ True` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ False` | `True` |'
  prefs: []
  type: TYPE_TB
- en: '| `True ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `False ^ False` | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `False ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: '| `NA ^ NA` | `NA` |'
  prefs: []
  type: TYPE_TB
- en: When an `NA` is present in an operation, the output value is `NA` only if the
    result cannot be determined solely based on the other input. For example, `True
    | NA` is `True`, because both `True | True` and `True | False` are `True`. In
    that case, we don’t actually need to consider the value of the `NA`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `True & NA` is `NA`. The result depends on whether the `NA`
    really is `True` or `False`, since `True & True` is `True`, but `True & False`
    is `False`, so we can’t determine the output.
  prefs: []
  type: TYPE_NORMAL
- en: This differs from how `np.nan` behaves in logical operations. pandas treated
    `np.nan` is *always false in the output*.
  prefs: []
  type: TYPE_NORMAL
- en: In `or`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In `and`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
