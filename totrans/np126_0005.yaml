- en: 'NumPy: the absolute basics for beginners'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/user/absolute_beginners.html](https://numpy.org/doc/1.26/user/absolute_beginners.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Welcome to the absolute beginner’s guide to NumPy! If you have comments or suggestions,
    please don’t hesitate to [reach out](https://numpy.org/community/)!
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to NumPy!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy (**Numerical Python**) is an open source Python library that’s used in
    almost every field of science and engineering. It’s the universal standard for
    working with numerical data in Python, and it’s at the core of the scientific
    Python and PyData ecosystems. NumPy users include everyone from beginning coders
    to experienced researchers doing state-of-the-art scientific and industrial research
    and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib,
    scikit-learn, scikit-image and most other data science and scientific Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy library contains multidimensional array and matrix data structures
    (you’ll find more information about this in later sections). It provides **ndarray**,
    a homogeneous n-dimensional array object, with methods to efficiently operate
    on it. NumPy can be used to perform a wide variety of mathematical operations
    on arrays. It adds powerful data structures to Python that guarantee efficient
    calculations with arrays and matrices and it supplies an enormous library of high-level
    mathematical functions that operate on these arrays and matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about [NumPy here](whatisnumpy.html#whatisnumpy)!
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install NumPy, we strongly recommend using a scientific Python distribution.
    If you’re looking for the full instructions for installing NumPy on your operating
    system, see [Installing NumPy](https://numpy.org/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have Python, you can install NumPy with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t have Python yet, you might want to consider using [Anaconda](https://www.anaconda.com/).
    It’s the easiest way to get started. The good thing about getting this distribution
    is the fact that you don’t need to worry too much about separately installing
    NumPy or any of the major packages that you’ll be using for your data analyses,
    like pandas, Scikit-Learn, etc.
  prefs: []
  type: TYPE_NORMAL
- en: How to import NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access NumPy and its functions import it in your Python code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We shorten the imported name to `np` for better readability of code using NumPy.
    This is a widely adopted convention that makes your code more readable for everyone
    working on it. We recommend to always use import numpy as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you aren’t already comfortable with reading tutorials that contain a lot
    of code, you might not know how to interpret a code block that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you aren’t familiar with this style, it’s very easy to understand. If you
    see `>>>`, you’re looking at **input**, or the code that you would enter. Everything
    that doesn’t have `>>>` in front of it is **output**, or the results of running
    your code. This is the style you see when you run `python` on the command line,
    but if you’re using IPython, you might see a different style. Note that it is
    not part of the code and will cause an error if typed or pasted into the Python
    shell. It can be safely typed or pasted into the IPython shell; the `>>>` is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between a Python list and a NumPy array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy gives you an enormous range of fast and efficient ways of creating arrays
    and manipulating numerical data inside them. While a Python list can contain different
    data types within a single list, all of the elements in a NumPy array should be
    homogeneous. The mathematical operations that are meant to be performed on arrays
    would be extremely inefficient if the arrays weren’t homogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why use NumPy?**'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays are faster and more compact than Python lists. An array consumes
    less memory and is convenient to use. NumPy uses much less memory to store data
    and it provides a mechanism of specifying the data types. This allows the code
    to be optimized even further.
  prefs: []
  type: TYPE_NORMAL
- en: What is an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a central data structure of the NumPy library. An array is a grid
    of values and it contains information about the raw data, how to locate an element,
    and how to interpret an element. It has a grid of elements that can be indexed
    in [various ways](quickstart.html#quickstart-indexing-slicing-and-iterating).
    The elements are all of the same type, referred to as the array `dtype`.
  prefs: []
  type: TYPE_NORMAL
- en: An array can be indexed by a tuple of nonnegative integers, by booleans, by
    another array, or by integers. The `rank` of the array is the number of dimensions.
    The `shape` of the array is a tuple of integers giving the size of the array along
    each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can initialize NumPy arrays is from Python lists, using nested lists
    for two- or higher-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can access the elements in the array using square brackets. When you’re accessing
    elements, remember that indexing in NumPy starts at 0\. That means that if you
    want to access the first element in your array, you’ll be accessing element “0”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: More information about arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `1D array`, `2D array`, `ndarray`, `vector`, `matrix`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You might occasionally hear an array referred to as a “ndarray,” which is shorthand
    for “N-dimensional array.” An N-dimensional array is simply an array with any
    number of dimensions. You might also hear **1-D**, or one-dimensional array, **2-D**,
    or two-dimensional array, and so on. The NumPy `ndarray` class is used to represent
    both matrices and vectors. A **vector** is an array with a single dimension (there’s
    no difference between row and column vectors), while a **matrix** refers to an
    array with two dimensions. For **3-D** or higher dimensional arrays, the term
    **tensor** is also commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the attributes of an array?**'
  prefs: []
  type: TYPE_NORMAL
- en: An array is usually a fixed-size container of items of the same type and size.
    The number of dimensions and items in an array is defined by its shape. The shape
    of an array is a tuple of non-negative integers that specify the sizes of each
    dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In NumPy, dimensions are called **axes**. This means that if you have a 2D
    array that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your array has 2 axes. The first axis has a length of 2 and the second axis
    has a length of 3.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in other Python container objects, the contents of an array can be
    accessed and modified by indexing or slicing the array. Unlike the typical container
    objects, different arrays can share the same data, so changes made on one array
    might be visible in another.
  prefs: []
  type: TYPE_NORMAL
- en: Array **attributes** reflect information intrinsic to the array itself. If you
    need to get, or even set, properties of an array without creating a new array,
    you can often access an array through its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Read more about array attributes here](../reference/arrays.ndarray.html#arrays-ndarray)
    and learn about [array objects here](../reference/arrays.html#arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a basic array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.array()`, `np.zeros()`, `np.ones()`, `np.empty()`,
    `np.arange()`, `np.linspace()`, `dtype`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: To create a NumPy array, you can use the function `np.array()`.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do to create a simple array is pass a list to it. If you choose
    to, you can also specify the type of data in your list. [You can find more information
    about data types here](../reference/arrays.dtypes.html#arrays-dtypes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can visualize your array this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_array.png](../Images/aaf6808d845c7bcc478972e091442ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Be aware that these visualizations are meant to simplify ideas and give you
    a basic understanding of NumPy concepts and mechanics. Arrays and array operations
    are much more complicated than are captured here!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides creating an array from a sequence of elements, you can easily create
    an array filled with `0`’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or an array filled with `1`’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or even an empty array! The function `empty` creates an array whose initial
    content is random and depends on the state of the memory. The reason to use `empty`
    over `zeros` (or something similar) is speed - just make sure to fill every element
    afterwards!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an array with a range of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And even an array that contains a range of evenly spaced intervals. To do this,
    you will specify the **first number**, **last number**, and the **step size**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `np.linspace()` to create an array with values that are spaced
    linearly in a specified interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Specifying your data type**'
  prefs: []
  type: TYPE_NORMAL
- en: While the default data type is floating point (`np.float64`), you can explicitly
    specify which data type you want using the `dtype` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about creating arrays here](quickstart.html#quickstart-array-creation)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding, removing, and sorting elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.sort()`, `np.concatenate()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an element is simple with `np.sort()`. You can specify the axis, kind,
    and order when you call the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly sort the numbers in ascending order with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to sort, which returns a sorted copy of an array, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    which is an indirect sort along a specified axis,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    which is an indirect stable sort on multiple keys,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), which will find elements in a sorted array, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`partition`](../reference/generated/numpy.partition.html#numpy.partition "numpy.partition"),
    which is a partial sort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To read more about sorting an array, see: [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort").'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with these arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can concatenate them with `np.concatenate()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you start with these arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can concatenate them with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order to remove elements from an array, it’s simple to use indexing to select
    the elements that you want to keep.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about concatenate, see: [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate").'
  prefs: []
  type: TYPE_NORMAL
- en: How do you know the shape and size of an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `ndarray.ndim`, `ndarray.size`, `ndarray.shape`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.ndim` will tell you the number of axes, or dimensions, of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.size` will tell you the total number of elements of the array. This
    is the *product* of the elements of the array’s shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.shape` will display a tuple of integers that indicate the number of
    elements stored along each dimension of the array. If, for example, you have a
    2-D array with 2 rows and 3 columns, the shape of your array is `(2, 3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the number of dimensions of the array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the total number of elements in the array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And to find the shape of your array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Can you reshape an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `arr.reshape()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yes!**'
  prefs: []
  type: TYPE_NORMAL
- en: Using `arr.reshape()` will give a new shape to an array without changing the
    data. Just remember that when you use the reshape method, the array you want to
    produce needs to have the same number of elements as the original array. If you
    start with an array with 12 elements, you’ll need to make sure that your new array
    also has a total of 12 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `reshape()` to reshape your array. For example, you can reshape
    this array to an array with three rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With `np.reshape`, you can specify a few optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is the array to be reshaped.'
  prefs: []
  type: TYPE_NORMAL
- en: '`newshape` is the new shape you want. You can specify an integer or a tuple
    of integers. If you specify an integer, the result will be an array of that length.
    The shape should be compatible with the original shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '`order:` `C` means to read/write the elements using C-like index order, `F`
    means to read/write the elements using Fortran-like index order, `A` means to
    read/write the elements in Fortran-like index order if a is Fortran contiguous
    in memory, C-like order otherwise. (This is an optional parameter and doesn’t
    need to be specified.)'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about C and Fortran order, you can [read more about
    the internal organization of NumPy arrays here](../dev/internals.html#numpy-internals).
    Essentially, C and Fortran orders have to do with how indices correspond to the
    order the array is stored in memory. In Fortran, when moving through the elements
    of a two-dimensional array as it is stored in memory, the **first** index is the
    most rapidly varying index. As the first index moves to the next row as it changes,
    the matrix is stored one column at a time. This is why Fortran is thought of as
    a **Column-major language**. In C on the other hand, the **last** index changes
    the most rapidly. The matrix is stored by rows, making it a **Row-major language**.
    What you do for C or Fortran depends on whether it’s more important to preserve
    the indexing convention or not reorder the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about shape manipulation here](quickstart.html#quickstart-shape-manipulation).'
  prefs: []
  type: TYPE_NORMAL
- en: How to convert a 1D array into a 2D array (how to add a new axis to an array)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.newaxis`, `np.expand_dims`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `np.newaxis` and `np.expand_dims` to increase the dimensions of
    your existing array.
  prefs: []
  type: TYPE_NORMAL
- en: Using `np.newaxis` will increase the dimensions of your array by one dimension
    when used once. This means that a **1D** array will become a **2D** array, a **2D**
    array will become a **3D** array, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.newaxis` to add a new axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can explicitly convert a 1D array with either a row vector or a column
    vector using `np.newaxis`. For example, you can convert a 1D array to a row vector
    by inserting an axis along the first dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for a column vector, you can insert an axis along the second dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can also expand an array by inserting a new axis at a specified position
    with `np.expand_dims`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.expand_dims` to add an axis at index position 1 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add an axis at index position 0 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Find more information about [newaxis here](../reference/arrays.indexing.html#arrays-indexing)
    and `expand_dims` at [`expand_dims`](../reference/generated/numpy.expand_dims.html#numpy.expand_dims
    "numpy.expand_dims").
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can index and slice NumPy arrays in the same ways you can slice Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can visualize it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_indexing.png](../Images/cd29651900916a5a0f06923d997eca93.png)'
  prefs: []
  type: TYPE_IMG
- en: You may want to take a section of your array or specific array elements to use
    in further analysis or additional operations. To do that, you’ll need to subset,
    slice, and/or index your arrays.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to select values from your array that fulfill certain conditions,
    it’s straightforward with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can easily print all of the values in the array that are less than 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can also select, for example, numbers that are equal to or greater than
    5, and use that condition to index an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select elements that are divisible by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can select elements that satisfy two conditions using the `&` and `|`
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can also make use of the logical operators **&** and **|** in order to return
    boolean values that specify whether or not the values in an array fulfill a certain
    condition. This can be useful with arrays that contain names or other categorical
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `np.nonzero()` to select elements or indices from an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.nonzero()` to print the indices of elements that are, for example,
    less than 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, a tuple of arrays was returned: one for each dimension. The
    first array represents the row indices where these values are found, and the second
    array represents the column indices where the values are found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to generate a list of coordinates where the elements exist, you
    can zip the arrays, iterate over the list of coordinates, and print them. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `np.nonzero()` to print the elements in an array that are
    less than 5 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If the element you’re looking for doesn’t exist in the array, then the returned
    array of indices will be empty. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about [indexing and slicing here](quickstart.html#quickstart-indexing-slicing-and-iterating)
    and [here](basics.indexing.html#basics-indexing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about using the nonzero function at: [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero").'
  prefs: []
  type: TYPE_NORMAL
- en: How to create an array from existing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `slicing and indexing`, `np.vstack()`, `np.hstack()`,
    `np.hsplit()`, `.view()`, `copy()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily create a new array from a section of an existing array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can create a new array from a section of your array any time by specifying
    where you want to slice your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, you grabbed a section of your array from index position 3 through index
    position 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also stack two existing arrays, both vertically and horizontally. Let’s
    say you have two arrays, `a1` and `a2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stack them vertically with `vstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Or stack them horizontally with `hstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can split an array into several smaller arrays using `hsplit`. You can specify
    either the number of equally shaped arrays to return or the columns *after* which
    the division should occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to split this array into three equally shaped arrays, you would
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to split your array after the third and fourth column, you’d
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about stacking and splitting arrays here](quickstart.html#quickstart-stacking-arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `view` method to create a new array object that looks at the
    same data as the original array (a *shallow copy*).
  prefs: []
  type: TYPE_NORMAL
- en: Views are an important NumPy concept! NumPy functions, as well as operations
    like indexing and slicing, will return views whenever possible. This saves memory
    and is faster (no copy of the data has to be made). However it’s important to
    be aware of this - modifying data in a view also modifies the original array!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now we create an array `b1` by slicing `a` and modify the first element of `b1`.
    This will modify the corresponding element in `a` as well!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `copy` method will make a complete copy of the array and its data
    (a *deep copy*). To use this on your array, you could run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about copies and views here](quickstart.html#quickstart-copies-and-views).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic array operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers addition, subtraction, multiplication, division, and more*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created your arrays, you can start to work with them. Let’s say,
    for example, that you’ve created two arrays, one called “data” and one called
    “ones”
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_array_dataones.png](../Images/9b59cfcd5bef02a4f4038fabe093cf23.png)'
  prefs: []
  type: TYPE_IMG
- en: You can add the arrays together with the plus sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_data_plus_ones.png](../Images/66d39b9fac255980e503123485c0444f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, do more than just addition!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_sub_mult_divide.png](../Images/c1f77f532a2c7d29d2aee60956b2d967.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic operations are simple with NumPy. If you want to find the sum of the elements
    in an array, you’d use `sum()`. This works for 1D arrays, 2D arrays, and arrays
    in higher dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: To add the rows or the columns in a 2D array, you would specify the axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sum over the axis of rows with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sum over the axis of columns with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about basic operations here](quickstart.html#quickstart-basic-operations).'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when you might want to carry out an operation between an array
    and a single number (also called *an operation between a vector and a scalar*)
    or between arrays of two different sizes. For example, your array (we’ll call
    it “data”) might contain information about distance in miles but you want to convert
    the information to kilometers. You can perform this operation with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_multiply_broadcasting.png](../Images/11c558ec6f5400f721ced3df1869a30c.png)'
  prefs: []
  type: TYPE_IMG
- en: NumPy understands that the multiplication should happen with each cell. That
    concept is called **broadcasting**. Broadcasting is a mechanism that allows NumPy
    to perform operations on arrays of different shapes. The dimensions of your array
    must be compatible, for example, when the dimensions of both arrays are equal
    or when one of them is 1\. If the dimensions are not compatible, you will get
    a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about broadcasting here](basics.broadcasting.html#basics-broadcasting).'
  prefs: []
  type: TYPE_NORMAL
- en: More useful array operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers maximum, minimum, sum, mean, product, standard deviation,
    and more*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy also performs aggregation functions. In addition to `min`, `max`, and
    `sum`, you can easily run `mean` to get the average, `prod` to get the result
    of multiplying the elements together, `std` to get the standard deviation, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_aggregation.png](../Images/2c41632a337fac537f465483e8f74817.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s start with this array, called “a”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s very common to want to aggregate along a row or column. By default, every
    NumPy aggregation function will return the aggregate of the entire array. To find
    the sum or the minimum of the elements in your array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can specify on which axis you want the aggregation function to be computed.
    For example, you can find the minimum value within each column by specifying `axis=0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The four values listed above correspond to the number of columns in your array.
    With a four-column array, you will get four values as your result.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about [array methods here](../reference/arrays.ndarray.html#array-ndarray-methods).
  prefs: []
  type: TYPE_NORMAL
- en: Creating matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can pass Python lists of lists to create a 2-D array (or “matrix”) to represent
    them in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_create_matrix.png](../Images/f0baeb2fd5bf39ba6f39a0bcd76f27cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Indexing and slicing operations are useful when you’re manipulating matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_indexing.png](../Images/18d8f5ed53ce3c532bdf9819f566656a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can aggregate matrices the same way you aggregated vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_aggregation.png](../Images/54fae10b03421e1cccc2bffe511a58b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can aggregate all the values in a matrix and you can aggregate them across
    columns or rows using the `axis` parameter. To illustrate this point, let’s look
    at a slightly modified dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_aggregation_row.png](../Images/0c528d4cd2dab05f6959a98c3ee1be32.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve created your matrices, you can add and multiply them using arithmetic
    operators if you have two matrices that are the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_arithmetic.png](../Images/3b22b1779686234e77a7e0898013d8e8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can do these arithmetic operations on matrices of different sizes, but only
    if one matrix has only one column or one row. In this case, NumPy will use its
    broadcast rules for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_broadcasting.png](../Images/0fa020c3b7055d29a2c34c8ca85295db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Be aware that when NumPy prints N-dimensional arrays, the last axis is looped
    over the fastest while the first axis is the slowest. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'There are often instances where we want NumPy to initialize the values of an
    array. NumPy offers functions like `ones()` and `zeros()`, and the `random.Generator`
    class for random number generation for that. All you need to do is pass in the
    number of elements you want it to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_ones_zeros_random.png](../Images/86d5e6196bdd4ee9106eaf83b61fe57a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use `ones()`, `zeros()`, and `random()` to create a 2D array if
    you give them a tuple describing the dimensions of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_ones_zeros_matrix.png](../Images/eec8e0a2353993e5f66abe64767dbd8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Read more about creating arrays, filled with `0`’s, `1`’s, other values or uninitialized,
    at [array creation routines](../reference/routines.array-creation.html#routines-array-creation).
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of random number generation is an important part of the configuration
    and evaluation of many numerical and machine learning algorithms. Whether you
    need to randomly initialize weights in an artificial neural network, split data
    into random sets, or randomly shuffle your dataset, being able to generate random
    numbers (actually, repeatable pseudo-random numbers) is essential.
  prefs: []
  type: TYPE_NORMAL
- en: With `Generator.integers`, you can generate random integers from low (remember
    that this is inclusive with NumPy) to high (exclusive). You can set `endpoint=True`
    to make the high number inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a 2 x 4 array of random integers between 0 and 4 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[Read more about random number generation here](../reference/random/index.html#numpyrandom).'
  prefs: []
  type: TYPE_NORMAL
- en: How to get unique items and counts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.unique()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the unique elements in an array easily with `np.unique`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'you can use `np.unique` to print the unique values in your array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: To get the indices of unique values in a NumPy array (an array of first index
    positions of unique values in the array), just pass the `return_index` argument
    in `np.unique()` as well as your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You can pass the `return_counts` argument in `np.unique()` along with your array
    to get the frequency count of unique values in a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works with 2D arrays! If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find unique values with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If the axis argument isn’t passed, your 2D array will be flattened.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get the unique rows or columns, make sure to pass the `axis`
    argument. To find the unique rows, specify `axis=0` and for columns, specify `axis=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the unique rows, index position, and occurrence count, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about finding the unique elements in an array, see [`unique`](../reference/generated/numpy.unique.html#numpy.unique
    "numpy.unique").
  prefs: []
  type: TYPE_NORMAL
- en: Transposing and reshaping a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `arr.reshape()`, `arr.transpose()`, `arr.T`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to need to transpose your matrices. NumPy arrays have the property
    `T` that allows you to transpose a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_transposing_reshaping.png](../Images/90ef6ecf8374753450db871d206d21f1.png)'
  prefs: []
  type: TYPE_IMG
- en: You may also need to switch the dimensions of a matrix. This can happen when,
    for example, you have a model that expects a certain input shape that is different
    from your dataset. This is where the `reshape` method can be useful. You simply
    need to pass in the new dimensions that you want for the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_reshape.png](../Images/2f1382886687a1a2177b527ec1527b58.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also use `.transpose()` to reverse or change the axes of an array according
    to the values you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: You can transpose your array with `arr.transpose()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `arr.T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about transposing and reshaping arrays, see [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose") and [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape").
  prefs: []
  type: TYPE_NORMAL
- en: How to reverse an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.flip()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s `np.flip()` function allows you to flip, or reverse, the contents of
    an array along an axis. When using `np.flip()`, specify the array you would like
    to reverse and the axis. If you don’t specify the axis, NumPy will reverse the
    contents along all of the axes of your input array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversing a 1D array**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you begin with a 1D array like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reverse it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to print your reversed array, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '**Reversing a 2D array**'
  prefs: []
  type: TYPE_NORMAL
- en: A 2D array works much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reverse the content in all of the rows and all of the columns with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily reverse only the *rows* with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Or reverse only the *columns* with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reverse the contents of only one column or row. For example, you
    can reverse the contents of the row at index position 1 (the second row):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reverse the column at index position 1 (the second column):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Read more about reversing arrays at [`flip`](../reference/generated/numpy.flip.html#numpy.flip
    "numpy.flip").
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping and flattening multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `.flatten()`, `ravel()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two popular ways to flatten an array: `.flatten()` and `.ravel()`.
    The primary difference between the two is that the new array created using `ravel()`
    is actually a reference to the parent array (i.e., a “view”). This means that
    any changes to the new array will affect the parent array as well. Since `ravel`
    does not create a copy, it’s memory efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: You can use `flatten` to flatten your array into a 1D array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: When you use `flatten`, changes to your new array won’t change the parent array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: But when you use `ravel`, the changes you make to the new array will affect
    the parent array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Read more about `flatten` at [`ndarray.flatten`](../reference/generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") and `ravel` at [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel").
  prefs: []
  type: TYPE_NORMAL
- en: How to access the docstring for more information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `help()`, `?`, `??`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the data science ecosystem, Python and NumPy are built with
    the user in mind. One of the best examples of this is the built-in access to documentation.
    Every object contains the reference to a string, which is known as the **docstring**.
    In most cases, this docstring contains a quick and concise summary of the object
    and how to use it. Python has a built-in `help()` function that can help you access
    this information. This means that nearly any time you need more information, you
    can use `help()` to quickly find the information that you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Because access to additional information is so useful, IPython uses the `?`
    character as a shorthand for accessing this documentation along with other relevant
    information. IPython is a command shell for interactive computing in multiple
    languages. [You can find more information about IPython here](https://ipython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: You can even use this notation for object methods and objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can obtain a lot of useful information (first details about `a` itself,
    followed by the docstring of `ndarray` of which `a` is an instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This also works for functions and other objects that **you** create. Just remember
    to include a docstring with your function using a string literal (`""" """` or
    `''' '''` around your documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain information about the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: You can reach another level of information by reading the source code of the
    object you’re interested in. Using a double question mark (`??`) allows you to
    access the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'If the object in question is compiled in a language other than Python, using
    `??` will return the same information as `?`. You’ll find this with a lot of built-in
    objects and types, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'and :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: have the same output because they were compiled in a programming language other
    than Python.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mathematical formulas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ease of implementing mathematical formulas that work on arrays is one of
    the things that make NumPy so widely used in the scientific Python community.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is the mean square error formula (a central formula used
    in supervised machine learning models that deal with regression):'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_MSE_formula.png](../Images/b9475c62996a78fe826723abd6d7dbe8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementing this formula is simple and straightforward in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_MSE_implementation.png](../Images/01cd11db569040a346561a5cfc3bf23a.png)'
  prefs: []
  type: TYPE_IMG
- en: What makes this work so well is that `predictions` and `labels` can contain
    one or a thousand values. They only need to be the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visualize it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_mse_viz1.png](../Images/a8dbf015be4eaea56890409cc1ac99ce.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, both the predictions and labels vectors contain three values,
    meaning `n` has a value of three. After we carry out subtractions the values in
    the vector are squared. Then NumPy sums the values, and your result is the error
    value for that prediction and a score for the quality of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_mse_viz2.png](../Images/a6678fbe867a803aa7d00ee7a4463e8b.png)
    ![../_images/np_MSE_explanation2.png](../Images/f167374d2ba2c45f5a4f4410c9076603.png)'
  prefs: []
  type: TYPE_IMG
- en: How to save and load NumPy objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.save`, `np.savez`, `np.savetxt`, `np.load`, `np.loadtxt`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You will, at some point, want to save your arrays to disk and load them back
    without having to re-run the code. Fortunately, there are several ways to save
    and load objects with NumPy. The ndarray objects can be saved to and loaded from
    the disk files with `loadtxt` and `savetxt` functions that handle normal text
    files, `load` and `save` functions that handle NumPy binary files with a **.npy**
    file extension, and a `savez` function that handles NumPy files with a **.npz**
    file extension.
  prefs: []
  type: TYPE_NORMAL
- en: The **.npy** and **.npz** files store data, shape, dtype, and other information
    required to reconstruct the ndarray in a way that allows the array to be correctly
    retrieved, even when the file is on another machine with different architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to store a single ndarray object, store it as a .npy file using
    `np.save`. If you want to store more than one ndarray object in a single file,
    save it as a .npz file using `np.savez`. You can also save several arrays into
    a single file in compressed npz format with [`savez_compressed`](../reference/generated/numpy.savez_compressed.html#numpy.savez_compressed
    "numpy.savez_compressed").
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to save and load and array with `np.save()`. Just make sure to specify
    the array you want to save and a file name. For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'You can save it as “filename.npy” with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You can use `np.load()` to reconstruct your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check your array, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can save a NumPy array as a plain text file like a **.csv** or **.txt**
    file with `np.savetxt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily save it as a .csv file with the name “new_file.csv” like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly and easily load your saved text file using `loadtxt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The `savetxt()` and `loadtxt()` functions accept additional optional parameters
    such as header, footer, and delimiter. While text files can be easier for sharing,
    .npy and .npz files are smaller and faster to read. If you need more sophisticated
    handling of your text file (for example, if you need to work with lines that contain
    missing values), you will want to use the [`genfromtxt`](../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
    "numpy.genfromtxt") function.
  prefs: []
  type: TYPE_NORMAL
- en: With [`savetxt`](../reference/generated/numpy.savetxt.html#numpy.savetxt "numpy.savetxt"),
    you can specify headers, footers, comments, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about [input and output routines here](../reference/routines.io.html#routines-io).
  prefs: []
  type: TYPE_NORMAL
- en: Importing and exporting a CSV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s simple to read in a CSV that contains existing information. The best and
    easiest way to do this is to use [Pandas](https://pandas.pydata.org).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_pandas.png](../Images/64f7d414cb396c6af87ad816cef866d4.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s simple to use Pandas in order to export your array as well. If you are
    new to NumPy, you may want to create a Pandas dataframe from the values in your
    array and then write the data frame to a CSV file with Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: If you created this array “a”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: You could create a Pandas dataframe
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily save your dataframe with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'And read your CSV with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_readcsv.png](../Images/54f26b8b35c3ff479bfd7fda3a4bd02a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also save your array with the NumPy `savetxt` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using the command line, you can read your saved CSV any time with
    a command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Or you can open the file any time with a text editor!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about Pandas, take a look at the [official
    Pandas documentation](https://pandas.pydata.org/index.html). Learn how to install
    Pandas with the [official Pandas installation information](https://pandas.pydata.org/pandas-docs/stable/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: Plotting arrays with Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to generate a plot for your values, it’s very simple with [Matplotlib](https://matplotlib.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you may have an array like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have Matplotlib installed, you can import it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'All you need to do to plot your values is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib1.png](../Images/fd0bab5f04bbeea3c1f395dd60acebf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, you can plot a 1D array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib2.png](../Images/e5b8c25f89b1a0fc9a74365cf85f25de.png)'
  prefs: []
  type: TYPE_IMG
- en: With Matplotlib, you have access to an enormous number of visualization options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib3.png](../Images/2eb12f2635bf2c5c1844f13053f5bf52.png)'
  prefs: []
  type: TYPE_IMG
- en: To read more about Matplotlib and what it can do, take a look at [the official
    documentation](https://matplotlib.org/). For directions regarding installing Matplotlib,
    see the official [installation section](https://matplotlib.org/users/installing.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*Image credits: Jay Alammar http://jalammar.github.io/*'
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to NumPy!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy (**Numerical Python**) is an open source Python library that’s used in
    almost every field of science and engineering. It’s the universal standard for
    working with numerical data in Python, and it’s at the core of the scientific
    Python and PyData ecosystems. NumPy users include everyone from beginning coders
    to experienced researchers doing state-of-the-art scientific and industrial research
    and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib,
    scikit-learn, scikit-image and most other data science and scientific Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: The NumPy library contains multidimensional array and matrix data structures
    (you’ll find more information about this in later sections). It provides **ndarray**,
    a homogeneous n-dimensional array object, with methods to efficiently operate
    on it. NumPy can be used to perform a wide variety of mathematical operations
    on arrays. It adds powerful data structures to Python that guarantee efficient
    calculations with arrays and matrices and it supplies an enormous library of high-level
    mathematical functions that operate on these arrays and matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about [NumPy here](whatisnumpy.html#whatisnumpy)!
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install NumPy, we strongly recommend using a scientific Python distribution.
    If you’re looking for the full instructions for installing NumPy on your operating
    system, see [Installing NumPy](https://numpy.org/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have Python, you can install NumPy with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t have Python yet, you might want to consider using [Anaconda](https://www.anaconda.com/).
    It’s the easiest way to get started. The good thing about getting this distribution
    is the fact that you don’t need to worry too much about separately installing
    NumPy or any of the major packages that you’ll be using for your data analyses,
    like pandas, Scikit-Learn, etc.
  prefs: []
  type: TYPE_NORMAL
- en: How to import NumPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access NumPy and its functions import it in your Python code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: We shorten the imported name to `np` for better readability of code using NumPy.
    This is a widely adopted convention that makes your code more readable for everyone
    working on it. We recommend to always use import numpy as `np`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you aren’t already comfortable with reading tutorials that contain a lot
    of code, you might not know how to interpret a code block that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: If you aren’t familiar with this style, it’s very easy to understand. If you
    see `>>>`, you’re looking at **input**, or the code that you would enter. Everything
    that doesn’t have `>>>` in front of it is **output**, or the results of running
    your code. This is the style you see when you run `python` on the command line,
    but if you’re using IPython, you might see a different style. Note that it is
    not part of the code and will cause an error if typed or pasted into the Python
    shell. It can be safely typed or pasted into the IPython shell; the `>>>` is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between a Python list and a NumPy array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy gives you an enormous range of fast and efficient ways of creating arrays
    and manipulating numerical data inside them. While a Python list can contain different
    data types within a single list, all of the elements in a NumPy array should be
    homogeneous. The mathematical operations that are meant to be performed on arrays
    would be extremely inefficient if the arrays weren’t homogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why use NumPy?**'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays are faster and more compact than Python lists. An array consumes
    less memory and is convenient to use. NumPy uses much less memory to store data
    and it provides a mechanism of specifying the data types. This allows the code
    to be optimized even further.
  prefs: []
  type: TYPE_NORMAL
- en: What is an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a central data structure of the NumPy library. An array is a grid
    of values and it contains information about the raw data, how to locate an element,
    and how to interpret an element. It has a grid of elements that can be indexed
    in [various ways](quickstart.html#quickstart-indexing-slicing-and-iterating).
    The elements are all of the same type, referred to as the array `dtype`.
  prefs: []
  type: TYPE_NORMAL
- en: An array can be indexed by a tuple of nonnegative integers, by booleans, by
    another array, or by integers. The `rank` of the array is the number of dimensions.
    The `shape` of the array is a tuple of integers giving the size of the array along
    each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can initialize NumPy arrays is from Python lists, using nested lists
    for two- or higher-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We can access the elements in the array using square brackets. When you’re accessing
    elements, remember that indexing in NumPy starts at 0\. That means that if you
    want to access the first element in your array, you’ll be accessing element “0”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: More information about arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `1D array`, `2D array`, `ndarray`, `vector`, `matrix`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You might occasionally hear an array referred to as a “ndarray,” which is shorthand
    for “N-dimensional array.” An N-dimensional array is simply an array with any
    number of dimensions. You might also hear **1-D**, or one-dimensional array, **2-D**,
    or two-dimensional array, and so on. The NumPy `ndarray` class is used to represent
    both matrices and vectors. A **vector** is an array with a single dimension (there’s
    no difference between row and column vectors), while a **matrix** refers to an
    array with two dimensions. For **3-D** or higher dimensional arrays, the term
    **tensor** is also commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the attributes of an array?**'
  prefs: []
  type: TYPE_NORMAL
- en: An array is usually a fixed-size container of items of the same type and size.
    The number of dimensions and items in an array is defined by its shape. The shape
    of an array is a tuple of non-negative integers that specify the sizes of each
    dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In NumPy, dimensions are called **axes**. This means that if you have a 2D
    array that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Your array has 2 axes. The first axis has a length of 2 and the second axis
    has a length of 3.
  prefs: []
  type: TYPE_NORMAL
- en: Just like in other Python container objects, the contents of an array can be
    accessed and modified by indexing or slicing the array. Unlike the typical container
    objects, different arrays can share the same data, so changes made on one array
    might be visible in another.
  prefs: []
  type: TYPE_NORMAL
- en: Array **attributes** reflect information intrinsic to the array itself. If you
    need to get, or even set, properties of an array without creating a new array,
    you can often access an array through its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Read more about array attributes here](../reference/arrays.ndarray.html#arrays-ndarray)
    and learn about [array objects here](../reference/arrays.html#arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a basic array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.array()`, `np.zeros()`, `np.ones()`, `np.empty()`,
    `np.arange()`, `np.linspace()`, `dtype`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: To create a NumPy array, you can use the function `np.array()`.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do to create a simple array is pass a list to it. If you choose
    to, you can also specify the type of data in your list. [You can find more information
    about data types here](../reference/arrays.dtypes.html#arrays-dtypes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'You can visualize your array this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_array.png](../Images/aaf6808d845c7bcc478972e091442ab0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Be aware that these visualizations are meant to simplify ideas and give you
    a basic understanding of NumPy concepts and mechanics. Arrays and array operations
    are much more complicated than are captured here!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides creating an array from a sequence of elements, you can easily create
    an array filled with `0`’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Or an array filled with `1`’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Or even an empty array! The function `empty` creates an array whose initial
    content is random and depends on the state of the memory. The reason to use `empty`
    over `zeros` (or something similar) is speed - just make sure to fill every element
    afterwards!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create an array with a range of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: And even an array that contains a range of evenly spaced intervals. To do this,
    you will specify the **first number**, **last number**, and the **step size**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `np.linspace()` to create an array with values that are spaced
    linearly in a specified interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '**Specifying your data type**'
  prefs: []
  type: TYPE_NORMAL
- en: While the default data type is floating point (`np.float64`), you can explicitly
    specify which data type you want using the `dtype` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about creating arrays here](quickstart.html#quickstart-array-creation)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding, removing, and sorting elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.sort()`, `np.concatenate()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an element is simple with `np.sort()`. You can specify the axis, kind,
    and order when you call the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly sort the numbers in ascending order with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to sort, which returns a sorted copy of an array, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    which is an indirect sort along a specified axis,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    which is an indirect stable sort on multiple keys,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), which will find elements in a sorted array, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`partition`](../reference/generated/numpy.partition.html#numpy.partition "numpy.partition"),
    which is a partial sort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To read more about sorting an array, see: [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort").'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with these arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: You can concatenate them with `np.concatenate()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you start with these arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'You can concatenate them with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: In order to remove elements from an array, it’s simple to use indexing to select
    the elements that you want to keep.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read more about concatenate, see: [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate").'
  prefs: []
  type: TYPE_NORMAL
- en: How do you know the shape and size of an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `ndarray.ndim`, `ndarray.size`, `ndarray.shape`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.ndim` will tell you the number of axes, or dimensions, of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.size` will tell you the total number of elements of the array. This
    is the *product* of the elements of the array’s shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.shape` will display a tuple of integers that indicate the number of
    elements stored along each dimension of the array. If, for example, you have a
    2-D array with 2 rows and 3 columns, the shape of your array is `(2, 3)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the number of dimensions of the array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the total number of elements in the array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'And to find the shape of your array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Can you reshape an array?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `arr.reshape()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yes!**'
  prefs: []
  type: TYPE_NORMAL
- en: Using `arr.reshape()` will give a new shape to an array without changing the
    data. Just remember that when you use the reshape method, the array you want to
    produce needs to have the same number of elements as the original array. If you
    start with an array with 12 elements, you’ll need to make sure that your new array
    also has a total of 12 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `reshape()` to reshape your array. For example, you can reshape
    this array to an array with three rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'With `np.reshape`, you can specify a few optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is the array to be reshaped.'
  prefs: []
  type: TYPE_NORMAL
- en: '`newshape` is the new shape you want. You can specify an integer or a tuple
    of integers. If you specify an integer, the result will be an array of that length.
    The shape should be compatible with the original shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '`order:` `C` means to read/write the elements using C-like index order, `F`
    means to read/write the elements using Fortran-like index order, `A` means to
    read/write the elements in Fortran-like index order if a is Fortran contiguous
    in memory, C-like order otherwise. (This is an optional parameter and doesn’t
    need to be specified.)'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about C and Fortran order, you can [read more about
    the internal organization of NumPy arrays here](../dev/internals.html#numpy-internals).
    Essentially, C and Fortran orders have to do with how indices correspond to the
    order the array is stored in memory. In Fortran, when moving through the elements
    of a two-dimensional array as it is stored in memory, the **first** index is the
    most rapidly varying index. As the first index moves to the next row as it changes,
    the matrix is stored one column at a time. This is why Fortran is thought of as
    a **Column-major language**. In C on the other hand, the **last** index changes
    the most rapidly. The matrix is stored by rows, making it a **Row-major language**.
    What you do for C or Fortran depends on whether it’s more important to preserve
    the indexing convention or not reorder the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about shape manipulation here](quickstart.html#quickstart-shape-manipulation).'
  prefs: []
  type: TYPE_NORMAL
- en: How to convert a 1D array into a 2D array (how to add a new axis to an array)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.newaxis`, `np.expand_dims`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `np.newaxis` and `np.expand_dims` to increase the dimensions of
    your existing array.
  prefs: []
  type: TYPE_NORMAL
- en: Using `np.newaxis` will increase the dimensions of your array by one dimension
    when used once. This means that a **1D** array will become a **2D** array, a **2D**
    array will become a **3D** array, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.newaxis` to add a new axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'You can explicitly convert a 1D array with either a row vector or a column
    vector using `np.newaxis`. For example, you can convert a 1D array to a row vector
    by inserting an axis along the first dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, for a column vector, you can insert an axis along the second dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: You can also expand an array by inserting a new axis at a specified position
    with `np.expand_dims`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.expand_dims` to add an axis at index position 1 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add an axis at index position 0 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Find more information about [newaxis here](../reference/arrays.indexing.html#arrays-indexing)
    and `expand_dims` at [`expand_dims`](../reference/generated/numpy.expand_dims.html#numpy.expand_dims
    "numpy.expand_dims").
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can index and slice NumPy arrays in the same ways you can slice Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'You can visualize it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_indexing.png](../Images/cd29651900916a5a0f06923d997eca93.png)'
  prefs: []
  type: TYPE_IMG
- en: You may want to take a section of your array or specific array elements to use
    in further analysis or additional operations. To do that, you’ll need to subset,
    slice, and/or index your arrays.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to select values from your array that fulfill certain conditions,
    it’s straightforward with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: You can easily print all of the values in the array that are less than 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: You can also select, for example, numbers that are equal to or greater than
    5, and use that condition to index an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select elements that are divisible by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can select elements that satisfy two conditions using the `&` and `|`
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: You can also make use of the logical operators **&** and **|** in order to return
    boolean values that specify whether or not the values in an array fulfill a certain
    condition. This can be useful with arrays that contain names or other categorical
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `np.nonzero()` to select elements or indices from an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `np.nonzero()` to print the indices of elements that are, for example,
    less than 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, a tuple of arrays was returned: one for each dimension. The
    first array represents the row indices where these values are found, and the second
    array represents the column indices where the values are found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to generate a list of coordinates where the elements exist, you
    can zip the arrays, iterate over the list of coordinates, and print them. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `np.nonzero()` to print the elements in an array that are
    less than 5 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'If the element you’re looking for doesn’t exist in the array, then the returned
    array of indices will be empty. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Learn more about [indexing and slicing here](quickstart.html#quickstart-indexing-slicing-and-iterating)
    and [here](basics.indexing.html#basics-indexing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about using the nonzero function at: [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero").'
  prefs: []
  type: TYPE_NORMAL
- en: How to create an array from existing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `slicing and indexing`, `np.vstack()`, `np.hstack()`,
    `np.hsplit()`, `.view()`, `copy()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can easily create a new array from a section of an existing array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: You can create a new array from a section of your array any time by specifying
    where you want to slice your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Here, you grabbed a section of your array from index position 3 through index
    position 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also stack two existing arrays, both vertically and horizontally. Let’s
    say you have two arrays, `a1` and `a2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stack them vertically with `vstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Or stack them horizontally with `hstack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: You can split an array into several smaller arrays using `hsplit`. You can specify
    either the number of equally shaped arrays to return or the columns *after* which
    the division should occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to split this array into three equally shaped arrays, you would
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to split your array after the third and fourth column, you’d
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about stacking and splitting arrays here](quickstart.html#quickstart-stacking-arrays).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `view` method to create a new array object that looks at the
    same data as the original array (a *shallow copy*).
  prefs: []
  type: TYPE_NORMAL
- en: Views are an important NumPy concept! NumPy functions, as well as operations
    like indexing and slicing, will return views whenever possible. This saves memory
    and is faster (no copy of the data has to be made). However it’s important to
    be aware of this - modifying data in a view also modifies the original array!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Now we create an array `b1` by slicing `a` and modify the first element of `b1`.
    This will modify the corresponding element in `a` as well!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `copy` method will make a complete copy of the array and its data
    (a *deep copy*). To use this on your array, you could run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about copies and views here](quickstart.html#quickstart-copies-and-views).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic array operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers addition, subtraction, multiplication, division, and more*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created your arrays, you can start to work with them. Let’s say,
    for example, that you’ve created two arrays, one called “data” and one called
    “ones”
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_array_dataones.png](../Images/9b59cfcd5bef02a4f4038fabe093cf23.png)'
  prefs: []
  type: TYPE_IMG
- en: You can add the arrays together with the plus sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_data_plus_ones.png](../Images/66d39b9fac255980e503123485c0444f.png)'
  prefs: []
  type: TYPE_IMG
- en: You can, of course, do more than just addition!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_sub_mult_divide.png](../Images/c1f77f532a2c7d29d2aee60956b2d967.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic operations are simple with NumPy. If you want to find the sum of the elements
    in an array, you’d use `sum()`. This works for 1D arrays, 2D arrays, and arrays
    in higher dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: To add the rows or the columns in a 2D array, you would specify the axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sum over the axis of rows with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'You can sum over the axis of columns with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[Learn more about basic operations here](quickstart.html#quickstart-basic-operations).'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when you might want to carry out an operation between an array
    and a single number (also called *an operation between a vector and a scalar*)
    or between arrays of two different sizes. For example, your array (we’ll call
    it “data”) might contain information about distance in miles but you want to convert
    the information to kilometers. You can perform this operation with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_multiply_broadcasting.png](../Images/11c558ec6f5400f721ced3df1869a30c.png)'
  prefs: []
  type: TYPE_IMG
- en: NumPy understands that the multiplication should happen with each cell. That
    concept is called **broadcasting**. Broadcasting is a mechanism that allows NumPy
    to perform operations on arrays of different shapes. The dimensions of your array
    must be compatible, for example, when the dimensions of both arrays are equal
    or when one of them is 1\. If the dimensions are not compatible, you will get
    a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Learn more about broadcasting here](basics.broadcasting.html#basics-broadcasting).'
  prefs: []
  type: TYPE_NORMAL
- en: More useful array operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers maximum, minimum, sum, mean, product, standard deviation,
    and more*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy also performs aggregation functions. In addition to `min`, `max`, and
    `sum`, you can easily run `mean` to get the average, `prod` to get the result
    of multiplying the elements together, `std` to get the standard deviation, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_aggregation.png](../Images/2c41632a337fac537f465483e8f74817.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s start with this array, called “a”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s very common to want to aggregate along a row or column. By default, every
    NumPy aggregation function will return the aggregate of the entire array. To find
    the sum or the minimum of the elements in your array, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: You can specify on which axis you want the aggregation function to be computed.
    For example, you can find the minimum value within each column by specifying `axis=0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The four values listed above correspond to the number of columns in your array.
    With a four-column array, you will get four values as your result.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about [array methods here](../reference/arrays.ndarray.html#array-ndarray-methods).
  prefs: []
  type: TYPE_NORMAL
- en: Creating matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can pass Python lists of lists to create a 2-D array (or “matrix”) to represent
    them in NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_create_matrix.png](../Images/f0baeb2fd5bf39ba6f39a0bcd76f27cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Indexing and slicing operations are useful when you’re manipulating matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_indexing.png](../Images/18d8f5ed53ce3c532bdf9819f566656a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can aggregate matrices the same way you aggregated vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_aggregation.png](../Images/54fae10b03421e1cccc2bffe511a58b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can aggregate all the values in a matrix and you can aggregate them across
    columns or rows using the `axis` parameter. To illustrate this point, let’s look
    at a slightly modified dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_aggregation_row.png](../Images/0c528d4cd2dab05f6959a98c3ee1be32.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve created your matrices, you can add and multiply them using arithmetic
    operators if you have two matrices that are the same size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_arithmetic.png](../Images/3b22b1779686234e77a7e0898013d8e8.png)'
  prefs: []
  type: TYPE_IMG
- en: You can do these arithmetic operations on matrices of different sizes, but only
    if one matrix has only one column or one row. In this case, NumPy will use its
    broadcast rules for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_matrix_broadcasting.png](../Images/0fa020c3b7055d29a2c34c8ca85295db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Be aware that when NumPy prints N-dimensional arrays, the last axis is looped
    over the fastest while the first axis is the slowest. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'There are often instances where we want NumPy to initialize the values of an
    array. NumPy offers functions like `ones()` and `zeros()`, and the `random.Generator`
    class for random number generation for that. All you need to do is pass in the
    number of elements you want it to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_ones_zeros_random.png](../Images/86d5e6196bdd4ee9106eaf83b61fe57a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use `ones()`, `zeros()`, and `random()` to create a 2D array if
    you give them a tuple describing the dimensions of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_ones_zeros_matrix.png](../Images/eec8e0a2353993e5f66abe64767dbd8a.png)'
  prefs: []
  type: TYPE_IMG
- en: Read more about creating arrays, filled with `0`’s, `1`’s, other values or uninitialized,
    at [array creation routines](../reference/routines.array-creation.html#routines-array-creation).
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of random number generation is an important part of the configuration
    and evaluation of many numerical and machine learning algorithms. Whether you
    need to randomly initialize weights in an artificial neural network, split data
    into random sets, or randomly shuffle your dataset, being able to generate random
    numbers (actually, repeatable pseudo-random numbers) is essential.
  prefs: []
  type: TYPE_NORMAL
- en: With `Generator.integers`, you can generate random integers from low (remember
    that this is inclusive with NumPy) to high (exclusive). You can set `endpoint=True`
    to make the high number inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate a 2 x 4 array of random integers between 0 and 4 with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[Read more about random number generation here](../reference/random/index.html#numpyrandom).'
  prefs: []
  type: TYPE_NORMAL
- en: How to get unique items and counts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.unique()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the unique elements in an array easily with `np.unique`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'you can use `np.unique` to print the unique values in your array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: To get the indices of unique values in a NumPy array (an array of first index
    positions of unique values in the array), just pass the `return_index` argument
    in `np.unique()` as well as your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: You can pass the `return_counts` argument in `np.unique()` along with your array
    to get the frequency count of unique values in a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works with 2D arrays! If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find unique values with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: If the axis argument isn’t passed, your 2D array will be flattened.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get the unique rows or columns, make sure to pass the `axis`
    argument. To find the unique rows, specify `axis=0` and for columns, specify `axis=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the unique rows, index position, and occurrence count, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about finding the unique elements in an array, see [`unique`](../reference/generated/numpy.unique.html#numpy.unique
    "numpy.unique").
  prefs: []
  type: TYPE_NORMAL
- en: Transposing and reshaping a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `arr.reshape()`, `arr.transpose()`, `arr.T`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to need to transpose your matrices. NumPy arrays have the property
    `T` that allows you to transpose a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_transposing_reshaping.png](../Images/90ef6ecf8374753450db871d206d21f1.png)'
  prefs: []
  type: TYPE_IMG
- en: You may also need to switch the dimensions of a matrix. This can happen when,
    for example, you have a model that expects a certain input shape that is different
    from your dataset. This is where the `reshape` method can be useful. You simply
    need to pass in the new dimensions that you want for the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_reshape.png](../Images/2f1382886687a1a2177b527ec1527b58.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also use `.transpose()` to reverse or change the axes of an array according
    to the values you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: You can transpose your array with `arr.transpose()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `arr.T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about transposing and reshaping arrays, see [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose") and [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape").
  prefs: []
  type: TYPE_NORMAL
- en: How to reverse an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.flip()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy’s `np.flip()` function allows you to flip, or reverse, the contents of
    an array along an axis. When using `np.flip()`, specify the array you would like
    to reverse and the axis. If you don’t specify the axis, NumPy will reverse the
    contents along all of the axes of your input array.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversing a 1D array**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you begin with a 1D array like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reverse it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to print your reversed array, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '**Reversing a 2D array**'
  prefs: []
  type: TYPE_NORMAL
- en: A 2D array works much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reverse the content in all of the rows and all of the columns with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily reverse only the *rows* with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'Or reverse only the *columns* with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reverse the contents of only one column or row. For example, you
    can reverse the contents of the row at index position 1 (the second row):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reverse the column at index position 1 (the second column):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Read more about reversing arrays at [`flip`](../reference/generated/numpy.flip.html#numpy.flip
    "numpy.flip").
  prefs: []
  type: TYPE_NORMAL
- en: Reshaping and flattening multidimensional arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `.flatten()`, `ravel()`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two popular ways to flatten an array: `.flatten()` and `.ravel()`.
    The primary difference between the two is that the new array created using `ravel()`
    is actually a reference to the parent array (i.e., a “view”). This means that
    any changes to the new array will affect the parent array as well. Since `ravel`
    does not create a copy, it’s memory efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start with this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: You can use `flatten` to flatten your array into a 1D array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: When you use `flatten`, changes to your new array won’t change the parent array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: But when you use `ravel`, the changes you make to the new array will affect
    the parent array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Read more about `flatten` at [`ndarray.flatten`](../reference/generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") and `ravel` at [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel").
  prefs: []
  type: TYPE_NORMAL
- en: How to access the docstring for more information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `help()`, `?`, `??`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the data science ecosystem, Python and NumPy are built with
    the user in mind. One of the best examples of this is the built-in access to documentation.
    Every object contains the reference to a string, which is known as the **docstring**.
    In most cases, this docstring contains a quick and concise summary of the object
    and how to use it. Python has a built-in `help()` function that can help you access
    this information. This means that nearly any time you need more information, you
    can use `help()` to quickly find the information that you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Because access to additional information is so useful, IPython uses the `?`
    character as a shorthand for accessing this documentation along with other relevant
    information. IPython is a command shell for interactive computing in multiple
    languages. [You can find more information about IPython here](https://ipython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: You can even use this notation for object methods and objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can obtain a lot of useful information (first details about `a` itself,
    followed by the docstring of `ndarray` of which `a` is an instance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: This also works for functions and other objects that **you** create. Just remember
    to include a docstring with your function using a string literal (`""" """` or
    `''' '''` around your documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain information about the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: You can reach another level of information by reading the source code of the
    object you’re interested in. Using a double question mark (`??`) allows you to
    access the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'If the object in question is compiled in a language other than Python, using
    `??` will return the same information as `?`. You’ll find this with a lot of built-in
    objects and types, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'and :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: have the same output because they were compiled in a programming language other
    than Python.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mathematical formulas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ease of implementing mathematical formulas that work on arrays is one of
    the things that make NumPy so widely used in the scientific Python community.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is the mean square error formula (a central formula used
    in supervised machine learning models that deal with regression):'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_MSE_formula.png](../Images/b9475c62996a78fe826723abd6d7dbe8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementing this formula is simple and straightforward in NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_MSE_implementation.png](../Images/01cd11db569040a346561a5cfc3bf23a.png)'
  prefs: []
  type: TYPE_IMG
- en: What makes this work so well is that `predictions` and `labels` can contain
    one or a thousand values. They only need to be the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visualize it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_mse_viz1.png](../Images/a8dbf015be4eaea56890409cc1ac99ce.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, both the predictions and labels vectors contain three values,
    meaning `n` has a value of three. After we carry out subtractions the values in
    the vector are squared. Then NumPy sums the values, and your result is the error
    value for that prediction and a score for the quality of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/np_mse_viz2.png](../Images/a6678fbe867a803aa7d00ee7a4463e8b.png)
    ![../_images/np_MSE_explanation2.png](../Images/f167374d2ba2c45f5a4f4410c9076603.png)'
  prefs: []
  type: TYPE_IMG
- en: How to save and load NumPy objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*This section covers* `np.save`, `np.savez`, `np.savetxt`, `np.load`, `np.loadtxt`'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: You will, at some point, want to save your arrays to disk and load them back
    without having to re-run the code. Fortunately, there are several ways to save
    and load objects with NumPy. The ndarray objects can be saved to and loaded from
    the disk files with `loadtxt` and `savetxt` functions that handle normal text
    files, `load` and `save` functions that handle NumPy binary files with a **.npy**
    file extension, and a `savez` function that handles NumPy files with a **.npz**
    file extension.
  prefs: []
  type: TYPE_NORMAL
- en: The **.npy** and **.npz** files store data, shape, dtype, and other information
    required to reconstruct the ndarray in a way that allows the array to be correctly
    retrieved, even when the file is on another machine with different architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to store a single ndarray object, store it as a .npy file using
    `np.save`. If you want to store more than one ndarray object in a single file,
    save it as a .npz file using `np.savez`. You can also save several arrays into
    a single file in compressed npz format with [`savez_compressed`](../reference/generated/numpy.savez_compressed.html#numpy.savez_compressed
    "numpy.savez_compressed").
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to save and load and array with `np.save()`. Just make sure to specify
    the array you want to save and a file name. For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'You can save it as “filename.npy” with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: You can use `np.load()` to reconstruct your array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check your array, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: You can save a NumPy array as a plain text file like a **.csv** or **.txt**
    file with `np.savetxt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you create this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily save it as a .csv file with the name “new_file.csv” like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'You can quickly and easily load your saved text file using `loadtxt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: The `savetxt()` and `loadtxt()` functions accept additional optional parameters
    such as header, footer, and delimiter. While text files can be easier for sharing,
    .npy and .npz files are smaller and faster to read. If you need more sophisticated
    handling of your text file (for example, if you need to work with lines that contain
    missing values), you will want to use the [`genfromtxt`](../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
    "numpy.genfromtxt") function.
  prefs: []
  type: TYPE_NORMAL
- en: With [`savetxt`](../reference/generated/numpy.savetxt.html#numpy.savetxt "numpy.savetxt"),
    you can specify headers, footers, comments, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about [input and output routines here](../reference/routines.io.html#routines-io).
  prefs: []
  type: TYPE_NORMAL
- en: Importing and exporting a CSV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s simple to read in a CSV that contains existing information. The best and
    easiest way to do this is to use [Pandas](https://pandas.pydata.org).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_pandas.png](../Images/64f7d414cb396c6af87ad816cef866d4.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s simple to use Pandas in order to export your array as well. If you are
    new to NumPy, you may want to create a Pandas dataframe from the values in your
    array and then write the data frame to a CSV file with Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: If you created this array “a”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: You could create a Pandas dataframe
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily save your dataframe with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'And read your CSV with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/np_readcsv.png](../Images/54f26b8b35c3ff479bfd7fda3a4bd02a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also save your array with the NumPy `savetxt` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using the command line, you can read your saved CSV any time with
    a command such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Or you can open the file any time with a text editor!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in learning more about Pandas, take a look at the [official
    Pandas documentation](https://pandas.pydata.org/index.html). Learn how to install
    Pandas with the [official Pandas installation information](https://pandas.pydata.org/pandas-docs/stable/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: Plotting arrays with Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to generate a plot for your values, it’s very simple with [Matplotlib](https://matplotlib.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you may have an array like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have Matplotlib installed, you can import it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'All you need to do to plot your values is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib1.png](../Images/fd0bab5f04bbeea3c1f395dd60acebf0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, you can plot a 1D array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib2.png](../Images/e5b8c25f89b1a0fc9a74365cf85f25de.png)'
  prefs: []
  type: TYPE_IMG
- en: With Matplotlib, you have access to an enormous number of visualization options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/matplotlib3.png](../Images/2eb12f2635bf2c5c1844f13053f5bf52.png)'
  prefs: []
  type: TYPE_IMG
- en: To read more about Matplotlib and what it can do, take a look at [the official
    documentation](https://matplotlib.org/). For directions regarding installing Matplotlib,
    see the official [installation section](https://matplotlib.org/users/installing.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*Image credits: Jay Alammar http://jalammar.github.io/*'
  prefs: []
  type: TYPE_NORMAL
