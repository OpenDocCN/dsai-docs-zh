- en: Find the Roots of a Polynomial Algebraically or Numerically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html](https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use SymPy to find the roots of a univariate polynomial algebraically. For example,
    finding the roots of \(ax^2 + bx + c\) for \(x\) yields \(x = \frac{-b\pm\sqrt{b^2
    - 4ac}}{2a}\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Consider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need a numeric (rather than algebraic) solution, you can use either
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)")
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy’s [`root()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "(in SciPy v1.13.1)")
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to solve systems of polynomial equations algebraically, use [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example of Finding the Roots of a Polynomial Algebraically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of finding the roots of a polynomial algebraically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example reproduces the [quadratic formula](https://en.wikipedia.org/wiki/Quadratic_formula).
  prefs: []
  type: TYPE_NORMAL
- en: Functions to Find the Roots of a Polynomial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several functions that you can use to find the roots of a polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") is a general solving function which can find roots,
    though is less efficient than [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") and is the only function in this list
    that does not convey the multiplicity of roots; [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") also works on [non-polynomial equations](solve-equation-algebraically.html)
    and [systems of non-polynomial equations](solve-system-of-equations-algebraically.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") computes the symbolic roots of a univariate polynomial;
    will fail for most high-degree polynomials (five or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") computes numerical approximations of the roots
    of any polynomial whose coefficients can be numerically evaluated, whether the
    coefficients are rational or irrational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can represent all the roots exactly of a polynomial
    of arbitrarily large degree, as long as the coefficients are rational numbers.
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can avoid both ill-conditioning and returning
    spurious complex parts because it uses a more exact, but much slower, numerical
    algorithm based on isolating intervals. The following two functions use [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") so they have the same properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") can find all the real roots exactly of a polynomial
    of arbitrarily large degree; because it finds only the real roots, it can be more
    efficient than functions that find all roots.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") can find all the roots exactly of a polynomial
    of arbitrarily large degree'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") factors a polynomial into irreducibles and can
    reveal that roots lie in the coefficient ring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each will be used on this page.
  prefs: []
  type: TYPE_NORMAL
- en: Guidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Include the Variable to be Solved for in the Function Call](solving-guidance.html#include-the-variable-to-be-solved-for-in-the-function-call)
    and [Use Exact Values](solving-guidance.html#use-exact-values).
  prefs: []
  type: TYPE_NORMAL
- en: Find the Roots of a Polynomial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the roots of a polynomial algebraically in several ways. The one
    to use depends on whether you
  prefs: []
  type: TYPE_NORMAL
- en: want an algebraic or numeric answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: want the multiplicity of each root (how many times each root is a solution).
    In the `expression` below representing \((x+2)^2(x-3)\), the root -2 has a multiplicity
    of two because \(x+2\) is squared, whereas 3 has a multiplicity of one because
    \(x-3\) has no exponent. Similarly, for the `symbolic` expression, the root \(-a\)
    has a multiplicity of two and the root \(b\) has a multiplicity of one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Algebraic Solution Without Root Multiplicities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use SymPy’s standard [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") function, though it will not return the multiplicity
    of roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will first try using [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots"); if that doesn’t work, it will try using [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots"). For cubics (third-degree polynomials)
    and quartics (fourth-degree polynomials), that means that [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will use radical formulae from roots rather than
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") even if RootOf is possible. The cubic and quartic
    formulae often give very complex expressions that are not useful in practice.
    As a result, you may want to set the [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") parameter `cubics` or `quartics` to `False` to
    return [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the first root from [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") in standard mathematical notation emphasizes how
    complex it is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[- \frac{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}
    + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}{2} - \frac{\sqrt{- 2 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}} - \frac{2}{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}}} + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}
    - \frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}}{2}\]
  prefs: []
  type: TYPE_NORMAL
- en: Further, there is no general radical formula for quintics (fifth degree) or
    higher polynomials, so their [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") representations may be the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Solve an Equation Algebraically](solve-equation-algebraically.html)
    for more about using [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve").
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Solution With Root Multiplicities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`roots`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") can give explicit expressions for the roots of
    polynomials that have symbolic coefficients (that is, if there are symbols in
    the coefficients) if [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") does not reveal them. However, it may fail for
    some polynomials. Here are examples of [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It returns results as a dictionary, where the key is the root (for example,
    -2) and the value is the multiplicity of that root (for example, 2).
  prefs: []
  type: TYPE_NORMAL
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") function uses a combination of techniques (factorization,
    decomposition, radical formulae) to find expressions in radicals if possible for
    the roots. When it can find some radical expressions for the roots, it returns
    them along with their multiplicity. This function will fail for most high-degree
    polynomials (five or greater) because they do not have radical solutions, and
    there is no guarantee that they have closed-form solutions at all, as explained
    by the [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).'
  prefs: []
  type: TYPE_NORMAL
- en: Factor the Equation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A different approach is to factor a polynomial using [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor"), which does not give the roots directly but can
    give you simpler expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") can also factorize a polynomial in a given [polynomial
    ring](../../modules/polys/basics.html#polys-ring) which can reveal roots lie in
    the coefficient ring. For example, if the polynomial has rational coefficients,
    then [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") will reveal any rational roots. If the coefficients
    are polynomials involving, for example, symbol \(a\) with rational coefficients
    then any roots that are polynomial functions of \(a\) with rational coefficients
    will be revealed. In this example, [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") reveals that \(x = a^2\) and \(x = -a^3 - a\)
    are roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Exact Numeric Solution With Root Multiplicities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`real_roots`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the roots to your polynomial are real, using [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") ensures that only real (not complex or imaginary)
    roots will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") calls [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf"), so for equations whose roots are all real,
    you can get the same results by iterating over the number of roots of your equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Approximate Numeric Solution With Root Multiplicities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nroots`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") gives an approximate numerical approximation to
    the roots of a polynomial. This example demonstrates that it can include numerical
    noise, for example a (negligible) imaginary component in what should be a real
    root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want numeric approximations of the real roots, but you want to know
    exactly which roots are real, then the best method is [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") with [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") is analogous to NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)") function. Usually the difference between these two is that
    [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots "sympy.polys.polytools.nroots")
    is more accurate but slower.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A major advantage of [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") is that it can compute numerical approximations
    of the roots of any polynomial whose coefficients can be numerically evaluated
    with [`evalf()`](../../modules/core.html#module-sympy.core.evalf "sympy.core.evalf")
    (that is, they do not have free symbols). Contrarily, symbolic solutions may not
    be possible for higher-order (fifth or greater) polynomials as explained by the
    [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).
    Even if closed-form solutions are available, they may have so many terms that
    they are not useful in practice. You may therefore want to use [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") to find approximate numeric solutions even if
    closed-form symbolic solutions are available. For example, the closed-form roots
    of a fourth-order (quartic) polynomial may be rather complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'so you may prefer an approximate numerical solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") can fail sometimes for polynomials that are numerically
    ill conditioned, for example [Wilkinson’s polynomial](https://en.wikipedia.org/wiki/Wilkinson%27s_polynomial).
    Using [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") and [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf") as described in [Numerically Evaluate CRootOf Roots](#numerically-evaluate-crootof-roots)
    can avoid both ill-conditioning and returning spurious complex parts because it
    uses a more exact, but much slower, numerical algorithm based on isolating intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: Complex Roots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For complex roots, similar functions can be used, for example [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the constants are symbolic, you may need to specify their domain for SymPy
    to recognize that the solutions are not real. For example, specifying that \(a\)
    is positive leads to imaginary roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") will also find imaginary or complex roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") will also return complex roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") will return only the real roots.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An advantage of [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") is that it can be more efficient than generating
    all the roots: [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can be slow for complex roots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make the expression into a polynomial class [`Poly`](../../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly"), you can use its [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") method to find the roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Use the Solution Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way to extract solutions from the result depends on the form of the result.
  prefs: []
  type: TYPE_NORMAL
- en: List (`all_roots`, `real_roots`, `nroots`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use standard Python list traversal techniques such as looping. Here,
    we substitute each root into the expression to verify that the result is \(0\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: List of dictionaries (`solve`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to [Use the Solution Result](solve-equation-algebraically.html#use-the-solution-result).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary (`roots`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use standard Python list traversal techniques such as looping through
    the keys and values in a dictionary. Here we print the value and multiplicity
    of each root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Expression (`factor`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can manipulate an algebraic expression using various SymPy techniques,
    for example substituting in a symbolic or numeric value for \(x\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tradeoffs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mathematical Exactness, Completeness of List of Roots, and Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the high-order polynomial \(x^5 - x + 1 = 0\). [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") returns numerical approximations to all five roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") can sometimes return only a subset of the roots
    or nothing if it can’t express any roots in radicals. In this case, it returns
    no roots (an empty set):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you set the flag `strict=True`, [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") will inform you that all roots cannot be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Get All Roots, Perhaps Implicitly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will return all five roots as `CRootOf` ([`ComplexRootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")) class members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where the second argument in each `CRootOf` is the index of the root.
  prefs: []
  type: TYPE_NORMAL
- en: Numerically Evaluate `CRootOf` Roots
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can then numerically evaluate those `CRootOf` roots using `n` from [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are only interested in the sole real root, it is faster to use [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") because it will not attempt to find the complex
    roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Representing Roots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf"), [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots"), and [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") can find all the roots exactly of a polynomial
    of arbitrarily large degree despite the [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).
    Those functions allow the roots to be categorized precisely and manipulated symbolically.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the roots have been found exactly, their properties can be determined
    free of numerical noise. For example, we can tell whether roots are real or not.
    If we request the [`conjugate()`](../../modules/core.html#sympy.core.expr.Expr.conjugate
    "sympy.core.expr.Expr.conjugate") (same real part and imaginary part with opposite
    sign) of a root, for example `r1`, and that is exactly equal to another root `r2`,
    that root `r2` will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will also give the complex roots where possible
    but it is less efficient than using [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") exactly represents the root in a way that can
    be manipulated symbolically, and computed to arbitrary precision. The [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") representation makes it possible to precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute all roots of a polynomial with exact rational coefficients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide exactly the multiplicity of every root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine exactly whether roots are real or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order the real and complex roots precisely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know which roots are complex conjugate pairs of each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine precisely which roots are rational vs irrational.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Represent every possible algebraic number exactly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other numerical methods such NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)"), [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots"), and [`nsolve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve
    "sympy.solvers.solvers.nsolve") cannot do any of these things robustly, if at
    all. Similarly, when numerically evaluated using [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"), the radical expressions returned by [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") or [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") cannot do these things robustly.
  prefs: []
  type: TYPE_NORMAL
- en: Not All Equations Can Be Solved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equations With No Closed-Form Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned above, higher-order polynomials (fifth or greater) are unlikely
    to have closed-form solutions, so you may have to represent them using, for example,
    [`RootOf` as described above](#representing-roots), or use a numerical method
    such as [`nroots` as described above](#nroots).
  prefs: []
  type: TYPE_NORMAL
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you encounter a bug with these commands, please post the problem on the [SymPy
    mailing list](https://groups.google.com/g/sympy). Until the issue is resolved,
    you can use another of the [Functions to Find the Roots of a Polynomial](#functions-to-find-the-roots-of-a-polynomial)
    or try one of the [Alternatives to Consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
