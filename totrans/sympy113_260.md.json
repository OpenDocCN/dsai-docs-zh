["```py\n     Basic\n        |\n        Atom\n        |\n        Number\n        |\n    Rational \n    ```", "```py\n    p._print(expr)\n    |\n    |-- p._print_Rational(expr)\n    |\n    |-- p._print_Number(expr)\n    |\n    |-- p._print_Atom(expr)\n    |\n    `-- p._print_Basic(expr) \n    ```", "```py\nfrom sympy.core.symbol import Symbol\nfrom sympy.printing.latex import LatexPrinter, print_latex\nfrom sympy.core.function import UndefinedFunction, Function\n\nclass MyLatexPrinter(LatexPrinter):\n  \"\"\"Print derivative of a function of symbols in a shorter form.\n \"\"\"\n    def _print_Derivative(self, expr):\n        function, *vars = expr.args\n        if not isinstance(type(function), UndefinedFunction) or \\\n           not all(isinstance(i, Symbol) for i in vars):\n            return super()._print_Derivative(expr)\n\n        # If you want the printer to work correctly for nested\n        # expressions then use self._print() instead of str() or latex().\n        # See the example of nested modulo below in the custom printing\n        # method section.\n        return \"{}_{{{}}}\".format(\n            self._print(Symbol(function.func.__name__)),\n                        ''.join(self._print(i) for i in vars))\n\ndef print_my_latex(expr):\n  \"\"\" Most of the printers define their own wrappers for print().\n These wrappers usually take printer settings. Our printer does not have\n any settings.\n \"\"\"\n    print(MyLatexPrinter().doprint(expr))\n\ny = Symbol(\"y\")\nx = Symbol(\"x\")\nf = Function(\"f\")\nexpr = f(x, y).diff(x, y)\n\n# Print the expression using the normal latex printer and our custom\n# printer.\nprint_latex(expr)\nprint_my_latex(expr) \n```", "```py\n\\frac{\\partial^{2}}{\\partial x\\partial y}  f{\\left(x,y \\right)}\nf_{xy} \n```", "```py\n>>> from sympy import Symbol, Mod, Integer, print_latex \n```", "```py\n>>> # Always use printer._print()\n>>> class ModOp(Mod):\n...     def _latex(self, printer):\n...         a, b = [printer._print(i) for i in self.args]\n...         return r\"\\operatorname{Mod}{\\left(%s, %s\\right)}\" % (a, b) \n```", "```py\n>>> x = Symbol('x')\n>>> m = Symbol('m')\n>>> print_latex(Mod(x, m))\nx \\bmod m\n>>> print_latex(ModOp(x, m))\n\\operatorname{Mod}{\\left(x, m\\right)} \n```", "```py\n    >>> # This example does not work properly, as only the outermost call may use\n    >>> # doprint.\n    >>> class ModOpModeWrong(Mod):\n    ...     def _latex(self, printer):\n    ...         a, b = [printer.doprint(i) for i in self.args]\n    ...         return r\"\\operatorname{Mod}{\\left(%s, %s\\right)}\" % (a, b) \n    ```", "```py\n    >>> print_latex(ModOp(x, m), mode='inline')  # ok\n    $\\operatorname{Mod}{\\left(x, m\\right)}$\n    >>> print_latex(ModOpModeWrong(x, m), mode='inline')  # bad\n    $\\operatorname{Mod}{\\left($x$, $m$\\right)}$ \n    ```", "```py\n    >>> class ModOpNestedWrong(Mod):\n    ...     def _latex(self, printer):\n    ...         a, b = [str(i) for i in self.args]\n    ...         return r\"\\operatorname{Mod}{\\left(%s, %s\\right)}\" % (a, b) \n    ```", "```py\n    >>> # Nested modulo.\n    >>> print_latex(ModOp(ModOp(x, m), Integer(7)))  # ok\n    \\operatorname{Mod}{\\left(\\operatorname{Mod}{\\left(x, m\\right)}, 7\\right)}\n    >>> print_latex(ModOpNestedWrong(ModOpNestedWrong(x, m), Integer(7)))  # bad\n    \\operatorname{Mod}{\\left(ModOpNestedWrong(x, m), 7\\right)} \n    ```", "```py\n    >>> from sympy.printing.latex import LatexPrinter\n    >>> class ModOpSettingsWrong(Mod):\n    ...     def _latex(self, printer):\n    ...         a, b = [LatexPrinter()._print(i) for i in self.args]\n    ...         return r\"\\operatorname{Mod}{\\left(%s, %s\\right)}\" % (a, b) \n    ```", "```py\n    >>> from sympy import Float\n    >>> print_latex(ModOp(Float(1) * x, m), full_prec=True)  # ok\n    \\operatorname{Mod}{\\left(1.00000000000000 x, m\\right)}\n    >>> print_latex(ModOpSettingsWrong(Float(1) * x, m), full_prec=True)  # bad\n    \\operatorname{Mod}{\\left(1.0 x, m\\right)} \n    ```", "```py\nclass sympy.printing.printer.Printer(settings=None)\n```", "```py\nprintmethod: str = None\n```", "```py\n_print(expr, **kwargs) → str\n```", "```py\ndoprint(expr)\n```", "```py\nclassmethod set_global_settings(**settings)\n```", "```py\nclass sympy.printing.pretty.pretty.PrettyPrinter(settings=None)\n```", "```py\nprintmethod: str = '_pretty'\n```", "```py\nsympy.printing.pretty.pretty.pretty(expr, *, order=None, full_prec='auto', use_unicode=True, wrap_line=True, num_columns=None, use_unicode_sqrt_char=True, root_notation=True, mat_symbol_style='plain', imaginary_unit='i', perm_cyclic=True)\n```", "```py\nsympy.printing.pretty.pretty.pretty_print(expr, **kwargs)\n```", "```py\n>>> from sympy.printing import print_ccode\n>>> from sympy.functions import sin, cos, Abs, gamma\n>>> from sympy.abc import x\n>>> print_ccode(sin(x)**2 + cos(x)**2, standard='C89')\npow(sin(x), 2) + pow(cos(x), 2)\n>>> print_ccode(2*x + cos(x), assign_to=\"result\", standard='C89')\nresult = 2*x + cos(x);\n>>> print_ccode(Abs(x**2), standard='C89')\nfabs(pow(x, 2))\n>>> print_ccode(gamma(x**2), standard='C99')\ntgamma(pow(x, 2)) \n```", "```py\nsympy.printing.c.known_functions_C89 = {'Abs': [(<function <lambda>>, 'fabs'), (<function <lambda>>, 'abs')], 'acos': 'acos', 'asin': 'asin', 'atan': 'atan', 'atan2': 'atan2', 'ceiling': 'ceil', 'cos': 'cos', 'cosh': 'cosh', 'exp': 'exp', 'floor': 'floor', 'log': 'log', 'sin': 'sin', 'sinh': 'sinh', 'sqrt': 'sqrt', 'tan': 'tan', 'tanh': 'tanh'}\n```", "```py\nsympy.printing.c.known_functions_C99 = {'Abs': [(<function <lambda>>, 'fabs'), (<function <lambda>>, 'abs')], 'Cbrt': 'cbrt', 'Max': 'fmax', 'Min': 'fmin', 'acos': 'acos', 'acosh': 'acosh', 'asin': 'asin', 'asinh': 'asinh', 'atan': 'atan', 'atan2': 'atan2', 'atanh': 'atanh', 'ceiling': 'ceil', 'cos': 'cos', 'cosh': 'cosh', 'erf': 'erf', 'erfc': 'erfc', 'exp': 'exp', 'exp2': 'exp2', 'expm1': 'expm1', 'floor': 'floor', 'fma': 'fma', 'gamma': 'tgamma', 'hypot': 'hypot', 'log': 'log', 'log10': 'log10', 'log1p': 'log1p', 'log2': 'log2', 'loggamma': 'lgamma', 'sin': 'sin', 'sinh': 'sinh', 'sqrt': 'sqrt', 'tan': 'tan', 'tanh': 'tanh'}\n```", "```py\nclass sympy.printing.c.C89CodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_ccode'\n```", "```py\nindent_code(code)\n```", "```py\nclass sympy.printing.c.C99CodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_ccode'\n```", "```py\nsympy.printing.c.ccode(expr, assign_to=None, standard='c99', **settings)\n```", "```py\n>>> from sympy import ccode, symbols, Rational, sin, ceiling, Abs, Function\n>>> x, tau = symbols(\"x, tau\")\n>>> expr = (2*tau)**Rational(7, 2)\n>>> ccode(expr)\n'8*M_SQRT2*pow(tau, 7.0/2.0)'\n>>> ccode(expr, math_macros={})\n'8*sqrt(2)*pow(tau, 7.0/2.0)'\n>>> ccode(sin(x), assign_to=\"s\")\n's = sin(x);'\n>>> from sympy.codegen.ast import real, float80\n>>> ccode(expr, type_aliases={real: float80})\n'8*M_SQRT2l*powl(tau, 7.0L/2.0L)' \n```", "```py\n>>> custom_functions = {\n...   \"ceiling\": \"CEIL\",\n...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n...           (lambda x: x.is_integer, \"ABS\")],\n...   \"func\": \"f\"\n... }\n>>> func = Function('func')\n>>> ccode(func(Abs(x) + ceiling(x)), standard='C89', user_functions=custom_functions)\n'f(fabs(x) + CEIL(x))' \n```", "```py\n>>> ccode(2**x + 3**x, standard='C99', user_functions={'Pow': [\n...   (lambda b, e: b == 2, lambda b, e: 'exp2(%s)' % e),\n...   (lambda b, e: b != 2, 'pow')]})\n'exp2(x) + pow(3, x)' \n```", "```py\n>>> from sympy import Piecewise\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(ccode(expr, tau, standard='C89'))\nif (x > 0) {\ntau = x + 1;\n}\nelse {\ntau = x;\n} \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> ccode(e.rhs, assign_to=e.lhs, contract=False, standard='C89')\n'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n>>> A = MatrixSymbol('A', 3, 1)\n>>> print(ccode(mat, A, standard='C89'))\nA[0] = pow(x, 2);\nif (x > 0) {\n A[1] = x + 1;\n}\nelse {\n A[1] = x;\n}\nA[2] = sin(x); \n```", "```py\nsympy.printing.c.print_ccode(expr, **settings)\n```", "```py\n>>> from sympy.printing import cxxcode\n>>> from sympy.functions import Min, gamma\n>>> from sympy.abc import x\n>>> print(cxxcode(Min(gamma(x) - 1, x), standard='C++11'))\nstd::min(x, std::tgamma(x) - 1) \n```", "```py\nclass sympy.printing.cxx.CXX98CodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_cxxcode'\n```", "```py\nclass sympy.printing.cxx.CXX11CodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_cxxcode'\n```", "```py\nsympy.printing.codeprinter.cxxcode(expr, assign_to=None, standard='c++11', **settings)\n```", "```py\n>>> from sympy.printing import print_rcode\n>>> from sympy.functions import sin, cos, Abs\n>>> from sympy.abc import x\n>>> print_rcode(sin(x)**2 + cos(x)**2)\nsin(x)^2 + cos(x)^2\n>>> print_rcode(2*x + cos(x), assign_to=\"result\")\nresult = 2*x + cos(x);\n>>> print_rcode(Abs(x**2))\nabs(x^2) \n```", "```py\nsympy.printing.rcode.known_functions = {'Abs': 'abs', 'Max': 'max', 'Min': 'min', 'acos': 'acos', 'acosh': 'acosh', 'asin': 'asin', 'asinh': 'asinh', 'atan': 'atan', 'atan2': 'atan2', 'atanh': 'atanh', 'beta': 'beta', 'ceiling': 'ceiling', 'cos': 'cos', 'cosh': 'cosh', 'digamma': 'digamma', 'erf': 'erf', 'exp': 'exp', 'factorial': 'factorial', 'floor': 'floor', 'gamma': 'gamma', 'log': 'log', 'sign': 'sign', 'sin': 'sin', 'sinh': 'sinh', 'sqrt': 'sqrt', 'tan': 'tan', 'tanh': 'tanh', 'trigamma': 'trigamma'}\n```", "```py\nclass sympy.printing.rcode.RCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_rcode'\n```", "```py\nindent_code(code)\n```", "```py\nsympy.printing.rcode.rcode(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import rcode, symbols, Rational, sin, ceiling, Abs, Function\n>>> x, tau = symbols(\"x, tau\")\n>>> rcode((2*tau)**Rational(7, 2))\n'8*sqrt(2)*tau^(7.0/2.0)'\n>>> rcode(sin(x), assign_to=\"s\")\n's = sin(x);' \n```", "```py\n>>> custom_functions = {\n...   \"ceiling\": \"CEIL\",\n...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n...           (lambda x: x.is_integer, \"ABS\")],\n...   \"func\": \"f\"\n... }\n>>> func = Function('func')\n>>> rcode(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n'f(fabs(x) + CEIL(x))' \n```", "```py\n>>> rcode(2**x + 3**x, user_functions={'Pow': [\n...   (lambda b, e: b == 2, lambda b, e: 'exp2(%s)' % e),\n...   (lambda b, e: b != 2, 'pow')]})\n'exp2(x) + pow(3, x)' \n```", "```py\n>>> from sympy import Piecewise\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(rcode(expr, assign_to=tau))\ntau = ifelse(x > 0,x + 1,x); \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> rcode(e.rhs, assign_to=e.lhs, contract=False)\n'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n>>> A = MatrixSymbol('A', 3, 1)\n>>> print(rcode(mat, A))\nA[0] = x^2;\nA[1] = ifelse(x > 0,x + 1,x);\nA[2] = sin(x); \n```", "```py\nsympy.printing.rcode.print_rcode(expr, **settings)\n```", "```py\nsympy.printing.fortran.fcode(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import fcode, symbols, Rational, sin, ceiling, floor\n>>> x, tau = symbols(\"x, tau\")\n>>> fcode((2*tau)**Rational(7, 2))\n'      8*sqrt(2.0d0)*tau**(7.0d0/2.0d0)'\n>>> fcode(sin(x), assign_to=\"s\")\n'      s = sin(x)' \n```", "```py\n>>> custom_functions = {\n...   \"ceiling\": \"CEIL\",\n...   \"floor\": [(lambda x: not x.is_integer, \"FLOOR1\"),\n...             (lambda x: x.is_integer, \"FLOOR2\")]\n... }\n>>> fcode(floor(x) + ceiling(x), user_functions=custom_functions)\n'      CEIL(x) + FLOOR1(x)' \n```", "```py\n>>> from sympy import Piecewise\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(fcode(expr, tau))\n if (x > 0) then\n tau = x + 1\n else\n tau = x\n end if \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> fcode(e.rhs, assign_to=e.lhs, contract=False)\n'      Dy(i) = (y(i + 1) - y(i))/(t(i + 1) - t(i))' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n>>> A = MatrixSymbol('A', 3, 1)\n>>> print(fcode(mat, A))\n A(1, 1) = x**2\n if (x > 0) then\n A(2, 1) = x + 1\n else\n A(2, 1) = x\n end if\n A(3, 1) = sin(x) \n```", "```py\nsympy.printing.fortran.print_fcode(expr, **settings)\n```", "```py\nclass sympy.printing.fortran.FCodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_fcode'\n```", "```py\nindent_code(code)\n```", "```py\n>>> from sympy import *\n>>> x = symbols(\"x\")\n>>> fcode(sqrt(1-x**2))\n'      sqrt(1 - x**2)'\n>>> fcode((3 + 4*I)/(1 - conjugate(x)))\n'      (cmplx(3,4))/(1 - conjg(x))' \n```", "```py\n>>> expr = sqrt(1-x**2).series(x,n=20).removeO()\n>>> print(fcode(expr))\n -715.0d0/65536.0d0*x**18 - 429.0d0/32768.0d0*x**16 - 33.0d0/\n @ 2048.0d0*x**14 - 21.0d0/1024.0d0*x**12 - 7.0d0/256.0d0*x**10 -\n @ 5.0d0/128.0d0*x**8 - 1.0d0/16.0d0*x**6 - 1.0d0/8.0d0*x**4 - 1.0d0\n @ /2.0d0*x**2 + 1 \n```", "```py\n>>> print(fcode(expr, assign_to=\"var\"))\n var = -715.0d0/65536.0d0*x**18 - 429.0d0/32768.0d0*x**16 - 33.0d0/\n @ 2048.0d0*x**14 - 21.0d0/1024.0d0*x**12 - 7.0d0/256.0d0*x**10 -\n @ 5.0d0/128.0d0*x**8 - 1.0d0/16.0d0*x**6 - 1.0d0/8.0d0*x**4 - 1.0d0\n @ /2.0d0*x**2 + 1 \n```", "```py\n>>> print(fcode(Piecewise((x,x<1),(x**2,True)), assign_to=\"var\"))\n if (x < 1) then\n var = x\n else\n var = x**2\n end if \n```", "```py\n>>> print(fcode(Piecewise((x,x<1),(x**2,True)), standard=95))\n merge(x, x**2, x < 1) \n```", "```py\n>>> A, B = map(IndexedBase, ['A', 'B'])\n>>> m = Symbol('m', integer=True)\n>>> i = Idx('i', m)\n>>> print(fcode(2*B[i], assign_to=A[i]))\n do i = 1, m\n A(i) = 2*B(i)\n end do \n```", "```py\n>>> print(fcode(A[i, i], assign_to=x))\n x = 0\n do i = 1, m\n x = x + A(i, i)\n end do \n```", "```py\n>>> print(fcode(x - pi**2 - E))\n parameter (E = 2.7182818284590452d0)\n parameter (pi = 3.1415926535897932d0)\n x - pi**2 - E\n>>> print(fcode(x - pi**2 - E, precision=25))\n parameter (E = 2.718281828459045235360287d0)\n parameter (pi = 3.141592653589793238462643d0)\n x - pi**2 - E\n>>> print(fcode(N(x - pi**2, 25)))\n x - 9.869604401089358618834491d0 \n```", "```py\n>>> print(fcode(1 - gamma(x)**2, user_functions={'gamma': 'mygamma'}))\n 1 - mygamma(x)**2 \n```", "```py\n>>> print(fcode(1 - gamma(x)**2, strict=False))\nC     Not supported in Fortran:\nC     gamma\n 1 - gamma(x)**2 \n```", "```py\n>>> print(fcode(1 - gamma(x)**2, allow_unknown_functions=True))\n 1 - gamma(x)**2 \n```", "```py\n>>> fcode(1 - gamma(x)**2, human=False)\n(set(), {gamma(x)}, '      1 - gamma(x)**2')\n>>> fcode(1 - sin(x)**2, human=False)\n(set(), set(), '      1 - sin(x)**2')\n>>> fcode(x - pi**2, human=False)\n({(pi, '3.1415926535897932d0')}, set(), '      x - pi**2') \n```", "```py\nclass sympy.printing.smtlib.SMTLibPrinter(settings: dict | None = None, symbol_table=None)\n```", "```py\nprintmethod: str = '_smtlib'\n```", "```py\n_default_settings: dict = {'known_constants': {}, 'known_functions': {<class 'sympy.core.add.Add'>: '+', <class 'sympy.core.mul.Mul'>: '*', <class 'sympy.core.power.Pow'>: 'pow', <class 'sympy.core.relational.Equality'>: '=', <class 'sympy.core.relational.GreaterThan'>: '>=', <class 'sympy.core.relational.LessThan'>: '<=', <class 'sympy.core.relational.StrictGreaterThan'>: '>', <class 'sympy.core.relational.StrictLessThan'>: '<', Abs: 'abs', And: 'and', ITE: 'ite', Implies: '=>', Max: 'max', Min: 'min', Not: 'not', Or: 'or', Q.eq: '=', Q.ge: '>=', Q.gt: '>', Q.le: '<=', Q.lt: '<', Xor: 'xor', acos: 'arccos', asin: 'arcsin', atan: 'arctan', atan2: 'arctan2', cos: 'cos', cosh: 'cosh', exp: 'exp', log: 'log', sin: 'sin', sinh: 'sinh', tan: 'tan', tanh: 'tanh'}, 'known_types': {<class 'bool'>: 'Bool', <class 'float'>: 'Real', <class 'int'>: 'Int'}, 'precision': None}\n```", "```py\nsympy.printing.smtlib.smtlib_code(expr, auto_assert=True, auto_declare=True, precision=None, symbol_table=None, known_types=None, known_constants=None, known_functions=None, prefix_expressions=None, suffix_expressions=None, log_warn=None)\n```", "```py\n>>> from sympy import smtlib_code, symbols, sin, Eq\n>>> x = symbols('x')\n>>> smtlib_code(sin(x).series(x).removeO(), log_warn=print)\nCould not infer type of `x`. Defaulting to float.\nNon-Boolean expression `x**5/120 - x**3/6 + x` will not be asserted. Converting to SMTLib verbatim.\n'(declare-const x Real)\\n(+ x (* (/ -1 6) (pow x 3)) (* (/ 1 120) (pow x 5)))' \n```", "```py\n>>> from sympy import Rational\n>>> x, y, tau = symbols(\"x, y, tau\")\n>>> smtlib_code((2*tau)**Rational(7, 2), log_warn=print)\nCould not infer type of `tau`. Defaulting to float.\nNon-Boolean expression `8*sqrt(2)*tau**(7/2)` will not be asserted. Converting to SMTLib verbatim.\n'(declare-const tau Real)\\n(* 8 (pow 2 (/ 1 2)) (pow tau (/ 7 2)))' \n```", "```py\n>>> from sympy import Piecewise\n>>> pw = Piecewise((x + 1, x > 0), (x, True))\n>>> smtlib_code(Eq(pw, 3), symbol_table={x: float}, log_warn=print)\n'(declare-const x Real)\\n(assert (= (ite (> x 0) (+ 1 x) x) 3))' \n```", "```py\n>>> from typing import Callable\n>>> from sympy import Function, Add\n>>> f = Function('f')\n>>> g = Function('g')\n>>> smt_builtin_funcs = {  # functions our SMT solver will understand\n...   f: \"existing_smtlib_fcn\",\n...   Add: \"sum\",\n... }\n>>> user_def_funcs = {  # functions defined by the user must have their types specified explicitly\n...   g: Callable[[int], float],\n... }\n>>> smtlib_code(f(x) + g(x), symbol_table=user_def_funcs, known_functions=smt_builtin_funcs, log_warn=print)\nNon-Boolean expression `f(x) + g(x)` will not be asserted. Converting to SMTLib verbatim.\n'(declare-const x Int)\\n(declare-fun g (Int) Real)\\n(sum (existing_smtlib_fcn x) (g x))' \n```", "```py\nsympy.printing.mathematica.known_functions = {'Chi': [(<function <lambda>>, 'CoshIntegral')], 'Ci': [(<function <lambda>>, 'CosIntegral')], 'DiracDelta': [(<function <lambda>>, 'DiracDelta')], 'Ei': [(<function <lambda>>, 'ExpIntegralEi')], 'FallingFactorial': [(<function <lambda>>, 'FactorialPower')], 'Heaviside': [(<function <lambda>>, 'HeavisideTheta')], 'KroneckerDelta': [(<function <lambda>>, 'KroneckerDelta')], 'Max': [(<function <lambda>>, 'Max')], 'Min': [(<function <lambda>>, 'Min')], 'RisingFactorial': [(<function <lambda>>, 'Pochhammer')], 'Shi': [(<function <lambda>>, 'SinhIntegral')], 'Si': [(<function <lambda>>, 'SinIntegral')], 'acos': [(<function <lambda>>, 'ArcCos')], 'acosh': [(<function <lambda>>, 'ArcCosh')], 'acot': [(<function <lambda>>, 'ArcCot')], 'acoth': [(<function <lambda>>, 'ArcCoth')], 'acsc': [(<function <lambda>>, 'ArcCsc')], 'acsch': [(<function <lambda>>, 'ArcCsch')], 'airyai': [(<function <lambda>>, 'AiryAi')], 'airyaiprime': [(<function <lambda>>, 'AiryAiPrime')], 'airybi': [(<function <lambda>>, 'AiryBi')], 'airybiprime': [(<function <lambda>>, 'AiryBiPrime')], 'appellf1': [(<function <lambda>>, 'AppellF1')], 'asec': [(<function <lambda>>, 'ArcSec')], 'asech': [(<function <lambda>>, 'ArcSech')], 'asin': [(<function <lambda>>, 'ArcSin')], 'asinh': [(<function <lambda>>, 'ArcSinh')], 'assoc_laguerre': [(<function <lambda>>, 'LaguerreL')], 'assoc_legendre': [(<function <lambda>>, 'LegendreP')], 'atan': [(<function <lambda>>, 'ArcTan')], 'atan2': [(<function <lambda>>, 'ArcTan')], 'atanh': [(<function <lambda>>, 'ArcTanh')], 'besseli': [(<function <lambda>>, 'BesselI')], 'besselj': [(<function <lambda>>, 'BesselJ')], 'besselk': [(<function <lambda>>, 'BesselK')], 'bessely': [(<function <lambda>>, 'BesselY')], 'beta': [(<function <lambda>>, 'Beta')], 'catalan': [(<function <lambda>>, 'CatalanNumber')], 'chebyshevt': [(<function <lambda>>, 'ChebyshevT')], 'chebyshevu': [(<function <lambda>>, 'ChebyshevU')], 'conjugate': [(<function <lambda>>, 'Conjugate')], 'cos': [(<function <lambda>>, 'Cos')], 'cosh': [(<function <lambda>>, 'Cosh')], 'cot': [(<function <lambda>>, 'Cot')], 'coth': [(<function <lambda>>, 'Coth')], 'csc': [(<function <lambda>>, 'Csc')], 'csch': [(<function <lambda>>, 'Csch')], 'dirichlet_eta': [(<function <lambda>>, 'DirichletEta')], 'elliptic_e': [(<function <lambda>>, 'EllipticE')], 'elliptic_f': [(<function <lambda>>, 'EllipticE')], 'elliptic_k': [(<function <lambda>>, 'EllipticK')], 'elliptic_pi': [(<function <lambda>>, 'EllipticPi')], 'erf': [(<function <lambda>>, 'Erf')], 'erf2': [(<function <lambda>>, 'Erf')], 'erf2inv': [(<function <lambda>>, 'InverseErf')], 'erfc': [(<function <lambda>>, 'Erfc')], 'erfcinv': [(<function <lambda>>, 'InverseErfc')], 'erfi': [(<function <lambda>>, 'Erfi')], 'erfinv': [(<function <lambda>>, 'InverseErf')], 'exp': [(<function <lambda>>, 'Exp')], 'expint': [(<function <lambda>>, 'ExpIntegralE')], 'factorial': [(<function <lambda>>, 'Factorial')], 'factorial2': [(<function <lambda>>, 'Factorial2')], 'fresnelc': [(<function <lambda>>, 'FresnelC')], 'fresnels': [(<function <lambda>>, 'FresnelS')], 'gamma': [(<function <lambda>>, 'Gamma')], 'gcd': [(<function <lambda>>, 'GCD')], 'gegenbauer': [(<function <lambda>>, 'GegenbauerC')], 'hankel1': [(<function <lambda>>, 'HankelH1')], 'hankel2': [(<function <lambda>>, 'HankelH2')], 'harmonic': [(<function <lambda>>, 'HarmonicNumber')], 'hermite': [(<function <lambda>>, 'HermiteH')], 'hyper': [(<function <lambda>>, 'HypergeometricPFQ')], 'jacobi': [(<function <lambda>>, 'JacobiP')], 'jn': [(<function <lambda>>, 'SphericalBesselJ')], 'laguerre': [(<function <lambda>>, 'LaguerreL')], 'lcm': [(<function <lambda>>, 'LCM')], 'legendre': [(<function <lambda>>, 'LegendreP')], 'lerchphi': [(<function <lambda>>, 'LerchPhi')], 'li': [(<function <lambda>>, 'LogIntegral')], 'log': [(<function <lambda>>, 'Log')], 'loggamma': [(<function <lambda>>, 'LogGamma')], 'lucas': [(<function <lambda>>, 'LucasL')], 'mathieuc': [(<function <lambda>>, 'MathieuC')], 'mathieucprime': [(<function <lambda>>, 'MathieuCPrime')], 'mathieus': [(<function <lambda>>, 'MathieuS')], 'mathieusprime': [(<function <lambda>>, 'MathieuSPrime')], 'meijerg': [(<function <lambda>>, 'MeijerG')], 'polygamma': [(<function <lambda>>, 'PolyGamma')], 'polylog': [(<function <lambda>>, 'PolyLog')], 'riemann_xi': [(<function <lambda>>, 'RiemannXi')], 'sec': [(<function <lambda>>, 'Sec')], 'sech': [(<function <lambda>>, 'Sech')], 'sin': [(<function <lambda>>, 'Sin')], 'sinc': [(<function <lambda>>, 'Sinc')], 'sinh': [(<function <lambda>>, 'Sinh')], 'sqrt': [(<function <lambda>>, 'Sqrt')], 'stieltjes': [(<function <lambda>>, 'StieltjesGamma')], 'subfactorial': [(<function <lambda>>, 'Subfactorial')], 'tan': [(<function <lambda>>, 'Tan')], 'tanh': [(<function <lambda>>, 'Tanh')], 'uppergamma': [(<function <lambda>>, 'Gamma')], 'yn': [(<function <lambda>>, 'SphericalBesselY')], 'zeta': [(<function <lambda>>, 'Zeta')]}\n```", "```py\nclass sympy.printing.mathematica.MCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_mcode'\n```", "```py\nsympy.printing.mathematica.mathematica_code(expr, **settings)\n```", "```py\n>>> from sympy import mathematica_code as mcode, symbols, sin\n>>> x = symbols('x')\n>>> mcode(sin(x).series(x).removeO())\n'(1/120)*x^5 - 1/6*x^3 + x' \n```", "```py\nclass sympy.printing.maple.MapleCodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_maple'\n```", "```py\nsympy.printing.maple.maple_code(expr, assign_to=None, **settings)\n```", "```py\nsympy.printing.maple.print_maple_code(expr, **settings)\n```", "```py\n>>> from sympy import print_maple_code, symbols\n>>> x, y = symbols('x y')\n>>> print_maple_code(x, assign_to=y)\ny := x \n```", "```py\nsympy.printing.jscode.known_functions = {'Abs': 'Math.abs', 'Max': 'Math.max', 'Min': 'Math.min', 'acos': 'Math.acos', 'acosh': 'Math.acosh', 'asin': 'Math.asin', 'asinh': 'Math.asinh', 'atan': 'Math.atan', 'atan2': 'Math.atan2', 'atanh': 'Math.atanh', 'ceiling': 'Math.ceil', 'cos': 'Math.cos', 'cosh': 'Math.cosh', 'exp': 'Math.exp', 'floor': 'Math.floor', 'log': 'Math.log', 'sign': 'Math.sign', 'sin': 'Math.sin', 'sinh': 'Math.sinh', 'tan': 'Math.tan', 'tanh': 'Math.tanh'}\n```", "```py\nclass sympy.printing.jscode.JavascriptCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_javascript'\n```", "```py\nindent_code(code)\n```", "```py\nsympy.printing.jscode.jscode(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import jscode, symbols, Rational, sin, ceiling, Abs\n>>> x, tau = symbols(\"x, tau\")\n>>> jscode((2*tau)**Rational(7, 2))\n'8*Math.sqrt(2)*Math.pow(tau, 7/2)'\n>>> jscode(sin(x), assign_to=\"s\")\n's = Math.sin(x);' \n```", "```py\n>>> custom_functions = {\n...   \"ceiling\": \"CEIL\",\n...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\"),\n...           (lambda x: x.is_integer, \"ABS\")]\n... }\n>>> jscode(Abs(x) + ceiling(x), user_functions=custom_functions)\n'fabs(x) + CEIL(x)' \n```", "```py\n>>> from sympy import Piecewise\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(jscode(expr, tau))\nif (x > 0) {\n tau = x + 1;\n}\nelse {\n tau = x;\n} \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> jscode(e.rhs, assign_to=e.lhs, contract=False)\n'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n>>> A = MatrixSymbol('A', 3, 1)\n>>> print(jscode(mat, A))\nA[0] = Math.pow(x, 2);\nif (x > 0) {\n A[1] = x + 1;\n}\nelse {\n A[1] = x;\n}\nA[2] = Math.sin(x); \n```", "```py\nsympy.printing.julia.known_fcns_src1 = ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 'sinh', 'cosh', 'tanh', 'coth', 'sech', 'csch', 'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch', 'sinc', 'atan2', 'sign', 'floor', 'log', 'exp', 'cbrt', 'sqrt', 'erf', 'erfc', 'erfi', 'factorial', 'gamma', 'digamma', 'trigamma', 'polygamma', 'beta', 'airyai', 'airyaiprime', 'airybi', 'airybiprime', 'besselj', 'bessely', 'besseli', 'besselk', 'erfinv', 'erfcinv']\n```", "```py\nsympy.printing.julia.known_fcns_src2 = {'Abs': 'abs', 'ceiling': 'ceil', 'conjugate': 'conj', 'hankel1': 'hankelh1', 'hankel2': 'hankelh2', 'im': 'imag', 're': 'real'}\n```", "```py\nclass sympy.printing.julia.JuliaCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_julia'\n```", "```py\nindent_code(code)\n```", "```py\nsympy.printing.julia.julia_code(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import julia_code, symbols, sin, pi\n>>> x = symbols('x')\n>>> julia_code(sin(x).series(x).removeO())\n'x .^ 5 / 120 - x .^ 3 / 6 + x' \n```", "```py\n>>> from sympy import Rational, ceiling\n>>> x, y, tau = symbols(\"x, y, tau\")\n>>> julia_code((2*tau)**Rational(7, 2))\n'8 * sqrt(2) * tau .^ (7 // 2)' \n```", "```py\n>>> julia_code(sin(pi*x*y), assign_to=\"s\")\n's = sin(pi * x .* y)' \n```", "```py\n>>> from sympy import Symbol, MatrixSymbol\n>>> n = Symbol('n', integer=True, positive=True)\n>>> A = MatrixSymbol('A', n, n)\n>>> julia_code(3*pi*A**3)\n'(3 * pi) * A ^ 3' \n```", "```py\n>>> julia_code(x**2*y*A**3)\n'(x .^ 2 .* y) * A ^ 3' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([[x**2, sin(x), ceiling(x)]])\n>>> julia_code(mat, assign_to='A')\n'A = [x .^ 2 sin(x) ceil(x)]' \n```", "```py\n>>> from sympy import Piecewise\n>>> pw = Piecewise((x + 1, x > 0), (x, True))\n>>> julia_code(pw, assign_to=tau)\n'tau = ((x > 0) ? (x + 1) : (x))' \n```", "```py\n>>> mat = Matrix([[x**2, pw, sin(x)]])\n>>> julia_code(mat, assign_to='A')\n'A = [x .^ 2 ((x > 0) ? (x + 1) : (x)) sin(x)]' \n```", "```py\n>>> from sympy import Function\n>>> f = Function('f')\n>>> g = Function('g')\n>>> custom_functions = {\n...   \"f\": \"existing_julia_fcn\",\n...   \"g\": [(lambda x: x.is_Matrix, \"my_mat_fcn\"),\n...         (lambda x: not x.is_Matrix, \"my_fcn\")]\n... }\n>>> mat = Matrix([[1, x]])\n>>> julia_code(f(x) + g(x) + g(mat), user_functions=custom_functions)\n'existing_julia_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])' \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e = Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> julia_code(e.rhs, assign_to=e.lhs, contract=False)\n'Dy[i] = (y[i + 1] - y[i]) ./ (t[i + 1] - t[i])' \n```", "```py\nsympy.printing.octave.known_fcns_src1 = ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'acot', 'atan', 'atan2', 'asec', 'acsc', 'sinh', 'cosh', 'tanh', 'coth', 'csch', 'sech', 'asinh', 'acosh', 'atanh', 'acoth', 'asech', 'acsch', 'erfc', 'erfi', 'erf', 'erfinv', 'erfcinv', 'besseli', 'besselj', 'besselk', 'bessely', 'bernoulli', 'beta', 'euler', 'exp', 'factorial', 'floor', 'fresnelc', 'fresnels', 'gamma', 'harmonic', 'log', 'polylog', 'sign', 'zeta', 'legendre']\n```", "```py\nsympy.printing.octave.known_fcns_src2 = {'Abs': 'abs', 'Chi': 'coshint', 'Ci': 'cosint', 'DiracDelta': 'dirac', 'Heaviside': 'heaviside', 'LambertW': 'lambertw', 'Max': 'max', 'Min': 'min', 'Mod': 'mod', 'RisingFactorial': 'pochhammer', 'Shi': 'sinhint', 'Si': 'sinint', 'arg': 'angle', 'binomial': 'bincoeff', 'ceiling': 'ceil', 'chebyshevt': 'chebyshevT', 'chebyshevu': 'chebyshevU', 'conjugate': 'conj', 'im': 'imag', 'laguerre': 'laguerreL', 'li': 'logint', 'loggamma': 'gammaln', 'polygamma': 'psi', 're': 'real'}\n```", "```py\nclass sympy.printing.octave.OctaveCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_octave'\n```", "```py\nindent_code(code)\n```", "```py\nsympy.printing.octave.octave_code(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import octave_code, symbols, sin, pi\n>>> x = symbols('x')\n>>> octave_code(sin(x).series(x).removeO())\n'x.^5/120 - x.^3/6 + x' \n```", "```py\n>>> from sympy import Rational, ceiling\n>>> x, y, tau = symbols(\"x, y, tau\")\n>>> octave_code((2*tau)**Rational(7, 2))\n'8*sqrt(2)*tau.^(7/2)' \n```", "```py\n>>> octave_code(sin(pi*x*y), assign_to=\"s\")\n's = sin(pi*x.*y);' \n```", "```py\n>>> from sympy import Symbol, MatrixSymbol\n>>> n = Symbol('n', integer=True, positive=True)\n>>> A = MatrixSymbol('A', n, n)\n>>> octave_code(3*pi*A**3)\n'(3*pi)*A^3' \n```", "```py\n>>> octave_code(x**2*y*A**3)\n'(x.^2.*y)*A^3' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([[x**2, sin(x), ceiling(x)]])\n>>> octave_code(mat, assign_to='A')\n'A = [x.^2 sin(x) ceil(x)];' \n```", "```py\n>>> from sympy import Piecewise\n>>> pw = Piecewise((x + 1, x > 0), (x, True))\n>>> octave_code(pw, assign_to=tau)\n'tau = ((x > 0).*(x + 1) + (~(x > 0)).*(x));' \n```", "```py\n>>> mat = Matrix([[x**2, pw, sin(x)]])\n>>> octave_code(mat, assign_to='A')\n'A = [x.^2 ((x > 0).*(x + 1) + (~(x > 0)).*(x)) sin(x)];' \n```", "```py\n>>> from sympy import Function\n>>> f = Function('f')\n>>> g = Function('g')\n>>> custom_functions = {\n...   \"f\": \"existing_octave_fcn\",\n...   \"g\": [(lambda x: x.is_Matrix, \"my_mat_fcn\"),\n...         (lambda x: not x.is_Matrix, \"my_fcn\")]\n... }\n>>> mat = Matrix([[1, x]])\n>>> octave_code(f(x) + g(x) + g(mat), user_functions=custom_functions)\n'existing_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])' \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e = Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> octave_code(e.rhs, assign_to=e.lhs, contract=False)\n'Dy(i) = (y(i + 1) - y(i))./(t(i + 1) - t(i));' \n```", "```py\nsympy.printing.rust.known_functions = {'Abs': 'abs', 'Max': 'max', 'Min': 'min', 'Pow': [(<function <lambda>>, 'recip', 2), (<function <lambda>>, 'sqrt', 2), (<function <lambda>>, 'sqrt().recip', 2), (<function <lambda>>, 'cbrt', 2), (<function <lambda>>, 'exp2', 3), (<function <lambda>>, 'powi', 1), (<function <lambda>>, 'powf', 1)], 'acos': 'acos', 'acosh': 'acosh', 'asin': 'asin', 'asinh': 'asinh', 'atan': 'atan', 'atan2': 'atan2', 'atanh': 'atanh', 'ceiling': 'ceil', 'cos': 'cos', 'cosh': 'cosh', 'exp': [(<function <lambda>>, 'exp', 2)], 'floor': 'floor', 'log': 'ln', 'sign': 'signum', 'sin': 'sin', 'sinh': 'sinh', 'sqrt': 'sqrt', 'tan': 'tan', 'tanh': 'tanh'}\n```", "```py\nclass sympy.printing.rust.RustCodePrinter(settings={})\n```", "```py\nprintmethod: str = '_rust_code'\n```", "```py\nindent_code(code)\n```", "```py\nsympy.printing.rust.rust_code(expr, assign_to=None, **settings)\n```", "```py\n>>> from sympy import rust_code, symbols, Rational, sin, ceiling, Abs, Function\n>>> x, tau = symbols(\"x, tau\")\n>>> rust_code((2*tau)**Rational(7, 2))\n'8*1.4142135623731*tau.powf(7_f64/2.0)'\n>>> rust_code(sin(x), assign_to=\"s\")\n's = x.sin();' \n```", "```py\n>>> custom_functions = {\n...   \"ceiling\": \"CEIL\",\n...   \"Abs\": [(lambda x: not x.is_integer, \"fabs\", 4),\n...           (lambda x: x.is_integer, \"ABS\", 4)],\n...   \"func\": \"f\"\n... }\n>>> func = Function('func')\n>>> rust_code(func(Abs(x) + ceiling(x)), user_functions=custom_functions)\n'(fabs(x) + x.CEIL()).f()' \n```", "```py\n>>> from sympy import Piecewise\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(rust_code(expr, tau))\ntau = if (x > 0) {\n x + 1\n} else {\n x\n}; \n```", "```py\n>>> from sympy import Eq, IndexedBase, Idx\n>>> len_y = 5\n>>> y = IndexedBase('y', shape=(len_y,))\n>>> t = IndexedBase('t', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> e=Eq(Dy[i], (y[i+1]-y[i])/(t[i+1]-t[i]))\n>>> rust_code(e.rhs, assign_to=e.lhs, contract=False)\n'Dy[i] = (y[i + 1] - y[i])/(t[i + 1] - t[i]);' \n```", "```py\n>>> from sympy import Matrix, MatrixSymbol\n>>> mat = Matrix([x**2, Piecewise((x + 1, x > 0), (x, True)), sin(x)])\n>>> A = MatrixSymbol('A', 3, 1)\n>>> print(rust_code(mat, A))\nA = [x.powi(2), if (x > 0) {\n x + 1\n} else {\n x\n}, x.sin()]; \n```", "```py\nclass sympy.printing.aesaracode.AesaraPrinter(*args, **kwargs)\n```", "```py\nprintmethod: str = '_aesara'\n```", "```py\ndoprint(expr, dtypes=None, broadcastables=None)\n```", "```py\nsympy.printing.aesaracode.aesara_code(expr, cache=None, **kwargs)\n```", "```py\nsympy.printing.aesaracode.aesara_function(inputs, outputs, scalar=False, *, dim=None, dims=None, broadcastables=None, **kwargs)\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy.printing.aesaracode import aesara_function \n```", "```py\n>>> f1 = aesara_function([x], [x**2 - 1], scalar=True)\n>>> f1(3)\n8.0 \n```", "```py\n>>> f2 = aesara_function([x, y, z], [(x**z + y**z)**(1/z)], scalar=True)\n>>> f2(3, 4, 2)\n5.0 \n```", "```py\n>>> f3 = aesara_function([x, y], [x**2 + y**2, x**2 - y**2], scalar=True)\n>>> f3(2, 3)\n[13.0, -5.0] \n```", "```py\nsympy.printing.aesaracode.dim_handling(inputs, dim=None, dims=None, broadcastables=None)\n```", "```py\nfrom sympy import *\nprint_gtk(x**2 + 2*exp(x**3)) \n```", "```py\nsympy.printing.gtk.print_gtk(x, start_viewer=True)\n```", "```py\nclass sympy.printing.lambdarepr.LambdaPrinter(settings=None)\n```", "```py\nprintmethod: str = '_lambdacode'\n```", "```py\nsympy.printing.lambdarepr.lambdarepr(expr, **settings)\n```", "```py\nsympy.printing.latex.accepted_latex_functions = ['arcsin', 'arccos', 'arctan', 'sin', 'cos', 'tan', 'sinh', 'cosh', 'tanh', 'sqrt', 'ln', 'log', 'sec', 'csc', 'cot', 'coth', 're', 'im', 'frac', 'root', 'arg']\n```", "```py\nclass sympy.printing.latex.LatexPrinter(settings=None)\n```", "```py\nprintmethod: str = '_latex'\n```", "```py\nparenthesize_super(s)\n```", "```py\nsympy.printing.latex.latex(expr, *, full_prec=False, fold_frac_powers=False, fold_func_brackets=False, fold_short_frac=None, inv_trig_style='abbreviated', itex=False, ln_notation=False, long_frac_ratio=None, mat_delim='[', mat_str=None, mode='plain', mul_symbol=None, order=None, symbol_names={}, root_notation=True, mat_symbol_style='plain', imaginary_unit='i', gothic_re_im=False, decimal_separator='period', perm_cyclic=True, parenthesize_super=True, min=None, max=None, diff_operator='d', adjoint_style='dagger')\n```", "```py, and ``'hermitian'```", "```py\n>>> from sympy import latex, Rational\n>>> from sympy.abc import tau\n>>> latex((2*tau)**Rational(7,2))\n'8 \\\\sqrt{2} \\\\tau^{\\\\frac{7}{2}}'\n>>> print(latex((2*tau)**Rational(7,2)))\n8 \\sqrt{2} \\tau^{\\frac{7}{2}} \n```", "```py\n>>> from sympy import latex, pi, sin, asin, Integral, Matrix, Rational, log\n>>> from sympy.abc import x, y, mu, r, tau \n```", "```py\n>>> print(latex((2*tau)**Rational(7,2)))\n8 \\sqrt{2} \\tau^{\\frac{7}{2}} \n```", "```py\n>>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n>>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n$8 \\sqrt{2} \\tau^{7 / 2}$\n>>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n\\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n>>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n\\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n>>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n$$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$\n>>> print(latex((2*mu)**Rational(7,2), mode='plain'))\n8 \\sqrt{2} \\mu^{\\frac{7}{2}}\n>>> print(latex((2*tau)**Rational(7,2), mode='inline'))\n$8 \\sqrt{2} \\tau^{7 / 2}$\n>>> print(latex((2*mu)**Rational(7,2), mode='equation*'))\n\\begin{equation*}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation*}\n>>> print(latex((2*mu)**Rational(7,2), mode='equation'))\n\\begin{equation}8 \\sqrt{2} \\mu^{\\frac{7}{2}}\\end{equation}\n>>> print(latex((2*mu)**Rational(7,2), mode='equation', itex=True))\n$$8 \\sqrt{2} \\mu^{\\frac{7}{2}}$$ \n```", "```py\n>>> print(latex((2*tau)**Rational(7,2), fold_frac_powers=True))\n8 \\sqrt{2} \\tau^{7/2}\n>>> print(latex((2*tau)**sin(Rational(7,2))))\n\\left(2 \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}}\n>>> print(latex((2*tau)**sin(Rational(7,2)), fold_func_brackets=True))\n\\left(2 \\tau\\right)^{\\sin {\\frac{7}{2}}}\n>>> print(latex(3*x**2/y))\n\\frac{3 x^{2}}{y}\n>>> print(latex(3*x**2/y, fold_short_frac=True))\n3 x^{2} / y\n>>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=2))\n\\frac{\\int r\\, dr}{2 \\pi}\n>>> print(latex(Integral(r, r)/2/pi, long_frac_ratio=0))\n\\frac{1}{2 \\pi} \\int r\\, dr \n```", "```py\n>>> print(latex((2*tau)**sin(Rational(7,2)), mul_symbol=\"times\"))\n\\left(2 \\times \\tau\\right)^{\\sin{\\left(\\frac{7}{2} \\right)}} \n```", "```py\n>>> print(latex(asin(Rational(7,2))))\n\\operatorname{asin}{\\left(\\frac{7}{2} \\right)}\n>>> print(latex(asin(Rational(7,2)), inv_trig_style=\"full\"))\n\\arcsin{\\left(\\frac{7}{2} \\right)}\n>>> print(latex(asin(Rational(7,2)), inv_trig_style=\"power\"))\n\\sin^{-1}{\\left(\\frac{7}{2} \\right)} \n```", "```py\n>>> print(latex(Matrix(2, 1, [x, y])))\n\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]\n>>> print(latex(Matrix(2, 1, [x, y]), mat_str = \"array\"))\n\\left[\\begin{array}{c}x\\\\y\\end{array}\\right]\n>>> print(latex(Matrix(2, 1, [x, y]), mat_delim=\"(\"))\n\\left(\\begin{matrix}x\\\\y\\end{matrix}\\right) \n```", "```py\n>>> print(latex(x**2, symbol_names={x: 'x_i'}))\nx_i^{2} \n```", "```py\n>>> print(latex(log(10)))\n\\log{\\left(10 \\right)}\n>>> print(latex(log(10), ln_notation=True))\n\\ln{\\left(10 \\right)} \n```", "```py\n>>> print(latex([2/x, y], mode='inline'))\n$\\left[ 2 / x, \\  y\\right]$ \n```", "```py\n>>> print(latex(int))\n\\mathtt{\\text{<class 'int'>}}\n>>> print(latex(\"plain % text\"))\n\\mathtt{\\text{plain \\% text}} \n```", "```py\nsympy.printing.latex.print_latex(expr, **settings)\n```", "```py\nclass sympy.printing.mathml.MathMLPrinterBase(settings=None)\n```", "```py\ndoprint(expr)\n```", "```py\nclass sympy.printing.mathml.MathMLContentPrinter(settings=None)\n```", "```py\nprintmethod: str = '_mathml_content'\n```", "```py\nmathml_tag(e)\n```", "```py\nclass sympy.printing.mathml.MathMLPresentationPrinter(settings=None)\n```", "```py\nprintmethod: str = '_mathml_presentation'\n```", "```py\nmathml_tag(e)\n```", "```py\nsympy.printing.mathml.mathml(expr, printer='content', *, order=None, encoding='utf-8', fold_frac_powers=False, fold_func_brackets=False, fold_short_frac=None, inv_trig_style='abbreviated', ln_notation=False, long_frac_ratio=None, mat_delim='[', mat_symbol_style='plain', mul_symbol=None, root_notation=True, symbol_names={}, mul_symbol_mathml_numbers='&#xB7;')\n```", "```py\nsympy.printing.mathml.print_mathml(expr, printer='content', **settings)\n```", "```py\n>>> ##\n>>> from sympy import print_mathml\n>>> from sympy.abc import x\n>>> print_mathml(x+1) \n<apply>\n <plus/>\n <ci>x</ci>\n <cn>1</cn>\n</apply>\n>>> print_mathml(x+1, printer='presentation')\n<mrow>\n <mi>x</mi>\n <mo>+</mo>\n <mn>1</mn>\n</mrow> \n```", "```py\nclass sympy.printing.pycode.MpmathPrinter(settings=None)\n```", "```py\nsympy.printing.pycode.pycode(expr, **settings)\n```", "```py\n>>> from sympy import pycode, tan, Symbol\n>>> pycode(tan(Symbol('x')) + 1)\n'math.tan(x) + 1' \n```", "```py\n>>> from sympy import print_python, sin\n>>> from sympy.abc import x\n\n>>> print_python(5*x**3 + sin(x))\nx = Symbol('x')\ne = 5*x**3 + sin(x) \n```", "```py\n>>> repr(5*x**3 + sin(x))\n'5*x**3 + sin(x)'\n\n>>> srepr(5*x**3 + sin(x))\n\"Add(Mul(Integer(5), Pow(Symbol('x'), Integer(3))), sin(Symbol('x')))\" \n```", "```py\nclass sympy.printing.repr.ReprPrinter(settings=None)\n```", "```py\nprintmethod: str = '_sympyrepr'\n```", "```py\nemptyPrinter(expr)\n```", "```py\nreprify(args, sep)\n```", "```py\nsympy.printing.repr.srepr(expr, *, order=None, perm_cyclic=True)\n```", "```py\nclass sympy.printing.str.StrPrinter(settings=None)\n```", "```py\nprintmethod: str = '_sympystr'\n```", "```py\nsympy.printing.str.sstr(expr, *, order=None, full_prec='auto', sympy_integers=False, abbrev=False, perm_cyclic=True, min=None, max=None)\n```", "```py\n>>> from sympy import symbols, Eq, sstr\n>>> a, b = symbols('a b')\n>>> sstr(Eq(a + b, 0))\n'Eq(a + b, 0)' \n```", "```py\nsympy.printing.str.sstrrepr(expr, *, order=None, full_prec='auto', sympy_integers=False, abbrev=False, perm_cyclic=True, min=None, max=None)\n```", "```py\nsympy.printing.tree.pprint_nodes(subtrees)\n```", "```py\n>>> from sympy.printing.tree import pprint_nodes\n>>> print(pprint_nodes([\"a\", \"b1\\nb2\", \"c\"]))\n+-a\n+-b1\n| b2\n+-c \n```", "```py\nsympy.printing.tree.print_node(node, assumptions=True)\n```", "```py\nsympy.printing.tree.tree(node, assumptions=True)\n```", "```pyis_integer`, ``is_real```", "```py\nsympy.printing.tree.print_tree(node, assumptions=True)\n```", "```pyis_integer`, ``is_real```", "```py\n>>> from sympy.printing import print_tree\n>>> from sympy import Symbol\n>>> x = Symbol('x', odd=True)\n>>> y = Symbol('y', even=True) \n```", "```py\n>>> print_tree(y**x)\nPow: y**x\n+-Symbol: y\n| algebraic: True\n| commutative: True\n| complex: True\n| even: True\n| extended_real: True\n| finite: True\n| hermitian: True\n| imaginary: False\n| infinite: False\n| integer: True\n| irrational: False\n| noninteger: False\n| odd: False\n| rational: True\n| real: True\n| transcendental: False\n+-Symbol: x\n algebraic: True\n commutative: True\n complex: True\n even: False\n extended_nonzero: True\n extended_real: True\n finite: True\n hermitian: True\n imaginary: False\n infinite: False\n integer: True\n irrational: False\n noninteger: False\n nonzero: True\n odd: True\n rational: True\n real: True\n transcendental: False\n zero: False \n```", "```py\n>>> print_tree(y**x, assumptions=False)\nPow: y**x\n+-Symbol: y\n+-Symbol: x \n```", "```py\nsympy.printing.preview.preview(expr, output='png', viewer=None, euler=True, packages=(), filename=None, outputbuffer=None, preamble=None, dvioptions=None, outputTexFile=None, extra_preamble=None, fontsize=None, **latex_settings)\n```", "```py\n>>> from sympy import symbols, preview, Symbol\n>>> x, y = symbols(\"x,y\") \n```", "```py\n>>> preview(x + y, output='png') \n```", "```py\n>>> preview(x + y, output='png', viewer='gimp') \n```", "```py\n>>> preview(x + y, output='dvi') \n```", "```py\n>>> from sympy.printing.preview import system_default_viewer\n>>> preview(x + y, output='dvi', viewer=system_default_viewer) \n```", "```py\n>>> preview(x + y, output='dvi', viewer='superior-dvi-viewer') \n```", "```py\n>>> from io import BytesIO\n>>> obj = BytesIO()\n>>> preview(x + y, output='png', viewer='BytesIO',\n...         outputbuffer=obj) \n```", "```py\n>>> preamble = \"\\\\documentclass[10pt]{article}\\n\" \\\n...            \"\\\\usepackage{amsmath,amsfonts}\\\\begin{document}\"\n>>> preview(x + y, output='png', preamble=preamble) \n```", "```py\n>>> from sympy import sin\n>>> extra_preamble = \"\\\\renewcommand{\\\\sin}{\\\\cos}\"\n>>> preview(sin(x), output='png', extra_preamble=extra_preamble) \n```", "```py\n>>> phidd = Symbol('phidd')\n>>> preview(phidd, symbol_names={phidd: r'\\ddot{\\varphi}'}) \n```", "```py\n>>> preview(x + y, outputTexFile=\"sample.tex\") \n```", "```py\nsympy.printing.conventions.split_super_sub(text)\n```", "```py\n>>> from sympy.printing.conventions import split_super_sub\n>>> split_super_sub('a_x^1')\n('a', ['1'], ['x'])\n>>> split_super_sub('var_sub1__sup_sub2')\n('var', ['sup'], ['sub1', 'sub2']) \n```", "```py\nclass sympy.printing.codeprinter.CodePrinter(settings=None)\n```", "```py\nprintmethod: str = '_sympystr'\n```", "```py\ndoprint(expr, assign_to=None)\n```", "```py\nexception sympy.printing.codeprinter.AssignmentError\n```", "```py\nsympy.printing.precedence.PRECEDENCE = {'Add': 40, 'And': 30, 'Atom': 1000, 'BitwiseAnd': 38, 'BitwiseOr': 36, 'BitwiseXor': 37, 'Func': 70, 'Lambda': 1, 'Mul': 50, 'Not': 100, 'Or': 20, 'Pow': 60, 'Relational': 35, 'Xor': 10}\n```", "```py\nsympy.printing.precedence.PRECEDENCE_VALUES = {'Add': 40, 'And': 30, 'Equality': 50, 'Equivalent': 10, 'Function': 70, 'HadamardPower': 60, 'HadamardProduct': 50, 'Implies': 10, 'KroneckerProduct': 50, 'MatAdd': 40, 'MatPow': 60, 'MatrixSolve': 50, 'Mod': 50, 'NegativeInfinity': 40, 'Not': 100, 'Or': 20, 'Pow': 60, 'Relational': 35, 'Sub': 40, 'TensAdd': 40, 'TensMul': 50, 'Unequality': 50, 'Xor': 10}\n```", "```py\nsympy.printing.precedence.PRECEDENCE_FUNCTIONS = {'Float': <function precedence_Float>, 'FracElement': <function precedence_FracElement>, 'Integer': <function precedence_Integer>, 'Mul': <function precedence_Mul>, 'PolyElement': <function precedence_PolyElement>, 'Rational': <function precedence_Rational>, 'UnevaluatedExpr': <function precedence_UnevaluatedExpr>}\n```", "```py\nsympy.printing.precedence.precedence(item)\n```", "```py\nsympy.printing.pretty.pretty_symbology.U(name)\n```", "```py\nsympy.printing.pretty.pretty_symbology.pretty_use_unicode(flag=None)\n```", "```py\nsympy.printing.pretty.pretty_symbology.pretty_try_use_unicode()\n```", "```py\nsympy.printing.pretty.pretty_symbology.xstr(*args)\n```", "```py\nsympy.printing.pretty.pretty_symbology.g(l)\n```", "```py\nsympy.printing.pretty.pretty_symbology.G(l)\n```", "```py\nsympy.printing.pretty.pretty_symbology.greek_letters = ['alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lamda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega']\n```", "```py\nsympy.printing.pretty.pretty_symbology.digit_2txt = {'0': 'ZERO', '1': 'ONE', '2': 'TWO', '3': 'THREE', '4': 'FOUR', '5': 'FIVE', '6': 'SIX', '7': 'SEVEN', '8': 'EIGHT', '9': 'NINE'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.symb_2txt = {'(': 'LEFT PARENTHESIS', ')': 'RIGHT PARENTHESIS', '+': 'PLUS SIGN', '-': 'MINUS', '=': 'EQUALS SIGN', '[': 'LEFT SQUARE BRACKET', ']': 'RIGHT SQUARE BRACKET', 'int': 'INTEGRAL', 'sum': 'SUMMATION', '{': 'LEFT CURLY BRACKET', '{}': 'CURLY BRACKET', '}': 'RIGHT CURLY BRACKET'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.sub = {'(': '₍', ')': '₎', '+': '₊', '-': '₋', '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄', '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉', '=': '₌', 'a': 'ₐ', 'beta': 'ᵦ', 'chi': 'ᵪ', 'e': 'ₑ', 'gamma': 'ᵧ', 'h': 'ₕ', 'i': 'ᵢ', 'k': 'ₖ', 'l': 'ₗ', 'm': 'ₘ', 'n': 'ₙ', 'o': 'ₒ', 'p': 'ₚ', 'phi': 'ᵩ', 'r': 'ᵣ', 'rho': 'ᵨ', 's': 'ₛ', 't': 'ₜ', 'u': 'ᵤ', 'v': 'ᵥ', 'x': 'ₓ'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.sup = {'(': '⁽', ')': '⁾', '+': '⁺', '-': '⁻', '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', '=': '⁼', 'i': 'ⁱ', 'n': 'ⁿ'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.xobj(symb, length)\n```", "```py\nsympy.printing.pretty.pretty_symbology.vobj(symb, height)\n```", "```py\nsympy.printing.pretty.pretty_symbology.hobj(symb, width)\n```", "```py\nsympy.printing.pretty.pretty_symbology.root = {2: '√', 3: '∛', 4: '∜'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.VF(txt)\n```", "```py\nsympy.printing.pretty.pretty_symbology.frac = {(1, 2): '½', (1, 3): '⅓', (1, 4): '¼', (1, 5): '⅕', (1, 6): '⅙', (1, 8): '⅛', (2, 3): '⅔', (2, 5): '⅖', (3, 4): '¾', (3, 5): '⅗', (3, 8): '⅜', (4, 5): '⅘', (5, 6): '⅚', (5, 8): '⅝', (7, 8): '⅞'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.xsym(sym)\n```", "```py\nsympy.printing.pretty.pretty_symbology.atoms_table = {'And': '∧', 'Arrow': '→', 'ArrowFromBar': '↦', 'Complexes': 'ℂ', 'Contradiction': '┬', 'Dagger': '†', 'Degree': '°', 'Differential': 'ⅆ', 'Dots': '…', 'ElementOf': '∈', 'EmptySequence': 'EmptySequence', 'EmptySet': '∅', 'Equiv': '⇔', 'Exp1': 'ℯ', 'IdentityMatrix': '𝕀', 'ImaginaryUnit': 'ⅈ', 'Implies': '⇔', 'Infinity': '∞', 'Integers': 'ℤ', 'Intersection': '∩', 'Modifier Letter Low Ring': '˳', 'Multiplication': '×', 'Nand': '⊼', 'Naturals': 'ℕ', 'Naturals0': 'ℕ₀', 'NegativeInfinity': '-∞', 'Nor': '⊽', 'Not': '¬', 'NotArrow': '↛', 'NotEquiv': '⇎', 'NotImplies': '⇎', 'OneMatrix': '𝟙', 'Or': '∨', 'Pi': 'π', 'Rationals': 'ℚ', 'Reals': 'ℝ', 'Ring': '∘', 'SmallElementOf': '∊', 'SuperscriptMinus': '⁻', 'SuperscriptPlus': '⁺', 'SymmetricDifference': '∆', 'Tautology': '┴', 'TensorProduct': '⨂', 'Union': '∪', 'Universe': '𝕌', 'Xor': '⊻', 'ZeroMatrix': '𝟘'}\n```", "```py\nsympy.printing.pretty.pretty_symbology.pretty_atom(atom_name, default=None, printer=None)\n```", "```py\nsympy.printing.pretty.pretty_symbology.pretty_symbol(symb_name, bold_name=False)\n```", "```py\nsympy.printing.pretty.pretty_symbology.annotated(letter)\n```", "```py\nclass sympy.printing.pretty.stringpict.stringPict(s, baseline=0)\n```", "```py\nabove(*args)\n```", "```py\nbelow(*args)\n```", "```py\n>>> from sympy.printing.pretty.stringpict import stringPict\n>>> print(stringPict(\"x+3\").below(\n...       stringPict.LINE, '3')[0]) \nx+3\n---\n 3 \n```", "```py\nheight()\n```", "```py\nleft(*args)\n```", "```py\nleftslash()\n```", "```py\nstatic next(*args)\n```", "```py\nparens(left='(', right=')', ifascii_nougly=False)\n```", "```py\nrender(*args, **kwargs)\n```", "```py\nright(*args)\n```", "```py\n>>> from sympy.printing.pretty.stringpict import stringPict\n>>> print(stringPict(\"10\").right(\" + \",stringPict(\"1\\r-\\r2\",1))[0])\n 1\n10 + -\n 2 \n```", "```py\nroot(n=None)\n```", "```py\nstatic stack(*args)\n```", "```py\nterminal_width()\n```", "```py\nwidth()\n```", "```py\nclass sympy.printing.pretty.stringpict.prettyForm(s, baseline=0, binding=0, unicode=None)\n```", "```py\nATOM this is an atom: never needs to be parenthesized\nFUNC this is a function application: parenthesize if added (?)\nDIV  this is a division: make wider division if divided\nPOW  this is a power: only parenthesize if exponent\nMUL  this is a multiplication: parenthesize if powered\nADD  this is an addition: parenthesize if multiplied or powered\nNEG  this is a negative number: optimize if added, parenthesize if\n     multiplied or powered\nOPEN this is an open object: parenthesize if added, multiplied, or\n     powered (example: Piecewise) \n```", "```py\nstatic apply(function, *args)\n```", "```py\nsympy.printing.dot.dotprint(expr, styles=((<class 'sympy.core.basic.Basic'>, {'color': 'blue', 'shape': 'ellipse'}), (<class 'sympy.core.expr.Expr'>, {'color': 'black'})), atom=<function <lambda>>, maxdepth=None, repeat=True, labelfunc=<class 'str'>, **kwargs)\n```", "```py\n> (\n> \n>     (Basic, {'color': 'blue', 'shape': 'ellipse'}),\n> \n>     (Expr,  {'color': 'black'})\n> \n> ) \n> ```", "```py\n>>> from sympy import dotprint\n>>> from sympy.abc import x\n>>> print(dotprint(x+2)) \ndigraph{\n\n# Graph style\n\"ordering\"=\"out\"\n\"rankdir\"=\"TD\"\n\n#########\n# Nodes #\n#########\n\n\"Add(Integer(2), Symbol('x'))_()\" [\"color\"=\"black\", \"label\"=\"Add\", \"shape\"=\"ellipse\"];\n\"Integer(2)_(0,)\" [\"color\"=\"black\", \"label\"=\"2\", \"shape\"=\"ellipse\"];\n\"Symbol('x')_(1,)\" [\"color\"=\"black\", \"label\"=\"x\", \"shape\"=\"ellipse\"];\n\n#########\n# Edges #\n#########\n\n\"Add(Integer(2), Symbol('x'))_()\" -> \"Integer(2)_(0,)\";\n\"Add(Integer(2), Symbol('x'))_()\" -> \"Symbol('x')_(1,)\";\n} \n```"]