- en: scipy.optimize.least_squares
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scipy.optimize.least_squares
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares)
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Solve a nonlinear least-squares problem with bounds on the variables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 解决带有变量边界的非线性最小二乘问题。
- en: 'Given the residuals f(x) (an m-D real function of n real variables) and the
    loss function rho(s) (a scalar function), [`least_squares`](#scipy.optimize.least_squares
    "scipy.optimize.least_squares") finds a local minimum of the cost function F(x):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 给定残差f(x)（一个m-D实函数的n个实变量）和损失函数rho(s)（一个标量函数），[`least_squares`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")找到成本函数F(x)的局部最小值：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The purpose of the loss function rho(s) is to reduce the influence of outliers
    on the solution.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 损失函数rho(s)的目的是减少离群值对解决方案的影响。
- en: 'Parameters:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**fun**callable'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**fun**可调用'
- en: Function which computes the vector of residuals, with the signature `fun(x,
    *args, **kwargs)`, i.e., the minimization proceeds with respect to its first argument.
    The argument `x` passed to this function is an ndarray of shape (n,) (never a
    scalar, even for n=1). It must allocate and return a 1-D array_like of shape (m,)
    or a scalar. If the argument `x` is complex or the function `fun` returns complex
    residuals, it must be wrapped in a real function of real arguments, as shown at
    the end of the Examples section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 计算残差向量的函数，具有签名`fun(x, *args, **kwargs)`，即最小化将相对于其第一个参数进行。传递给此函数的参数`x`是形状为(n,)的ndarray（即使对于n=1，也不是标量）。它必须分配并返回形状为(m,)的1-D数组或标量。如果参数`x`是复数或函数`fun`返回复数残差，则必须将其包装在实数参数的实函数中，如示例部分的最后所示。
- en: '**x0**array_like with shape (n,) or float'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0**array_like，形状为(n,)或float'
- en: Initial guess on independent variables. If float, it will be treated as a 1-D
    array with one element. When *method* is ‘trf’, the initial guess might be slightly
    adjusted to lie sufficiently within the given *bounds*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 独立变量的初始猜测。如果是float，它将被视为具有一个元素的1-D数组。当*method*为‘trf’时，初始猜测可能会被略微调整，以确保足够位于给定的*bounds*内。
- en: '**jac**{‘2-point’, ‘3-point’, ‘cs’, callable}, optional'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**jac**{‘2-point’, ‘3-point’, ‘cs’, callable}，可选'
- en: Method of computing the Jacobian matrix (an m-by-n matrix, where element (i,
    j) is the partial derivative of f[i] with respect to x[j]). The keywords select
    a finite difference scheme for numerical estimation. The scheme ‘3-point’ is more
    accurate, but requires twice as many operations as ‘2-point’ (default). The scheme
    ‘cs’ uses complex steps, and while potentially the most accurate, it is applicable
    only when *fun* correctly handles complex inputs and can be analytically continued
    to the complex plane. Method ‘lm’ always uses the ‘2-point’ scheme. If callable,
    it is used as `jac(x, *args, **kwargs)` and should return a good approximation
    (or the exact value) for the Jacobian as an array_like (np.atleast_2d is applied),
    a sparse matrix (csr_matrix preferred for performance) or a [`scipy.sparse.linalg.LinearOperator`](scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算雅可比矩阵的方法（一个m×n矩阵，其中元素(i, j)是f[i]关于x[j]的偏导数）。关键字选择了用于数值估计的有限差分方案。方案“3-point”更精确，但需要两倍的操作量比“2-point”（默认）多。方案“cs”使用复步长，虽然可能是最精确的，但仅当*fun*正确处理复数输入并且能在复平面上解析延续时适用。方法“lm”始终使用“2-point”方案。如果可调用，则用作`jac(x,
    *args, **kwargs)`，应返回雅可比矩阵的良好近似值（或确切值），作为数组（np.atleast_2d应用），稀疏矩阵（出于性能考虑，优先使用csr_matrix）或[`scipy.sparse.linalg.LinearOperator`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator")。
- en: '**bounds**2-tuple of array_like or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"), optional'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**bounds**形如2元组的array_like或[`Bounds`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")，可选'
- en: 'There are two ways to specify bounds:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种指定边界的方法：
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Bounds`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")类的实例'
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Lower and upper bounds on independent variables. Defaults to no bounds. Each
    array must match the size of *x0* or be a scalar, in the latter case a bound will
    be the same for all variables. Use `np.inf` with an appropriate sign to disable
    bounds on all or some variables.
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立变量的上下界。默认无界。每个数组必须与*x0*的大小相匹配或者是标量，在后一种情况下，所有变量的边界将相同。使用适当符号的`np.inf`以禁用所有或部分变量的边界。
- en: '**method**{‘trf’, ‘dogbox’, ‘lm’}, optional'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**method**{‘trf’, ‘dogbox’, ‘lm’}, optional'
- en: Algorithm to perform minimization.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最小化的算法。
- en: '‘trf’ : Trust Region Reflective algorithm, particularly suitable for large
    sparse problems with bounds. Generally robust method.'
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘trf’：反射信赖区域算法，特别适用于具有边界的大型稀疏问题。通常是健壮的方法。
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘dogbox’ : dogleg algorithm with rectangular trust regions, typical use case
    is small problems with bounds. Not recommended for problems with rank-deficient
    Jacobian.'
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘dogbox’：矩形信赖区域的狗腿算法，典型应用场景是具有边界的小问题。不推荐处理秩亏的雅可比矩阵问题。
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘lm’ : Levenberg-Marquardt algorithm as implemented in MINPACK. Doesn’t handle
    bounds and sparse Jacobians. Usually the most efficient method for small unconstrained
    problems.'
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘lm’：MINPACK中实现的Levenberg-Marquardt算法。不处理边界和稀疏雅可比矩阵。通常是小型无约束问题的最有效方法。
- en: Default is ‘trf’. See Notes for more information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为‘trf’。更多信息请参见注释。
- en: '**ftol**float or None, optional'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**ftol**float或None，可选'
- en: Tolerance for termination by the change of the cost function. Default is 1e-8\.
    The optimization process is stopped when `dF < ftol * F`, and there was an adequate
    agreement between a local quadratic model and the true model in the last step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 终止由成本函数变化的公差。默认为1e-8。当`dF < ftol * F`且在上一步中局部二次模型与真实模型之间有足够协议时，优化过程停止。
- en: If None and ‘method’ is not ‘lm’, the termination by this condition is disabled.
    If ‘method’ is ‘lm’, this tolerance must be higher than machine epsilon.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 若为None且‘method’不为‘lm’，则此条件下的终止被禁用。若‘method’为‘lm’，则此公差必须高于机器epsilon。
- en: '**xtol**float or None, optional'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**xtol**float或None，可选'
- en: 'Tolerance for termination by the change of the independent variables. Default
    is 1e-8\. The exact condition depends on the *method* used:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 终止由独立变量变化的公差。默认为1e-8。确切条件取决于所使用的*method*：
- en: 'For ‘trf’ and ‘dogbox’ : `norm(dx) < xtol * (xtol + norm(x))`.'
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于‘trf’和‘dogbox’：`norm(dx) < xtol * (xtol + norm(x))`。
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For ‘lm’ : `Delta < xtol * norm(xs)`, where `Delta` is a trust-region radius
    and `xs` is the value of `x` scaled according to *x_scale* parameter (see below).'
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于‘lm’：`Delta < xtol * norm(xs)`，其中`Delta`是信赖区域半径，`xs`是根据*x_scale*参数缩放后的*x*的值（见下文）。
- en: If None and ‘method’ is not ‘lm’, the termination by this condition is disabled.
    If ‘method’ is ‘lm’, this tolerance must be higher than machine epsilon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 若为None且‘method’不为‘lm’，则此条件下的终止被禁用。若‘method’为‘lm’，则此公差必须高于机器epsilon。
- en: '**gtol**float or None, optional'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**gtol**float或None，可选'
- en: 'Tolerance for termination by the norm of the gradient. Default is 1e-8. The
    exact condition depends on a *method* used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 终止由梯度范数的公差。默认为1e-8。确切条件取决于所使用的*method*：
- en: 'For ‘trf’ : `norm(g_scaled, ord=np.inf) < gtol`, where `g_scaled` is the value
    of the gradient scaled to account for the presence of the bounds [[STIR]](#r20fc1df64af7-stir).'
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于‘trf’：`norm(g_scaled, ord=np.inf) < gtol`，其中`g_scaled`是考虑边界存在的梯度值[[STIR]](#r20fc1df64af7-stir)。
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For ‘dogbox’ : `norm(g_free, ord=np.inf) < gtol`, where `g_free` is the gradient
    with respect to the variables which are not in the optimal state on the boundary.'
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于‘dogbox’：`norm(g_free, ord=np.inf) < gtol`，其中`g_free`是相对于在边界上不处于最佳状态的变量的梯度。
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For ‘lm’ : the maximum absolute value of the cosine of angles between columns
    of the Jacobian and the residual vector is less than *gtol*, or the residual vector
    is zero.'
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于‘lm’：雅可比矩阵的列与残差向量之间夹角的最大绝对值小于*gtol*，或者残差向量为零。
- en: If None and ‘method’ is not ‘lm’, the termination by this condition is disabled.
    If ‘method’ is ‘lm’, this tolerance must be higher than machine epsilon.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 若为None且‘method’不为‘lm’，则此条件下的终止被禁用。若‘method’为‘lm’，则此公差必须高于机器epsilon。
- en: '**x_scale**array_like or ‘jac’, optional'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**x_scale**array_like或‘jac’，可选'
- en: Characteristic scale of each variable. Setting *x_scale* is equivalent to reformulating
    the problem in scaled variables `xs = x / x_scale`. An alternative view is that
    the size of a trust region along jth dimension is proportional to `x_scale[j]`.
    Improved convergence may be achieved by setting *x_scale* such that a step of
    a given size along any of the scaled variables has a similar effect on the cost
    function. If set to ‘jac’, the scale is iteratively updated using the inverse
    norms of the columns of the Jacobian matrix (as described in [[JJMore]](#r20fc1df64af7-jjmore)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量的特征尺度。设置 *x_scale* 相当于在缩放变量 `xs = x / x_scale` 中重新表述问题。另一种观点是，沿第 j 维的信任区域大小与
    `x_scale[j]` 成比例。通过设置 *x_scale*，可以实现改进的收敛性，使得沿着任何缩放变量的给定大小步骤对成本函数产生类似的影响。如果设置为
    ‘jac’，则使用雅可比矩阵列的逆范数进行迭代更新尺度（如 [[JJMore]](#r20fc1df64af7-jjmore) 中描述）。
- en: '**loss**str or callable, optional'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**loss**str 或 callable，可选'
- en: 'Determines the loss function. The following keyword values are allowed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 确定损失函数。允许以下关键字值：
- en: '‘linear’ (default) : `rho(z) = z`. Gives a standard least-squares problem.'
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘linear’（默认）：`rho(z) = z`。给出一个标准的最小二乘问题。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘soft_l1’ : `rho(z) = 2 * ((1 + z)**0.5 - 1)`. The smooth approximation of
    l1 (absolute value) loss. Usually a good choice for robust least squares.'
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘soft_l1’：`rho(z) = 2 * ((1 + z)**0.5 - 1)`。l1（绝对值）损失的平滑逼近。通常是鲁棒最小二乘的良好选择。
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘huber’ : `rho(z) = z if z <= 1 else 2*z**0.5 - 1`. Works similarly to ‘soft_l1’.'
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '‘huber’ : `rho(z) = z if z <= 1 else 2*z**0.5 - 1`。与 ‘soft_l1’ 类似工作。'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘cauchy’ : `rho(z) = ln(1 + z)`. Severely weakens outliers influence, but may
    cause difficulties in optimization process.'
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '‘cauchy’ : `rho(z) = ln(1 + z)`. 严重削弱离群值的影响，但可能会导致优化过程中的困难。'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘arctan’ : `rho(z) = arctan(z)`. Limits a maximum loss on a single residual,
    has properties similar to ‘cauchy’.'
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘arctan’：`rho(z) = arctan(z)`。限制单个残差的最大损失，具有类似 ‘cauchy’ 的特性。
- en: If callable, it must take a 1-D ndarray `z=f**2` and return an array_like with
    shape (3, m) where row 0 contains function values, row 1 contains first derivatives
    and row 2 contains second derivatives. Method ‘lm’ supports only ‘linear’ loss.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可调用，它必须接受一个一维 ndarray `z=f**2` 并返回一个形状为 (3, m) 的 array_like，其中第 0 行包含函数值，第
    1 行包含一阶导数，第 2 行包含二阶导数。方法 ‘lm’ 仅支持 ‘linear’ 损失。
- en: '**f_scale**float, optional'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**f_scale**float，可选'
- en: Value of soft margin between inlier and outlier residuals, default is 1.0\.
    The loss function is evaluated as follows `rho_(f**2) = C**2 * rho(f**2 / C**2)`,
    where `C` is *f_scale*, and `rho` is determined by *loss* parameter. This parameter
    has no effect with `loss='linear'`, but for other *loss* values it is of crucial
    importance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变量之间的软边界值，默认为 1.0。损失函数的评估如下 `rho_(f**2) = C**2 * rho(f**2 / C**2)`，其中 `C` 是
    *f_scale*，而 `rho` 受 *loss* 参数控制。对于 `loss='linear'`，此参数没有影响，但对于其他 *loss* 值，它至关重要。
- en: '**max_nfev**None or int, optional'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**max_nfev**None 或 int，可选'
- en: 'Maximum number of function evaluations before the termination. If None (default),
    the value is chosen automatically:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 函数评估的最大次数在终止之前。如果为 None（默认），则自动选择该值：
- en: 'For ‘trf’ and ‘dogbox’ : 100 * n.'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ‘trf’ 和 ‘dogbox’：100 * n。
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For ‘lm’ : 100 * n if *jac* is callable and 100 * n * (n + 1) otherwise (because
    ‘lm’ counts function calls in Jacobian estimation).'
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'For ‘lm’ : 100 * n if *jac* is callable and 100 * n * (n + 1) otherwise (because
    ‘lm’ counts function calls in Jacobian estimation).'
- en: '**diff_step**None or array_like, optional'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**diff_step**None 或 array_like，可选'
- en: Determines the relative step size for the finite difference approximation of
    the Jacobian. The actual step is computed as `x * diff_step`. If None (default),
    then *diff_step* is taken to be a conventional “optimal” power of machine epsilon
    for the finite difference scheme used [[NR]](#r20fc1df64af7-nr).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确定雅可比矩阵有限差分近似的相对步长。实际步长计算为 `x * diff_step`。如果为 None（默认），则 *diff_step* 被认为是用于有限差分方案的常规“最优”机器
    epsilon 的幂 [[NR]](#r20fc1df64af7-nr)。
- en: '**tr_solver**{None, ‘exact’, ‘lsmr’}, optional'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**tr_solver**{None, ‘exact’, ‘lsmr’}，可选'
- en: Method for solving trust-region subproblems, relevant only for ‘trf’ and ‘dogbox’
    methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 解决信任区域子问题的方法，仅对 ‘trf’ 和 ‘dogbox’ 方法有效。
- en: ‘exact’ is suitable for not very large problems with dense Jacobian matrices.
    The computational complexity per iteration is comparable to a singular value decomposition
    of the Jacobian matrix.
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘exact’ 适用于问题规模不是很大且雅可比矩阵稠密的情况。每次迭代的计算复杂度与雅可比矩阵的奇异值分解相当。
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘lsmr’ is suitable for problems with sparse and large Jacobian matrices. It
    uses the iterative procedure [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr") for finding a solution of a linear least-squares problem
    and only requires matrix-vector product evaluations.
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘lsmr’适用于具有稀疏和大雅可比矩阵的问题。它使用迭代过程[`scipy.sparse.linalg.lsmr`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr")来找到线性最小二乘问题的解，并且只需矩阵-向量乘积评估。
- en: If None (default), the solver is chosen based on the type of Jacobian returned
    on the first iteration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为None（默认值），则求解器基于第一次迭代返回的雅可比矩阵类型选择。
- en: '**tr_options**dict, optional'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**tr_options**字典，可选'
- en: Keyword options passed to trust-region solver.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字选项传递给信任区域求解器。
- en: '`tr_solver=''exact''`: *tr_options* are ignored.'
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tr_solver=''exact''`：*tr_options*将被忽略。'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tr_solver=''lsmr''`: options for [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr"). Additionally, `method=''trf''` supports ‘regularize’
    option (bool, default is True), which adds a regularization term to the normal
    equation, which improves convergence if the Jacobian is rank-deficient [[Byrd]](#r20fc1df64af7-byrd)
    (eq. 3.4).'
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tr_solver=''lsmr''`：[`scipy.sparse.linalg.lsmr`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr")的选项。此外，`method=''trf''`支持‘regularize’选项（布尔值，默认为True），该选项在正规方程中添加正则化项，如果雅可比矩阵是秩缺乏的[[Byrd]](#r20fc1df64af7-byrd)（eq.
    3.4）时可以改善收敛性。'
- en: '**jac_sparsity**{None, array_like, sparse matrix}, optional'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**jac_sparsity**{None, array_like, 稀疏矩阵}，可选'
- en: Defines the sparsity structure of the Jacobian matrix for finite difference
    estimation, its shape must be (m, n). If the Jacobian has only few non-zero elements
    in *each* row, providing the sparsity structure will greatly speed up the computations
    [[Curtis]](#r20fc1df64af7-curtis). A zero entry means that a corresponding element
    in the Jacobian is identically zero. If provided, forces the use of ‘lsmr’ trust-region
    solver. If None (default), then dense differencing will be used. Has no effect
    for ‘lm’ method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 定义雅可比矩阵的稀疏结构用于有限差分估计，其形状必须为(m, n)。如果雅可比矩阵每行只有少量非零元素，则提供稀疏结构将极大加速计算[[Curtis]](#r20fc1df64af7-curtis)。零条目意味着雅可比矩阵中对应元素恒为零。如果提供，则强制使用‘lsmr’信任区域求解器。如果为None（默认值），则将使用密集差分。对‘lm’方法无效。
- en: '**verbose**{0, 1, 2}, optional'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**详细**{0, 1, 2}，可选'
- en: 'Level of algorithm’s verbosity:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 算法详细程度：
- en: '0 (default) : work silently.'
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0（默认值）：静默工作。
- en: ''
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : display a termination report.'
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：显示终止报告。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2 : display progress during iterations (not supported by ‘lm’ method).'
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2：在迭代过程中显示进展（不支持‘lm’方法）。
- en: '**args, kwargs**tuple and dict, optional'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**args, kwargs**元组和字典，可选'
- en: Additional arguments passed to *fun* and *jac*. Both empty by default. The calling
    signature is `fun(x, *args, **kwargs)` and the same for *jac*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给*fun*和*jac*的额外参数。默认情况下两者为空。调用签名为`fun(x, *args, **kwargs)`，*jac*相同。
- en: 'Returns:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**result**OptimizeResult'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**result**OptimizeResult'
- en: '[`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") with the following fields defined:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[`OptimizeResult`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")，定义了以下字段：'
- en: xndarray, shape (n,)
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: xndarray，形状为(n,)
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solution found.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 找到解决方案。
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: costfloat
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: costfloat
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Value of the cost function at the solution.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解处成本函数的值。
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: funndarray, shape (m,)
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: funndarray，形状为(m,)
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Vector of residuals at the solution.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解处的残差向量。
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: jacndarray, sparse matrix or LinearOperator, shape (m, n)
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: jacndarray、稀疏矩阵或线性算子，形状为(m, n)
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modified Jacobian matrix at the solution, in the sense that J^T J is a Gauss-Newton
    approximation of the Hessian of the cost function. The type is the same as the
    one used by the algorithm.
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在解处的修改雅可比矩阵，即J^T J是成本函数海森矩阵的高斯-牛顿近似。类型与算法使用的类型相同。
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: gradndarray, shape (m,)
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: gradndarray，形状为(m,)
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gradient of the cost function at the solution.
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解处成本函数的梯度。
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: optimalityfloat
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优越性浮点数
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First-order optimality measure. In unconstrained problems, it is always the
    uniform norm of the gradient. In constrained problems, it is the quantity which
    was compared with *gtol* during iterations.
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一阶最优性度量。在无约束问题中，它总是梯度的一致范数。在有约束问题中，它是在迭代过程中与*gtol*比较的量。
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: active_maskndarray of int, shape (n,)
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: active_maskndarray整数，形状为(n,)
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each component shows whether a corresponding constraint is active (that is,
    whether a variable is at the bound):'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个分量显示相应约束是否活跃（即变量是否位于边界处）：
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '0 : a constraint is not active.'
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：约束未生效。
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '-1 : a lower bound is active.'
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: -1：下界生效。
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : an upper bound is active.'
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1 : 上限激活。'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Might be somewhat arbitrary for ‘trf’ method as it generates a sequence of strictly
    feasible iterates and *active_mask* is determined within a tolerance threshold.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 ‘trf’ 方法来说可能有些随意，因为它生成严格可行迭代序列，并且 *active_mask* 在容差阈值内确定。
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: nfevint
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: nfevint
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number of function evaluations done. Methods ‘trf’ and ‘dogbox’ do not count
    function calls for numerical Jacobian approximation, as opposed to ‘lm’ method.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数评估次数。‘trf’ 和 ‘dogbox’ 方法不计算数值雅可比逼近的函数调用次数，而‘lm’方法则计算。
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: njevint or None
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: njevint 或 None
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number of Jacobian evaluations done. If numerical Jacobian approximation is
    used in ‘lm’ method, it is set to None.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 雅可比矩阵评估次数。如果在 ‘lm’ 方法中使用数值雅可比逼近，则设置为 None。
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: statusint
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: statusint
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The reason for algorithm termination:'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 算法终止的原因：
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '-1 : improper input parameters status returned from MINPACK.'
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-1 : 从 MINPACK 返回的不合适的输入参数状态。'
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : the maximum number of function evaluations is exceeded.'
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0 : 超过了最大函数评估次数。'
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : *gtol* termination condition is satisfied.'
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1 : *gtol* 终止条件满足。'
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2 : *ftol* termination condition is satisfied.'
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2 : *ftol* 终止条件满足。'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '3 : *xtol* termination condition is satisfied.'
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '3 : *xtol* 终止条件满足。'
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '4 : Both *ftol* and *xtol* termination conditions are satisfied.'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4 : *ftol* 和 *xtol* 终止条件均满足。'
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: messagestr
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: messagestr
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Verbal description of the termination reason.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 终止原因的口头描述。
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: successbool
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: successbool
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: True if one of the convergence criteria is satisfied (*status* > 0).
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果满足其中一个收敛条件，则返回 True（*status* > 0）。
- en: See also
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`leastsq`](scipy.optimize.leastsq.html#scipy.optimize.leastsq "scipy.optimize.leastsq")'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[`leastsq`](scipy.optimize.leastsq.html#scipy.optimize.leastsq "scipy.optimize.leastsq")'
- en: A legacy wrapper for the MINPACK implementation of the Levenberg-Marquadt algorithm.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: MINPACK 实现的 Levenberg-Marquadt 算法的遗留包装器。
- en: '[`curve_fit`](scipy.optimize.curve_fit.html#scipy.optimize.curve_fit "scipy.optimize.curve_fit")'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[`curve_fit`](scipy.optimize.curve_fit.html#scipy.optimize.curve_fit "scipy.optimize.curve_fit")'
- en: Least-squares minimization applied to a curve-fitting problem.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 用于曲线拟合问题的最小二乘最小化。
- en: Notes
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Method ‘lm’ (Levenberg-Marquardt) calls a wrapper over least-squares algorithms
    implemented in MINPACK (lmder, lmdif). It runs the Levenberg-Marquardt algorithm
    formulated as a trust-region type algorithm. The implementation is based on paper
    [[JJMore]](#r20fc1df64af7-jjmore), it is very robust and efficient with a lot
    of smart tricks. It should be your first choice for unconstrained problems. Note
    that it doesn’t support bounds. Also, it doesn’t work when m < n.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ‘lm’ 方法（Levenberg-Marquardt）调用 MINPACK 中实现的最小二乘算法的包装器（lmder, lmdif）。它以信任区域类型算法的形式运行
    Levenberg-Marquardt 算法。该实现基于文献 [[JJMore]](#r20fc1df64af7-jjmore)，非常稳健和高效，采用了许多巧妙的技巧。对于无约束问题，它应该是你的首选。注意它不支持边界条件，且在
    m < n 时不起作用。
- en: Method ‘trf’ (Trust Region Reflective) is motivated by the process of solving
    a system of equations, which constitute the first-order optimality condition for
    a bound-constrained minimization problem as formulated in [[STIR]](#r20fc1df64af7-stir).
    The algorithm iteratively solves trust-region subproblems augmented by a special
    diagonal quadratic term and with trust-region shape determined by the distance
    from the bounds and the direction of the gradient. This enhancements help to avoid
    making steps directly into bounds and efficiently explore the whole space of variables.
    To further improve convergence, the algorithm considers search directions reflected
    from the bounds. To obey theoretical requirements, the algorithm keeps iterates
    strictly feasible. With dense Jacobians trust-region subproblems are solved by
    an exact method very similar to the one described in [[JJMore]](#r20fc1df64af7-jjmore)
    (and implemented in MINPACK). The difference from the MINPACK implementation is
    that a singular value decomposition of a Jacobian matrix is done once per iteration,
    instead of a QR decomposition and series of Givens rotation eliminations. For
    large sparse Jacobians a 2-D subspace approach of solving trust-region subproblems
    is used [[STIR]](#r20fc1df64af7-stir), [[Byrd]](#r20fc1df64af7-byrd). The subspace
    is spanned by a scaled gradient and an approximate Gauss-Newton solution delivered
    by [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr"). When no constraints are imposed the algorithm is
    very similar to MINPACK and has generally comparable performance. The algorithm
    works quite robust in unbounded and bounded problems, thus it is chosen as a default
    algorithm.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 方法‘trf’（Trust Region Reflective）的动机源于解决方程组的过程，这组成了形式化为[[STIR]](#r20fc1df64af7-stir)中约束边界最小化问题的一阶最优性条件。该算法通过迭代解决增强的信赖域子问题，其特殊对角二次项增强了与边界的距离和梯度方向决定的信赖域形状。这些增强有助于避免直接朝着边界步进，并有效地探索变量空间的整体。为了进一步提高收敛速度，该算法考虑了从边界反射的搜索方向。为了符合理论要求，算法保持迭代点始终可行。对于稠密雅可比矩阵，信赖域子问题通过一种与[[JJMore]](#r20fc1df64af7-jjmore)描述的方法非常相似的准确方法来解决（在MINPACK中实现）。与MINPACK实现的不同之处在于，雅可比矩阵的奇异值分解在每次迭代中只进行一次，而不是QR分解和一系列Givens旋转消元。对于大型稀疏雅可比矩阵，使用二维子空间方法解决信赖域子问题，该子空间由梯度的缩放和[`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr")提供的近似Gauss-Newton解决方案所构成[[STIR]](#r20fc1df64af7-stir)，[[Byrd]](#r20fc1df64af7-byrd)。当不加约束时，该算法与MINPACK非常相似，并且通常具有可比较的性能。该算法在无界和有界问题中表现相当强大，因此被选择为默认算法。
- en: Method ‘dogbox’ operates in a trust-region framework, but considers rectangular
    trust regions as opposed to conventional ellipsoids [[Voglis]](#r20fc1df64af7-voglis).
    The intersection of a current trust region and initial bounds is again rectangular,
    so on each iteration a quadratic minimization problem subject to bound constraints
    is solved approximately by Powell’s dogleg method [[NumOpt]](#r20fc1df64af7-numopt).
    The required Gauss-Newton step can be computed exactly for dense Jacobians or
    approximately by [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr") for large sparse Jacobians. The algorithm is likely
    to exhibit slow convergence when the rank of Jacobian is less than the number
    of variables. The algorithm often outperforms ‘trf’ in bounded problems with a
    small number of variables.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 方法‘dogbox’在信赖域框架中运作，但考虑到矩形信赖域，而不是传统的椭球体[[Voglis]](#r20fc1df64af7-voglis)。当前信赖域与初始边界的交集再次是矩形，因此在每次迭代中，通过Powell的dogleg方法近似地解决了一个受限二次最小化问题[[NumOpt]](#r20fc1df64af7-numopt)。对于稠密雅可比矩阵，可以通过准确计算Gauss-Newton步骤，或者对于大型稀疏雅可比矩阵，可以通过[`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr")进行近似计算。当雅可比矩阵的秩小于变量数时，该算法可能展现出较慢的收敛速度。在变量数较少的有界问题中，该算法通常优于‘trf’。
- en: Robust loss functions are implemented as described in [[BA]](#r20fc1df64af7-ba).
    The idea is to modify a residual vector and a Jacobian matrix on each iteration
    such that computed gradient and Gauss-Newton Hessian approximation match the true
    gradient and Hessian approximation of the cost function. Then the algorithm proceeds
    in a normal way, i.e., robust loss functions are implemented as a simple wrapper
    over standard least-squares algorithms.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁棒损失函数的实现如 [[BA]](#r20fc1df64af7-ba) 描述的那样。其思想是在每次迭代中修改残差向量和雅可比矩阵，使得计算的梯度和 Gauss-Newton
    Hessian 近似与成本函数的真实梯度和 Hessian 近似匹配。然后算法按正常方式继续，即，鲁棒损失函数被实现为标准最小二乘算法的简单包装。
- en: New in version 0.17.0.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 0.17.0 中的新增内容。
- en: References
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[STIR] ([1](#id1),[2](#id7),[3](#id9))'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[STIR] ([1](#id1),[2](#id7),[3](#id9))'
- en: M. A. Branch, T. F. Coleman, and Y. Li, “A Subspace, Interior, and Conjugate
    Gradient Method for Large-Scale Bound-Constrained Minimization Problems,” SIAM
    Journal on Scientific Computing, Vol. 21, Number 1, pp 1-23, 1999.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: M. A. Branch, T. F. Coleman 和 Y. Li，《A Subspace, Interior, and Conjugate Gradient
    Method for Large-Scale Bound-Constrained Minimization Problems》，《SIAM Journal
    on Scientific Computing》，第 21 卷，第 1 期，pp. 1-23，1999。
- en: '[[NR](#id3)]'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[[牛顿拉夫逊法](#id3)]'
- en: William H. Press et. al., “Numerical Recipes. The Art of Scientific Computing.
    3rd edition”, Sec. 5.7.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: William H. Press 等人，《Numerical Recipes. The Art of Scientific Computing. 3rd
    edition》，第 5.7 节。
- en: '[Byrd] ([1](#id4),[2](#id10))'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[Byrd] ([1](#id4),[2](#id10))'
- en: R. H. Byrd, R. B. Schnabel and G. A. Shultz, “Approximate solution of the trust
    region problem by minimization over two-dimensional subspaces”, Math. Programming,
    40, pp. 247-263, 1988.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: R. H. Byrd, R. B. Schnabel 和 G. A. Shultz，《Approximate solution of the trust
    region problem by minimization over two-dimensional subspaces》，《Math. Programming》，第
    40 卷，pp. 247-263，1988。
- en: '[[Curtis](#id5)]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[[Curtis](#id5)]'
- en: A. Curtis, M. J. D. Powell, and J. Reid, “On the estimation of sparse Jacobian
    matrices”, Journal of the Institute of Mathematics and its Applications, 13, pp.
    117-120, 1974.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: A. Curtis, M. J. D. Powell 和 J. Reid，《On the estimation of sparse Jacobian matrices》，《Journal
    of the Institute of Mathematics and its Applications》，第 13 卷，pp. 117-120，1974。
- en: '[JJMore] ([1](#id2),[2](#id6),[3](#id8))'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[JJMore] ([1](#id2),[2](#id6),[3](#id8))'
- en: 'J. J. More, “The Levenberg-Marquardt Algorithm: Implementation and Theory,”
    Numerical Analysis, ed. G. A. Watson, Lecture Notes in Mathematics 630, Springer
    Verlag, pp. 105-116, 1977.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'J. J. More，《The Levenberg-Marquardt Algorithm: Implementation and Theory》，《Numerical
    Analysis》，编者 G. A. Watson，Lecture Notes in Mathematics 630，Springer Verlag，pp.
    105-116，1977。'
- en: '[[Voglis](#id11)]'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[[Voglis](#id11)]'
- en: C. Voglis and I. E. Lagaris, “A Rectangular Trust Region Dogleg Approach for
    Unconstrained and Bound Constrained Nonlinear Optimization”, WSEAS International
    Conference on Applied Mathematics, Corfu, Greece, 2004.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C. Voglis 和 I. E. Lagaris，《A Rectangular Trust Region Dogleg Approach for Unconstrained
    and Bound Constrained Nonlinear Optimization》，WSEAS International Conference on
    Applied Mathematics，希腊科尔富，2004。
- en: '[[NumOpt](#id12)]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[[数值优化](#id12)]'
- en: J. Nocedal and S. J. Wright, “Numerical optimization, 2nd edition”, Chapter
    4.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: J. Nocedal 和 S. J. Wright，《Numerical optimization, 2nd edition》，第 4 章。
- en: '[[BA](#id13)]'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[[BA](#id13)]'
- en: 'B. Triggs et. al., “Bundle Adjustment - A Modern Synthesis”, Proceedings of
    the International Workshop on Vision Algorithms: Theory and Practice, pp. 298-372,
    1999.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'B. Triggs 等人，《Bundle Adjustment - A Modern Synthesis》，《Proceedings of the International
    Workshop on Vision Algorithms: Theory and Practice》，pp. 298-372，1999。'
- en: Examples
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: In this example we find a minimum of the Rosenbrock function without bounds
    on independent variables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在独立变量上找到了 Rosenbrock 函数的最小值，没有约束。
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we only provide the vector of the residuals. The algorithm constructs
    the cost function as a sum of squares of the residuals, which gives the Rosenbrock
    function. The exact minimum is at `x = [1.0, 1.0]`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只提供残差向量。算法将成本函数构建为残差平方和，这给出了 Rosenbrock 函数。精确的最小值在 `x = [1.0, 1.0]` 处。
- en: '[PRE3]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We now constrain the variables, in such a way that the previous solution becomes
    infeasible. Specifically, we require that `x[1] >= 1.5`, and `x[0]` left unconstrained.
    To this end, we specify the *bounds* parameter to [`least_squares`](#scipy.optimize.least_squares
    "scipy.optimize.least_squares") in the form `bounds=([-np.inf, 1.5], np.inf)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们限制变量，使得先前的解决方案变得不可行。具体来说，我们要求 `x[1] >= 1.5`，而 `x[0]` 保持未约束。为此，我们在 [`least_squares`](#scipy.optimize.least_squares
    "scipy.optimize.least_squares") 中的 *bounds* 参数中指定了形式为 `bounds=([-np.inf, 1.5],
    np.inf)`。
- en: 'We also provide the analytic Jacobian:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了分析雅可比矩阵：
- en: '[PRE4]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Putting this all together, we see that the new solution lies on the bound:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们看到新解决方案位于边界上：
- en: '[PRE5]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we solve a system of equations (i.e., the cost function should be zero
    at a minimum) for a Broyden tridiagonal vector-valued function of 100000 variables:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们解一个方程组（即，成本函数在最小值处应为零），对一个有 100000 个变量的 Broyden 三对角向量值函数进行约束：
- en: '[PRE6]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The corresponding Jacobian matrix is sparse. We tell the algorithm to estimate
    it by finite differences and provide the sparsity structure of Jacobian to significantly
    speed up this process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的雅可比矩阵是稀疏的。我们告诉算法通过有限差分来估计它，并提供雅可比矩阵的稀疏结构，以显著加快这个过程。
- en: '[PRE7]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s also solve a curve fitting problem using robust loss function to take
    care of outliers in the data. Define the model function as `y = a + b * exp(c
    * t)`, where t is a predictor variable, y is an observation and a, b, c are parameters
    to estimate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还用鲁棒损失函数解决一个曲线拟合问题，以处理数据中的离群值。定义模型函数为`y = a + b * exp(c * t)`，其中t是预测变量，y是观测值，a、b、c是要估计的参数。
- en: 'First, define the function which generates the data with noise and outliers,
    define the model parameters, and generate data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义生成带有噪声和离群值数据的函数，定义模型参数，并生成数据：
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Define function for computing residuals and initial estimate of parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 定义计算残差和参数初始估计的函数。
- en: '[PRE9]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Compute a standard least-squares solution:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 计算标准最小二乘解：
- en: '[PRE10]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now compute two solutions with two different robust loss functions. The parameter
    *f_scale* is set to 0.1, meaning that inlier residuals should not significantly
    exceed 0.1 (the noise level used).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用两个不同的鲁棒损失函数计算两个解。参数*f_scale*设为0.1，意味着内点残差不应显著超过0.1（所用的噪声水平）。
- en: '[PRE11]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And, finally, plot all the curves. We see that by selecting an appropriate *loss*
    we can get estimates close to optimal even in the presence of strong outliers.
    But keep in mind that generally it is recommended to try ‘soft_l1’ or ‘huber’
    losses first (if at all necessary) as the other two options may cause difficulties
    in optimization process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，绘制所有曲线。我们可以看到通过选择适当的*loss*，即使在存在强离群值的情况下，我们也可以得到接近最优的估计。但请记住，通常建议首先尝试使用‘soft_l1’或‘huber’损失（如有必要），因为其他两个选项可能会在优化过程中造成困难。
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![../../_images/scipy-optimize-least_squares-1_00_00.png](../Images/2ae49de882c02b5c0b611ae4394a5dd3.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![../../_images/scipy-optimize-least_squares-1_00_00.png](../Images/2ae49de882c02b5c0b611ae4394a5dd3.png)'
- en: 'In the next example, we show how complex-valued residual functions of complex
    variables can be optimized with `least_squares()`. Consider the following function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们展示了如何使用`least_squares()`来优化复变量的复值残差函数。考虑以下函数：
- en: '[PRE13]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We wrap it into a function of real variables that returns real residuals by
    simply handling the real and imaginary parts as independent variables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其封装为一个处理实部和虚部作为独立变量的实变量函数，返回实残差：
- en: '[PRE14]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Thus, instead of the original m-D complex function of n complex variables we
    optimize a 2m-D real function of 2n real variables:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不再优化原始的n个复变量的m-D复杂函数，而是优化一个2n个实变量的2m-D实函数：
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
