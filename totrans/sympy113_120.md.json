["```py\n>>> from sympy import Array\n>>> a1 = Array([[1, 2], [3, 4], [5, 6]])\n>>> a1\n[[1, 2], [3, 4], [5, 6]]\n>>> a1.shape\n(3, 2)\n>>> a1.rank()\n2\n>>> from sympy.abc import x, y, z\n>>> a2 = Array([[[x, y], [z, x*z]], [[1, x*y], [1/x, x/y]]])\n>>> a2\n[[[x, y], [z, x*z]], [[1, x*y], [1/x, x/y]]]\n>>> a2.shape\n(2, 2, 2)\n>>> a2.rank()\n3 \n```", "```py\n>>> m1 = Array(range(12), (3, 4))\n>>> m1\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n>>> m2 = Array(range(12), (3, 2, 2))\n>>> m2\n[[[0, 1], [2, 3]], [[4, 5], [6, 7]], [[8, 9], [10, 11]]]\n>>> m2[1,1,1]\n7\n>>> m2.reshape(4, 3)\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]] \n```", "```py\n>>> m2[:, 1, 1]\n[3, 7, 11] \n```", "```py\n>>> from sympy.abc import x, y, z\n>>> m3 = Array([x**3, x*y, z])\n>>> m3.diff(x)\n[3*x**2, y, 0]\n>>> m3.diff(z)\n[0, 0, 1] \n```", "```py\n>>> (1+x)*m3\n[x**3*(x + 1), x*y*(x + 1), z*(x + 1)] \n```", "```py\n>>> m3.applyfunc(lambda x: x/2)\n[x**3/2, x*y/2, z/2] \n```", "```py\n>>> m2.tolist()\n[[[0, 1], [2, 3]], [[4, 5], [6, 7]], [[8, 9], [10, 11]]]\n>>> isinstance(m2.tolist(), list)\nTrue \n```", "```py\n>>> m1.tomatrix()\nMatrix([\n[0, 1,  2,  3],\n[4, 5,  6,  7],\n[8, 9, 10, 11]]) \n```", "```py\n>>> from sympy import Array, tensorproduct\n>>> from sympy.abc import x,y,z,t\n>>> A = Array([x, y, z, t])\n>>> B = Array([1, 2, 3, 4])\n>>> tensorproduct(A, B)\n[[x, 2*x, 3*x, 4*x], [y, 2*y, 3*y, 4*y], [z, 2*z, 3*z, 4*z], [t, 2*t, 3*t, 4*t]] \n```", "```py\n>>> from sympy.tensor.array.expressions import ArrayTensorProduct\n>>> ArrayTensorProduct(A, B)\nArrayTensorProduct([x, y, z, t], [1, 2, 3, 4]) \n```", "```py\n>>> ArrayTensorProduct(A, B).as_explicit()\n[[x, 2*x, 3*x, 4*x], [y, 2*y, 3*y, 4*y], [z, 2*z, 3*z, 4*z], [t, 2*t, 3*t, 4*t]] \n```", "```py\n>>> from sympy import eye\n>>> p1 = tensorproduct(A, eye(4))\n>>> p1\n[[[x, 0, 0, 0], [0, x, 0, 0], [0, 0, x, 0], [0, 0, 0, x]], [[y, 0, 0, 0], [0, y, 0, 0], [0, 0, y, 0], [0, 0, 0, y]], [[z, 0, 0, 0], [0, z, 0, 0], [0, 0, z, 0], [0, 0, 0, z]], [[t, 0, 0, 0], [0, t, 0, 0], [0, 0, t, 0], [0, 0, 0, t]]] \n```", "```py\n>>> p1[0,:,:]\n[[x, 0, 0, 0], [0, x, 0, 0], [0, 0, x, 0], [0, 0, 0, x]] \n```", "```py\n>>> from sympy import tensorcontraction\n>>> C = Array([[x, y], [z, t]]) \n```", "```py\n>>> tensorcontraction(C, (0, 1))\nt + x \n```", "```py\n>>> from sympy.tensor.array.expressions import ArrayContraction\n>>> ArrayContraction(C, (0, 1))\nArrayContraction([[x, y], [z, t]], (0, 1))\n>>> ArrayContraction(C, (0, 1)).as_explicit()\nt + x \n```", "```py\n>>> D = Array([[2, 1], [0, -1]])\n>>> tensorcontraction(tensorproduct(C, D), (1, 2))\n[[2*x, x - y], [2*z, -t + z]] \n```", "```py\n>>> from sympy import Matrix\n>>> Matrix([[x, y], [z, t]])*Matrix([[2, 1], [0, -1]])\nMatrix([\n[2*x,  x - y],\n[2*z, -t + z]]) \n```", "```py\n>>> C.tomatrix()*D.tomatrix()\nMatrix([\n[2*x,  x - y],\n[2*z, -t + z]]) \n```", "```py\n>>> from sympy import tensordiagonal\n>>> from sympy.abc import a, b, c, d\n>>> m = Matrix([[a, b], [c, d]])\n>>> tensorcontraction(m, [0, 1])\na + d\n>>> tensordiagonal(m, [0, 1])\n[a, d] \n```", "```py\n>>> from sympy import derive_by_array\n>>> from sympy.abc import x, y, z, t\n>>> from sympy import sin, exp \n```", "```py\n>>> derive_by_array(sin(x*y), x)\ny*cos(x*y) \n```", "```py\n>>> derive_by_array(sin(x*y), [x, y, z])\n[y*cos(x*y), x*cos(x*y), 0] \n```", "```py\n>>> basis = [x, y, z]\n>>> ax = derive_by_array([exp(x), sin(y*z), t], basis)\n>>> ax\n[[exp(x), 0, 0], [0, z*cos(y*z), 0], [0, y*cos(y*z), 0]] \n```", "```py\n>>> tensorcontraction(ax, (0, 1))\nz*cos(y*z) + exp(x) \n```", "```py\nclass sympy.tensor.array.ImmutableDenseNDimArray(iterable, shape=None, **kwargs)\n```", "```py\nclass sympy.tensor.array.ImmutableSparseNDimArray(iterable=None, shape=None, **kwargs)\n```", "```py\nclass sympy.tensor.array.MutableDenseNDimArray(iterable=None, shape=None, **kwargs)\n```", "```py\nclass sympy.tensor.array.MutableSparseNDimArray(iterable=None, shape=None, **kwargs)\n```", "```py\nsympy.tensor.array.derive_by_array(expr, dx)\n```", "```py\n>>> from sympy import derive_by_array\n>>> from sympy.abc import x, y, z, t\n>>> from sympy import cos\n>>> derive_by_array(cos(x*t), x)\n-t*sin(t*x)\n>>> derive_by_array(cos(x*t), [x, y, z, t])\n[-t*sin(t*x), 0, 0, -x*sin(t*x)]\n>>> derive_by_array([x, y**2*z], [[x, y], [z, t]])\n[[[1, 0], [0, 2*y*z]], [[0, y**2], [0, 0]]] \n```", "```py\nsympy.tensor.array.permutedims(expr, perm=None, index_order_old=None, index_order_new=None)\n```", "```py\n>>> from sympy.abc import x, y, z, t\n>>> from sympy import sin\n>>> from sympy import Array, permutedims\n>>> a = Array([[x, y, z], [t, sin(x), 0]])\n>>> a\n[[x, y, z], [t, sin(x), 0]]\n>>> permutedims(a, (1, 0))\n[[x, t], [y, sin(x)], [z, 0]] \n```", "```py\n>>> from sympy import transpose\n>>> transpose(a)\n[[x, t], [y, sin(x)], [z, 0]] \n```", "```py\n>>> b = Array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n>>> permutedims(b, (2, 1, 0))\n[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]\n>>> permutedims(b, (1, 2, 0))\n[[[1, 5], [2, 6]], [[3, 7], [4, 8]]] \n```", "```py\n>>> permutedims(b, index_order_old=\"cba\", index_order_new=\"abc\")\n[[[1, 5], [3, 7]], [[2, 6], [4, 8]]]\n>>> permutedims(b, index_order_old=\"cab\", index_order_new=\"abc\")\n[[[1, 5], [2, 6]], [[3, 7], [4, 8]]] \n```", "```py\n>>> from sympy.combinatorics import Permutation\n>>> permutedims(b, Permutation([1, 2, 0]))\n[[[1, 5], [2, 6]], [[3, 7], [4, 8]]] \n```", "```py\nsympy.tensor.array.tensorcontraction(array, *contraction_axes)\n```", "```py\n>>> from sympy import Array, tensorcontraction\n>>> from sympy import Matrix, eye\n>>> tensorcontraction(eye(3), (0, 1))\n3\n>>> A = Array(range(18), (3, 2, 3))\n>>> A\n[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]\n>>> tensorcontraction(A, (0, 2))\n[21, 30] \n```", "```py\n>>> from sympy import tensorproduct\n>>> from sympy.abc import a,b,c,d,e,f,g,h\n>>> m1 = Matrix([[a, b], [c, d]])\n>>> m2 = Matrix([[e, f], [g, h]])\n>>> p = tensorproduct(m1, m2)\n>>> p\n[[[[a*e, a*f], [a*g, a*h]], [[b*e, b*f], [b*g, b*h]]], [[[c*e, c*f], [c*g, c*h]], [[d*e, d*f], [d*g, d*h]]]]\n>>> tensorcontraction(p, (1, 2))\n[[a*e + b*g, a*f + b*h], [c*e + d*g, c*f + d*h]]\n>>> m1*m2\nMatrix([\n[a*e + b*g, a*f + b*h],\n[c*e + d*g, c*f + d*h]]) \n```", "```py\nsympy.tensor.array.tensorproduct(*args)\n```", "```py\n>>> from sympy.tensor.array import tensorproduct, Array\n>>> from sympy.abc import x, y, z, t\n>>> A = Array([[1, 2], [3, 4]])\n>>> B = Array([x, y])\n>>> tensorproduct(A, B)\n[[[x, y], [2*x, 2*y]], [[3*x, 3*y], [4*x, 4*y]]]\n>>> tensorproduct(A, x)\n[[x, 2*x], [3*x, 4*x]]\n>>> tensorproduct(A, B, B)\n[[[[x**2, x*y], [x*y, y**2]], [[2*x**2, 2*x*y], [2*x*y, 2*y**2]]], [[[3*x**2, 3*x*y], [3*x*y, 3*y**2]], [[4*x**2, 4*x*y], [4*x*y, 4*y**2]]]] \n```", "```py\n>>> from sympy import Matrix, eye\n>>> m = Matrix([[x, y], [z, t]])\n>>> p = tensorproduct(eye(3), m)\n>>> p\n[[[[x, y], [z, t]], [[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[x, y], [z, t]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]], [[x, y], [z, t]]]] \n```", "```py\nsympy.tensor.array.tensordiagonal(array, *diagonal_axes)\n```", "```py\n>>> from sympy import Array, tensordiagonal\n>>> from sympy import Matrix, eye\n>>> tensordiagonal(eye(3), (0, 1))\n[1, 1, 1] \n```", "```py\n>>> from sympy.abc import a,b,c,d\n>>> m1 = Matrix([[a, b], [c, d]])\n>>> tensordiagonal(m1, [0, 1])\n[a, d] \n```", "```py\n>>> A = Array(range(18), (3, 2, 3))\n>>> A\n[[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]], [[12, 13, 14], [15, 16, 17]]]\n>>> tensordiagonal(A, (0, 2))\n[[0, 7, 14], [3, 10, 17]]\n>>> from sympy import permutedims\n>>> tensordiagonal(A, (0, 2)) == permutedims(Array([A[0, :, 0], A[1, :, 1], A[2, :, 2]]), [1, 0])\nTrue \n```"]