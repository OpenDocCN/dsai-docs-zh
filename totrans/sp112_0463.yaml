- en: scipy.optimize.milp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.milp.html#scipy.optimize.milp](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.milp.html#scipy.optimize.milp)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Mixed-integer linear programming
  prefs: []
  type: TYPE_NORMAL
- en: 'Solves problems of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\min_x \ & c^T x \\ \mbox{such that} \ & b_l \leq A x \leq b_u,\\
    & l \leq x \leq u, \\ & x_i \in \mathbb{Z}, i \in X_i\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(x\) is a vector of decision variables; \(c\), \(b_l\), \(b_u\), \(l\),
    and \(u\) are vectors; \(A\) is a matrix, and \(X_i\) is the set of indices of
    decision variables that must be integral. (In this context, a variable that can
    assume only integer values is said to be “integral”; it has an “integrality” constraint.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, that’s:'
  prefs: []
  type: TYPE_NORMAL
- en: 'minimize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By default, `l = 0` and `u = np.inf` unless specified with `bounds`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**c**1D dense array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The coefficients of the linear objective function to be minimized. *c* is converted
    to a double precision array before the problem is solved.
  prefs: []
  type: TYPE_NORMAL
- en: '**integrality**1D dense array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates the type of integrality constraint on each decision variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`0` : Continuous variable; no integrality constraint.'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` : Integer variable; decision variable must be an integer within *bounds*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`2` : Semi-continuous variable; decision variable must be within *bounds* or
    take value `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`3` : Semi-integer variable; decision variable must be an integer within *bounds*
    or take value `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, all variables are continuous. *integrality* is converted to an array
    of integers before the problem is solved.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**scipy.optimize.Bounds, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Bounds on the decision variables. Lower and upper bounds are converted to double
    precision arrays before the problem is solved. The `keep_feasible` parameter of
    the [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    object is ignored. If not specified, all decision variables are constrained to
    be non-negative.
  prefs: []
  type: TYPE_NORMAL
- en: '**constraints**sequence of scipy.optimize.LinearConstraint, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear constraints of the optimization problem. Arguments may be one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A single [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single tuple that can be converted to a [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") object as `LinearConstraint(*constraints)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sequence composed entirely of objects of type 1\. and 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the problem is solved, all values are converted to double precision,
    and the matrices of constraint coefficients are converted to instances of [`scipy.sparse.csc_array`](scipy.sparse.csc_array.html#scipy.sparse.csc_array
    "scipy.sparse.csc_array"). The `keep_feasible` parameter of [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") objects is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**options**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of solver options. The following keys are recognized.
  prefs: []
  type: TYPE_NORMAL
- en: 'dispbool (default: `False`)'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `True` if indicators of optimization status are to be printed to the
    console during optimization.
  prefs: []
  type: TYPE_NORMAL
- en: node_limitint, optional
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of nodes (linear program relaxations) to solve before stopping.
    Default is no maximum number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'presolvebool (default: `True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Presolve attempts to identify trivial infeasibilities, identify trivial unboundedness,
    and simplify the problem before sending it to the main solver.
  prefs: []
  type: TYPE_NORMAL
- en: time_limitfloat, optional
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of seconds allotted to solve the problem. Default is no time
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: mip_rel_gapfloat, optional
  prefs: []
  type: TYPE_NORMAL
- en: 'Termination criterion for MIP solver: solver will terminate when the gap between
    the primal objective value and the dual objective bound, scaled by the primal
    objective value, is <= mip_rel_gap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**res**OptimizeResult'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`scipy.optimize.OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult"). The object is guaranteed to have the following
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: statusint
  prefs: []
  type: TYPE_NORMAL
- en: An integer representing the exit status of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '`0` : Optimal solution found.'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` : Iteration or time limit reached.'
  prefs: []
  type: TYPE_NORMAL
- en: '`2` : Problem is infeasible.'
  prefs: []
  type: TYPE_NORMAL
- en: '`3` : Problem is unbounded.'
  prefs: []
  type: TYPE_NORMAL
- en: '`4` : Other; see message for details.'
  prefs: []
  type: TYPE_NORMAL
- en: successbool
  prefs: []
  type: TYPE_NORMAL
- en: '`True` when an optimal solution is found and `False` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: messagestr
  prefs: []
  type: TYPE_NORMAL
- en: A string descriptor of the exit status of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The following attributes will also be present, but the values may be `None`,
    depending on the solution status.
  prefs: []
  type: TYPE_NORMAL
- en: xndarray
  prefs: []
  type: TYPE_NORMAL
- en: The values of the decision variables that minimize the objective function while
    satisfying the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: funfloat
  prefs: []
  type: TYPE_NORMAL
- en: The optimal value of the objective function `c @ x`.
  prefs: []
  type: TYPE_NORMAL
- en: mip_node_countint
  prefs: []
  type: TYPE_NORMAL
- en: The number of subproblems or “nodes” solved by the MILP solver.
  prefs: []
  type: TYPE_NORMAL
- en: mip_dual_boundfloat
  prefs: []
  type: TYPE_NORMAL
- en: The MILP solver’s final estimate of the lower bound on the optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: mip_gapfloat
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the primal objective value and the dual objective bound,
    scaled by the primal objective value.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '[`milp`](#scipy.optimize.milp "scipy.optimize.milp") is a wrapper of the HiGHS
    linear optimization software [[1]](#rab6a199aba7d-1). The algorithm is deterministic,
    and it typically finds the global optimum of moderately challenging mixed-integer
    linear programs (when it exists).'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Huangfu, Q., Galabova, I., Feldmeier, M., and Hall, J. A. J. “HiGHS - high performance
    software for linear optimization.” [https://highs.dev/](https://highs.dev/)
  prefs: []
  type: TYPE_NORMAL
- en: '[2]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Huangfu, Q. and Hall, J. A. J. “Parallelizing the dual revised simplex method.”
    Mathematical Programming Computation, 10 (1), 119-142, 2018\. DOI: 10.1007/s12532-017-0130-5'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the problem at [https://en.wikipedia.org/wiki/Integer_programming#Example](https://en.wikipedia.org/wiki/Integer_programming#Example),
    which is expressed as a maximization problem of two variables. Since [`milp`](#scipy.optimize.milp
    "scipy.optimize.milp") requires that the problem be expressed as a minimization
    problem, the objective function coefficients on the decision variables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the negative sign: we maximize the original objective function by minimizing
    the negative of the objective function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We collect the coefficients of the constraints into arrays like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because there is no lower limit on these constraints, we have defined a variable
    `b_l` full of values representing negative infinity. This may be unfamiliar to
    users of [`scipy.optimize.linprog`](scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"), which only accepts “less than” (or “upper bound”) inequality
    constraints of the form `A_ub @ x <= b_u`. By accepting both `b_l` and `b_u` of
    constraints `b_l <= A_ub @ x <= b_u`, [`milp`](#scipy.optimize.milp "scipy.optimize.milp")
    makes it easy to specify “greater than” inequality constraints, “less than” inequality
    constraints, and equality constraints concisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'These arrays are collected into a single [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") object like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The non-negativity bounds on the decision variables are enforced by default,
    so we do not need to provide an argument for *bounds*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the problem states that both decision variables must be integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We solve the problem like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that had we solved the relaxed problem (without integrality constraints):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: we would not have obtained the correct solution by rounding to the nearest integers.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples are given [in the tutorial](../../tutorial/optimize.html#tutorial-optimize-milp).
  prefs: []
  type: TYPE_NORMAL
