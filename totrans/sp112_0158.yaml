- en: scipy.integrate.solve_bvp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.solve_bvp.html#scipy.integrate.solve_bvp](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.solve_bvp.html#scipy.integrate.solve_bvp)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solve a boundary value problem for a system of ODEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function numerically solves a first order system of ODEs subject to two-point
    boundary conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here x is a 1-D independent variable, y(x) is an N-D vector-valued function
    and p is a k-D vector of unknown parameters which is to be found along with y(x).
    For the problem to be determined, there must be n + k boundary conditions, i.e.,
    bc must be an (n + k)-D function.
  prefs: []
  type: TYPE_NORMAL
- en: The last singular term on the right-hand side of the system is optional. It
    is defined by an n-by-n matrix S, such that the solution must satisfy S y(a) =
    0\. This condition will be forced during iterations, so it must not contradict
    boundary conditions. See [[2]](#r25f8479e577a-2) for the explanation how this
    term is handled when solving BVPs numerically.
  prefs: []
  type: TYPE_NORMAL
- en: Problems in a complex domain can be solved as well. In this case, y and p are
    considered to be complex, and f and bc are assumed to be complex-valued functions,
    but x stays real. Note that f and bc must be complex differentiable (satisfy Cauchy-Riemann
    equations [[4]](#r25f8479e577a-4)), otherwise you should rewrite your problem
    for real and imaginary parts separately. To solve a problem in a complex domain,
    pass an initial guess for y with a complex data type (see below).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-hand side of the system. The calling signature is `fun(x, y)`, or `fun(x,
    y, p)` if parameters are present. All arguments are ndarray: `x` with shape (m,),
    `y` with shape (n, m), meaning that `y[:, i]` corresponds to `x[i]`, and `p` with
    shape (k,). The return value must be an array with shape (n, m) and with the same
    layout as `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**bc**callable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function evaluating residuals of the boundary conditions. The calling signature
    is `bc(ya, yb)`, or `bc(ya, yb, p)` if parameters are present. All arguments are
    ndarray: `ya` and `yb` with shape (n,), and `p` with shape (k,). The return value
    must be an array with shape (n + k,).'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial mesh. Must be a strictly increasing sequence of real numbers with `x[0]=a`
    and `x[-1]=b`.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**array_like, shape (n, m)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess for the function values at the mesh nodes, ith column corresponds
    to `x[i]`. For problems in a complex domain pass *y* with a complex data type
    (even if the initial guess is purely real).
  prefs: []
  type: TYPE_NORMAL
- en: '**p**array_like with shape (k,) or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess for the unknown parameters. If None (default), it is assumed that
    the problem doesn’t depend on any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**S**array_like with shape (n, n) or None'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix defining the singular term. If None (default), the problem is solved
    without the singular term.
  prefs: []
  type: TYPE_NORMAL
- en: '**fun_jac**callable or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function computing derivatives of f with respect to y and p. The calling signature
    is `fun_jac(x, y)`, or `fun_jac(x, y, p)` if parameters are present. The return
    must contain 1 or 2 elements in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'df_dy : array_like with shape (n, n, m), where an element (i, j, q) equals
    to d f_i(x_q, y_q, p) / d (y_q)_j.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'df_dp : array_like with shape (n, k, m), where an element (i, j, q) equals
    to d f_i(x_q, y_q, p) / d p_j.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Here q numbers nodes at which x and y are defined, whereas i and j number vector
    components. If the problem is solved without unknown parameters, df_dp should
    not be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If *fun_jac* is None (default), the derivatives will be estimated by the forward
    finite differences.
  prefs: []
  type: TYPE_NORMAL
- en: '**bc_jac**callable or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Function computing derivatives of bc with respect to ya, yb, and p. The calling
    signature is `bc_jac(ya, yb)`, or `bc_jac(ya, yb, p)` if parameters are present.
    The return must contain 2 or 3 elements in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'dbc_dya : array_like with shape (n, n), where an element (i, j) equals to d
    bc_i(ya, yb, p) / d ya_j.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dbc_dyb : array_like with shape (n, n), where an element (i, j) equals to d
    bc_i(ya, yb, p) / d yb_j.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dbc_dp : array_like with shape (n, k), where an element (i, j) equals to d
    bc_i(ya, yb, p) / d p_j.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If the problem is solved without unknown parameters, dbc_dp should not be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If *bc_jac* is None (default), the derivatives will be estimated by the forward
    finite differences.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Desired tolerance of the solution. If we define `r = y' - f(x, y)`, where y
    is the found solution, then the solver tries to achieve on each mesh interval
    `norm(r / (1 + abs(f)) < tol`, where `norm` is estimated in a root mean squared
    sense (using a numerical quadrature formula). Default is 1e-3.
  prefs: []
  type: TYPE_NORMAL
- en: '**max_nodes**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum allowed number of the mesh nodes. If exceeded, the algorithm terminates.
    Default is 1000.
  prefs: []
  type: TYPE_NORMAL
- en: '**verbose**{0, 1, 2}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level of algorithm’s verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '0 (default) : work silently.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : display a termination report.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2 : display progress during iterations.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bc_tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Desired absolute tolerance for the boundary condition residuals: *bc* value
    should satisfy `abs(bc) < bc_tol` component-wise. Equals to *tol* by default.
    Up to 10 iterations are allowed to achieve this tolerance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bunch object with the following fields defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sol**PPoly'
  prefs: []
  type: TYPE_NORMAL
- en: Found solution for y as [`scipy.interpolate.PPoly`](scipy.interpolate.PPoly.html#scipy.interpolate.PPoly
    "scipy.interpolate.PPoly") instance, a C1 continuous cubic spline.
  prefs: []
  type: TYPE_NORMAL
- en: '**p**ndarray or None, shape (k,)'
  prefs: []
  type: TYPE_NORMAL
- en: Found parameters. None, if the parameters were not present in the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes of the final mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**ndarray, shape (n, m)'
  prefs: []
  type: TYPE_NORMAL
- en: Solution values at the mesh nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**yp**ndarray, shape (n, m)'
  prefs: []
  type: TYPE_NORMAL
- en: Solution derivatives at the mesh nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**rms_residuals**ndarray, shape (m - 1,)'
  prefs: []
  type: TYPE_NORMAL
- en: RMS values of the relative residuals over each mesh interval (see the description
    of *tol* parameter).
  prefs: []
  type: TYPE_NORMAL
- en: '**niter**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of completed iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '**status**int'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason for algorithm termination:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: The algorithm converged to the desired accuracy.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1: The maximum number of mesh nodes is exceeded.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2: A singular Jacobian encountered when solving the collocation system.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**message**string'
  prefs: []
  type: TYPE_NORMAL
- en: Verbal description of the termination reason.
  prefs: []
  type: TYPE_NORMAL
- en: '**success**bool'
  prefs: []
  type: TYPE_NORMAL
- en: True if the algorithm converged to the desired accuracy (`status=0`).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This function implements a 4th order collocation algorithm with the control
    of residuals similar to [[1]](#r25f8479e577a-1). A collocation system is solved
    by a damped Newton method with an affine-invariant criterion function as described
    in [[3]](#r25f8479e577a-3).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in [[1]](#r25f8479e577a-1) integral residuals are defined without
    normalization by interval lengths. So, their definition is different by a multiplier
    of h**0.5 (h is an interval length) from the definition used here.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.18.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id3),[2](#id5))'
  prefs: []
  type: TYPE_NORMAL
- en: J. Kierzenka, L. F. Shampine, “A BVP Solver Based on Residual Control and the
    Maltab PSE”, ACM Trans. Math. Softw., Vol. 27, Number 3, pp. 299-316, 2001.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: L.F. Shampine, P. H. Muir and H. Xu, “A User-Friendly Fortran BVP Solver”.
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: U. Ascher, R. Mattheij and R. Russell “Numerical Solution of Boundary Value
    Problems for Ordinary Differential Equations”.
  prefs: []
  type: TYPE_NORMAL
- en: '[[4](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cauchy-Riemann equations](https://en.wikipedia.org/wiki/Cauchy-Riemann_equations)
    on Wikipedia.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we solve Bratu’s problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: for k = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We rewrite the equation as a first-order system and implement its right-hand
    side evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement evaluation of the boundary condition residuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the initial mesh with 5 nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This problem is known to have two solutions. To obtain both of them, we use
    two different initial guesses for y. We denote them by subscripts a and b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to run the solver.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s plot the two found solutions. We take an advantage of having the solution
    in a spline form to produce a smooth plot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-integrate-solve_bvp-1_00_00.png](../Images/5cbea3df378a236a759fa4681cf3e2c3.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the two solutions have similar shape, but differ in scale significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example, we solve a simple Sturm-Liouville problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is known that a non-trivial solution y = A * sin(k * x) is possible for
    k = pi * n, where n is an integer. To establish the normalization constant A =
    1 we add a boundary condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we rewrite our equation as a first-order system and implement its right-hand
    side evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that parameters p are passed as a vector (with one element in our case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the boundary conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up the initial mesh and guess for y. We aim to find the solution for k
    = 2 * pi, to achieve that we set values of y to approximately follow sin(2 * pi
    * x):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the solver with 6 as an initial guess for k.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the found k is approximately correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, plot the solution to see the anticipated sinusoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-integrate-solve_bvp-1_01_00.png](../Images/175cf204d4121d0a36d80889d6cee876.png)'
  prefs: []
  type: TYPE_IMG
