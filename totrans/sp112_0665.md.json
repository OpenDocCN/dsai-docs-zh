["```py\nclass scipy.signal.ShortTimeFFT(win, hop, fs, *, fft_mode='onesided', mfft=None, dual_win=None, scale_to=None, phase_shift=0)\n```", "```py\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from scipy.signal import ShortTimeFFT\n>>> from scipy.signal.windows import gaussian\n...\n>>> T_x, N = 1 / 20, 1000  # 20 Hz sampling rate for 50 s signal\n>>> t_x = np.arange(N) * T_x  # time indexes for signal\n>>> f_i = 1 * np.arctan((t_x - t_x[N // 2]) / 2) + 5  # varying frequency\n>>> x = np.sin(2*np.pi*np.cumsum(f_i)*T_x) # the signal \n```", "```py\n>>> g_std = 8  # standard deviation for Gaussian window in samples\n>>> w = gaussian(50, std=g_std, sym=True)  # symmetric Gaussian window\n>>> SFT = ShortTimeFFT(w, hop=10, fs=1/T_x, mfft=200, scale_to='magnitude')\n>>> Sx = SFT.stft(x)  # perform the STFT \n```", "```py\n>>> fig1, ax1 = plt.subplots(figsize=(6., 4.))  # enlarge plot a bit\n>>> t_lo, t_hi = SFT.extent(N)[:2]  # time range of plot\n>>> ax1.set_title(rf\"STFT ({SFT.m_num*SFT.T:g}$\\,s$ Gaussian window, \" +\n...               rf\"$\\sigma_t={g_std*SFT.T}\\,$s)\")\n>>> ax1.set(xlabel=f\"Time $t$ in seconds ({SFT.p_num(N)} slices, \" +\n...                rf\"$\\Delta t = {SFT.delta_t:g}\\,$s)\",\n...         ylabel=f\"Freq. $f$ in Hz ({SFT.f_pts} bins, \" +\n...                rf\"$\\Delta f = {SFT.delta_f:g}\\,$Hz)\",\n...         xlim=(t_lo, t_hi))\n...\n>>> im1 = ax1.imshow(abs(Sx), origin='lower', aspect='auto',\n...                  extent=SFT.extent(N), cmap='viridis')\n>>> ax1.plot(t_x, f_i, 'r--', alpha=.5, label='$f_i(t)$')\n>>> fig1.colorbar(im1, label=\"Magnitude $|S_x(t, f)|$\")\n...\n>>> # Shade areas where window slices stick out to the side:\n>>> for t0_, t1_ in [(t_lo, SFT.lower_border_end[0] * SFT.T),\n...                  (SFT.upper_border_begin(N)[0] * SFT.T, t_hi)]:\n...     ax1.axvspan(t0_, t1_, color='w', linewidth=0, alpha=.2)\n>>> for t_ in [0, N * SFT.T]:  # mark signal borders with vertical line:\n...     ax1.axvline(t_, color='y', linestyle='--', alpha=0.5)\n>>> ax1.legend()\n>>> fig1.tight_layout()\n>>> plt.show() \n```", "```py\n>>> SFT.invertible  # check if invertible\nTrue\n>>> x1 = SFT.istft(Sx, k1=N)\n>>> np.allclose(x, x1)\nTrue \n```", "```py\n>>> p_q = SFT.nearest_k_p(N // 2)\n>>> Sx0 = SFT.stft(x[:p_q])\n>>> Sx1 = SFT.stft(x[p_q:]) \n```", "```py\n>>> p0_ub = SFT.upper_border_begin(p_q)[1] - SFT.p_min\n>>> p1_le = SFT.lower_border_end[1] - SFT.p_min\n>>> Sx01 = np.hstack((Sx0[:, :p0_ub],\n...                   Sx0[:, p0_ub:] + Sx1[:, :p1_le],\n...                   Sx1[:, p1_le:]))\n>>> np.allclose(Sx01, Sx)  # Compare with SFT of complete signal\nTrue \n```", "```py\n>>> y_p = SFT.istft(Sx, N//3, N//2)\n>>> np.allclose(y_p, x[N//3:N//2])\nTrue \n```"]