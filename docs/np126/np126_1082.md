# NumPy 安全性

> 原文：[`numpy.org/doc/1.26/reference/security.html`](https://numpy.org/doc/1.26/reference/security.html)

安全问题可以按照项目 README 中描述的方式进行私下报告，也可以在打开[问题跟踪器上的新问题](https://github.com/numpy/numpy/issues/new/choose)时进行报告。[Python 安全报告指南](https://www.python.org/dev/security/)是一个很好的资源，其中的注意事项也适用于 NumPy。

NumPy 的维护人员不是安全专家。然而，我们对安全问题持有责任感，对 NumPy 代码库及其使用方式的专家。在发布针对 NumPy 的安全公告之前，请通知我们，因为我们乐意优先处理问题或帮助评估错误的严重性。我们事先不知道的安全公告可能会给所有相关方带来大量工作。

## 在处理不可信数据时的建议使用 NumPy

可以自由执行 NumPy（或 Python）函数的用户必须被视为具有相同特权的进程/Python 解释器。

也就是说，NumPy 通常能够安全使用来自非特权用户的*数据*，并且通过安全的 API 函数读取（例如从文本文件或没有 pickle 支持的`.npy`文件加载）。恶意*值*或*数据大小*不应导致特权升级。

使用不受信任数据时，以下要点可能很有用或应该注意：

+   耗尽内存可能导致内存溢出杀死，这是可能的拒绝服务攻击。可能的原因包括：

    +   读取文本文件的函数可能需要比原始输入文件大小多得多的内存。

    +   如果用户可以创建任意形状的数组，NumPy 的广播意味着中间或结果数组可能比输入大得多。

+   NumPy 结构化 dtype 允许大量的复杂性。幸运的是，当提供意外的结构化 dtype 时，大多数代码会出现优雅失效。然而，代码应该禁止不受信任的用户提供这些（例如通过`.npy`文件）或仔细检查包含的字段以防止嵌套结构/子数组 dtype。

+   通常应考虑通过用户输入传递是不安全的（除了被读取的数据）。例如，`np.dtype(user_string)`或`dtype=user_string`。

+   操作的速度可能取决于值和内存顺序可能导致更大的临时内存使用和较慢的执行。这意味着操作可能比简单测试用例显着慢或使用更多内存。

+   在读取数据时，考虑强制规定特定形状（例如一维）或 dtype，如`float64`、`float32`或`int64`，以减少复杂性。

当处理非常规不可信数据时，建议对分析进行沙盒化，以防潜在的特权升级。如果使用基于 NumPy 的进一步库，则特别建议这样做，因为这些库会增加额外的复杂性和潜在的安全问题。

## 在处理不受信任数据时的建议使用 NumPy

能够自由执行 NumPy（或 Python）函数的用户必须被视为拥有与进程/Python 解释器相同的特权。

也就是说,NumPy 应该通常是安全的,可用于由特权用户提供的*数据*,并通过安全的 API 函数读取（例如从文本文件或不支持 pickle 的 `.npy` 文件加载）。恶意的*值*或*数据大小*绝不应导致特权升级。

在处理不受信任的数据时,以下几点可能有用或值得注意：

+   耗尽内存可能导致内存溢出,这是一种可能的拒绝服务攻击。可能的原因包括：

    +   读取文本文件的函数可能需要比原始输入文件大得多的内存。

    +   如果用户可以创建任意形状的数组,NumPy 的广播意味着中间或结果数组可能远大于输入。

+   NumPy 结构化 dtypes 允许大量复杂性。幸运的是,当提供意外的结构化 dtype 时,大多数代码都能优雅地失败。然而,代码应该禁止不受信任的用户提供这些（例如通过 `.npy` 文件）,或仔细检查包含的嵌套结构化/子数组 dtypes 的字段。

+   将用户输入传递下去通常应被视为不安全的（读取的数据除外）。一个例子是 `np.dtype(user_string)` 或 `dtype=user_string`。

+   操作的速度可能取决于值,内存顺序可能导致更大的临时内存使用和更慢的执行。这意味着与简单的测试用例相比,操作可能显著更慢或使用更多内存。

+   在读取数据时,考虑强制执行特定的形状（例如一维）或 dtype，如 `float64`、`float32` 或 `int64`，以减少复杂性。

在处理非平凡的不受信任数据时，建议对分析进行沙箱化以防止潜在的特权升级。如果进一步使用基于 NumPy 的库，这尤其是个好主意,因为这些库增加了额外的复杂性和潜在的安全问题。
