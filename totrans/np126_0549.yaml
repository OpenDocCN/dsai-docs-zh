- en: numpy.lib.format
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: numpy.lib.format
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.lib.format.html](https://numpy.org/doc/1.26/reference/generated/numpy.lib.format.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.lib.format.html](https://numpy.org/doc/1.26/reference/generated/numpy.lib.format.html)
- en: Binary serialization
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制序列化
- en: NPY format
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPY 格式
- en: A simple format for saving numpy arrays to disk with the full information about
    them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的格式，用于将 NumPy 数组保存到磁盘，并包含有关它们的完整信息。
- en: The `.npy` format is the standard binary file format in NumPy for persisting
    a *single* arbitrary NumPy array on disk. The format stores all of the shape and
    dtype information necessary to reconstruct the array correctly even on another
    machine with a different architecture. The format is designed to be as simple
    as possible while achieving its limited goals.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npy` 格式是 NumPy 中用于将*单个*任意 NumPy 数组持久化到磁盘的标准二进制文件格式。该格式存储了重建数组所需的所有形状和数据类型信息，即使在具有不同架构的另一台机器上也能正确重建数组。该格式旨在尽可能简单，同时实现其有限的目标。'
- en: The `.npz` format is the standard format for persisting *multiple* NumPy arrays
    on disk. A `.npz` file is a zip file containing multiple `.npy` files, one for
    each array.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npz` 格式是将*多个* NumPy 数组持久化到磁盘的标准格式。一个`.npz`文件是一个 zip 文件，包含多个`.npy`文件，每个文件对应一个数组。'
- en: Capabilities
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 能力
- en: Can represent all NumPy arrays including nested record arrays and object arrays.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。
- en: Represents the data in its native binary form.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以其本机二进制形式表示数据。
- en: Supports Fortran-contiguous arrays directly.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接支持 Fortran 连续数组。
- en: Stores all of the necessary information to reconstruct the array including shape
    and dtype on a machine of a different architecture. Both little-endian and big-endian
    arrays are supported, and a file with little-endian numbers will yield a little-endian
    array on any machine reading the file. The types are described in terms of their
    actual sizes. For example, if a machine with a 64-bit C “long int” writes out
    an array with “long ints”, a reading machine with 32-bit C “long ints” will yield
    an array with 64-bit integers.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储了重建数组所需的所有信息，包括在不同架构的机器上的形状和数据类型。支持小端和大端数组，具有小端数字的文件将在任何读取该文件的机器上产生小端数组。类型是根据它们的实际大小描述的。例如，如果一个具有
    64 位 C “long int”的机器写出一个带有“long ints”的数组，那么一个具有 32 位 C “long ints”的读取机器将产生一个带有
    64 位整数的数组。
- en: Is straightforward to reverse engineer. Datasets often live longer than the
    programs that created them. A competent developer should be able to create a solution
    in their preferred programming language to read most `.npy` files that they have
    been given without much documentation.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易被逆向工程。数据集通常比创建它们的程序存在时间更长。一个称职的开发者应该能够用他们喜欢的编程语言创建一个解决方案，以读取大部分没有太多文档的`.npy`文件。
- en: Allows memory-mapping of the data. See [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap").
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许内存映射数据。参见[`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap)。
- en: Can be read from a filelike stream object instead of an actual file.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从类似文件的流对象而不是实际文件中读取。
- en: Stores object arrays, i.e. arrays containing elements that are arbitrary Python
    objects. Files with object arrays are not to be mmapable, but can be read and
    written to disk.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不能进行内存映射，但可以读取和写入磁盘。
- en: Limitations
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses
    will be accepted for writing, but only the array data will be written out. A regular
    numpy.ndarray object will be created upon reading the file.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: numpy.ndarray 的任意子类并不完全保留。子类将被接受用于写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray
    对象。
- en: Warning
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Due to limitations in the interpretation of structured dtypes, dtypes with fields
    with empty names will have the names replaced by ‘f0’, ‘f1’, etc. Such arrays
    will not round-trip through the format entirely accurately. The data is intact;
    only the field names will differ. We are working on a fix for this. This fix will
    not require a change in the file format. The arrays with such structures can still
    be saved and restored, and the correct dtype may be restored by using the `loadedarray.view(correct_dtype)`
    method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对结构化数据类型的解释存在限制，具有空名称字段的数据类型将被替换为‘f0’、‘f1’等。这样的数组将无法完全准确地通过格式循环。数据是完整的；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用`loadedarray.view(correct_dtype)`方法恢复正确的数据类型。
- en: File extensions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件扩展名
- en: We recommend using the `.npy` and `.npz` extensions for files saved in this
    format. This is by no means a requirement; applications may wish to use these
    file formats but use an extension specific to the application. In the absence
    of an obvious alternative, however, we suggest using `.npy` and `.npz`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`.npy`和`.npz`扩展名保存此格式的文件。这绝不是必须的；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。
- en: Version numbering
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本编号
- en: The version numbering of these formats is independent of NumPy version numbering.
    If the format is upgraded, the code in *numpy.io* will still be able to read and
    write Version 1.0 files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式的版本编号与NumPy版本编号是独立的。如果格式升级，*numpy.io*中的代码仍将能够读取和写入版本1.0文件。
- en: Format Version 1.0
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本 1.0
- en: 'The first 6 bytes are a magic string: exactly `\x93NUMPY`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前6个字节是一个魔术字符串：正好为`\x93NUMPY`。
- en: 'The next 1 byte is an unsigned byte: the major version number of the file format,
    e.g. `\x01`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的1个字节是无符号字节：文件格式的主要版本号，例如`\x01`。
- en: 'The next 1 byte is an unsigned byte: the minor version number of the file format,
    e.g. `\x00`. Note: the version of the file format is not tied to the version of
    the numpy package.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的1个字节是无符号字节：文件格式的次要版本号，例如`\x00`。注意：文件格式的版本与numpy软件包的版本无关。
- en: 'The next 2 bytes form a little-endian unsigned short int: the length of the
    header data HEADER_LEN.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的2个字节形成一个小端无符号短整型：头数据HEADER_LEN的长度。
- en: The next HEADER_LEN bytes form the header data describing the array’s format.
    It is an ASCII string which contains a Python literal expression of a dictionary.
    It is terminated by a newline (`\n`) and padded with spaces (`\x20`) to make the
    total of `len(magic string) + 2 + len(length) + HEADER_LEN` be evenly divisible
    by 64 for alignment purposes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的HEADER_LEN字节形成描述数组格式的头数据。这是一个ASCII字符串，包含一个字典的Python文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic
    string) + 2 + len(length) + HEADER_LEN`的总和能够被64整除，以��对齐。
- en: 'The dictionary contains three keys:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 字典包含三个键：
- en: “descr”dtype.descr
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “descr”dtype.descr
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object that can be passed as an argument to the [`numpy.dtype`](numpy.dtype.html#numpy.dtype
    "numpy.dtype") constructor to create the array’s dtype.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可作为参数传递给[`numpy.dtype`](numpy.dtype.html#numpy.dtype "numpy.dtype")构造函数以创建数组dtype的对象。
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “fortran_order”bool
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “fortran_order”布尔值
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous
    arrays are a common form of non-C-contiguity, we allow them to be written directly
    to disk for efficiency.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组数据是否是Fortran连续的。由于Fortran连续数组是一种常见的非C连续形式，我们允许它们直接写入磁盘以提高效率。
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “shape”tuple of int
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “shape”整数元组
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The shape of the array.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组的形状。
- en: For repeatability and readability, the dictionary keys are sorted in alphabetic
    order. This is for convenience only. A writer SHOULD implement this if possible.
    A reader MUST NOT depend on this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重复性和可读性，字典键按字母顺序排序。这仅为方便起见。作者应尽可能实现这一点。读者不应依赖于此。
- en: Following the header comes the array data. If the dtype contains Python objects
    (i.e. `dtype.hasobject is True`), then the data is a Python pickle of the array.
    Otherwise the data is the contiguous (either C- or Fortran-, depending on `fortran_order`)
    bytes of the array. Consumers can figure out the number of bytes by multiplying
    the number of elements given by the shape (noting that `shape=()` means there
    is 1 element) by `dtype.itemsize`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后是数组数据。如果dtype包含Python对象（即`dtype.hasobject is True`），则数据是数组的Python pickle。否则，数据是数组的连续（无论是C还是Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数量相乘（注意`shape=()`表示有1个元素）乘以`dtype.itemsize`来计算字节数。
- en: Format Version 2.0
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本 2.0
- en: The version 1.0 format only allowed the array header to have a total size of
    65535 bytes. This can be exceeded by structured arrays with a large number of
    columns. The version 2.0 format extends the header size to 4 GiB. [`numpy.save`](numpy.save.html#numpy.save
    "numpy.save") will automatically save in 2.0 format if the data requires it, else
    it will always use the more compatible 1.0 format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.0格式仅允许数组头的总大小为65535字节。结构化数组的列数较多时可能会超过此限制。版本2.0格式将头大小扩展到4 GiB。[`numpy.save`](numpy.save.html#numpy.save
    "numpy.save")将根据数据的需要自动保存为2.0格式，否则将始终使用更兼容的1.0格式。
- en: 'The description of the fourth element of the header therefore has become: “The
    next 4 bytes form a little-endian unsigned int: the length of the header data
    HEADER_LEN.”'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，头的第四个元素的描述变为：“接下来的4个字节形成一个小端无符号整型：头数据HEADER_LEN的长度。”
- en: Format Version 3.0
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本 3.0
- en: This version replaces the ASCII string (which in practice was latin1) with a
    utf8-encoded string, so supports structured types with any unicode field names.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本用 utf8 编码的字符串替换了 ASCII 字符串（实际上是 latin1），因此支持具有任何 Unicode 字段名称的结构化类型。
- en: Notes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `.npy` format, including motivation for creating it and a comparison of
    alternatives, is described in the [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html
    "(in NumPy Enhancement Proposals)"), however details have evolved with time and
    this document is more current.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npy` 格式，包括创建动机和替代方案的比较，在 [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html
    "(in NumPy Enhancement Proposals)") 中有描述，但随着时间的推移，细节已经发生变化，本文档更为当前。'
- en: Functions
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数
- en: '| [`descr_to_dtype`](numpy.lib.format.descr_to_dtype.html#numpy.lib.format.descr_to_dtype
    "numpy.lib.format.descr_to_dtype")(descr) | Returns a dtype based off the given
    description. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| [`descr_to_dtype`](numpy.lib.format.descr_to_dtype.html#numpy.lib.format.descr_to_dtype
    "numpy.lib.format.descr_to_dtype")(descr) | 根据给定描述返回 dtype。 |'
- en: '| [`dtype_to_descr`](numpy.lib.format.dtype_to_descr.html#numpy.lib.format.dtype_to_descr
    "numpy.lib.format.dtype_to_descr")(dtype) | Get a serializable descriptor from
    the dtype. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| [`dtype_to_descr`](numpy.lib.format.dtype_to_descr.html#numpy.lib.format.dtype_to_descr
    "numpy.lib.format.dtype_to_descr")(dtype) | 从 dtype 获取可序列化的描述符。 |'
- en: '| [`header_data_from_array_1_0`](numpy.lib.format.header_data_from_array_1_0.html#numpy.lib.format.header_data_from_array_1_0
    "numpy.lib.format.header_data_from_array_1_0")(array) | Get the dictionary of
    header metadata from a numpy.ndarray. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| [`header_data_from_array_1_0`](numpy.lib.format.header_data_from_array_1_0.html#numpy.lib.format.header_data_from_array_1_0
    "numpy.lib.format.header_data_from_array_1_0")(array) | 从 numpy.ndarray 获取头部元数据的字典。
    |'
- en: '| [`magic`](numpy.lib.format.magic.html#numpy.lib.format.magic "numpy.lib.format.magic")(major, minor)
    | Return the magic string for the given file format version. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| [`magic`](numpy.lib.format.magic.html#numpy.lib.format.magic "numpy.lib.format.magic")(major, minor)
    | 返回给定文件格式版本的魔术字符串。 |'
- en: '| [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap")(filename[, mode, dtype, shape, ...]) | Open a
    .npy file as a memory-mapped array. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap")(filename[, mode, dtype, shape, ...]) | 将 .npy
    文件作为内存映射数组打开。 |'
- en: '| [`read_array`](numpy.lib.format.read_array.html#numpy.lib.format.read_array
    "numpy.lib.format.read_array")(fp[, allow_pickle, ...]) | Read an array from an
    NPY file. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| [`read_array`](numpy.lib.format.read_array.html#numpy.lib.format.read_array
    "numpy.lib.format.read_array")(fp[, allow_pickle, ...]) | 从 NPY 文件中读取数组。 |'
- en: '| [`read_array_header_1_0`](numpy.lib.format.read_array_header_1_0.html#numpy.lib.format.read_array_header_1_0
    "numpy.lib.format.read_array_header_1_0")(fp[, max_header_size]) | Read an array
    header from a filelike object using the 1.0 file format version. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| [`read_array_header_1_0`](numpy.lib.format.read_array_header_1_0.html#numpy.lib.format.read_array_header_1_0
    "numpy.lib.format.read_array_header_1_0")(fp[, max_header_size]) | 使用 1.0 文件格式版本从文件对象中读取数组头。
    |'
- en: '| [`read_array_header_2_0`](numpy.lib.format.read_array_header_2_0.html#numpy.lib.format.read_array_header_2_0
    "numpy.lib.format.read_array_header_2_0")(fp[, max_header_size]) | Read an array
    header from a filelike object using the 2.0 file format version. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| [`read_array_header_2_0`](numpy.lib.format.read_array_header_2_0.html#numpy.lib.format.read_array_header_2_0
    "numpy.lib.format.read_array_header_2_0")(fp[, max_header_size]) | 使用 2.0 文件格式版本从文件对象中读取数组头。
    |'
- en: '| [`read_magic`](numpy.lib.format.read_magic.html#numpy.lib.format.read_magic
    "numpy.lib.format.read_magic")(fp) | Read the magic string to get the version
    of the file format. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| [`read_magic`](numpy.lib.format.read_magic.html#numpy.lib.format.read_magic
    "numpy.lib.format.read_magic")(fp) | 读取魔术字符串以获取文件格式的版本。 |'
- en: '| [`write_array`](numpy.lib.format.write_array.html#numpy.lib.format.write_array
    "numpy.lib.format.write_array")(fp, array[, version, ...]) | Write an array to
    an NPY file, including a header. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| [`write_array`](numpy.lib.format.write_array.html#numpy.lib.format.write_array
    "numpy.lib.format.write_array")(fp, array[, version, ...]) | 将数组写入 NPY 文件，包括头部。
    |'
- en: '| [`write_array_header_1_0`](numpy.lib.format.write_array_header_1_0.html#numpy.lib.format.write_array_header_1_0
    "numpy.lib.format.write_array_header_1_0")(fp, d) | Write the header for an array
    using the 1.0 format. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| [`write_array_header_1_0`](numpy.lib.format.write_array_header_1_0.html#numpy.lib.format.write_array_header_1_0
    "numpy.lib.format.write_array_header_1_0")(fp, d) | 使用 1.0 格式写入数组头。 |'
- en: '| [`write_array_header_2_0`](numpy.lib.format.write_array_header_2_0.html#numpy.lib.format.write_array_header_2_0
    "numpy.lib.format.write_array_header_2_0")(fp, d) | Write the header for an array
    using the 2.0 format. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| [`write_array_header_2_0`](numpy.lib.format.write_array_header_2_0.html#numpy.lib.format.write_array_header_2_0
    "numpy.lib.format.write_array_header_2_0")(fp, d) | 使用 2.0 格式写入数组头。 |'
- en: NPY format
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NPY 格式
- en: A simple format for saving numpy arrays to disk with the full information about
    them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将 numpy 数组保存到磁盘的简单格式，包含有关它们的所有信息。
- en: The `.npy` format is the standard binary file format in NumPy for persisting
    a *single* arbitrary NumPy array on disk. The format stores all of the shape and
    dtype information necessary to reconstruct the array correctly even on another
    machine with a different architecture. The format is designed to be as simple
    as possible while achieving its limited goals.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npy` 格式是 NumPy 中用于在磁盘上持久化*单个*任意 NumPy 数组的标准二进制文件格式。该格式存储了重建数组所需的所有形状和 dtype
    信息，即使在具有不同架构的另一台机器上也能正确重建数组。该格式旨在尽可能简单，同时实现其有限的目标。'
- en: The `.npz` format is the standard format for persisting *multiple* NumPy arrays
    on disk. A `.npz` file is a zip file containing multiple `.npy` files, one for
    each array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npz` 格式是在磁盘上持久化*多个* NumPy 数组的标准格式。一个 `.npz` 文件是一个 zip 文件，包含多个 `.npy` 文件，每个文件对应一个数组。'
- en: Capabilities
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 能力
- en: Can represent all NumPy arrays including nested record arrays and object arrays.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。
- en: Represents the data in its native binary form.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以其本机二进制形式表示数据。
- en: Supports Fortran-contiguous arrays directly.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接支持 Fortran 连续数组。
- en: Stores all of the necessary information to reconstruct the array including shape
    and dtype on a machine of a different architecture. Both little-endian and big-endian
    arrays are supported, and a file with little-endian numbers will yield a little-endian
    array on any machine reading the file. The types are described in terms of their
    actual sizes. For example, if a machine with a 64-bit C “long int” writes out
    an array with “long ints”, a reading machine with 32-bit C “long ints” will yield
    an array with 64-bit integers.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储了重建数组所需的所有信息，包括形状和 dtype，在具有不同架构的机器上。支持小端和大端数组，并且具有小端数字的文件将在读取文件的任何机器上产生小端数组。类型是根据其实际大小描述的。例如，如果具有
    64 位 C “long int”的机器写出一个带有“long ints”的数组，那么具有 32 位 C “long ints”的读取机器将产生一个带有 64
    位整数的数组。
- en: Is straightforward to reverse engineer. Datasets often live longer than the
    programs that created them. A competent developer should be able to create a solution
    in their preferred programming language to read most `.npy` files that they have
    been given without much documentation.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于逆向工程。数据集通常比创建它们的程序存在时间更长。一位称职的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取大部分给定的 `.npy`
    文件而无需太多文档。
- en: Allows memory-mapping of the data. See [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap").
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对数据进行内存映射。参见 [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap")。
- en: Can be read from a filelike stream object instead of an actual file.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从类似文件流对象而不是实际文件中读取。
- en: Stores object arrays, i.e. arrays containing elements that are arbitrary Python
    objects. Files with object arrays are not to be mmapable, but can be read and
    written to disk.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不能进行内存映射，但可以读取和写入磁盘。
- en: Limitations
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses
    will be accepted for writing, but only the array data will be written out. A regular
    numpy.ndarray object will be created upon reading the file.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意的 numpy.ndarray 子类并不完全保留。子类将被接受进行写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray
    对象。
- en: Warning
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Due to limitations in the interpretation of structured dtypes, dtypes with fields
    with empty names will have the names replaced by ‘f0’, ‘f1’, etc. Such arrays
    will not round-trip through the format entirely accurately. The data is intact;
    only the field names will differ. We are working on a fix for this. This fix will
    not require a change in the file format. The arrays with such structures can still
    be saved and restored, and the correct dtype may be restored by using the `loadedarray.view(correct_dtype)`
    method.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对结构化 dtypes 的解释存在限制，具有空名称字段的 dtypes 将其名称替换为‘f0’、‘f1’等。这样的数组将无法完全准确地通过格式循环。数据完整；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用
    `loadedarray.view(correct_dtype)` 方法恢复正确的 dtype。
- en: File extensions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件扩展名
- en: We recommend using the `.npy` and `.npz` extensions for files saved in this
    format. This is by no means a requirement; applications may wish to use these
    file formats but use an extension specific to the application. In the absence
    of an obvious alternative, however, we suggest using `.npy` and `.npz`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`.npy`和`.npz`扩展名保存以这种格式保存的文件。这绝不是一个要求；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。
- en: Version numbering
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本编号
- en: The version numbering of these formats is independent of NumPy version numbering.
    If the format is upgraded, the code in *numpy.io* will still be able to read and
    write Version 1.0 files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式的版本编号与NumPy版本编号无关。如果格式升级，*numpy.io*中的代码仍将能够读取和写入版本1.0文件。
- en: Format Version 1.0
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本1.0
- en: 'The first 6 bytes are a magic string: exactly `\x93NUMPY`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前6个字节是一个魔术字符串：确切地为`\x93NUMPY`。
- en: 'The next 1 byte is an unsigned byte: the major version number of the file format,
    e.g. `\x01`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字节是一个无符号字节：文件格式的主版本号，例如`\x01`。
- en: 'The next 1 byte is an unsigned byte: the minor version number of the file format,
    e.g. `\x00`. Note: the version of the file format is not tied to the version of
    the numpy package.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字节是一个无符号字节：文件格式的次版本号，例如`\x00`。注意：文件格式的版本与numpy软件包的版本无关。
- en: 'The next 2 bytes form a little-endian unsigned short int: the length of the
    header data HEADER_LEN.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的2个字节形成一个小端无符号短整数：头部数据HEADER_LEN的长度。
- en: The next HEADER_LEN bytes form the header data describing the array’s format.
    It is an ASCII string which contains a Python literal expression of a dictionary.
    It is terminated by a newline (`\n`) and padded with spaces (`\x20`) to make the
    total of `len(magic string) + 2 + len(length) + HEADER_LEN` be evenly divisible
    by 64 for alignment purposes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的HEADER_LEN字节形成描述数组格式的头部数据。这是一个ASCII字符串，其中包含一个字典的Python文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic
    string) + 2 + len(length) + HEADER_LEN`的总和能够被64整除，以便对齐。
- en: 'The dictionary contains three keys:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 字典包含三个键：
- en: “descr”dtype.descr
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “descr”dtype.descr
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object that can be passed as an argument to the [`numpy.dtype`](numpy.dtype.html#numpy.dtype
    "numpy.dtype") constructor to create the array’s dtype.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个可以作为参数传递给[`numpy.dtype`](numpy.dtype.html#numpy.dtype "numpy.dtype")构造函数以创建数组dtype的对象。
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “fortran_order”bool
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “fortran_order”布尔值
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous
    arrays are a common form of non-C-contiguity, we allow them to be written directly
    to disk for efficiency.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组数据是否是Fortran连续的。由于Fortran连续数组是一种常见的非C连续形式，我们允许它们直接写入磁盘以提高效率。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “shape”tuple of int
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “shape”整数元组
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The shape of the array.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组的形状。
- en: For repeatability and readability, the dictionary keys are sorted in alphabetic
    order. This is for convenience only. A writer SHOULD implement this if possible.
    A reader MUST NOT depend on this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重复性和可读性，字典键按字母顺序排序。这仅供方便。如果可能的话，写入者应该实现这一点。读者不应该依赖于此。
- en: Following the header comes the array data. If the dtype contains Python objects
    (i.e. `dtype.hasobject is True`), then the data is a Python pickle of the array.
    Otherwise the data is the contiguous (either C- or Fortran-, depending on `fortran_order`)
    bytes of the array. Consumers can figure out the number of bytes by multiplying
    the number of elements given by the shape (noting that `shape=()` means there
    is 1 element) by `dtype.itemsize`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后是数组数据。如果dtype包含Python对象（即`dtype.hasobject`为True），那么数据是数组的Python pickle。否则，数据是数组的连续（无论是C还是Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数乘以`dtype.itemsize`来计算字节数（注意`shape=()`表示有1个元素）。
- en: Format Version 2.0
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本2.0
- en: The version 1.0 format only allowed the array header to have a total size of
    65535 bytes. This can be exceeded by structured arrays with a large number of
    columns. The version 2.0 format extends the header size to 4 GiB. [`numpy.save`](numpy.save.html#numpy.save
    "numpy.save") will automatically save in 2.0 format if the data requires it, else
    it will always use the more compatible 1.0 format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.0格式只允许数组头部的总大小为65535字节。这可以被具有大量列的结构化数组超过。版本2.0格式将头部大小扩展到4 GiB。如果数据需要，[`numpy.save`](numpy.save.html#numpy.save
    "numpy.save")将自动保存为2.0格式，否则它将始终使用更兼容的1.0格式。
- en: 'The description of the fourth element of the header therefore has become: “The
    next 4 bytes form a little-endian unsigned int: the length of the header data
    HEADER_LEN.”'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，头部的第四个元素的描述变为：“接下来的4个字节形成一个小端无符号整数：头部数据HEADER_LEN的长度。”
- en: Format Version 3.0
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本 3.0
- en: This version replaces the ASCII string (which in practice was latin1) with a
    utf8-encoded string, so supports structured types with any unicode field names.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本将 ASCII 字符串（实际上是 latin1）替换为 utf8 编码的字符串，因此支持具有任何 Unicode 字段名称的结构化类型。
- en: Notes
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The `.npy` format, including motivation for creating it and a comparison of
    alternatives, is described in the [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html
    "(in NumPy Enhancement Proposals)"), however details have evolved with time and
    this document is more current.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 描述了`.npy`格式，包括创建动机和与其他格式的比较，在[“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html)中，然而细节随着时间的推移而发展，这份文档更为当前。
- en: Capabilities
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能
- en: Can represent all NumPy arrays including nested record arrays and object arrays.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。
- en: Represents the data in its native binary form.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以其本机二进制形式表示数据。
- en: Supports Fortran-contiguous arrays directly.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接支持 Fortran 连续数组。
- en: Stores all of the necessary information to reconstruct the array including shape
    and dtype on a machine of a different architecture. Both little-endian and big-endian
    arrays are supported, and a file with little-endian numbers will yield a little-endian
    array on any machine reading the file. The types are described in terms of their
    actual sizes. For example, if a machine with a 64-bit C “long int” writes out
    an array with “long ints”, a reading machine with 32-bit C “long ints” will yield
    an array with 64-bit integers.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储重建数组所需的所有信息，包括在不同架构的机器上的形状和数据类型。支持小端和大端数组，并且具有小端数字的文件将在任何读取文件的机器上产生小端数组。类型是根据它们的实际大小描述的。例如，如果一个具有
    64 位 C “long int”的机器写出一个带有“long ints”的数组，那么一个具有 32 位 C “long ints”的读取机器将产生一个带有
    64 位整数的数组。
- en: Is straightforward to reverse engineer. Datasets often live longer than the
    programs that created them. A competent developer should be able to create a solution
    in their preferred programming language to read most `.npy` files that they have
    been given without much documentation.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于逆向工程。数据集通常比创建它们的程序存在时间更长。一位称职的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取大多数给定的`.npy`文件而无需太多文档。
- en: Allows memory-mapping of the data. See [`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap
    "numpy.lib.format.open_memmap").
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对数据进行内存映射。请参阅[`open_memmap`](numpy.lib.format.open_memmap.html#numpy.lib.format.open_memmap)。
- en: Can be read from a filelike stream object instead of an actual file.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从类似文件流对象而不是实际文件中读取。
- en: Stores object arrays, i.e. arrays containing elements that are arbitrary Python
    objects. Files with object arrays are not to be mmapable, but can be read and
    written to disk.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不可进行内存映射，但可以读取和写入磁盘。
- en: Limitations
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses
    will be accepted for writing, but only the array data will be written out. A regular
    numpy.ndarray object will be created upon reading the file.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意的 numpy.ndarray 子类不会完全保留。子类将被接受进行写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray
    对象。
- en: Warning
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Due to limitations in the interpretation of structured dtypes, dtypes with fields
    with empty names will have the names replaced by ‘f0’, ‘f1’, etc. Such arrays
    will not round-trip through the format entirely accurately. The data is intact;
    only the field names will differ. We are working on a fix for this. This fix will
    not require a change in the file format. The arrays with such structures can still
    be saved and restored, and the correct dtype may be restored by using the `loadedarray.view(correct_dtype)`
    method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对结构化数据类型的解释存在限制，具有空字段名称的数据类型将被替换为‘f0’、‘f1’等。这样的数组将无法完全准确地循环通过格式。数据是完整的；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用`loadedarray.view(correct_dtype)`方法恢复正确的数据类型。
- en: File extensions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件扩展名
- en: We recommend using the `.npy` and `.npz` extensions for files saved in this
    format. This is by no means a requirement; applications may wish to use these
    file formats but use an extension specific to the application. In the absence
    of an obvious alternative, however, we suggest using `.npy` and `.npz`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`.npy`和`.npz`扩展名保存以这种格式保存的文件。这绝不是一个要求；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。
- en: Version numbering
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本编号
- en: The version numbering of these formats is independent of NumPy version numbering.
    If the format is upgraded, the code in *numpy.io* will still be able to read and
    write Version 1.0 files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式的版本编号与NumPy版本编号是独立的。如果格式升级，*numpy.io*中的代码仍然能够读取和写入Version 1.0文件。
- en: Format Version 1.0
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本1.0
- en: 'The first 6 bytes are a magic string: exactly `\x93NUMPY`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前6个字节是一个魔术字符串：正好是`\x93NUMPY`。
- en: 'The next 1 byte is an unsigned byte: the major version number of the file format,
    e.g. `\x01`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的1个字节是一个无符号字节：文件格式的主要版本号，例如`\x01`。
- en: 'The next 1 byte is an unsigned byte: the minor version number of the file format,
    e.g. `\x00`. Note: the version of the file format is not tied to the version of
    the numpy package.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的1个字节是一个无符号字节：文件格式的次要版本号，例如`\x00`。注意：文件格式的版本与numpy软件包的版本无关。
- en: 'The next 2 bytes form a little-endian unsigned short int: the length of the
    header data HEADER_LEN.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的2个字节形成一个小端无符号短整数：头部数据HEADER_LEN的长度。
- en: The next HEADER_LEN bytes form the header data describing the array’s format.
    It is an ASCII string which contains a Python literal expression of a dictionary.
    It is terminated by a newline (`\n`) and padded with spaces (`\x20`) to make the
    total of `len(magic string) + 2 + len(length) + HEADER_LEN` be evenly divisible
    by 64 for alignment purposes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的HEADER_LEN字节形成描述数组格式的头部数据。它是一个ASCII字符串，其中包含一个字典的Python文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic
    string) + 2 + len(length) + HEADER_LEN`的总和能够被64整除，以便对齐。
- en: 'The dictionary contains three keys:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字典包含三个键：
- en: “descr”dtype.descr
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “descr”dtype.descr
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An object that can be passed as an argument to the [`numpy.dtype`](numpy.dtype.html#numpy.dtype
    "numpy.dtype") constructor to create the array’s dtype.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以作为参数传递给[`numpy.dtype`](numpy.dtype.html#numpy.dtype "numpy.dtype")构造函数以创建数组dtype的对象。
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “fortran_order”bool
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “fortran_order”bool
- en: ''
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous
    arrays are a common form of non-C-contiguity, we allow them to be written directly
    to disk for efficiency.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组数据是否是Fortran连续的。由于Fortran连续数组是一种常见的非C连续形式，我们允许它们直接写入磁盘以提高效率。
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “shape”tuple of int
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “shape”int元组
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The shape of the array.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组的形状。
- en: For repeatability and readability, the dictionary keys are sorted in alphabetic
    order. This is for convenience only. A writer SHOULD implement this if possible.
    A reader MUST NOT depend on this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重复性和可读性，字典键按字母顺序排序。这仅仅是为了方便。如果可能的话，写入者应该实现这一点。读者不应该依赖于此。
- en: Following the header comes the array data. If the dtype contains Python objects
    (i.e. `dtype.hasobject is True`), then the data is a Python pickle of the array.
    Otherwise the data is the contiguous (either C- or Fortran-, depending on `fortran_order`)
    bytes of the array. Consumers can figure out the number of bytes by multiplying
    the number of elements given by the shape (noting that `shape=()` means there
    is 1 element) by `dtype.itemsize`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后是数组数据。如果dtype包含Python对象（即`dtype.hasobject is True`），那么数据是数组的Python pickle。否则，数据是数组的连续（无论是C还是Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数量相乘（注意`shape=()`表示有1个元素）来计算字节数，乘以`dtype.itemsize`。
- en: Format Version 2.0
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本2.0
- en: The version 1.0 format only allowed the array header to have a total size of
    65535 bytes. This can be exceeded by structured arrays with a large number of
    columns. The version 2.0 format extends the header size to 4 GiB. [`numpy.save`](numpy.save.html#numpy.save
    "numpy.save") will automatically save in 2.0 format if the data requires it, else
    it will always use the more compatible 1.0 format.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.0格式只允许数组头部的总大小为65535字节。这可以被具有大量列的结构化数组超过。版本2.0格式将头部大小扩展到4 GiB。[`numpy.save`](numpy.save.html#numpy.save
    "numpy.save")将自动保存为2.0格式，如果数据需要，否则它将始终使用更兼容的1.0格式。
- en: 'The description of the fourth element of the header therefore has become: “The
    next 4 bytes form a little-endian unsigned int: the length of the header data
    HEADER_LEN.”'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，头部的第四个元素的描述变为：“接下来的4个字节形成一个小端无符号整数：头部数据HEADER_LEN的长度。”
- en: Format Version 3.0
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式版本3.0
- en: This version replaces the ASCII string (which in practice was latin1) with a
    utf8-encoded string, so supports structured types with any unicode field names.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本用utf8编码的字符串替换了ASCII字符串（实际上是latin1），因此支持具有任何Unicode字段名称的结构化类型。
- en: Notes
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `.npy` format, including motivation for creating it and a comparison of
    alternatives, is described in the [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html
    "(in NumPy Enhancement Proposals)"), however details have evolved with time and
    this document is more current.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`.npy` 格式，包括创建动机和与其他替代方案的比较，在 [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html
    "(在 NumPy Enhancement Proposals 中)") 中有描述，然而随着时间的推移，细节已经发生变化，本文档更为当前。'
