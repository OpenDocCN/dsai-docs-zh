- en: Array Iterator API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/iterator.html](https://numpy.org/doc/1.26/reference/c-api/iterator.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Array Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The array iterator encapsulates many of the key features in ufuncs, allowing
    user code to support features like output parameters, preservation of memory layouts,
    and buffering of data with the wrong alignment or type, without requiring difficult
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: This page documents the API for the iterator. The iterator is named `NpyIter`
    and functions are named `NpyIter_*`.
  prefs: []
  type: TYPE_NORMAL
- en: There is an [introductory guide to array iteration](../arrays.nditer.html#arrays-nditer)
    which may be of interest for those using this C API. In many instances, testing
    out ideas by creating the iterator in Python is a good idea before writing the
    C iteration code.
  prefs: []
  type: TYPE_NORMAL
- en: '## Iteration Example'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to become familiar with the iterator is to look at its usage within
    the NumPy codebase itself. For example, here is a slightly tweaked version of
    the code for [`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero "PyArray_CountNonzero"),
    which counts the number of non-zero elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Multi-Iteration Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a copy function using the iterator. The `order` parameter is used to
    control the memory layout of the allocated result, typically [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Multi Index Tracking Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example shows you how to work with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag. For simplicity, we assume the argument is a two-dimensional
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When called with a 2x3 array, the above example prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Iterator Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator layout is an internal detail, and user code only sees an incomplete
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is an opaque pointer type for the iterator. Access to its contents can
    only be done through the iterator API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the type which exposes the iterator to Python. Currently, no API is
    exposed which provides access to the values of a Python-created iterator. If an
    iterator is created in Python, it must be used in Python and vice versa. Such
    an API will likely be created in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a function pointer for the iteration loop, returned by [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext
    "NpyIter_GetIterNext").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a function pointer for getting the current iterator multi-index, returned
    by [`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex "NpyIter_GetGetMultiIndex").
  prefs: []
  type: TYPE_NORMAL
- en: Construction and Destruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creates an iterator for the given numpy array object `op`.
  prefs: []
  type: TYPE_NORMAL
- en: Flags that may be passed in `flags` are any combination of the global and per-operand
    flags documented in [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew"),
    except for [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE").
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If `dtype` isn’t `NULL`, then it requires that data type. If copying is allowed,
    it will make a temporary copy if the data is castable. If [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") is enabled, it will also copy the data back with another
    cast upon iterator destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: To make an iterator similar to the old iterator, this should work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to edit an array with aligned `double` code, but the order doesn’t
    matter, you would use this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creates an iterator for broadcasting the `nop` array objects provided in `op`,
    using regular NumPy broadcasting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern. When using [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), if you also want to ensure that the iteration is not reversed
    along an axis, you should pass the flag [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES").
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If `op_dtypes` isn’t `NULL`, it specifies a data type or `NULL` for each `op[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags that may be passed in `flags`, applying to the whole iterator, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a raveled flat index matching C order. This option
    cannot be used with [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a raveled flat index matching Fortran order. This
    option cannot be used with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a multi-index. This prevents the iterator from
    coalescing axes to produce bigger inner loops. If the loop is also not buffered
    and no index is being tracked (*NpyIter_RemoveAxis* can be called), then the iterator
    size can be `-1` to indicate that the iterator is too large. This can happen due
    to complex broadcasting and will result in errors being created when the setting
    the iterator range, removing the multi index, or getting the next function. However,
    it is possible to remove axes again and use the iterator normally if the size
    is small enough after removal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to skip iteration of the innermost loop, requiring the user
    of the iterator to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: This flag is incompatible with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), and [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This only affects the iterator when [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is specified for the order parameter. By default with [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), the iterator reverses axes which have negative strides, so that
    memory is traversed in a forward direction. This disables this step. Use this
    flag if you want to use the underlying memory-ordering of the axes, but don’t
    want an axis reversed. This is the behavior of `numpy.ravel(a, order='K')`, for
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to convert all the operands to a common data type, calculated
    based on the ufunc type promotion rules. Copying or buffering must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If the common data type is known ahead of time, don’t use this flag. Instead,
    set the requested dtype for all the operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Indicates that arrays with reference types (object arrays or structured arrays
    containing an object type) may be accepted and used in the iterator. If this flag
    is enabled, the caller must be sure to check whether NpyIter_IterationNeedsAPI(iter)
    is true, in which case it may not release the GIL during iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indicates that arrays with a size of zero should be permitted. Since the typical
    iteration loop does not naturally work with zero-sized arrays, you must check
    that the IterSize is larger than zero before entering the iteration loop. Currently
    only the operands are checked, not a forced shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Permits writeable operands with a dimension with zero stride and size greater
    than one. Note that such operands must be read/write.
  prefs: []
  type: TYPE_NORMAL
- en: When buffering is enabled, this also switches to a special buffering mode which
    reduces the loop length as necessary to not trample on values being reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you want to do a reduction on an automatically allocated output,
    you must use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get its reference, then set every value to the reduction unit before doing
    the iteration loop. In the case of a buffered reduction, this means you must also
    specify the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    then reset the iterator after initializing the allocated operand to prepare the
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Enables support for iteration of sub-ranges of the full `iterindex` range `[0,
    NpyIter_IterSize(iter))`. Use the function [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") to specify a range for iteration.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can only be used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") when [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")
    is enabled. This is because without buffering, the inner loop is always the size
    of the innermost iteration dimension, and allowing it to get cut up would require
    special handling, effectively making it more like the buffered version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to store buffering data, and use buffering to satisfy data
    type, alignment, and byte-order requirements. To buffer an operand, do not specify
    the [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") flags, because they will override buffering. Buffering
    is especially useful for Python code using the iterator, allowing for larger chunks
    of data at once to amortize the Python interpreter overhead.
  prefs: []
  type: TYPE_NORMAL
- en: If used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    the inner loop for the caller may get larger chunks than would be possible without
    buffering, because of how the strides are laid out.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if an operand is given the flag [`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY"),
    a copy will be made in preference to buffering. Buffering will still occur when
    the array was broadcast so elements need to be duplicated to get a constant stride.
  prefs: []
  type: TYPE_NORMAL
- en: In normal buffering, the size of each inner loop is equal to the buffer size,
    or possibly larger if [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")
    is specified. If [`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")
    is enabled and a reduction occurs, the inner loops may become smaller depending
    on the structure of the reduction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When buffering is enabled, this allows the size of the inner loop to grow when
    buffering isn’t necessary. This option is best used if you’re doing a straight
    pass through all the data, rather than anything with small cache-friendly arrays
    of temporary values for each inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When buffering is enabled, this delays allocation of the buffers until [`NpyIter_Reset`](#c.NpyIter_Reset
    "NpyIter_Reset") or another reset function is called. This flag exists to avoid
    wasteful copying of buffer data when making multiple copies of a buffered iterator
    for multi-threaded iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of this flag is for setting up reduction operations. After the iterator
    is created, and a reduction output is allocated automatically by the iterator
    (be sure to use READWRITE access), its value may be initialized to the reduction
    unit. Use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get the object. Then, call [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")
    to allocate and fill the buffers with their initial values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If any write operand has overlap with any read operand, eliminate all overlap
    by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary).
    A pair of operands has overlap if there is a memory address that contains data
    common to both arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Because exact overlap detection has exponential runtime in the number of dimensions,
    the decision is made based on heuristics, which has false positives (needless
    copies in unusual cases) but has no false negatives.
  prefs: []
  type: TYPE_NORMAL
- en: If any read/write overlap exists, this flag ensures the result of the operation
    is the same as if all operands were copied. In cases where copies would need to
    be made, **the result of the computation may be undefined without this flag!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags that may be passed in `op_flags[i]`, where `0 <= i < nop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Indicate how the user of the iterator will read or write to `op[i]`. Exactly
    one of these flags must be specified per operand. Using `NPY_ITER_READWRITE` or
    `NPY_ITER_WRITEONLY` for a user-provided operand may trigger *WRITEBACKIFCOPY`*
    semantics. The data will be written back to the original array when `NpyIter_Deallocate`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Allow a copy of `op[i]` to be made if it does not meet the data type or alignment
    requirements as specified by the constructor flags and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Triggers [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY"), and when an array
    operand is flagged for writing and is copied, causes the data in a copy to be
    copied back to `op[i]` when `NpyIter_Deallocate` is called.
  prefs: []
  type: TYPE_NORMAL
- en: If the operand is flagged as write-only and a copy is needed, an uninitialized
    temporary array will be created and then copied to back to `op[i]` on calling
    `NpyIter_Deallocate`, instead of doing the unnecessary copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to provide data for `op[i]` that is in native byte order,
    aligned according to the dtype requirements, contiguous, or any combination.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the iterator produces pointers into the arrays provided, which may
    be aligned or unaligned, and with any byte order. If copying or buffering is not
    enabled and the operand data doesn’t satisfy the constraints, an error will be
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: The contiguous constraint applies only to the inner loop, successive inner loops
    may have arbitrary pointer changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the requested data type is in non-native byte order, the NBO flag overrides
    it and the requested data type is converted to be in native byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is for output arrays, and requires that the flag [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY") or [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    be set. If `op[i]` is NULL, creates a new array with the final broadcast dimensions,
    and a layout matching the iteration order of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: When `op[i]` is NULL, the requested data type `op_dtypes[i]` may be NULL as
    well, in which case it is automatically generated from the dtypes of the arrays
    which are flagged as readable. The rules for generating the dtype are the same
    is for UFuncs. Of special note is handling of byte order in the selected dtype.
    If there is exactly one input, the input’s dtype is used as is. Otherwise, if
    more than one input dtypes are combined together, the output will be in native
    byte order.
  prefs: []
  type: TYPE_NORMAL
- en: After being allocated with this flag, the caller may retrieve the new array
    by calling [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    and getting the i-th object in the returned C array. The caller must call Py_INCREF
    on it to claim a reference to the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For use with [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE"),
    this flag disables allocating an array subtype for the output, forcing it to be
    a straight ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Maybe it would be better to introduce a function `NpyIter_GetWrappedOutput`
    and remove this flag?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Ensures that the input or output matches the iteration dimensions exactly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that this operand is the mask to use for selecting elements when writing
    to operands which have the [`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")
    flag applied to them. Only one operand may have [`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK") flag applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: The data type of an operand with this flag should be either [`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL
    "NPY_BOOL"), [`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK "NPY_MASK"), or a struct
    dtype whose fields are all valid mask dtypes. In the latter case, it must match
    up with a struct operand being WRITEMASKED, as it is specifying a mask for each
    field of that array.
  prefs: []
  type: TYPE_NORMAL
- en: This flag only affects writing from the buffer back to the array. This means
    that if the operand is also [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    or [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY"), code doing
    iteration can write to this operand to control which elements will be untouched
    and which ones will be modified. This is useful when the mask should be a combination
    of input masks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: This array is the mask for all [`writemasked`](../generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") operands. Code uses the `writemasked` flag which indicates that
    only elements where the chosen ARRAYMASK operand is True will be written to. In
    general, the iterator does not enforce this, it is up to the code doing the iteration
    to follow that promise.
  prefs: []
  type: TYPE_NORMAL
- en: When `writemasked` flag is used, and this operand is buffered, this changes
    how data is copied from the buffer into the array. A masked copying routine is
    used, which only copies the elements in the buffer for which `writemasked` returns
    true from the corresponding element in the ARRAYMASK operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In memory overlap checks, assume that operands with `NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`
    enabled are accessed only in the iterator order.
  prefs: []
  type: TYPE_NORMAL
- en: This enables the iterator to reason about data dependency, possibly avoiding
    unnecessary copies.
  prefs: []
  type: TYPE_NORMAL
- en: This flag has effect only if `NPY_ITER_COPY_IF_OVERLAP` is enabled on the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Extends [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") with several
    advanced options providing more control over broadcasting and buffering.
  prefs: []
  type: TYPE_NORMAL
- en: If -1/NULL values are passed to `oa_ndim`, `op_axes`, `itershape`, and `buffersize`,
    it is equivalent to [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew").
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `oa_ndim`, when not zero or -1, specifies the number of dimensions
    that will be iterated with customized broadcasting. If it is provided, `op_axes`
    must and `itershape` can also be provided. The `op_axes` parameter let you control
    in detail how the axes of the operand arrays get matched together and iterated.
    In `op_axes`, you must provide an array of `nop` pointers to `oa_ndim`-sized arrays
    of type `npy_intp`. If an entry in `op_axes` is NULL, normal broadcasting rules
    will apply. In `op_axes[j][i]` is stored either a valid axis of `op[j]`, or -1
    which means `newaxis`. Within each `op_axes[j]` array, axes may not be repeated.
    The following example is how normal broadcasting applies to a 3-D array, a 2-D
    array, a 1-D array and a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Before NumPy 1.8 `oa_ndim == 0` was used for signalling that ``op_axes`
    and `itershape` are unused. This is deprecated and should be replaced with -1\.
    Better backward compatibility may be achieved by using [`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew") for this case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `itershape` parameter allows you to force the iterator to have a specific
    iteration shape. It is an array of length `oa_ndim`. When an entry is negative,
    its value is determined from the operands. This parameter allows automatically
    allocated outputs to get additional dimensions which don’t match up with any dimension
    of an input.
  prefs: []
  type: TYPE_NORMAL
- en: If `buffersize` is zero, a default buffer size is used, otherwise it specifies
    how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192
    are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Makes a copy of the given iterator. This function is provided primarily to enable
    multi-threaded iteration of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '*TODO*: Move this to a section about multithreaded iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach to multithreaded iteration is to first create an iterator
    with the flags [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED"), [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED"), [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    and possibly [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER").
    Create a copy of this iterator for each thread (minus one for the first iterator).
    Then, take the iteration index range `[0, NpyIter_GetIterSize(iter))` and split
    it up into tasks, for example using a TBB parallel_for loop. When a thread gets
    a task to execute, it then uses its copy of the iterator by calling [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") and iterating over the full range.
  prefs: []
  type: TYPE_NORMAL
- en: When using the iterator in multi-threaded code or in code not holding the Python
    GIL, care must be taken to only call functions which are safe in that context.
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") cannot be safely called without
    the Python GIL, because it increments Python references. The `Reset*` and some
    other functions may be safely called by passing in the `errmsg` parameter as non-NULL,
    so that the functions will pass back errors through it instead of setting a Python
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate") must be
    called for each copy.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Removes an axis from iteration. This requires that [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") was set for iterator creation, and does not work if buffering
    is enabled or an index is being tracked. This function also resets the iterator
    to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for setting up an accumulation loop, for example. The iterator
    can first be created with all the dimensions, including the accumulation axis,
    so that the output gets created correctly. Then, the accumulation axis can be
    removed, and the calculation done in a nested fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again! The
    iterator range will be reset as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If the iterator is tracking a multi-index, this strips support for them, and
    does further iterator optimizations that are possible if multi-indices are not
    needed. This function also resets the iterator to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again!'
  prefs: []
  type: TYPE_NORMAL
- en: After calling this function, [NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex
    "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex "iter")) will return
    false.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    was called, you may want to enable the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP"). This flag is not permitted together with [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX"), so this function is provided to enable the feature after
    [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    is called. This function also resets the iterator to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function changes the internal logic of the iterator. Any
    cached functions or pointers from the iterator must be retrieved again!'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Deallocates the iterator object and resolves any needed writebacks.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator back to its initial state, at the beginning of the iteration
    range.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator and restricts it to the `iterindex` range `[istart, iend)`.
    See [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") for an explanation of how
    to use this for multi-threaded iteration. This requires that the flag [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was passed to the iterator constructor.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reset both the `iterindex` range and the base pointers at the
    same time, you can do the following to avoid extra buffer copying (be sure to
    add the return code error checks when you copy this code).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator back to its initial state, but using the values in `baseptrs`
    for the data instead of the pointers from the arrays being iterated. This functions
    is intended to be used, together with the `op_axes` parameter, by nested iteration
    code with two or more iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '*TODO*: Move the following into a special section on nested iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating iterators for nested iteration requires some care. All the iterator
    operands must match exactly, or the calls to [`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers") will be invalid. This means that automatic copies
    and output allocation should not be used haphazardly. It is possible to still
    use the automatic data conversion and casting features of the iterator by creating
    one of the iterators with all the conversion parameters enabled, then grabbing
    the allocated operands with the [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray") function and passing them into the constructors for
    the rest of the iterators.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: When creating iterators for nested iteration, the code must not
    use a dimension more than once in the different iterators. If this is done, nested
    iteration will produce out-of-bounds pointers during iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: When creating iterators for nested iteration, buffering can only
    be applied to the innermost iterator. If a buffered iterator is used as the source
    for `baseptrs`, it will point into a small buffer instead of the array and the
    inner iteration will be invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern for using nested iterators is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `ndim` indices pointed to by `multi_index`.
    Returns an error if a multi-index is not being tracked, the indices are out of
    bounds, or inner loop iteration is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `index` specified. If the iterator was
    constructed with the flag [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    `index` is the C-order index, and if the iterator was constructed with the flag
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), `index` is the Fortran-order
    index. Returns an error if there is no index being tracked, the index is out of
    bounds, or inner loop iteration is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of elements being iterated. This is the product of all the
    dimensions in the shape. When a multi index is being tracked (and *NpyIter_RemoveAxis*
    may be called) the size may be `-1` to indicate an iterator is too large. Such
    an iterator is invalid, but may become valid after *NpyIter_RemoveAxis* is called.
    It is not necessary to check for this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Gets the `iterindex` of the iterator, which is an index matching the iteration
    order of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Gets the `iterindex` sub-range that is being iterated. If [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was not specified, this always returns the range `[0, NpyIter_IterSize(iter))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `iterindex` specified. The IterIndex is
    an index matching the iteration order of the iterator. Returns an error if the
    `iterindex` is out of bounds, buffering is enabled, or inner loop iteration is
    disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was passed to the iterator constructor, and no call
    to one of the Reset functions has been done yet, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the caller needs to handle the inner-most 1-dimensional loop, or
    0 if the iterator handles all looping. This is controlled by the constructor flag
    [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    or [`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop "NpyIter_EnableExternalLoop").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator requires buffering, which occurs when an operand needs
    conversion or alignment and so cannot be used directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If the iterator is buffered, returns the size of the buffer being used, otherwise
    returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of dimensions being iterated. If a multi-index was not requested
    in the iterator constructor, this value may be smaller than the number of dimensions
    in the original objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of operands in the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Gets the array of strides for the specified axis. Requires that the iterator
    be tracking a multi-index, and that buffering not be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: This may be used when you want to match up operand axes in some fashion, then
    remove them with [`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")
    to handle their processing manually. By calling this function before removing
    the axes, you can get the strides for the manual processing.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NULL` on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Returns the broadcast shape of the iterator in `outshape`. This can only be
    called on an iterator which is tracking a multi-index.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` data type Descrs for the objects being
    iterated. The result points into `iter`, so the caller does not gain any references
    to the Descrs.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` operand PyObjects that are being iterated.
    The result points into `iter`, so the caller does not gain any references to the
    PyObjects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a reference to a new ndarray view, which is a view into the
    i-th object in the array [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray"), whose dimensions and strides match the internal optimized
    iteration pattern. A C-order iteration of this view is equivalent to the iterator’s
    iteration order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an iterator was created with a single array as its input, and
    it was possible to rearrange all its axes and then collapse it into a single strided
    iteration, this would return a view that is a one-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Fills `nop` flags. Sets `outreadflags[i]` to 1 if `op[i]` can be read from,
    and to 0 if not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Fills `nop` flags. Sets `outwriteflags[i]` to 1 if `op[i]` can be written to,
    and to 0 if not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Builds a set of strides which are the same as the strides of an output array
    created using the [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")
    flag, where NULL was passed for op_axes. This is for data packed contiguously,
    but not necessarily in C or Fortran order. This should be used together with [`NpyIter_GetShape`](#c.NpyIter_GetShape
    "NpyIter_GetShape") and [`NpyIter_GetNDim`](#c.NpyIter_GetNDim "NpyIter_GetNDim")
    with the flag [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    passed into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: A use case for this function is to match the shape and layout of the iterator
    and tack on one or more dimensions. For example, in order to generate a vector
    per input value for a numerical gradient, you pass in ndim*itemsize for itemsize,
    then add another dimension to the end with size ndim and stride itemsize. To do
    the Hessian matrix, you do the same thing but add two dimensions, or take advantage
    of the symmetry and pack it into 1 dimension with a particular encoding.
  prefs: []
  type: TYPE_NORMAL
- en: This function may only be called if the iterator is tracking a multi-index and
    if [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES "NPY_ITER_DONT_NEGATE_STRIDES")
    was used to prevent an axis from being iterated in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: If an array is created with this method, simply adding ‘itemsize’ for each iteration
    will traverse the new array matching the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see whether this is the first time the elements of the specified reduction
    operand which the iterator points at are being seen for the first time. The function
    returns a reasonable answer for reduction operands and when buffering is disabled.
    The answer may be incorrect for buffered non-reduction operands.
  prefs: []
  type: TYPE_NORMAL
- en: This function is intended to be used in EXTERNAL_LOOP mode only, and will produce
    some wrong answers when that mode is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If this function returns true, the caller should also check the inner loop stride
    of the operand, because if that stride is 0, then only the first element of the
    innermost external loop is being visited for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '*WARNING*: For performance reasons, ‘iop’ is not bounds-checked, it is not
    confirmed that ‘iop’ is actually a reduction operand, and it is not confirmed
    that EXTERNAL_LOOP mode is enabled. These checks are the responsibility of the
    caller, and should be done outside of any inner loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions For Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Returns a function pointer for iteration. A specialized version of the function
    pointer may be calculated by this function instead of being stored in the iterator
    structure. Thus, to get good performance, it is required that the function pointer
    be saved in a variable rather than retrieved for each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: The typical looping construct is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is specified, the typical inner loop construct is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we are using the dataptr array inside the iterator, not copying
    the values to a local temporary. This is possible because when `iternext()` is
    called, these pointers will be overwritten with fresh values, not incrementally
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: If a compile-time fixed buffer is being used (both flags [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") and [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")), the inner size may be used as a signal as well. The
    size is guaranteed to become zero when `iternext()` returns false, enabling the
    following loop construct. Note that if you use this construct, you should not
    pass [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER") as a flag,
    because it will cause larger sizes under some circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Returns a function pointer for getting the current multi-index of the iterator.
    Returns NULL if the iterator is not tracking a multi-index. It is recommended
    that this function pointer be cached in a local variable before the iteration
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` data pointers. If [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") was not specified, each data pointer points to the current
    data item of the iterator. If no inner iteration was specified, it points to the
    first data item of the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Gets the array of data pointers directly into the arrays (never into the buffers),
    corresponding to iteration index 0.
  prefs: []
  type: TYPE_NORMAL
- en: These pointers are different from the pointers accepted by `NpyIter_ResetBasePointers`,
    because the direction along some axes may have been reversed.
  prefs: []
  type: TYPE_NORMAL
- en: This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the index being tracked, or NULL if no index is
    being tracked. It is only usable if one of the flags [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    were specified during construction.
  prefs: []
  type: TYPE_NORMAL
- en: When the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is used, the code needs to know the parameters for doing the inner loop. These
    functions provide that information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to an array of the `nop` strides, one for each iterated object,
    to be used by the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: While the pointer may be cached, its values may change if the
    iterator is buffered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the number of iterations the inner loop should execute.
  prefs: []
  type: TYPE_NORMAL
- en: This address may be cached before the iteration loop, calling `iternext` will
    not change it. The value itself may change during iteration, in particular if
    buffering is enabled. This function may be safely called without holding the Python
    GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Gets an array of strides which are fixed, or will not change during the entire
    iteration. For strides that may change, the value NPY_MAX_INTP is placed in the
    stride.
  prefs: []
  type: TYPE_NORMAL
- en: Once the iterator is prepared for iteration (after a reset if [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was used), call this to get the strides which may be
    used to select a fast inner loop function. For example, if the stride is 0, that
    means the inner loop can always load its value into a variable once, then use
    the variable throughout the loop, or if the stride equals the itemsize, a contiguous
    version for that operand may be used.
  prefs: []
  type: TYPE_NORMAL
- en: This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '## Converting from Previous NumPy Iterators'
  prefs: []
  type: TYPE_NORMAL
- en: The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter*
    and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast,
    and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality
    with a single object and associated API. One goal of the new API is that all uses
    of the existing iterator should be replaceable with the new iterator without significant
    effort. In 1.6, the major exception to this is the neighborhood iterator, which
    does not have corresponding features in this iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a conversion table for which functions to use with the new iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *Iterator Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` parameter **or** Iterator
    flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **NOT SUPPORTED** (Use the support for multiple operands instead.) |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | Will need to add this in Python exposure |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | Return value of `iternext` function pointer |'
  prefs: []
  type: TYPE_TB
- en: '| *Multi-iterator Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **NOT SUPPORTED** (always lock-step iteration) |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | Return value of `iternext` function pointer |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | Handled by [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | Iterator flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Other Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | Iterator flag [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
  prefs: []
  type: TYPE_TB
- en: Array Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The array iterator encapsulates many of the key features in ufuncs, allowing
    user code to support features like output parameters, preservation of memory layouts,
    and buffering of data with the wrong alignment or type, without requiring difficult
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: This page documents the API for the iterator. The iterator is named `NpyIter`
    and functions are named `NpyIter_*`.
  prefs: []
  type: TYPE_NORMAL
- en: There is an [introductory guide to array iteration](../arrays.nditer.html#arrays-nditer)
    which may be of interest for those using this C API. In many instances, testing
    out ideas by creating the iterator in Python is a good idea before writing the
    C iteration code.
  prefs: []
  type: TYPE_NORMAL
- en: '## Iteration Example'
  prefs: []
  type: TYPE_NORMAL
- en: The best way to become familiar with the iterator is to look at its usage within
    the NumPy codebase itself. For example, here is a slightly tweaked version of
    the code for [`PyArray_CountNonzero`](array.html#c.PyArray_CountNonzero "PyArray_CountNonzero"),
    which counts the number of non-zero elements in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Multi-Iteration Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a copy function using the iterator. The `order` parameter is used to
    control the memory layout of the allocated result, typically [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Multi Index Tracking Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example shows you how to work with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag. For simplicity, we assume the argument is a two-dimensional
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'When called with a 2x3 array, the above example prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Iterator Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator layout is an internal detail, and user code only sees an incomplete
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is an opaque pointer type for the iterator. Access to its contents can
    only be done through the iterator API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is the type which exposes the iterator to Python. Currently, no API is
    exposed which provides access to the values of a Python-created iterator. If an
    iterator is created in Python, it must be used in Python and vice versa. Such
    an API will likely be created in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This is a function pointer for the iteration loop, returned by [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext
    "NpyIter_GetIterNext").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This is a function pointer for getting the current iterator multi-index, returned
    by [`NpyIter_GetGetMultiIndex`](#c.NpyIter_GetGetMultiIndex "NpyIter_GetGetMultiIndex").
  prefs: []
  type: TYPE_NORMAL
- en: Construction and Destruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Creates an iterator for the given numpy array object `op`.
  prefs: []
  type: TYPE_NORMAL
- en: Flags that may be passed in `flags` are any combination of the global and per-operand
    flags documented in [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew"),
    except for [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE").
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If `dtype` isn’t `NULL`, then it requires that data type. If copying is allowed,
    it will make a temporary copy if the data is castable. If [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") is enabled, it will also copy the data back with another
    cast upon iterator destruction.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: To make an iterator similar to the old iterator, this should work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: If you want to edit an array with aligned `double` code, but the order doesn’t
    matter, you would use this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Creates an iterator for broadcasting the `nop` array objects provided in `op`,
    using regular NumPy broadcasting rules.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_ORDER`](array.html#c.NPY_ORDER "NPY_ORDER") enum values may
    be passed to `order`. For efficient iteration, [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is the best option, and the other orders enforce the particular
    iteration pattern. When using [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), if you also want to ensure that the iteration is not reversed
    along an axis, you should pass the flag [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES
    "NPY_ITER_DONT_NEGATE_STRIDES").
  prefs: []
  type: TYPE_NORMAL
- en: Any of the [`NPY_CASTING`](array.html#c.NPY_CASTING "NPY_CASTING") enum values
    may be passed to `casting`. The values include [`NPY_NO_CASTING`](array.html#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](array.html#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING"), [`NPY_SAFE_CASTING`](array.html#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](array.html#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](array.html#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING"). To allow the casts to occur, copying or buffering must
    also be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If `op_dtypes` isn’t `NULL`, it specifies a data type or `NULL` for each `op[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags that may be passed in `flags`, applying to the whole iterator, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a raveled flat index matching C order. This option
    cannot be used with [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a raveled flat index matching Fortran order. This
    option cannot be used with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to track a multi-index. This prevents the iterator from
    coalescing axes to produce bigger inner loops. If the loop is also not buffered
    and no index is being tracked (*NpyIter_RemoveAxis* can be called), then the iterator
    size can be `-1` to indicate that the iterator is too large. This can happen due
    to complex broadcasting and will result in errors being created when the setting
    the iterator range, removing the multi index, or getting the next function. However,
    it is possible to remove axes again and use the iterator normally if the size
    is small enough after removal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to skip iteration of the innermost loop, requiring the user
    of the iterator to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: This flag is incompatible with [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), and [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This only affects the iterator when [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is specified for the order parameter. By default with [`NPY_KEEPORDER`](array.html#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER"), the iterator reverses axes which have negative strides, so that
    memory is traversed in a forward direction. This disables this step. Use this
    flag if you want to use the underlying memory-ordering of the axes, but don’t
    want an axis reversed. This is the behavior of `numpy.ravel(a, order='K')`, for
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to convert all the operands to a common data type, calculated
    based on the ufunc type promotion rules. Copying or buffering must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If the common data type is known ahead of time, don’t use this flag. Instead,
    set the requested dtype for all the operands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Indicates that arrays with reference types (object arrays or structured arrays
    containing an object type) may be accepted and used in the iterator. If this flag
    is enabled, the caller must be sure to check whether NpyIter_IterationNeedsAPI(iter)
    is true, in which case it may not release the GIL during iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Indicates that arrays with a size of zero should be permitted. Since the typical
    iteration loop does not naturally work with zero-sized arrays, you must check
    that the IterSize is larger than zero before entering the iteration loop. Currently
    only the operands are checked, not a forced shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Permits writeable operands with a dimension with zero stride and size greater
    than one. Note that such operands must be read/write.
  prefs: []
  type: TYPE_NORMAL
- en: When buffering is enabled, this also switches to a special buffering mode which
    reduces the loop length as necessary to not trample on values being reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you want to do a reduction on an automatically allocated output,
    you must use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get its reference, then set every value to the reduction unit before doing
    the iteration loop. In the case of a buffered reduction, this means you must also
    specify the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    then reset the iterator after initializing the allocated operand to prepare the
    buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Enables support for iteration of sub-ranges of the full `iterindex` range `[0,
    NpyIter_IterSize(iter))`. Use the function [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") to specify a range for iteration.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can only be used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") when [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED "NPY_ITER_BUFFERED")
    is enabled. This is because without buffering, the inner loop is always the size
    of the innermost iteration dimension, and allowing it to get cut up would require
    special handling, effectively making it more like the buffered version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to store buffering data, and use buffering to satisfy data
    type, alignment, and byte-order requirements. To buffer an operand, do not specify
    the [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY
    "NPY_ITER_UPDATEIFCOPY") flags, because they will override buffering. Buffering
    is especially useful for Python code using the iterator, allowing for larger chunks
    of data at once to amortize the Python interpreter overhead.
  prefs: []
  type: TYPE_NORMAL
- en: If used with [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    the inner loop for the caller may get larger chunks than would be possible without
    buffering, because of how the strides are laid out.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if an operand is given the flag [`NPY_ITER_COPY`](#c.NPY_ITER_COPY
    "NPY_ITER_COPY") or [`NPY_ITER_UPDATEIFCOPY`](#c.NPY_ITER_UPDATEIFCOPY "NPY_ITER_UPDATEIFCOPY"),
    a copy will be made in preference to buffering. Buffering will still occur when
    the array was broadcast so elements need to be duplicated to get a constant stride.
  prefs: []
  type: TYPE_NORMAL
- en: In normal buffering, the size of each inner loop is equal to the buffer size,
    or possibly larger if [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER")
    is specified. If [`NPY_ITER_REDUCE_OK`](#c.NPY_ITER_REDUCE_OK "NPY_ITER_REDUCE_OK")
    is enabled and a reduction occurs, the inner loops may become smaller depending
    on the structure of the reduction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: When buffering is enabled, this allows the size of the inner loop to grow when
    buffering isn’t necessary. This option is best used if you’re doing a straight
    pass through all the data, rather than anything with small cache-friendly arrays
    of temporary values for each inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: When buffering is enabled, this delays allocation of the buffers until [`NpyIter_Reset`](#c.NpyIter_Reset
    "NpyIter_Reset") or another reset function is called. This flag exists to avoid
    wasteful copying of buffer data when making multiple copies of a buffered iterator
    for multi-threaded iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of this flag is for setting up reduction operations. After the iterator
    is created, and a reduction output is allocated automatically by the iterator
    (be sure to use READWRITE access), its value may be initialized to the reduction
    unit. Use [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    to get the object. Then, call [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset")
    to allocate and fill the buffers with their initial values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If any write operand has overlap with any read operand, eliminate all overlap
    by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary).
    A pair of operands has overlap if there is a memory address that contains data
    common to both arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Because exact overlap detection has exponential runtime in the number of dimensions,
    the decision is made based on heuristics, which has false positives (needless
    copies in unusual cases) but has no false negatives.
  prefs: []
  type: TYPE_NORMAL
- en: If any read/write overlap exists, this flag ensures the result of the operation
    is the same as if all operands were copied. In cases where copies would need to
    be made, **the result of the computation may be undefined without this flag!**
  prefs: []
  type: TYPE_NORMAL
- en: 'Flags that may be passed in `op_flags[i]`, where `0 <= i < nop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Indicate how the user of the iterator will read or write to `op[i]`. Exactly
    one of these flags must be specified per operand. Using `NPY_ITER_READWRITE` or
    `NPY_ITER_WRITEONLY` for a user-provided operand may trigger *WRITEBACKIFCOPY`*
    semantics. The data will be written back to the original array when `NpyIter_Deallocate`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Allow a copy of `op[i]` to be made if it does not meet the data type or alignment
    requirements as specified by the constructor flags and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Triggers [`NPY_ITER_COPY`](#c.NPY_ITER_COPY "NPY_ITER_COPY"), and when an array
    operand is flagged for writing and is copied, causes the data in a copy to be
    copied back to `op[i]` when `NpyIter_Deallocate` is called.
  prefs: []
  type: TYPE_NORMAL
- en: If the operand is flagged as write-only and a copy is needed, an uninitialized
    temporary array will be created and then copied to back to `op[i]` on calling
    `NpyIter_Deallocate`, instead of doing the unnecessary copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Causes the iterator to provide data for `op[i]` that is in native byte order,
    aligned according to the dtype requirements, contiguous, or any combination.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the iterator produces pointers into the arrays provided, which may
    be aligned or unaligned, and with any byte order. If copying or buffering is not
    enabled and the operand data doesn’t satisfy the constraints, an error will be
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: The contiguous constraint applies only to the inner loop, successive inner loops
    may have arbitrary pointer changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the requested data type is in non-native byte order, the NBO flag overrides
    it and the requested data type is converted to be in native byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This is for output arrays, and requires that the flag [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY
    "NPY_ITER_WRITEONLY") or [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    be set. If `op[i]` is NULL, creates a new array with the final broadcast dimensions,
    and a layout matching the iteration order of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: When `op[i]` is NULL, the requested data type `op_dtypes[i]` may be NULL as
    well, in which case it is automatically generated from the dtypes of the arrays
    which are flagged as readable. The rules for generating the dtype are the same
    is for UFuncs. Of special note is handling of byte order in the selected dtype.
    If there is exactly one input, the input’s dtype is used as is. Otherwise, if
    more than one input dtypes are combined together, the output will be in native
    byte order.
  prefs: []
  type: TYPE_NORMAL
- en: After being allocated with this flag, the caller may retrieve the new array
    by calling [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray "NpyIter_GetOperandArray")
    and getting the i-th object in the returned C array. The caller must call Py_INCREF
    on it to claim a reference to the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: For use with [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE"),
    this flag disables allocating an array subtype for the output, forcing it to be
    a straight ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Maybe it would be better to introduce a function `NpyIter_GetWrappedOutput`
    and remove this flag?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Ensures that the input or output matches the iteration dimensions exactly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that this operand is the mask to use for selecting elements when writing
    to operands which have the [`NPY_ITER_WRITEMASKED`](#c.NPY_ITER_WRITEMASKED "NPY_ITER_WRITEMASKED")
    flag applied to them. Only one operand may have [`NPY_ITER_ARRAYMASK`](#c.NPY_ITER_ARRAYMASK
    "NPY_ITER_ARRAYMASK") flag applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: The data type of an operand with this flag should be either [`NPY_BOOL`](dtype.html#c.NPY_TYPES.NPY_BOOL
    "NPY_BOOL"), [`NPY_MASK`](dtype.html#c.NPY_TYPES.NPY_MASK "NPY_MASK"), or a struct
    dtype whose fields are all valid mask dtypes. In the latter case, it must match
    up with a struct operand being WRITEMASKED, as it is specifying a mask for each
    field of that array.
  prefs: []
  type: TYPE_NORMAL
- en: This flag only affects writing from the buffer back to the array. This means
    that if the operand is also [`NPY_ITER_READWRITE`](#c.NPY_ITER_READWRITE "NPY_ITER_READWRITE")
    or [`NPY_ITER_WRITEONLY`](#c.NPY_ITER_WRITEONLY "NPY_ITER_WRITEONLY"), code doing
    iteration can write to this operand to control which elements will be untouched
    and which ones will be modified. This is useful when the mask should be a combination
    of input masks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: This array is the mask for all [`writemasked`](../generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") operands. Code uses the `writemasked` flag which indicates that
    only elements where the chosen ARRAYMASK operand is True will be written to. In
    general, the iterator does not enforce this, it is up to the code doing the iteration
    to follow that promise.
  prefs: []
  type: TYPE_NORMAL
- en: When `writemasked` flag is used, and this operand is buffered, this changes
    how data is copied from the buffer into the array. A masked copying routine is
    used, which only copies the elements in the buffer for which `writemasked` returns
    true from the corresponding element in the ARRAYMASK operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In memory overlap checks, assume that operands with `NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE`
    enabled are accessed only in the iterator order.
  prefs: []
  type: TYPE_NORMAL
- en: This enables the iterator to reason about data dependency, possibly avoiding
    unnecessary copies.
  prefs: []
  type: TYPE_NORMAL
- en: This flag has effect only if `NPY_ITER_COPY_IF_OVERLAP` is enabled on the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Extends [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") with several
    advanced options providing more control over broadcasting and buffering.
  prefs: []
  type: TYPE_NORMAL
- en: If -1/NULL values are passed to `oa_ndim`, `op_axes`, `itershape`, and `buffersize`,
    it is equivalent to [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew").
  prefs: []
  type: TYPE_NORMAL
- en: The parameter `oa_ndim`, when not zero or -1, specifies the number of dimensions
    that will be iterated with customized broadcasting. If it is provided, `op_axes`
    must and `itershape` can also be provided. The `op_axes` parameter let you control
    in detail how the axes of the operand arrays get matched together and iterated.
    In `op_axes`, you must provide an array of `nop` pointers to `oa_ndim`-sized arrays
    of type `npy_intp`. If an entry in `op_axes` is NULL, normal broadcasting rules
    will apply. In `op_axes[j][i]` is stored either a valid axis of `op[j]`, or -1
    which means `newaxis`. Within each `op_axes[j]` array, axes may not be repeated.
    The following example is how normal broadcasting applies to a 3-D array, a 2-D
    array, a 1-D array and a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Before NumPy 1.8 `oa_ndim == 0` was used for signalling that ``op_axes`
    and `itershape` are unused. This is deprecated and should be replaced with -1\.
    Better backward compatibility may be achieved by using [`NpyIter_MultiNew`](#c.NpyIter_MultiNew
    "NpyIter_MultiNew") for this case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The `itershape` parameter allows you to force the iterator to have a specific
    iteration shape. It is an array of length `oa_ndim`. When an entry is negative,
    its value is determined from the operands. This parameter allows automatically
    allocated outputs to get additional dimensions which don’t match up with any dimension
    of an input.
  prefs: []
  type: TYPE_NORMAL
- en: If `buffersize` is zero, a default buffer size is used, otherwise it specifies
    how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192
    are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error, otherwise returns the allocated iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Makes a copy of the given iterator. This function is provided primarily to enable
    multi-threaded iteration of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '*TODO*: Move this to a section about multithreaded iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach to multithreaded iteration is to first create an iterator
    with the flags [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP"),
    [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED "NPY_ITER_RANGED"), [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED"), [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC "NPY_ITER_DELAY_BUFALLOC"),
    and possibly [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER").
    Create a copy of this iterator for each thread (minus one for the first iterator).
    Then, take the iteration index range `[0, NpyIter_GetIterSize(iter))` and split
    it up into tasks, for example using a TBB parallel_for loop. When a thread gets
    a task to execute, it then uses its copy of the iterator by calling [`NpyIter_ResetToIterIndexRange`](#c.NpyIter_ResetToIterIndexRange
    "NpyIter_ResetToIterIndexRange") and iterating over the full range.
  prefs: []
  type: TYPE_NORMAL
- en: When using the iterator in multi-threaded code or in code not holding the Python
    GIL, care must be taken to only call functions which are safe in that context.
    [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") cannot be safely called without
    the Python GIL, because it increments Python references. The `Reset*` and some
    other functions may be safely called by passing in the `errmsg` parameter as non-NULL,
    so that the functions will pass back errors through it instead of setting a Python
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[`NpyIter_Deallocate`](#c.NpyIter_Deallocate "NpyIter_Deallocate") must be
    called for each copy.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Removes an axis from iteration. This requires that [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") was set for iterator creation, and does not work if buffering
    is enabled or an index is being tracked. This function also resets the iterator
    to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for setting up an accumulation loop, for example. The iterator
    can first be created with all the dimensions, including the accumulation axis,
    so that the output gets created correctly. Then, the accumulation axis can be
    removed, and the calculation done in a nested fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again! The
    iterator range will be reset as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: If the iterator is tracking a multi-index, this strips support for them, and
    does further iterator optimizations that are possible if multi-indices are not
    needed. This function also resets the iterator to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function may change the internal memory layout of the iterator.
    Any cached functions or pointers from the iterator must be retrieved again!'
  prefs: []
  type: TYPE_NORMAL
- en: After calling this function, [NpyIter_HasMultiIndex](#c.NpyIter_HasMultiIndex
    "NpyIter_HasMultiIndex")([iter](#c.NpyIter_RemoveMultiIndex "iter")) will return
    false.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: If [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    was called, you may want to enable the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP"). This flag is not permitted together with [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX"), so this function is provided to enable the feature after
    [`NpyIter_RemoveMultiIndex`](#c.NpyIter_RemoveMultiIndex "NpyIter_RemoveMultiIndex")
    is called. This function also resets the iterator to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: This function changes the internal logic of the iterator. Any
    cached functions or pointers from the iterator must be retrieved again!'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Deallocates the iterator object and resolves any needed writebacks.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator back to its initial state, at the beginning of the iteration
    range.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator and restricts it to the `iterindex` range `[istart, iend)`.
    See [`NpyIter_Copy`](#c.NpyIter_Copy "NpyIter_Copy") for an explanation of how
    to use this for multi-threaded iteration. This requires that the flag [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was passed to the iterator constructor.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to reset both the `iterindex` range and the base pointers at the
    same time, you can do the following to avoid extra buffer copying (be sure to
    add the return code error checks when you copy this code).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Resets the iterator back to its initial state, but using the values in `baseptrs`
    for the data instead of the pointers from the arrays being iterated. This functions
    is intended to be used, together with the `op_axes` parameter, by nested iteration
    code with two or more iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '*TODO*: Move the following into a special section on nested iterators.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating iterators for nested iteration requires some care. All the iterator
    operands must match exactly, or the calls to [`NpyIter_ResetBasePointers`](#c.NpyIter_ResetBasePointers
    "NpyIter_ResetBasePointers") will be invalid. This means that automatic copies
    and output allocation should not be used haphazardly. It is possible to still
    use the automatic data conversion and casting features of the iterator by creating
    one of the iterators with all the conversion parameters enabled, then grabbing
    the allocated operands with the [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray") function and passing them into the constructors for
    the rest of the iterators.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: When creating iterators for nested iteration, the code must not
    use a dimension more than once in the different iterators. If this is done, nested
    iteration will produce out-of-bounds pointers during iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: When creating iterators for nested iteration, buffering can only
    be applied to the innermost iterator. If a buffered iterator is used as the source
    for `baseptrs`, it will point into a small buffer instead of the array and the
    inner iteration will be invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern for using nested iterators is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `ndim` indices pointed to by `multi_index`.
    Returns an error if a multi-index is not being tracked, the indices are out of
    bounds, or inner loop iteration is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `index` specified. If the iterator was
    constructed with the flag [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX "NPY_ITER_C_INDEX"),
    `index` is the C-order index, and if the iterator was constructed with the flag
    [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX"), `index` is the Fortran-order
    index. Returns an error if there is no index being tracked, the index is out of
    bounds, or inner loop iteration is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of elements being iterated. This is the product of all the
    dimensions in the shape. When a multi index is being tracked (and *NpyIter_RemoveAxis*
    may be called) the size may be `-1` to indicate an iterator is too large. Such
    an iterator is invalid, but may become valid after *NpyIter_RemoveAxis* is called.
    It is not necessary to check for this case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Gets the `iterindex` of the iterator, which is an index matching the iteration
    order of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Gets the `iterindex` sub-range that is being iterated. If [`NPY_ITER_RANGED`](#c.NPY_ITER_RANGED
    "NPY_ITER_RANGED") was not specified, this always returns the range `[0, NpyIter_IterSize(iter))`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Adjusts the iterator to point to the `iterindex` specified. The IterIndex is
    an index matching the iteration order of the iterator. Returns an error if the
    `iterindex` is out of bounds, buffering is enabled, or inner loop iteration is
    disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the flag [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was passed to the iterator constructor, and no call
    to one of the Reset functions has been done yet, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the caller needs to handle the inner-most 1-dimensional loop, or
    0 if the iterator handles all looping. This is controlled by the constructor flag
    [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    or [`NpyIter_EnableExternalLoop`](#c.NpyIter_EnableExternalLoop "NpyIter_EnableExternalLoop").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX
    "NPY_ITER_MULTI_INDEX") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator requires buffering, which occurs when an operand needs
    conversion or alignment and so cannot be used directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Returns 1 if the iterator was created with the [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER
    "NPY_ITER_GROWINNER") flag, 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: If the iterator is buffered, returns the size of the buffer being used, otherwise
    returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of dimensions being iterated. If a multi-index was not requested
    in the iterator constructor, this value may be smaller than the number of dimensions
    in the original objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Returns the number of operands in the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Gets the array of strides for the specified axis. Requires that the iterator
    be tracking a multi-index, and that buffering not be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: This may be used when you want to match up operand axes in some fashion, then
    remove them with [`NpyIter_RemoveAxis`](#c.NpyIter_RemoveAxis "NpyIter_RemoveAxis")
    to handle their processing manually. By calling this function before removing
    the axes, you can get the strides for the manual processing.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NULL` on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Returns the broadcast shape of the iterator in `outshape`. This can only be
    called on an iterator which is tracking a multi-index.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` data type Descrs for the objects being
    iterated. The result points into `iter`, so the caller does not gain any references
    to the Descrs.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` operand PyObjects that are being iterated.
    The result points into `iter`, so the caller does not gain any references to the
    PyObjects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a reference to a new ndarray view, which is a view into the
    i-th object in the array [`NpyIter_GetOperandArray`](#c.NpyIter_GetOperandArray
    "NpyIter_GetOperandArray"), whose dimensions and strides match the internal optimized
    iteration pattern. A C-order iteration of this view is equivalent to the iterator’s
    iteration order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an iterator was created with a single array as its input, and
    it was possible to rearrange all its axes and then collapse it into a single strided
    iteration, this would return a view that is a one-dimensional array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Fills `nop` flags. Sets `outreadflags[i]` to 1 if `op[i]` can be read from,
    and to 0 if not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Fills `nop` flags. Sets `outwriteflags[i]` to 1 if `op[i]` can be written to,
    and to 0 if not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Builds a set of strides which are the same as the strides of an output array
    created using the [`NPY_ITER_ALLOCATE`](#c.NPY_ITER_ALLOCATE "NPY_ITER_ALLOCATE")
    flag, where NULL was passed for op_axes. This is for data packed contiguously,
    but not necessarily in C or Fortran order. This should be used together with [`NpyIter_GetShape`](#c.NpyIter_GetShape
    "NpyIter_GetShape") and [`NpyIter_GetNDim`](#c.NpyIter_GetNDim "NpyIter_GetNDim")
    with the flag [`NPY_ITER_MULTI_INDEX`](#c.NPY_ITER_MULTI_INDEX "NPY_ITER_MULTI_INDEX")
    passed into the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: A use case for this function is to match the shape and layout of the iterator
    and tack on one or more dimensions. For example, in order to generate a vector
    per input value for a numerical gradient, you pass in ndim*itemsize for itemsize,
    then add another dimension to the end with size ndim and stride itemsize. To do
    the Hessian matrix, you do the same thing but add two dimensions, or take advantage
    of the symmetry and pack it into 1 dimension with a particular encoding.
  prefs: []
  type: TYPE_NORMAL
- en: This function may only be called if the iterator is tracking a multi-index and
    if [`NPY_ITER_DONT_NEGATE_STRIDES`](#c.NPY_ITER_DONT_NEGATE_STRIDES "NPY_ITER_DONT_NEGATE_STRIDES")
    was used to prevent an axis from being iterated in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: If an array is created with this method, simply adding ‘itemsize’ for each iteration
    will traverse the new array matching the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Returns `NPY_SUCCEED` or `NPY_FAIL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see whether this is the first time the elements of the specified reduction
    operand which the iterator points at are being seen for the first time. The function
    returns a reasonable answer for reduction operands and when buffering is disabled.
    The answer may be incorrect for buffered non-reduction operands.
  prefs: []
  type: TYPE_NORMAL
- en: This function is intended to be used in EXTERNAL_LOOP mode only, and will produce
    some wrong answers when that mode is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If this function returns true, the caller should also check the inner loop stride
    of the operand, because if that stride is 0, then only the first element of the
    innermost external loop is being visited for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: '*WARNING*: For performance reasons, ‘iop’ is not bounds-checked, it is not
    confirmed that ‘iop’ is actually a reduction operand, and it is not confirmed
    that EXTERNAL_LOOP mode is enabled. These checks are the responsibility of the
    caller, and should be done outside of any inner loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions For Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Returns a function pointer for iteration. A specialized version of the function
    pointer may be calculated by this function instead of being stored in the iterator
    structure. Thus, to get good performance, it is required that the function pointer
    be saved in a variable rather than retrieved for each loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: The typical looping construct is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: When [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is specified, the typical inner loop construct is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Observe that we are using the dataptr array inside the iterator, not copying
    the values to a local temporary. This is possible because when `iternext()` is
    called, these pointers will be overwritten with fresh values, not incrementally
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: If a compile-time fixed buffer is being used (both flags [`NPY_ITER_BUFFERED`](#c.NPY_ITER_BUFFERED
    "NPY_ITER_BUFFERED") and [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP")), the inner size may be used as a signal as well. The
    size is guaranteed to become zero when `iternext()` returns false, enabling the
    following loop construct. Note that if you use this construct, you should not
    pass [`NPY_ITER_GROWINNER`](#c.NPY_ITER_GROWINNER "NPY_ITER_GROWINNER") as a flag,
    because it will cause larger sizes under some circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Returns a function pointer for getting the current multi-index of the iterator.
    Returns NULL if the iterator is not tracking a multi-index. It is recommended
    that this function pointer be cached in a local variable before the iteration
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Returns NULL if there is an error. If errmsg is non-NULL, no Python exception
    is set when `NPY_FAIL` is returned. Instead, *errmsg is set to an error message.
    When errmsg is non-NULL, the function may be safely called without holding the
    Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the `nop` data pointers. If [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP
    "NPY_ITER_EXTERNAL_LOOP") was not specified, each data pointer points to the current
    data item of the iterator. If no inner iteration was specified, it points to the
    first data item of the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Gets the array of data pointers directly into the arrays (never into the buffers),
    corresponding to iteration index 0.
  prefs: []
  type: TYPE_NORMAL
- en: These pointers are different from the pointers accepted by `NpyIter_ResetBasePointers`,
    because the direction along some axes may have been reversed.
  prefs: []
  type: TYPE_NORMAL
- en: This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This gives back a pointer to the index being tracked, or NULL if no index is
    being tracked. It is only usable if one of the flags [`NPY_ITER_C_INDEX`](#c.NPY_ITER_C_INDEX
    "NPY_ITER_C_INDEX") or [`NPY_ITER_F_INDEX`](#c.NPY_ITER_F_INDEX "NPY_ITER_F_INDEX")
    were specified during construction.
  prefs: []
  type: TYPE_NORMAL
- en: When the flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    is used, the code needs to know the parameters for doing the inner loop. These
    functions provide that information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to an array of the `nop` strides, one for each iterated object,
    to be used by the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer may be cached before the iteration loop, calling `iternext` will
    not change it. This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: While the pointer may be cached, its values may change if the
    iterator is buffered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the number of iterations the inner loop should execute.
  prefs: []
  type: TYPE_NORMAL
- en: This address may be cached before the iteration loop, calling `iternext` will
    not change it. The value itself may change during iteration, in particular if
    buffering is enabled. This function may be safely called without holding the Python
    GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Gets an array of strides which are fixed, or will not change during the entire
    iteration. For strides that may change, the value NPY_MAX_INTP is placed in the
    stride.
  prefs: []
  type: TYPE_NORMAL
- en: Once the iterator is prepared for iteration (after a reset if [`NPY_ITER_DELAY_BUFALLOC`](#c.NPY_ITER_DELAY_BUFALLOC
    "NPY_ITER_DELAY_BUFALLOC") was used), call this to get the strides which may be
    used to select a fast inner loop function. For example, if the stride is 0, that
    means the inner loop can always load its value into a variable once, then use
    the variable throughout the loop, or if the stride equals the itemsize, a contiguous
    version for that operand may be used.
  prefs: []
  type: TYPE_NORMAL
- en: This function may be safely called without holding the Python GIL.
  prefs: []
  type: TYPE_NORMAL
- en: '## Converting from Previous NumPy Iterators'
  prefs: []
  type: TYPE_NORMAL
- en: The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter*
    and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast,
    and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality
    with a single object and associated API. One goal of the new API is that all uses
    of the existing iterator should be replaceable with the new iterator without significant
    effort. In 1.6, the major exception to this is the neighborhood iterator, which
    does not have corresponding features in this iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a conversion table for which functions to use with the new iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *Iterator Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_IterNew`](array.html#c.PyArray_IterNew "PyArray_IterNew") | [`NpyIter_New`](#c.NpyIter_New
    "NpyIter_New") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_IterAllButAxis`](array.html#c.PyArray_IterAllButAxis "PyArray_IterAllButAxis")
    | [`NpyIter_New`](#c.NpyIter_New "NpyIter_New") + `axes` parameter **or** Iterator
    flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_BroadcastToShape`](array.html#c.PyArray_BroadcastToShape "PyArray_BroadcastToShape")
    | **NOT SUPPORTED** (Use the support for multiple operands instead.) |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArrayIter_Check`](array.html#c.PyArrayIter_Check "PyArrayIter_Check")
    | Will need to add this in Python exposure |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_RESET`](array.html#c.PyArray_ITER_RESET "PyArray_ITER_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_NEXT`](array.html#c.PyArray_ITER_NEXT "PyArray_ITER_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_DATA`](array.html#c.PyArray_ITER_DATA "PyArray_ITER_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_GOTO`](array.html#c.PyArray_ITER_GOTO "PyArray_ITER_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_GOTO1D`](array.html#c.PyArray_ITER_GOTO1D "PyArray_ITER_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ITER_NOTDONE`](array.html#c.PyArray_ITER_NOTDONE "PyArray_ITER_NOTDONE")
    | Return value of `iternext` function pointer |'
  prefs: []
  type: TYPE_TB
- en: '| *Multi-iterator Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIterNew`](array.html#c.PyArray_MultiIterNew "PyArray_MultiIterNew")
    | [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_RESET`](array.html#c.PyArray_MultiIter_RESET "PyArray_MultiIter_RESET")
    | [`NpyIter_Reset`](#c.NpyIter_Reset "NpyIter_Reset") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NEXT`](array.html#c.PyArray_MultiIter_NEXT "PyArray_MultiIter_NEXT")
    | Function pointer from [`NpyIter_GetIterNext`](#c.NpyIter_GetIterNext "NpyIter_GetIterNext")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_DATA`](array.html#c.PyArray_MultiIter_DATA "PyArray_MultiIter_DATA")
    | [`NpyIter_GetDataPtrArray`](#c.NpyIter_GetDataPtrArray "NpyIter_GetDataPtrArray")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NEXTi`](array.html#c.PyArray_MultiIter_NEXTi "PyArray_MultiIter_NEXTi")
    | **NOT SUPPORTED** (always lock-step iteration) |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_GOTO`](array.html#c.PyArray_MultiIter_GOTO "PyArray_MultiIter_GOTO")
    | [`NpyIter_GotoMultiIndex`](#c.NpyIter_GotoMultiIndex "NpyIter_GotoMultiIndex")
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_GOTO1D`](array.html#c.PyArray_MultiIter_GOTO1D "PyArray_MultiIter_GOTO1D")
    | [`NpyIter_GotoIndex`](#c.NpyIter_GotoIndex "NpyIter_GotoIndex") or [`NpyIter_GotoIterIndex`](#c.NpyIter_GotoIterIndex
    "NpyIter_GotoIterIndex") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_MultiIter_NOTDONE`](array.html#c.PyArray_MultiIter_NOTDONE "PyArray_MultiIter_NOTDONE")
    | Return value of `iternext` function pointer |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_Broadcast`](array.html#c.PyArray_Broadcast "PyArray_Broadcast")
    | Handled by [`NpyIter_MultiNew`](#c.NpyIter_MultiNew "NpyIter_MultiNew") |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_RemoveSmallest`](array.html#c.PyArray_RemoveSmallest "PyArray_RemoveSmallest")
    | Iterator flag [`NPY_ITER_EXTERNAL_LOOP`](#c.NPY_ITER_EXTERNAL_LOOP "NPY_ITER_EXTERNAL_LOOP")
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Other Functions* |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`PyArray_ConvertToCommonType`](array.html#c.PyArray_ConvertToCommonType
    "PyArray_ConvertToCommonType") | Iterator flag [`NPY_ITER_COMMON_DTYPE`](#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") |'
  prefs: []
  type: TYPE_TB
