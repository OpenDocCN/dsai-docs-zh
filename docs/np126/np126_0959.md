# 升级 PCG64 为 PCG64DXSM

> 原文：[`numpy.org/doc/1.26/reference/random/upgrading-pcg64.html`](https://numpy.org/doc/1.26/reference/random/upgrading-pcg64.html)

在大规模并行上下文中使用`PCG64` `BitGenerator` 已经显示出了统计上的弱点，在 numpy 1.17 发布时并不明显。大多数用户永远不会观察到这个弱点，并且可以继续安全使用 `PCG64`. 我们引入了一个新的 `PCG64DXSM` `BitGenerator`，它最终将成为将来版本中由 `default_rng` 使用的新默认 `BitGenerator` 实现。 `PCG64DXSM` 解决了统计上的弱点，同时保留了 `PCG64` 的性能和特性。

## 这会对我产生影响吗？

如果您

> 1.  只使用单个`Generator`实例，
> 1.  
> 1.  只使用`RandomState`或`numpy.random`中的函数，
> 1.  
> 1.  只使用`PCG64.jumped`方法来生成并行流，
> 1.  
> 1.  明确使用`BitGenerator`而非`PCG64`,

那么这个弱点对你没有任何影响。继续进行。

如果您使用 `default_rng`或 `SeedSequence.spawn` 创建的适量并行流，在 1000s 范围内，那么观察到这个弱点的机会是微乎其微的。您可以继续舒适地使用 `PCG64`。

如果您使用了大量的并行流，数量达到百万级，并且从每个流中抽取了大量的数字，那么观察到这种弱点的机会就会变得不可忽略，尽管仍然很小。这样的用例示例可能是一个非常大的分布式强化学习问题，每个问题都有数百万次长的蒙特卡洛模拟，每个模拟都生成了数十亿次的随机数。这种用例应该明确地考虑使用`PCG64DXSM`或者另一个现代的`BitGenerator`，比如`SFC64`或`Philox`，但是几乎可以肯定你可能计算过的任何旧结果都是无效的。无论如何，这种弱点属于一种[生日悖论](https://en.wikipedia.org/wiki/Birthday_problem)的碰撞。也就是说，几百万个并行流中的一对，考虑在一起，可能不会通过一套严格的随机性检验。其余数百万个流都会完全正常，而在大多数应用中，坏对在整个计算中剩余流的影响很可能会被淹没。

## 技术细节

像许多伪随机数生成算法一样，`PCG64`是由一个转换函数构建的，这个函数会推进一个 128 位的状态，以及一个输出函数，将 128 位的状态混合成一个 64 位整数输出。PCG 系列伪随机数生成器的一个指导设计原则之一是在转换函数和输出函数之间平衡计算成本（和伪随机性强度）。转换函数是一个 128 位线性同余生成器（LCG），它包括将 128 位状态与固定乘法常数相乘，然后加上用户选择的增量，在 128 位模算术中。尽管 128 位 LCG 本身足够大，可以通过简单的输出函数在自身上通过严格的统计测试，但 LCG 是已知有弱点的伪随机数生成器。`PCG64`的输出函数旨在通过“恰到好处”的位混合来修补一些已知的弱点，以帮助在不增加太多计算成本的情况下提高统计特性。

已知这个随机数发生器（LCG）的一个弱点是，使用步数为 2 的 N 次方(`bg.advance(2**N)`)会使低位的 N 个 bit 与上一状态相同。对于一个逐个生成的单一流而言，这只会产生微不足道的影响。剩下的\(128-N\)个 bit 会提供足够的伪随机性，对于在单一流中观察到的任何实际 N 而言，这些 bit 都会被混合在一起。这就是为什么如果你的应用中只使用单一流，那你就不用担心这个问题。类似地，`PCG64.jumped`方法使用了经过精心选择的步数来避免这些冲突。然而，一旦你开始创建“随机初始化”的并行流，要么通过多次调用`default_rng`来使用操作系统熵，要么通过使用`SeedSequence.spawn`，那么我们就需要考虑有多少低位需要“冲突”才能创建一对糟糕的流，然后评估创建这种冲突的概率。[根据经验确定](https://github.com/numpy/numpy/issues/16313)，如果共享状态的低 58 位和共享增量，那么当这对流相互交错时，在绘制了数 GB 的数据后，会在合理的时间内使`PractRand`失败。根据生日悖论的标准计算，对于 58 位的冲突，我们可以看到我们可以创建\(2^{29}\)，或者大约五亿个流，这是冲突概率变得很高的时候。五亿个流是相当多的，而且每个流需要绘制大量的数据才能使统计相关性显现在甚至是严格的`PractRand`测试中。但是，对于分布式强化学习等非常大型的应用程序来说，这些都是可能会出现的问题。我们有理由期待，即使在这些应用程序中，冲突可能也不会对最终结果产生实际影响，因为统计问题只局限于发生冲突的那一对。

现在，让我们考虑增量不受限制的情况。我们的`PCG64`实现同时对状态和增量进行种子化；也就是说，两次调用`default_rng`（几乎肯定）具有不同的状态和增量。在我们第一次发布时，我们认为有种子增量会提供一定程度的额外保护，即在一对流中观察到相关性（`PractRand`失败）需要在状态空间和增量空间中都“接近”。如果这是真的，那么碰撞的“瓶颈”就是`SeedSequence`内部的 128 位熵池大小（128 位的碰撞属于“天方夜谭般不可能发生”类别）。不幸的是，这不是真的。

LCG（线性同余发生器）的一个已知特性是不同的增量会创建*不同*的流，但它们之间存在已知关系。每个 LCG 都有一个遍历所有\(2^{128}\)个不同的 128 位状态的轨道。具有不同增量的两个 LCG 之间是相关的，因为可以“旋转”第一个 LCG 的轨道（将其前进若干步，这些步数可以从两个增量计算出来），以便两个 LCG 始终具有相同的状态，同时可能会有一个加法常数和比特的反转。然后，如果同时迭代两个流，状态将始终由相同的加法常数（和反转，如果存在的话）相关联。请记住，`PCG64`由转移函数（LCG）和输出函数构成。人们预期输出函数的混淆效果足以使不同的流在实践中独立（即“通过`PractRand`测试”），除非两个增量在路径上出现了病态关系（例如 1 和 3）。我们在`PCG64`中实现的当时标准的 PCG 算法的输出函数 XSL-RR 事实证明对掩盖我们上述描述的基础 LCG 的 58 位冲突太弱。对于任何给定的增量对，状态的“冲突”空间的大小是相同的，因此对于这种弱点，增量提供的额外独立性并不能转化为对`PractRand`可以检测到的统计相关性的额外保护。

幸运的是，加强输出功能能够纠正这个弱点，并*确实*将不同的增量提供的额外差异转化为对低位碰撞的额外保护。 要归功于[PCG 作者](https://github.com/numpy/numpy/issues/13635#issuecomment-506088698)，在新的`BitGenerator`系统的长期诞生过程中，她根据相关讨论开发了更为强大的输出功能。在那个时候，我们 NumPy 开发人员选择“保守”，并使用了经过更长时间测试的 XSL-RR 变体。 DXSM 输出功能采用了在强整数哈希中使用的“xorshift-multiply”构造，其雪崩特性比 XSL-RR 输出功能好得多。虽然存在能够诱导“坏”加法常数的“病态”增量对，使得两个流相关联，但绝大多数对会诱导“好”加法常数，使得 LCG 状态的仅有差异流几乎成为独立的输出流。事实上，现在我们曾经关于`PCG64`所做的声明实际上也适用于`PCG64DXSM`：碰撞是可能的，但两个流必须同时在 128 位状态空间中“接近”*且*在 127 位增量空间中“接近”，因此这比在 128 位内部`SeedSequence`池中发生碰撞的微不足道的机会更不太可能。 DXSM 输出功能比 XSL-RR 更具计算密集性，在大多数机器上，LCG 中的一些优化可以弥补性能损失，因此`PCG64DXSM`是一个很好、安全的升级。当然，还有无数更强大的输出功能可以考虑，但大多数会有更大的计算成本，而 DXSM 输出功能现在已经通过`PractRand`进行了大量的 CPU 周期测试。  

## 这会影响我吗？

如果您    

> 1.  只使用单个`Generator`实例，
> 1.  
> 1.  只使用`RandomState`或`numpy.random`中的函数，
> 1.  
> 1.  只使用`PCG64.jumped`方法生成并行流，
> 1.  
> 1.  如果明确使用`BitGenerator`而不是`PCG64`，

那么这个弱点对你完全没有影响。继续进行。

如果您使用了适度数量的由`default_rng`或`SeedSequence.spawn`创建的并行流，数量在 1000 左右，那么观察到这个弱点的机会几乎可以忽略不计。您可以继续舒适地使用`PCG64`。

如果您使用了非常大数量的并行流，数量在百万级，并且每个流中抽取了大量的数字，那么观察到这个弱点的机会可能会变得不可忽略，尽管仍然很小。这样一个使用案例的例子是一个非常大的分布式强化学习问题，每个都生成了数亿次随机数抽取的长蒙特卡洛模拟。这样的使用情况应该明确考虑使用`PCG64DXSM`或另一个现代`BitGenerator`，如`SFC64`或`Philox`，但是您可能计算的任何旧结果都不太可能无效。无论如何，这个弱点是一种[生日悖论](https://en.wikipedia.org/wiki/Birthday_problem)碰撞。也就是说，数百万个并行流中的一对考虑在一起，可能无法通过一组严格的随机性检验。剩下的数百万个流都是完全正常的，并且在大多数应用中，剩余流的影响很可能会淹没整个计算中的坏对的效果。

## 技术细节

像许多 PRNG 算法一样，`PCG64`是由一个转换函数构造的，它推进一个 128 位状态，以及一个输出函数，将 128 位状态混合成一个 64 位整数进行输出。PCG 系列 PRNG 的一个指导性设计原则之一是在转换函数和输出函数之间平衡计算成本（和伪随机强度）。转换函数是一个 128 位线性同余生成器（LCG），它包括将 128 位状态与固定乘法常数相乘，然后在 128 位模算术中加上用户选择的增量。LCGs 是经过深入分析的 PRNG，已知存在一些弱点，尽管 128 位 LCGs 足够大，足以单独通过严格的统计测试，仅使用微不足道的输出函数。`PCG64`的输出函数旨在通过“恰到好处”的比特位混淆，修复一些已知的弱点，以协助统计特性，而不增加过多的计算成本。

其中一个已知的弱点是，通过步数为 2 的幂（`bg.advance(2**N)`）推进 LCG 的状态将使刚离开的较低的 `N` 位与当前状态相同。对于按顺序抽取的单个流，这影响不大。剩下的 \(128-N\) 位提供了足够的伪随机性，对于任何在单个流中可以观察到的实际 `N` 来说，都会混合其中，这就是为什么如果你的应用程序只使用单个流，则不需要担心这一点。同样地，`PCG64.jumped` 方法使用了精心选择的步数，以避免创建这些冲突。但是，一旦开始创建“随机初始化”的并行流，无论是通过反复调用 `default_rng` 使用操作系统熵，还是使用 `SeedSequence.spawn`，那么我们就需要考虑需要“碰撞”多少较低的位，以创建一对糟糕的流，然后评估创建这种碰撞的概率。[经验上](https://github.com/numpy/numpy/issues/16313)，已经确定如果共享状态的较低 58 位并共享增量，则这对流，在交错时，将在抽取几吉字节的数据后合理时间内失败 [`PractRand`](http://pracrand.sourceforge.net/) 测试。根据 58 位碰撞的生日悖论标准计算，我们可以看到可以创建 \(2^{29}\)，或约半十亿个流，这是碰撞概率变高的时候。半十亿个流是非常多的，甚至在严格的 `PractRand` 测试中，每个流需要抽取的数据量变得明显相关之前，统计学上的相关性变得明显之前。但是这是对于非常大的应用程序（如分布式强化学习）的前景。有理由期望，即使在这些应用中，碰撞可能对总体结果产生实际影响，因为统计问题仅限于碰撞对。

现在，让我们考虑当增量不受限制时的情况。我们的`PCG64`的实现同时对状态和增量进行种子化；也就是说，两次调用`default_rng`（几乎可以确定）具有不同的状态和增量。在我们的第一个发布版本中，我们认为拥有种子增量会提供一定程度的额外保护，即必须在状态空间和增量空间中“接近”，才能观察到一对流的相关性（`PractRand`失败）。如果这是真的，那么碰撞的“瓶颈”将是`SeedSequence`内的 128 位熵池大小（128 位碰撞属于“不可思议的罕见”类别）。不幸的是，这并不是真的。

LCG 的已知特性之一是不同的增量会创建*不同的*流，但具有已知的关系。每个 LCG 都有一个轨道，遍历所有\(2^{128}\)个不同的 128 位状态。具有不同增量的两个 LCG 相关联，因为可以“旋转”第一个 LCG 的轨道（将其前进一个我们可以从两个增量计算出的步骤数），以便然后两个 LCG 将始终具有相同的状态，最多一个加法常数和可能位的反转。然后，如果同时迭代两个流，则状态将*始终*保持由相同的加法常数（如果存在）和位反转相关。请记住，`PCG64`由转换函数（LCG）和输出函数构成。人们预期输出函数的混淆效果足够强大，使得不同的流在实践上相互独立（即“通过`PractRand`测试”），除非两个增量与彼此病态相关（例如 1 和 3）。我们在`PCG64`中实现的当时标准 PCG 算法的输出函数 XSL-RR 事实证明对上述我们描述的基础 LCG 的 58 位碰撞太弱。对于任何给定的增量对，状态的“碰撞”空间大小是相同的，因此对于这种弱点，增量提供的额外差异性并不能转化为`PractRand`能够检测到的统计相关性的额外保护。

幸运的是，加强输出功能能够纠正这一弱点，*确实*将由不同增量提供的额外清晰度转化为对这些低位冲突的额外保护。要赞扬[PCG 作者](https://github.com/numpy/numpy/issues/13635#issuecomment-506088698)的是，她在新的`BitGenerator`系统漫长的诞生过程中，根据相关讨论开发了一个更强大的输出功能。我们 NumPy 开发人员选择“保守”，使用了在那个时候经过更长时间测试的 XSL-RR 变体。DXSM 输出功能采用了在强整数哈希中使用的“xorshift-multiply”构造，其具有比 XSL-RR 输出功能更好的雪崩特性。虽然有一些“病态”的增量对，会引发与两个流相关的“不好”的加法常量，但绝大多数对会引发“好”的加法常量，使简单区分的 LCG 状态流变成实际上独立的输出流。事实上，我们曾经关于`PCG64`提出的声明现在实际上也适用于`PCG64DXSM`：碰撞是可能的，但两个流必须同时在 128 位状态空间*和*127 位增量空间内“接近”，这比在 128 位内部`SeedSequence`池内碰撞的微不足道的机会更不太可能。DXSM 输出功能比 XSL-RR 更耗计算资源，但在大多数机器上通过 LCG 的一些优化弥补了性能损失，因此`PCG64DXSM`是一个不错、安全的升级选择。当然，有无限多种更强大的输出功能可供考虑，但大多数将具有更大的计算成本，而 DXSM 输出功能目前已经通过`PractRand`获得了许多 CPU 周期的测试。
