- en: NumPy for MATLAB users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html](https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Some key differences
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
- en: Rough equivalents
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: General purpose equivalents
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '## Notes'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ‘array’ or ‘matrix’? Which should I use?
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 由于`array`在NumPy中是默认值，一些函数可能返回一个`array`，即使你给它们一个`matrix`作为参数。这不应该发生在NumPy函数中（如果发生了，那是一个错误），但基于NumPy的第三方代码可能不会像NumPy那样遵守类型保留。'
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:)` `A*B`是矩阵乘法，因此看起来就像您在线性代数中编写一样（对于Python >= 3.5，普通数组使用`@`操作符具有相同的便利）。'
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 按元素相乘需要调用函数`multiply(A,B)`。'
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<:(` 操作符重载的使用有点不合逻辑：`*`不是按元素运行，但`/`是。'
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`scipy.sparse`的交互方式更清晰。
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`array`更加明智。的确，我们最终打算废弃`matrix`。
- en: Customizing your environment
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义您的环境
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在MATLAB中，用于自定义环境的主要工具是修改搜索路径，包含您喜欢函数的位置。您可以将这种定制放入MATLAB将在启动时运行的启动脚本中。
- en: NumPy, or rather Python, has similar facilities.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy，或者更确切地说是Python，具有类似的功能。
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改Python搜索路径以包括您自己模块的位置，请定义`PYTHONPATH`环境变量。
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在启动交互式Python解释器时执行特定的脚本文件，请定义`PYTHONSTARTUP`环境变量，其中包含您启动脚本的名称。
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与MATLAB不同，在Python中，您需要首先执行一个‘import’语句来使特定文件中的函数可访问。
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个看起来像这样的启动脚本（注意：这只是一个例子，不是“最佳实践”的陈述）：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用不推荐使用的*matrix*和其他*matlib*函数：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Links
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)找到另一个有些过时的MATLAB/NumPy交叉参考。
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[专题软件页面](https://scipy.org/topical-software.html)中找到用于科学工作的Python的工具的广泛列表。
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[Python软件列表：脚本](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)以获取使用Python作为脚本语言的软件列表
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB®和SimuLink®是The MathWorks，Inc.的注册商标。
- en: Introduction
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: MATLAB®和NumPy有很多共同之处，但NumPy是为了与Python一起工作而创建的，并不是MATLAB的克隆。本指南将帮助MATLAB用户开始使用NumPy。
- en: Some key differences
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些关键区别
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: Rough equivalents
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: General purpose equivalents
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: General purpose equivalents
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
- en: '## Notes'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: ‘array’ or ‘matrix’? Which should I use?
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  id: totrans-540
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  id: totrans-541
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  id: totrans-542
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  id: totrans-543
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  id: totrans-545
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  id: totrans-550
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your environment
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: NumPy, or rather Python, has similar facilities.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Links
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
