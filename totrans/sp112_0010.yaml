- en: Sparse Arrays (scipy.sparse)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/sparse.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/sparse.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: '`scipy.sparse` and its submodules provide tools for working with *sparse arrays*.
    Sparse arrays are arrays where only a few locations in the array have any data,
    most of the locations are considered as “empty”. Sparse arrays are useful because
    they allow for simpler, faster, and/or less memory-intensive algorithms for linear
    algebra ([`scipy.sparse.linalg`](../reference/sparse.linalg.html#module-scipy.sparse.linalg
    "scipy.sparse.linalg")) or graph-based computations ([`scipy.sparse.csgraph`](../reference/sparse.csgraph.html#module-scipy.sparse.csgraph
    "scipy.sparse.csgraph")), but they are generally less flexible for operations
    like slicing, reshaping, or assignment. This guide will introduce the basics of
    sparse arrays in [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse
    "scipy.sparse"), explain the unique aspects of sparse data structures, and refer
    onward for other sections of the user guide explaining [sparse linear algebra](https://docs.scipy.org/doc/scipy/tutorial/arpack.html)
    and [graph methods](https://docs.scipy.org/doc/scipy/tutorial/csgraph.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with sparse arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sparse arrays are a special kind of array where only a few locations in the
    array have data. This allows for *compressed* representations of the data to be
    used, where only the locations where data exists are recorded. There are many
    different sparse array formats, each of which makes a different tradeoff between
    compression and functionality. To start, let’s build a very simple sparse array,
    the Coordinate (COO) array ([`coo_array`](../reference/generated/scipy.sparse.coo_array.html#scipy.sparse.coo_array
    "scipy.sparse.coo_array")) and compare it to a dense array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that in our dense array, we have five nonzero values. For example, `2`
    is at location `0,3`, and `4` is at location `1,1`. All of the other values are
    zero. The sparse array records these five values *explicitly* (see the `5 stored
    elements in COOrdinate format`), and then represents all of the remaining zeros
    as *implicit* values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most sparse array methods work in a similar fashion to dense array methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A few “extra” properties, such as `.nnz` which returns the number of stored
    values, are present on sparse arrays as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the reduction operations, such as `.mean()`, `.sum()`, or `.max()`
    will return a numpy array when applied over an axis of the sparse array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is because reductions over sparse arrays are often dense.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sparse array formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Different kinds of sparse arrays have different capabilities. For example,
    COO arrays cannot be subscripted or sliced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But, other formats, such as the Compressed Sparse Row (CSR) [`csr_array`](../reference/generated/scipy.sparse.csr_array.html#scipy.sparse.csr_array
    "scipy.sparse.csr_array") support slicing and element indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse "scipy.sparse")
    will return a different sparse matrix format than the input sparse matrix format.
    For example, the dot product of two sparse arrays in COO format will be a CSR
    format array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This change occurs because [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse
    "scipy.sparse") will change the format of input sparse arrays in order to use
    the most efficient computational method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse "scipy.sparse")
    module contains the following formats, each with their own distinct advantages
    and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Block Sparse Row (BSR) arrays [`scipy.sparse.bsr_array`](../reference/generated/scipy.sparse.bsr_array.html#scipy.sparse.bsr_array
    "scipy.sparse.bsr_array"), which are most appropriate when the parts of the array
    with data occur in contiguous blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate (COO) arrays [`scipy.sparse.coo_array`](../reference/generated/scipy.sparse.coo_array.html#scipy.sparse.coo_array
    "scipy.sparse.coo_array"), which provide a simple way to construct sparse arrays
    and modify them in place. COO can also be quickly converted into other formats,
    such CSR, CSC, or BSR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressed Sparse Row (CSR) arrays [`scipy.sparse.csr_array`](../reference/generated/scipy.sparse.csr_array.html#scipy.sparse.csr_array
    "scipy.sparse.csr_array"), which are most useful for fast arithmetic, vector products,
    and slicing by row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressed Sparse Column (CSC) arrays [`scipy.sparse.csc_array`](../reference/generated/scipy.sparse.csc_array.html#scipy.sparse.csc_array
    "scipy.sparse.csc_array"), which are most useful for fast arithmetic, vector products,
    and slicing by column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagonal (DIA) arrays [`scipy.sparse.dia_array`](../reference/generated/scipy.sparse.dia_array.html#scipy.sparse.dia_array
    "scipy.sparse.dia_array"), which are useful for efficient storage and fast arithmetic
    so long as the data primarily occurs along diagonals of the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary of Keys (DOK) arrays [`scipy.sparse.dok_array`](../reference/generated/scipy.sparse.dok_array.html#scipy.sparse.dok_array
    "scipy.sparse.dok_array"), which are useful for fast construction and single-element
    access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List of Lists (LIL) arrays [`scipy.sparse.lil_array`](../reference/generated/scipy.sparse.lil_array.html#scipy.sparse.lil_array
    "scipy.sparse.lil_array"), which are useful for fast construction and modification
    of sparse arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the strengths and weaknesses of each of the sparse array
    formats can be found in [their documentation](https://docs.scipy.org/doc/scipy/reference/sparse.html#sparse-array-classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'All formats of [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse
    "scipy.sparse") arrays can be constructed directly from a [`numpy.ndarray`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0.dev0)"). However, some sparse formats can be constructed in different
    ways, too. Each sparse array format has different strengths, and these strengths
    are documented in each class. For example, one of the most common methods for
    constructing sparse arrays is to build a sparse array from the individual `row`,
    `column`, and `data` values. For our array from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `row`, `column`, and `data` arrays describe the rows, columns, and values
    where our sparse array has entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these, we can now define a sparse array without building a dense array
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Different classes have different constructors, but the [`scipy.sparse.csr_array`](../reference/generated/scipy.sparse.csr_array.html#scipy.sparse.csr_array
    "scipy.sparse.csr_array"), [`scipy.sparse.csc_array`](../reference/generated/scipy.sparse.csc_array.html#scipy.sparse.csc_array
    "scipy.sparse.csc_array"), and [`scipy.sparse.coo_array`](../reference/generated/scipy.sparse.coo_array.html#scipy.sparse.coo_array
    "scipy.sparse.coo_array") allow for this style of construction.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse arrays, implicit zeros, and duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sparse arrays are useful because they represent much of their values *implicitly*,
    without storing an actual placeholder value. In [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse
    "scipy.sparse"), the value used to represent “no data” is an *implicit zero*.
    This can be confusing when *explicit zeros* are required. For example, in [graph
    methods](https://docs.scipy.org/doc/scipy/tutorial/csgraph.html) from [`scipy.sparse.csgraph`](../reference/sparse.csgraph.html#module-scipy.sparse.csgraph
    "scipy.sparse.csgraph"), we often need to be able to distinguish between (A) a
    link connecting nodes `i` and `j` with zero weight and (B) no link between `i`
    and `j`. Sparse matrices can do this, so long as we keep the *explicit* and *implicit*
    zeros in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our previous `csr` array, we could include an explicit zero
    by including it in the `data` list. Let’s treat the final entry in the array at
    the bottom row and last column as an *explicit zero*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our sparse array will have *six* stored elements, not five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The “extra” element is our *explicit zero*. The two are still identical when
    converted back into a dense array, because dense arrays represent *everything*
    explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But, for sparse arithmetic, linear algebra, and graph methods, the value at
    `2,3` will be considered an *explicit zero*. To remove this explicit zero, we
    can use the `csr.eliminate_zeros()` method. This operates on the sparse array
    *in place*, and removes any zero-value stored elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before `csr.eliminate_zeros()`, there were six stored elements. After, there
    are only five stored elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another point of complication arises from how *duplicates* are processed when
    constructing a sparse array. A *duplicate* can occur when we have two or more
    entries at `row,col` when constructing a sparse array. This often occurs when
    building sparse arrays using the `data`, `row`, and `col` vectors. For example,
    we might represent our previous array with a duplicate value at `1,1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can see that there are *two* `data` values that correspond
    to the `1,1` location in our final array. [`scipy.sparse`](../reference/sparse.html#module-scipy.sparse
    "scipy.sparse") will store these values separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are six stored elements in this sparse array, despite only
    having five unique locations where data occurs. When these arrays are converted
    back to dense arrays, the duplicate values are summed. So, at location `1,1`,
    the dense array will contain the sum of duplicate stored entries, `1 + 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove duplicate values within the sparse array itself and thus reduce the
    number of stored elements, we can use the `.sum_duplicates()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there are only five stored elements in our sparse array, and it is identical
    to the array we have been working with throughout this guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Canonical formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several sparse array formats have “canonical formats” to allow for more efficient
    operations. Generally these consist of added restrictions like:'
  prefs: []
  type: TYPE_NORMAL
- en: No duplicate entries for any value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Classes with a canonical form include: [`coo_array`](../reference/generated/scipy.sparse.coo_array.html#scipy.sparse.coo_array
    "scipy.sparse.coo_array"), [`csr_array`](../reference/generated/scipy.sparse.csr_array.html#scipy.sparse.csr_array
    "scipy.sparse.csr_array"), [`csc_array`](../reference/generated/scipy.sparse.csc_array.html#scipy.sparse.csc_array
    "scipy.sparse.csc_array"), and [`bsr_array`](../reference/generated/scipy.sparse.bsr_array.html#scipy.sparse.bsr_array
    "scipy.sparse.bsr_array"). See the docstrings of these classes for details on
    each canonical representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if an instance of these classes is in canonical form, use the `.has_canonical_format`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert an instance to canonical form, use the `.sum_duplicates()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next steps with sparse arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sparse array types are most helpful when working with large, nearly empty arrays.
    Specifically, [sparse linear algebra](https://docs.scipy.org/doc/scipy/tutorial/arpack.html)
    and [sparse graph methods](https://docs.scipy.org/doc/scipy/tutorial/csgraph.html)
    see the largest improvements in efficiency in these circumstances.
  prefs: []
  type: TYPE_NORMAL
