- en: List of active deprecations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/explanation/active-deprecations.html](https://docs.sympy.org/latest/explanation/active-deprecations.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This pages lists all active deprecations in the SymPy codebase. See the [Deprecation
    Policy](../contributing/deprecations.html#deprecation-policy) page for a description
    of SymPy’s deprecation policy, as well as instructions for contributors on how
    to deprecate things.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the deprecation policy for SymPy is for deprecations to last
    at least **1 year** after the first major release that includes the deprecation.
    After that period, the deprecated functionality may be removed from SymPy, and
    code will need to be updated to use the replacement feature to continue working.
  prefs: []
  type: TYPE_NORMAL
- en: During the deprecation period, a `SymPyDeprecationWarning` message will be printed
    whenever the deprecated functionality is used. It is recommended for users to
    update their code so that it does not use deprecated functionality, as described
    below for each given deprecation.
  prefs: []
  type: TYPE_NORMAL
- en: '## Silencing SymPy Deprecation Warnings'
  prefs: []
  type: TYPE_NORMAL
- en: 'To silence SymPy deprecation warnings, add a filter using the [`warnings`](https://docs.python.org/3/library/warnings.html)
    module. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here `(?s).*<regex matching the warning message>` is a regular expression matching
    the warning message. For example, to filter a warning about `sympy.printing`,
    you might use `message=r"(?s).*sympy\.printing"`. The leading `(?s).*` is there
    because the warnings module matches `message` against the start of the warning
    message, and because typical warning messages span multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: '`<regex matching your module>` should be a regular expression matching your
    module that uses the deprecated code. It is recommended to include this so that
    you don’t also silence the same warning for unrelated modules.'
  prefs: []
  type: TYPE_NORMAL
- en: This same pattern may be used to instead turn `SymPyDeprecationWarning` into
    an error so that you can test that you aren’t using deprecated code. To do this,
    replace `"ignore"` with `"error"` in the above example. You may also omit `message`
    to make this apply to all `SymPyDeprecationWarning` warnings.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using pytest, you can use the [pytest warnings filtering capabilities](https://docs.pytest.org/en/latest/how-to/capture-warnings.html)
    to either ignore `SymPyDeprecationWarning` or turn them into errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Python [`-W` flag](https://docs.python.org/3/using/cmdline.html#cmdoption-W)
    and [`PYTHONWARNINGS` environment variable](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONWARNINGS)
    will NOT work to filter SymPy deprecation warnings (see [this blog post](https://nedbatchelder.com/blog/201810/why_warnings_is_mysterious.html)
    by Ned Batchelder and [this SymPy issue](https://github.com/sympy/sympy/issues/15130)
    for details on why). You will need to either add a `warnings` filter as above
    or use pytest to filter SymPy deprecation warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Deprecated mechanics Body class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Body` class in the `sympy.physics.mechanics` module has been deprecated.
    It was introduced to support the joints framework. However, it causes several
    problems because it represents both rigid bodies and particles. `Body` has now
    been fully replaced by `RigidBody` and `Particle`. Previously, one could create
    a simple rigid body or particle using only the `Body` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now they should be created using the `RigidBody` and `Particle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]  ### Deprecated mechanics JointsMethod'
  prefs: []
  type: TYPE_NORMAL
- en: The `JointsMethod` class in the `sympy.physics.mechanics` module has been deprecated.
    It was introduced to support the joints framework, but it has been fully replaced
    due to limitations in its design. Previously, one could construct as system solely
    consisting out of bodies and joints, which were then parsed by `JointsMethod`
    to a backend, like `KanesMethod` to form the equations of motion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The replacement of `JointsMethod` is `System`, which can be used to form the
    equations of motion of the same cart pole as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]  ### Deprecated matrix mixin classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrix mixin classes are deprecated. Previously the `Matrix` class (aka
    `MutableDenseMatrix`) was created through an inheritance hierarchy that looked
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As of SymPy 1.13 this has been simplified and all classes above `MatrixBase`are
    merged together so the hierarchy looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The matrix mixin classes like `MatrixRequired` etc are still available because
    downstream code might be subclassing these classes but these are all deprecated
    and will be removed in a future version of SymPy. Subclassing these classes is
    deprecated and anycode that does that should be changed to not subclass them.
  prefs: []
  type: TYPE_NORMAL
- en: It is also deprecated to use these classes with `isinstance` like `isinstance(M,
    MatrixCommon)`. Any code doing this should be changed to use `isinstance(M, Matrixbase)`
    instead which will also work with previous SymPy versions.
  prefs: []
  type: TYPE_NORMAL
- en: More generally importing anything from the `sympy.matrices.common` or `sympy.matrices.matrices`
    modules in which these classes are defined is deprecated. These modules will be
    removed in a future release of SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this change is that the convoluted inheritance hierarchy made
    it difficult to improve `Matrix` for the majority of users while still providing
    all of these classes that could be subclassed. Since these mixin classes are no
    longer used as part of `Matrix` they no longer serve any function within SymPy
    and the removal of this now unused code will simplify the codebase.  ### The string
    fallback in `sympify()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `sympify` function would previously convert an unrecognized object to a
    string and retry sympification. This was deprecated in SymPy 1.6 and was removed
    in SymPy 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") is that `sympify(expr)` tries various methods to
    try to convert `expr` into a SymPy objects. Previously if all these methods would
    fail, it would take `str(expr)` and try to parse it using [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). This string fallback feature was deprecated
    in SymPy 1.6 and was removed in SymPy 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behaviour was problematic for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It could affect performance in major ways. See for instance issues [#18056](https://github.com/sympy/sympy/issues/18056)
    and [#15416](https://github.com/sympy/sympy/issues/15416) where it caused up to
    100x slowdowns. The issue is that SymPy functions automatically call `sympify`
    on their arguments. Whenever a function is passed something that `sympify` doesn’t
    know how to convert to a SymPy object, for instance, a Python function type, it
    passes the string to [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). This is significantly slower than the
    direct conversions that happen by default. This occurs specifically whenever `sympify()`
    is used in library code instead of `_sympify()` (or equivalently `sympify(strict=True)`),
    but presently this is done a lot. Using `strict=True` will at some point be the
    default for all library code, but this is a [harder change to make](https://github.com/sympy/sympy/issues/11003).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can cause security issues, since strings are evaled, and objects can return
    whatever string they want in their `__repr__`. See also [https://github.com/sympy/sympy/pull/12524](https://github.com/sympy/sympy/pull/12524).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It really wasn’t very useful to begin with. Just because an object’s string
    form can be parsed into a SymPy expression doesn’t mean it should be parsed that
    way. This is usually correct for custom numeric types, but an object’s repr could
    be anything. For instance, if the string form of an object looks like a valid
    Python identifier, it would parse as a `Symbol`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of ways to make custom objects work inside of [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify").
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if an object is intended to work alongside other SymPy expressions,
    it should subclass from [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") (or [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")). If it does, [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") will just return it unchanged because it will already
    be a valid SymPy object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For objects that you control, you can add the `_sympy_` method. The [sympify
    docstring](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    has an example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For objects that you don’t control, you can add a custom converter to the `sympy.core.sympify.converter`
    dictionary. The [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") docstring also has an example of this.  ### Deprecate
    the DMP.rep attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The internal type of `Poly` is the `DMP` class which previously could be used
    to access the coefficients of a polynomial as a list like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As of SymPy 1.13 the `DMP` type may be implemented by one of two subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DMP_Python` which is like the previous `DMP` type and has a list as its internal
    representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DUP_Flint` which wraps a Flint polynomial from python-flint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DUP_Flint` type does not have an attribute that is analogous to the list
    that `DMP_Python` has. Accessing `.rep` will still generate a list but now gives
    a deprecation warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of `.rep` use the `DMP.to_list()` method which returns an equivalent
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.to_list()` method is also available in previous versions of SymPy and
    its behaviour is unchanged.  ### Deprecate the pkgdata module'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sympy.utilities.pkdata` module is deprecated and will be removed. It is
    no longer used anywhere in SymPy and is unsuitable for use by any downstream code.
    Use the stdlib `importlib.resources` module instead.  ### Deprecate Eq.rewrite(Add)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to rewrite `eq = Eq(x, y)` like `eq.rewrite(Add)` to give `x -
    y` has been deprecated in favor of writing `eq.lhs - eq.rhs`. A replacement property/method
    was not deemed necessary given the clarity of the explicit use of `lhs` and `rhs`,
    and the inclusion of this functionality in the rewrite apparatus leads to failures
    when a node expecting a Boolean is re- written as an Expr.  ### Deprecate markers,
    annotations, fill, rectangles of the Plot class'
  prefs: []
  type: TYPE_NORMAL
- en: The properties `markers, annotations, fill, rectangles` (containing user-provided
    numerical data to be added on a plot) are deprecated. The new implementation saves
    user-provided numerical data into appropriate data series, which can easily be
    processed by `MatplotlibBackend`. Instead of setting those properties directly,
    users should pass the homonym keyword arguments to the plotting functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported behavior is to pass keyword arguments to the plotting functions,
    which works fine for all versions of SymPy (before and after 1.13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting attributes on the plot object is deprecated and will raise warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Motivation for this deprecation: the implementation of the `Plot` class suggests
    that it is ok to add attributes and hard-coded if-statements in the `MatplotlibBackend`
    class to provide more and more functionalities for user-provided numerical data
    (e.g. adding horizontal lines, or vertical lines, or bar plots, etc). However,
    in doing so one would reinvent the wheel: plotting libraries already implements
    the necessary API. There is no need to hard code these things. The plotting module
    should facilitate the visualization of symbolic expressions. The best way to add
    custom numerical data is to retrieve the figure created by the plotting module
    and use the API of a particular plotting library. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]  ### Moved mechanics functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the introduction of some new objects like the `Inertia` and load objects
    in the `sympy.physics.mechanics` module, some functions from `sympy.physics.mechanics.functions`
    have been moved to new modules. This removes some circular import errors and makes
    it easier to navigate through the source code, due to the parity between function
    names and module names. The following functions were moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inertia` has been moved to `sympy.physics.mechanics.inertia`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inertia_of_point_mass` has been moved to `sympy.physics.mechanics.inertia`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gravity` has been moved to `sympy.physics.mechanics.loads`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previously you could import the functions from `sympy.physics.mechanics.functions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now they should be imported from `sympy.physics.mechanics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]  ### Ordered comparisons like `a < b` with modular integers'
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy’s `GF` domains represent modular integers. Previously it was possible
    to compare these with ordered comparisons like `a < b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will now fail with `TypeError` when the ground types are set to `flint`.
    When the ground types are not `flint` these comparisons are now deprecated: they
    will still work but will give a deprecation warning when used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ordered comparisons of modular integer or finite fields do not make sense because
    these are not ordered fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]  ### The `ModularInteger.to_int()` method'
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy’s `GF` domains are for modular integers e.g. `GF(n)` is for the integers
    modulo `n` and can be used like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of a modular integer domain have a `to_int()` method that is deprecated
    since SymPy 1.13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead the preferred way to achieve equivalent behavior is to use the method
    on the domain (added in SymPy 1.13) or alternatively calling `int` might be better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These two ways of converting to an `int` are not equivalent. The domain `GF(p)`
    can be defined with `symmetric=True` or `symmetric=False`. This difference affects
    the behavior of the `to_int` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So if `symmetric=True` (which is the default) then the `to_int` method will
    sometimes return negative integers. If `symmetric=False` or if the `int(a)` method
    is used the returned result is always a nonnegative integer. Note also that the
    behaviour of `int(a)` was changed in SymPy 1.13: in previous versions it was equivalent
    to `a.to_int()`. To write code that behaves the same way in all SymPy versions
    you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `symmetric=False` and use `int(a)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a function like
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The reason for this change is that it makes it possible to use python-flint’s
    `nmod` as an alternative (much faster) implementation for the elements of `GF(p)`.
    It is not possible to add a `to_int` method to python-flint’s `nmod` type or to
    capture the equivalent of `symmetric=True/False` by storing data in the `nmod`
    instance. Deprecating and removing the `to_int` method and changing the behavior
    of the `int` method means that the element instances do not have any behavior
    that depends on whether the domain is considered to be “symmetric” or not. Instead
    the notion of “symmetric” is now purely a property of the domain object itself
    rather than of the elements and so the `to_int` method that depends on this must
    be a domain method rather than an element method.  ### Relocate symbolic functions
    from `ntheory` to `functions`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following symbolic functions in `ntheory` have been moved to `functions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.divisor_sigma`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.primenu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.primeomega`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.reduce_totient`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.totient`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.generate.primepi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.partitions_.npartitions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.residue_ntheory.jacobi_symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.residue_ntheory.legendre_symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.ntheory.residue_ntheory.mobius`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that imports these functions from top-level like `from sympy import mobius`
    will continue to work fine. However code that imports these from the fully qualified
    module like `from sympy.ntheory import mobius` or `from sympy.ntheory.residue_ntheory
    import mobius` will now see a deprecation warning. The new location for these
    functions is in `sympy.functions` but the intended way to import them is still
    from top-level like `from sympy import mobius`.
  prefs: []
  type: TYPE_NORMAL
- en: The following symbolic functions in `ntheory` have been moved to `functions`,
    but cannot be imported at top-level.
  prefs: []
  type: TYPE_NORMAL
- en: '`sympy.ntheory.factor_.udivisor_sigma`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following functions have been moved from `functions` to `ntheory` because
    they are numeric functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`sympy.functions.combinatorial.numbers.carmichael.is_carmichael`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.functions.combinatorial.numbers.carmichael.find_carmichael_numbers_in_range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.functions.combinatorial.numbers.carmichael.find_first_n_carmichaels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using these functions, change from
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Version 1.12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### The `ManagedProperties` metaclass'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ManagedProperties` metaclass was previously the metaclass for `Basic`.
    Now `Basic` does not use metaclasses and so its metaclass is just `type`. Any
    code that previously subclassed `Basic` and wanted to do anything with metaclasses
    would have needed to subclass `ManagedProperties` to make the relevant metaclass.
    The only relevant method of `ManagedProperties` has been moved to `Basic.__init_subclass__`.
    Since `ManagedProperties` is not used as the metaclass for `Basic` any more and
    no longer does anything useful it should be possible for such code to just subclass
    `type` instead for any metaclass.  ### New Joint coordinate format'
  prefs: []
  type: TYPE_NORMAL
- en: 'The format, i.e. type and auto generated name, of the generalized coordinates
    and generalized speeds of the joints in the `sympy.physics.mechanics` module has
    changed. The data type has changed from `list` to `Matrix`, which is the same
    as the type for the generalized coordinates within the `KanesMethod`. The auto
    naming of the generalized coordinates and generalized speeds of the `PinJoint`
    and `PrismaticJoint` have also changed to `q_<joint.name>` and `u_<joint.name>`.
    Previously each of those joints had an unique template for auto generating these
    names.  ### New Joint intermediate frames'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the joint axis in the `sympy.physics.mechanics` module has
    changed. Instead of using the arguments `parent_axis` and `child_axis` to automatically
    determine the joint axis and an intermediate reference frame, the joints now use
    an intermediate frame argument for both the parent and the child body, i.e. `parent_interframe`
    and `child_interframe`. This means that you can now fully define the joint attachment,
    consisting of a point and frame, for both bodies. Furthermore, if a joint like
    the `PinJoint` has a specific joint axis, e.g. the axis about which the rotation
    occurs, then this axis can be specified using the `joint_axis` argument. An advantage
    of this setup is that one can more accurately define the transformation from the
    parent body to the child body.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want a `PinJoint` that rotates the child body about
    the `parent.z` axis and `-child.z` axis. The previous way to specify this joint
    was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When inspecting this matrix you will notice that for `theta_pin = 0` the child
    body is rotated \(\pi\) rad about the `parent.y` axis. In the new definition you
    can see that we get the same result, but this time we have also specified this
    exact rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However if you liked the fact that the deprecated arguments aligned the frames
    for you, then you can still make use of this feature by providing vectors to `parent_interframe`
    and `child_interframe`, which are then oriented such that the joint axis expressed
    in the intermediate frame is aligned with the given vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]  ### Change in joint attachment point argument'
  prefs: []
  type: TYPE_NORMAL
- en: The argument names for specifying the attachment points of a joint in `sympy.physics.mechanics`
    , i.e. `parent_joint_pos` and `child_joint_pos`, have been changed to `parent_point`
    and `child_point`. This is because these arguments can now also be `Point` objects,
    so they can be exactly the same as the `parent_point` and `child_point` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want a `PinJoint` in the parent to be positioned at
    `parent.frame.x` with respect to the mass center, and in the child at `-child.frame.x`.
    The previous way to specify this was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now you can do the same with either
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Version 1.11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Modules `sympy.tensor.array.expressions.conv_*` renamed to `sympy.tensor.array.expressions.from_*`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid possible naming and tab-completion conflicts with functions
    with similar names to the names of the modules, all modules whose name starts
    with `conv_*` in `sympy.tensor.array.expressions` have been renamed to `from_*`.  ###
    New Mathematica code parser'
  prefs: []
  type: TYPE_NORMAL
- en: The old mathematica code parser defined in the module `sympy.parsing.mathematica`
    in the function `mathematica` is deprecated. The function `parse_mathematica`
    with a new and more comprehensive parser should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `additional_translations` parameter for the Mathematica parser is not available
    in `parse_mathematica`. Additional translation rules to convert Mathematica expressions
    into SymPy ones should be specified after the conversion using SymPy’s `.replace(
    )` or `.subs( )` methods on the output expression. If the translator fails to
    recognize the logical meaning of a Mathematica expression, a form similar to Mathematica’s
    full form will be returned, using SymPy’s `Function` object to encode the nodes
    of the syntax tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want `F` to be a function that returns the maximum
    value multiplied by the minimum value, the previous way to specify this conversion
    was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now you can do the same with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]  ### Redundant static methods in `carmichael`'
  prefs: []
  type: TYPE_NORMAL
- en: A number of static methods in `~.carmichael` are just wrappers around other
    functions. Instead of `carmichael.is_perfect_square` use `sympy.ntheory.primetest.is_square`
    and instead of `carmichael.is_prime` use `~.isprime`. Finally, `carmichael.divides`
    can be replaced by instead checking
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]  ### The `check` argument to `HadamardProduct`, `MatAdd` and `MatMul`'
  prefs: []
  type: TYPE_NORMAL
- en: This argument can be used to pass incorrect values to `~.HadamardProduct`, `~.MatAdd`,
    and `~.MatMul` leading to later problems. The `check` argument will be removed
    and the arguments will always be checked for correctness, i.e., the arguments
    are matrices or matrix symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Some traversal functions have been moved'
  prefs: []
  type: TYPE_NORMAL
- en: Some traversal functions have moved. Specifically, the functions
  prefs: []
  type: TYPE_NORMAL
- en: '`bottom_up`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interactive_traversal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postorder_traversal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preorder_traversal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: have moved to different SymPy submodules.
  prefs: []
  type: TYPE_NORMAL
- en: These functions should be used from the top-level `sympy` namespace, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, end-users should use the top-level `sympy` namespace for any functions
    present there. If a name is in the top-level namespace, its specific SymPy submodule
    should not be relied on, as functions may move around due to internal refactorings.  ###
    `sympy.core.trace`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace object `sympy.core.trace.Tr()` was moved to `sympy.physics.quantum.trace.Tr()`.
    This was because it was only used in the `sympy.physics.quantum` submodule, so
    it was better to have it there than in the core.  ### The `sympy.core.compatibility`
    submodule'
  prefs: []
  type: TYPE_NORMAL
- en: The `sympy.core.compatibility` submodule is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: This submodule was only ever intended for internal use. Now that SymPy no longer
    supports Python 2, this module is no longer necessary, and the remaining helper
    functions have been moved to more convenient places in the SymPy codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the functions that were in this module are available from the top-level
    SymPy namespace, i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In general, end-users should use the top-level `sympy` namespace for any functions
    present there. If a name is in the top-level namespace, its specific SymPy submodule
    should not be relied on, as functions may move around due to internal refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining functions in `sympy.core.compatibility` were only intended for
    internal SymPy use and should not be used by user code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, these two functions, `ordered` and `default_sort_key`, also used
    to be in `sympy.utilities.iterables` but have been moved from there as well.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### `expr_free_symbols`'
  prefs: []
  type: TYPE_NORMAL
- en: The `expr_free_symbols` attribute of various SymPy objects is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '`expr_free_symbols` was meant to represent indexed objects such as `MatrixElement`
    and [`Indexed`](../modules/tensor/indexed.html#sympy.tensor.indexed.Indexed "sympy.tensor.indexed.Indexed")
    as free symbols. This was intended to make derivatives of free symbols work. However,
    this now works without making use of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This was a general property that was added to solve a very specific problem
    but it added a layer of abstraction that is not necessary in general.
  prefs: []
  type: TYPE_NORMAL
- en: objects that have structural “non-expression” nodes already allow one to focus
    on the expression node if desired, e.g.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: introduction of this property encourages imprecise thinking when requesting
    free_symbols since it allows one to get symbols from a specific node of an object
    without specifying the node
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the property was incorrectly added to `AtomicExpr` so numbers are returned
    as `expr_free_symbols`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'the application of the concept was misapplied to define `Subs.expr_free_symbols`:
    it added in `expr_free_symbols` of the point but the point is a `Tuple` so nothing
    was added'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it was not used anywhere else in the codebase except in the context of differentiating
    a `Subs` object, which suggested that it was not something of general use, this
    is also confirmed by the fact that,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it was added without specific tests except for test of the derivatives of the
    Subs object for which it was introduced
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See issue [#21494](https://github.com/sympy/sympy/issues/21494) for more discussion.  ###
    `sympy.stats.sample(numsamples=n)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `numsamples` parameter to [`sympy.stats.sample()`](../modules/stats.html#sympy.stats.sample
    "sympy.stats.sample") is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '`numsamples` makes `sample()` return a list of size `numsamples`, like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, this functionality can be easily implemented by the user with a list
    comprehension
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, it is redundant with the `size` parameter, which makes `sample`
    return a NumPy array with the given shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Historically, `sample` was changed in SymPy 1.7 so it returned an iterator instead
    of sample value. Since an iterator was returned, a numsamples parameter was added
    to specify the length of the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this new behavior was considered confusing, as discussed in issue
    [#21563](https://github.com/sympy/sympy/issues/21563), so it was reverted. Now,
    `sample_iter` should be used if a iterator is needed. Consequently, the `numsamples`
    parameter is no longer needed for `sample()`.  ### `sympy.polys.solvers.RawMatrix`'
  prefs: []
  type: TYPE_NORMAL
- en: The `RawMatrix` class is deprecated. The `RawMatrix` class was a subclass of
    `Matrix` that used domain elements instead of `Expr` as the elements of the matrix.
    This breaks a key internal invariant of `Matrix` and this kind of subclassing
    limits improvements to the `Matrix` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only part of SymPy that documented the use of the `RawMatrix` class was
    the Smith normal form code, and that has now been changed to use `DomainMatrix`
    instead. It is recommended that anyone using `RawMatrix` with the previous Smith
    Normal Form code should switch to using `DomainMatrix` as shown in issue [#21402](https://github.com/sympy/sympy/pull/21402).
    A better API for the Smith normal form will be added later.  ### Non-`Expr` objects
    in a Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SymPy 1.8 and earlier versions it was possible to put non-[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") elements in a [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") and the matrix elements could be any arbitrary
    Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not useful and does not really work, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The main reason for making this possible was that there were a number of `Matrix`
    subclasses in the SymPy codebase that wanted to work with objects from the polys
    module, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '`RawMatrix` (see [above](#deprecated-rawmatrix)) was used in `solve_lin_sys`
    which was part of `heurisch` and was also used by `smith_normal_form`. The `NewMatrix`
    class used domain elements as the elements of the Matrix rather than `Expr`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NewMatrix` was used in the `holonomic` module and also used domain elements
    as matrix elements'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PolyMatrix` used a mix of `Poly` and `Expr` as the matrix elements and was
    used by `risch`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these matrix subclasses were broken in different ways and the introduction
    of [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") ([#20780](https://github.com/sympy/sympy/pull/20780),
    [#20759](https://github.com/sympy/sympy/pull/20759), [#20621](https://github.com/sympy/sympy/pull/20621),
    [#19882](https://github.com/sympy/sympy/pull/19882), [#18844](https://github.com/sympy/sympy/pull/18844))
    provides a better solution for all cases. Previous PRs have removed the dependence
    of these other use cases on Matrix ([#21441](https://github.com/sympy/sympy/pull/21441),
    [#21427](https://github.com/sympy/sympy/pull/21427), [#21402](https://github.com/sympy/sympy/pull/21402))
    and now [#21496](https://github.com/sympy/sympy/pull/21496) has deprecated having
    non-`Expr` in a `Matrix`.
  prefs: []
  type: TYPE_NORMAL
- en: This change makes it possible to improve the internals of the Matrix class but
    it potentially impacts on some downstream use cases that might be similar to the
    uses of `Matrix` with non-`Expr` elements that were in the SymPy codebase. A potential
    replacement for code that used `Matrix` with non-`Expr` elements is [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") if the elements are something
    like domain elements and a domain object can be provided for them. Alternatively
    if the goal is just printing support then perhaps `TableForm` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t clear what to advise as a replacement here without knowing more about
    the usecase. If you are unclear how to update your code, please [open an issue](https://github.com/sympy/sympy/issues/new)
    or [write to our mailing list](https://groups.google.com/g/sympy) so we can discuss
    it.  ### The `get_segments` attribute of plotting objects'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_segments` method implemented in [`Line2DBaseSeries`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries
    "sympy.plotting.series.Line2DBaseSeries") is used to convert two list of coordinates,
    `x` and `y`, into a list of segments used by Matplotlib’s `LineCollection` to
    plot a line.
  prefs: []
  type: TYPE_NORMAL
- en: Since the list of segments is only required by Matplotlib (for example, Bokeh,
    Plotly, Mayavi, K3D only require lists of coordinates), this has been moved inside
    the `MatplotlibBackend` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that previously, the method [`get_points()`](../modules/plotting.html#sympy.plotting.series.LineOver1DRangeSeries.get_points
    "sympy.plotting.series.LineOver1DRangeSeries.get_points") always returned uniformly
    sampled points, which meant that some functions were not plotted correctly when
    using `get_points()` to plot with Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this problem, the method `get_segments()` could be used, which used
    adaptive sampling and which could be used with Matplotlib’s `LineCollection`.
    However, this has been changed, and now `get_points()` can also use adaptive sampling.
    The [`get_data()`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries.get_data
    "sympy.plotting.series.Line2DBaseSeries.get_data") method can also be used.  ###
    The `mdft` function in `sympy.physics.matrices`'
  prefs: []
  type: TYPE_NORMAL
- en: The `sympy.physics.matrices.mdft()` function is deprecated. It can be replaced
    with the `DFT` class in `sympy.matrices.expressions.fourier`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, replace `mdft(n)` with `DFT(n).as_explicit()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This was changed because the `sympy.physics` submodule is supposed to only
    contain things that are specific to physics, but the discrete Fourier transform
    matrix is a more general mathematical concept, so it is better located in the
    `sympy.matrices` module. Furthermore, the `DFT` class is a [matrix expression](../modules/matrices/expressions.html#module-sympy.matrices.expressions
    "sympy.matrices.expressions"), meaning it can be unevaluated and support symbolic
    shape.  ### The private `SparseMatrix._smat` and `DenseMatrix._mat` attributes'
  prefs: []
  type: TYPE_NORMAL
- en: The `._mat` attribute of [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") and the `._smat` attribute of [`SparseMatrix`](../modules/matrices/sparse.html#sympy.matrices.sparse.SparseMatrix
    "sympy.matrices.sparse.SparseMatrix") are deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: The internal representation of `Matrix` and `SparseMatrix` was changed to be
    a [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") in [#21626](https://github.com/sympy/sympy/pull/21626)
    so that it is no longer possible to expose a mutable list/dict as a way of mutating
    a `Matrix`. Instead of `._mat` the new `.flat()` method can be used, which returns
    a new list that cannot be used to mutate the `Matrix` itself. Instead of `._smat`
    the `.todok()` method can be used which returns a new dict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these attributes are already changed in SymPy 1.9 to return read-only
    copies, so that any code that relied on mutating them will be broken. Also these
    attributes were technically always private (they started with an underscore),
    so user code should not really have been using them in the first place.  ### laplace_transform
    of a Matrix with noconds=False'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to version 1.9, calling [`laplace_transform()`](../modules/integrals/integrals.html#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform") on a [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") with `noconds=False` (which is the default), resulted
    in a Matrix of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: However, `Matrix` is only designed to work with `Expr` objects (see [Non-Expr
    objects in a Matrix](#deprecated-non-expr-in-matrix) above).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, either use `noconds=True` to remove the convergence conditions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: or use `legacy_matrix=False` to return the new behavior, which will be to return
    a single tuple with the Matrix in the first argument and the convergence conditions
    combined into a single condition for the whole matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When this deprecation is removed the `legacy_matrix=False` behavior will become
    the default, but the flag will be left intact for compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### `sympy.printing.theanocode`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Theano](https://github.com/Theano/Theano) has been discontinued, and forked
    into a new project called [Aesara](https://github.com/aesara-devs/aesara). The
    `sympy.printing.theanocode` module has been renamed to [`sympy.printing.aesaracode`](../modules/printing.html#module-sympy.printing.aesaracode
    "sympy.printing.aesaracode"), and all the corresponding functions have been renamed
    (e.g., `theano_code` has been renamed to [`aesara_code()`](../modules/printing.html#sympy.printing.aesaracode.aesara_code
    "sympy.printing.aesaracode.aesara_code"), `TheanoPrinter` has been renamed to
    [`AesaraPrinter`](../modules/printing.html#sympy.printing.aesaracode.AesaraPrinter
    "sympy.printing.aesaracode.AesaraPrinter"), and so on).  ### `sympy.assumptions.handlers.AskHandler`
    and related methods'
  prefs: []
  type: TYPE_NORMAL
- en: '`Predicate` has experienced a big design change. Previously, its handler was
    a list of `AskHandler` classes and registration was done by `add_handler()` and
    `remove_handler()` functions. Now, its handler is a multipledispatch instance
    and registration is done by `register()` or `register_many()` methods. Users must
    define a predicate class to introduce a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, handlers were defined and registered this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See GitHub issue [#20209](https://github.com/sympy/sympy/issues/20209).
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.7.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Calling `sympy.stats.StochasticProcess.distribution` with `RandomIndexedSymbol`'
  prefs: []
  type: TYPE_NORMAL
- en: The `distribution` method of `sympy.stats` [stochastic processes](../modules/stats.html#sympy-stats-stochastic-processes)
    used to accept a `RandomIndexedSymbol` (that is, a stochastic process indexed
    with a timestamp), but should now only be called with the timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Previously this would work
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It should now be called like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This was change was made as part of a change to store only `Basic` objects in
    `sympy.stats` `.args`. See issue [#20078](https://github.com/sympy/sympy/issues/20078)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### `sympy.stats.DiscreteMarkovChain.absorbing_probabilites()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `absorbing_probabilites` method name was misspelled. The correct spelling
    [`absorbing_probabilities()`](../modules/stats.html#sympy.stats.DiscreteMarkovChain.absorbing_probabilities
    "sympy.stats.DiscreteMarkovChain.absorbing_probabilities") (“absorbing probabilit*i*es”)
    should be used instead.  ### `sympy.utilities.misc.find_executable()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `sympy.utilities.misc.find_executable()` is deprecated. Instead
    use the standard library [`shutil.which()`](https://docs.python.org/3/library/shutil.html#shutil.which)
    function, which has been in the standard library since Python 3.3 and is more
    powerful.  ### Mutable attributes in `sympy.diffgeom`'
  prefs: []
  type: TYPE_NORMAL
- en: Several parts of [`sympy.diffgeom`](../modules/diffgeom.html#module-sympy.diffgeom
    "sympy.diffgeom") have been updated to no longer be mutable, which better matches
    the immutable design used in the rest of SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Passing strings for symbol names in [`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem
    "sympy.diffgeom.CoordSystem") is deprecated. Instead you should be explicit and
    pass symbols with the appropriate assumptions, for instance, instead of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, the `names` keyword argument has been renamed to `symbols`, which
    should be a list of symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Manifold.patches` attribute is deprecated. Patches should be tracked separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Patch.coord_systems` attribute is deprecated. Coordinate systems should
    be tracked separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CoordSystem.transforms` attribute, `CoordSystem.connect_to()` method,
    and `CoordSystem.coord_tuple_transform_to()` method are deprecated. Instead, use
    the `relations` keyword to the `CoordSystem` class constructor and the [`CoordSystem.transformation()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transformation
    "sympy.diffgeom.CoordSystem.transformation") and [`CoordSystem.transform()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transform
    "sympy.diffgeom.CoordSystem.transform") methods (see the docstring of [`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem
    "sympy.diffgeom.CoordSystem") for examples).  ### The `unicode` argument and attribute
    to `sympy.printing.pretty.stringpict.prettyForm` and the `sympy.printing.pretty.pretty_symbology.xstr`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sympy.printing.pretty.pretty_symbology.xstr` function, and the `unicode`
    argument and attribute to [`sympy.printing.pretty.stringpict.prettyForm`](../modules/printing.html#sympy.printing.pretty.stringpict.prettyForm
    "sympy.printing.pretty.stringpict.prettyForm") were both present to support the
    Unicode behavior of Python 2\. Since Unicode strings are the default in Python
    3, these are not needed any more. `xstr()` should be replaced with just `str()`,
    the `unicode` argument to `prettyForm` should be omitted, and the `prettyForm.unicode`
    attribute should be replaced with the `prettyForm.s` attribute.  ### Passing the
    arguments to `lambdify` as a `set`'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the function arguments to lambdify as a set is deprecated. Instead pass
    them as a list or tuple. For example, instead of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because sets are unordered. For instance, in the above example it would
    be impossible for `lambidfy` to know if it was called with `{x, y}` or `{y, x}`.
    Thus, when passed the arguments as a set `lambdify` would have to guess their
    order, which would lead to an incorrect function if it guessed incorrectly.  ###
    Core operators no longer accept non-Expr args'
  prefs: []
  type: TYPE_NORMAL
- en: The core operator classes [`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add"),
    [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"), and [`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow") can no longer be constructed directly with objects that
    are not subclasses of [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr").
  prefs: []
  type: TYPE_NORMAL
- en: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    is the superclass of all SymPy classes that represent scalar numeric quantities.
    For example, [`sin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin"), [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"), and [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") are all subclasses of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"). However, may objects in SymPy are not [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") because they represent some other type of mathematical
    object. For example, [`Set`](../modules/sets.html#sympy.sets.sets.Set "sympy.sets.sets.Set"),
    [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    and [`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")
    are all non-`Expr`. These do not make mathematical sense inside of `Add`, `Mul`,
    and `Pow`, which are designed specifically to represent the addition, multiplication,
    and exponentiation of scalar complex numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Manually constructing one of these classes with such an object is possible,
    but it will generally create something that will then break. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: works and creates `Tuple(2)`, but only because `Mul` is “tricked” by always
    treating \(1 \cdot x = x\). If instead you try
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: it fails with an exception
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: because it tries to call a method of `Expr` on the `Tuple` object, which does
    not have all the `Expr` methods (because it is not a subclass of `Expr`).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use the `+`, `*`, or `**` operation on a non-`Expr` object, use
    the operator directly rather than using `Mul`, `Add` or `Pow`. If functional versions
    of these are desired, you can use a `lambda` or the [`operator`](https://docs.python.org/3/library/operator.html)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Various `sympy.utilities` submodules have moved'
  prefs: []
  type: TYPE_NORMAL
- en: The following submodules have been renamed.
  prefs: []
  type: TYPE_NORMAL
- en: '`sympy.utilities.benchmarking` → `sympy.testing.benchmarking`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.utilities.pytest` → `sympy.testing.pytest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.utilities.randtests` → `sympy.core.random`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.utilities.runtests` → `sympy.testing.runtests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.utilities.tmpfiles` → `sympy.testing.tmpfiles`  ### `sympy.testing.randtest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest` is deprecated. The functions in it have been moved
    to `sympy.core.random`. The following functions have been moved.'
  prefs: []
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest.random_complex_number` → `sympy.core.random.random_complex_number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest.verify_numerically` `sympy.core.random.verify_numerically`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest.test_derivative_numerically` → `sympy.core.random.test_derivative_numerically`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest._randrange` → `sympy.core.random._randrange`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sympy.testing.randtest._randint` → `sympy.core.random._randint`  ### Mixing
    `Poly` and non-polynomial expressions in binary operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In previous versions of SymPy, [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") was a subclass of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), but it has been changed to only be a subclass of [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). This means that some things that used to work with
    `Poly` are now deprecated because they are only designed to work with [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") objects.
  prefs: []
  type: TYPE_NORMAL
- en: This includes combining `Poly` with `Expr` objects using binary operations,
    for example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, either explicitly convert the non-`Poly` operand to a `Poly` using
    [`Expr.as_poly()`](../modules/core.html#sympy.core.expr.Expr.as_poly "sympy.core.expr.Expr.as_poly")
    or convert the `Poly` operand to an [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") using [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr"), depending on which type you want the result
    to be.  ### The `print_cyclic` flag of `sympy.combinatorics.Permutation`'
  prefs: []
  type: TYPE_NORMAL
- en: The `print_cyclic` attribute of [`sympy.combintorics.Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") controls whether permutations
    print as cycles or arrays. This would be done by setting `Permutation.print_cyclic
    = True` or `Permutation.print_cyclic = False`. However, this method of controlling
    printing is bad because it is a global flag, but printing should not depend on
    global behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, users should use the `perm_cyclic` flag of the corresponding printer.
    The easiest way to configure this is to set the flag when calling [`init_printing()`](../modules/interactive.html#sympy.interactive.printing.init_printing
    "sympy.interactive.printing.init_printing"), like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") docstring contains more details
    on the `perm_cyclic` flag.  ### Using `integrate` with `Poly`'
  prefs: []
  type: TYPE_NORMAL
- en: In previous versions of SymPy, [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") was a subclass of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), but it has been changed to only be a subclass of [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). This means that some things that used to work with
    `Poly` are now deprecated because they are only designed to work with [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") objects.
  prefs: []
  type: TYPE_NORMAL
- en: This includes calling [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") or [`Integral`](../modules/integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") with `Poly`.
  prefs: []
  type: TYPE_NORMAL
- en: To integrate a `Poly`, use the [`Poly.integrate()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.integrate
    "sympy.polys.polytools.Poly.integrate") method. To compute the integral as an
    [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") object,
    call the [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr") method first.
  prefs: []
  type: TYPE_NORMAL
- en: 'See also [Mixing Poly and non-polynomial expressions in binary operations](#deprecated-poly-nonpoly-binary-operations)
    above.  ### Creating an indefinite `Integral` with an `Eq` argument'
  prefs: []
  type: TYPE_NORMAL
- en: Passing an [`Eq()`](../modules/core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    object to [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") is deprecated in the case where the integral
    is indefinite. This is because if \(f(x) = g(x)\), then \(\int f(x)\,dx = \int
    g(x)\,dx\) is not true in general, due to the arbitrary constants (which `integrate`
    does not include).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make an equality of indefinite integrals, use `Eq(integrate(f(x),
    x), integrate(g(x), x))` explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have an equality object `eq`, you can use `Eq(integrate(eq.lhs,
    x), integrate(eq.rhs, x))`.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### `Tensor.fun_eval` and `Tensor.__call__`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TensExpr.fun_eval` and `Tensor.__call__` (i.e., calling a tensor to evaluate
    it) are deprecated. The `Tensor.substitute_indices()` method should be used. This
    was changed because `fun_eval` was considered a confusing name and using function
    evaluation was considered both confusing and dangerous.  ### `TensorType`'
  prefs: []
  type: TYPE_NORMAL
- en: The `TensorType` class is deprecated. Use [`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads") instead. The `TensorType` class had no purpose
    except shorter creation of [`TensorHead`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorHead
    "sympy.tensor.tensor.TensorHead") objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'See also [The tensorhead() function](#deprecated-tensorhead) below.  ### The
    `dummy_fmt` argument to `TensorIndexType`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dummy_fmt` keyword argument to [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") is deprecated. Setting `dummy_fmt=''L''`
    leads to `_dummy_fmt=''L_%d''`, which is confusing and uses obsolete string formatting.
    `dummy_name` should be used instead. This change was made because `dummy_name`
    is a clearer name.  ### The `metric` argument to `TensorIndexType`'
  prefs: []
  type: TYPE_NORMAL
- en: The `metric` keyword argument to [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") is deprecated. The name “metric” was ambiguous
    because it meant “metric symmetry” in some places and “metric tensor” in others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the `metric_symmetry` keyword or the `TensorIndexType.set_metric()`
    method should be used instead.  ### The `get_kronecker_delta()` and `get_epsilon()`
    methods of `TensorIndexType`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_kronecker_delta()` and `get_epsilon()` methods of [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") are deprecated. Use the `TensorIndexType.delta`
    and `TensorIndexType.epsilon` properties instead, respectively.  ### The `tensorsymmetry()`
    function'
  prefs: []
  type: TYPE_NORMAL
- en: The `tensorsymmetry()` function in `sympy.tensor` is deprecated. Use the [`TensorSymmetry`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorSymmetry
    "sympy.tensor.tensor.TensorSymmetry") class constructor instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`TensorSymmetry` is preferred over `tensorsymmetry()` because the latter'
  prefs: []
  type: TYPE_NORMAL
- en: Does not have any extra functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Involves obscure Young tableau
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is not a member of the `TensorSymmetry` class  ### The `tensorhead()` function'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `tensorhead()` function is deprecated in favor of [`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads"). `tensor_heads()` is more consistent with
    other SymPy names (i.e., `Symbol` and `symbols()` or `TensorIndex` and `tensor_indices()`).
    It also does not use Young tableau to denote symmetries.  ### The `is_EmptySet`
    attribute of sets'
  prefs: []
  type: TYPE_NORMAL
- en: The `is_EmptySet` attribute of [Set](../modules/sets.html#sets-module) objects
    is deprecated. Instead either use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference is that `s.is_empty` may return `None` if it is unknown if the
    set is empty.  ### `ProductSet(iterable)`'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a single iterable as the first argument to [`ProductSet`](../modules/sets.html#sympy.sets.sets.ProductSet
    "sympy.sets.sets.ProductSet") is deprecated. Creating a product set from an iterable
    should be done using `ProductSet(*iterable)`, or as each individual argument.
    For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done because sets themselves can be iterables, and sets of sets are
    allowed. But the product set of a single set should mathematically be that set
    itself (or more exactly, the set of 1-tuples of elements of that set). Automatically
    denesting a single iterable makes it impossible to represent this object and makes
    `ProductSet` not generalize correctly when passed 1 argument. On the other hand,
    treating the first argument differently if it is a set than if it is another type
    of iterable (which is what is currently done in the deprecated code path) is confusing
    behavior.  ### The `set_potential_energy` method in `sympy.physics.mechanics`'
  prefs: []
  type: TYPE_NORMAL
- en: The `set_potential_energy()` methods of [`sympy.physics.mechanics.particle.Particle`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle
    "sympy.physics.mechanics.particle.Particle") and [`sympy.physics.mechanics.rigidbody.RigidBody`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody
    "sympy.physics.mechanics.rigidbody.RigidBody") are deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Instead one should set the [`Particle.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle.potential_energy
    "sympy.physics.mechanics.particle.Particle.potential_energy") and [`RigidBody.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody.potential_energy
    "sympy.physics.mechanics.rigidbody.RigidBody.potential_energy") attributes to
    set the potential energy, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This change was made to be more Pythonic, by using setters and getters of a
    `@property` method rather than an explicit `set_` method.  ### Using a set for
    the condition in `ConditionSet`'
  prefs: []
  type: TYPE_NORMAL
- en: Using a set for the condition in ConditionSet is deprecated. A boolean should
    be used instead. This is because the condition is mathematically a boolean, and
    it is ambiguous what a set should mean in this context.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this deprecation, replace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: would become
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]  ### The `max_degree` and `get_upper_degree` properties of `sympy.polys.multivariate_resultants.DixonResultant`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max_degree` property and `get_upper_degree()` methods of `DixonResultant`
    are deprecated. See issue [#17749](https://github.com/sympy/sympy/pull/17749)
    for details.  ### Non-tuple iterable for the first argument to `Lambda`'
  prefs: []
  type: TYPE_NORMAL
- en: Using a non-tuple as the first argument to [`Lambda`](../modules/core.html#sympy.core.function.Lambda
    "sympy.core.function.Lambda") is deprecated. If you have a non-tuple, convert
    it to a tuple first, like `Lambda(tuple(args), expr)`.
  prefs: []
  type: TYPE_NORMAL
- en: This was done so that `Lambda` could support general tuple unpacking, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]  ### The `evaluate` flag to `differentiate_finite`'
  prefs: []
  type: TYPE_NORMAL
- en: The `evaluate` flag to [`differentiate_finite()`](../modules/calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite") is deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: '`differentiate_finite(expr, x, evaluate=True)` expands the intermediate derivatives
    before computing differences. But this usually not what you want, as it does not
    satisfy the product rule.'
  prefs: []
  type: TYPE_NORMAL
- en: If you really do want this behavior, you can emulate it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See the discussion on issue [#17881](https://github.com/sympy/sympy/pull/17881).
  prefs: []
  type: TYPE_NORMAL
- en: Version 1.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### `TensorIndexType.data` and related methods'
  prefs: []
  type: TYPE_NORMAL
- en: The `TensorIndexType.data` property is deprecated, as well as several methods
    which made use of it including the `get_matrix()`, the `__getitem__()` (indexing),
    `__iter__()` (iteration), `_components_data_full_destroy()`, and `__pow__()` (`**`)
    methods. Storing data on tensor objects was a design flaw and not consistent with
    how the rest of SymPy works.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the [`TensExpr.replace_with_arrays()`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensExpr.replace_with_arrays
    "sympy.tensor.tensor.TensExpr.replace_with_arrays") method should be used.
  prefs: []
  type: TYPE_NORMAL
