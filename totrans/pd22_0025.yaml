- en: Essential basic functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/basics.html](https://pandas.pydata.org/docs/user_guide/basics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here we discuss a lot of the essential functionality common to the pandas data
    structures. To begin, let’s create some example objects like we did in the [10
    minutes to pandas](10min.html#min) section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '## Head and tail'
  prefs: []
  type: TYPE_NORMAL
- en: To view a small sample of a Series or DataFrame object, use the [`head()`](../reference/api/pandas.DataFrame.head.html#pandas.DataFrame.head
    "pandas.DataFrame.head") and [`tail()`](../reference/api/pandas.DataFrame.tail.html#pandas.DataFrame.tail
    "pandas.DataFrame.tail") methods. The default number of elements to display is
    five, but you may pass a custom number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]  ## Attributes and underlying data'
  prefs: []
  type: TYPE_NORMAL
- en: pandas objects have a number of attributes enabling you to access the metadata
  prefs: []
  type: TYPE_NORMAL
- en: '**shape**: gives the axis dimensions of the object, consistent with ndarray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: *index* (only axis)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: *index* (rows) and *columns*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, **these attributes can be safely assigned to**!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: pandas objects ([`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index"),
    [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"))
    can be thought of as containers for arrays, which hold the actual data and do
    the actual computation. For many types, the underlying array is a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). However, pandas and 3rd party libraries may *extend* NumPy’s
    type system to add support for custom arrays (see [dtypes](#basics-dtypes)).
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual data inside a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use the `.array` property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[`array`](../reference/api/pandas.Series.array.html#pandas.Series.array "pandas.Series.array")
    will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). The exact details of what an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") is and why pandas uses them are a bit
    beyond the scope of this introduction. See [dtypes](#basics-dtypes) for more.'
  prefs: []
  type: TYPE_NORMAL
- en: If you know you need a NumPy array, use [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") or `numpy.asarray()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the Series or Index is backed by an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") may involve copying data and coercing values. See [dtypes](#basics-dtypes)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") gives some control over the `dtype` of the resulting
    [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). For example, consider datetimes with timezones. NumPy doesn’t
    have a dtype to represent timezone-aware datetimes, so there are two possibly
    useful representations:'
  prefs: []
  type: TYPE_NORMAL
- en: An object-dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)") with [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects, each with the correct `tz`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `datetime64[ns]` -dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"), where the values have been converted to UTC and the timezone
    discarded
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timezones may be preserved with `dtype=object`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Or thrown away with `dtype='datetime64[ns]'`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the “raw data” inside a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is possibly a bit more complex. When your `DataFrame` only
    has a single data type for all the columns, [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the underlying data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If a DataFrame contains homogeneously-typed data, the ndarray can actually be
    modified in-place, and the changes will be reflected in the data structure. For
    heterogeneous data (e.g. some of the DataFrame’s columns are not all the same
    dtype), this will not be the case. The values attribute itself, unlike the axis
    labels, cannot be assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with heterogeneous data, the dtype of the resulting ndarray will
    be chosen to accommodate all of the data involved. For example, if strings are
    involved, the result will be of object dtype. If there are only floats and integers,
    the resulting array will be of float dtype.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, pandas recommended [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") or [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") for extracting the data from a Series or DataFrame.
    You’ll still find references to these in old code bases and online. Going forward,
    we recommend avoiding `.values` and using `.array` or `.to_numpy()`. `.values`
    has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: When your Series contains an [extension type](../development/extending.html#extending-extension-types),
    it’s unclear whether [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") returns a NumPy array or the extension array. [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always return an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), and will never copy data. [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will always return a NumPy array, potentially at the
    cost of copying / coercing values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When your DataFrame contains a mixture of data types, [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") may involve copying data and coercing values to a common
    dtype, a relatively expensive operation. [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy"), being a method, makes it clearer that the returned
    NumPy array may not be a view on the same data in the DataFrame.  ## Accelerated
    operations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: pandas has support for accelerating certain types of binary numerical and boolean
    operations using the `numexpr` library and the `bottleneck` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: These libraries are especially useful when dealing with large data sets, and
    provide large speedups. `numexpr` uses smart chunking, caching, and multiple cores.
    `bottleneck` is a set of specialized cython routines that are especially fast
    when dealing with arrays that have `nans`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample (using 100 column x 100,000 row `DataFrames`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | 0.11.0 (ms) | Prior Version (ms) | Ratio to Prior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 > df2` | 13.32 | 125.35 | 0.1063 |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 * df2` | 21.71 | 36.63 | 0.5928 |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 + df2` | 22.04 | 36.50 | 0.6039 |'
  prefs: []
  type: TYPE_TB
- en: You are highly encouraged to install both libraries. See the section [Recommended
    Dependencies](../getting_started/install.html#install-recommended-dependencies)
    for more installation info.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are both enabled to be used by default, you can control this by setting
    the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]  ## Flexible binary operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'With binary operations between pandas data structures, there are two key points
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional
    (e.g. Series) objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data in computations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate how to manage these issues independently, though they can
    be handled simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Matching / broadcasting behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Missing data / operations with fill values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '### Flexible comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).  ###
    Boolean reductions'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can reduce to a final boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.  ###
    Comparing if objects are equivalent'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Comparing array-like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Combining overlapping data sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: General DataFrame combine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]  ## Descriptive statistics'
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a large number of methods for computing descriptive statistics
    and other related operations on [Series](../reference/series.html#api-series-stats),
    [DataFrame](../reference/frame.html#api-dataframe-stats). Most of these are aggregations
    (hence producing a lower-dimensional result) like [`sum()`](../reference/api/pandas.DataFrame.sum.html#pandas.DataFrame.sum
    "pandas.DataFrame.sum"), [`mean()`](../reference/api/pandas.DataFrame.mean.html#pandas.DataFrame.mean
    "pandas.DataFrame.mean"), and [`quantile()`](../reference/api/pandas.DataFrame.quantile.html#pandas.DataFrame.quantile
    "pandas.DataFrame.quantile"), but some of them, like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod"), produce an object of the same size. Generally speaking,
    these methods take an **axis** argument, just like *ndarray.{sum, std, …}*, but
    the axis can be specified by name or integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: no axis argument needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: “index” (axis=0, default), “columns” (axis=1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All such methods have a `skipna` option signaling whether to exclude missing
    data (`True` by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Combined with the broadcasting / arithmetic behavior, one can describe various
    statistical procedures, like standardization (rendering data zero mean and standard
    deviation of 1), very concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that methods like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod") preserve the location of `NaN` values. This is somewhat
    different from [`expanding()`](../reference/api/pandas.DataFrame.expanding.html#pandas.DataFrame.expanding
    "pandas.DataFrame.expanding") and [`rolling()`](../reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling
    "pandas.DataFrame.rolling") since `NaN` behavior is furthermore dictated by a
    `min_periods` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here is a quick reference summary table of common functions. Each also takes
    an optional `level` parameter which applies only if the object has a [hierarchical
    index](advanced.html#advanced-hierarchical).
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA observations |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of values |'
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median of values |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | Mode |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Absolute Value |'
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of values |'
  prefs: []
  type: TYPE_TB
- en: '| `std` | Bessel-corrected sample standard deviation |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Unbiased variance |'
  prefs: []
  type: TYPE_TB
- en: '| `sem` | Standard error of the mean |'
  prefs: []
  type: TYPE_TB
- en: '| `skew` | Sample skewness (3rd moment) |'
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | Sample kurtosis (4th moment) |'
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Sample quantile (value at %) |'
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum |'
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product |'
  prefs: []
  type: TYPE_TB
- en: '| `cummax` | Cumulative maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `cummin` | Cumulative minimum |'
  prefs: []
  type: TYPE_TB
- en: 'Note that by chance some NumPy methods, like `mean`, `std`, and `sum`, will
    exclude NAs on Series input by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series.nunique()`](../reference/api/pandas.Series.nunique.html#pandas.Series.nunique
    "pandas.Series.nunique") will return the number of unique non-NA values in a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '### Summarizing data: describe'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select specific percentiles to include in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By default, the median is always included.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.  ### Index of min/max values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.  ### Value
    counts (histogramming) / mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Discretization and quantiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass infinite values to define the bins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]  ## Function application'
  prefs: []
  type: TYPE_NORMAL
- en: To apply your own or another library’s functions to pandas objects, you should
    be aware of the three methods below. The appropriate method to use depends on
    whether your function expects to operate on an entire `DataFrame` or `Series`,
    row- or column-wise, or elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tablewise Function Application](#tablewise-function-application): [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Row or Column-wise Function Application](#row-or-column-wise-function-application):
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Aggregation API](#aggregation-api): [`agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg") and [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Applying Elementwise Functions](#applying-elementwise-functions): [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '### Tablewise function application'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple functions yield multiple rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a named function will yield that name for the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '#### Custom describe'
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]  ### Transform API'
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Transform with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Transforming with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]  ### Applying elementwise functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]  ## Reindexing and altering labels'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") is the fundamental data alignment method in pandas. It
    is used to implement nearly all other features relying on label-alignment functionality.
    To *reindex* means to conform the data to match a given set of labels along a
    particular axis. This accomplishes several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Reorders the existing data to match a new set of labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts missing value (NA) markers in label locations where no data for that
    label existed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If specified, **fill** data for missing labels using logic (highly relevant
    to working with time series data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `f` label was not contained in the Series and hence appears as `NaN`
    in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, you can simultaneously reindex the index and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Index` objects containing the actual axis labels can be **shared**
    between objects. So if we have a Series and a DataFrame, the following can be
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This means that the reindexed Series’s index is the same Python object as the
    DataFrame’s index.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") also supports an “axis-style” calling convention,
    where you specify a single `labels` argument and the `axis` it applies to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[MultiIndex / Advanced Indexing](advanced.html#advanced) is an even more concise
    way of doing reindexing.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing performance-sensitive code, there is a good reason to spend some
    time becoming a reindexing ninja: **many operations are faster on pre-aligned
    data**. Adding two unaligned DataFrames internally triggers a reindexing step.
    For exploratory analysis you will hardly notice the difference (because `reindex`
    has been heavily optimized), but when CPU cycles matter sprinkling a few explicit
    `reindex` calls here and there can have an impact.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Reindexing to align with another object'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]  ### Aligning objects with each other with `align`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]  ### Filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.  ###
    Limits on filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.  ### Dropping labels from an axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]  ### Renaming / mapping labels'
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]  ## Iteration'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of basic iteration over pandas objects depends on the type. When
    iterating over a Series, it is regarded as array-like, and basic iteration produces
    the values. DataFrames follow the dict-like convention of iterating over the “keys”
    of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, basic iteration (`for i in object`) produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: column labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, for example, iterating over a DataFrame gives you the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: pandas objects also have the dict-like [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") method to iterate over the (key, value) pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over the rows of a DataFrame, you can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"): Iterate over the rows of a DataFrame as (index,
    Series) pairs. This converts the rows to Series objects, which can change the
    dtypes and has some performance implications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples"): Iterate over the rows of a DataFrame as namedtuples
    of the values. This is a lot faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"), and is in most cases preferable to use to iterate
    over the values of a DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating through pandas objects is generally **slow**. In many cases, iterating
    manually over the rows is not needed and can be avoided with one of the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for a *vectorized* solution: many operations can be performed using built-in
    methods or NumPy functions, (boolean) indexing, …'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have a function that cannot work on the full DataFrame/Series at once,
    it is better to use [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") instead of iterating over the values. See the docs on
    [function application](#basics-apply).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to do iterative manipulations on the values but performance is important,
    consider writing the inner loop with cython or numba. See the [enhancing performance](enhancingperf.html#enhancingperf)
    section for some examples of this approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You should **never modify** something you are iterating over. This is not guaranteed
    to work in all cases. Depending on the data types, the iterator returns a copy
    and not a view, and writing to it will have no effect!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following case setting the value has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '### iterrows'
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: itertuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.  ## .dt accessor'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has an accessor to succinctly return datetime like properties for
    the *values* of the Series, if it is a datetime/period like Series. This will
    return a Series, indexed like the existing Series.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables nice expressions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily produces tz aware transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also chain these types of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: You can also format datetime values as strings with [`Series.dt.strftime()`](../reference/api/pandas.Series.dt.strftime.html#pandas.Series.dt.strftime
    "pandas.Series.dt.strftime") which supports the same format as the standard [`strftime()`](https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime
    "(in Python v3.12)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `.dt` accessor works for period and timedelta dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Series.dt` will raise a `TypeError` if you access with a non-datetime-like
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized string methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Series is equipped with a set of string processing methods that make it easy
    to operate on each element of the array. Perhaps most importantly, these methods
    exclude missing/NA values automatically. These are accessed via the Series’s `str`
    attribute and generally have names matching the equivalent (scalar) built-in string
    methods. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Powerful pattern-matching methods are provided as well, but note that pattern-matching
    generally uses [regular expressions](https://docs.python.org/3/library/re.html)
    by default (and in some cases always uses them).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Prior to pandas 1.0, string methods were only available on `object` -dtype `Series`.
    pandas 1.0 added the [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") which is dedicated to strings. See [Text data types](text.html#text-types)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Vectorized String Methods](text.html#text-string-methods) for a
    complete description.
  prefs: []
  type: TYPE_NORMAL
- en: '## Sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas supports three kinds of sorting: sorting by index labels, sorting by
    column values, and sorting by a combination of both.'
  prefs: []
  type: TYPE_NORMAL
- en: '### By index'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'For information on key sorting by value, see [value sorting](#basics-sort-value-key).  ###
    By values'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `by` parameter can take a list of column names, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The name or type of each column can be used to apply different functions to
    different columns.  ### By indexes and values'
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Sort by ‘second’ (index) and ‘A’ (column)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.  ### searchsorted'
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]  ### smallest / largest values'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]  ### Sorting by a MultiIndex column'
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Copying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method on pandas objects copies the underlying data (though
    not the axis indexes, since they are immutable) and returns a new object. Note
    that **it is seldom necessary to copy objects**. For example, there are only a
    handful of ways to alter a DataFrame *in-place*:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, deleting, or modifying a column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to the `index` or `columns` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For homogeneous data, directly modifying the values via the `values` attribute
    or advanced indexing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be clear, no pandas method has the side effect of modifying your data; almost
    every method returns a new object, leaving the original object untouched. If the
    data is modified, it is because you did so explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '## dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, pandas uses NumPy arrays and dtypes for Series or individual
    columns of a DataFrame. NumPy provides support for `float`, `int`, `bool`, `timedelta64[ns]`
    and `datetime64[ns]` (note that NumPy does not support timezone-aware datetimes).
  prefs: []
  type: TYPE_NORMAL
- en: pandas and third-party libraries *extend* NumPy’s type system in a few places.
    This section describes the extensions pandas has made internally. See [Extension
    types](../development/extending.html#extending-extension-types) for how to write
    your own extension that works with pandas. See [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html)
    for a list of third-party libraries that have implemented an extension.
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists all of pandas extension types. For methods requiring
    `dtype` arguments, strings can be specified as indicated. See the respective documentation
    sections for more on each type.
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind of Data | Data Type | Scalar | Array | String Aliases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [tz-aware datetime](timeseries.html#timeseries-timezone) | [`DatetimeTZDtype`](../reference/api/pandas.DatetimeTZDtype.html#pandas.DatetimeTZDtype
    "pandas.DatetimeTZDtype") | [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") | [`arrays.DatetimeArray`](../reference/api/pandas.arrays.DatetimeArray.html#pandas.arrays.DatetimeArray
    "pandas.arrays.DatetimeArray") | `''datetime64[ns, <tz>]''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Categorical](categorical.html#categorical) | [`CategoricalDtype`](../reference/api/pandas.CategoricalDtype.html#pandas.CategoricalDtype
    "pandas.CategoricalDtype") | (none) | [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") | `''category''` |'
  prefs: []
  type: TYPE_TB
- en: '| [period (time spans)](timeseries.html#timeseries-periods) | [`PeriodDtype`](../reference/api/pandas.PeriodDtype.html#pandas.PeriodDtype
    "pandas.PeriodDtype") | [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") | [`arrays.PeriodArray`](../reference/api/pandas.arrays.PeriodArray.html#pandas.arrays.PeriodArray
    "pandas.arrays.PeriodArray") `''Period[<freq>]''` | `''period[<freq>]''`, |'
  prefs: []
  type: TYPE_TB
- en: '| [sparse](sparse.html#sparse) | [`SparseDtype`](../reference/api/pandas.SparseDtype.html#pandas.SparseDtype
    "pandas.SparseDtype") | (none) | [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") | `''Sparse''`, `''Sparse[int]''`, `''Sparse[float]''`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [intervals](advanced.html#advanced-intervalindex) | [`IntervalDtype`](../reference/api/pandas.IntervalDtype.html#pandas.IntervalDtype
    "pandas.IntervalDtype") | [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval
    "pandas.Interval") | [`arrays.IntervalArray`](../reference/api/pandas.arrays.IntervalArray.html#pandas.arrays.IntervalArray
    "pandas.arrays.IntervalArray") | `''interval''`, `''Interval''`, `''Interval[<numpy_dtype>]''`,
    `''Interval[datetime64[ns, <tz>]]''`, `''Interval[timedelta64[<freq>]]''` |'
  prefs: []
  type: TYPE_TB
- en: '| [nullable integer](integer_na.html#integer-na) | [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype
    "pandas.Int64Dtype"), … | (none) | [`arrays.IntegerArray`](../reference/api/pandas.arrays.IntegerArray.html#pandas.arrays.IntegerArray
    "pandas.arrays.IntegerArray") | `''Int8''`, `''Int16''`, `''Int32''`, `''Int64''`,
    `''UInt8''`, `''UInt16''`, `''UInt32''`, `''UInt64''` |'
  prefs: []
  type: TYPE_TB
- en: '| [nullable float](../reference/arrays.html#api-arrays-float-na) | [`Float64Dtype`](../reference/api/pandas.Float64Dtype.html#pandas.Float64Dtype
    "pandas.Float64Dtype"), … | (none) | [`arrays.FloatingArray`](../reference/api/pandas.arrays.FloatingArray.html#pandas.arrays.FloatingArray
    "pandas.arrays.FloatingArray") | `''Float32''`, `''Float64''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Strings](text.html#text) | [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)") | [`arrays.StringArray`](../reference/api/pandas.arrays.StringArray.html#pandas.arrays.StringArray
    "pandas.arrays.StringArray") | `''string''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Boolean (with NA)](../reference/arrays.html#api-arrays-bool) | [`BooleanDtype`](../reference/api/pandas.BooleanDtype.html#pandas.BooleanDtype
    "pandas.BooleanDtype") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)") | [`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") | `''boolean''` |'
  prefs: []
  type: TYPE_TB
- en: pandas has two ways to store strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`object` dtype, which can hold any Python object, including strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"), which is dedicated to strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, we recommend using [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"). See [Text data types](text.html#text-types) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, arbitrary objects may be stored using the `object` dtype, but should
    be avoided to the extent possible (for performance and interoperability with other
    libraries and methods. See [object conversion](#basics-object-conversion)).
  prefs: []
  type: TYPE_NORMAL
- en: A convenient [`dtypes`](../reference/api/pandas.DataFrame.dtypes.html#pandas.DataFrame.dtypes
    "pandas.DataFrame.dtypes") attribute for DataFrame returns a Series with the data
    type of each column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: On a `Series` object, use the [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: If a pandas object contains data with multiple dtypes *in a single column*,
    the dtype of the column will be chosen to accommodate all of the data types (`object`
    is the most general).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The number of columns of each type in a `DataFrame` can be found by calling
    `DataFrame.dtypes.value_counts()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed
    (either directly via the `dtype` keyword, a passed `ndarray`, or a passed `Series`),
    then it will be preserved in DataFrame operations. Furthermore, different numeric
    dtypes will **NOT** be combined. The following example will give you a taste.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: upcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: astype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '### object conversion'
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: gotchas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: While float dtypes are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Selecting columns based on `dtype`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") method implements subsetting of columns based
    on their `dtype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with a slew of different dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'And the dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") has two parameters `include` and `exclude` that
    allow you to say “give me the columns *with* these dtypes” (`include`) and/or
    “give the columns *without* these dtypes” (`exclude`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select `bool` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass the name of a dtype in the [NumPy dtype hierarchy](https://numpy.org/doc/stable/reference/arrays.scalars.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") also works with generic dtypes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select all numeric and boolean columns while excluding unsigned
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'To select string columns you must use the `object` dtype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the child dtypes of a generic `dtype` like `numpy.number` you can
    define a function that returns a tree of child dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'All NumPy dtypes are subclasses of `numpy.generic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: pandas also defines the types `category`, and `datetime64[ns, tz]`, which are
    not integrated into the normal NumPy hierarchy and won’t show up with the above
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '## Head and tail'
  prefs: []
  type: TYPE_NORMAL
- en: To view a small sample of a Series or DataFrame object, use the [`head()`](../reference/api/pandas.DataFrame.head.html#pandas.DataFrame.head
    "pandas.DataFrame.head") and [`tail()`](../reference/api/pandas.DataFrame.tail.html#pandas.DataFrame.tail
    "pandas.DataFrame.tail") methods. The default number of elements to display is
    five, but you may pass a custom number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '## Attributes and underlying data'
  prefs: []
  type: TYPE_NORMAL
- en: pandas objects have a number of attributes enabling you to access the metadata
  prefs: []
  type: TYPE_NORMAL
- en: '**shape**: gives the axis dimensions of the object, consistent with ndarray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: *index* (only axis)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: *index* (rows) and *columns*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, **these attributes can be safely assigned to**!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: pandas objects ([`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index"),
    [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"))
    can be thought of as containers for arrays, which hold the actual data and do
    the actual computation. For many types, the underlying array is a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). However, pandas and 3rd party libraries may *extend* NumPy’s
    type system to add support for custom arrays (see [dtypes](#basics-dtypes)).
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual data inside a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use the `.array` property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[`array`](../reference/api/pandas.Series.array.html#pandas.Series.array "pandas.Series.array")
    will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). The exact details of what an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") is and why pandas uses them are a bit
    beyond the scope of this introduction. See [dtypes](#basics-dtypes) for more.'
  prefs: []
  type: TYPE_NORMAL
- en: If you know you need a NumPy array, use [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") or `numpy.asarray()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: When the Series or Index is backed by an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") may involve copying data and coercing values. See [dtypes](#basics-dtypes)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") gives some control over the `dtype` of the resulting
    [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). For example, consider datetimes with timezones. NumPy doesn’t
    have a dtype to represent timezone-aware datetimes, so there are two possibly
    useful representations:'
  prefs: []
  type: TYPE_NORMAL
- en: An object-dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)") with [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects, each with the correct `tz`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `datetime64[ns]` -dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"), where the values have been converted to UTC and the timezone
    discarded
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timezones may be preserved with `dtype=object`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Or thrown away with `dtype='datetime64[ns]'`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the “raw data” inside a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is possibly a bit more complex. When your `DataFrame` only
    has a single data type for all the columns, [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the underlying data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: If a DataFrame contains homogeneously-typed data, the ndarray can actually be
    modified in-place, and the changes will be reflected in the data structure. For
    heterogeneous data (e.g. some of the DataFrame’s columns are not all the same
    dtype), this will not be the case. The values attribute itself, unlike the axis
    labels, cannot be assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with heterogeneous data, the dtype of the resulting ndarray will
    be chosen to accommodate all of the data involved. For example, if strings are
    involved, the result will be of object dtype. If there are only floats and integers,
    the resulting array will be of float dtype.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, pandas recommended [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") or [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") for extracting the data from a Series or DataFrame.
    You’ll still find references to these in old code bases and online. Going forward,
    we recommend avoiding `.values` and using `.array` or `.to_numpy()`. `.values`
    has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: When your Series contains an [extension type](../development/extending.html#extending-extension-types),
    it’s unclear whether [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") returns a NumPy array or the extension array. [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always return an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), and will never copy data. [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will always return a NumPy array, potentially at the
    cost of copying / coercing values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your DataFrame contains a mixture of data types, [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") may involve copying data and coercing values to a common
    dtype, a relatively expensive operation. [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy"), being a method, makes it clearer that the returned
    NumPy array may not be a view on the same data in the DataFrame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '## Accelerated operations'
  prefs: []
  type: TYPE_NORMAL
- en: pandas has support for accelerating certain types of binary numerical and boolean
    operations using the `numexpr` library and the `bottleneck` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: These libraries are especially useful when dealing with large data sets, and
    provide large speedups. `numexpr` uses smart chunking, caching, and multiple cores.
    `bottleneck` is a set of specialized cython routines that are especially fast
    when dealing with arrays that have `nans`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample (using 100 column x 100,000 row `DataFrames`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | 0.11.0 (ms) | Prior Version (ms) | Ratio to Prior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 > df2` | 13.32 | 125.35 | 0.1063 |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 * df2` | 21.71 | 36.63 | 0.5928 |'
  prefs: []
  type: TYPE_TB
- en: '| `df1 + df2` | 22.04 | 36.50 | 0.6039 |'
  prefs: []
  type: TYPE_TB
- en: You are highly encouraged to install both libraries. See the section [Recommended
    Dependencies](../getting_started/install.html#install-recommended-dependencies)
    for more installation info.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are both enabled to be used by default, you can control this by setting
    the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '## Flexible binary operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'With binary operations between pandas data structures, there are two key points
    of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional
    (e.g. Series) objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data in computations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate how to manage these issues independently, though they can
    be handled simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Matching / broadcasting behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Missing data / operations with fill values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '### Flexible comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).  ###
    Boolean reductions'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: You can reduce to a final boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.  ###
    Comparing if objects are equivalent'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Comparing array-like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Combining overlapping data sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: General DataFrame combine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Matching / broadcasting behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Missing data / operations with fill values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '### Flexible comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).
  prefs: []
  type: TYPE_NORMAL
- en: '### Boolean reductions'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: You can reduce to a final boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '### Comparing if objects are equivalent'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Comparing array-like objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Combining overlapping data sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: General DataFrame combine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '## Descriptive statistics'
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a large number of methods for computing descriptive statistics
    and other related operations on [Series](../reference/series.html#api-series-stats),
    [DataFrame](../reference/frame.html#api-dataframe-stats). Most of these are aggregations
    (hence producing a lower-dimensional result) like [`sum()`](../reference/api/pandas.DataFrame.sum.html#pandas.DataFrame.sum
    "pandas.DataFrame.sum"), [`mean()`](../reference/api/pandas.DataFrame.mean.html#pandas.DataFrame.mean
    "pandas.DataFrame.mean"), and [`quantile()`](../reference/api/pandas.DataFrame.quantile.html#pandas.DataFrame.quantile
    "pandas.DataFrame.quantile"), but some of them, like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod"), produce an object of the same size. Generally speaking,
    these methods take an **axis** argument, just like *ndarray.{sum, std, …}*, but
    the axis can be specified by name or integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: no axis argument needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: “index” (axis=0, default), “columns” (axis=1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'All such methods have a `skipna` option signaling whether to exclude missing
    data (`True` by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Combined with the broadcasting / arithmetic behavior, one can describe various
    statistical procedures, like standardization (rendering data zero mean and standard
    deviation of 1), very concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Note that methods like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod") preserve the location of `NaN` values. This is somewhat
    different from [`expanding()`](../reference/api/pandas.DataFrame.expanding.html#pandas.DataFrame.expanding
    "pandas.DataFrame.expanding") and [`rolling()`](../reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling
    "pandas.DataFrame.rolling") since `NaN` behavior is furthermore dictated by a
    `min_periods` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Here is a quick reference summary table of common functions. Each also takes
    an optional `level` parameter which applies only if the object has a [hierarchical
    index](advanced.html#advanced-hierarchical).
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA observations |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of values |'
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of values |'
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median of values |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `mode` | Mode |'
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Absolute Value |'
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of values |'
  prefs: []
  type: TYPE_TB
- en: '| `std` | Bessel-corrected sample standard deviation |'
  prefs: []
  type: TYPE_TB
- en: '| `var` | Unbiased variance |'
  prefs: []
  type: TYPE_TB
- en: '| `sem` | Standard error of the mean |'
  prefs: []
  type: TYPE_TB
- en: '| `skew` | Sample skewness (3rd moment) |'
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | Sample kurtosis (4th moment) |'
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Sample quantile (value at %) |'
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum |'
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product |'
  prefs: []
  type: TYPE_TB
- en: '| `cummax` | Cumulative maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `cummin` | Cumulative minimum |'
  prefs: []
  type: TYPE_TB
- en: 'Note that by chance some NumPy methods, like `mean`, `std`, and `sum`, will
    exclude NAs on Series input by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series.nunique()`](../reference/api/pandas.Series.nunique.html#pandas.Series.nunique
    "pandas.Series.nunique") will return the number of unique non-NA values in a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '### Summarizing data: describe'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select specific percentiles to include in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: By default, the median is always included.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.  ### Index of min/max values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.  ### Value
    counts (histogramming) / mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Discretization and quantiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass infinite values to define the bins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '### Summarizing data: describe'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select specific percentiles to include in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: By default, the median is always included.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '### Index of min/max values'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Value counts (histogramming) / mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Discretization and quantiling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass infinite values to define the bins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '## Function application'
  prefs: []
  type: TYPE_NORMAL
- en: To apply your own or another library’s functions to pandas objects, you should
    be aware of the three methods below. The appropriate method to use depends on
    whether your function expects to operate on an entire `DataFrame` or `Series`,
    row- or column-wise, or elementwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tablewise Function Application](#tablewise-function-application): [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Row or Column-wise Function Application](#row-or-column-wise-function-application):
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Aggregation API](#aggregation-api): [`agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg") and [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Applying Elementwise Functions](#applying-elementwise-functions): [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '### Tablewise function application'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'Is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple functions yield multiple rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a named function will yield that name for the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '#### Custom describe'
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]  ### Transform API'
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Transform with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Transforming with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]  ### Applying elementwise functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]  ### Tablewise function application'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'Is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple functions yield multiple rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a named function will yield that name for the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '#### Custom describe'
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple functions yield multiple rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a named function will yield that name for the row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Aggregating with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '#### Custom describe'
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '### Transform API'
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Transform with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Transforming with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Transform with multiple functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Transforming with a dict
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '### Applying elementwise functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '## Reindexing and altering labels'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") is the fundamental data alignment method in pandas. It
    is used to implement nearly all other features relying on label-alignment functionality.
    To *reindex* means to conform the data to match a given set of labels along a
    particular axis. This accomplishes several things:'
  prefs: []
  type: TYPE_NORMAL
- en: Reorders the existing data to match a new set of labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts missing value (NA) markers in label locations where no data for that
    label existed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If specified, **fill** data for missing labels using logic (highly relevant
    to working with time series data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `f` label was not contained in the Series and hence appears as `NaN`
    in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, you can simultaneously reindex the index and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Index` objects containing the actual axis labels can be **shared**
    between objects. So if we have a Series and a DataFrame, the following can be
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: This means that the reindexed Series’s index is the same Python object as the
    DataFrame’s index.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") also supports an “axis-style” calling convention,
    where you specify a single `labels` argument and the `axis` it applies to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[MultiIndex / Advanced Indexing](advanced.html#advanced) is an even more concise
    way of doing reindexing.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing performance-sensitive code, there is a good reason to spend some
    time becoming a reindexing ninja: **many operations are faster on pre-aligned
    data**. Adding two unaligned DataFrames internally triggers a reindexing step.
    For exploratory analysis you will hardly notice the difference (because `reindex`
    has been heavily optimized), but when CPU cycles matter sprinkling a few explicit
    `reindex` calls here and there can have an impact.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Reindexing to align with another object'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]  ### Aligning objects with each other with `align`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]  ### Filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.  ###
    Limits on filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.  ### Dropping labels from an axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]  ### Renaming / mapping labels'
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]  ### Reindexing to align with another object'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '### Aligning objects with each other with `align`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '### Filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Limits on filling while reindexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.
  prefs: []
  type: TYPE_NORMAL
- en: '### Dropping labels from an axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '### Renaming / mapping labels'
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '## Iteration'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of basic iteration over pandas objects depends on the type. When
    iterating over a Series, it is regarded as array-like, and basic iteration produces
    the values. DataFrames follow the dict-like convention of iterating over the “keys”
    of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, basic iteration (`for i in object`) produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: column labels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, for example, iterating over a DataFrame gives you the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: pandas objects also have the dict-like [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") method to iterate over the (key, value) pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over the rows of a DataFrame, you can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"): Iterate over the rows of a DataFrame as (index,
    Series) pairs. This converts the rows to Series objects, which can change the
    dtypes and has some performance implications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples"): Iterate over the rows of a DataFrame as namedtuples
    of the values. This is a lot faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"), and is in most cases preferable to use to iterate
    over the values of a DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating through pandas objects is generally **slow**. In many cases, iterating
    manually over the rows is not needed and can be avoided with one of the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for a *vectorized* solution: many operations can be performed using built-in
    methods or NumPy functions, (boolean) indexing, …'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have a function that cannot work on the full DataFrame/Series at once,
    it is better to use [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") instead of iterating over the values. See the docs on
    [function application](#basics-apply).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to do iterative manipulations on the values but performance is important,
    consider writing the inner loop with cython or numba. See the [enhancing performance](enhancingperf.html#enhancingperf)
    section for some examples of this approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You should **never modify** something you are iterating over. This is not guaranteed
    to work in all cases. Depending on the data types, the iterator returns a copy
    and not a view, and writing to it will have no effect!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following case setting the value has no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '### iterrows'
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: itertuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.
  prefs: []
  type: TYPE_NORMAL
- en: items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '### iterrows'
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: itertuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '## .dt accessor'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has an accessor to succinctly return datetime like properties for
    the *values* of the Series, if it is a datetime/period like Series. This will
    return a Series, indexed like the existing Series.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables nice expressions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily produces tz aware transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also chain these types of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: You can also format datetime values as strings with [`Series.dt.strftime()`](../reference/api/pandas.Series.dt.strftime.html#pandas.Series.dt.strftime
    "pandas.Series.dt.strftime") which supports the same format as the standard [`strftime()`](https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime
    "(in Python v3.12)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: The `.dt` accessor works for period and timedelta dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Series.dt` will raise a `TypeError` if you access with a non-datetime-like
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized string methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Series is equipped with a set of string processing methods that make it easy
    to operate on each element of the array. Perhaps most importantly, these methods
    exclude missing/NA values automatically. These are accessed via the Series’s `str`
    attribute and generally have names matching the equivalent (scalar) built-in string
    methods. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Powerful pattern-matching methods are provided as well, but note that pattern-matching
    generally uses [regular expressions](https://docs.python.org/3/library/re.html)
    by default (and in some cases always uses them).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Prior to pandas 1.0, string methods were only available on `object` -dtype `Series`.
    pandas 1.0 added the [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") which is dedicated to strings. See [Text data types](text.html#text-types)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Vectorized String Methods](text.html#text-string-methods) for a
    complete description.
  prefs: []
  type: TYPE_NORMAL
- en: '## Sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas supports three kinds of sorting: sorting by index labels, sorting by
    column values, and sorting by a combination of both.'
  prefs: []
  type: TYPE_NORMAL
- en: '### By index'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'For information on key sorting by value, see [value sorting](#basics-sort-value-key).  ###
    By values'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'The `by` parameter can take a list of column names, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'The name or type of each column can be used to apply different functions to
    different columns.  ### By indexes and values'
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Sort by ‘second’ (index) and ‘A’ (column)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.  ### searchsorted'
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]  ### smallest / largest values'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]  ### Sorting by a MultiIndex column'
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]  ### By index'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: For information on key sorting by value, see [value sorting](#basics-sort-value-key).
  prefs: []
  type: TYPE_NORMAL
- en: '### By values'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The `by` parameter can take a list of column names, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: The name or type of each column can be used to apply different functions to
    different columns.
  prefs: []
  type: TYPE_NORMAL
- en: '### By indexes and values'
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Sort by ‘second’ (index) and ‘A’ (column)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '### searchsorted'
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '### smallest / largest values'
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '### Sorting by a MultiIndex column'
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Copying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method on pandas objects copies the underlying data (though
    not the axis indexes, since they are immutable) and returns a new object. Note
    that **it is seldom necessary to copy objects**. For example, there are only a
    handful of ways to alter a DataFrame *in-place*:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, deleting, or modifying a column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to the `index` or `columns` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For homogeneous data, directly modifying the values via the `values` attribute
    or advanced indexing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be clear, no pandas method has the side effect of modifying your data; almost
    every method returns a new object, leaving the original object untouched. If the
    data is modified, it is because you did so explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '## dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, pandas uses NumPy arrays and dtypes for Series or individual
    columns of a DataFrame. NumPy provides support for `float`, `int`, `bool`, `timedelta64[ns]`
    and `datetime64[ns]` (note that NumPy does not support timezone-aware datetimes).
  prefs: []
  type: TYPE_NORMAL
- en: pandas and third-party libraries *extend* NumPy’s type system in a few places.
    This section describes the extensions pandas has made internally. See [Extension
    types](../development/extending.html#extending-extension-types) for how to write
    your own extension that works with pandas. See [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html)
    for a list of third-party libraries that have implemented an extension.
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists all of pandas extension types. For methods requiring
    `dtype` arguments, strings can be specified as indicated. See the respective documentation
    sections for more on each type.
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind of Data | Data Type | Scalar | Array | String Aliases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [tz-aware datetime](timeseries.html#timeseries-timezone) | [`DatetimeTZDtype`](../reference/api/pandas.DatetimeTZDtype.html#pandas.DatetimeTZDtype
    "pandas.DatetimeTZDtype") | [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") | [`arrays.DatetimeArray`](../reference/api/pandas.arrays.DatetimeArray.html#pandas.arrays.DatetimeArray
    "pandas.arrays.DatetimeArray") | `''datetime64[ns, <tz>]''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Categorical](categorical.html#categorical) | [`CategoricalDtype`](../reference/api/pandas.CategoricalDtype.html#pandas.CategoricalDtype
    "pandas.CategoricalDtype") | (none) | [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") | `''category''` |'
  prefs: []
  type: TYPE_TB
- en: '| [period (time spans)](timeseries.html#timeseries-periods) | [`PeriodDtype`](../reference/api/pandas.PeriodDtype.html#pandas.PeriodDtype
    "pandas.PeriodDtype") | [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") | [`arrays.PeriodArray`](../reference/api/pandas.arrays.PeriodArray.html#pandas.arrays.PeriodArray
    "pandas.arrays.PeriodArray") `''Period[<freq>]''` | `''period[<freq>]''`, |'
  prefs: []
  type: TYPE_TB
- en: '| [sparse](sparse.html#sparse) | [`SparseDtype`](../reference/api/pandas.SparseDtype.html#pandas.SparseDtype
    "pandas.SparseDtype") | (none) | [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") | `''Sparse''`, `''Sparse[int]''`, `''Sparse[float]''`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [intervals](advanced.html#advanced-intervalindex) | [`IntervalDtype`](../reference/api/pandas.IntervalDtype.html#pandas.IntervalDtype
    "pandas.IntervalDtype") | [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval
    "pandas.Interval") | [`arrays.IntervalArray`](../reference/api/pandas.arrays.IntervalArray.html#pandas.arrays.IntervalArray
    "pandas.arrays.IntervalArray") | `''interval''`, `''Interval''`, `''Interval[<numpy_dtype>]''`,
    `''Interval[datetime64[ns, <tz>]]''`, `''Interval[timedelta64[<freq>]]''` |'
  prefs: []
  type: TYPE_TB
- en: '| [nullable integer](integer_na.html#integer-na) | [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype
    "pandas.Int64Dtype"), … | (none) | [`arrays.IntegerArray`](../reference/api/pandas.arrays.IntegerArray.html#pandas.arrays.IntegerArray
    "pandas.arrays.IntegerArray") | `''Int8''`, `''Int16''`, `''Int32''`, `''Int64''`,
    `''UInt8''`, `''UInt16''`, `''UInt32''`, `''UInt64''` |'
  prefs: []
  type: TYPE_TB
- en: '| [nullable float](../reference/arrays.html#api-arrays-float-na) | [`Float64Dtype`](../reference/api/pandas.Float64Dtype.html#pandas.Float64Dtype
    "pandas.Float64Dtype"), … | (none) | [`arrays.FloatingArray`](../reference/api/pandas.arrays.FloatingArray.html#pandas.arrays.FloatingArray
    "pandas.arrays.FloatingArray") | `''Float32''`, `''Float64''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Strings](text.html#text) | [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)") | [`arrays.StringArray`](../reference/api/pandas.arrays.StringArray.html#pandas.arrays.StringArray
    "pandas.arrays.StringArray") | `''string''` |'
  prefs: []
  type: TYPE_TB
- en: '| [Boolean (with NA)](../reference/arrays.html#api-arrays-bool) | [`BooleanDtype`](../reference/api/pandas.BooleanDtype.html#pandas.BooleanDtype
    "pandas.BooleanDtype") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)") | [`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") | `''boolean''` |'
  prefs: []
  type: TYPE_TB
- en: pandas has two ways to store strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`object` dtype, which can hold any Python object, including strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"), which is dedicated to strings.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, we recommend using [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"). See [Text data types](text.html#text-types) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, arbitrary objects may be stored using the `object` dtype, but should
    be avoided to the extent possible (for performance and interoperability with other
    libraries and methods. See [object conversion](#basics-object-conversion)).
  prefs: []
  type: TYPE_NORMAL
- en: A convenient [`dtypes`](../reference/api/pandas.DataFrame.dtypes.html#pandas.DataFrame.dtypes
    "pandas.DataFrame.dtypes") attribute for DataFrame returns a Series with the data
    type of each column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: On a `Series` object, use the [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype") attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: If a pandas object contains data with multiple dtypes *in a single column*,
    the dtype of the column will be chosen to accommodate all of the data types (`object`
    is the most general).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The number of columns of each type in a `DataFrame` can be found by calling
    `DataFrame.dtypes.value_counts()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed
    (either directly via the `dtype` keyword, a passed `ndarray`, or a passed `Series`),
    then it will be preserved in DataFrame operations. Furthermore, different numeric
    dtypes will **NOT** be combined. The following example will give you a taste.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: upcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: astype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '### object conversion'
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: gotchas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: While float dtypes are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: upcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: astype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '### object conversion'
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: gotchas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: While float dtypes are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: Selecting columns based on `dtype`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") method implements subsetting of columns based
    on their `dtype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with a slew of different dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: 'And the dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") has two parameters `include` and `exclude` that
    allow you to say “give me the columns *with* these dtypes” (`include`) and/or
    “give the columns *without* these dtypes” (`exclude`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select `bool` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass the name of a dtype in the [NumPy dtype hierarchy](https://numpy.org/doc/stable/reference/arrays.scalars.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") also works with generic dtypes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select all numeric and boolean columns while excluding unsigned
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: 'To select string columns you must use the `object` dtype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the child dtypes of a generic `dtype` like `numpy.number` you can
    define a function that returns a tree of child dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'All NumPy dtypes are subclasses of `numpy.generic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: pandas also defines the types `category`, and `datetime64[ns, tz]`, which are
    not integrated into the normal NumPy hierarchy and won’t show up with the above
    function.
  prefs: []
  type: TYPE_NORMAL
