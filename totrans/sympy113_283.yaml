- en: AGCA - Algebraic Geometry and Commutative Algebra Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/polys/agca.html](https://docs.sympy.org/latest/modules/polys/agca.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic geometry is a mixture of the ideas of two Mediterranean cultures.
    It is the superposition of the Arab science of the lightening calculation of the
    solutions of equations over the Greek art of position and shape. This tapestry
    was originally woven on European soil and is still being refined under the influence
    of international fashion. Algebraic geometry studies the delicate balance between
    the geometrically plausible and the algebraically possible. Whenever one side
    of this mathematical teeter-totter outweighs the other, one immediately loses
    interest and runs off in search of a more exciting amusement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —George R. Kempf (1944 – 2002)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Algebraic Geometry refers to the study of geometric problems via algebraic methods
    (and sometimes vice versa). While this is a rather old topic, algebraic geometry
    as understood today is very much a 20th century development. Building on ideas
    of e.g. Riemann and Dedekind, it was realized that there is an intimate connection
    between properties of the set of solutions of a system of polynomial equations
    (called an algebraic variety) and the behavior of the set of polynomial functions
    on that variety (called the coordinate ring).
  prefs: []
  type: TYPE_NORMAL
- en: As in many geometric disciplines, we can distinguish between local and global
    questions (and methods). Local investigations in algebraic geometry are essentially
    equivalent to the study of certain rings, their ideals and modules. This latter
    topic is also called commutative algebra. It is the basic local toolset of algebraic
    geometers, in much the same way that differential analysis is the local toolset
    of differential geometers.
  prefs: []
  type: TYPE_NORMAL
- en: A good conceptual introduction to commutative algebra is [[Atiyah69]](literature.html#atiyah69).
    An introduction more geared towards computations, and the work most of the algorithms
    in this module are based on, is [[Greuel2008]](literature.html#greuel2008).
  prefs: []
  type: TYPE_NORMAL
- en: This module aims to eventually allow expression and solution of both local and
    global geometric problems, both in the classical case over a field and in the
    more modern arithmetic cases. So far, however, there is no geometric functionality
    at all. Currently the module only provides tools for computational commutative
    algebra over fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'All code examples assume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we document the usage of the AGCA module. For convenience of
    the reader, some definitions and examples/explanations are interspersed.
  prefs: []
  type: TYPE_NORMAL
- en: Base Rings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost all computations in commutative algebra are relative to a “base ring”.
    (For example, when asking questions about an ideal, the base ring is the ring
    the ideal is a subset of.) In principle all polys “domains” can be used as base
    rings. However, useful functionality is only implemented for polynomial rings
    over fields, and various localizations and quotients thereof.
  prefs: []
  type: TYPE_NORMAL
- en: 'As demonstrated in the examples below, the most convenient method to create
    objects you are interested in is to build them up from the ground field, and then
    use the various methods to create new objects from old. For example, in order
    to create the local ring of the nodal cubic \(y^2 = x^3\) at the origin, over
    \(\mathbb{Q}\), you do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the python list notation can be used as a short cut to express ideals.
    You can use the `convert` method to return ordinary sympy objects into objects
    understood by the AGCA module (although in many cases this will be done automatically
    – for example the list was automatically turned into an ideal, and in the process
    the symbols \(x\) and \(y\) were automatically converted into other representations).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When no localisation is needed, a more mathematical notation can be used. For
    example, let us create the coordinate ring of three-dimensional affine space \(\mathbb{A}^3\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more details, refer to the following class documentation. Note that the
    base rings, being domains, are the main point of overlap between the AGCA module
    and the rest of the polys module. All domains are documented in detail in the
    polys reference, so we show here only an abridged version, with the methods most
    pertinent to the AGCA module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Represents a ring domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Generate a free module of rank `rank` over self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Generate an ideal of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Form a quotient ring of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `e` can be an ideal or an iterable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The division operator has been overloaded for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A class for representing multivariate polynomial rings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Class representing (commutative) quotient rings.
  prefs: []
  type: TYPE_NORMAL
- en: You should not usually instantiate this by hand, instead use the constructor
    from the base ring in the construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Shorter versions are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: ring - the base ring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: base_ideal - the ideal used to form the quotient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules, Ideals and their Elementary Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let \(A\) be a ring. An \(A\)-module is a set \(M\), together with two binary
    operations \(+: M \times M \to M\) and \(\times: R \times M \to M\) called addition
    and scalar multiplication. These are required to satisfy certain axioms, which
    can be found in e.g. [[Atiyah69]](literature.html#atiyah69). In this way modules
    are a direct generalisation of both vector spaces (\(A\) being a field) and abelian
    groups (\(A = \mathbb{Z}\)). A *submodule* of the \(A\)-module \(M\) is a subset
    \(N \subset M\), such that the binary operations restrict to \(N\), and \(N\)
    becomes an \(A\)-module with these operations.'
  prefs: []
  type: TYPE_NORMAL
- en: The ring \(A\) itself has a natural \(A\)-module structure where addition and
    multiplication in the module coincide with addition and multiplication in the
    ring. This \(A\)-module is also written as \(A\). An \(A\)-submodule of \(A\)
    is called an *ideal* of \(A\). Ideals come up very naturally in algebraic geometry.
    More general modules can be seen as a technically convenient “elbow room” beyond
    talking only about ideals.
  prefs: []
  type: TYPE_NORMAL
- en: 'If \(M\), \(N\) are \(A\)-modules, then there is a natural (componentwise)
    \(A\)-module structure on \(M \times N\). Similarly there are \(A\)-module structures
    on cartesian products of more components. (For the categorically inclined: the
    cartesian product of finitely many \(A\)-modules, with this \(A\)-module structure,
    is the finite biproduct in the category of all \(A\)-modules. With infinitely
    many components, it is the direct product (but the infinite direct sum has to
    be constructed differently).) As usual, repeated product of the \(A\)-module \(M\)
    is denoted \(M, M^2, M^3 \ldots\), or \(M^I\) for arbitrary index sets \(I\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An \(A\)-module \(M\) is called *free* if it is isomorphic to the \(A\)-module
    \(A^I\) for some (not necessarily finite) index set \(I\) (refer to the next section
    for a definition of isomorphism). The cardinality of \(I\) is called the *rank*
    of \(M\); one may prove this is well-defined. In general, the AGCA module only
    works with free modules of finite rank, and other closely related modules. The
    easiest way to create modules is to use member methods of the objects they are
    made up from. For example, let us create a free module of rank 4 over the coordinate
    ring of \(\mathbb{A}^2\) we created above, together with a submodule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note how python lists can be used as a short-cut notation for module elements
    (vectors). As usual, the `convert` method can be used to convert sympy/python
    objects into the internal AGCA representation (see detailed reference below).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the detailed documentation of the classes for modules, free modules,
    and submodules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class for modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not instantiate - use ring explicit constructors instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: dtype - type of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ring - containing ring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-implemented methods:'
  prefs: []
  type: TYPE_NORMAL
- en: submodule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: quotient_module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_submodule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multiply_ideal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method convert likely needs to be changed in subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `elem` is an element of this module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Convert `elem` into internal representation of this module.
  prefs: []
  type: TYPE_NORMAL
- en: If `M` is not None, it should be a module containing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Return the identity homomorphism on `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `other` is a submodule of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `self` is a zero module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Multiply `self` by the ideal `other`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Generate a quotient module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generate a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `other` is is a subset of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class for free modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: rank - rank of the free module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-implemented methods:'
  prefs: []
  type: TYPE_NORMAL
- en: submodule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Return a set of basis elements.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Convert `elem` into the internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called implicitly whenever computations involve elements not
    in the internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`FreeModuleElement`](#sympy.polys.agca.modules.FreeModuleElement "sympy.polys.agca.modules.FreeModuleElement")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return the identity homomorphism on `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `other` is a submodule of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `self` is a zero module.
  prefs: []
  type: TYPE_NORMAL
- en: (If, as this implementation assumes, the coefficient ring is not the zero ring,
    then this is equivalent to the rank being zero.)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Multiply `self` by the ideal `other`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Return a quotient module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or more conicisely, using the overloaded division operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Element of a free module. Data stored as a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Base class for submodules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: container - containing module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gens - generators (subset of containing module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rank - rank of containing module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-implemented methods:'
  prefs: []
  type: TYPE_NORMAL
- en: _contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _syzygies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _in_terms_of_generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _intersect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _module_quotient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that likely need change in subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: reduce_element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Convert `elem` into the internal represantition.
  prefs: []
  type: TYPE_NORMAL
- en: Mostly called implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Return the identity homomorphism on `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Express element `e` of `self` in terms of the generators.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Return a homomorphism representing the inclusion map of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, the natural map from `self` to `self.container`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Returns the intersection of `self` with submodule `other`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Some implementation allow further options to be passed. Currently, to only one
    implemented is `relations=True`, in which case the function will return a triple
    `(res, rela, relb)`, where `res` is the intersection module, and `rela` and `relb`
    are lists of coefficient vectors, expressing the generators of `res` in terms
    of the generators of `self` (`rela`) and `other` (`relb`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The above result says: the intersection module is generated by the single element
    \((-xy, -xy) = -y (x, x) = -x (y, y)\), where \((x, x)\) and \((y, y)\) respectively
    are the unique generators of the two modules being intersected.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is the entire free module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `other` is a submodule of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a zero module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Returns the module quotient of `self` by submodule `other`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, if `self` is the module \(M\) and `other` is \(N\), then return the
    ideal \(\{f \in R | fN \subset M\}\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Some implementations allow further options to be passed. Currently, the only
    one implemented is `relations=True`, which may only be passed if `other` is principal.
    In this case the function will return a pair `(res, rel)` where `res` is the ideal,
    and `rel` is a list of coefficient vectors, expressing the generators of the ideal,
    multiplied by the generator of `other` in terms of generators of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This means that the quotient ideal is generated by the single element \(y\),
    and that \(y (x, x) = 1 (xy, xy)\), \((x, x)\) and \((xy, xy)\) being the generators
    of \(T\) and \(S\), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Multiply `self` by the ideal `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Return a quotient module.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as taking a submodule of a quotient of the containing module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or more coincisely, using the overloaded division operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Reduce the element `x` of our ring modulo the ideal `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Here “reduce” has no specific meaning, it could return a unique normal form,
    simplify the expression a bit, or just do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Generate a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Compute the syzygy module of the generators of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose \(M\) is generated by \(f_1, \ldots, f_n\) over the ring \(R\). Consider
    the homomorphism \(\phi: R^n \to M\), given by sending \((r_1, \ldots, r_n) \to
    r_1 f_1 + \cdots + r_n f_n\). The syzygy module is defined to be the kernel of
    \(\phi\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'The syzygy module is zero iff the generators generate freely a free submodule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly more interesting example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Returns the module generated by the union of `self` and `other`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideals are created very similarly to modules. For example, let’s verify that
    the nodal cubic is indeed singular at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We are using here the fact that a curve is non-singular at a point if and only
    if the maximal ideal of the local ring is principal, and that in this case at
    least one of \(x\) and \(y\) must be generators.
  prefs: []
  type: TYPE_NORMAL
- en: This is the detailed documentation of the class ideal. Please note that most
    of the methods regarding properties of ideals (primality etc.) are not yet implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class for ideals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not instantiate - use explicit constructors in the ring class instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: ring - the ring this ideal belongs to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-implemented methods:'
  prefs: []
  type: TYPE_NORMAL
- en: _contains_elem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _contains_ideal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _quotient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _intersect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _union
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_whole_ring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_prime, is_maximal, is_primary, is_radical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: is_principal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: height, depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: radical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that likely should be overridden in subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: reduce_element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `elem` is an element of this ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Compute the depth of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Compute the height of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Compute the intersection of self with ideal J.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a maximal ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a primary ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a principal ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a radical ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is the whole ring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is the zero ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Compute the ideal product of `self` and `J`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, compute the ideal generated by products \(xy\), for \(x\) an element
    of `self` and \(y \in J\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Compute the ideal quotient of `self` by `J`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, if `self` is the ideal \(I\), compute the set \(I : J = \{x \in R
    | xJ \subset I \}\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Compute the radical of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Reduce the element `x` of our ring modulo the ideal `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here “reduce” has no specific meaning: it could return a unique normal form,
    simplify the expression a bit, or just do nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Compute the ideal saturation of `self` by `J`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, if `self` is the ideal \(I\), compute the set \(I : J^\infty = \{x
    \in R | xJ^n \subset I \text{ for some } n\}\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `other` is is a subset of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `other` may be an ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Compute the ideal generated by the union of `self` and `J`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If \(M\) is an \(A\)-module and \(N\) is an \(A\)-submodule, we can define
    two elements \(x\) and \(y\) of \(M\) to be equivalent if \(x - y \in N\). The
    set of equivalence classes is written \(M/N\), and has a natural \(A\)-module
    structure. This is called the quotient module of \(M\) by \(N\). If \(K\) is a
    submodule of \(M\) containing \(N\), then \(K/N\) is in a natural way a submodule
    of \(M/N\). Such a module is called a subquotient. Here is the documentation of
    quotient and subquotient modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Class for quotient modules.
  prefs: []
  type: TYPE_NORMAL
- en: Do not instantiate this directly. For subquotients, see the SubQuotientModule
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: base - the base module we are a quotient of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: killed_module - the submodule used to form the quotient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rank of the base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Convert `elem` into the internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called implicitly whenever computations involve elements not
    in the internal representation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`QuotientModuleElement`](#sympy.polys.agca.modules.QuotientModuleElement
    "sympy.polys.agca.modules.QuotientModuleElement")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Return the identity homomorphism on `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `other` is a submodule of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a zero module.
  prefs: []
  type: TYPE_NORMAL
- en: This happens if and only if the base module is the same as the submodule being
    killed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Return the quotient homomorphism to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, return a homomorphism representing the natural map from `self.base`
    to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Generate a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as taking a quotient of a submodule of the base module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Element of a quotient module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Equality comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Submodule of a quotient module.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalently, quotient module of a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not instantiate this, instead use the submodule or quotient_module constructing
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: base - base module we are quotient of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: killed_module - submodule used to form the quotient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is the entire free module.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Return the quotient homomorphism to self.
  prefs: []
  type: TYPE_NORMAL
- en: That is, return the natural map from `self.base` to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Module Homomorphisms and Syzygies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let \(M\) and \(N\) be \(A\)-modules. A mapping \(f: M \to N\) satisfying various
    obvious properties (see [[Atiyah69]](literature.html#atiyah69)) is called an \(A\)-module
    homomorphism. In this case \(M\) is called the *domain* and *N* the *codomain*.
    The set \(\{x \in M | f(x) = 0\}\) is called the *kernel* \(ker(f)\), whereas
    the set \(\{f(x) | x \in M\}\) is called the *image* \(im(f)\). The kernel is
    a submodule of \(M\), the image is a submodule of \(N\). The homomorphism \(f\)
    is injective if and only if \(ker(f) = 0\) and surjective if and only if \(im(f)
    = N\). A bijective homomorphism is called an *isomorphism*. Equivalently, \(ker(f)
    = 0\) and \(im(f) = N\). (A related notion, which currently has no special name
    in the AGCA module, is that of the *cokernel*, \(coker(f) = N/im(f)\).)'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose now \(M\) is an \(A\)-module. \(M\) is called *finitely generated* if
    there exists a surjective homomorphism \(A^n \to M\) for some \(n\). If such a
    morphism \(f\) is chosen, the images of the standard basis of \(A^n\) are called
    the *generators* of \(M\). The module \(ker(f)\) is called *syzygy module* with
    respect to the generators. A module is called *finitely presented* if it is finitely
    generated with a finitely generated syzygy module. The class of finitely presented
    modules is essentially the largest class we can hope to be able to meaningfully
    compute in.
  prefs: []
  type: TYPE_NORMAL
- en: It is an important theorem that, for all the rings we are considering, all submodules
    of finitely generated modules are finitely generated, and hence finitely generated
    and finitely presented modules are the same.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of syzygies, while it may first seem rather abstract, is actually
    very computational. This is because there exist (fairly easy) algorithms for computing
    them, and more general questions (kernels, intersections, …) are often reduced
    to syzygy computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us say a few words about the definition of homomorphisms in the AGCA module.
    Suppose first that \(f : M \to N\) is an arbitrary morphism of \(A\)-modules.
    Then if \(K\) is a submodule of \(M\), \(f\) naturally defines a new homomorphism
    \(g: K \to N\) (via \(g(x) = f(x)\)), called the *restriction* of \(f\) to \(K\).
    If now \(K\) contained in the kernel of \(f\), then moreover \(f\) defines in
    a natural homomorphism \(g: M/K \to N\) (same formula as above!), and we say that
    \(f\) *descends* to \(M/K\). Similarly, if \(L\) is a submodule of \(N\), there
    is a natural homomorphism \(g: M \to N/L\), we say that \(g\) *factors* through
    \(f\). Finally, if now \(L\) contains the image of \(f\), then there is a natural
    homomorphism \(g: M \to L\) (defined, again, by the same formula), and we say
    \(g\) is obtained from \(f\) by restriction of codomain. Observe also that each
    of these four operations is reversible, in the sense that given \(g\), one can
    always (non-uniquely) find \(f\) such that \(g\) is obtained from \(f\) in the
    above way.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all modules implemented in AGCA are obtained from free modules by
    taking a succession of submodules and quotients. Hence, in order to explain how
    to define a homomorphism between arbitrary modules, in light of the above, we
    need only explain how to define homomorphisms of free modules. But, essentially
    by the definition of free module, a homomorphism from a free module \(A^n\) to
    any module \(M\) is precisely the same as giving \(n\) elements of \(M\) (the
    images of the standard basis), and giving an element of a free module \(A^m\)
    is precisely the same as giving \(m\) elements of \(A\). Hence a homomorphism
    of free modules \(A^n \to A^m\) can be specified via a matrix, entirely analogously
    to the case of vector spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The functions `restrict_domain` etc. of the class `Homomorphism` can be used
    to carry out the operations described above, and homomorphisms of free modules
    can in principle be instantiated by hand. Since these operations are so common,
    there is a convenience function `homomorphism` to define a homomorphism between
    arbitrary modules via the method outlined above. It is essentially the only way
    homomorphisms need ever be created by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Create a homomorphism object.
  prefs: []
  type: TYPE_NORMAL
- en: This function tries to build a homomorphism from `domain` to `codomain` via
    the matrix `matrix`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: If `domain` is a free module generated by \(e_1, \ldots, e_n\), then `matrix`
    should be an n-element iterable \((b_1, \ldots, b_n)\) where the \(b_i\) are elements
    of `codomain`. The constructed homomorphism is the unique homomorphism sending
    \(e_i\) to \(b_i\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: If `domain` is a submodule of a free module, them `matrix` determines a homomoprhism
    from the containing free module to `codomain`, and the homomorphism returned is
    obtained by restriction to `domain`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: If `domain` is a (sub)quotient \(N/K\), then `matrix` determines a homomorphism
    from \(N\) to `codomain`. If the kernel contains \(K\), this homomorphism descends
    to `domain` and is returned; otherwise an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here is the detailed reference of the actual homomorphism class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Abstract base class for module homomoprhisms. Do not instantiate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use the `homomorphism` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: ring - the ring over which we are considering modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: domain - the domain module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: codomain - the codomain module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _ker - cached kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _img - cached image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-implemented methods:'
  prefs: []
  type: TYPE_NORMAL
- en: _kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _restrict_domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _restrict_codomain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _quotient_domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _quotient_codomain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _mul_scalar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: _add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Compute the image of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, if `self` is the homomorphism \(\phi: M \to N\), then compute \(im(\phi)
    = \{\phi(x) | x \in M \}\). This is a submodule of \(N\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is injective.
  prefs: []
  type: TYPE_NORMAL
- en: That is, check if the elements of the domain are mapped to the same codomain
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is an isomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: That is, check if every element of the codomain has precisely one preimage.
    Equivalently, `self` is both injective and surjective.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is surjective.
  prefs: []
  type: TYPE_NORMAL
- en: That is, check if every element of the codomain has at least one preimage.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Return True if `self` is a zero morphism.
  prefs: []
  type: TYPE_NORMAL
- en: That is, check if every element of the domain is mapped to zero under self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Compute the kernel of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, if `self` is the homomorphism \(\phi: M \to N\), then compute \(ker(\phi)
    = \{x \in M | \phi(x) = 0\}\). This is a submodule of \(M\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Return `self` with codomain replaced by `codomain/sm`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `sm` must be a submodule of `self.codomain`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as composing with the quotient map on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Return `self` with domain replaced by `domain/sm`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `sm` must be a submodule of `self.kernel()`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Return `self`, with codomain restricted to to `sm`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `sm` has to be a submodule of `self.codomain` containing the image.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Return `self`, with the domain restricted to `sm`.
  prefs: []
  type: TYPE_NORMAL
- en: Here `sm` has to be a submodule of `self.domain`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as just composing on the right with the submodule inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Finite Extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let \(A\) be a (commutative) ring and \(B\) an extension ring of \(A\). An element
    \(t\) of \(B\) is a generator of \(B\) (over \(A\)) if all elements of \(B\) can
    be represented as polynomials in \(t\) with coefficients in \(A\). The representation
    is unique if and only if \(t\) satisfies no non-trivial polynomial relation, in
    which case \(B\) can be identified with a (univariate) polynomial ring over \(A\).
  prefs: []
  type: TYPE_NORMAL
- en: The polynomials having \(t\) as a root form a non-zero ideal in general. The
    most important case in practice is that of an ideal generated by a single monic
    polynomial. If \(t\) satisfies such a polynomial relation, then its highest power
    \(t^n\) can be written as linear combination of lower powers. It follows, inductively,
    that all higher powers of \(t\) also have such a representation. Hence the lower
    powers \(t^i\) (\(i = 0, \dots, n-1\)) form a basis of \(B\), which is then called
    a finite extension of \(A\), or, more precisely, a monogenic finite extension
    as it is generated by a single element \(t\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Finite extension generated by an integral element.
  prefs: []
  type: TYPE_NORMAL
- en: The generator is defined by a monic univariate polynomial derived from the argument
    `mod`.
  prefs: []
  type: TYPE_NORMAL
- en: A shorter alias is `FiniteExtension`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Quadratic integer ring \(\mathbb{Z}[\sqrt2]\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Finite field \(GF(5^3)\) defined by the primitive polynomial \(x^3 + x^2 + 2\)
    (over \(\mathbb{Z}_5\)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Function field of an elliptic curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`ExtensionElement`](#sympy.polys.agca.extensions.ExtensionElement
    "sympy.polys.agca.extensions.ExtensionElement")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Element of a finite extension.
  prefs: []
  type: TYPE_NORMAL
- en: A class of univariate polynomials modulo the `modulus` of the extension `ext`.
    It is represented by the unique polynomial `rep` of lowest degree. Both `rep`
    and the representation `mod` of `modulus` are of class DMP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Multiplicative inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotInvertible**'
  prefs: []
  type: TYPE_NORMAL
- en: If the element is a zero divisor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
