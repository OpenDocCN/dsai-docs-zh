- en: NumPy for MATLAB users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html](https://numpy.org/doc/1.26/user/numpy-for-matlab-users.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Some key differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  prefs: []
  type: TYPE_TB
- en: Rough equivalents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  prefs: []
  type: TYPE_NORMAL
- en: General purpose equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  prefs: []
  type: TYPE_TB
- en: '## Notes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: ‘array’ or ‘matrix’? Which should I use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy, or rather Python, has similar facilities.
  prefs: []
  type: TYPE_NORMAL
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  prefs: []
  type: TYPE_NORMAL
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  prefs: []
  type: TYPE_NORMAL
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MATLAB® and NumPy have a lot in common, but NumPy was created to work with Python,
    not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: Some key differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| In MATLAB, the basic type, even for scalars, is a multidimensional array.
    Array assignments in MATLAB are stored as 2D arrays of double precision floating
    point numbers, unless you specify the number of dimensions and type. Operations
    on the 2D instances of these arrays are modeled on matrix operations in linear
    algebra. | In NumPy, the basic type is a multidimensional `array`. Array assignments
    in NumPy are usually stored as [n-dimensional arrays](../reference/arrays.html#arrays)
    with the minimum type required to hold the objects in sequence, unless you specify
    the number of dimensions and type. NumPy performs operations element-by-element,
    so multiplying 2D arrays with `*` is not a matrix multiplication – it’s an element-by-element
    multiplication. (The `@` operator, available since Python 3.5, can be used for
    conventional matrix multiplication.) |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB numbers indices from 1; `a(1)` is the first element. [See note INDEXING](#numpy-for-matlab-users-notes)
    | NumPy, like Python, numbers indices from 0; `a[0]` is the first element. |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB’s scripting language was created for linear algebra so the syntax
    for some array manipulations is more compact than NumPy’s. On the other hand,
    the API for adding GUIs and creating full-fledged applications is more or less
    an afterthought. | NumPy is based on Python, a general-purpose language. The advantage
    to NumPy is access to Python libraries including: [SciPy](https://www.scipy.org/),
    [Matplotlib](https://matplotlib.org/), [Pandas](https://pandas.pydata.org/), [OpenCV](https://opencv.org/),
    and more. In addition, Python is often [embedded as a scripting language](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    in other software, allowing NumPy to be used there too. |'
  prefs: []
  type: TYPE_TB
- en: '| MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write
    scheme to prevent creating copies until they are needed. Slicing operations copy
    parts of the array. | NumPy array slicing uses pass-by-reference, that does not
    copy the arguments. Slicing operations are views into an array. |'
  prefs: []
  type: TYPE_TB
- en: Rough equivalents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The table below gives rough equivalents for some common MATLAB expressions.
    These are similar expressions, not equivalents. For details, see the [documentation](../reference/index.html#reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the table below, it is assumed that you have executed the following commands
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Also assume below that if the Notes talk about “matrix” that the arguments are
    two-dimensional entities.
  prefs: []
  type: TYPE_NORMAL
- en: General purpose equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  prefs: []
  type: TYPE_TB
- en: General purpose equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `help func` | `info(func)` or `help(func)` or `func?` (in IPython) | get
    help on the function *func* |'
  prefs: []
  type: TYPE_TB
- en: '| `which func` | [see note HELP](#numpy-for-matlab-users-notes) | find out
    where *func* is defined |'
  prefs: []
  type: TYPE_TB
- en: '| `type func` | `np.source(func)` or `func??` (in IPython) | print source for
    *func* (if not a native function) |'
  prefs: []
  type: TYPE_TB
- en: '| `% comment` | `# comment` | comment a line of code with the text `comment`
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| use a for-loop to print the numbers 1, 2, and 3 using [`range`](https://docs.python.org/3/library/stdtypes.html#range
    "(in Python v3.11)") |'
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | `a and b` | short-circuiting logical AND operator ([Python native
    operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in Python
    v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | `a or b` | short-circuiting logical OR operator ([Python
    native operator](https://docs.python.org/3/library/stdtypes.html#boolean "(in
    Python v3.11)")); scalar arguments only |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| The [boolean objects](https://docs.python.org/3/library/stdtypes.html#bltin-boolean-values
    "(in Python v3.11)") in Python are `True` and `False`, as opposed to MATLAB logical
    types of `1` and `0`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| create an if-else statement to check if `a` is 4 or 5 and print result |'
  prefs: []
  type: TYPE_TB
- en: '| `1*i`, `1*j`, `1i`, `1j` | `1j` | complex numbers |'
  prefs: []
  type: TYPE_TB
- en: '| `eps` | `np.finfo(float).eps` or `np.spacing(1)` | distance from 1 to the
    next larger representable real number in double precision |'
  prefs: []
  type: TYPE_TB
- en: '| `load data.mat` | `io.loadmat(''data.mat'')` | Load MATLAB variables saved
    to the file `data.mat`. (Note: When saving arrays to `data.mat` in MATLAB/Octave,
    use a recent binary format. [`scipy.io.loadmat`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat
    "(in SciPy v1.11.2)") will create a dictionary with the saved arrays and further
    information.) |'
  prefs: []
  type: TYPE_TB
- en: '| `ode45` | `integrate.solve_ivp(f)` | integrate an ODE with Runge-Kutta 4,5
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ode15s` | `integrate.solve_ivp(f, method=''BDF'')` | integrate an ODE with
    BDF method |'
  prefs: []
  type: TYPE_TB
- en: Linear algebra equivalents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| MATLAB | NumPy | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ndims(a)` | `np.ndim(a)` or `a.ndim` | number of dimensions of array `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `numel(a)` | `np.size(a)` or `a.size` | number of elements of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a)` | `np.shape(a)` or `a.shape` | “size” of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `size(a,n)` | `a.shape[n-1]` | get the number of elements of the n-th dimension
    of array `a`. (Note that MATLAB uses 1 based indexing while Python uses 0 based
    indexing, See note [INDEXING](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[ 1 2 3; 4 5 6 ]` | `np.array([[1., 2., 3.], [4., 5., 6.]])` | define a
    2x3 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[ a b; c d ]` | `np.block([[a, b], [c, d]])` | construct a matrix from blocks
    `a`, `b`, `c`, and `d` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end)` | `a[-1]` | access last element in MATLAB vector (1xn or nx1) or
    1D NumPy array `a` (length n) |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,5)` | `a[1, 4]` | access element in second row, fifth column in 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(2,:)` | `a[1]` or `a[1, :]` | entire second row of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:5,:)` | `a[0:5]` or `a[:5]` or `a[0:5, :]` | first 5 rows of 2D array
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end-4:end,:)` | `a[-5:]` | last 5 rows of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:3,5:9)` | `a[0:3, 4:9]` | The first through third rows and fifth through
    ninth columns of a 2D array, `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a([2,4,5],[1,3])` | `a[np.ix_([1, 3, 4], [0, 2])]` | rows 2,4 and 5 and
    columns 1 and 3\. This allows the matrix to be modified, and doesn’t require a
    regular slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `a(3:2:21,:)` | `a[2:21:2,:]` | every other row of `a`, starting with the
    third and going to the twenty-first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(1:2:end,:)` | `a[::2, :]` | every other row of `a`, starting with the
    first |'
  prefs: []
  type: TYPE_TB
- en: '| `a(end:-1:1,:)` or `flipud(a)` | `a[::-1,:]` | `a` with rows in reverse order
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a([1:end 1],:)` | `a[np.r_[:len(a),0]]` | `a` with copy of the first row
    appended to the end |'
  prefs: []
  type: TYPE_TB
- en: '| `a.''` | `a.transpose()` or `a.T` | transpose of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a''` | `a.conj().transpose()` or `a.conj().T` | conjugate transpose of `a`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | `a @ b` | matrix multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* b` | `a * b` | element-wise multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `a./b` | `a/b` | element-wise divide |'
  prefs: []
  type: TYPE_TB
- en: '| `a.^3` | `a**3` | element-wise exponentiation |'
  prefs: []
  type: TYPE_TB
- en: '| `(a > 0.5)` | `(a > 0.5)` | matrix whose i,jth element is (a_ij > 0.5). The
    MATLAB result is an array of logical values 0 and 1\. The NumPy result is an array
    of the boolean values `False` and `True`. |'
  prefs: []
  type: TYPE_TB
- en: '| `find(a > 0.5)` | `np.nonzero(a > 0.5)` | find the indices where (`a` > 0.5)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v > 0.5))` | `a[:,np.nonzero(v > 0.5)[0]]` | extract the columns
    of `a` where vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:,find(v>0.5))` | `a[:, v.T > 0.5]` | extract the columns of `a` where
    column vector v > 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| `a(a<0.5)=0` | `a[a < 0.5]=0` | `a` with elements less than 0.5 zeroed out
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a .* (a>0.5)` | `a * (a > 0.5)` | `a` with elements less than 0.5 zeroed
    out |'
  prefs: []
  type: TYPE_TB
- en: '| `a(:) = 3` | `a[:] = 3` | set all values to the same scalar value |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x` | `y = x.copy()` | NumPy assigns by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(2,:)` | `y = x[1, :].copy()` | NumPy slices are by reference |'
  prefs: []
  type: TYPE_TB
- en: '| `y=x(:)` | `y = x.flatten()` | turn array into vector (note that this forces
    a copy). To obtain the same data ordering as in MATLAB, use `x.flatten(''F'')`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `1:10` | `np.arange(1., 11.)` or `np.r_[1.:11.]` or `np.r_[1:10:10j]` | create
    an increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `0:9` | `np.arange(10.)` or `np.r_[:10.]` or `np.r_[:9:10j]` | create an
    increasing vector (see note [RANGES](#numpy-for-matlab-users-notes)) |'
  prefs: []
  type: TYPE_TB
- en: '| `[1:10]''` | `np.arange(1.,11.)[:, np.newaxis]` | create a column vector
    |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4)` | `np.zeros((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `zeros(3,4,5)` | `np.zeros((3, 4, 5))` | 3x4x5 three-dimensional array full
    of 64-bit floating point zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `ones(3,4)` | `np.ones((3, 4))` | 3x4 two-dimensional array full of 64-bit
    floating point ones |'
  prefs: []
  type: TYPE_TB
- en: '| `eye(3)` | `np.eye(3)` | 3x3 identity matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(a)` | `np.diag(a)` | returns a vector of the diagonal elements of 2D
    array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,0)` | `np.diag(v, 0)` | returns a square diagonal matrix whose nonzero
    values are the elements of vector, `v` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'or older version: `random.rand((3, 4))` | generate a random 3x4 array with
    default random number generator and seed = 42 |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `linspace(1,3,4)` | `np.linspace(1,3,4)` | 4 equally spaced samples between
    1 and 3, inclusive |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid(0:8,0:5)` | `np.mgrid[0:9.,0:6.]` or `np.meshgrid(r_[0:9.],r_[0:6.])`
    | two 2D arrays: one of x values, the other of y values |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ogrid[0:9.,0:6.]` or `np.ix_(np.r_[0:9.],np.r_[0:6.]` | the best way
    to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `[x,y]=meshgrid([1,2,4],[2,4,5])` | `np.meshgrid([1,2,4],[2,4,5])` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `np.ix_([1,2,4],[2,4,5])` | the best way to eval functions on a grid |'
  prefs: []
  type: TYPE_TB
- en: '| `repmat(a, m, n)` | `np.tile(a, (m, n))` | create m by n copies of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a b]` | `np.concatenate((a,b),1)` or `np.hstack((a,b))` or `np.column_stack((a,b))`
    or `np.c_[a,b]` | concatenate columns of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `[a; b]` | `np.concatenate((a,b))` or `np.vstack((a,b))` or `np.r_[a,b]`
    | concatenate rows of `a` and `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(max(a))` | `a.max()` or `np.nanmax(a)` | maximum element of `a` (with
    ndims(a)<=2 for MATLAB, if there are NaN’s, `nanmax` will ignore these and return
    largest value) |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a)` | `a.max(0)` | maximum element of each column of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,[],2)` | `a.max(1)` | maximum element of each row of array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `max(a,b)` | `np.maximum(a, b)` | compares `a` and `b` element-wise, and
    returns the maximum value from each pair |'
  prefs: []
  type: TYPE_TB
- en: '| `norm(v)` | `np.sqrt(v @ v)` or `np.linalg.norm(v)` | L2 norm of vector `v`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | `logical_and(a,b)` | element-by-element AND operator (NumPy ufunc)
    [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | `np.logical_or(a,b)` | element-by-element OR operator (NumPy
    ufunc) [See note LOGICOPS](#numpy-for-matlab-users-notes) |'
  prefs: []
  type: TYPE_TB
- en: '| `bitand(a,b)` | `a & b` | bitwise AND operator (Python native and NumPy ufunc)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bitor(a,b)` | `a &#124; b` | bitwise OR operator (Python native and NumPy
    ufunc) |'
  prefs: []
  type: TYPE_TB
- en: '| `inv(a)` | `linalg.inv(a)` | inverse of square 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `pinv(a)` | `linalg.pinv(a)` | pseudo-inverse of 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `rank(a)` | `np.linalg.matrix_rank(a)` | matrix rank of a 2D array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a\b` | `linalg.solve(a, b)` if `a` is square; `linalg.lstsq(a, b)` otherwise
    | solution of a x = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `b/a` | Solve `a.T x.T = b.T` instead | solution of x a = b for x |'
  prefs: []
  type: TYPE_TB
- en: '| `[U,S,V]=svd(a)` | `U, S, Vh = linalg.svd(a); V = Vh.T` | singular value
    decomposition of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `chol(a)` | `linalg.cholesky(a)` | Cholesky factorization of a 2D array |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a)` | `D,V = linalg.eig(a)` | eigenvalues \(\lambda\) and eigenvectors
    \(v\) of `a`, where \(\mathbf{a} v = \lambda v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eig(a,b)` | `D,V = linalg.eig(a, b)` | eigenvalues \(\lambda\) and
    eigenvectors \(v\) of `a`, `b` where \(\mathbf{a} v = \lambda \mathbf{b} v\) |'
  prefs: []
  type: TYPE_TB
- en: '| `[V,D]=eigs(a,3)` | `D,V = eigs(a, k=3)` | find the `k=3` largest eigenvalues
    and eigenvectors of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[Q,R]=qr(a,0)` | `Q,R = linalg.qr(a)` | QR decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `[L,U,P]=lu(a)` where `a==P''*L*U` | `P,L,U = linalg.lu(a)` where `a == P@L@U`
    | LU decomposition with partial pivoting (note: P(MATLAB) == transpose(P(NumPy)))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `conjgrad` | `cg` | conjugate gradients solver |'
  prefs: []
  type: TYPE_TB
- en: '| `fft(a)` | `np.fft.fft(a)` | Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `ifft(a)` | `np.fft.ifft(a)` | inverse Fourier transform of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a)` | `np.sort(a)` or `a.sort(axis=0)` | sort each column of a 2D array,
    `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `sort(a, 2)` | `np.sort(a, axis=1)` or `a.sort(axis=1)` | sort the each row
    of 2D array, `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `[b,I]=sortrows(a,1)` | `I = np.argsort(a[:, 0]); b = a[I,:]` | save the
    array `a` as array `b` with rows sorted by the first column |'
  prefs: []
  type: TYPE_TB
- en: '| `x = Z\y` | `x = linalg.lstsq(Z, y)` | perform a linear regression of the
    form \(\mathbf{Zx}=\mathbf{y}\) |'
  prefs: []
  type: TYPE_TB
- en: '| `decimate(x, q)` | `signal.resample(x, np.ceil(len(x)/q))` | downsample with
    low-pass filtering |'
  prefs: []
  type: TYPE_TB
- en: '| `unique(a)` | `np.unique(a)` | a vector of unique values in array `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `squeeze(a)` | `a.squeeze()` | remove singleton dimensions of array `a`.
    Note that MATLAB will always return arrays of 2D or higher while NumPy will return
    arrays of 0D or higher |'
  prefs: []
  type: TYPE_TB
- en: '## Notes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Submatrix**: Assignment to a submatrix can be done with lists of indices
    using the `ix_` command. E.g., for 2D array `a`, one might do: `ind=[1, 3]; a[np.ix_(ind,
    ind)] += 100`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HELP**: There is no direct equivalent of MATLAB’s `which` command, but the
    commands [`help`](https://docs.python.org/3/library/functions.html#help "(in Python
    v3.11)") and [`numpy.source`](../reference/generated/numpy.source.html#numpy.source
    "numpy.source") will usually list the filename where the function is located.
    Python also has an `inspect` module (do `import inspect`) which provides a `getfile`
    that often works.'
  prefs: []
  type: TYPE_NORMAL
- en: '**INDEXING**: MATLAB uses one based indexing, so the initial element of a sequence
    has index 1\. Python uses zero based indexing, so the initial element of a sequence
    has index 0\. Confusion and flamewars arise because each has advantages and disadvantages.
    One based indexing is consistent with common human language usage, where the “first”
    element of a sequence has index 1\. Zero based indexing [simplifies indexing](https://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?q=g:thl3498076713d&hl=en).
    See also [a text by prof.dr. Edsger W. Dijkstra](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**RANGES**: In MATLAB, `0:5` can be used as both a range literal and a ‘slice’
    index (inside parentheses); however, in Python, constructs like `0:5` can *only*
    be used as a slice index (inside square brackets). Thus the somewhat quirky `r_`
    object was created to allow NumPy to have a similarly terse range construction
    mechanism. Note that `r_` is not called like a function or a constructor, but
    rather *indexed* using square brackets, which allows the use of Python’s slice
    syntax in the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LOGICOPS**: `&` or `|` in NumPy is bitwise AND/OR, while in MATLAB & and
    `|` are logical AND/OR. The two can appear to work the same, but there are important
    differences. If you would have used MATLAB’s `&` or `|` operators, you should
    use the NumPy ufuncs `logical_and`/`logical_or`. The notable differences between
    MATLAB’s and NumPy’s `&` and `|` operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-logical {0,1} inputs: NumPy’s output is the bitwise AND of the inputs.
    MATLAB treats any non-zero value as 1 and returns the logical AND. For example
    `(3 & 4)` in NumPy is `0`, while in MATLAB both `3` and `4` are considered logical
    true and `(3 & 4)` returns `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Precedence: NumPy’s & operator is higher precedence than logical operators
    like `<` and `>`; MATLAB’s is the reverse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you know you have boolean arguments, you can get away with using NumPy’s
    bitwise operators, but be careful with parentheses, like this: `z = (x > 1) &
    (x < 2)`. The absence of NumPy operator forms of `logical_and` and `logical_or`
    is an unfortunate consequence of Python’s design.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RESHAPE and LINEAR INDEXING**: MATLAB always allows multi-dimensional arrays
    to be accessed using scalar or linear indices, NumPy does not. Linear indices
    are common in MATLAB programs, e.g. `find()` on a matrix returns them, whereas
    NumPy’s find behaves differently. When converting MATLAB code it might be necessary
    to first reshape a matrix to a linear sequence, perform some indexing operations
    and then reshape back. As reshape (usually) produces views onto the same storage,
    it should be possible to do this fairly efficiently. Note that the scan order
    used by reshape in NumPy defaults to the ‘C’ order, whereas MATLAB uses the Fortran
    order. If you are simply converting to a linear sequence and back this doesn’t
    matter. But if you are converting reshapes from MATLAB code which relies on the
    scan order, then this MATLAB code: `z = reshape(x,3,4);` should become `z = x.reshape(3,4,order=''F'').copy()`
    in NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: ‘array’ or ‘matrix’? Which should I use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, NumPy has provided a special matrix type, *np.matrix*, which is
    a subclass of ndarray which makes binary operations linear algebra operations.
    You may see it used in some existing code instead of *np.array*. So, which one
    to use?
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Short answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use arrays**.'
  prefs: []
  type: TYPE_NORMAL
- en: They support multidimensional array algebra that is supported in MATLAB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions
    return arrays, not matrices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear distinction between element-wise operations and linear algebra
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have standard vectors or row/column vectors if you like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until Python 3.5 the only disadvantage of using the array type was that you
    had to use `dot` instead of `*` to multiply (reduce) two tensors (scalar product,
    matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication
    `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Given the above, we intend to deprecate `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Long answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy contains both an `array` class and a `matrix` class. The `array` class
    is intended to be a general-purpose n-dimensional array for many kinds of numerical
    computing, while `matrix` is intended to facilitate linear algebra computations
    specifically. In practice there are only a handful of key differences between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators `*` and `@`, functions `dot()`, and `multiply()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, **``*`` means element-wise multiplication**, while **``@`` means
    matrix multiplication**; they have associated functions `multiply()` and `dot()`.
    (Before Python 3.5, `@` did not exist and one had to use `dot()` for matrix multiplication).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **``*`` means matrix multiplication**, and for element-wise multiplication
    one has to use the `multiply()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of vectors (one-dimensional arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `array`, the **vector shapes 1xN, Nx1, and N are all different things**.
    Operations like `A[:,1]` return a one-dimensional array of shape N, not a two-dimensional
    array of shape Nx1\. Transpose on a one-dimensional `array` does nothing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `matrix`, **one-dimensional arrays are always upconverted to 1xN or Nx1
    matrices** (row or column vectors). `A[:,1]` returns a two-dimensional matrix
    of shape Nx1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of higher-dimensional arrays (ndim > 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` objects **can have number of dimensions > 2**;'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` objects **always have exactly two dimensions**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array` **has a .T attribute**, which returns the transpose of the data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix` **also has .H, .I, and .A attributes**, which return the conjugate
    transpose, inverse, and `asarray()` of the matrix, respectively.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` constructor **takes (nested) Python sequences as initializers**.
    As in, `array([[1,2,3],[4,5,6]])`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `matrix` constructor additionally **takes a convenient string initializer**.
    As in `matrix("[1 2 3; 4 5 6]")`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are pros and cons to using both:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Element-wise multiplication is easy: `A*B`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` You have to remember that matrix multiplication has its own operator,
    `@`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` You can treat one-dimensional arrays as *either* row or column vectors.
    `A @ v` treats `v` as a column vector, while `v @ A` treats `v` as a row vector.
    This can save you having to type a lot of transposes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `array` is the “default” NumPy type, so it gets the most testing, and
    is the type most likely to be returned by 3rd party code that uses NumPy.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Is quite at home handling data of any number of dimensions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` Closer in semantics to tensor algebra, if you are familiar with that.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` *All* operations (`*`, `/`, `+`, `-` etc.) are element-wise.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:(` Sparse matrices from `scipy.sparse` do not interact as well with arrays.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:\\` Behavior is more like that of MATLAB matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Maximum of two-dimensional. To hold three-dimensional data you need `array`
    or perhaps a Python list of `matrix`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Minimum of two-dimensional. You cannot have vectors. They must be cast
    as single-column or single-row matrices.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Since `array` is the default in NumPy, some functions may return an `array`
    even if you give them a `matrix` as an argument. This shouldn’t happen with NumPy
    functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor
    type preservation like NumPy does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:)` `A*B` is matrix multiplication, so it looks just like you write it in
    linear algebra (For Python >= 3.5 plain arrays have the same convenience with
    the `@` operator).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` Element-wise multiplication requires calling a function, `multiply(A,B)`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<:(` The use of operator overloading is a bit illogical: `*` does not work
    element-wise but `/` does.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction with `scipy.sparse` is a bit cleaner.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `array` is thus much more advisable to use. Indeed, we intend to deprecate
    `matrix` eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MATLAB the main tool available to you for customizing the environment is
    to modify the search path with the locations of your favorite functions. You can
    put such customizations into a startup script that MATLAB will run on startup.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy, or rather Python, has similar facilities.
  prefs: []
  type: TYPE_NORMAL
- en: To modify your Python search path to include the locations of your own modules,
    define the `PYTHONPATH` environment variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have a particular script file executed when the interactive Python interpreter
    is started, define the `PYTHONSTARTUP` environment variable to contain the name
    of your startup script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike MATLAB, where anything on your path can be called immediately, with Python
    you need to first do an ‘import’ statement to make functions in a particular file
    accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example you might make a startup script that looks like this (Note: this
    is just an example, not a statement of “best practices”):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the deprecated *matrix* and other *matlib* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another somewhat outdated MATLAB/NumPy cross-reference can be found at [http://mathesaurus.sf.net/](http://mathesaurus.sf.net/)
  prefs: []
  type: TYPE_NORMAL
- en: An extensive list of tools for scientific work with Python can be found in the
    [topical software page](https://scipy.org/topical-software.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'See [List of Python software: scripting](https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language)
    for a list of software that use Python as a scripting language'
  prefs: []
  type: TYPE_NORMAL
- en: MATLAB® and SimuLink® are registered trademarks of The MathWorks, Inc.
  prefs: []
  type: TYPE_NORMAL
