- en: Comparison with R / R libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_r.html](https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_r.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since pandas aims to provide a lot of the data manipulation and analysis functionality
    that people use [R](https://www.r-project.org/) for, this page was started to
    provide a more detailed look at the [R language](https://en.wikipedia.org/wiki/R_(programming_language))
    and its many third party libraries as they relate to pandas. In comparisons with
    R and CRAN libraries, we care about the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality / flexibility**: what can/cannot be done with each tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: how fast are operations. Hard numbers/benchmarks are preferable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease-of-use**: Is one tool easier/harder to use (you may have to be the judge
    of this, given side-by-side code comparisons)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This page is also here to offer a bit of a translation guide for users of these
    R packages.
  prefs: []
  type: TYPE_NORMAL
- en: Quick reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start off with a quick reference guide pairing some common R operations
    using [dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) with pandas
    equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Querying, filtering, sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dim(df)` | `df.shape` |'
  prefs: []
  type: TYPE_TB
- en: '| `head(df)` | `df.head()` |'
  prefs: []
  type: TYPE_TB
- en: '| `slice(df, 1:10)` | `df.iloc[:9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `filter(df, col1 == 1, col2 == 1)` | `df.query(''col1 == 1 & col2 == 1'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `df[df$col1 == 1 & df$col2 == 1,]` | `df[(df.col1 == 1) & (df.col2 == 1)]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1, col2)` | `df[[''col1'', ''col2'']]` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1:col3)` | `df.loc[:, ''col1'':''col3'']` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, -(col1:col3))` | `df.drop(cols_to_drop, axis=1)` but see [[1]](#select-range)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1))` | `df[[''col1'']].drop_duplicates()` |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1, col2))` | `df[[''col1'', ''col2'']].drop_duplicates()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_n(df, 10)` | `df.sample(n=10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_frac(df, 0.01)` | `df.sample(frac=0.01)` |'
  prefs: []
  type: TYPE_TB
- en: Sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, col1, col2)` | `df.sort_values([''col1'', ''col2''])` |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, desc(col1))` | `df.sort_values(''col1'', ascending=False)` |'
  prefs: []
  type: TYPE_TB
- en: Transforming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})[''col_one'']`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rename(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mutate(df, c=a-b)` | `df.assign(c=df[''a'']-df[''b''])` |'
  prefs: []
  type: TYPE_TB
- en: Grouping and summarizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `summary(df)` | `df.describe()` |'
  prefs: []
  type: TYPE_TB
- en: '| `gdf <- group_by(df, col1)` | `gdf = df.groupby(''col1'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, avg=mean(col1, na.rm=TRUE))` | `df.groupby(''col1'').agg({''col1'':
    ''mean''})` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, total=sum(col1))` | `df.groupby(''col1'').sum()` |'
  prefs: []
  type: TYPE_TB
- en: Base R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slicing with R’s [`c`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/c.html)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R makes it easy to access `data.frame` columns by name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: or by integer location
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple columns by name in pandas is straightforward
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple noncontiguous columns by integer location can be achieved
    with a combination of the `iloc` indexer attribute and `numpy.r_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[`aggregate`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/aggregate.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R you may want to split data into subsets and compute the mean for each.
    Using a data.frame called `df` and splitting it into groups `by1` and `by2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method is similar to base R `aggregate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`match` / `%in%`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common way to select data in R is using `%in%` which is defined using the
    function `match`. The operator `%in%` is used to return a logical vector indicating
    if there is a match or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`isin()`](../../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") method is similar to R `%in%` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` function returns a vector of the positions of matches of its first
    argument in its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/indexing.html#indexing-basics-indexing-isin).
  prefs: []
  type: TYPE_NORMAL
- en: '[`tapply`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/tapply.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tapply` is similar to `aggregate`, but data can be in a ragged array, since
    the subclass sizes are possibly irregular. Using a data.frame called `baseball`,
    and retrieving information based on the array `team`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas we may use [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table") method to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot).
  prefs: []
  type: TYPE_NORMAL
- en: '[`subset`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") method is similar to the base R `subset` function. In
    R you might want to get the rows of a `data.frame` where one column’s values are
    less than another column’s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas, there are a few ways to perform subsetting. You can use [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") or pass an expression as if it were an index/slice as
    well as standard boolean indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the query documentation](../../user_guide/indexing.html#indexing-query).
  prefs: []
  type: TYPE_NORMAL
- en: '[`with`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/with.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R with the columns `a` and
    `b` would be evaluated using `with` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In certain cases [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") will be much faster than evaluation in pure Python. For
    more details and examples see [the eval documentation](../../user_guide/enhancingperf.html#enhancingperf-eval).
  prefs: []
  type: TYPE_NORMAL
- en: plyr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`plyr` is an R library for the split-apply-combine strategy for data analysis.
    The functions revolve around three data structures in R, `a` for `arrays`, `l`
    for `lists`, and `d` for `data.frame`. The table below shows how these data structures
    could be mapped in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '| R | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| array | list |'
  prefs: []
  type: TYPE_TB
- en: '| lists | dictionary or list of objects |'
  prefs: []
  type: TYPE_TB
- en: '| data.frame | dataframe |'
  prefs: []
  type: TYPE_TB
- en: ddply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R where you want to summarize
    `x` by `month`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-aggregate).
  prefs: []
  type: TYPE_NORMAL
- en: reshape / reshape2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: meltarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a 3 dimensional array called `a` in R where you want to
    melt it into a data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In Python, since `a` is a list, you can simply use list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: meltlist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a list called `a` in R where you want to melt it into a
    data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In Python, this list would be a list of tuples, so [`DataFrame()`](../../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") method would convert it to a dataframe as required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the Into to Data Structures documentation](../../user_guide/dsintro.html#dsintro).
  prefs: []
  type: TYPE_NORMAL
- en: meltdf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `cheese` in R where you want to reshape
    the data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, the [`melt()`](../../reference/api/pandas.melt.html#pandas.melt
    "pandas.melt") method is the R equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-melt).
  prefs: []
  type: TYPE_NORMAL
- en: cast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R `acast` is an expression using a data.frame called `df` in R to cast into
    a higher dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python the best way is to make use of [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly for `dcast` which uses a data.frame called `df` in R to aggregate
    information based on `Animal` and `FeedType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Python can approach this in two different ways. Firstly, similar to above using
    [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is to use the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot)
    or [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`factor`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/factor.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas has a data type for categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas this is accomplished with `pd.cut` and `astype("category")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [categorical introduction](../../user_guide/categorical.html#categorical)
    and the [API documentation](../../reference/arrays.html#api-arrays-categorical).
    There is also a documentation regarding the [differences to R’s factor](../../user_guide/categorical.html#categorical-rfactor).
  prefs: []
  type: TYPE_NORMAL
- en: Quick reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start off with a quick reference guide pairing some common R operations
    using [dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) with pandas
    equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Querying, filtering, sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dim(df)` | `df.shape` |'
  prefs: []
  type: TYPE_TB
- en: '| `head(df)` | `df.head()` |'
  prefs: []
  type: TYPE_TB
- en: '| `slice(df, 1:10)` | `df.iloc[:9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `filter(df, col1 == 1, col2 == 1)` | `df.query(''col1 == 1 & col2 == 1'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `df[df$col1 == 1 & df$col2 == 1,]` | `df[(df.col1 == 1) & (df.col2 == 1)]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1, col2)` | `df[[''col1'', ''col2'']]` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1:col3)` | `df.loc[:, ''col1'':''col3'']` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, -(col1:col3))` | `df.drop(cols_to_drop, axis=1)` but see [[1]](#select-range)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1))` | `df[[''col1'']].drop_duplicates()` |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1, col2))` | `df[[''col1'', ''col2'']].drop_duplicates()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_n(df, 10)` | `df.sample(n=10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_frac(df, 0.01)` | `df.sample(frac=0.01)` |'
  prefs: []
  type: TYPE_TB
- en: Sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, col1, col2)` | `df.sort_values([''col1'', ''col2''])` |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, desc(col1))` | `df.sort_values(''col1'', ascending=False)` |'
  prefs: []
  type: TYPE_TB
- en: Transforming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})[''col_one'']`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rename(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mutate(df, c=a-b)` | `df.assign(c=df[''a'']-df[''b''])` |'
  prefs: []
  type: TYPE_TB
- en: Grouping and summarizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `summary(df)` | `df.describe()` |'
  prefs: []
  type: TYPE_TB
- en: '| `gdf <- group_by(df, col1)` | `gdf = df.groupby(''col1'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, avg=mean(col1, na.rm=TRUE))` | `df.groupby(''col1'').agg({''col1'':
    ''mean''})` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, total=sum(col1))` | `df.groupby(''col1'').sum()` |'
  prefs: []
  type: TYPE_TB
- en: Querying, filtering, sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dim(df)` | `df.shape` |'
  prefs: []
  type: TYPE_TB
- en: '| `head(df)` | `df.head()` |'
  prefs: []
  type: TYPE_TB
- en: '| `slice(df, 1:10)` | `df.iloc[:9]` |'
  prefs: []
  type: TYPE_TB
- en: '| `filter(df, col1 == 1, col2 == 1)` | `df.query(''col1 == 1 & col2 == 1'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `df[df$col1 == 1 & df$col2 == 1,]` | `df[(df.col1 == 1) & (df.col2 == 1)]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1, col2)` | `df[[''col1'', ''col2'']]` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col1:col3)` | `df.loc[:, ''col1'':''col3'']` |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, -(col1:col3))` | `df.drop(cols_to_drop, axis=1)` but see [[1]](#select-range)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1))` | `df[[''col1'']].drop_duplicates()` |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct(select(df, col1, col2))` | `df[[''col1'', ''col2'']].drop_duplicates()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_n(df, 10)` | `df.sample(n=10)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sample_frac(df, 0.01)` | `df.sample(frac=0.01)` |'
  prefs: []
  type: TYPE_TB
- en: Sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, col1, col2)` | `df.sort_values([''col1'', ''col2''])` |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange(df, desc(col1))` | `df.sort_values(''col1'', ascending=False)` |'
  prefs: []
  type: TYPE_TB
- en: Transforming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `select(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})[''col_one'']`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `rename(df, col_one = col1)` | `df.rename(columns={''col1'': ''col_one''})`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mutate(df, c=a-b)` | `df.assign(c=df[''a'']-df[''b''])` |'
  prefs: []
  type: TYPE_TB
- en: Grouping and summarizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| R | pandas |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `summary(df)` | `df.describe()` |'
  prefs: []
  type: TYPE_TB
- en: '| `gdf <- group_by(df, col1)` | `gdf = df.groupby(''col1'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, avg=mean(col1, na.rm=TRUE))` | `df.groupby(''col1'').agg({''col1'':
    ''mean''})` |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise(gdf, total=sum(col1))` | `df.groupby(''col1'').sum()` |'
  prefs: []
  type: TYPE_TB
- en: Base R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slicing with R’s [`c`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/c.html)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R makes it easy to access `data.frame` columns by name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: or by integer location
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple columns by name in pandas is straightforward
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple noncontiguous columns by integer location can be achieved
    with a combination of the `iloc` indexer attribute and `numpy.r_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[`aggregate`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/aggregate.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R you may want to split data into subsets and compute the mean for each.
    Using a data.frame called `df` and splitting it into groups `by1` and `by2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method is similar to base R `aggregate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`match` / `%in%`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common way to select data in R is using `%in%` which is defined using the
    function `match`. The operator `%in%` is used to return a logical vector indicating
    if there is a match or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`isin()`](../../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") method is similar to R `%in%` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` function returns a vector of the positions of matches of its first
    argument in its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/indexing.html#indexing-basics-indexing-isin).
  prefs: []
  type: TYPE_NORMAL
- en: '[`tapply`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/tapply.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tapply` is similar to `aggregate`, but data can be in a ragged array, since
    the subclass sizes are possibly irregular. Using a data.frame called `baseball`,
    and retrieving information based on the array `team`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas we may use [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table") method to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot).
  prefs: []
  type: TYPE_NORMAL
- en: '[`subset`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") method is similar to the base R `subset` function. In
    R you might want to get the rows of a `data.frame` where one column’s values are
    less than another column’s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas, there are a few ways to perform subsetting. You can use [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") or pass an expression as if it were an index/slice as
    well as standard boolean indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the query documentation](../../user_guide/indexing.html#indexing-query).
  prefs: []
  type: TYPE_NORMAL
- en: '[`with`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/with.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R with the columns `a` and
    `b` would be evaluated using `with` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In certain cases [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") will be much faster than evaluation in pure Python. For
    more details and examples see [the eval documentation](../../user_guide/enhancingperf.html#enhancingperf-eval).
  prefs: []
  type: TYPE_NORMAL
- en: Slicing with R’s [`c`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/c.html)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R makes it easy to access `data.frame` columns by name
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: or by integer location
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple columns by name in pandas is straightforward
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Selecting multiple noncontiguous columns by integer location can be achieved
    with a combination of the `iloc` indexer attribute and `numpy.r_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[`aggregate`](https://stat.ethz.ch/R-manual/R-patched/library/stats/html/aggregate.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R you may want to split data into subsets and compute the mean for each.
    Using a data.frame called `df` and splitting it into groups `by1` and `by2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method is similar to base R `aggregate` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`match` / `%in%`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common way to select data in R is using `%in%` which is defined using the
    function `match`. The operator `%in%` is used to return a logical vector indicating
    if there is a match or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`isin()`](../../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") method is similar to R `%in%` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `match` function returns a vector of the positions of matches of its first
    argument in its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/indexing.html#indexing-basics-indexing-isin).
  prefs: []
  type: TYPE_NORMAL
- en: '[`tapply`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/tapply.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tapply` is similar to `aggregate`, but data can be in a ragged array, since
    the subclass sizes are possibly irregular. Using a data.frame called `baseball`,
    and retrieving information based on the array `team`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas we may use [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table") method to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot).
  prefs: []
  type: TYPE_NORMAL
- en: '[`subset`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") method is similar to the base R `subset` function. In
    R you might want to get the rows of a `data.frame` where one column’s values are
    less than another column’s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas, there are a few ways to perform subsetting. You can use [`query()`](../../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") or pass an expression as if it were an index/slice as
    well as standard boolean indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the query documentation](../../user_guide/indexing.html#indexing-query).
  prefs: []
  type: TYPE_NORMAL
- en: '[`with`](https://stat.ethz.ch/R-manual/R-patched/library/base/html/with.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R with the columns `a` and
    `b` would be evaluated using `with` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In certain cases [`eval()`](../../reference/api/pandas.DataFrame.eval.html#pandas.DataFrame.eval
    "pandas.DataFrame.eval") will be much faster than evaluation in pure Python. For
    more details and examples see [the eval documentation](../../user_guide/enhancingperf.html#enhancingperf-eval).
  prefs: []
  type: TYPE_NORMAL
- en: plyr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`plyr` is an R library for the split-apply-combine strategy for data analysis.
    The functions revolve around three data structures in R, `a` for `arrays`, `l`
    for `lists`, and `d` for `data.frame`. The table below shows how these data structures
    could be mapped in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '| R | Python |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| array | list |'
  prefs: []
  type: TYPE_TB
- en: '| lists | dictionary or list of objects |'
  prefs: []
  type: TYPE_TB
- en: '| data.frame | dataframe |'
  prefs: []
  type: TYPE_TB
- en: ddply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R where you want to summarize
    `x` by `month`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-aggregate).
  prefs: []
  type: TYPE_NORMAL
- en: ddply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `df` in R where you want to summarize
    `x` by `month`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas the equivalent expression, using the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the groupby documentation](../../user_guide/groupby.html#groupby-aggregate).
  prefs: []
  type: TYPE_NORMAL
- en: reshape / reshape2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: meltarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a 3 dimensional array called `a` in R where you want to
    melt it into a data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In Python, since `a` is a list, you can simply use list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: meltlist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a list called `a` in R where you want to melt it into a
    data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In Python, this list would be a list of tuples, so [`DataFrame()`](../../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") method would convert it to a dataframe as required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the Into to Data Structures documentation](../../user_guide/dsintro.html#dsintro).
  prefs: []
  type: TYPE_NORMAL
- en: meltdf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `cheese` in R where you want to reshape
    the data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, the [`melt()`](../../reference/api/pandas.melt.html#pandas.melt
    "pandas.melt") method is the R equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-melt).
  prefs: []
  type: TYPE_NORMAL
- en: cast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R `acast` is an expression using a data.frame called `df` in R to cast into
    a higher dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python the best way is to make use of [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly for `dcast` which uses a data.frame called `df` in R to aggregate
    information based on `Animal` and `FeedType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Python can approach this in two different ways. Firstly, similar to above using
    [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is to use the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot)
    or [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`factor`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/factor.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas has a data type for categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas this is accomplished with `pd.cut` and `astype("category")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [categorical introduction](../../user_guide/categorical.html#categorical)
    and the [API documentation](../../reference/arrays.html#api-arrays-categorical).
    There is also a documentation regarding the [differences to R’s factor](../../user_guide/categorical.html#categorical-rfactor).
  prefs: []
  type: TYPE_NORMAL
- en: meltarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a 3 dimensional array called `a` in R where you want to
    melt it into a data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In Python, since `a` is a list, you can simply use list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: meltlist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a list called `a` in R where you want to melt it into a
    data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In Python, this list would be a list of tuples, so [`DataFrame()`](../../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") method would convert it to a dataframe as required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the Into to Data Structures documentation](../../user_guide/dsintro.html#dsintro).
  prefs: []
  type: TYPE_NORMAL
- en: meltdf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An expression using a data.frame called `cheese` in R where you want to reshape
    the data.frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, the [`melt()`](../../reference/api/pandas.melt.html#pandas.melt
    "pandas.melt") method is the R equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-melt).
  prefs: []
  type: TYPE_NORMAL
- en: cast
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In R `acast` is an expression using a data.frame called `df` in R to cast into
    a higher dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python the best way is to make use of [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly for `dcast` which uses a data.frame called `df` in R to aggregate
    information based on `Animal` and `FeedType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Python can approach this in two different ways. Firstly, similar to above using
    [`pivot_table()`](../../reference/api/pandas.pivot_table.html#pandas.pivot_table
    "pandas.pivot_table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is to use the [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [the reshaping documentation](../../user_guide/reshaping.html#reshaping-pivot)
    or [the groupby documentation](../../user_guide/groupby.html#groupby-split).
  prefs: []
  type: TYPE_NORMAL
- en: '[`factor`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/factor.html)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas has a data type for categorical data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas this is accomplished with `pd.cut` and `astype("category")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: For more details and examples see [categorical introduction](../../user_guide/categorical.html#categorical)
    and the [API documentation](../../reference/arrays.html#api-arrays-categorical).
    There is also a documentation regarding the [differences to R’s factor](../../user_guide/categorical.html#categorical-rfactor).
  prefs: []
  type: TYPE_NORMAL
