- en: Optimization (scipy.optimize)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 (scipy.optimize)
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/optimize.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/optimize.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/optimize.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/optimize.html)
- en: Contents
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目录
- en: '[Optimization (](#optimization-scipy-optimize)[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize"))'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[优化 (](#optimization-scipy-optimize)[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize"))'
- en: '[Unconstrained minimization of multivariate scalar functions (](#unconstrained-minimization-of-multivariate-scalar-functions-minimize)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[多元标量函数的无约束最小化 (](#unconstrained-minimization-of-multivariate-scalar-functions-minimize)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
- en: '[Nelder-Mead Simplex algorithm (`method=''Nelder-Mead''`)](#nelder-mead-simplex-algorithm-method-nelder-mead)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[尼尔德-米德单纯形算法 (`method=''Nelder-Mead''`)](#nelder-mead-simplex-algorithm-method-nelder-mead)'
- en: '[Broyden-Fletcher-Goldfarb-Shanno algorithm (`method=''BFGS''`)](#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[布洛伊登-弗莱彻-戈尔德法-沙诺算法 (`method=''BFGS''`)](#broyden-fletcher-goldfarb-shanno-algorithm-method-bfgs)'
- en: '[Avoiding Redundant Calculation](#avoiding-redundant-calculation)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[避免冗余计算](#avoiding-redundant-calculation)'
- en: '[Newton-Conjugate-Gradient algorithm (`method=''Newton-CG''`)](#newton-conjugate-gradient-algorithm-method-newton-cg)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[牛顿共轭梯度算法 (`method=''Newton-CG''`)](#newton-conjugate-gradient-algorithm-method-newton-cg)'
- en: '[Full Hessian example:](#full-hessian-example)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整海森矩阵示例：](#full-hessian-example)'
- en: '[Hessian product example:](#hessian-product-example)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[海森矩阵乘积示例：](#hessian-product-example)'
- en: '[Trust-Region Newton-Conjugate-Gradient Algorithm (`method=''trust-ncg''`)](#trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信赖区域牛顿共轭梯度算法 (`method=''trust-ncg''`)](#trust-region-newton-conjugate-gradient-algorithm-method-trust-ncg)'
- en: '[Full Hessian example:](#id4)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整海森矩阵示例：](#id4)'
- en: '[Hessian product example:](#id5)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[海森矩阵乘积示例：](#id5)'
- en: '[Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm
    (`method=''trust-krylov''`)](#trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信赖区域截断广义兰兹-共轭梯度算法 (`method=''trust-krylov''`)](#trust-region-truncated-generalized-lanczos-conjugate-gradient-algorithm-method-trust-krylov)'
- en: '[Full Hessian example:](#id8)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整海森矩阵示例：](#id8)'
- en: '[Hessian product example:](#id9)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[海森矩阵乘积示例：](#id9)'
- en: '[Trust-Region Nearly Exact Algorithm (`method=''trust-exact''`)](#trust-region-nearly-exact-algorithm-method-trust-exact)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信赖区域近乎精确算法 (`method=''trust-exact''`)](#trust-region-nearly-exact-algorithm-method-trust-exact)'
- en: '[Constrained minimization of multivariate scalar functions (](#constrained-minimization-of-multivariate-scalar-functions-minimize)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[多元标量函数的约束最小化 (](#constrained-minimization-of-multivariate-scalar-functions-minimize)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
- en: '[Trust-Region Constrained Algorithm (`method=''trust-constr''`)](#trust-region-constrained-algorithm-method-trust-constr)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信赖区域约束算法 (`method=''trust-constr''`)](#trust-region-constrained-algorithm-method-trust-constr)'
- en: '[Defining Bounds Constraints:](#defining-bounds-constraints)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义边界约束：](#defining-bounds-constraints)'
- en: '[Defining Linear Constraints:](#defining-linear-constraints)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义线性约束：](#defining-linear-constraints)'
- en: '[Defining Nonlinear Constraints:](#defining-nonlinear-constraints)'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义非线性约束：](#defining-nonlinear-constraints)'
- en: '[Solving the Optimization Problem:](#solving-the-optimization-problem)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解决优化问题：](#solving-the-optimization-problem)'
- en: '[Sequential Least SQuares Programming (SLSQP) Algorithm (`method=''SLSQP''`)](#sequential-least-squares-programming-slsqp-algorithm-method-slsqp)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[顺序最小二乘编程 (SLSQP) 算法 (`method=''SLSQP''`)](#sequential-least-squares-programming-slsqp-algorithm-method-slsqp)'
- en: '[Global optimization](#global-optimization)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[全局优化](#global-optimization)'
- en: '[Least-squares minimization (](#least-squares-minimization-least-squares)[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares"))'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[最小二乘最小化 (](#least-squares-minimization-least-squares)[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares"))'
- en: '[Example of solving a fitting problem](#example-of-solving-a-fitting-problem)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解决拟合问题的示例](#example-of-solving-a-fitting-problem)'
- en: '[Further examples](#further-examples)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更多示例](#further-examples)'
- en: '[Univariate function minimizers (](#univariate-function-minimizers-minimize-scalar)[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar"))'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一元函数最小化器 (](#univariate-function-minimizers-minimize-scalar)[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar"))'
- en: '[Unconstrained minimization (`method=''brent''`)](#unconstrained-minimization-method-brent)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无约束最小化 (`method=''brent''`)](#unconstrained-minimization-method-brent)'
- en: '[Bounded minimization (`method=''bounded''`)](#bounded-minimization-method-bounded)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[有界最小化 (`method=''bounded''`)](#bounded-minimization-method-bounded)'
- en: '[Custom minimizers](#custom-minimizers)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自定义最小化器](#custom-minimizers)'
- en: '[Root finding](#root-finding)'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[根查找](#root-finding)'
- en: '[Scalar functions](#scalar-functions)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[标量函数](#scalar-functions)'
- en: '[Fixed-point solving](#fixed-point-solving)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[固定点求解](#fixed-point-solving)'
- en: '[Sets of equations](#sets-of-equations)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[方程组](#sets-of-equations)'
- en: '[Root finding for large problems](#root-finding-for-large-problems)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大问题的根查找](#root-finding-for-large-problems)'
- en: '[Still too slow? Preconditioning.](#still-too-slow-preconditioning)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[仍然太慢？预调节。](#still-too-slow-preconditioning)'
- en: '[Linear programming (](#linear-programming-linprog)[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"))'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性规划 (`linprog`)](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")'
- en: '[Linear programming example](#linear-programming-example)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性规划示例](#linear-programming-example)'
- en: '[Assignment problems](#assignment-problems)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[分配问题](#assignment-problems)'
- en: '[Linear sum assignment problem example](#linear-sum-assignment-problem-example)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[线性和分配问题示例](#linear-sum-assignment-problem-example)'
- en: '[Mixed integer linear programming](#mixed-integer-linear-programming)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合整数线性规划](#mixed-integer-linear-programming)'
- en: '[Knapsack problem example](#knapsack-problem-example)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[背包问题示例](#knapsack-problem-example)'
- en: 'The [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize "scipy.optimize")
    package provides several commonly used optimization algorithms. A detailed listing
    is available: [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize") (can also be found by `help(scipy.optimize)`).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize "scipy.optimize")
    包提供了几种常用的优化算法。详细清单可参阅：[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize") （也可通过`help(scipy.optimize)`查找）。'
- en: '[Unconstrained minimization of multivariate scalar functions (](#id21)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[无约束多变量标量函数最小化 (](#id21)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
- en: 'The [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function provides a common interface to unconstrained
    and constrained minimization algorithms for multivariate scalar functions in [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize"). To demonstrate the minimization function, consider the problem
    of minimizing the Rosenbrock function of \(N\) variables:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") 函数为多变量标量函数的无约束和约束最小化算法提供了通用接口，在[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize")中使用。为了演示最小化函数，考虑如下问题，即最小化具有\(N\)个变量的Rosenbrock函数：'
- en: \[f\left(\mathbf{x}\right)=\sum_{i=1}^{N-1}100\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}.\]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: \[f\left(\mathbf{x}\right)=\sum_{i=1}^{N-1}100\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}.\]
- en: The minimum value of this function is 0 which is achieved when \(x_{i}=1.\)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的最小值为0，当\(x_{i}=1.\)时达到。
- en: Note that the Rosenbrock function and its derivatives are included in [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize"). The implementations shown in the following sections provide
    examples of how to define an objective function as well as its jacobian and hessian
    functions. Objective functions in [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize") expect a numpy array as their first parameter which is to be
    optimized and must return a float value. The exact calling signature must be `f(x,
    *args)` where `x` represents a numpy array and `args` a tuple of additional arguments
    supplied to the objective function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Rosenbrock函数及其导数包含在[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize")中。以下部分中展示的实现示例说明了如何定义一个目标函数以及其雅可比和Hessian函数。[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize")中的目标函数期望其第一个参数是numpy数组，用于优化，并且必须返回一个浮点值。确切的调用签名必须是`f(x, *args)`，其中`x`表示numpy数组，`args`是传递给目标函数的额外参数的元组。
- en: '[Nelder-Mead Simplex algorithm (`method=''Nelder-Mead''`)](#id22)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Nelder-Mead Simplex算法 (`method=''Nelder-Mead''`)](#id22)'
- en: 'In the example below, the [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") routine is used with the *Nelder-Mead* simplex algorithm
    (selected through the `method` parameter):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，使用*Nelder-Mead* simplex算法（通过`method`参数选择）调用了[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")例程：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The simplex algorithm is probably the simplest way to minimize a fairly well-behaved
    function. It requires only function evaluations and is a good choice for simple
    minimization problems. However, because it does not use any gradient evaluations,
    it may take longer to find the minimum.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Simplex算法可能是最简单的最小化相当良好函数的方法。它只需要函数评估，并且对于简单的最小化问题是一个很好的选择。然而，由于它不使用任何梯度评估，可能需要更长时间找到最小值。
- en: Another optimization algorithm that needs only function calls to find the minimum
    is *Powell*’s method available by setting `method='powell'` in [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仅需函数调用来找到最小值的优化算法是*Powell*方法，通过在[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")中设置`method='powell'`来选择。
- en: 'To demonstrate how to supply additional arguments to an objective function,
    let us minimize the Rosenbrock function with an additional scaling factor *a*
    and an offset *b*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何向目标函数提供额外参数，让我们最小化Rosenbrock函数，其中包括一个额外的缩放因子*a*和一个偏移量*b*：
- en: \[f\left(\mathbf{x}, a, b\right)=\sum_{i=1}^{N-1}a\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}
    + b.\]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: \[f\left(\mathbf{x}, a, b\right)=\sum_{i=1}^{N-1}a\left(x_{i+1}-x_{i}^{2}\right)^{2}+\left(1-x_{i}\right)^{2}
    + b.\]
- en: Again using the [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") routine this can be solved by the following code block
    for the example parameters `a=0.5` and `b=1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")例程，以下代码块展示了如何使用示例参数 `a=0.5` 和 `b=1` 来解决这个问题。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As an alternative to using the `args` parameter of [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"), simply wrap the objective function in a new function
    that accepts only `x`. This approach is also useful when it is necessary to pass
    additional parameters to the objective function as keyword arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")的`args`参数的替代方法，只需将目标函数包装在一个新函数中，该函数仅接受`x`作为参数即可。当需要将额外参数作为关键字参数传递给目标函数时，这种方法也很有用。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another alternative is to use [`functools.partial`](https://docs.python.org/3/library/functools.html#functools.partial
    "(in Python v3.12)").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用[`functools.partial`](https://docs.python.org/3/library/functools.html#functools.partial
    "(in Python v3.12)")。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Broyden-Fletcher-Goldfarb-Shanno algorithm (`method=''BFGS''`)](#id23)'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Broyden-Fletcher-Goldfarb-Shanno算法 (`method=''BFGS''`)](#id23)'
- en: In order to converge more quickly to the solution, this routine uses the gradient
    of the objective function. If the gradient is not given by the user, then it is
    estimated using first-differences. The Broyden-Fletcher-Goldfarb-Shanno (BFGS)
    method typically requires fewer function calls than the simplex algorithm even
    when the gradient must be estimated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更快地收敛到解，这个例程使用了目标函数的梯度。如果用户没有提供梯度，则使用一阶差分法估算。即使必须估算梯度，Broyden-Fletcher-Goldfarb-Shanno（BFGS）方法通常比单纯形法需要更少的函数调用。
- en: 'To demonstrate this algorithm, the Rosenbrock function is again used. The gradient
    of the Rosenbrock function is the vector:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个算法，再次使用了Rosenbrock函数。Rosenbrock函数的梯度是以下向量：
- en: \begin{eqnarray*} \frac{\partial f}{\partial x_{j}} & = & \sum_{i=1}^{N}200\left(x_{i}-x_{i-1}^{2}\right)\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-2\left(1-x_{i-1}\right)\delta_{i-1,j}.\\
    & = & 200\left(x_{j}-x_{j-1}^{2}\right)-400x_{j}\left(x_{j+1}-x_{j}^{2}\right)-2\left(1-x_{j}\right).\end{eqnarray*}
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \frac{\partial f}{\partial x_{j}} & = & \sum_{i=1}^{N}200\left(x_{i}-x_{i-1}^{2}\right)\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-2\left(1-x_{i-1}\right)\delta_{i-1,j}.\\
    & = & 200\left(x_{j}-x_{j-1}^{2}\right)-400x_{j}\left(x_{j+1}-x_{j}^{2}\right)-2\left(1-x_{j}\right).\end{eqnarray*}
- en: This expression is valid for the interior derivatives. Special cases are
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式对内部导数是有效的。特殊情况包括
- en: \begin{eqnarray*} \frac{\partial f}{\partial x_{0}} & = & -400x_{0}\left(x_{1}-x_{0}^{2}\right)-2\left(1-x_{0}\right),\\
    \frac{\partial f}{\partial x_{N-1}} & = & 200\left(x_{N-1}-x_{N-2}^{2}\right).\end{eqnarray*}
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \frac{\partial f}{\partial x_{0}} & = & -400x_{0}\left(x_{1}-x_{0}^{2}\right)-2\left(1-x_{0}\right),\\
    \frac{\partial f}{\partial x_{N-1}} & = & 200\left(x_{N-1}-x_{N-2}^{2}\right).\end{eqnarray*}
- en: 'A Python function which computes this gradient is constructed by the code-segment:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码段构建一个计算此梯度的Python函数：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This gradient information is specified in the [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function through the `jac` parameter as illustrated
    below.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些梯度信息在[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")函数中通过`jac`参数指定，如下所示。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Avoiding Redundant Calculation](#id24)'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[避免冗余计算](#id24)'
- en: It is common for the objective function and its gradient to share parts of the
    calculation. For instance, consider the following problem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数及其梯度共享部分计算是常见的。例如，考虑以下问题。
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, `expensive` is called 12 times: six times in the objective function and
    six times from the gradient. One way of reducing redundant calculations is to
    create a single function that returns both the objective function and the gradient.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`expensive` 被调用了12次：在目标函数中六次，在梯度中六次。减少冗余计算的一种方法是创建一个返回目标函数和梯度的单一函数。
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we call minimize, we specify `jac==True` to indicate that the provided
    function returns both the objective function and its gradient. While convenient,
    not all [`scipy.optimize`](../reference/optimize.html#module-scipy.optimize "scipy.optimize")
    functions support this feature, and moreover, it is only for sharing calculations
    between the function and its gradient, whereas in some problems we will want to
    share calculations with the Hessian (second derivative of the objective function)
    and constraints. A more general approach is to memoize the expensive parts of
    the calculation. In simple situations, this can be accomplished with the [`functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache
    "(in Python v3.12)") wrapper.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用minimize时，指定`jac==True`表示提供的函数返回目标函数及其梯度。虽然方便，但并非所有[`scipy.optimize`](../reference/optimize.html#module-scipy.optimize
    "scipy.optimize")函数都支持此功能，而且仅适用于在函数和其梯度之间共享计算，而在某些问题中，我们可能需要在Hessian（目标函数的二阶导数）和约束之间共享计算。更一般的方法是对计算的昂贵部分进行缓存。在简单情况下，可以使用[`functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache
    "(in Python v3.12)")包装器实现。
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Newton-Conjugate-Gradient algorithm (`method=''Newton-CG''`)](#id25)'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Newton-Conjugate-Gradient算法（`method=''Newton-CG''`）](#id25)'
- en: 'Newton-Conjugate Gradient algorithm is a modified Newton’s method and uses
    a conjugate gradient algorithm to (approximately) invert the local Hessian [[NW]](#nw).
    Newton’s method is based on fitting the function locally to a quadratic form:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Newton-Conjugate Gradient算法是改进的Newton方法，使用共轭梯度算法（近似）求解局部Hessian矩阵的逆[[NW]](#nw)。Newton方法基于将函数局部拟合为二次型：
- en: \[f\left(\mathbf{x}\right)\approx f\left(\mathbf{x}_{0}\right)+\nabla f\left(\mathbf{x}_{0}\right)\cdot\left(\mathbf{x}-\mathbf{x}_{0}\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}_{0}\right)^{T}\mathbf{H}\left(\mathbf{x}_{0}\right)\left(\mathbf{x}-\mathbf{x}_{0}\right).\]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: \[f\left(\mathbf{x}\right)\approx f\left(\mathbf{x}_{0}\right)+\nabla f\left(\mathbf{x}_{0}\right)\cdot\left(\mathbf{x}-\mathbf{x}_{0}\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}_{0}\right)^{T}\mathbf{H}\left(\mathbf{x}_{0}\right)\left(\mathbf{x}-\mathbf{x}_{0}\right).\]
- en: where \(\mathbf{H}\left(\mathbf{x}_{0}\right)\) is a matrix of second-derivatives
    (the Hessian). If the Hessian is positive definite then the local minimum of this
    function can be found by setting the gradient of the quadratic form to zero, resulting
    in
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: where \(\mathbf{H}\left(\mathbf{x}_{0}\right)\) is a matrix of second-derivatives
    (the Hessian). If the Hessian is positive definite then the local minimum of this
    function can be found by setting the gradient of the quadratic form to zero, resulting
    in
- en: \[\mathbf{x}_{\textrm{opt}}=\mathbf{x}_{0}-\mathbf{H}^{-1}\nabla f.\]
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{x}_{\textrm{opt}}=\mathbf{x}_{0}-\mathbf{H}^{-1}\nabla f.\]
- en: The inverse of the Hessian is evaluated using the conjugate-gradient method.
    An example of employing this method to minimizing the Rosenbrock function is given
    below. To take full advantage of the Newton-CG method, a function which computes
    the Hessian must be provided. The Hessian matrix itself does not need to be constructed,
    only a vector which is the product of the Hessian with an arbitrary vector needs
    to be available to the minimization routine. As a result, the user can provide
    either a function to compute the Hessian matrix, or a function to compute the
    product of the Hessian with an arbitrary vector.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: The inverse of the Hessian is evaluated using the conjugate-gradient method.
    An example of employing this method to minimizing the Rosenbrock function is given
    below. To take full advantage of the Newton-CG method, a function which computes
    the Hessian must be provided. The Hessian matrix itself does not need to be constructed,
    only a vector which is the product of the Hessian with an arbitrary vector needs
    to be available to the minimization routine. As a result, the user can provide
    either a function to compute the Hessian matrix, or a function to compute the
    product of the Hessian with an arbitrary vector.
- en: '[Full Hessian example:](#id26)'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Full Hessian example:](#id26)'
- en: The Hessian of the Rosenbrock function is
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: The Hessian of the Rosenbrock function is
- en: \begin{eqnarray*} H_{ij}=\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}}
    & = & 200\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-400x_{i}\left(\delta_{i+1,j}-2x_{i}\delta_{i,j}\right)-400\delta_{i,j}\left(x_{i+1}-x_{i}^{2}\right)+2\delta_{i,j},\\
    & = & \left(202+1200x_{i}^{2}-400x_{i+1}\right)\delta_{i,j}-400x_{i}\delta_{i+1,j}-400x_{i-1}\delta_{i-1,j},\end{eqnarray*}
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} H_{ij}=\frac{\partial^{2}f}{\partial x_{i}\partial x_{j}}
    & = & 200\left(\delta_{i,j}-2x_{i-1}\delta_{i-1,j}\right)-400x_{i}\left(\delta_{i+1,j}-2x_{i}\delta_{i,j}\right)-400\delta_{i,j}\left(x_{i+1}-x_{i}^{2}\right)+2\delta_{i,j},\\
    & = & \left(202+1200x_{i}^{2}-400x_{i+1}\right)\delta_{i,j}-400x_{i}\delta_{i+1,j}-400x_{i-1}\delta_{i-1,j},\end{eqnarray*}
- en: if \(i,j\in\left[1,N-2\right]\) with \(i,j\in\left[0,N-1\right]\) defining the
    \(N\times N\) matrix. Other non-zero entries of the matrix are
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: if \(i,j\in\left[1,N-2\right]\) with \(i,j\in\left[0,N-1\right]\) defining the
    \(N\times N\) matrix. Other non-zero entries of the matrix are
- en: \begin{eqnarray*} \frac{\partial^{2}f}{\partial x_{0}^{2}} & = & 1200x_{0}^{2}-400x_{1}+2,\\
    \frac{\partial^{2}f}{\partial x_{0}\partial x_{1}}=\frac{\partial^{2}f}{\partial
    x_{1}\partial x_{0}} & = & -400x_{0},\\ \frac{\partial^{2}f}{\partial x_{N-1}\partial
    x_{N-2}}=\frac{\partial^{2}f}{\partial x_{N-2}\partial x_{N-1}} & = & -400x_{N-2},\\
    \frac{\partial^{2}f}{\partial x_{N-1}^{2}} & = & 200.\end{eqnarray*}
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} \frac{\partial^{2}f}{\partial x_{0}^{2}} & = & 1200x_{0}^{2}-400x_{1}+2,\\
    \frac{\partial^{2}f}{\partial x_{0}\partial x_{1}}=\frac{\partial^{2}f}{\partial
    x_{1}\partial x_{0}} & = & -400x_{0},\\ \frac{\partial^{2}f}{\partial x_{N-1}\partial
    x_{N-2}}=\frac{\partial^{2}f}{\partial x_{N-2}\partial x_{N-1}} & = & -400x_{N-2},\\
    \frac{\partial^{2}f}{\partial x_{N-1}^{2}} & = & 200.\end{eqnarray*}
- en: For example, the Hessian when \(N=5\) is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: For example, the Hessian when \(N=5\) is
- en: \[\begin{split}\mathbf{H}=\begin{bmatrix} 1200x_{0}^{2}+2\mkern-2em\\&1200x_{1}^{2}+202\mkern-2em\\&&1200x_{1}^{2}+202\mkern-2em\\&&&1200x_{3}^{2}+202\mkern-1em\\&&&&200\end{bmatrix}-400\begin{bmatrix}
    x_1 & x_0 \\ x_0 & x_2 & x_1 \\ & x_1 & x_3 & x_2\\ & & x_2 & x_4 & x_3 \\ & &
    & x_3 & 0\end{bmatrix}.\end{split}\]
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{H}=\begin{bmatrix} 1200x_{0}^{2}+2\mkern-2em\\&1200x_{1}^{2}+202\mkern-2em\\&&1200x_{1}^{2}+202\mkern-2em\\&&&1200x_{3}^{2}+202\mkern-1em\\&&&&200\end{bmatrix}-400\begin{bmatrix}
    x_1 & x_0 \\ x_0 & x_2 & x_1 \\ & x_1 & x_3 & x_2\\ & & x_2 & x_4 & x_3 \\ & &
    & x_3 & 0\end{bmatrix}.\end{split}\]
- en: 'The code which computes this Hessian along with the code to minimize the function
    using Newton-CG method is shown in the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'The code which computes this Hessian along with the code to minimize the function
    using Newton-CG method is shown in the following example:'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Hessian product example:](#id27)'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Hessian product example:](#id27)'
- en: For larger minimization problems, storing the entire Hessian matrix can consume
    considerable time and memory. The Newton-CG algorithm only needs the product of
    the Hessian times an arbitrary vector. As a result, the user can supply code to
    compute this product rather than the full Hessian by giving a `hess` function
    which take the minimization vector as the first argument and the arbitrary vector
    as the second argument (along with extra arguments passed to the function to be
    minimized). If possible, using Newton-CG with the Hessian product option is probably
    the fastest way to minimize the function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的最小化问题，存储整个 Hessian 矩阵可能会消耗大量时间和内存。Newton-CG 算法仅需 Hessian 与任意向量的乘积。因此，用户可以提供计算该乘积的代码，而不是完整的
    Hessian 矩阵，方法是通过提供一个 `hess` 函数，该函数将最小化向量作为第一个参数，任意向量作为第二个参数（以及传递给要最小化函数的额外参数）。如果可能，使用具有
    Hessian 乘积选项的 Newton-CG 可能是最快的最小化函数的方式。
- en: 'In this case, the product of the Rosenbrock Hessian with an arbitrary vector
    is not difficult to compute. If \(\mathbf{p}\) is the arbitrary vector, then \(\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}\)
    has elements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用 Rosenbrock Hessian 乘以任意向量的乘积并不难计算。如果 \(\mathbf{p}\) 是任意向量，则 \(\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}\)
    的元素为：
- en: \[\begin{split}\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}=\begin{bmatrix} \left(1200x_{0}^{2}-400x_{1}+2\right)p_{0}-400x_{0}p_{1}\\
    \vdots\\ -400x_{i-1}p_{i-1}+\left(202+1200x_{i}^{2}-400x_{i+1}\right)p_{i}-400x_{i}p_{i+1}\\
    \vdots\\ -400x_{N-2}p_{N-2}+200p_{N-1}\end{bmatrix}.\end{split}\]
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\mathbf{H}\left(\mathbf{x}\right)\mathbf{p}=\begin{bmatrix} \left(1200x_{0}^{2}-400x_{1}+2\right)p_{0}-400x_{0}p_{1}\\
    \vdots\\ -400x_{i-1}p_{i-1}+\left(202+1200x_{i}^{2}-400x_{i+1}\right)p_{i}-400x_{i}p_{i+1}\\
    \vdots\\ -400x_{N-2}p_{N-2}+200p_{N-1}\end{bmatrix}.\end{split}\]
- en: 'Code which makes use of this Hessian product to minimize the Rosenbrock function
    using [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") 函数来最小化 Rosenbrock 函数的代码如下：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: According to [[NW]](#nw) p. 170 the `Newton-CG` algorithm can be inefficient
    when the Hessian is ill-conditioned because of the poor quality search directions
    provided by the method in those situations. The method `trust-ncg`, according
    to the authors, deals more effectively with this problematic situation and will
    be described next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [[NW]](#nw) 第 170 页，当 Hessian 矩阵条件差时，`Newton-CG` 算法可能效率低下，因为在这些情况下方法提供的搜索方向质量较差。作者表示，`trust-ncg`
    方法更有效地处理这种问题情况，并将在下文中详细描述。
- en: '[Trust-Region Newton-Conjugate-Gradient Algorithm (`method=''trust-ncg''`)](#id28)'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Trust-Region Newton-Conjugate-Gradient Algorithm (`method=''trust-ncg''`)](#id28)'
- en: 'The `Newton-CG` method is a line search method: it finds a direction of search
    minimizing a quadratic approximation of the function and then uses a line search
    algorithm to find the (nearly) optimal step size in that direction. An alternative
    approach is to, first, fix the step size limit \(\Delta\) and then find the optimal
    step \(\mathbf{p}\) inside the given trust-radius by solving the following quadratic
    subproblem:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Newton-CG` 方法是一种线搜索方法：它找到一个搜索方向，最小化函数的二次近似，然后使用一种线搜索算法在该方向上找到（几乎）最优的步长。另一种方法是先固定步长限制
    \(\Delta\)，然后通过解以下二次子问题找到给定信赖半径内的最优步 \(\mathbf{p}\)：'
- en: '\begin{eqnarray*} \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&\\
    \text{subject to: } \|\mathbf{p}\|\le \Delta.& \end{eqnarray*}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '\begin{eqnarray*} \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&\\
    \text{subject to: } \|\mathbf{p}\|\le \Delta.& \end{eqnarray*}'
- en: The solution is then updated \(\mathbf{x}_{k+1} = \mathbf{x}_{k} + \mathbf{p}\)
    and the trust-radius \(\Delta\) is adjusted according to the degree of agreement
    of the quadratic model with the real function. This family of methods is known
    as trust-region methods. The `trust-ncg` algorithm is a trust-region method that
    uses a conjugate gradient algorithm to solve the trust-region subproblem [[NW]](#nw).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解被更新为 \(\mathbf{x}_{k+1} = \mathbf{x}_{k} + \mathbf{p}\)，并且信赖半径 \(\Delta\) 根据二次模型与实际函数的一致程度进行调整。这类方法被称为信赖域方法。`trust-ncg`
    算法是一种信赖域方法，它使用共轭梯度算法来解决信赖域子问题 [[NW]](#nw)。
- en: '[Full Hessian example:](#id29)'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Full Hessian example:](#id29)'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Hessian product example:](#id30)'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Hessian product example:](#id30)'
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm
    (`method=''trust-krylov''`)](#id31)'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Trust-Region Truncated Generalized Lanczos / Conjugate Gradient Algorithm
    (`method=''trust-krylov''`)](#id31)'
- en: Similar to the `trust-ncg` method, the `trust-krylov` method is a method suitable
    for large-scale problems as it uses the hessian only as linear operator by means
    of matrix-vector products. It solves the quadratic subproblem more accurately
    than the `trust-ncg` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与`trust-ncg`方法类似，`trust-krylov`方法适用于大规模问题，因为它只使用海森矩阵作为线性操作符，通过矩阵-向量乘积来解决二次子问题。它比`trust-ncg`方法更准确地解决了二次子问题。
- en: '\begin{eqnarray*} \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&\\
    \text{subject to: } \|\mathbf{p}\|\le \Delta.& \end{eqnarray*}'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '\begin{eqnarray*} \min_{\mathbf{p}} f\left(\mathbf{x}_{k}\right)+\nabla f\left(\mathbf{x}_{k}\right)\cdot\mathbf{p}+\frac{1}{2}\mathbf{p}^{T}\mathbf{H}\left(\mathbf{x}_{k}\right)\mathbf{p};&\\
    \text{subject to: } \|\mathbf{p}\|\le \Delta.& \end{eqnarray*}'
- en: This method wraps the [[TRLIB]](#trlib) implementation of the [[GLTR]](#gltr)
    method solving exactly a trust-region subproblem restricted to a truncated Krylov
    subspace. For indefinite problems it is usually better to use this method as it
    reduces the number of nonlinear iterations at the expense of few more matrix-vector
    products per subproblem solve in comparison to the `trust-ncg` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用[[TRLIB]](#trlib)实现了[[GLTR]](#gltr)方法，精确求解了限制在截断Krylov子空间中的信任域子问题。对于不定问题，使用该方法通常更好，因为它减少了非线性迭代的次数，而在每个子问题求解中增加了少量的矩阵-向量乘积。
- en: '[Full Hessian example:](#id32)'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Full Hessian example:](#id32)'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Hessian product example:](#id33)'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[Hessian product example:](#id33)'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[[TRLIB](#id6)]'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[[TRLIB](#id6)]'
- en: 'F. Lenders, C. Kirches, A. Potschka: “trlib: A vector-free implementation of
    the GLTR method for iterative solution of the trust region problem”, [arXiv:1611.04718](https://arxiv.org/abs/1611.04718)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'F. Lenders, C. Kirches, A. Potschka：“trlib: A vector-free implementation of
    the GLTR method for iterative solution of the trust region problem”, [arXiv:1611.04718](https://arxiv.org/abs/1611.04718)'
- en: '[[GLTR](#id7)]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[[GLTR](#id7)]'
- en: 'N. Gould, S. Lucidi, M. Roma, P. Toint: “Solving the Trust-Region Subproblem
    using the Lanczos Method”, SIAM J. Optim., 9(2), 504–525, (1999). [DOI:10.1137/S1052623497322735](https://doi.org/10.1137/S1052623497322735)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: N. Gould, S. Lucidi, M. Roma, P. Toint：“Solving the Trust-Region Subproblem
    using the Lanczos Method”, SIAM J. Optim., 9(2), 504–525, (1999). [DOI:10.1137/S1052623497322735](https://doi.org/10.1137/S1052623497322735)
- en: '[Trust-Region Nearly Exact Algorithm (`method=''trust-exact''`)](#id34)'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[Trust-Region Nearly Exact Algorithm (`method=''trust-exact''`)](#id34)'
- en: All methods `Newton-CG`, `trust-ncg` and `trust-krylov` are suitable for dealing
    with large-scale problems (problems with thousands of variables). That is because
    the conjugate gradient algorithm approximately solve the trust-region subproblem
    (or invert the Hessian) by iterations without the explicit Hessian factorization.
    Since only the product of the Hessian with an arbitrary vector is needed, the
    algorithm is specially suited for dealing with sparse Hessians, allowing low storage
    requirements and significant time savings for those sparse problems.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法`Newton-CG`，`trust-ncg`和`trust-krylov`都适用于处理大规模问题（具有数千个变量的问题）。这是因为共轭梯度算法通过迭代近似地解决信任域子问题（或反转海森矩阵），而不需要显式的海森矩阵分解。由于只需海森矩阵与任意向量的乘积，因此该算法特别适用于处理稀疏海森矩阵，从而实现低存储需求和在这些稀疏问题中显著的时间节省。
- en: 'For medium-size problems, for which the storage and factorization cost of the
    Hessian are not critical, it is possible to obtain a solution within fewer iteration
    by solving the trust-region subproblems almost exactly. To achieve that, a certain
    nonlinear equations is solved iteratively for each quadratic subproblem [[CGT]](#cgt).
    This solution requires usually 3 or 4 Cholesky factorizations of the Hessian matrix.
    As the result, the method converges in fewer number of iterations and takes fewer
    evaluations of the objective function than the other implemented trust-region
    methods. The Hessian product option is not supported by this algorithm. An example
    using the Rosenbrock function follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中等大小的问题，其中海森矩阵的存储和分解成本并不关键，通过几乎精确地求解信任域子问题，可以在较少的迭代次数内获得解决方案。为了实现这一点，对每个二次子问题进行了某些非线性方程的迭代求解
    [[CGT]](#cgt)。这种解决方案通常需要对海森矩阵进行3到4次乔列斯基分解。因此，该方法收敛的迭代次数较少，并且比其他实现的信任域方法需要更少的目标函数评估。该算法不支持海森乘积选项。以下是使用Rosenbrock函数的示例：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[NW] ([1](#id1),[2](#id2),[3](#id3))'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[NW] ([1](#id1),[2](#id2),[3](#id3))'
- en: J. Nocedal, S.J. Wright “Numerical optimization.” 2nd edition. Springer Science
    (2006).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: J. Nocedal, S.J. Wright：“Numerical optimization.” 第2版. Springer Science (2006).
- en: '[[CGT](#id10)]'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[[CGT](#id10)]'
- en: Conn, A. R., Gould, N. I., & Toint, P. L. “Trust region methods”. Siam. (2000).
    pp. 169-200.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 康恩, A. R., 戈尔德, N. I., & 琼特, P. L. “信赖域方法”. Siam. (2000). pp. 169-200.
- en: '## [Constrained minimization of multivariate scalar functions (](#id35)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '## [多变量标量函数的约束最小化 (](#id35)[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize"))'
- en: The [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function provides algorithms for constrained minimization,
    namely `'trust-constr'` , `'SLSQP'` and `'COBYLA'`. They require the constraints
    to be defined using slightly different structures. The method `'trust-constr'`
    requires the constraints to be defined as a sequence of objects [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") and [`NonlinearConstraint`](../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint"). Methods `'SLSQP'` and `'COBYLA'`, on the
    other hand, require constraints to be defined as a sequence of dictionaries, with
    keys `type`, `fun` and `jac`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") 函数提供了约束最小化的算法，即 `''trust-constr''` 、 `''SLSQP''` 和
    `''COBYLA''` 。它们要求约束使用稍微不同的结构定义。 `''trust-constr''` 方法要求约束以 [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") 和 [`NonlinearConstraint`](../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint") 对象序列的形式给出。另一方面， `''SLSQP''` 和 `''COBYLA''`
    方法要求约束以字典序列的形式给出，其中包括 `type` 、 `fun` 和 `jac` 键。'
- en: 'As an example let us consider the constrained minimization of the Rosenbrock
    function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑对Rosenbrock函数的约束最小化：
- en: '\begin{eqnarray*} \min_{x_0, x_1} & ~~100\left(x_{1}-x_{0}^{2}\right)^{2}+\left(1-x_{0}\right)^{2}
    &\\ \text{subject to: } & x_0 + 2 x_1 \leq 1 & \\ & x_0^2 + x_1 \leq 1 & \\ &
    x_0^2 - x_1 \leq 1 & \\ & 2 x_0 + x_1 = 1 & \\ & 0 \leq x_0 \leq 1 & \\ & -0.5
    \leq x_1 \leq 2.0\. & \end{eqnarray*}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '\begin{eqnarray*} \min_{x_0, x_1} & ~~100\left(x_{1}-x_{0}^{2}\right)^{2}+\left(1-x_{0}\right)^{2}
    &\\ \text{subject to: } & x_0 + 2 x_1 \leq 1 & \\ & x_0^2 + x_1 \leq 1 & \\ &
    x_0^2 - x_1 \leq 1 & \\ & 2 x_0 + x_1 = 1 & \\ & 0 \leq x_0 \leq 1 & \\ & -0.5
    \leq x_1 \leq 2.0\. & \end{eqnarray*}'
- en: This optimization problem has the unique solution \([x_0, x_1] = [0.4149,~ 0.1701]\),
    for which only the first and fourth constraints are active.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该优化问题有唯一解 \([x_0, x_1] = [0.4149,~ 0.1701]\)，其中仅第一和第四个约束是活动约束。
- en: '[Trust-Region Constrained Algorithm (`method=''trust-constr''`)](#id36)'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[信赖域约束算法 (`method=''trust-constr''`)](#id36)'
- en: 'The trust-region constrained method deals with constrained minimization problems
    of the form:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 信赖域约束方法处理以下形式的约束最小化问题：
- en: '\begin{eqnarray*} \min_x & f(x) & \\ \text{subject to: } & ~~~ c^l \leq c(x)
    \leq c^u, &\\ & x^l \leq x \leq x^u. & \end{eqnarray*}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '\begin{eqnarray*} \min_x & f(x) & \\ \text{subject to: } & ~~~ c^l \leq c(x)
    \leq c^u, &\\ & x^l \leq x \leq x^u. & \end{eqnarray*}'
- en: When \(c^l_j = c^u_j\) the method reads the \(j\)-th constraint as an equality
    constraint and deals with it accordingly. Besides that, one-sided constraint can
    be specified by setting the upper or lower bound to `np.inf` with the appropriate
    sign.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当 \(c^l_j = c^u_j\) 时，该方法将第 \(j\) 个约束视为等式约束，并相应处理。此外，通过将上界或下界设置为 `np.inf` 和适当的符号，可以指定单侧约束。
- en: The implementation is based on [[EQSQP]](#eqsqp) for equality-constraint problems
    and on [[TRIP]](#trip) for problems with inequality constraints. Both are trust-region
    type algorithms suitable for large-scale problems.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现基于 [[EQSQP]](#eqsqp) 用于等式约束问题和 [[TRIP]](#trip) 用于不等式约束问题。这两种方法都是适用于大规模问题的信赖域类型算法。
- en: '[Defining Bounds Constraints:](#id37)'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[定义边界约束：](#id37)'
- en: The bound constraints \(0 \leq x_0 \leq 1\) and \(-0.5 \leq x_1 \leq 2.0\) are
    defined using a [`Bounds`](../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds") object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 边界约束 \(0 \leq x_0 \leq 1\) 和 \(-0.5 \leq x_1 \leq 2.0\) 使用 [`Bounds`](../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds") 对象定义。
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Defining Linear Constraints:](#id38)'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[定义线性约束：](#id38)'
- en: 'The constraints \(x_0 + 2 x_1 \leq 1\) and \(2 x_0 + x_1 = 1\) can be written
    in the linear constraint standard format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 约束 \(x_0 + 2 x_1 \leq 1\) 和 \(2 x_0 + x_1 = 1\) 可以用线性约束标准格式写成：
- en: \begin{equation*} \begin{bmatrix}-\infty \\1\end{bmatrix} \leq \begin{bmatrix}
    1& 2 \\ 2& 1\end{bmatrix} \begin{bmatrix} x_0 \\x_1\end{bmatrix} \leq \begin{bmatrix}
    1 \\ 1\end{bmatrix},\end{equation*}
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} \begin{bmatrix}-\infty \\1\end{bmatrix} \leq \begin{bmatrix}
    1& 2 \\ 2& 1\end{bmatrix} \begin{bmatrix} x_0 \\x_1\end{bmatrix} \leq \begin{bmatrix}
    1 \\ 1\end{bmatrix},\end{equation*}
- en: and defined using a [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用 [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") 对象定义。
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Defining Nonlinear Constraints:](#id39)'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[定义非线性约束:](#id39)'
- en: 'The nonlinear constraint:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性约束：
- en: \begin{equation*} c(x) = \begin{bmatrix} x_0^2 + x_1 \\ x_0^2 - x_1\end{bmatrix}
    \leq \begin{bmatrix} 1 \\ 1\end{bmatrix}, \end{equation*}
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} c(x) = \begin{bmatrix} x_0^2 + x_1 \\ x_0^2 - x_1\end{bmatrix}
    \leq \begin{bmatrix} 1 \\ 1\end{bmatrix}, \end{equation*}
- en: 'with Jacobian matrix:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 Jacobian 矩阵为：
- en: \begin{equation*} J(x) = \begin{bmatrix} 2x_0 & 1 \\ 2x_0 & -1\end{bmatrix},\end{equation*}
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} J(x) = \begin{bmatrix} 2x_0 & 1 \\ 2x_0 & -1\end{bmatrix},\end{equation*}
- en: 'and linear combination of the Hessians:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Hessian 的线性组合：
- en: \begin{equation*} H(x, v) = \sum_{i=0}^1 v_i \nabla^2 c_i(x) = v_0\begin{bmatrix}
    2 & 0 \\ 0 & 0\end{bmatrix} + v_1\begin{bmatrix} 2 & 0 \\ 0 & 0\end{bmatrix},
    \end{equation*}
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} H(x, v) = \sum_{i=0}^1 v_i \nabla^2 c_i(x) = v_0\begin{bmatrix}
    2 & 0 \\ 0 & 0\end{bmatrix} + v_1\begin{bmatrix} 2 & 0 \\ 0 & 0\end{bmatrix},
    \end{equation*}
- en: is defined using a [`NonlinearConstraint`](../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint") object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`NonlinearConstraint`](../reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint") 对象定义。
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Alternatively, it is also possible to define the Hessian \(H(x, v)\) as a sparse
    matrix,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以将 Hessian \(H(x, v)\) 定义为稀疏矩阵。
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or as a [`LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或作为 [`LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") 对象定义。
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the evaluation of the Hessian \(H(x, v)\) is difficult to implement or
    computationally infeasible, one may use [`HessianUpdateStrategy`](../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy"). Currently available strategies are [`BFGS`](../reference/generated/scipy.optimize.BFGS.html#scipy.optimize.BFGS
    "scipy.optimize.BFGS") and [`SR1`](../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1
    "scipy.optimize.SR1").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估 Hessian \(H(x, v)\) 难以实现或计算上不可行时，可以使用 [`HessianUpdateStrategy`](../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy")。目前可用的策略有 [`BFGS`](../reference/generated/scipy.optimize.BFGS.html#scipy.optimize.BFGS
    "scipy.optimize.BFGS") 和 [`SR1`](../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1
    "scipy.optimize.SR1")。
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Alternatively, the Hessian may be approximated using finite differences.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过有限差分来近似 Hessian。
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Jacobian of the constraints can be approximated by finite differences as
    well. In this case, however, the Hessian cannot be computed with finite differences
    and needs to be provided by the user or defined using [`HessianUpdateStrategy`](../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy").
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的 Jacobian 也可以通过有限差分来近似。然而，在这种情况下，Hessian 不能通过有限差分来计算，需要用户提供或使用 [`HessianUpdateStrategy`](../reference/generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") 定义。
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Solving the Optimization Problem:](#id40)'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[解决优化问题:](#id40)'
- en: 'The optimization problem is solved using:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的解决方法为：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When needed, the objective function Hessian can be defined using a [`LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") object,
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，可以使用 [`LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") 对象定义目标函数的 Hessian，
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: or a Hessian-vector product through the parameter `hessp`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过参数 `hessp` 实现 Hessian-向量乘积。
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Alternatively, the first and second derivatives of the objective function can
    be approximated. For instance, the Hessian can be approximated with [`SR1`](../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1
    "scipy.optimize.SR1") quasi-Newton approximation and the gradient with finite
    differences.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以近似计算目标函数的一阶和二阶导数。例如，可以用[`SR1`](../reference/generated/scipy.optimize.SR1.html#scipy.optimize.SR1
    "scipy.optimize.SR1")拟牛顿逼近法近似计算Hessian矩阵，用有限差分法近似计算梯度。
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[[TRIP](#id12)]'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[[旅行](#id12)]'
- en: 'Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999. An interior point
    algorithm for large-scale nonlinear programming. SIAM Journal on Optimization
    9.4: 877-900.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999. An interior point
    algorithm for large-scale nonlinear programming. SIAM Journal on Optimization
    9.4: 877-900.'
- en: '[[EQSQP](#id11)]'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[[EQSQP](#id11)]'
- en: 'Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998\. On the implementation
    of an algorithm for large-scale equality constrained optimization. SIAM Journal
    on Optimization 8.3: 682-706.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998\. On the implementation
    of an algorithm for large-scale equality constrained optimization. SIAM Journal
    on Optimization 8.3: 682-706.'
- en: '[Sequential Least SQuares Programming (SLSQP) Algorithm (`method=''SLSQP''`)](#id41)'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[顺序最小二乘规划（SLSQP）算法（`method=''SLSQP''`）](#id41)'
- en: 'The SLSQP method deals with constrained minimization problems of the form:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SLSQP方法处理形如以下约束极小化问题：
- en: '\begin{eqnarray*} \min_x & f(x) \\ \text{subject to: } & c_j(x) = 0 , &j \in
    \mathcal{E}\\ & c_j(x) \geq 0 , &j \in \mathcal{I}\\ & \text{lb}_i \leq x_i \leq
    \text{ub}_i , &i = 1,...,N. \end{eqnarray*}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '\begin{eqnarray*} \min_x & f(x) \\ \text{subject to: } & c_j(x) = 0 , &j \in
    \mathcal{E}\\ & c_j(x) \geq 0 , &j \in \mathcal{I}\\ & \text{lb}_i \leq x_i \leq
    \text{ub}_i , &i = 1,...,N. \end{eqnarray*}'
- en: Where \(\mathcal{E}\) or \(\mathcal{I}\) are sets of indices containing equality
    and inequality constraints.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(\mathcal{E}\)或\(\mathcal{I}\)是包含等式和不等式约束的索引集合。
- en: Both linear and nonlinear constraints are defined as dictionaries with keys
    `type`, `fun` and `jac`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 线性和非线性约束都被定义为带有`type`、`fun`和`jac`键的字典。
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the optimization problem is solved with:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的求解方式为：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Most of the options available for the method `'trust-constr'` are not available
    for `'SLSQP'`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数适用于方法`'trust-constr'`的选项对`'SLSQP'`不可用。
- en: '[Global optimization](#id42)'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[全局优化](#id42)'
- en: 'Global optimization aims to find the global minimum of a function within given
    bounds, in the presence of potentially many local minima. Typically, global minimizers
    efficiently search the parameter space, while using a local minimizer (e.g., [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")) under the hood. SciPy contains a number of good global
    optimizers. Here, we’ll use those on the same objective function, namely the (aptly
    named) `eggholder` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 全局优化旨在在给定边界内找到函数的全局最小值，在可能存在许多局部最小值的情况下。通常情况下，全局最小化器能有效地搜索参数空间，同时在底层使用局部最小化器（例如[`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")）。SciPy包含多种优秀的全局优化器。在这里，我们将在相同的目标函数上使用它们，即（恰当命名的）`eggholder`函数：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This function looks like an egg carton:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数看起来像一个蛋盒：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '!["A 3-D plot shown from a three-quarter view. The function is very noisy with
    dozens of valleys and peaks. There is no clear min or max discernible from this
    view and it''s not possible to see all the local peaks and valleys from this view."](../Images/f00875f602e0f9af927431623e84f19c.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '!["从三分之一的视角显示的三维图。该函数非常嘈杂，有数十个山谷和峰顶。从这个视角不可能清晰地看到最小值或最大值，并且不可能从这个视角看到所有局部山谷和峰顶。"](../Images/f00875f602e0f9af927431623e84f19c.png)'
- en: We now use the global optimizers to obtain the minimum and the function value
    at the minimum. We’ll store the results in a dictionary so we can compare different
    optimization results later.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用全局优化器来获取最小值及其处的函数值。我们将结果存储在字典中，以便稍后比较不同的优化结果。
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'All optimizers return an `OptimizeResult`, which in addition to the solution
    contains information on the number of function evaluations, whether the optimization
    was successful, and more. For brevity, we won’t show the full output of the other
    optimizers:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优化器返回一个`OptimizeResult`，除了解决方案外，还包含有关函数评估次数、优化是否成功等信息。为简洁起见，我们不会显示其他优化器的完整输出：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[`shgo`](../reference/generated/scipy.optimize.shgo.html#scipy.optimize.shgo
    "scipy.optimize.shgo") has a second method, which returns all local minima rather
    than only what it thinks is the global minimum:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[`shgo`](../reference/generated/scipy.optimize.shgo.html#scipy.optimize.shgo
    "scipy.optimize.shgo")还有第二种方法，它返回所有局部最小值，而不仅仅是它认为的全局最小值：'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We’ll now plot all found minima on a heatmap of the function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将所有找到的最小值绘制在函数的热图上：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '!["This X-Y plot is a heatmap with the Z value denoted with the lowest points
    as black and the highest values as white. The image resembles a chess board rotated
    45 degrees but heavily smoothed. A red dot is located at many of the minima on
    the grid resulting from the SHGO optimizer. SHGO shows the global minima as a
    red X in the top right. A local minima found with dual annealing is a white circle
    marker in the top left. A different local minima found with basinhopping is a
    yellow marker in the top center. The code is plotting the differential evolution
    result as a cyan circle, but it is not visible on the plot. At a glance it''s
    not clear which of these valleys is the true global minima."](../Images/0809f14215273ae4249636368e116991.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '!["这个 X-Y 图是一个热图，Z 值用最低点为黑色，最高值为白色表示。图像类似于旋转了 45 度但严重平滑的棋盘格。一个红色的点位于由 SHGO
    优化器产生的许多最小值格点上。SHGO 在右上角显示全局最小值为红色 X。用双退火找到的局部最小值为左上角的白色圆形标记。用盆地跳跃找到的另一个局部最小值为顶部中心的黄色标记。代码正在绘制差分进化结果作为青色圆圈，但在图上看不见。乍一看不清楚哪个山谷是真正的全局最小值。"](../Images/0809f14215273ae4249636368e116991.png)'
- en: '[Least-squares minimization (](#id43)[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares"))'
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[最小二乘最小化（](#id43)[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares"))'
- en: 'SciPy is capable of solving robustified bound-constrained nonlinear least-squares
    problems:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 能够解决鲁棒的有界非线性最小二乘问题：
- en: \begin{align} &\min_\mathbf{x} \frac{1}{2} \sum_{i = 1}^m \rho\left(f_i(\mathbf{x})^2\right)
    \\ &\text{subject to }\mathbf{lb} \leq \mathbf{x} \leq \mathbf{ub} \end{align}
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{align} &\min_\mathbf{x} \frac{1}{2} \sum_{i = 1}^m \rho\left(f_i(\mathbf{x})^2\right)
    \\ &\text{subject to }\mathbf{lb} \leq \mathbf{x} \leq \mathbf{ub} \end{align}
- en: Here \(f_i(\mathbf{x})\) are smooth functions from \(\mathbb{R}^n\) to \(\mathbb{R}\),
    we refer to them as residuals. The purpose of a scalar-valued function \(\rho(\cdot)\)
    is to reduce the influence of outlier residuals and contribute to robustness of
    the solution, we refer to it as a loss function. A linear loss function gives
    a standard least-squares problem. Additionally, constraints in a form of lower
    and upper bounds on some of \(x_j\) are allowed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 \( f_i(\mathbf{x}) \) 是从 \( \mathbb{R}^n \) 到 \( \mathbb{R} \) 的光滑函数，我们称之为残差。标量函数
    \( \rho(\cdot) \) 的目的是减少异常残差的影响，并有助于解的鲁棒性，我们称之为损失函数。线性损失函数给出了标准的最小二乘问题。此外，允许对某些
    \( x_j \) 设置下界和上界的约束。
- en: All methods specific to least-squares minimization utilize a \(m \times n\)
    matrix of partial derivatives called Jacobian and defined as \(J_{ij} = \partial
    f_i / \partial x_j\). It is highly recommended to compute this matrix analytically
    and pass it to [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares"), otherwise, it will be estimated by finite differences,
    which takes a lot of additional time and can be very inaccurate in hard cases.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有特定于最小二乘最小化的方法都利用一个 \( m \times n \) 的偏导数矩阵，称为雅可比矩阵，定义为 \( J_{ij} = \partial
    f_i / \partial x_j \)。强烈建议通过解析方式计算此矩阵并传递给 [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")，否则将通过有限差分法估计，这将耗费大量额外时间，并且在复杂情况下可能非常不准确。
- en: Function [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") can be used for fitting a function \(\varphi(t;
    \mathbf{x})\) to empirical data \(\{(t_i, y_i), i = 0, \ldots, m-1\}\). To do
    this, one should simply precompute residuals as \(f_i(\mathbf{x}) = w_i (\varphi(t_i;
    \mathbf{x}) - y_i)\), where \(w_i\) are weights assigned to each observation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") 可用于将函数 \(\varphi(t; \mathbf{x})\) 拟合到经验数据 \(\{(t_i,
    y_i), i = 0, \ldots, m-1\}\)。为此，只需预先计算残差如 \( f_i(\mathbf{x}) = w_i (\varphi(t_i;
    \mathbf{x}) - y_i) \)，其中 \( w_i \) 是分配给每个观测值的权重。
- en: '[Example of solving a fitting problem](#id44)'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[解决拟合问题的示例](#id44)'
- en: Here we consider an enzymatic reaction [[1]](#id15). There are 11 residuals
    defined as
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们考虑一个酶反应 [[1]](#id15)。定义了 11 个残差为
- en: \[f_i(x) = \frac{x_0 (u_i^2 + u_i x_1)}{u_i^2 + u_i x_2 + x_3} - y_i, \quad
    i = 0, \ldots, 10,\]
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f_i(x) = \frac{x_0 (u_i^2 + u_i x_1)}{u_i^2 + u_i x_2 + x_3} - y_i, \quad
    i = 0, \ldots, 10, \]
- en: 'where \(y_i\) are measurement values and \(u_i\) are values of the independent
    variable. The unknown vector of parameters is \(\mathbf{x} = (x_0, x_1, x_2, x_3)^T\).
    As was said previously, it is recommended to compute Jacobian matrix in a closed
    form:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(y_i\)是测量值，\(u_i\)是自变量值。未知参数向量为\(\mathbf{x} = (x_0, x_1, x_2, x_3)^T\)。如前所述，建议以闭合形式计算雅可比矩阵：
- en: \begin{align} &J_{i0} = \frac{\partial f_i}{\partial x_0} = \frac{u_i^2 + u_i
    x_1}{u_i^2 + u_i x_2 + x_3} \\ &J_{i1} = \frac{\partial f_i}{\partial x_1} = \frac{u_i
    x_0}{u_i^2 + u_i x_2 + x_3} \\ &J_{i2} = \frac{\partial f_i}{\partial x_2} = -\frac{x_0
    (u_i^2 + u_i x_1) u_i}{(u_i^2 + u_i x_2 + x_3)^2} \\ &J_{i3} = \frac{\partial
    f_i}{\partial x_3} = -\frac{x_0 (u_i^2 + u_i x_1)}{(u_i^2 + u_i x_2 + x_3)^2}
    \end{align}
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{align} &J_{i0} = \frac{\partial f_i}{\partial x_0} = \frac{u_i^2 + u_i
    x_1}{u_i^2 + u_i x_2 + x_3} \\ &J_{i1} = \frac{\partial f_i}{\partial x_1} = \frac{u_i
    x_0}{u_i^2 + u_i x_2 + x_3} \\ &J_{i2} = \frac{\partial f_i}{\partial x_2} = -\frac{x_0
    (u_i^2 + u_i x_1) u_i}{(u_i^2 + u_i x_2 + x_3)^2} \\ &J_{i3} = \frac{\partial
    f_i}{\partial x_3} = -\frac{x_0 (u_i^2 + u_i x_1)}{(u_i^2 + u_i x_2 + x_3)^2}
    \end{align}
- en: We are going to use the “hard” starting point defined in [[2]](#id16). To find
    a physically meaningful solution, avoid potential division by zero and assure
    convergence to the global minimum we impose constraints \(0 \leq x_j \leq 100,
    j = 0, 1, 2, 3\).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[[2]](#id16)中定义的“难点”起始点。为了找到物理上有意义的解，避免可能的除零，并确保收敛到全局最小值，我们施加约束条件\(0 \leq
    x_j \leq 100, j = 0, 1, 2, 3\)。
- en: 'The code below implements least-squares estimation of \(\mathbf{x}\) and finally
    plots the original data and the fitted model function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码实现了对\(\mathbf{x}\)的最小二乘估计，并最终绘制了原始数据和拟合的模型函数：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '!["This code plots an X-Y time-series. The series starts in the lower left
    at (0, 0) and rapidly trends up to the maximum of 0.2 then flattens out. The fitted
    model is shown as a smooth orange trace and is well fit to the data."](../Images/d7351b0461faa8d2d74c1fec2f2ac2fc.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '!["此代码绘制了一个X-Y时间序列。该序列从左下角的(0, 0)开始，迅速趋向最大值0.2，然后趋于平缓。拟合模型显示为平滑的橙色曲线，与数据非常匹配。"](../Images/d7351b0461faa8d2d74c1fec2f2ac2fc.png)'
- en: '[Further examples](#id45)'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[更多示例](#id45)'
- en: Three interactive examples below illustrate usage of [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") in greater detail.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的三个互动示例详细说明了如何使用[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")。
- en: '[Large-scale bundle adjustment in scipy](https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html)
    demonstrates large-scale capabilities of [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares") and how to efficiently compute finite difference
    approximation of sparse Jacobian.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Scipy 中的大规模束调整](https://scipy-cookbook.readthedocs.io/items/bundle_adjustment.html)展示了[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")的大规模能力，以及如何高效地计算稀疏雅可比矩阵的有限差分近似。'
- en: '[Robust nonlinear regression in scipy](https://scipy-cookbook.readthedocs.io/items/robust_regression.html)
    shows how to handle outliers with a robust loss function in a nonlinear regression.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Scipy 中的鲁棒非线性回归](https://scipy-cookbook.readthedocs.io/items/robust_regression.html)展示了如何在非线性回归中使用鲁棒损失函数处理异常值。'
- en: '[Solving a discrete boundary-value problem in scipy](https://scipy-cookbook.readthedocs.io/items/discrete_bvp.html)
    examines how to solve a large system of equations and use bounds to achieve desired
    properties of the solution.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Scipy 中解离散边值问题](https://scipy-cookbook.readthedocs.io/items/discrete_bvp.html)介绍了如何解决大型方程系统，并使用边界来实现解的期望性质。'
- en: For the details about mathematical algorithms behind the implementation refer
    to documentation of [`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares").
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实现背后数学算法的详细信息，请参阅[`least_squares`](../reference/generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")的文档。
- en: '[Univariate function minimizers (](#id46)[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar"))'
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[单变量函数最小化器 (](#id46)[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar"))'
- en: Often only the minimum of an univariate function (i.e., a function that takes
    a scalar as input) is needed. In these circumstances, other optimization techniques
    have been developed that can work faster. These are accessible from the [`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar") function, which proposes several algorithms.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 经常只需要对单变量函数（即以标量作为输入的函数）进行最小化。在这些情况下，已经开发出了其他可以更快工作的优化技术。这些技术可以从[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")函数中访问，该函数提供了几种算法。
- en: '[Unconstrained minimization (`method=''brent''`)](#id47)'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[无约束最小化（`method=''brent''`）](#id47)'
- en: 'There are, actually, two methods that can be used to minimize an univariate
    function: [`brent`](../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent
    "scipy.optimize.brent") and [`golden`](../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden
    "scipy.optimize.golden"), but [`golden`](../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden
    "scipy.optimize.golden") is included only for academic purposes and should rarely
    be used. These can be respectively selected through the *method* parameter in
    [`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar"). The [`brent`](../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent
    "scipy.optimize.brent") method uses Brent’s algorithm for locating a minimum.
    Optimally, a bracket (the [`bracket`](../reference/generated/scipy.optimize.bracket.html#scipy.optimize.bracket
    "scipy.optimize.bracket") parameter) should be given which contains the minimum
    desired. A bracket is a triple \(\left( a, b, c \right)\) such that \(f \left(
    a \right) > f \left( b \right) < f \left( c \right)\) and \(a < b < c\) . If this
    is not given, then alternatively two starting points can be chosen and a bracket
    will be found from these points using a simple marching algorithm. If these two
    starting points are not provided, *0* and *1* will be used (this may not be the
    right choice for your function and result in an unexpected minimum being returned).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两种方法可以用来最小化单变量函数：[`brent`](../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent
    "scipy.optimize.brent")和[`golden`](../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden
    "scipy.optimize.golden")，但[`golden`](../reference/generated/scipy.optimize.golden.html#scipy.optimize.golden
    "scipy.optimize.golden")仅用于学术目的，应该很少使用。这些可以通过[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")中的*method*参数分别选择。[`brent`](../reference/generated/scipy.optimize.brent.html#scipy.optimize.brent
    "scipy.optimize.brent")方法使用Brent算法来寻找最小值。理想情况下，应该提供一个包含所需最小值的区间（[`bracket`](../reference/generated/scipy.optimize.bracket.html#scipy.optimize.bracket
    "scipy.optimize.bracket")参数），这是一个三元组 \(\left( a, b, c \right)\)，使得 \(f \left(
    a \right) > f \left( b \right) < f \left( c \right)\) 并且 \(a < b < c\)。如果未提供这个参数，则可以选择两个起始点，并且使用简单的逐步算法从这些点中找到一个区间。如果没有提供这两个起始点，则会使用
    *0* 和 *1*（这可能不是您函数的正确选择，可能会返回意外的最小值）。
- en: 'Here is an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Bounded minimization (`method=''bounded''`)](#id48)'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[有界最小化（`method=''bounded''`）](#id48)'
- en: Very often, there are constraints that can be placed on the solution space before
    minimization occurs. The *bounded* method in [`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar") is an example of a constrained minimization
    procedure that provides a rudimentary interval constraint for scalar functions.
    The interval constraint allows the minimization to occur only between two fixed
    endpoints, specified using the mandatory *bounds* parameter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，在进行最小化之前可以对解空间施加约束。[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")中的 *bounded* 方法是一个有约束的最小化过程的例子，它为标量函数提供了一个基本的区间约束。区间约束只允许在两个固定端点之间进行最小化，这些端点使用强制的
    *bounds* 参数指定。
- en: 'For example, to find the minimum of \(J_{1}\left( x \right)\) near \(x=5\)
    , [`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar") can be called using the interval \(\left[ 4,
    7 \right]\) as a constraint. The result is \(x_{\textrm{min}}=5.3314\) :'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 \(x=5\) 附近找到 \(J_{1}\left( x \right)\) 的最小值，可以使用区间 \(\left[ 4, 7 \right]\)
    作为约束来调用[`minimize_scalar`](../reference/generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")。结果是 \(x_{\textrm{min}}=5.3314\) ：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[Custom minimizers](#id49)'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[自定义最小化器](#id49)'
- en: Sometimes, it may be useful to use a custom method as a (multivariate or univariate)
    minimizer, for example, when using some library wrappers of [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") (e.g., [`basinhopping`](../reference/generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping")).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用自定义方法作为（多变量或单变量）最小化器可能很有用，例如，在使用某些库包装器时，例如 [`minimize`](../reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")（例如，[`basinhopping`](../reference/generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping")）。
- en: We can achieve that by, instead of passing a method name, passing a callable
    (either a function or an object implementing a *__call__* method) as the *method*
    parameter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不传递方法名称，而是传递一个可调用对象（一个函数或实现了 *__call__* 方法的对象）作为 *method* 参数来实现这一点。
- en: 'Let us consider an (admittedly rather virtual) need to use a trivial custom
    multivariate minimization method that will just search the neighborhood in each
    dimension independently with a fixed step size:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个（诚然相当虚拟的）需求，使用一个简单的自定义多变量最小化方法，只会以固定步长独立地在每个维度中搜索邻域：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will work just as well in case of univariate optimization:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单变量优化，这同样有效：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Root finding](#id50)'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[根查找](#id50)'
- en: '[Scalar functions](#id51)'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[标量函数](#id51)'
- en: If one has a single-variable equation, there are multiple different root finding
    algorithms that can be tried. Most of these algorithms require the endpoints of
    an interval in which a root is expected (because the function changes signs).
    In general, [`brentq`](../reference/generated/scipy.optimize.brentq.html#scipy.optimize.brentq
    "scipy.optimize.brentq") is the best choice, but the other methods may be useful
    in certain circumstances or for academic purposes. When a bracket is not available,
    but one or more derivatives are available, then [`newton`](../reference/generated/scipy.optimize.newton.html#scipy.optimize.newton
    "scipy.optimize.newton") (or `halley`, `secant`) may be applicable. This is especially
    the case if the function is defined on a subset of the complex plane, and the
    bracketing methods cannot be used.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有单变量方程，则可以尝试多种不同的根查找算法。大多数这些算法需要预期根处函数变号的区间端点（因为函数变化方向）。一般而言，[`brentq`](../reference/generated/scipy.optimize.brentq.html#scipy.optimize.brentq
    "scipy.optimize.brentq") 是最佳选择，但其他方法在某些情况或学术目的下可能也有用。当不存在一个区间但存在一个或多个导数时，则可以应用
    [`newton`](../reference/generated/scipy.optimize.newton.html#scipy.optimize.newton
    "scipy.optimize.newton")（或 `halley`，`secant`）。特别是在函数在复平面的某个子集上定义时，且无法使用区间法时，这种情况尤为如此。
- en: '[Fixed-point solving](#id52)'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[固定点求解](#id52)'
- en: 'A problem closely related to finding the zeros of a function is the problem
    of finding a fixed point of a function. A fixed point of a function is the point
    at which evaluation of the function returns the point: \(g\left(x\right)=x.\)
    Clearly, the fixed point of \(g\) is the root of \(f\left(x\right)=g\left(x\right)-x.\)
    Equivalently, the root of \(f\) is the fixed point of \(g\left(x\right)=f\left(x\right)+x.\)
    The routine [`fixed_point`](../reference/generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point
    "scipy.optimize.fixed_point") provides a simple iterative method using Aitkens
    sequence acceleration to estimate the fixed point of \(g\) given a starting point.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与查找函数零点密切相关的问题是查找函数的固定点的问题。函数的固定点是使得函数评估返回该点的点：\(g\left(x\right)=x.\) 显然，\(g\)
    的固定点是 \(f\left(x\right)=g\left(x\right)-x\) 的根。等价地，\(f\) 的根是 \(g\left(x\right)=f\left(x\right)+x\)
    的固定点。例程 [`fixed_point`](../reference/generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point
    "scipy.optimize.fixed_point") 提供了一种简单的迭代方法，使用Aitkens序列加速来估计给定起始点的 \(g\) 的固定点。
- en: '[Sets of equations](#id53)'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[方程组](#id53)'
- en: Finding a root of a set of non-linear equations can be achieved using the [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") function. Several methods are available, amongst which
    `hybr` (the default) and `lm`, which, respectively, use the hybrid method of Powell
    and the Levenberg-Marquardt method from MINPACK.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") 函数来找到一组非线性方程的根。有多种方法可用，其中包括使用Powell的混合方法和MINPACK中的Levenberg-Marquardt方法的
    `hybr`（默认）和 `lm`。
- en: The following example considers the single-variable transcendental equation
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例考虑单变量超越方程
- en: \[x+2\cos\left(x\right)=0,\]
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: \[x+2\cos\left(x\right)=0,\]
- en: 'a root of which can be found as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下找到一个根：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Consider now a set of non-linear equations
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一组非线性方程：
- en: \begin{eqnarray*} x_{0}\cos\left(x_{1}\right) & = & 4,\\ x_{0}x_{1}-x_{1} &
    = & 5. \end{eqnarray*}
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{eqnarray*} x_{0}\cos\left(x_{1}\right) & = & 4,\\ x_{0}x_{1}-x_{1} &
    = & 5. \end{eqnarray*}
- en: We define the objective function so that it also returns the Jacobian and indicate
    this by setting the `jac` parameter to `True`. Also, the Levenberg-Marquardt solver
    is used here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义目标函数，使其返回雅可比矩阵，并通过设置 `jac` 参数为 `True` 来指示这一点。此外，这里使用了 Levenberg-Marquardt
    求解器。
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[Root finding for large problems](#id54)'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[解决大问题的根查找](#id54)'
- en: Methods `hybr` and `lm` in [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") cannot deal with a very large number of variables (*N*),
    as they need to calculate and invert a dense *N x N* Jacobian matrix on every
    Newton step. This becomes rather inefficient when *N* grows.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `hybr` 和 `lm` 在 [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") 中不能处理非常大数量的变量 (*N*)，因为它们需要在每次牛顿步骤中计算并求逆密集的 *N x N* 雅可比矩阵，当
    *N* 增大时效率变得相当低下。
- en: 'Consider, for instance, the following problem: we need to solve the following
    integrodifferential equation on the square \([0,1]\times[0,1]\):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑在正方形 \([0,1]\times[0,1]\) 上解决以下积分微分方程：
- en: \[(\partial_x^2 + \partial_y^2) P + 5 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2
    = 0\]
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: \[(\partial_x^2 + \partial_y^2) P + 5 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2
    = 0\]
- en: with the boundary condition \(P(x,1) = 1\) on the upper edge and \(P=0\) elsewhere
    on the boundary of the square. This can be done by approximating the continuous
    function *P* by its values on a grid, \(P_{n,m}\approx{}P(n h, m h)\), with a
    small grid spacing *h*. The derivatives and integrals can then be approximated;
    for instance \(\partial_x^2 P(x,y)\approx{}(P(x+h,y) - 2 P(x,y) + P(x-h,y))/h^2\).
    The problem is then equivalent to finding the root of some function `residual(P)`,
    where `P` is a vector of length \(N_x N_y\).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在边界条件 \(P(x,1) = 1\) 上以及方形边界上的其他地方 \(P=0\)。可以通过在网格上近似连续函数 *P* 的值 \(P_{n,m}\approx{}P(n
    h, m h)\)，其中网格间距 *h* 很小，来完成此操作。然后可以近似导数和积分；例如 \(\partial_x^2 P(x,y)\approx{}(P(x+h,y)
    - 2 P(x,y) + P(x-h,y))/h^2\)。然后，问题等效于找到某些函数 `residual(P)` 的根，其中 `P` 是长度为 \(N_x
    N_y\) 的向量。
- en: Now, because \(N_x N_y\) can be large, methods `hybr` or `lm` in [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") will take a long time to solve this problem. The solution
    can, however, be found using one of the large-scale solvers, for example `krylov`,
    `broyden2`, or `anderson`. These use what is known as the inexact Newton method,
    which instead of computing the Jacobian matrix exactly, forms an approximation
    for it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于 \(N_x N_y\) 可能很大，方法 [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") 中的 `hybr` 或 `lm` 将花费很长时间来解决这个问题。然而，可以使用其中一个大规模求解器（例如 `krylov`、`broyden2`
    或 `anderson`）来找到解决方案。这些方法使用所谓的不精确牛顿方法，它不会精确计算雅可比矩阵，而是形成其近似值。
- en: 'The problem we have can now be solved as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以解决如下问题：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '!["This code generates a 2-D heatmap with Z values from 0 to 1\. The graph
    resembles a smooth, dark blue-green, U shape, with an open yellow top. The right,
    bottom, and left edges have a value near zero and the top has a value close to
    1\. The center of the solution space has a value close to 0.8."](../Images/400641c4415abf89b06b3df5e6b75895.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '!["This code generates a 2-D heatmap with Z values from 0 to 1\. The graph
    resembles a smooth, dark blue-green, U shape, with an open yellow top. The right,
    bottom, and left edges have a value near zero and the top has a value close to
    1\. The center of the solution space has a value close to 0.8."](../Images/400641c4415abf89b06b3df5e6b75895.png)'
- en: '[Still too slow? Preconditioning.](#id55)'
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[还是太慢？预处理。](#id55)'
- en: When looking for the zero of the functions \(f_i({\bf x}) = 0\), *i = 1, 2,
    …, N*, the `krylov` solver spends most of the time inverting the Jacobian matrix,
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当寻找函数 \(f_i({\bf x}) = 0\) 的零点时，*i = 1, 2, …, N*，`krylov` 求解器大部分时间用于求解雅可比矩阵的逆。
- en: \[J_{ij} = \frac{\partial f_i}{\partial x_j} .\]
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: \[J_{ij} = \frac{\partial f_i}{\partial x_j} .\]
- en: 'If you have an approximation for the inverse matrix \(M\approx{}J^{-1}\), you
    can use it for *preconditioning* the linear-inversion problem. The idea is that
    instead of solving \(J{\bf s}={\bf y}\) one solves \(MJ{\bf s}=M{\bf y}\): since
    matrix \(MJ\) is “closer” to the identity matrix than \(J\) is, the equation should
    be easier for the Krylov method to deal with.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对逆矩阵 \(M\approx{}J^{-1}\) 有一个近似值，可以用它来*预处理*线性反演问题。其思想是，不是解决 \(J{\bf s}={\bf
    y}\)，而是解决 \(MJ{\bf s}=M{\bf y}\)：因为矩阵 \(MJ\) 比 \(J\) 更接近单位矩阵，所以对于 Krylov 方法来说，这个方程应该更容易处理。
- en: The matrix *M* can be passed to [`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root") with method `krylov` as an option `options['jac_options']['inner_M']`.
    It can be a (sparse) matrix or a [`scipy.sparse.linalg.LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") instance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵*M*可以作为选项`options['jac_options']['inner_M']`传递给[`root`](../reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "scipy.optimize.root")的`krylov`方法。它可以是一个（稀疏）矩阵或[`scipy.sparse.linalg.LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator")实例。
- en: 'For the problem in the previous section, we note that the function to solve
    consists of two parts: the first one is the application of the Laplace operator,
    \([\partial_x^2 + \partial_y^2] P\), and the second is the integral. We can actually
    easily compute the Jacobian corresponding to the Laplace operator part: we know
    that in 1-D'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前一节中的问题，我们注意到要解决的函数由两部分组成：第一部分是拉普拉斯算子的应用，\([\partial_x^2 + \partial_y^2] P\)，第二部分是积分。实际上，我们可以很容易地计算与拉普拉斯算子部分对应的雅可比矩阵：我们知道在一维中
- en: \[\begin{split}\partial_x^2 \approx \frac{1}{h_x^2} \begin{pmatrix} -2 & 1 &
    0 & 0 \cdots \\ 1 & -2 & 1 & 0 \cdots \\ 0 & 1 & -2 & 1 \cdots \\ \ldots \end{pmatrix}
    = h_x^{-2} L\end{split}\]
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\partial_x^2 \approx \frac{1}{h_x^2} \begin{pmatrix} -2 & 1 &
    0 & 0 \cdots \\ 1 & -2 & 1 & 0 \cdots \\ 0 & 1 & -2 & 1 \cdots \\ \ldots \end{pmatrix}
    = h_x^{-2} L\end{split}\]
- en: so that the whole 2-D operator is represented by
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使得整个二维算子表示为
- en: \[J_1 = \partial_x^2 + \partial_y^2 \simeq h_x^{-2} L \otimes I + h_y^{-2} I
    \otimes L\]
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: \[J_1 = \partial_x^2 + \partial_y^2 \simeq h_x^{-2} L \otimes I + h_y^{-2} I
    \otimes L\]
- en: The matrix \(J_2\) of the Jacobian corresponding to the integral is more difficult
    to calculate, and since *all* of it entries are nonzero, it will be difficult
    to invert. \(J_1\) on the other hand is a relatively simple matrix, and can be
    inverted by [`scipy.sparse.linalg.splu`](../reference/generated/scipy.sparse.linalg.splu.html#scipy.sparse.linalg.splu
    "scipy.sparse.linalg.splu") (or the inverse can be approximated by [`scipy.sparse.linalg.spilu`](../reference/generated/scipy.sparse.linalg.spilu.html#scipy.sparse.linalg.spilu
    "scipy.sparse.linalg.spilu")). So we are content to take \(M\approx{}J_1^{-1}\)
    and hope for the best.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与积分对应的雅可比矩阵\(J_2\)更难计算，由于其所有条目都不为零，因此很难求逆。另一方面，\(J_1\)是一个相对简单的矩阵，可以通过[`scipy.sparse.linalg.splu`](../reference/generated/scipy.sparse.linalg.splu.html#scipy.sparse.linalg.splu
    "scipy.sparse.linalg.splu")求逆（或者可以通过[`scipy.sparse.linalg.spilu`](../reference/generated/scipy.sparse.linalg.spilu.html#scipy.sparse.linalg.spilu
    "scipy.sparse.linalg.spilu")近似求逆）。因此，我们满足于取\(M\approx{}J_1^{-1}\)并希望一切顺利。
- en: In the example below, we use the preconditioner \(M=J_1^{-1}\).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用预处理器\(M=J_1^{-1}\)。
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Resulting run, first without preconditioning:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 结果运行，首先没有预处理：
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'and then with preconditioning:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行预处理：
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using a preconditioner reduced the number of evaluations of the `residual` function
    by a factor of *4*. For problems where the residual is expensive to compute, good
    preconditioning can be crucial — it can even decide whether the problem is solvable
    in practice or not.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器将`residual`函数的评估次数减少了*4*倍。对于计算成本高昂的残差的问题，良好的预处理至关重要 —— 它甚至可以决定问题在实践中是否可解。
- en: Preconditioning is an art, science, and industry. Here, we were lucky in making
    a simple choice that worked reasonably well, but there is a lot more depth to
    this topic than is shown here.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理是一门艺术、科学和工业。在这里，我们很幸运地做出了一个简单的选择，效果还不错，但这个主题比这里展示的要深入得多。
- en: '[Linear programming (](#id56)[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"))'
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[线性规划（](#id56)[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"))'
- en: 'The function [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") can minimize a linear objective function subject to
    linear equality and inequality constraints. This kind of problem is well known
    as linear programming. Linear programming solves problems of the following form:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")可以最小化一个线性目标函数，同时满足线性等式和不等式约束。这种问题被称为线性规划。线性规划解决以下形式的问题：
- en: \[\begin{split}\min_x \ & c^T x \\ \mbox{such that} \ & A_{ub} x \leq b_{ub},\\
    & A_{eq} x = b_{eq},\\ & l \leq x \leq u ,\end{split}\]
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\min_x \ & c^T x \\ \mbox{such that} \ & A_{ub} x \leq b_{ub},\\
    & A_{eq} x = b_{eq},\\ & l \leq x \leq u ,\end{split}\]
- en: where \(x\) is a vector of decision variables; \(c\), \(b_{ub}\), \(b_{eq}\),
    \(l\), and \(u\) are vectors; and \(A_{ub}\) and \(A_{eq}\) are matrices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(x\)是决策变量向量；\(c\)、\(b_{ub}\)、\(b_{eq}\)、\(l\)和\(u\)是向量；\(A_{ub}\)和\(A_{eq}\)是矩阵。
- en: In this tutorial, we will try to solve a typical linear programming problem
    using [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog").
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将尝试使用[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")解决典型的线性规划问题。
- en: '[Linear programming example](#id57)'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[线性规划示例](#id57)'
- en: 'Consider the following simple linear programming problem:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的线性规划问题：
- en: \[\begin{split}\max_{x_1, x_2, x_3, x_4} \ & 29x_1 + 45x_2 \\ \mbox{such that}
    \ & x_1 -x_2 -3x_3 \leq 5\\ & 2x_1 -3x_2 -7x_3 + 3x_4 \geq 10\\ & 2x_1 + 8x_2
    + x_3 = 60\\ & 4x_1 + 4x_2 + x_4 = 60\\ & 0 \leq x_0\\ & 0 \leq x_1 \leq 5\\ &
    x_2 \leq 0.5\\ & -3 \leq x_3\\\end{split}\]
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\max_{x_1, x_2, x_3, x_4} \ & 29x_1 + 45x_2 \\ \mbox{such that}
    \ & x_1 -x_2 -3x_3 \leq 5\\ & 2x_1 -3x_2 -7x_3 + 3x_4 \geq 10\\ & 2x_1 + 8x_2
    + x_3 = 60\\ & 4x_1 + 4x_2 + x_4 = 60\\ & 0 \leq x_0\\ & 0 \leq x_1 \leq 5\\ &
    x_2 \leq 0.5\\ & -3 \leq x_3\\\end{split}\]
- en: We need some mathematical manipulations to convert the target problem to the
    form accepted by [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog").
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些数学操作来将目标问题转换为[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")接受的形式。
- en: 'First of all, let’s consider the objective function. We want to maximize the
    objective function, but [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") can only accept a minimization problem. This is easily
    remedied by converting the maximize \(29x_1 + 45x_2\) to minimizing \(-29x_1 -45x_2\).
    Also, \(x_3, x_4\) are not shown in the objective function. That means the weights
    corresponding with \(x_3, x_4\) are zero. So, the objective function can be converted
    to:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑目标函数。我们想要最大化目标函数，但[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")只能接受最小化问题。这很容易通过将最大化\(29x_1 + 45x_2\)转换为最小化\(-29x_1 -45x_2\)来修正。另外，\(x_3,
    x_4\)在目标函数中没有显示。这意味着与\(x_3, x_4\)对应的权重为零。因此，目标函数可以转换为：
- en: \[\min_{x_1, x_2, x_3, x_4} \ -29x_1 -45x_2 + 0x_3 + 0x_4\]
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: \[\min_{x_1, x_2, x_3, x_4} \ -29x_1 -45x_2 + 0x_3 + 0x_4\]
- en: If we define the vector of decision variables \(x = [x_1, x_2, x_3, x_4]^T\),
    the objective weights vector \(c\) of [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") in this problem should be
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义决策变量向量\(x = [x_1, x_2, x_3, x_4]^T\)，那么[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")在这个问题中的目标权重向量\(c\)应为
- en: \[c = [-29, -45, 0, 0]^T\]
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: \[c = [-29, -45, 0, 0]^T\]
- en: 'Next, let’s consider the two inequality constraints. The first one is a “less
    than” inequality, so it is already in the form accepted by [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"). The second one is a “greater than” inequality, so we
    need to multiply both sides by \(-1\) to convert it to a “less than” inequality.
    Explicitly showing zero coefficients, we have:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑这两个不等式约束。第一个是“小于”不等式，因此已经是[`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")接受的形式。第二个是“大于”不等式，因此我们需要将两边乘以\(-1\)将其转换为“小于”不等式。明确显示零系数，我们有：
- en: \[\begin{split}x_1 -x_2 -3x_3 + 0x_4 &\leq 5\\ -2x_1 + 3x_2 + 7x_3 - 3x_4 &\leq
    -10\\\end{split}\]
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}x_1 -x_2 -3x_3 + 0x_4 &\leq 5\\ -2x_1 + 3x_2 + 7x_3 - 3x_4 &\leq
    -10\\\end{split}\]
- en: 'These equations can be converted to matrix form:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程可以转换为矩阵形式：
- en: \[\begin{split}A_{ub} x \leq b_{ub}\\\end{split}\]
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}A_{ub} x \leq b_{ub}\\\end{split}\]
- en: where
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: \begin{equation*} A_{ub} = \begin{bmatrix} 1 & -1 & -3 & 0 \\ -2 & 3 & 7 & -3
    \end{bmatrix} \end{equation*}\begin{equation*} b_{ub} = \begin{bmatrix} 5 \\ -10
    \end{bmatrix} \end{equation*}
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} A_{ub} = \begin{bmatrix} 1 & -1 & -3 & 0 \\ -2 & 3 & 7 & -3
    \end{bmatrix} \end{equation*}\begin{equation*} b_{ub} = \begin{bmatrix} 5 \\ -10
    \end{bmatrix} \end{equation*}
- en: 'Next, let’s consider the two equality constraints. Showing zero weights explicitly,
    these are:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑两个等式约束。明确显示零权重，它们是：
- en: \[\begin{split}2x_1 + 8x_2 + 1x_3 + 0x_4 &= 60\\ 4x_1 + 4x_2 + 0x_3 + 1x_4 &=
    60\\\end{split}\]
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}2x_1 + 8x_2 + 1x_3 + 0x_4 &= 60\\ 4x_1 + 4x_2 + 0x_3 + 1x_4 &=
    60\\\end{split}\]
- en: 'These equations can be converted to matrix form:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程可以转换为矩阵形式：
- en: \[\begin{split}A_{eq} x = b_{eq}\\\end{split}\]
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}A_{eq} x = b_{eq}\\\end{split}\]
- en: where
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: \begin{equation*} A_{eq} = \begin{bmatrix} 2 & 8 & 1 & 0 \\ 4 & 4 & 0 & 1 \end{bmatrix}
    \end{equation*}\begin{equation*} b_{eq} = \begin{bmatrix} 60 \\ 60 \end{bmatrix}
    \end{equation*}
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*} A_{eq} = \begin{bmatrix} 2 & 8 & 1 & 0 \\ 4 & 4 & 0 & 1 \end{bmatrix}
    \end{equation*}\begin{equation*} b_{eq} = \begin{bmatrix} 60 \\ 60 \end{bmatrix}
    \end{equation*}
- en: 'Lastly, let’s consider the separate inequality constraints on individual decision
    variables, which are known as “box constraints” or “simple bounds”. These constraints
    can be applied using the bounds argument of [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog"). As noted in the [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") documentation, the default value of bounds is `(0, None)`,
    meaning that the lower bound on each decision variable is 0, and the upper bound
    on each decision variable is infinity: all the decision variables are non-negative.
    Our bounds are different, so we will need to specify the lower and upper bound
    on each decision variable as a tuple and group these tuples into a list.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑对单独决策变量的分离不等式约束，这些约束被称为“箱约束”或“简单边界”。这些约束可以使用 [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") 的 bounds 参数来应用。如 [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") 文档中所述，bounds 的默认值为 `(0, None)`，意味着每个决策变量的下界为 0，上界为无穷大：所有决策变量均为非负数。我们的边界不同，因此我们需要将每个决策变量的下界和上界指定为一个元组，并将这些元组分组成一个列表。
- en: Finally, we can solve the transformed problem using [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog").
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 [`linprog`](../reference/generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") 解决转换后的问题。
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The result states that our problem is infeasible, meaning that there is no
    solution vector that satisfies all the constraints. That doesn’t necessarily mean
    we did anything wrong; some problems truly are infeasible. Suppose, however, that
    we were to decide that our bound constraint on \(x_1\) was too tight and that
    it could be loosened to \(0 \leq x_1 \leq 6\). After adjusting our code `x1_bounds
    = (0, 6)` to reflect the change and executing it again:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示我们的问题是不可行的，这意味着没有满足所有约束的解向量。这并不一定意味着我们做错了什么；有些问题确实是不可行的。然而，假设我们决定我们对 \(x_1\)
    的边界约束太严格，可以放宽为 \(0 \leq x_1 \leq 6\)。在调整我们的代码 `x1_bounds = (0, 6)` 反映这一变化并再次执行后：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The result shows the optimization was successful. We can check the objective
    value (`result.fun`) is same as \(c^Tx\):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示优化成功。我们可以检查目标值 (`result.fun`) 是否与 \(c^Tx\) 相同：
- en: '[PRE62]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also check that all constraints are satisfied within reasonable tolerances:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查所有约束是否在合理的容差范围内得到满足：
- en: '[PRE63]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[Assignment problems](#id58)'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[分配问题](#id58)'
- en: '[Linear sum assignment problem example](#id59)'
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[线性和分配问题示例](#id59)'
- en: 'Consider the problem of selecting students for a swimming medley relay team.
    We have a table showing times for each swimming style of five students:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑选择一个游泳混合接力队的学生问题。我们有一个表格显示了五名学生每种游泳风格的时间：
- en: '| Student | backstroke | breaststroke | butterfly | freestyle |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| Student | backstroke | breaststroke | butterfly | freestyle |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| A | 43.5 | 47.1 | 48.4 | 38.2 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| A | 43.5 | 47.1 | 48.4 | 38.2 |'
- en: '| B | 45.5 | 42.1 | 49.6 | 36.8 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| B | 45.5 | 42.1 | 49.6 | 36.8 |'
- en: '| C | 43.4 | 39.1 | 42.1 | 43.2 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| C | 43.4 | 39.1 | 42.1 | 43.2 |'
- en: '| D | 46.5 | 44.1 | 44.5 | 41.2 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| D | 46.5 | 44.1 | 44.5 | 41.2 |'
- en: '| E | 46.3 | 47.8 | 50.4 | 37.2 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| E | 46.3 | 47.8 | 50.4 | 37.2 |'
- en: We need to choose a student for each of the four swimming styles such that the
    total relay time is minimized. This is a typical linear sum assignment problem.
    We can use [`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment") to solve it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每种四种游泳风格选择一个学生，以使接力总时间最小化。这是一个典型的线性和分配问题。我们可以使用 [`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment") 来解决它。
- en: The linear sum assignment problem is one of the most famous combinatorial optimization
    problems. Given a “cost matrix” \(C\), the problem is to choose
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 线性和分配问题是最著名的组合优化问题之一。给定一个“成本矩阵” \(C\)，问题是选择每行中的一个元素
- en: exactly one element from each row
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从而确保每列中不选择超过一个元素
- en: without choosing more than one element from any column
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不选择任何列中超过一个元素
- en: such that the sum of the chosen elements is minimized
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以使所选元素的和最小化
- en: In other words, we need to assign each row to one column such that the sum of
    the corresponding entries is minimized.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要将每一行分配给一个列，使得对应条目的总和最小化。
- en: Formally, let \(X\) be a boolean matrix where \(X[i,j] = 1\) iff row \(i\) is
    assigned to column \(j\). Then the optimal assignment has cost
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，设 \(X\) 是一个布尔矩阵，其中 \(X[i,j] = 1\) 当且仅当第 \(i\) 行被分配给第 \(j\) 列。那么最优的分配成本为
- en: \[\min \sum_i \sum_j C_{i,j} X_{i,j}\]
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: \[\min \sum_i \sum_j C_{i,j} X_{i,j}\]
- en: 'The first step is to define the cost matrix. In this example, we want to assign
    each swimming style to a student. [`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment") is able to assign each row of a cost matrix
    to a column. Therefore, to form the cost matrix, the table above needs to be transposed
    so that the rows correspond with swimming styles and the columns correspond with
    students:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义成本矩阵。在这个例子中，我们想要将每种游泳风格分配给一个学生。[`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment") 能够将成本矩阵的每一行分配给一列。因此，为了形成成本矩阵，需要将上表进行转置，使得行对应于游泳风格，列对应于学生：
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can solve the assignment problem with [`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment"):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[`linear_sum_assignment`](../reference/generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment")解决分配问题：
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `row_ind` and `col_ind` are optimal assigned matrix indexes of the cost
    matrix:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_ind` 和 `col_ind` 是成本矩阵的最优分配索引：'
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The optimal assignment is:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最优分配为：
- en: '[PRE67]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The optimal total medley time is:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最优的混合接力总时间为：
- en: '[PRE68]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that this result is not the same as the sum of the minimum times for each
    swimming style:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个结果与每种游泳风格的最小时间总和不同：
- en: '[PRE69]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: because student “C” is the best swimmer in both “breaststroke” and “butterfly”
    style. We cannot assign student “C” to both styles, so we assigned student C to
    the “breaststroke” style and D to the “butterfly” style to minimize the total
    time.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因为学生“C”在“蛙泳”和“蝶泳”项目中都是最好的游泳者。我们不能让学生“C”同时参加两个项目，所以我们将学生C分配到“蛙泳”项目，学生D分配到“蝶泳”项目以最小化总时间。
- en: References
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Some further reading and related software, such as Newton-Krylov [[KK]](#kk),
    PETSc [[PP]](#pp), and PyAMG [[AMG]](#amg):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一些进一步阅读和相关软件，例如牛顿-克里洛夫 [[KK]](#kk)，PETSc [[PP]](#pp)，和 PyAMG [[AMG]](#amg)：
- en: '[[KK](#id17)]'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[[KK](#id17)]'
- en: D.A. Knoll and D.E. Keyes, “Jacobian-free Newton-Krylov methods”, J. Comp. Phys.
    193, 357 (2004). [DOI:10.1016/j.jcp.2003.08.010](https://doi.org/10.1016/j.jcp.2003.08.010)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: D.A. Knoll 和 D.E. Keyes，“Jacobian-free Newton-Krylov methods”，J. Comp. Phys.
    193, 357 (2004)。[DOI:10.1016/j.jcp.2003.08.010](https://doi.org/10.1016/j.jcp.2003.08.010)
- en: '[[PP](#id18)]'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[[PP](#id18)]'
- en: PETSc [https://www.mcs.anl.gov/petsc/](https://www.mcs.anl.gov/petsc/) and its
    Python bindings [https://bitbucket.org/petsc/petsc4py/](https://bitbucket.org/petsc/petsc4py/)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: PETSc [https://www.mcs.anl.gov/petsc/](https://www.mcs.anl.gov/petsc/) 和其 Python
    绑定 [https://bitbucket.org/petsc/petsc4py/](https://bitbucket.org/petsc/petsc4py/)
- en: '[[AMG](#id19)]'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[[AMG](#id19)]'
- en: PyAMG (algebraic multigrid preconditioners/solvers) [https://github.com/pyamg/pyamg/issues](https://github.com/pyamg/pyamg/issues)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: PyAMG（代数多重网格预处理器/求解器）[https://github.com/pyamg/pyamg/issues](https://github.com/pyamg/pyamg/pyamg/issues)
- en: '## [Mixed integer linear programming](#id60)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '## [混合整数线性规划](#id60)'
- en: '[Knapsack problem example](#id61)'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[背包问题示例](#id61)'
- en: The knapsack problem is a well known combinatorial optimization problem. Given
    a set of items, each with a size and a value, the problem is to choose the items
    that maximize the total value under the condition that the total size is below
    a certain threshold.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题是一个著名的组合优化问题。给定一组物品，每个物品有一个大小和一个价值，问题是在总大小不超过一定阈值的条件下选择物品以最大化总价值。
- en: Formally, let
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，设
- en: \(x_i\) be a boolean variable that indicates whether item \(i\) is included
    in the knapsack,
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(x_i\) 是一个布尔变量，表示是否将物品 \(i\) 放入背包，
- en: \(n\) be the total number of items,
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(n\) 表示物品的总数，
- en: \(v_i\) be the value of item \(i\),
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(v_i\) 是物品 \(i\) 的价值，
- en: \(s_i\) be the size of item \(i\), and
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(s_i\) 表示物品 \(i\) 的大小，以及
- en: \(C\) be the capacity of the knapsack.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(C\) 表示背包的容量。
- en: 'Then the problem is:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '然后问题是:'
- en: \[\max \sum_i^n v_{i} x_{i}\]\[\text{subject to} \sum_i^n s_{i} x_{i} \leq C,
    x_{i} \in {0, 1}\]
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: \[\max \sum_i^n v_{i} x_{i}\]\[\text{subject to} \sum_i^n s_{i} x_{i} \leq C,
    x_{i} \in {0, 1}\]
- en: Although the objective function and inequality constraints are linear in the
    *decision variables* \(x_i\), this differs from a typical linear programming problem
    in that the decision variables can only assume integer values. Specifically, our
    decision variables can only be \(0\) or \(1\), so this is known as a *binary integer
    linear program* (BILP). Such a problem falls within the larger class of *mixed
    integer linear programs* (MILPs), which we we can solve with [`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp").
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目标函数和不等式约束在*决策变量* \(x_i\) 中是线性的，但这与典型的线性规划问题不同，因为决策变量只能取整数值。具体来说，我们的决策变量只能是
    \(0\) 或 \(1\)，因此这被称为*二进制整数线性规划*（BILP）。这种问题属于更大的*混合整数线性规划*（MILP）类别，我们可以使用[`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp")来解决。
- en: In our example, there are 8 items to choose from, and the size and value of
    each is specified as follows.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，有 8 个可供选择的项目，每个项目的大小和价值如下所示。
- en: '[PRE70]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We need to constrain our eight decision variables to be binary. We do so by
    adding a [`Bounds`](../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"): constraint to ensure that they lie between \(0\) and
    \(1\), and we apply “integrality” constraints to ensure that they are *either*
    \(0\) *or* \(1\).'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将八个决策变量限制为二进制。我们通过添加一个[`Bounds`](../reference/generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")约束来确保它们位于 \(0\) 和 \(1\) 之间，并应用“整数性”约束以确保它们要么是 \(0\) 要么是
    \(1\)。
- en: '[PRE71]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The knapsack capacity constraint is specified using [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")指定背包容量约束。
- en: '[PRE72]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If we are following the usual rules of linear algebra, the input `A` should
    be a two-dimensional matrix, and the lower and upper bounds `lb` and `ub` should
    be one-dimensional vectors, but [`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") is forgiving as long as the inputs can be broadcast
    to consistent shapes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循线性代数的常规规则，输入 `A` 应该是一个二维矩阵，而下限和上限 `lb` 和 `ub` 应该是一维向量，但[`LinearConstraint`](../reference/generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")会根据需要自动调整形状。
- en: Using the variables defined above, we can solve the knapsack problem using [`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp"). Note that [`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp") minimizes the objective function, but we want to maximize
    the total value, so we set *c* to be negative of the values.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面定义的变量，我们可以使用[`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp")解决背包问题。注意，[`milp`](../reference/generated/scipy.optimize.milp.html#scipy.optimize.milp
    "scipy.optimize.milp")最小化目标函数，但我们希望最大化总价值，因此我们将*c*设置为值的负数。
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s check the result:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查结果：
- en: '[PRE74]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This means that we should select the items 1, 2, 4, 5, 6 to optimize the total
    value under the size constraint. Note that this is different from we would have
    obtained had we solved the *linear programming relaxation* (without integrality
    constraints) and attempted to round the decision variables.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该选择项目 1、2、4、5、6 来优化在大小约束下的总价值。注意，这与我们解决*线性规划松弛*（没有整数约束）并尝试四舍五入决策变量所得到的结果不同。
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If we were to round this solution up to `array([1., 1., 1., 1., 1., 1., 0.,
    0.])`, our knapsack would be over the capacity constraint, whereas if we were
    to round down to `array([1., 1., 1., 1., 0., 1., 0., 0.])`, we would have a sub-optimal
    solution.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个解决方案四舍五入到 `array([1., 1., 1., 1., 1., 1., 0., 0.])`，我们的背包将超过容量限制，而如果我们将其四舍五入到
    `array([1., 1., 1., 1., 0., 1., 0., 0.])`，则会得到一个次优解。
- en: 'For more MILP tutorials, see the Jupyter notebooks on SciPy Cookbooks:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 更多MILP教程，请参阅SciPy Cookbook上的Jupyter笔记本：
- en: '[Compressed Sensing l1 program](https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_1.ipynb)'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[压缩感知 l1 程序](https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_1.ipynb)'
- en: '[Compressed Sensing l0 program](https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_2.ipynb)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[压缩感知 l0 程序](https://nbviewer.org/github/scipy/scipy-cookbook/blob/main/ipython/LinearAndMixedIntegerLinearProgramming/compressed_sensing_milp_tutorial_2.ipynb)'
