# 开发工作流程

> 原文：[`numpy.org/doc/1.26/dev/development_workflow.html`](https://numpy.org/doc/1.26/dev/development_workflow.html)

你已经通过创建 NumPy fork 获得了自己的分叉版本的[NumPy](https://www.numpy.org)存储库，通过创建本地副本，你已经按照 Git 配置配置了[git](https://git-scm.com/)，并像[将你的存储库链接到上游存储库](https://scikit-image.org/docs/stable/gitwash/set_up_fork.html#linking-to-upstream "(in skimage v0.21.0)")中所解释的那样，将上游存储库链接了起来。

下面描述的是一种使用 Git 的推荐工作流程。

## 基本工作流程

简而言之：

1.  为每次编辑启动一个新的*功能分支*。请参见下面的内容（#making-a-new-feature-branch）。

1.  开始动手吧！请参见下面的内容（#editing-workflow）

1.  完成后：

    +   *贡献者*：将你的功能分支推送到你自己的 Github 存储库，并创建一个拉取请求。

    +   *核心开发者*：如果你想在不经过进一步审查的情况下推送更改，请参阅下面的注释（#pushing-to-main）。

这种工作方式有助于保持工作井然有序，并尽可能明确历史记录。

另请参阅

有许多在线教程可以帮助你[学习 git](https://try.github.io/)。有关特定 git 工作流程的讨论，请参阅这些讨论[linux git workflow](https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html)，以及[ipython git workflow](https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html)。

### 创建一个新的功能分支

首先，从`upstream`存储库获取新的提交：

```py
git fetch upstream 
```

然后，在上游存储库的主分支基础上创建一个新的分支：

```py
git checkout -b my-new-feature upstream/main 
```  ### 编辑工作流程

#### 概述

```py
# hack hack
git status # Optional
git diff # Optional
git add modified_file
git commit
# push the branch to your own Github repo
git push origin my-new-feature 
```

#### 更详细

1.  做一些更改。当你觉得已经完成了一组完整的相关更改时，继续下一步。

1.  可选：使用`git status`检查哪些文件发生了变化（参见[git status](https://www.kernel.org/pub/software/scm/git/docs/git-status.html)）。你会看到一个像下面这样的列表：

    ```py
    # On branch my-new-feature
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #   (use "git checkout -- <file>..." to discard changes in working directory)
    #
    #  modified:   README
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #  INSTALL
    no changes added to commit (use "git add" and/or "git commit -a") 
    ```

1.  可选：使用`git diff`与上一个版本比较更改（参见[git diff](https://www.kernel.org/pub/software/scm/git/docs/git-diff.html)）。这将打开一个简单的文本浏览器界面，突出显示你的文件与上一个版本之间的差异。

1.  使用`git add modified_file`添加任何相关修改或新文件（参见[git add](https://www.kernel.org/pub/software/scm/git/docs/git-add.html)）。这将把文件放入暂存区，这是一个文件队列，将添加到下一个提交中。只添加具有相关完整更改的文件。将有未完成更改的文件留到以后提交。

1.  要将暂存的文件提交到本地仓库副本，请运行`git commit`。此时，一个文本编辑器将打开，允许您编写提交消息。请阅读提交消息部分以确保您编写的提交消息格式正确且详细足够。保存消息并关闭编辑器后，您的提交将保存。对于微不足道的提交，可以使用`-m`标志通过命令行传递简短的提交消息。例如，`git commit -am "ENH: Some message"`。

    在某些情况下，您会看到这种形式的提交命令：`git commit -a`。额外的`-a`标志自动提交所有修改的文件并删除所有已删除的文件。这可以节省您输入大量`git add`命令的操作；但是，如果您不小心，它可能会在提交中添加不需要的更改。欲了解更多信息，请参阅[为什么使用-a 标志？](http://www.gitready.com/beginner/2009/01/18/the-staging-area.html) - 以及[tangled working copy problem](https://tomayko.com/writings/the-thing-about-git)中的有用用例描述。

1.  将更改推送到您在[github](https://github.com/numpy/numpy)上 fork 的仓库：

    ```py
    git push origin my-new-feature 
    ```

    欲了解更多信息，请参阅[git push](https://www.kernel.org/pub/software/scm/git/docs/git-push.html)。

注意

假设您已经按照这些页面上的说明操作，git 将创建到您的[githhub](https://github.com/numpy/numpy)仓库的默认链接称为`origin`。在 git >= 1.7 中，您可以使用`--set-upstream`选项确保将链接到`origin`永久设置：

```py
git push --set-upstream origin my-new-feature 
```

从现在开始，[git](https://git-scm.com/)将知道`my-new-feature`与您自己的[githhub](https://github.com/numpy/numpy)仓库中的`my-new-feature`分支相关联。随后的推送调用可以简化为以下方式：

```py
git push 
```

每次创建新分支时，您必须使用`--set-upstream`参数。

可能出现这样的情况：在您编辑时，`upstream`上新增了影响您工作的新提交。在这种情况下，请遵循本文档中的在主分支上进行变基部分，将这些更改应用到您的分支上。

#### 编写提交消息

提交消息应清晰并遵循几个基本规则。示例：

```py
ENH: add functionality X to numpy.<submodule>.

The first line of the commit message starts with a capitalized acronym
(options listed below) indicating what type of commit this is.  Then a blank
line, then more text if needed.  Lines shouldn't be longer than 72
characters.  If the commit is related to a ticket, indicate that with
"See #3456", "See ticket 3456", "Closes #3456" or similar. 
```

在提交消息中描述更改的动机，修复错误的性质或有关增强功能的某些细节也是一个好习惯。消息应该能够在不查看代码更改的情况下被理解。像`MAINT：fixed another one`这样的提交消息是不被推荐的示例；读者必须在其他地方寻找上下文。

提交消息开头的标准首字母缩写为：

```py
API: an (incompatible) API change
BENCH: changes to the benchmark suite
BLD: change related to building numpy
BUG: bug fix
DEP: deprecate something, or remove a deprecated object
DEV: development tool or utility
DOC: documentation
ENH: enhancement
MAINT: maintenance commit (refactoring, typos, etc.)
REV: revert an earlier commit
STY: style fix (whitespace, PEP8)
TST: addition or modification of tests
TYP: static typing
REL: related to releasing numpy 
```

##### 跳过连续集成的命令。

默认情况下，针对每个 PR 都会运行许多连续集成（CI）作业，从在不同操作系统和硬件平台上运行测试套件到构建文档。在某些情况下，您已经知道不需要 CI（或不是全部），例如如果您正在处理 CI 配置文件、自述文件中的文本或其他不涉及常规构建、测试或文档序列的文件。在这种情况下，您可以通过在提交消息中包含以下片段之一来明确跳过 CI：

+   `[跳过 ci]`：跳过所有 CI

    只有在您还没有准备好让检查在您的 PR 上运行时才建议使用（例如，如果这只是一个草稿）。

+   `[跳过 actions]`：跳过 GitHub Actions 作业

    [GitHub Actions](https://docs.github.com/actions) 是运行大多数 CI 检查的地方，包括代码检查、基本测试在大多数架构和操作系统上运行以及几个编译器和 CPU 优化设置。[查看这些检查的配置文件。](https://github.com/numpy/numpy/tree/main/.github/workflows)

+   `[跳过 travis]`：跳过 TravisCI 作业

    [TravisCI](https://www.travis-ci.com/) 将针对 Python 3.9 在 PowerPC 和 s390x 架构上测试您的更改。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.travis.yml)

+   `[跳过 azp]`：跳过 Azure 作业

    [Azure](https://azure.microsoft.com/en-us/products/devops/pipelines) 是进行所有综合测试的地方。这是一个昂贵的运行，如果您只进行文档更改，则通常可以跳过它。[查看这些检查的主配置文件。](https://github.com/numpy/numpy/blob/main/azure-pipelines.yml)

+   `[跳过 circle]`：跳过 CircleCI 作业

    [CircleCI](https://circleci.com/) 是我们构建文档并在每个 PR 预览中存储生成的工件的地方。此检查还将运行所有的文档字符串示例并验证它们的结果。如果您没有进行文档更改，但例如更改了函数的 API，则可能需要运行这些测试以验证 doctests 仍然有效。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.circleci/config.yml)

+   `[跳过 cirrus]`：跳过 Cirrus 作业

    [CirrusCI](https://cirrus-ci.org/) 主要触发 Linux aarch64 和 MacOS Arm64 轮子的上传。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.cirrus.star)

##### 测试构建轮子

Numpy 目前使用[cibuildwheel](https://https://cibuildwheel.readthedocs.io/en/stable/)来通过持续集成服务构建轮子。为了节省资源，cibuildwheel 轮子构建器并不默认在每个 PR 或提交到主分支上运行。

如果您希望测试您的拉取请求不会破坏轮子构建器，您可以将`[wheel build]`附加到提交消息的末尾，也可以将以下标签之一添加到拉取请求中（如果您具有此权限）：

+   `36 - Build`: 用于改变构建流程/配置的拉取请求

+   `03 - Maintenance`: 用于升级依赖关系的拉取请求

+   `14 - Release`: 为准备发行的拉取请求

通过 github actions 构建的轮子（包括 64 位 linux，macOS 和 windows，arm64 macOS，和 32 位 windows）将被上传为 zip 文件的工件。 你可以从“Wheel builder”[Action](https://github.com/numpy/numpy/actions)的摘要页面访问它们。通过[travis](https://app.travis-ci.com/github/numpy/numpy/builds) CI 构建的 aarch64 轮子不作为工件提供。另外，如果满足以下条件，这些轮子将被上传到[`anaconda.org/scientific-python-nightly-wheels/`](https://anaconda.org/scientific-python-nightly-wheels/)：

+   通过每周的 cron 作业或者

+   如果 Github 操作或者 travis 构建是手动触发的，需要适当的权限

如果构建是由以`v`开头的标签触发的，这些轮子将被上传到[`anaconda.org/multibuild-wheels-staging/`](https://anaconda.org/multibuild-wheels-staging/)  ### 获取邮件列表的意见

如果你计划新增功能或者 API 改变，最明智的做法是先给 NumPy 邮件列表发送邮件，请求意见。如果一周内没有收到回复，再次发邮件也没问题。  ### 请求将您的更改与主 repo 合并

当你觉得自己的工作已完成时，你可以创建一个拉取请求（PR）。 Github 有一个很好的帮助页面，详细说明了[提出拉取请求的流程](https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request)。

如果你的更改涉及对 API 的修改或者添加/修改功能，按照`doc/release/upcoming_changes/`目录中`doc/release/upcoming_changes/README.rst`文件中的说明和格式添加发行说明。  ### 获取您的 PR 审查

我们会尽快审查拉取请求，通常在一周内。如果你两周内没有收到审查意见，请随时在你的 PR 上添加评论询问意见（这会通知维护者）。

如果你的 PR 很大或者很复杂，在 numpy-discussion 邮件列表上征求意见可能也是有用的。  ### 在主分支上变基

这将根据上游[NumPy github](https://github.com/numpy/numpy)仓库的更改来更新你的功能分支。如果你绝对不需要这样做，尽量避免这样做，除非当你完成时。第一步将是将远程仓库与上游的新提交更新：

```py
git fetch upstream 
```

接下来，你需要更新功能分支：

```py
# go to the feature branch
git checkout my-new-feature
# make a backup in case you mess up
git branch tmp my-new-feature
# rebase on upstream main branch
git rebase upstream/main 
```

如果你对已经在上游变更的文件进行了更改，这可能会导致冲突，你需要解决冲突。在这种情况下，请参见下文获取帮助。

最后，在成功的变基之后，请删除备份分支：

```py
git branch -D tmp 
```

注意

与其将上游合并回您的分支，不如在`main`上进行变基。当在特性分支上工作时，不鼓励使用`git merge`和`git pull`。### 从错误中恢复

有时候，你可能会搞砸合并或变基。幸运的是，在 Git 中相对容易从这些错误中恢复。

如果你在变基过程中搞砸了：

```py
git rebase --abort 
```

如果你在变基之后注意到你搞砸了：

```py
# reset branch back to the saved point
git reset --hard tmp 
```

如果您忘记创建备份分支：

```py
# look at the reflog of the branch
git reflog show my-feature-branch

8630830 my-feature-branch@{0}: commit: BUG: io: close file handles immediately
278dd2a my-feature-branch@{1}: rebase finished: refs/heads/my-feature-branch onto 11ee694744f2552d
26aa21a my-feature-branch@{2}: commit: BUG: lib: make seek_gzip_factory not leak gzip obj
...

# reset the branch to where it was before the botched rebase
git reset --hard my-feature-branch@{2} 
```

如果您没有真正出错，但有合并冲突，您需要解决这些冲突。这可能是最棘手的问题之一。有关如何解决冲突的详细说明，请参见[这篇关于合并冲突的文章](https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts)。

## 再做一些你可能想做的事情

### 重写提交历史

注意

这只适用于你自己的特性分支。

你的提交中有一个令人尴尬的拼写错误？或者你有几次错误的尝试，你不希望后人看到。

可以通过*交互式变基*完成此操作。

假设提交历史如下所示：

```py
git log --oneline
eadc391 Fix some remaining bugs
a815645 Modify it so that it works
2dec1ac Fix a few bugs + disable
13d7934 First implementation
6ad92e5 * masked is now an instance of a new object, MaskedConstant
29001ed Add pre-nep for a couple of structured_array_extensions.
... 
```

而`6ad92e5`是`main`分支中的最后一个提交。假设我们要进行以下更改：

+   将`13d7934`的提交信息改为更合理的内容。

+   将提交`2dec1ac`，`a815645`，`eadc391`合并为一个。

我们按以下步骤进行：

```py
# make a backup of the current state
git branch tmp HEAD
# interactive rebase
git rebase -i 6ad92e5 
```

这将在编辑器中打开以下文本：

```py
pick 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
pick a815645 Modify it so that it works
pick eadc391 Fix some remaining bugs

# Rebase 6ad92e5..eadc391 onto 6ad92e5
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
# 
```

为了实现我们想要的效果，我们将进行以下更改：

```py
r 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
f a815645 Modify it so that it works
f eadc391 Fix some remaining bugs 
```

这意味着（i）我们想要编辑`13d7934`的提交信息，并且（ii）将最后三个提交合并为一个。现在我们保存并退出编辑器。

Git 会立即打开一个编辑器来编辑提交信息。在修改后，我们得到输出：

```py
[detached HEAD 721fc64] FOO: First implementation
 2 files changed, 199 insertions(+), 66 deletions(-)
[detached HEAD 0f22701] Fix a few bugs + disable
 1 files changed, 79 insertions(+), 61 deletions(-)
Successfully rebased and updated refs/heads/my-feature-branch. 
```

现在历史看起来是这样的：

```py
0f22701 Fix a few bugs + disable
721fc64 ENH: Sophisticated feature
6ad92e5 * masked is now an instance of a new object, MaskedConstant 
```

如果出错了，可以通过上面解释的方法进行恢复。

### 在[github](https://github.com/numpy/numpy)上删除一个分支

```py
git checkout main
# delete branch locally
git branch -D my-unwanted-branch
# delete branch on github
git push origin --delete my-unwanted-branch 
```

参见：[`stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely`](https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely)

### 多个人共享一个仓库

如果您想与其他人一起处理某些事情，其中您都将提交到同一个仓库，甚至是同一个分支，那么请通过[github](https://github.com/numpy/numpy)共享它。

在创建一个 NumPy fork 中将 NumPy 首先 fork 到您的帐户。

然后，打开你的 forked 仓库的 github 页面，例如`https://github.com/your-user-name/numpy`

点击“管理员”按钮，并将其他任何人添加为仓库的合作者：

> ![../_images/pull_button.png](img/d9f57a07c985576ccac113b960131340.png)

现在所有这些人都可以做到：

```py
git clone git@github.com:your-user-name/numpy.git 
```

请记住，以`git@`开头的链接使用 ssh 协议，可读可写；以`git://`开头的链接为只读。

然后，你的合作者可以直接在那个仓库中进行提交，使用常规的方式：

```py
git commit -am 'ENH - much better code'
git push origin my-feature-branch # pushes directly into your repo 
```

### 检出来自现有 pull request 的更改

如果你想在 pull request 中测试更改或者在新的 pull request 中继续工作，那么提交将被克隆到你 fork 的存储库的本地分支中

首先确保你的上游指向主要存储库，参考[将您的存储库链接到上游存储库](https://scikit-image.org/docs/stable/gitwash/set_up_fork.html#linking-to-upstream "(在 skimage v0.21.0 中)")

然后，获取更改并创建一个本地分支。假设`$ID`是 pull request 的编号，`$BRANCHNAME`是你想要创建的*新的本地*分支的名称：

```py
git fetch upstream pull/$ID/head:$BRANCHNAME 
```

检出新创建的分支：

```py
git checkout $BRANCHNAME 
```

现在你把更改放入了 pull request 中。

### 探索你的存储库

要查看存储库分支和提交的图形表示：

```py
gitk --all 
```

查看此分支的线性提交列表：

```py
git log 
```

你也可以查看你的[Github](https://github.com/numpy/numpy)存储库的[网络图形可视化工具](https://github.blog/2008-04-10-say-hello-to-the-network-graph-visualizer/)。

### 回溯

回溯是将在[numpy/main](https://github.com/numpy/numpy)提交的新功能/修复复制到稳定版本发布分支的过程。为此，你需要在你要回溯到的分支上创建一个分支，从`numpy/main`中挑选你想要的提交，然后为包含回溯内容的分支提交一个 pull request。

1.  首先，你需要创建一个你将要工作的分支。它应该是基于较旧版本的 NumPy（而不是主分支）：

    ```py
    # Make a new branch based on numpy/maintenance/1.8.x,
    # backport-3324 is our new name for the branch.
    git checkout -b backport-3324 upstream/maintenance/1.8.x 
    ```

1.  现在，你需要使用[git cherry-pick](https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html)将 main 分支上的更改应用到这个分支上：

    ```py
    # Update remote
    git fetch upstream
    # Check the commit log for commits to cherry pick
    git log upstream/main
    # This pull request included commits aa7a047 to c098283 (inclusive)
    # so you use the .. syntax (for a range of commits), the ^ makes the
    # range inclusive.
    git cherry-pick aa7a047^..c098283
    ...
    # Fix any conflicts, then if needed:
    git cherry-pick --continue 
    ```

1.  你可能会遇到一些合并冲突。解决方法与其他合并/衍合冲突相同。此外，你可以使用[git blame](https://www.kernel.org/pub/software/scm/git/docs/git-blame.html)来查看主分支和回溯分支之间的差异，确保不会出现问题。

1.  推送新的分支到你的 Github 存储库：

    ```py
    git push -u origin backport-3324 
    ```

1.  最后使用 Github 发起一个 pull request。确保它是针对维护分支而不是主分支的，Github 通常会建议你将 pull request 发起到主分支。

### 推送更改到主要存储库

*需要对主要 NumPy 存储库拥有提交权限*

当你在一个特性分支上有一组“准备好的”更改，准备推送到 NumPy 的`main`或`maintenance`分支时，可以按如下方式将它们推送到`upstream`：

1.  首先，在目标分支上进行合并或衍合。

    1.  如果只有少量不相关的提交，则更倾向于使用衍合：

        ```py
        git fetch upstream
        git rebase upstream/main 
        ```

        参见在主分支上衍合。

    1.  如果所有的提交都是相关的，请创建一个合并提交：

        ```py
        git fetch upstream
        git merge --no-ff upstream/main 
        ```

1.  检查即将推送的内容是否合理：

    ```py
    git log -p upstream/main..
    git log --oneline --graph 
    ```

1.  推送到上游存储库：

    ```py
    git push upstream my-feature-branch:main 
    ```

注意

通常最好使用`-n`标志进行`git push`以先检查一下您将要将更改推送到您希望的位置。

## 基本工作流程

简而言之：

1.  为你所做的每一组编辑开始一个*特性分支*，参见下文。

1.  开始工作！参见下文

1.  完成后：

    +   *贡献者*：将您的功能分支推送到您自己的 Github 存储库，并创建一个拉取请求。

    +   *核心开发者*：如果您想要在不经过进一步审查的情况下推送更改，请阅读下面的备注（下方）。

这种工作方式有助于保持工作井然有序，使历史尽可能清晰。

参见

有许多在线教程可帮助您[学习 git](https://try.github.io/)。有关特定 git 工作流程的讨论，请参阅[linux git workflow](https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html)，以及[ipython git workflow](https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html) 。

### 创建一个新的功能分支

首先，请从`upstream`存储库中抓取新的提交：

```py
git fetch upstream 
```

然后，请基于上游存储库的主分支创建一个新分支：

```py
git checkout -b my-new-feature upstream/main 
```  ### 编辑工作流程

#### 概述

```py
# hack hack
git status # Optional
git diff # Optional
git add modified_file
git commit
# push the branch to your own Github repo
git push origin my-new-feature 
```

#### 更详细的内容

1.  进行一些更改。当您感觉自己完成了一组完整的相关更改时，请继续下一步。

1.  可选：使用 `git status` 检查更改了哪些文件（请参阅[git status](https://www.kernel.org/pub/software/scm/git/docs/git-status.html)）。您将看到如下列表：

    ```py
    # On branch my-new-feature
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #   (use "git checkout -- <file>..." to discard changes in working directory)
    #
    #  modified:   README
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #  INSTALL
    no changes added to commit (use "git add" and/or "git commit -a") 
    ```

1.  可选：使用 `git diff` 与先前版本比较变化（查看[git diff](https://www.kernel.org/pub/software/scm/git/docs/git-diff.html)）。这将带来一个简单的文本浏览器界面，突出显示您的文件与先前版本之间的差异。

1.  使用 `git add modified_file` 添加任何相关的修改或新文件（请参阅[git add](https://www.kernel.org/pub/software/scm/git/docs/git-add.html)）。这将把文件放入暂存区，这是一个将添加到您下一个提交的文件队列。只添加具有相关完整更改的文件。将未完成更改的文件留到后续提交。

1.  要将暂存文件提交到您的本地存储库副本中，请执行 `git commit`。此时，将打开一个文本编辑器，允许您编写提交消息。阅读提交消息部分 确保您正在编写格式正确且足够详细的提交消息。保存消息并关闭编辑器后，您的提交将被保存。对于琐碎的提交，可以使用 `-m` 标志通过命令行传递简短的提交消息。例如，`git commit -am "ENH: Some message"`。

    在某些情况下，您将看到提交命令的这种形式：`git commit -a`。额外的`-a`标志会自动提交所有修改后的文件，并删除所有已删除的文件。这可以帮您节省一些输入大量`git add`命令的时间；然而，如果不仔细，它可能会给提交添加不想要的更改。更多信息，请参阅[为什么使用 -a 标志？](http://www.gitready.com/beginner/2009/01/18/the-staging-area.html) - 以及在 [纠缠的工作副本问题](https://tomayko.com/writings/the-thing-about-git) 中有用的用例描述。

1.  将更改推送到您在[github](https://github.com/numpy/numpy)上 fork 的仓库：

    ```py
    git push origin my-new-feature 
    ```

    获取更多信息，请参阅[git push](https://www.kernel.org/pub/software/scm/git/docs/git-push.html)。

注意

假设您已经按照这些页面中的说明操作，git 会为您的[github](https://github.com/numpy/numpy)仓库创建一个名为`origin`的默认链接。在 git >= 1.7 中，您可以使用`--set-upstream`选项确保永久设置到 origin 的链接：

```py
git push --set-upstream origin my-new-feature 
```

从现在开始，[git](https://git-scm.com/)将知道`my-new-feature`和您自己的[github](https://github.com/numpy/numpy)仓库中的`my-new-feature`分支相关联。此后的 push 调用可以简化为以下形式：

```py
git push 
```

对于每个新分支，您必须使用`--set-upstream`。

可能存在这样的情况，即在您编辑时，`upstream`中新增了对您工作有影响的新提交。在这种情况下，请按照本文档的 Rebasing on main 部分的指示将这些更改应用到您的分支上。

#### 编写提交消息

提交消息应该清晰并遵循一些基本规则。例如：

```py
ENH: add functionality X to numpy.<submodule>.

The first line of the commit message starts with a capitalized acronym
(options listed below) indicating what type of commit this is.  Then a blank
line, then more text if needed.  Lines shouldn't be longer than 72
characters.  If the commit is related to a ticket, indicate that with
"See #3456", "See ticket 3456", "Closes #3456" or similar. 
```

在提交消息中描述更改的动机、修复错误的性质或有关增强功能的一些细节也很有必要。提交消息应该可以在不查看代码更改的情况下就能理解。`MAINT: fixed another one`这样的提交消息是一个不好的示例；读者必须去其他地方找上下文。

进行提交消息时，应该使用以下标准首字母缩写：

```py
API: an (incompatible) API change
BENCH: changes to the benchmark suite
BLD: change related to building numpy
BUG: bug fix
DEP: deprecate something, or remove a deprecated object
DEV: development tool or utility
DOC: documentation
ENH: enhancement
MAINT: maintenance commit (refactoring, typos, etc.)
REV: revert an earlier commit
STY: style fix (whitespace, PEP8)
TST: addition or modification of tests
TYP: static typing
REL: related to releasing numpy 
```

##### 跳过持续集成的命令

默认情况下，每个 PR 会运行很多持续集成（CI）作业，从在不同操作系统和硬件平台上运行测试套件到构建文档。在某些情况下，您已经知道不需要 CI（或者不是全部 CI），例如，如果您正在处理 CI 配置文件、README 中的文本或者其他不涉及常规构建、测试或文档序列的文件。在这种情况下，您可以通过在提交消息中包含以下任一片段来显式跳过 CI：

+   `[skip ci]`：跳过所有 CI

    仅在您还没有准备好在 PR 上运行检查时才推荐使用（例如，如果只是草稿而已）。

+   `[skip actions]`：跳过 GitHub Actions 作业

    [GitHub Actions](https://docs.github.com/actions)是运行大多数 CI 检查的地方，包括 linter、基准测试、运行大多数体系结构和操作系统的基本测试以及几个编译器和 CPU 优化设置。[请参阅这些检查的配置文件。](https://github.com/numpy/numpy/tree/main/.github/workflows)

+   `[skip travis]`：跳过 TravisCI 作业

    [TravisCI](https://www.travis-ci.com/)将对您的更改在 PowerPC 和 s390x 架构上的 Python 3.9 进行测试。[请参阅这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.travis.yml)

+   `[skip azp]`：跳过 Azure 作业

    [Azure](https://azure.microsoft.com/en-us/products/devops/pipelines) 是运行所有综合测试的地方。这是一个昂贵的运行，如果您只进行文档更改，那么通常可以跳过这个运行。[请查看这些检查的主配置文件。](https://github.com/numpy/numpy/blob/main/azure-pipelines.yml)

+   `[跳过 Circle]`: 跳过 CircleCI 作业

    [CircleCI](https://circleci.com/) 是我们构建文档并存储生成的预览文件的地方。此检查还将运行所有文档字符串示例并验证其结果。如果你没有进行文档更改，但进行了函数 API 的更改，例如，你可能需要运行这些测试来验证文档测试仍然有效。[请查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.circleci/config.yml)

+   `[跳过 Cirrus]`: 跳过 Cirrus 作业

    [CirrusCI](https://cirrus-ci.org/)主要触发 Linux aarch64 和 MacOS Arm64 的 wheels 上传。[请查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.cirrus.star)

##### 测试构建 wheels

Numpy 目前使用 [cibuildwheel](https://https://cibuildwheel.readthedocs.io/en/stable/) 来通过持续集成服务构建 wheels。为节省资源，默认情况下不会在每个单独的 PR 或提交到主分支时运行 cibuildwheel wheel 构建器。

如果您想测试您的 pull request 是否导致 wheel 构建器失败，您可以将 `[wheel build]` 添加到提交的提交消息的末尾，或者如果有权限的话，将以下标签之一添加到 pull request 中：

+   `36 - 构建`: 用于更改构建过程/配置的 pull requests

+   `03 - 维护`: 用于升级依赖项的 pull requests

+   `14 - 发布`: 用于准备发布的 pull requests

通过 github actions 构建的 wheels（包括 64 位 linux、macOS 和 windows, arm64 macOS 和 32 位 windows）将以 zip 文件的形式上传为 artifacts。您可以从“Wheel builder” [Action](https://github.com/numpy/numpy/actions) 的摘要页面访问它们。通过 [travis](https://app.travis-ci.com/github/numpy/numpy/builds) CI 构建的 aarch64 wheels 不作为 artifacts 提供。此外，如果满足以下条件，wheels 将上传至 [`anaconda.org/scientific-python-nightly-wheels/`](https://anaconda.org/scientific-python-nightly-wheels/)：

+   通过每周的定时作业或

+   如果 github action 或 travis 构建是手动触发的，需要适当的权限

如果构建是由以 `v` 开头的标签触发，则 wheels 将上传至 [`anaconda.org/multibuild-wheels-staging/`](https://anaconda.org/multibuild-wheels-staging/) ### 获取邮件列表的意见

如果您计划进行新的功能或 API 更改，最明智的做法是先发送电子邮件给 NumPy [邮件列表](https://mail.python.org/mailman/listinfo/numpy-discussion)询问意见。如果一周内没有收到回复，再次发送电子邮件也可以。  ### 请求将您的更改与主存储库合并

当您觉得您的工作已经完成，可以创建一个拉取请求（PR）。Github 有一个很好的帮助页面来概述[提交拉取请求的过程](https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request)。

如果您的更改涉及对 API 的修改或添加/修改功能，请在`doc/release/upcoming_changes/`目录下添加一个发布说明，按照`doc/release/upcoming_changes/README.rst`文件中的说明和格式操作。  ### 获取您的 PR 审查

我们会尽快审查拉取请求，通常在一周内。如果在两周内没有评论，可以在 PR 上添加评论要求反馈（这将通知维护者）。

如果您的 PR 较大或较复杂，向 numpy-discussion 邮件列表请求输入可能也是有用的。  ### 变基到主分支

这将使用 upstream [NumPy github](https://github.com/numpy/numpy)仓库中的更改更新您的特性分支。如果不是绝对需要这样做，请尽量避免这样做，除非您已经完成了。第一步将是使用新提交来更新远程存储库：

```py
git fetch upstream 
```

接下来，您需要更新特性分支：

```py
# go to the feature branch
git checkout my-new-feature
# make a backup in case you mess up
git branch tmp my-new-feature
# rebase on upstream main branch
git rebase upstream/main 
```

如果您对已经发生改变的文件进行了修改，这可能会产生您需要解决的合并冲突。在这种情况下，参见下文获取帮助。

最后，在成功的变基后，删除备份分支：

```py
git branch -D tmp 
```

注

变基到主分支优先于将 upstream 合并到您的分支。在处理特性分支时，不鼓励使用`git merge`和`git pull`。  ### 从搞砸中恢复

有时，您可能会搞砸合并或变基。幸运的是，在 Git 中相对简单地从这些错误中恢复。

如果在变基期间出现了问题：

```py
git rebase --abort 
```

如果您在变基后注意到您搞砸了：

```py
# reset branch back to the saved point
git reset --hard tmp 
```

如果您忘记创建备份分支：

```py
# look at the reflog of the branch
git reflog show my-feature-branch

8630830 my-feature-branch@{0}: commit: BUG: io: close file handles immediately
278dd2a my-feature-branch@{1}: rebase finished: refs/heads/my-feature-branch onto 11ee694744f2552d
26aa21a my-feature-branch@{2}: commit: BUG: lib: make seek_gzip_factory not leak gzip obj
...

# reset the branch to where it was before the botched rebase
git reset --hard my-feature-branch@{2} 
```

如果您实际上并没有搞砸，但存在合并冲突，您需要解决这些问题。这可能是比较棘手的事情之一。有关如何做到这一点的优秀说明，请参阅[这篇关于解决冲突的文章](https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts)。

首先，从`upstream`存储库中提取新的提交：

```py
git fetch upstream 
```

然后，基于 upstream 存储库的主分支创建新分支：

```py
git checkout -b my-new-feature upstream/main 
```

### 编辑工作流程

#### 概述

```py
# hack hack
git status # Optional
git diff # Optional
git add modified_file
git commit
# push the branch to your own Github repo
git push origin my-new-feature 
```

#### 更详细

1.  进行一些更改。当您感到已经完成一组相关的完整工作时，可以继续下一步。

1.  可选：使用 `git status` 检查哪些文件发生了变化（参见 [git status](https://www.kernel.org/pub/software/scm/git/docs/git-status.html)）。你会看到像下面这样的列表：

    ```py
    # On branch my-new-feature
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #   (use "git checkout -- <file>..." to discard changes in working directory)
    #
    #  modified:   README
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #  INSTALL
    no changes added to commit (use "git add" and/or "git commit -a") 
    ```

1.  可选：使用 `git diff`（参见 [git diff](https://www.kernel.org/pub/software/scm/git/docs/git-diff.html)）比较更改与上一个版本。这将带出一个简单的文本浏览器界面，突出显示你的文件与上一个版本之间的差异。

1.  使用 `git add modified_file` 添加任何相关的修改或新文件（参见 [git add](https://www.kernel.org/pub/software/scm/git/docs/git-add.html)）。这将把文件放入暂存区，即下一个提交要添加的文件队列。仅添加具有相关、完整更改的文件。将未完成更改的文件留到后续的提交中。

1.  要将暂存的文件提交到本地副本仓库，请执行 `git commit`。此时，一个文本编辑器将打开，允许你编写提交消息。请阅读 提交消息部分 以确保你编写了格式正确且足够详细的提交消息。保存消息并关闭编辑器后，你的提交将被保存。对于琐碎的提交，可以使用 `-m` 标志通过命令行传递短的提交消息。例如，`git commit -am "ENH: Some message"`。

    在某些情况下，你可能会看到 `git commit -a` 形式的提交命令。额外的 `-a` 标志会自动提交所有修改的文件并删除所有已删除的文件。这可以节省大量输入的 `git add` 命令；然而，如果不小心，它可能会在提交中添加不需要的更改。更多信息，请参见 [为什么要使用 -a 标志？](http://www.gitready.com/beginner/2009/01/18/the-staging-area.html) - 以及 [包含综合用例描述的有用工作副本问题](https://tomayko.com/writings/the-thing-about-git)。

1.  将更改推送到你在 [github](https://github.com/numpy/numpy) 上 fork 的仓库：

    ```py
    git push origin my-new-feature 
    ```

    更多信息，请参见 [git push](https://www.kernel.org/pub/software/scm/git/docs/git-push.html)。

注意

假设你已经按照这些页面上的说明进行了操作，git 将会创建一个指向你的 [github](https://github.com/numpy/numpy) 仓库的默认链接，称为 `origin`。在 git >= 1.7 中，你可以使用 `--set-upstream` 选项来确保链接到 origin 是永久设置的：

```py
git push --set-upstream origin my-new-feature 
```

从现在起，[git](https://git-scm.com/) 将会知道 `my-new-feature` 与你自己的 [github](https://github.com/numpy/numpy) 仓库中的 `my-new-feature` 分支相关。随后的推送操作将被简化为以下内容：

```py
git push 
```

对于你创建的每个新分支，都必须使用 `--set-upstream`。

可能的情况是，在你编辑时，`upstream` 添加了影响你工作的新提交。在这种情况下，请按照本文档的 Rebasing on main 部分的说明将这些更改应用到你的分支上。

#### 编写提交消息

提交消息应该清晰，并遵循一些基本规则。例如：

```py
ENH: add functionality X to numpy.<submodule>.

The first line of the commit message starts with a capitalized acronym
(options listed below) indicating what type of commit this is.  Then a blank
line, then more text if needed.  Lines shouldn't be longer than 72
characters.  If the commit is related to a ticket, indicate that with
"See #3456", "See ticket 3456", "Closes #3456" or similar. 
```

在提交消息中描述变更的动机，修复错误或增强的性质等具体细节也是很好的。提交消息应该能够在不看代码变更的情况下理解。像`MAINT: fixed another one`这样的提交消息就是一个反面教材；读者必须去其他地方查看背景信息。

要在提交消息开头使用的标准首字母缩写为：

```py
API: an (incompatible) API change
BENCH: changes to the benchmark suite
BLD: change related to building numpy
BUG: bug fix
DEP: deprecate something, or remove a deprecated object
DEV: development tool or utility
DOC: documentation
ENH: enhancement
MAINT: maintenance commit (refactoring, typos, etc.)
REV: revert an earlier commit
STY: style fix (whitespace, PEP8)
TST: addition or modification of tests
TYP: static typing
REL: related to releasing numpy 
```

##### 跳过持续集成的命令

默认情况下，每个 PR 都会运行大量的持续集成（CI）作业，包括在不同操作系统和硬件平台上运行测试套件以及构建文档。在某些情况下，你已经知道不需要 CI（或者不需要全部），例如如果你在 CI 配置文件、README 中的文本或其他不涉及常规构建、测试或文档序列的文件上工作。在这种情况下，你可以通过在提交消息中包含以下片段之一来明确地跳过 CI：

+   `[skip ci]`: 跳过所有 CI

    只有在你的 PR 还没有准备好进行检查时才推荐使用（例如，如果这只是一个草稿）。

+   `[skip actions]`: 跳过 GitHub Actions 工作

    [GitHub Actions](https://docs.github.com/actions) 是大多数 CI 检查运行的地方，包括代码检查、基准测试、大部分架构和操作系统的基本测试，以及几个编译器和 CPU 优化设置。[点击以查看这些检查的配置文件。](https://github.com/numpy/numpy/tree/main/.github/workflows)

+   `[skip travis]`: 跳过 TravisCI 工作

    [TravisCI](https://www.travis-ci.com/) 将在 PowerPC 和 s390x 架构上测试你的更改对 Python 3.9 的兼容性。[点击以查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.travis.yml)

+   `[skip azp]`: 跳过 Azure 工作

    [Azure](https://azure.microsoft.com/en-us/products/devops/pipelines) 是运行所有全面测试的地方。这是一个昂贵的运行，如果你只是做文档更改，可能会跳过。[点击以查看这些检查的主配置文件。](https://github.com/numpy/numpy/blob/main/azure-pipelines.yml)

+   `[skip circle]`: 跳过 CircleCI 工作

    [CircleCI](https://circleci.com/) 是我们构建文档并在每个 PR 中存储生成的预览文件的地方。此检查还将运行所有的文档字符串示例并验证它们的结果。如果你不对文档进行更改，但对函数的 API 进行更改，例如，你可能需要运行这些测试来验证 doctest 是否仍然有效。[点击以查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.circleci/config.yml)

+   `[skip cirrus]`: 跳过 Cirrus 工作

    [CirrusCI](https://cirrus-ci.org/) 主要触发 Linux aarch64 和 MacOS Arm64 轮上传。[点击以查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.cirrus.star)

##### 测试构建轮上传

Numpy 目前使用 [cibuildwheel](https://https://cibuildwheel.readthedocs.io/en/stable/) 来通过持续集成服务构建轮子。为了节省资源，默认情况下不会在每个单独的 PR 或提交到主分支时运行 cibuildwheel 轮子构建器。

如果您想测试您的拉取请求是否破坏了构建程序，您可以在提交消息的末尾附加 `[wheel build]`，或者在拉取请求中添加以下标签之一（如果您有权限这样做的话）：

+   `36 - 构建`: 用于更改构建过程/配置的拉取请求

+   `03 - 维护`: 用于更新依赖项的拉取请求

+   `14 - 发布`: 用于准备发布的拉取请求

通过 github actions 构建的轮子（包括 64 位 Linux、macOS 和 Windows，arm64 macOS 和 32 位 Windows）将以 zip 文件的形式上传为工件。您可以从“Wheel builder” [Action](https://github.com/numpy/numpy/actions) 的摘要页面访问它们。通过 [travis](https://app.travis-ci.com/github/numpy/numpy/builds) CI 构建的 aarch64 轮子不作为工件提供。此外，轮子将根据以下条件上传到 [`anaconda.org/scientific-python-nightly-wheels/`](https://anaconda.org/scientific-python-nightly-wheels/)：

+   由每周的定期 cron 任务执行或

+   如果 github action 或 travis 构建已手动触发，则需要适当的权限

如果构建是由以 `v` 开头的仓库标签触发的，则将轮子上传到 [`anaconda.org/multibuild-wheels-staging/`](https://anaconda.org/multibuild-wheels-staging/)

#### 概述

```py
# hack hack
git status # Optional
git diff # Optional
git add modified_file
git commit
# push the branch to your own Github repo
git push origin my-new-feature 
```

#### 更详细

1.  进行一些更改。当你觉得已经完成了一组相关的工作，并且是可工作的时候，就可以继续下一步了。

1.  可选：使用 `git status` 检查哪些文件发生了变化（参见 [git status](https://www.kernel.org/pub/software/scm/git/docs/git-status.html)）。您将看到类似于这样的列表：

    ```py
    # On branch my-new-feature
    # Changed but not updated:
    #   (use "git add <file>..." to update what will be committed)
    #   (use "git checkout -- <file>..." to discard changes in working directory)
    #
    #  modified:   README
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #  INSTALL
    no changes added to commit (use "git add" and/or "git commit -a") 
    ```

1.  可选：使用 `git diff` ([git diff](https://www.kernel.org/pub/software/scm/git/docs/git-diff.html)) 比较更改与上一个版本的区别。这将带来一个简单的文本浏览器界面，突出显示您的文件与上一个版本之间的差异。

1.  使用 `git add modified_file`（参见 [git add](https://www.kernel.org/pub/software/scm/git/docs/git-add.html)）添加任何相关的修改或新文件。这将把文件放入暂存区，即将添加到您的下一个提交的文件队列。只添加具有相关、完整更改的文件。将具有未完成更改的文件留到以后提交。

1.  要将暂存文件提交到本地仓库的副本中，请使用`git commit`。此时，文本编辑器将打开，允许你编写提交消息。请阅读 commit message section 以确保你正在编写格式正确且详细的提交消息。保存消息并关闭编辑器后，你的提交将被保存。对于琐碎的提交，可以通过命令行使用`-m`标志传递简短的提交消息。例如，`git commit -am "ENH: Some message"`。

    在某些情况下，你会看到这种形式的提交命令：`git commit -a`。额外的`-a`标志会自动提交所有修改的文件，并删除所有已删除的文件。这可以节省你大量使用`git add`命令的输入；但是，如果不小心的话，它可能会向提交添加不必要的更改。欲了解更多信息，请参阅[为什么使用-a 标志？](http://www.gitready.com/beginner/2009/01/18/the-staging-area.html) - 以及在[纠缠的工作副本问题](https://tomayko.com/writings/the-thing-about-git)中的有用用例描述。

1.  将更改推送到你在[github](https://github.com/numpy/numpy)上分叉的仓库：

    ```py
    git push origin my-new-feature 
    ```

    欲了解更多信息，请参阅[git push](https://www.kernel.org/pub/software/scm/git/docs/git-push.html)。

注意

假设你已经按照这些页面的说明操作，git 将创建到你的[github](https://github.com/numpy/numpy)仓库的默认链接称为`origin`。在 git >= 1.7 中，你可以使用`--set-upstream`选项确保链接到 origin 永久设置：

```py
git push --set-upstream origin my-new-feature 
```

从现在开始，git 将知道`my-new-feature`与你自己的[github](https://github.com/numpy/numpy)仓库中的`my-new-feature`分支相关联。随后的推送调用将简化如下：

```py
git push 
```

你必须为每个创建的新分支使用`--set-upstream`。

可能情况是，当你在编辑时，`upstream`会添加对你的工作有影响的新提交。在这种情况下，请遵循本文档的 Rebasing on main 部分，将这些更改应用到你的分支上。

#### 编写提交消息

提交消息应明确，并遵循一些基本规则。例如：

```py
ENH: add functionality X to numpy.<submodule>.

The first line of the commit message starts with a capitalized acronym
(options listed below) indicating what type of commit this is.  Then a blank
line, then more text if needed.  Lines shouldn't be longer than 72
characters.  If the commit is related to a ticket, indicate that with
"See #3456", "See ticket 3456", "Closes #3456" or similar. 
```

描述更改的动机，修复 bug 的性质或增强功能的一些细节也是需要在提交消息中包含的好内容。提交消息应可不查看代码更改即可理解。像`MAINT: fixed another one`这样的提交消息是一个反例；读者必须去其他地方查找上下文。

以标准缩略词开始提交消息的是：

```py
API: an (incompatible) API change
BENCH: changes to the benchmark suite
BLD: change related to building numpy
BUG: bug fix
DEP: deprecate something, or remove a deprecated object
DEV: development tool or utility
DOC: documentation
ENH: enhancement
MAINT: maintenance commit (refactoring, typos, etc.)
REV: revert an earlier commit
STY: style fix (whitespace, PEP8)
TST: addition or modification of tests
TYP: static typing
REL: related to releasing numpy 
```

##### 跳过持续集成的命令

默认情况下，针对每个 PR 都会运行许多持续集成（CI）作业，从在不同操作系统和硬件平台上运行测试套件到构建文档等。在某些情况下，您可能已经知道不需要进行 CI（或者不需要全部 CI），例如，如果您正在处理 CI 配置文件，README 中的文本或其他不涉及常规构建、测试或文档序列的文件。在这种情况下，您可以通过在提交消息中包含以下片段之一来明确跳过 CI：

+   `[skip ci]`: 跳过所有 CI

    仅在您仍未准备好运行检查的情况下才建议使用（例如，如果这只是一个草稿）。

+   `[skip actions]`: 跳过 GitHub Actions 作业

    [GitHub Actions](https://docs.github.com/actions)是大多数 CI 检查都运行的地方，包括检查程序、基准测试、对大多数架构和操作系统运行基本测试，以及若干编译器和 CPU 优化设置。[查看这些检查的配置文件。](https://github.com/numpy/numpy/tree/main/.github/workflows)

+   `[skip travis]`: 跳过 TravisCI 作业

    [TravisCI](https://www.travis-ci.com/)将针对 Python 3.9 在 PowerPC 和 s390x 架构上测试您的更改。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.travis.yml)

+   `[skip azp]`: 跳过 Azure 作业

    [Azure](https://azure.microsoft.com/en-us/products/devops/pipelines)是运行所有综合测试的地方。这是一个昂贵的运行，如果您只进行文档更改，例如，您通常可以跳过这一步。[查看这些检查的主配置文件。](https://github.com/numpy/numpy/blob/main/azure-pipelines.yml)

+   `[skip circle]`: 跳过 CircleCI 作业

    [CircleCI](https://circleci.com/)是我们构建文档并在每个 PR 中存储生成的预览文件的地方。此检查还将运行所有的文档字符串示例并验证它们的结果。如果您不进行文档更改，但对函数的 API 进行更改，例如，您可能需要运行这些测试以验证文档测试是否仍然有效。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.circleci/config.yml)

+   `[skip cirrus]`: 跳过 Cirrus 作业

    [CirrusCI](https://cirrus-ci.org/)主要触发 Linux aarch64 和 MacOS Arm64 的上传。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.cirrus.star)

##### 测试构建轮子

Numpy 目前使用[cibuildwheel](https://https://cibuildwheel.readthedocs.io/en/stable/)来通过持续集成服务构建轮子。为了节省资源，cibuildwheel 轮子构建器不会在每个单独的 PR 或提交到主分支上默认运行。

如果您想要测试您的拉取请求不会破坏轮子构建器，您可以在提交的提交消息的末尾附加`[wheel build]`，或者在拉取请求中添加以下标签中的一个（如果您有权限这样做）：

+   `36 - 构建`：适用于更改构建流程/配置的拉取请求

+   `03 - 维护`：适用于升级依赖项的拉取请求

+   `14 - 发布`：用于准备发布的拉取请求

通过 github 动作构建的轮子（包括 64 位 linux、macOS 和 windows，arm64 macOS 和 32 位 windows）将作为 zip 文件上传为工件。你可以从“Wheel builder”[Action](https://github.com/numpy/numpy/actions)的摘要页面访问它们。通过[travis](https://app.travis-ci.com/github/numpy/numpy/builds) CI 构建的 aarch64 轮子不以工件形式提供。此外，如果满足以下条件，这些轮子将被上传到[`anaconda.org/scientific-python-nightly-wheels/`](https://anaconda.org/scientific-python-nightly-wheels/)：

+   通过每周的定期计划作业或

+   如果 github 动作或 travis 构建已经手动触发，这需要适当的权限

如果构建是由仓库以`v`开头的标签触发的，这些轮子将被上传到[`anaconda.org/multibuild-wheels-staging/`](https://anaconda.org/multibuild-wheels-staging/)

##### 跳过持续集成的命令

默认情况下，每个 PR 都会运行许多持续集成（CI）作业，从在不同操作系统和硬件平台上运行测试套件到构建文档。在某些情况下，你可能已经知道不需要 CI（或者不需要全部），例如，如果你在 CI 配置文件、README 中的文本，或者其他不涉及正常构建、测试或文档序列的文件上工作。在这种情况下，你可以通过在提交消息中包含以下片段来显式地跳过 CI：

+   `[跳过 ci]`：跳过所有 CI

    只有在你还没有准备好进行 PR 检查时才建议这样做（例如，如果这只是一个草稿）。

+   `[跳过 actions]`：跳过 GitHub Actions 作业

    [GitHub Actions](https://docs.github.com/actions) 是大多数 CI 检查的运行位置，包括代码检查器、基准测试、对大多数架构和操作系统运行基本测试，以及几个编译器和 CPU 优化设置。[查看这些检查的配置文件。](https://github.com/numpy/numpy/tree/main/.github/workflows)

+   `[跳过 travis]`：跳过 TravisCI 作业

    [TravisCI](https://www.travis-ci.com/) 将在 PowerPC 和 s390x 架构上测试您的更改是否适用于 Python 3.9。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.travis.yml)

+   `[跳过 azp]`：跳过 Azure 作业

    [Azure](https://azure.microsoft.com/en-us/products/devops/pipelines) 是运行所有综合测试的地方。这是一个昂贵的运行，如果你只是进行文档方面的更改，你通常可以跳过。[查看这些检查的主配置文件。](https://github.com/numpy/numpy/blob/main/azure-pipelines.yml)

+   `[跳过 circle]`：跳过 CircleCI 作业

    [CircleCI](https://circleci.com/) 是我们构建文档并存储生成的预览内容的地方。此检查还将运行所有文档字符串示例并验证其结果。如果您没有对文档进行更改，但对函数的 API 进行了更改，例如，您可能需要运行这些测试以验证 doctests 仍然有效。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.circleci/config.yml)

+   `[跳过 Cirrus]`: 跳过 Cirrus 任务

    [CirrusCI](https://cirrus-ci.org/) 主要触发 Linux aarch64 和 MacOS Arm64 轮毂上传。[查看这些检查的配置文件。](https://github.com/numpy/numpy/blob/main/.cirrus.star)

##### 测试构建轮毂

目前 Numpy 使用 [cibuildwheel](https://https://cibuildwheel.readthedocs.io/en/stable/) 来通过持续集成服务构建轮毂。为了节省资源，cibuildwheel 轮毂构建器默认情况下不会在每个单独的 PR 或提交到主存储库上运行。

如果您想要测试您的拉取请求不会破坏轮毂构建器，您可以在提交消息的结尾添加`[wheel build]`，或者如果有权限，可以在拉取请求中添加以下任一标签：

+   `36 - 构建：用于更改构建过程/配置的拉取请求`

+   `03 - 维护：用于更新依赖关系的拉取请求`

+   `14 - 发布：用于准备发布的拉取请求`

通过 github actions 构建的轮毂（包括 64 位 Linux、macOS 和 Windows、arm64 macOS 和 32 位 Windows）将以 zip 文件的形式作为构件上传。您可以从“轮毂构建器”[操作](https://github.com/numpy/numpy/actions)的总览页面访问它们。通过 [travis](https://app.travis-ci.com/github/numpy/numpy/builds) CI 构建的 aarch64 轮毂不作为构件提供。此外，如果满足以下条件，这些轮毂将被上传到 [`anaconda.org/scientific-python-nightly-wheels/`](https://anaconda.org/scientific-python-nightly-wheels/)：

+   通过每周的定时任务或者

+   如果 github action 或 travis 构建是手动触发的，这需要适当的权限

如果该构建是由以`v`开头的 tag 触发的，将轮毂上传到 [`anaconda.org/multibuild-wheels-staging/`](https://anaconda.org/multibuild-wheels-staging/)

### 获取邮件列表的意见

如果您计划添加新功能或 API 更改，最明智的做法是先给 NumPy [邮件列表](https://mail.python.org/mailman/listinfo/numpy-discussion) 发电子邮件请求评论。如果一周内没有回复，可以再次发送电子邮件询问。

### 请将您的更改申请合并到主存储库

当您感到工作已经完成时，可以创建一个拉取请求（PR）。 Github 有一个很好的帮助页面，概述了 [提交拉取请求](https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request) 的过程。

如果您的更改涉及对 API 进行修改或添加/修改了某个函数，需要在 `doc/release/upcoming_changes/` 目录中添加一个发布说明，按照 `doc/release/upcoming_changes/README.rst` 文件中的说明和格式进行操作。

### 获取您的 PR 审核

我们会尽快审查 PR，通常在一周内，如果在两周内没有收到审查意见，欢迎通过在您的 PR 上添加评论来征求反馈（这将会提醒维护者）。

如果您的 PR 较大或较复杂，询问 numpy-discussion 邮件列表上的意见也可能会有用。

### 变基到主分支

这会将您的功能分支与上游[NumPy 的 GitHub](https://github.com/numpy/numpy) 仓库的更改同步。如果非常不需要这样做，请尽量避免这样做，除非您已经完成。第一步将是从上游更新远程仓库中的新提交：

```py
git fetch upstream 
```

接下来，您需要更新功能分支：

```py
# go to the feature branch
git checkout my-new-feature
# make a backup in case you mess up
git branch tmp my-new-feature
# rebase on upstream main branch
git rebase upstream/main 
```

如果您对已经在上游发生了更改的文件进行了更改，可能会引发您需要解决的合并冲突。有关在这种情况下的帮助，请参见下文。

最后，在成功变基后删除备份分支：

```py
git branch -D tmp 
```

注意

优先使用变基到主分支，而不是把上游合并回您的分支。在处理功能分支时，不建议使用 `git merge` 和 `git pull`。

### 从错误中恢复

有时候，您会在合并或变基时搞砸。幸运的是，在 Git 中，从这样的错误中恢复相对容易。

如果您在变基时搞砸了：

```py
git rebase --abort 
```

如果您在变基之后发现自己搞砸了：

```py
# reset branch back to the saved point
git reset --hard tmp 
```

如果您忘了制作备份分支：

```py
# look at the reflog of the branch
git reflog show my-feature-branch

8630830 my-feature-branch@{0}: commit: BUG: io: close file handles immediately
278dd2a my-feature-branch@{1}: rebase finished: refs/heads/my-feature-branch onto 11ee694744f2552d
26aa21a my-feature-branch@{2}: commit: BUG: lib: make seek_gzip_factory not leak gzip obj
...

# reset the branch to where it was before the botched rebase
git reset --hard my-feature-branch@{2} 
```

如果实际上您没有搞砸，但出现合并冲突，那就需要解决这些问题。这可能是让人比较头痛的事情之一。有关如何处理这个问题的详细描述，请参见[这篇合并冲突的文章](https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts)。

## 您可能还需要做的其他事情

### 重写提交历史

注意

仅适用于您自己的功能分支。

在您提交的更改中有一个令人尴尬的拼写错误？或者您可能有几次错误的开始，不希望后人看到。

这可以通过*交互式变基*来完成。

假设提交历史看起来是这样的：

```py
git log --oneline
eadc391 Fix some remaining bugs
a815645 Modify it so that it works
2dec1ac Fix a few bugs + disable
13d7934 First implementation
6ad92e5 * masked is now an instance of a new object, MaskedConstant
29001ed Add pre-nep for a couple of structured_array_extensions.
... 
```

`6ad92e5` 是 `main` 分支中的最后一个提交。假设我们需要做以下更改：

+   重新编写 `13d7934` 的提交消息，变得更合理。

+   将提交 `2dec1ac`、`a815645`、`eadc391` 合并为一个。

我们按照以下步骤进行：

```py
# make a backup of the current state
git branch tmp HEAD
# interactive rebase
git rebase -i 6ad92e5 
```

这将打开一个编辑器，并在其中显示以下文本：

```py
pick 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
pick a815645 Modify it so that it works
pick eadc391 Fix some remaining bugs

# Rebase 6ad92e5..eadc391 onto 6ad92e5
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
# 
```

为达到我们的目的，我们将对其进行以下更改：

```py
r 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
f a815645 Modify it so that it works
f eadc391 Fix some remaining bugs 
```

这意味着（i）我们想编辑 `13d7934` 的提交消息，以及（ii）将最后的三个提交合并成一个。现在保存并退出编辑器。

然后 Git 立即会带出一个编辑器，用于编辑提交消息。修改后，我们获得输出：

```py
[detached HEAD 721fc64] FOO: First implementation
 2 files changed, 199 insertions(+), 66 deletions(-)
[detached HEAD 0f22701] Fix a few bugs + disable
 1 files changed, 79 insertions(+), 61 deletions(-)
Successfully rebased and updated refs/heads/my-feature-branch. 
```

此时，历史记录如下：

```py
0f22701 Fix a few bugs + disable
721fc64 ENH: Sophisticated feature
6ad92e5 * masked is now an instance of a new object, MaskedConstant 
```

如果出现问题，可以再次按照上面的方法进行恢复。

### 删除[github](https://github.com/numpy/numpy)上的分支

```py
git checkout main
# delete branch locally
git branch -D my-unwanted-branch
# delete branch on github
git push origin --delete my-unwanted-branch 
```

参见：[`stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely`](https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely)

### 多人共享一个单一的存储库

如果您想和其他人一起处理一些事情，大家一起提交到同一个存储库，甚至是同一个分支中，只需通过[github](https://github.com/numpy/numpy)共享即可。

首先将 NumPy 派生到您的帐户中，如创建 NumPy 派生所示。

然后，转到您的派生存储库的 github 页面，例如 `https://github.com/your-user-name/numpy`

单击“管理”按钮，并将其他人添加为存储库的合作者：

> ![../_images/pull_button.png](img/d9f57a07c985576ccac113b960131340.png)

现在，所有这些人都可以执行以下操作：

```py
git clone git@github.com:your-user-name/numpy.git 
```

请记住，以`git@`开头的链接使用 ssh 协议并具有读写权限；以`git://`开头的链接是只读的。

您的合作者随后可以直接提交到该存储库，使用如下方式：

```py
git commit -am 'ENH - much better code'
git push origin my-feature-branch # pushes directly into your repo 
```

### 检出现有拉取请求的更改

如果您想要在拉取请求中测试更改或继续新的拉取请求中的工作，则提交将克隆到您的派生存储库中的本地分支

首先确保您的上游指向主存储库，例如从[将您的存储库链接到上游存储库](https://scikit-image.org/docs/stable/gitwash/set_up_fork.html#linking-to-upstream)（在 skimage v0.21.0 中）

然后，获取更改并创建一个本地分支。假设`$ID`是拉取请求编号，`$BRANCHNAME`是您希望创建的*新的本地*分支的名称：

```py
git fetch upstream pull/$ID/head:$BRANCHNAME 
```

检出新创建的分支：

```py
git checkout $BRANCHNAME 
```

现在您在拉取请求中有了更改。

### 浏览您的存储库

要查看存储库分支和提交的图形表示：

```py
gitk --all 
```

要查看此分支的提交的线性列表：

```py
git log 
```

您还可以查看您的[github](https://github.com/numpy/numpy)存储库的[网络图形可视化器](https://github.blog/2008-04-10-say-hello-to-the-network-graph-visualizer/)。

### 回溯

回溯是将提交的新功能/修复从 [numpy/main](https://github.com/numpy/numpy) 复制回到稳定发布分支的过程。要做到这一点，您需要从要回溯的分支创建一个分支，从`numpy/main`中选择您想要的提交，然后提交包含回溯内容的分支的拉取请求。

1.  首先，您需要创建一个分支，该分支需要基于旧版本的 NumPy（而不是主分支）：

    ```py
    # Make a new branch based on numpy/maintenance/1.8.x,
    # backport-3324 is our new name for the branch.
    git checkout -b backport-3324 upstream/maintenance/1.8.x 
    ```

1.  现在，您需要使用[git cherry-pick](https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html)将主分支的更改应用到此分支中：

    ```py
    # Update remote
    git fetch upstream
    # Check the commit log for commits to cherry pick
    git log upstream/main
    # This pull request included commits aa7a047 to c098283 (inclusive)
    # so you use the .. syntax (for a range of commits), the ^ makes the
    # range inclusive.
    git cherry-pick aa7a047^..c098283
    ...
    # Fix any conflicts, then if needed:
    git cherry-pick --continue 
    ```

1.  在这里你可能会遇到一些冲突，解决冲突的方法与合并/变基冲突相同。只需使用[git blame](https://www.kernel.org/pub/software/scm/git/docs/git-blame.html)可以查看主分支和后移分支之间的差异，以确保不会出错。

1.  将新分支推送到你的 Github 仓库：

    ```py
    git push -u origin backport-3324 
    ```

1.  最后，使用 Github 创建一个拉取请求。确保它针对的是 maintenance 分支而不是 main 分支，Github 通常会建议你针对 main 创建拉取请求。

### 将更改推送到主要仓库

*需要对主要的 NumPy 仓库具有提交权限。*

当你在一个功能分支上有一组"准备好"的更改，准备推送到 NumPy 的`main`或`maintenance`分支时，可以按如下方式将它们推送到`upstream`：

1.  首先，在���标分支上进行合并或变基。

    1.  只有少数不相关的提交，然后优先使用变基：

        ```py
        git fetch upstream
        git rebase upstream/main 
        ```

        参见在主分支上进行变基。

    1.  如果所有提交都相关，请创建一个合并提交：

        ```py
        git fetch upstream
        git merge --no-ff upstream/main 
        ```

1.  检查你将要推送的内容是否合理：

    ```py
    git log -p upstream/main..
    git log --oneline --graph 
    ```

1.  推送到上游：

    ```py
    git push upstream my-feature-branch:main 
    ```

注意

使用`-n`标志进行`git push`通常是一个好主意，以先检查你要推送的更改是否正确，并将其推送到正确的位置。### 修改提交历史

注意

仅对你自己的功能分支执行此操作。

你在一个提交中有一个令人尴尬的拼写错误吗？或者你已经开始了几次你不想让后世看到的错误。

这可以通过*交互式变基*来完成。

假设提交历史看起来是这样的：

```py
git log --oneline
eadc391 Fix some remaining bugs
a815645 Modify it so that it works
2dec1ac Fix a few bugs + disable
13d7934 First implementation
6ad92e5 * masked is now an instance of a new object, MaskedConstant
29001ed Add pre-nep for a couple of structured_array_extensions.
... 
```

`6ad92e5`是`main`分支上的最后一个提交。假设我们要进行以下更改：

+   重写`13d7934`的提交消息为一些更明智的东西。

+   将提交`2dec1ac`，`a815645`，`eadc391`合并为一个提交。

我们按如下方式操作：

```py
# make a backup of the current state
git branch tmp HEAD
# interactive rebase
git rebase -i 6ad92e5 
```

这将打开一个编辑器，其中包含以下文本：

```py
pick 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
pick a815645 Modify it so that it works
pick eadc391 Fix some remaining bugs

# Rebase 6ad92e5..eadc391 onto 6ad92e5
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
# 
```

为了实现我们的目标，我们将对其进行以下更改：

```py
r 13d7934 First implementation
pick 2dec1ac Fix a few bugs + disable
f a815645 Modify it so that it works
f eadc391 Fix some remaining bugs 
```

这意味着我们要编辑`13d7934`的提交信息，并将最后三个提交合并为一个。现在我们保存并退出编辑器。

Git 立即打开一个编辑器来编辑提交消息。修改后，我们会得到输出：

```py
[detached HEAD 721fc64] FOO: First implementation
 2 files changed, 199 insertions(+), 66 deletions(-)
[detached HEAD 0f22701] Fix a few bugs + disable
 1 files changed, 79 insertions(+), 61 deletions(-)
Successfully rebased and updated refs/heads/my-feature-branch. 
```

然后历史看起来是这样的：

```py
0f22701 Fix a few bugs + disable
721fc64 ENH: Sophisticated feature
6ad92e5 * masked is now an instance of a new object, MaskedConstant 
```

如果出错了，可以按照上面的说明进行恢复。

### 删除在[github](https://github.com/numpy/numpy)上的一个分支

```py
git checkout main
# delete branch locally
git branch -D my-unwanted-branch
# delete branch on github
git push origin --delete my-unwanted-branch 
```

参见：[`stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely`](https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely)

### 几个人共享一个仓库

如果你想与他人一起工作，共享同一个仓库，甚至是同一个分支，只需通过[github](https://github.com/numpy/numpy)共享即可。

首先将 NumPy fork 到你的账户中，参见创建一个 NumPy fork。

然后，打开你 fork 的仓库的 github 页面，比如`https://github.com/your-user-name/numpy`

点击“管理”按钮，并将其他任何人添加为存储库的协作者：

> ![../_images/pull_button.png](img/d9f57a07c985576ccac113b960131340.png)

现在所有这些人都可以做：

```py
git clone git@github.com:your-user-name/numpy.git 
```

记住，以`git@`开头的链接使用 ssh 协议并且是可读写的；以`git://`开头的链接是只读的。

你的协作者随后可以直接向该存储库提交常规提交：

```py
git commit -am 'ENH - much better code'
git push origin my-feature-branch # pushes directly into your repo 
```

### 检出现有拉取请求中的更改

如果你想要测试拉取请求中的更改或者继续新拉取请求中的工作，那么提交将被克隆到你的 forked 存储库的本地分支中。

首先确保你的上游指向主存储库，就像[将你的存储库链接到上游存储库](https://scikit-image.org/docs/stable/gitwash/set_up_fork.html#linking-to-upstream "(in skimage v0.21.0)")一样

然后，获取更改并创建一个本地分支。假设`$ID`是拉取请求编号，`$BRANCHNAME`是你想创建的*新的本地*分支的名称：

```py
git fetch upstream pull/$ID/head:$BRANCHNAME 
```

检出新创建的分支：

```py
git checkout $BRANCHNAME 
```

现在你已经有了拉取请求中的更改。

### 浏览你的存储库

要查看存储库分支和提交的图形表示：

```py
gitk --all 
```

要查看此分支的提交的线性列表：

```py
git log 
```

你也可以查看你的[github](https://github.com/numpy/numpy)存储库的[网络图可视化器](https://github.blog/2008-04-10-say-hello-to-the-network-graph-visualizer/)。

### 回溯

回溯是将在[numpy/main](https://github.com/numpy/numpy)提交的新功能/修复复制回稳定发布分支的过程。为此，你可以从你要回溯的分支上创建一个分支，从`numpy/main`中挑选你想要的提交，然后为包含回溯的分支提交一个拉取请求。

1.  首先，你需要创建你将在其上工作的分支。这需要基于 NumPy 的旧版本（不是主分支）：

    ```py
    # Make a new branch based on numpy/maintenance/1.8.x,
    # backport-3324 is our new name for the branch.
    git checkout -b backport-3324 upstream/maintenance/1.8.x 
    ```

1.  现在你需要使用[git cherry-pick](https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html)将主分支的更改应用到此分支：

    ```py
    # Update remote
    git fetch upstream
    # Check the commit log for commits to cherry pick
    git log upstream/main
    # This pull request included commits aa7a047 to c098283 (inclusive)
    # so you use the .. syntax (for a range of commits), the ^ makes the
    # range inclusive.
    git cherry-pick aa7a047^..c098283
    ...
    # Fix any conflicts, then if needed:
    git cherry-pick --continue 
    ```

1.  你可能会遇到一些冲突在这里挑樱桃。这些冲突的解决方式与合并/重新基础冲突相同。除此之外，你可以使用[git blame](https://www.kernel.org/pub/software/scm/git/docs/git-blame.html)来查看主分支和回溯分支之间的差异，以确保没有任何问题。

1.  将新分支推送到你的 Github 存储库：

    ```py
    git push -u origin backport-3324 
    ```

1.  最后使用 Github 创建一个拉取请求。确保它是针对维护分支而不是主分支的，Github 通常会建议你针对主分支创建拉取请求。

### 将更改推送到主存储库

*需要对主 NumPy 存储库具有提交权限。*

当你在一个特性分支上有一组“准备就绪”的更改准备好提交给 NumPy 的`main`或`maintenance`分支时，你可以按如下方式将它们推送到`upstream`：

1.  首先，在目标分支上合并或重新基于。

    1.  只有少数不相关的提交，那么更喜欢重新基于：

        ```py
        git fetch upstream
        git rebase upstream/main 
        ```

        见在主分支上重新基于。

    1.  如果所有的提交都是相关的，请创建一个合并提交：

        ```py
        git fetch upstream
        git merge --no-ff upstream/main 
        ```

1.  确认一下你将要推送的内容是否合理：

    ```py
    git log -p upstream/main..
    git log --oneline --graph 
    ```

1.  推送到上游：

    ```py
    git push upstream my-feature-branch:main 
    ```

注意：

使用`-n`标志对`git push`使用是一个好习惯，首先可以检查一下你要推送的改动是否是你想要的，并且推送到了正确的位置。
