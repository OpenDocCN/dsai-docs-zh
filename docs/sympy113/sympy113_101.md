# 数值评估

> 原文：[https://docs.sympy.org/latest/modules/evalf.html](https://docs.sympy.org/latest/modules/evalf.html)

## 基础

精确的 SymPy 表达式可以使用 `.evalf()` 方法或 `N()` 函数转换为浮点数近似值（小数）。`N(expr, <args>)` 等效于 `sympify(expr).evalf(<args>)`。

```py
>>> from sympy import *
>>> N(sqrt(2)*pi)
4.44288293815837
>>> (sqrt(2)*pi).evalf()
4.44288293815837 
```

默认情况下，数值评估的精度为 15 位小数。您可以选择将所需的精度（应为正整数）作为参数传递给 `evalf` 或 `N`：

```py
>>> N(sqrt(2)*pi, 5)
4.4429
>>> N(sqrt(2)*pi, 50)
4.4428829381583662470158809900606936986146216893757 
```

支持复数：

```py
>>> N(1/(pi + I), 20)
0.28902548222223624241 - 0.091999668350375232456*I 
```

如果表达式包含符号或由于其他原因无法进行数值评估，则调用 `.evalf()` 或 `N()` 将返回原始表达式，或者在某些情况下返回部分评估的表达式。例如，当表达式是展开形式的多项式时，将评估系数：

```py
>>> x = Symbol('x')
>>> (pi*x**2 + x/3).evalf()
3.14159265358979*x**2 + 0.333333333333333*x 
```

您还可以使用标准 Python 函数 `float()`、`complex()` 将 SymPy 表达式转换为常规 Python 数字：

```py
>>> float(pi)  
3.141592653589793
>>> complex(pi+E*I)  
(3.141592653589793+2.718281828459045j) 
```

如果使用这些函数，未能将表达式评估为显式数字（例如，如果表达式包含符号），则会引发异常。

本质上不存在上限精度限制。例如，以下命令计算了π/e的前 100,000 位小数：

```py
>>> N(pi/E, 100000) 
... 
```

这显示了π的第 999,951 至 1,000,000 位小数：

```py
>>> str(N(pi, 10**6))[-50:] 
'95678796130331164628399634646042209010610577945815' 
```

高精度计算可能会很慢。建议（但完全可选）安装 gmpy（[https://github.com/aleaxit/gmpy](https://github.com/aleaxit/gmpy)），这将显著加快上述计算等的速度。

## 浮点数

SymPy 中的浮点数是 `Float` 类的实例。可以将 `Float` 作为第二个参数创建自定义精度：

```py
>>> Float(0.1)
0.100000000000000
>>> Float(0.1, 10)
0.1000000000
>>> Float(0.125, 30)
0.125000000000000000000000000000
>>> Float(0.1, 30)
0.100000000000000005551115123126 
```

正如最后一个示例所示，某些 Python 浮点数仅精确到约 15 位小数输入，而其他（例如分母为 2 的幂的浮点数，如 0.125 = 1/8）则是精确的。要从高精度小数创建 `Float`，最好传递字符串、`Rational` 或 `evalf` `Rational`：

```py
>>> Float('0.1', 30)
0.100000000000000000000000000000
>>> Float(Rational(1, 10), 30)
0.100000000000000000000000000000
>>> Rational(1, 10).evalf(30)
0.100000000000000000000000000000 
```

数的精度决定了1）在与该数进行算术运算时使用的精度，以及2）打印该数时显示的位数。当两个不同精度的数一起进行算术运算时，结果将使用较高的精度。0.1 +/- 0.001 和 3.1415 +/- 0.0001 的乘积的不确定性约为 0.003，但显示了 5 位有效数字。

```py
>>> Float(0.1, 3)*Float(3.1415, 5)
0.31417 
```

因此，显示的精度不应用作错误传播或重要性算术的模型；相反，该方案用于确保数值算法的稳定性。

`N` 和 `evalf` 可用于更改现有浮点数的精度：

```py
>>> N(3.5)
3.50000000000000
>>> N(3.5, 5)
3.5000
>>> N(3.5, 30)
3.50000000000000000000000000000 
```

## 精度和错误处理

当输入到 `N` 或 `evalf` 的是复杂表达式时，数值误差传播成为一个问题。例如，考虑第100个斐波那契数和卓越但不精确的近似 \(\varphi^{100} / \sqrt{5}\)，其中 \(\varphi\) 是黄金比例。使用普通浮点算术，将这些数字相减会错误地导致完全的取消：

```py
>>> a, b = GoldenRatio**1000/sqrt(5), fibonacci(1000)
>>> float(a)
4.34665576869e+208
>>> float(b)
4.34665576869e+208
>>> float(a) - float(b)
0.0 
```

`N` 和 `evalf` 会跟踪错误并自动增加内部使用的精度，以获得正确的结果：

```py
>>> N(fibonacci(100) - GoldenRatio**100/sqrt(5))
-5.64613129282185e-22 
```

不幸的是，数值评估无法区分一个恰好为零的表达式和一个仅仅非常小的表达式。因此，默认情况下工作精度被限制在大约100位数字。如果我们尝试使用第1000个斐波那契数，会发生以下情况：

```py
>>> N(fibonacci(1000) - (GoldenRatio)**1000/sqrt(5))
0.e+85 
```

返回数字的位数不足表明 `N` 未能达到完全的精确度。结果表明表达式的大小为10^84以下，但这并不是一个特别好的答案。要强制使用更高的工作精度，可以使用 `maxn` 关键字参数：

```py
>>> N(fibonacci(1000) - (GoldenRatio)**1000/sqrt(5), maxn=500)
-4.60123853010113e-210 
```

通常情况下，`maxn` 可以设置得非常高（数千位数字），但请注意，这可能在极端情况下导致显著的减速。或者，可以将 `strict=True` 选项设置为强制引发异常，而不是在请求的精度不足时静默返回值：

```py
>>> N(fibonacci(1000) - (GoldenRatio)**1000/sqrt(5), strict=True)
Traceback (most recent call last):
...
PrecisionExhausted: Failed to distinguish the expression:

-sqrt(5)*GoldenRatio**1000/5 + 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875

from zero. Try simplifying the input, using chop=True, or providing a higher maxn for evalf 
```

如果我们添加一个项，使得斐波那契逼近变得精确（Binet 公式的完整形式），我们得到一个恰好为零的表达式，但 `N` 不知道这一点：

```py
>>> f = fibonacci(100) - (GoldenRatio**100 - (GoldenRatio-1)**100)/sqrt(5)
>>> N(f)
0.e-104
>>> N(f, maxn=1000)
0.e-1336 
```

在已知会发生这种取消的情况下，`chop` 选项非常有用。这基本上会将数字的实部或虚部中非常小的数替换为精确的零：

```py
>>> N(f, chop=True)
0
>>> N(3 + I*f, chop=True)
3.00000000000000 
```

在希望去除无意义数字的情况下，重新评估或使用 round 方法非常有用：

```py
>>> Float('.1', '')*Float('.12345', '')
0.012297
>>> ans = _
>>> N(ans, 1)
0.01
>>> ans.round(2)
0.01 
```

如果处理的数值表达式不包含浮点数，可以以任意精度进行评估。要将结果舍入到给定小数的相对值，round 方法非常有用：

```py
>>> v = 10*pi + cos(1)
>>> N(v)
31.9562288417661
>>> v.round(3)
31.956 
```

## 总和与积分

总和（特别是无穷级数）和积分可以像常规闭合形式表达式一样使用，并支持任意精度评估：

```py
>>> var('n x')
(n, x)
>>> Sum(1/n**n, (n, 1, oo)).evalf()
1.29128599706266
>>> Integral(x**(-x), (x, 0, 1)).evalf()
1.29128599706266
>>> Sum(1/n**n, (n, 1, oo)).evalf(50)
1.2912859970626635404072825905956005414986193682745
>>> Integral(x**(-x), (x, 0, 1)).evalf(50)
1.2912859970626635404072825905956005414986193682745
>>> (Integral(exp(-x**2), (x, -oo, oo)) ** 2).evalf(30)
3.14159265358979323846264338328 
```

默认情况下，使用双曲正弦积分算法来评估积分。对于平滑的被积函数（甚至是具有端点奇异性的积分），此算法非常高效和稳健，但可能在高度振荡或中间间断的积分中遇到困难。在许多情况下，`evalf` / `N` 将正确估计误差。对于以下积分，结果是准确的，但只精确到四位数：

```py
>>> f = abs(sin(x))
>>> Integral(abs(sin(x)), (x, 0, 4)).evalf()
2.346 
```

最好将这个积分拆分成两个部分：

```py
>>> (Integral(f, (x, 0, pi)) + Integral(f, (x, pi, 4))).evalf()
2.34635637913639 
```

类似的例子是以下振荡积分：

```py
>>> Integral(sin(x)/x**2, (x, 1, oo)).evalf(maxn=20)
0.5 
```

可以通过告知 `evalf` 或 `N` 使用振荡积分算法来更有效地处理它：

```py
>>> Integral(sin(x)/x**2, (x, 1, oo)).evalf(quad='osc')
0.504067061906928
>>> Integral(sin(x)/x**2, (x, 1, oo)).evalf(20, quad='osc')
0.50406706190692837199 
```

振荡积分需要包含形如 cos(ax+b) 或 sin(ax+b) 因子的被积函数。请注意，许多其他振荡积分可以通过变量变换转换为此形式：

```py
>>> init_printing(use_unicode=False)
>>> intgrl = Integral(sin(1/x), (x, 0, 1)).transform(x, 1/x)
>>> intgrl
 oo
 /
 |
 |  sin(x)
 |  ------ dx
 |     2
 |    x
 |
/
1
>>> N(intgrl, quad='osc')
0.504067061906928 
```

如果无穷级数收敛速度足够快，直接求和。否则，使用外推方法（通常是欧拉-麦克劳林公式但也包括理查森外推）加速收敛。这允许对缓慢收敛级数进行高精度评估：

```py
>>> var('k')
k
>>> Sum(1/k**2, (k, 1, oo)).evalf()
1.64493406684823
>>> zeta(2).evalf()
1.64493406684823
>>> Sum(1/k-log(1+1/k), (k, 1, oo)).evalf()
0.577215664901533
>>> Sum(1/k-log(1+1/k), (k, 1, oo)).evalf(50)
0.57721566490153286060651209008240243104215933593992
>>> EulerGamma.evalf(50)
0.57721566490153286060651209008240243104215933593992 
```

欧拉-麦克劳林公式还用于有限级数，允许快速近似而不需评估所有项：

```py
>>> Sum(1/k, (k, 10000000, 20000000)).evalf()
0.693147255559946 
```

请注意，`evalf` 做出了不总是最优的一些假设。为了对数值求和进行精细调整，手动使用 `Sum.euler_maclaurin` 方法可能是值得的。

为了有理超几何级数（其中项是多项式、幂、阶乘、二项式系数等的乘积）采用了特殊优化。`N`/`evalf` 类型的级数可以非常快速地高精度求和。例如，这个拉马努金公式可以用简单的命令在几分之一秒内求和到 10,000 位数：

```py
>>> f = factorial
>>> n = Symbol('n', integer=True)
>>> R = 9801/sqrt(8)/Sum(f(4*n)*(1103+26390*n)/f(n)**4/396**(4*n),
...                         (n, 0, oo))
>>> N(R, 10000) 
3.141592653589793238462643383279502884197169399375105820974944592307816406286208
99862803482534211706798214808651328230664709384460955058223172535940812848111745
02841027019385211055596446229489549303819644288109756659334461284756482337867831
... 
```

## 数值简化

函数 `nsimplify` 尝试找到一个数值上等于给定输入的公式。此功能可用于猜测精确浮点输入的确切公式，或者猜测复杂符号输入的简化公式。`nsimplify` 使用的算法能够识别简单分数、简单代数表达式、给定常数的线性组合以及任何前述内容的某些基本函数变换。

可选地，`nsimplify` 可以传入常数列表（例如 pi）和最小数值容差。以下是一些基本示例：

```py
>>> nsimplify(0.1)
1/10
>>> nsimplify(6.28, [pi], tolerance=0.01)
2*pi
>>> nsimplify(pi, tolerance=0.01)
22/7
>>> nsimplify(pi, tolerance=0.001)
355
---
113
>>> nsimplify(0.33333, tolerance=1e-4)
1/3
>>> nsimplify(2.0**(1/3.), tolerance=0.001)
635
---
504
>>> nsimplify(2.0**(1/3.), tolerance=0.001, full=True)
3 ___
\/ 2 
```

这里是几个更高级的示例：

```py
>>> nsimplify(Float('0.130198866629986772369127970337',30), [pi, E])
 1
----------
5*pi
---- + 2*e
 7
>>> nsimplify(cos(atan('1/3')))
 ____
3*\/ 10
--------
 10
>>> nsimplify(4/(1+sqrt(5)), [GoldenRatio])
-2 + 2*GoldenRatio
>>> nsimplify(2 + exp(2*atan('1/4')*I))
49   8*I
-- + ---
17    17
>>> nsimplify((1/(exp(3*pi*I/5)+1)))
 ___________
 /   ___
1        /  \/ 5    1
- - I*  /   ----- + -
2     \/      10    4
>>> nsimplify(I**I, [pi])
 -pi
 ----
 2
e
>>> n = Symbol('n')
>>> nsimplify(Sum(1/n**2, (n, 1, oo)), [pi])
 2
pi
---
 6
>>> nsimplify(gamma('1/4')*gamma('3/4'), [pi])
 ___
\/ 2 *pi 
```
