- en: numpy.linalg.svd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.linalg.svd.html](https://numpy.org/doc/1.26/reference/generated/numpy.linalg.svd.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Singular Value Decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: When *a* is a 2D array, and `full_matrices=False`, then it is factorized as
    `u @ np.diag(s) @ vh = (u * s) @ vh`, where *u* and the Hermitian transpose of
    *vh* are 2D arrays with orthonormal columns and *s* is a 1D array of *a*’s singular
    values. When *a* is higher-dimensional, SVD is applied in stacked mode as explained
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(…, M, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: A real or complex array with `a.ndim >= 2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_matrices**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True (default), *u* and *vh* have the shapes `(..., M, M)` and `(..., N,
    N)`, respectively. Otherwise, the shapes are `(..., M, K)` and `(..., K, N)`,
    respectively, where `K = min(M, N)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**compute_uv**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not to compute *u* and *vh* in addition to *s*. True by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**hermitian**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, *a* is assumed to be Hermitian (symmetric if real-valued), enabling
    a more efficient method for finding singular values. Defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.17.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: When *compute_uv* is True, the result is a namedtuple with the following
  prefs: []
  type: TYPE_NORMAL
- en: 'attribute names:'
  prefs: []
  type: TYPE_NORMAL
- en: '**U**{ (…, M, M), (…, M, K) } array'
  prefs: []
  type: TYPE_NORMAL
- en: Unitary array(s). The first `a.ndim - 2` dimensions have the same size as those
    of the input *a*. The size of the last two dimensions depends on the value of
    *full_matrices*. Only returned when *compute_uv* is True.
  prefs: []
  type: TYPE_NORMAL
- en: '**S**(…, K) array'
  prefs: []
  type: TYPE_NORMAL
- en: Vector(s) with the singular values, within each vector sorted in descending
    order. The first `a.ndim - 2` dimensions have the same size as those of the input
    *a*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Vh**{ (…, N, N), (…, K, N) } array'
  prefs: []
  type: TYPE_NORMAL
- en: Unitary array(s). The first `a.ndim - 2` dimensions have the same size as those
    of the input *a*. The size of the last two dimensions depends on the value of
    *full_matrices*. Only returned when *compute_uv* is True.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: If SVD computation does not converge.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.svd`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Similar function in SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.svdvals`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.svdvals.html#scipy.linalg.svdvals
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Compute singular values of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.8.0: Broadcasting rules apply, see the [`numpy.linalg`](../routines.linalg.html#module-numpy.linalg
    "numpy.linalg") documentation for details.'
  prefs: []
  type: TYPE_NORMAL
- en: The decomposition is performed using LAPACK routine `_gesdd`.
  prefs: []
  type: TYPE_NORMAL
- en: SVD is usually described for the factorization of a 2D matrix \(A\). The higher-dimensional
    case will be discussed below. In the 2D case, SVD is written as \(A = U S V^H\),
    where \(A = a\), \(U= u\), \(S= \mathtt{np.diag}(s)\) and \(V^H = vh\). The 1D
    array *s* contains the singular values of *a* and *u* and *vh* are unitary. The
    rows of *vh* are the eigenvectors of \(A^H A\) and the columns of *u* are the
    eigenvectors of \(A A^H\). In both cases the corresponding (possibly non-zero)
    eigenvalues are given by `s**2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *a* has more than two dimensions, then broadcasting rules apply, as explained
    in [Linear algebra on several matrices at once](../routines.linalg.html#routines-linalg-broadcasting).
    This means that SVD is working in “stacked” mode: it iterates over all indices
    of the first `a.ndim - 2` dimensions and for each combination SVD is applied to
    the last two indices. The matrix *a* can be reconstructed from the decomposition
    with either `(u * s[..., None, :]) @ vh` or `u @ (s[..., None] * vh)`. (The `@`
    operator can be replaced by the function `np.matmul` for python versions below
    3.5.)'
  prefs: []
  type: TYPE_NORMAL
- en: If *a* is a `matrix` object (as opposed to an `ndarray`), then so are all the
    return values.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Reconstruction based on full SVD, 2D case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Reconstruction based on reduced SVD, 2D case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Reconstruction based on full SVD, 4D case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Reconstruction based on reduced SVD, 4D case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
