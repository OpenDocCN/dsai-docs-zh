["```py\n>>> from sympy.tensor.array.expressions import ArraySymbol\n>>> from sympy.abc import i, j, k\n>>> A = ArraySymbol(\"A\", (3, 2, 4))\n>>> A.shape\n(3, 2, 4)\n>>> A[i, j, k]\nA[i, j, k]\n>>> A.as_explicit()\n[[[A[0, 0, 0], A[0, 0, 1], A[0, 0, 2], A[0, 0, 3]],\n [A[0, 1, 0], A[0, 1, 1], A[0, 1, 2], A[0, 1, 3]]],\n [[A[1, 0, 0], A[1, 0, 1], A[1, 0, 2], A[1, 0, 3]],\n [A[1, 1, 0], A[1, 1, 1], A[1, 1, 2], A[1, 1, 3]]],\n [[A[2, 0, 0], A[2, 0, 1], A[2, 0, 2], A[2, 0, 3]],\n [A[2, 1, 0], A[2, 1, 1], A[2, 1, 2], A[2, 1, 3]]]] \n```", "```py\n>>> from sympy import Array\n>>> from sympy import tensorproduct\n>>> from sympy.tensor.array.expressions import ArrayTensorProduct\n>>> a = Array([1, 2, 3])\n>>> b = Array([i, j, k])\n>>> expr = ArrayTensorProduct(a, b, b)\n>>> expr\nArrayTensorProduct([1, 2, 3], [i, j, k], [i, j, k])\n>>> expr.as_explicit() == tensorproduct(a, b, b)\nTrue \n```", "```py\n>>> from sympy.tensor.array.expressions import convert_indexed_to_array\n>>> from sympy import Sum\n>>> A = ArraySymbol(\"A\", (3, 3))\n>>> B = ArraySymbol(\"B\", (3, 3))\n>>> convert_indexed_to_array(A[i, j], [i, j])\nA\n>>> convert_indexed_to_array(A[i, j], [j, i])\nPermuteDims(A, (0 1))\n>>> convert_indexed_to_array(A[i, j] + B[j, i], [i, j])\nArrayAdd(A, PermuteDims(B, (0 1)))\n>>> convert_indexed_to_array(Sum(A[i, j]*B[j, k], (j, 0, 2)), [i, k])\nArrayContraction(ArrayTensorProduct(A, B), (1, 2)) \n```", "```py\n>>> convert_indexed_to_array(A[i, i], [i])\nArrayDiagonal(A, (0, 1)) \n```", "```py\n>>> convert_indexed_to_array(Sum(A[i, i], (i, 0, 2)), [i])\nArrayContraction(A, (0, 1)) \n```", "```py\n>>> from sympy import MatrixSymbol\n>>> from sympy.tensor.array.expressions import ArrayContraction\n>>> M = MatrixSymbol(\"M\", 3, 3)\n>>> N = MatrixSymbol(\"N\", 3, 3) \n```", "```py\n>>> from sympy.tensor.array.expressions import convert_matrix_to_array\n>>> expr = convert_matrix_to_array(M*N)\n>>> expr\nArrayContraction(ArrayTensorProduct(M, N), (1, 2)) \n```", "```py\n>>> from sympy.tensor.array.expressions import convert_array_to_matrix\n>>> convert_array_to_matrix(expr)\nM*N \n```", "```py\n>>> expr_tr = ArrayContraction(expr, (0, 1))\n>>> expr_tr\nArrayContraction(ArrayContraction(ArrayTensorProduct(M, N), (1, 2)), (0, 1)) \n```", "```py\n>>> expr_tr.doit()\nArrayContraction(ArrayTensorProduct(M, N), (0, 3), (1, 2)) \n```", "```py\n>>> expr.as_explicit()\n[[M[0, 0]*N[0, 0] + M[0, 1]*N[1, 0] + M[0, 2]*N[2, 0], M[0, 0]*N[0, 1] + M[0, 1]*N[1, 1] + M[0, 2]*N[2, 1], M[0, 0]*N[0, 2] + M[0, 1]*N[1, 2] + M[0, 2]*N[2, 2]],\n [M[1, 0]*N[0, 0] + M[1, 1]*N[1, 0] + M[1, 2]*N[2, 0], M[1, 0]*N[0, 1] + M[1, 1]*N[1, 1] + M[1, 2]*N[2, 1], M[1, 0]*N[0, 2] + M[1, 1]*N[1, 2] + M[1, 2]*N[2, 2]],\n [M[2, 0]*N[0, 0] + M[2, 1]*N[1, 0] + M[2, 2]*N[2, 0], M[2, 0]*N[0, 1] + M[2, 1]*N[1, 1] + M[2, 2]*N[2, 1], M[2, 0]*N[0, 2] + M[2, 1]*N[1, 2] + M[2, 2]*N[2, 2]]] \n```", "```py\n>>> from sympy import Trace\n>>> convert_matrix_to_array(Trace(M))\nArrayContraction(M, (0, 1))\n>>> convert_matrix_to_array(Trace(M*N))\nArrayContraction(ArrayTensorProduct(M, N), (0, 3), (1, 2)) \n```", "```py\n>>> convert_matrix_to_array(M.T)\nPermuteDims(M, (0 1)) \n```", "```py\n>>> from sympy.tensor.array.expressions import array_derive\n>>> d = array_derive(M, M)\n>>> d\nPermuteDims(ArrayTensorProduct(I, I), (3)(1 2)) \n```", "```py\n>>> d.as_explicit()\n[[[[1, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 1, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 1], [0, 0, 0], [0, 0, 0]]], [[[0, 0, 0], [1, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]]], [[[0, 0, 0], [0, 0, 0], [1, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 1, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 1]]]]\n>>> Me = M.as_explicit()\n>>> Me.diff(Me)\n[[[[1, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 1, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 1], [0, 0, 0], [0, 0, 0]]], [[[0, 0, 0], [1, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 1, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 1], [0, 0, 0]]], [[[0, 0, 0], [0, 0, 0], [1, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 1, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 1]]]] \n```", "```py\nclass sympy.tensor.array.expressions.ArrayTensorProduct(*args, **kwargs)\n```", "```py\nclass sympy.tensor.array.expressions.ArrayContraction(expr, *contraction_indices, **kwargs)\n```", "```py\nclass sympy.tensor.array.expressions.ArrayDiagonal(expr, *diagonal_indices, **kwargs)\n```", "```py\nclass sympy.tensor.array.expressions.PermuteDims(expr, permutation=None, index_order_old=None, index_order_new=None, **kwargs)\n```", "```py\n>>> from sympy.tensor.array import permutedims\n>>> from sympy import MatrixSymbol\n>>> M = MatrixSymbol(\"M\", 3, 3)\n>>> cg = permutedims(M, [1, 0]) \n```", "```py\n>>> from sympy.tensor.array.expressions.from_array_to_matrix import convert_array_to_matrix\n>>> convert_array_to_matrix(cg)\nM.T \n```", "```py\n>>> N = MatrixSymbol(\"N\", 3, 2)\n>>> cg = permutedims(N, [1, 0])\n>>> cg.shape\n(2, 3) \n```", "```py\n>>> from sympy.tensor.array.expressions import ArraySymbol, PermuteDims\n>>> M = ArraySymbol(\"M\", (1, 2, 3, 4, 5))\n>>> expr = PermuteDims(M, index_order_old=\"ijklm\", index_order_new=\"kijml\")\n>>> expr\nPermuteDims(M, (0 2 1)(3 4))\n>>> expr.shape\n(3, 1, 2, 5, 4) \n```", "```py\n>>> from sympy.tensor.array import tensorproduct\n>>> M = MatrixSymbol(\"M\", 4, 5)\n>>> tp = tensorproduct(M, N)\n>>> tp.shape\n(4, 5, 3, 2)\n>>> perm1 = permutedims(tp, [2, 3, 1, 0]) \n```", "```py\n>>> perm1.expr.args\n(N, M)\n>>> perm1.shape\n(3, 2, 5, 4)\n>>> perm1.permutation\n(2 3) \n```", "```py\n>>> perm1.permutation.array_form\n[0, 1, 3, 2] \n```", "```py\n>>> perm2 = permutedims(perm1, [1, 0, 2, 3])\n>>> perm2.shape\n(2, 3, 5, 4)\n>>> perm2.permutation.array_form\n[1, 0, 3, 2] \n```"]