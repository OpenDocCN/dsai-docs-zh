["```py\nexpression\n   |\ncode printers\n   |\ncode generators\n   |\nautowrap \n```", "```py\n>>> from sympy import *\n>>> init_printing(use_unicode=True)\n>>> from sympy.abc import a, e, k, n, r, t, x, y, z, T, Z\n>>> from sympy.abc import beta, omega, tau\n>>> f, g = symbols('f, g', cls=Function) \n```", "```py\n>>> from sympy.codegen.ast import Assignment\n>>> print(ccode(Assignment(x, y + 1)))\nx = y + 1; \n```", "```py\n>>> expr = (Rational(-1, 2) * Z * k * (e**2) / r)\n>>> expr\n 2\n-Z⋅e ⋅k\n────────\n 2⋅r\n>>> ccode(expr)\n-1.0/2.0*Z*pow(e, 2)*k/r\n>>> from sympy.codegen.ast import real, float80\n>>> ccode(expr, assign_to=\"E\", type_aliases={real: float80})\nE = -1.0L/2.0L*Z*powl(e, 2)*k/r; \n```", "```py\n>>> from sympy.codegen.cfunctions import expm1\n>>> ccode(expm1(x), standard='C99')\nexpm1(x) \n```", "```py\n>>> expr = Piecewise((x + 1, x > 0), (x, True))\n>>> print(fcode(expr, tau))\n if (x > 0) then\n tau = x + 1\n else\n tau = x\n end if \n```", "```py\n>>> len_y = 5\n>>> mat_1 = IndexedBase('mat_1', shape=(len_y,))\n>>> mat_2 = IndexedBase('mat_2', shape=(len_y,))\n>>> Dy = IndexedBase('Dy', shape=(len_y-1,))\n>>> i = Idx('i', len_y-1)\n>>> eq = Eq(Dy[i], (mat_1[i+1] - mat_1[i]) / (mat_2[i+1] - mat_2[i]))\n>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))\nDy[i] = (mat_1[i + 1] - mat_1[i])/(mat_2[i + 1] - mat_2[i]);\n>>> Res = IndexedBase('Res', shape=(len_y,))\n>>> j = Idx('j', len_y)\n>>> eq = Eq(Res[j], mat_1[j]*mat_2[j])\n>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=True))\nfor (var j=0; j<5; j++){\n Res[j] = 0;\n}\nfor (var j=0; j<5; j++){\n for (var j=0; j<5; j++){\n Res[j] = Res[j] + mat_1[j]*mat_2[j];\n }\n}\n>>> print(jscode(eq.rhs, assign_to=eq.lhs, contract=False))\nRes[j] = mat_1[j]*mat_2[j]; \n```", "```py\n>>> custom_functions = {\n...   \"f\": \"existing_octave_fcn\",\n...   \"g\": [(lambda x: x.is_Matrix, \"my_mat_fcn\"),\n...         (lambda x: not x.is_Matrix, \"my_fcn\")]\n... }\n>>> mat = Matrix([[1, x]])\n>>> octave_code(f(x) + g(x) + g(mat), user_functions=custom_functions)\nexisting_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x]) \n```", "```py\n>>> x_ = Function('x')\n>>> expr = x_(n*T) * sin((t - n*T) / T)\n>>> expr = expr / ((-T*n + t) / T)\n>>> expr\n ⎛-T⋅n + t⎞\nT⋅x(T⋅n)⋅sin⎜────────⎟\n ⎝   T    ⎠\n──────────────────────\n -T⋅n + t\n\n>>> expr = summation(expr, (n, -1, 1))\n>>> mathematica_code(expr)\nT*(x[-T]*Sin[(T + t)/T]/(T + t) + x[T]*Sin[(-T + t)/T]/(-T + t) + x[0]*Sin[t/T]/t) \n```", "```py\n>>> k, g1, g2, r, I, S = symbols(\"k, gamma_1, gamma_2, r, I, S\")\n>>> expr = k * g1 * g2 / (r**3)\n>>> expr = expr * 2 * I * S * (3 * (cos(beta))**2 - 1) / 2\n>>> expr\n ⎛     2       ⎞\nI⋅S⋅γ₁⋅γ₂⋅k⋅⎝3⋅cos (β) - 1⎠\n───────────────────────────\n 3\n r\n>>> print(jscode(expr, assign_to=\"H_is\"))\nH_is = I*S*gamma_1*gamma_2*k*(3*Math.pow(Math.cos(beta), 2) - 1)/Math.pow(r, 3);\n>>> print(ccode(expr, assign_to=\"H_is\", standard='C89'))\nH_is = I*S*gamma_1*gamma_2*k*(3*pow(cos(beta), 2) - 1)/pow(r, 3);\n>>> print(fcode(expr, assign_to=\"H_is\"))\n H_is = I*S*gamma_1*gamma_2*k*(3*cos(beta)**2 - 1)/r**3\n>>> print(julia_code(expr, assign_to=\"H_is\"))\nH_is = I .* S .* gamma_1 .* gamma_2 .* k .* (3 * cos(beta) .^ 2 - 1) ./ r .^ 3\n>>> print(octave_code(expr, assign_to=\"H_is\"))\nH_is = I.*S.*gamma_1.*gamma_2.*k.*(3*cos(beta).^2 - 1)./r.^3;\n>>> print(rust_code(expr, assign_to=\"H_is\"))\nH_is = I*S*gamma_1*gamma_2*k*(3*beta.cos().powi(2) - 1)/r.powi(3);\n>>> print(mathematica_code(expr))\nI*S*gamma_1*gamma_2*k*(3*Cos[beta]^2 - 1)/r^3 \n```", "```py\n>>> from sympy.utilities.codegen import codegen\n>>> length, breadth, height = symbols('length, breadth, height')\n>>> [(c_name, c_code), (h_name, c_header)] = \\\n... codegen(('volume', length*breadth*height), \"C99\", \"test\",\n...         header=False, empty=False)\n>>> print(c_name)\ntest.c\n>>> print(c_code)\n#include \"test.h\"\n#include <math.h>\ndouble volume(double breadth, double height, double length) {\n double volume_result;\n volume_result = breadth*height*length;\n return volume_result;\n}\n>>> print(h_name)\ntest.h\n>>> print(c_header)\n#ifndef PROJECT__TEST__H\n#define PROJECT__TEST__H\ndouble volume(double breadth, double height, double length);\n#endif \n```", "```py\n>>> [(f_name, f_code), header] = codegen((\"volume\", length*breadth*height),\n...     \"F95\", header=False, empty=False, argument_sequence=(breadth, length),\n...     global_vars=(height,))\n>>> print(f_code)\nREAL*8 function volume(breadth, length)\nimplicit none\nREAL*8, intent(in) :: breadth\nREAL*8, intent(in) :: length\nvolume = breadth*height*length\nend function \n```", "```py\n>>> from sympy.utilities.codegen import make_routine\n>>> from sympy.physics.hydrogen import R_nl\n>>> expr = R_nl(3, y, x, 6)\n>>> routine = make_routine('my_routine', expr)\n>>> [arg.result_var for arg in routine.results]   \n[result₅₁₄₂₃₄₁₆₈₁₃₉₇₇₁₉₄₂₈]\n>>> [arg.expr for arg in routine.results]\n⎡                __________                                          ⎤\n⎢          y    ╱ (2 - y)!   -2⋅x                                    ⎥\n⎢4⋅√6⋅(4⋅x) ⋅  ╱  ──────── ⋅ℯ    ⋅assoc_laguerre(2 - y, 2⋅y + 1, 4⋅x)⎥\n⎢            ╲╱   (y + 3)!                                           ⎥\n⎢────────────────────────────────────────────────────────────────────⎥\n⎣                                 3                                  ⎦\n>>> [arg.name for arg in routine.arguments]\n[x, y] \n```", "```py\n>>> routine = make_routine('fcn', [x*y, Eq(a, 1), Eq(r, x + r), Matrix([[x, 2]])])\n>>> [arg.result_var for arg in routine.results]   \n[result_5397460570204848505]\n>>> [arg.expr for arg in routine.results]\n[x⋅y]\n>>> [arg.name for arg in routine.arguments]   \n[x, y, a, r, out_8598435338387848786] \n```", "```py\n>>> from sympy.utilities.codegen import (InputArgument, OutputArgument,\n...                                      InOutArgument)\n>>> [a.name for a in routine.arguments if isinstance(a, InputArgument)]\n[x, y]\n\n>>> [a.name for a in routine.arguments if isinstance(a, OutputArgument)]  \n[a, out_8598435338387848786]\n>>> [a.expr for a in routine.arguments if isinstance(a, OutputArgument)]\n[1, [x  2]]\n\n>>> [a.name for a in routine.arguments if isinstance(a, InOutArgument)]\n[r]\n>>> [a.expr for a in routine.arguments if isinstance(a, InOutArgument)]\n[r + x] \n```", "```py\n>>> from sympy.utilities.autowrap import autowrap\n>>> expr = ((x - y + z)**(13)).expand()\n>>> binary_func = autowrap(expr)    \n>>> binary_func(1, 4, 2)    \n-1.0 \n```", "```py\n>>> from sympy.utilities.autowrap import autowrap\n>>> from sympy.physics.qho_1d import psi_n\n>>> x_ = IndexedBase('x')\n>>> y_ = IndexedBase('y')\n>>> m = symbols('m', integer=True)\n>>> i = Idx('i', m)\n>>> qho = autowrap(Eq(y_[i], psi_n(0, x_[i], m, omega)), tempdir='/tmp') \n```", "```py\nsubroutine autofunc(m, omega, x, y)\nimplicit none\nINTEGER*4, intent(in) :: m\nREAL*8, intent(in) :: omega\nREAL*8, intent(in), dimension(1:m) :: x\nREAL*8, intent(out), dimension(1:m) :: y\nINTEGER*4 :: i\n\nREAL*8, parameter :: hbar = 1.05457162d-34\nREAL*8, parameter :: pi = 3.14159265358979d0\ndo i = 1, m\n   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &\n         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))\nend do\n\nend subroutine \n```", "```py\n>>> eq = Eq(y_[i], psi_n(0, x_[i], m, omega))\n>>> qho = autowrap(eq, tempdir='/tmp', args=[y, x, m, omega]) \n```", "```py\nsubroutine autofunc(y, x, m, omega)\nimplicit none\nINTEGER*4, intent(in) :: m\nREAL*8, intent(in) :: omega\nREAL*8, intent(out), dimension(1:m) :: y\nREAL*8, intent(in), dimension(1:m) :: x\nINTEGER*4 :: i\n\nREAL*8, parameter :: hbar = 1.05457162d-34\nREAL*8, parameter :: pi = 3.14159265358979d0\ndo i = 1, m\n   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &\n         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))\nend do\n\nend subroutine \n```", "```py\n>>> from sympy.utilities.autowrap import binary_function\n>>> from sympy.physics.hydrogen import R_nl\n>>> psi_nl = R_nl(1, 0, a, r)\n>>> f = binary_function('f', psi_nl)    \n>>> f(a, r).evalf(3, subs={a: 1, r: 2})  \n0.766 \n```", "```py\n>>> x = get_numpy_array(...) \n>>> y = sin(x) / x \n```", "```py\nfor(int  i  =  0;  i  <  n;  i++)\n{\n  temp[i]  =  sin(x[i]);\n}\nfor(int  i  =  i;  i  <  n;  i++)\n{\n  y[i]  =  temp[i]  /  x[i];\n} \n```", "```py\nfor(int  i  =  i;  i  <  n;  i++)\n{\n  y[i]  =  sin(x[i])  /  x[i];\n} \n```", "```py\n>>> from sympy import *\n>>> from sympy.abc import x\n>>> expr = sin(x)/x \n```", "```py\n>>> from sympy.utilities.autowrap import ufuncify\n>>> f = ufuncify([x], expr) \n```", "```py\n>>> from sympy.physics.hydrogen import R_nl\n>>> expr = R_nl(3, 1, x, 6)\n>>> expr\n -2⋅x\n8⋅x⋅(4 - 4⋅x)⋅ℯ\n───────────────────\n 3 \n```", "```py\n>>> from sympy.utilities.autowrap import ufuncify\n>>> from sympy.utilities.lambdify import lambdify\n>>> fn_numpy = lambdify(x, expr, 'numpy')   \n>>> fn_fortran = ufuncify([x], expr, backend='f2py')    \n>>> from numpy import linspace  \n>>> xx = linspace(0, 1, 5)  \n>>> fn_numpy(xx)    \n[ 0\\.          1.21306132  0.98101184  0.44626032  0\\.        ]\n>>> fn_fortran(xx)  \n[ 0\\.          1.21306132  0.98101184  0.44626032  0\\.        ]\n>>> import timeit\n>>> timeit.timeit('fn_numpy(xx)', 'from __main__ import fn_numpy, xx', number=10000)    \n0.18891601900395472\n>>> timeit.timeit('fn_fortran(xx)', 'from __main__ import fn_fortran, xx', number=10000)    \n0.004707066000264604 \n```", "```py\n>>> from sympy import Symbol, exp, log\n>>> from sympy.codegen.rewriting import optimize, optims_c99\n>>> x = Symbol('x')\n>>> optimize(3*exp(2*x) - 3, optims_c99)\n3*expm1(2*x)\n>>> optimize(exp(2*x) - 1 - exp(-33), optims_c99)\nexpm1(2*x) - exp(-33)\n>>> optimize(log(3*x + 3), optims_c99)\nlog1p(x) + log(3)\n>>> optimize(log(2*x + 3), optims_c99)\nlog(2*x + 3) \n```", "```py\nclass sympy.codegen.rewriting.FuncMinusOneOptim(func, func_m_1, opportunistic=True)\n```", "```py\n>>> from sympy import symbols, exp\n>>> from sympy.codegen.rewriting import FuncMinusOneOptim\n>>> from sympy.codegen.cfunctions import expm1\n>>> x, y = symbols('x y')\n>>> expm1_opt = FuncMinusOneOptim(exp, expm1)\n>>> expm1_opt(exp(x) + 2*exp(5*y) - 3)\nexpm1(x) + 2*expm1(5*y) \n```", "```py\nreplace_in_Add(e)\n```", "```py\nclass sympy.codegen.rewriting.Optimization(cost_function=None, priority=1)\n```", "```py\nclass sympy.codegen.rewriting.ReplaceOptim(query, value, **kwargs)\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.codegen.rewriting import ReplaceOptim\n>>> from sympy.codegen.cfunctions import exp2\n>>> x = Symbol('x')\n>>> exp2_opt = ReplaceOptim(lambda p: p.is_Pow and p.base == 2,\n...     lambda p: exp2(p.exp))\n>>> exp2_opt(2**x)\nexp2(x) \n```", "```py\nsympy.codegen.rewriting.create_expand_pow_optimization(limit, *, base_req=<function <lambda>>)\n```", "```py\n>>> from sympy import Symbol, sin\n>>> from sympy.codegen.rewriting import create_expand_pow_optimization\n>>> x = Symbol('x')\n>>> expand_opt = create_expand_pow_optimization(3)\n>>> expand_opt(x**5 + x**3)\nx**5 + x*x*x\n>>> expand_opt(x**5 + x**3 + sin(x)**3)\nx**5 + sin(x)**3 + x*x*x\n>>> opt2 = create_expand_pow_optimization(3, base_req=lambda b: not b.is_Function)\n>>> opt2((x+1)**2 + sin(x)**2)\nsin(x)**2 + (x + 1)*(x + 1) \n```", "```py\nsympy.codegen.rewriting.optimize(expr, optimizations)\n```", "```py\n>>> from sympy import log, Symbol\n>>> from sympy.codegen.rewriting import optims_c99, optimize\n>>> x = Symbol('x')\n>>> optimize(log(x+3)/log(2) + log(x**2 + 1), optims_c99)\nlog1p(x**2) + log2(x + 3) \n```", "```py\n>>> from sympy import symbols, MatrixSymbol\n>>> n = symbols('n', integer=True)\n>>> A = MatrixSymbol('A', n, n)\n>>> x = MatrixSymbol('x', n, 1)\n>>> expr = A**(-1) * x\n>>> from sympy import assuming, Q\n>>> from sympy.codegen.rewriting import matinv_opt, optimize\n>>> with assuming(Q.fullrank(A)):\n...     optimize(expr, [matinv_opt])\nMatrixSolve(A, vector=x) \n```", "```py\nclass sympy.codegen.matrix_nodes.MatrixSolve(*args, **kwargs)\n```", "```py\n>>> from sympy import symbols, MatrixSymbol\n>>> from sympy.codegen.matrix_nodes import MatrixSolve\n>>> n = symbols('n', integer=True)\n>>> A = MatrixSymbol('A', n, n)\n>>> x = MatrixSymbol('x', n, 1)\n>>> from sympy.printing.numpy import NumPyPrinter\n>>> NumPyPrinter().doprint(MatrixSolve(A, x))\n'numpy.linalg.solve(A, x)'\n>>> from sympy import octave_code\n>>> octave_code(MatrixSolve(A, x))\n'A \\\\ x' \n```", "```py\nclass sympy.codegen.approximations.SeriesApprox(bounds, reltol, max_order=4, n_point_checks=4, **kwargs)\n```", "```py\n>>> from sympy import sin, pi\n>>> from sympy.abc import x, y\n>>> from sympy.codegen.rewriting import optimize\n>>> from sympy.codegen.approximations import SeriesApprox\n>>> bounds = {x: (-.1, .1), y: (pi-1, pi+1)}\n>>> series_approx2 = SeriesApprox(bounds, reltol=1e-2)\n>>> series_approx3 = SeriesApprox(bounds, reltol=1e-3)\n>>> series_approx8 = SeriesApprox(bounds, reltol=1e-8)\n>>> expr = sin(x)*sin(y)\n>>> optimize(expr, [series_approx2])\nx*(-y + (y - pi)**3/6 + pi)\n>>> optimize(expr, [series_approx3])\n(-x**3/6 + x)*sin(y)\n>>> optimize(expr, [series_approx8])\nsin(x)*sin(y) \n```", "```py\nclass sympy.codegen.approximations.SumApprox(bounds, reltol, **kwargs)\n```", "```py\n>>> from sympy import exp\n>>> from sympy.abc import x, y, z\n>>> from sympy.codegen.rewriting import optimize\n>>> from sympy.codegen.approximations import SumApprox\n>>> bounds = {x: (-1, 1), y: (1000, 2000), z: (-10, 3)}\n>>> sum_approx3 = SumApprox(bounds, reltol=1e-3)\n>>> sum_approx2 = SumApprox(bounds, reltol=1e-2)\n>>> sum_approx1 = SumApprox(bounds, reltol=1e-1)\n>>> expr = 3*(x + y + exp(z))\n>>> optimize(expr, [sum_approx3])\n3*(x + y + exp(z))\n>>> optimize(expr, [sum_approx2])\n3*y + 3*exp(z)\n>>> optimize(expr, [sum_approx1])\n3*y \n```", "```py\n*Basic*\n     |\n     |\n CodegenAST\n     |\n     |--->AssignmentBase\n     |             |--->Assignment\n     |             |--->AugmentedAssignment\n     |                                    |--->AddAugmentedAssignment\n     |                                    |--->SubAugmentedAssignment\n     |                                    |--->MulAugmentedAssignment\n     |                                    |--->DivAugmentedAssignment\n     |                                    |--->ModAugmentedAssignment\n     |\n     |--->CodeBlock\n     |\n     |\n     |--->Token\n              |--->Attribute\n              |--->For\n              |--->String\n              |       |--->QuotedString\n              |       |--->Comment\n              |--->Type\n              |       |--->IntBaseType\n              |       |              |--->_SizedIntType\n              |       |                               |--->SignedIntType\n              |       |                               |--->UnsignedIntType\n              |       |--->FloatBaseType\n              |                        |--->FloatType\n              |                        |--->ComplexBaseType\n              |                                           |--->ComplexType\n              |--->Node\n              |       |--->Variable\n              |       |           |---> Pointer\n              |       |--->FunctionPrototype\n              |                            |--->FunctionDefinition\n              |--->Element\n              |--->Declaration\n              |--->While\n              |--->Scope\n              |--->Stream\n              |--->Print\n              |--->FunctionCall\n              |--->BreakToken\n              |--->ContinueToken\n              |--->NoneToken\n              |--->Return \n```", "```py\n>>> from sympy import symbols, cos\n>>> from sympy.codegen.ast import While, Assignment, aug_assign, Print, QuotedString\n>>> t, dx, x = symbols('tol delta val')\n>>> expr = cos(x) - x**3\n>>> whl = While(abs(dx) > t, [\n...     Assignment(dx, -expr/expr.diff(x)),\n...     aug_assign(x, '+', dx),\n...     Print([x])\n... ])\n>>> from sympy import pycode\n>>> py_str = pycode(whl)\n>>> print(py_str)\nwhile (abs(delta) > tol):\n delta = (val**3 - math.cos(val))/(-3*val**2 - math.sin(val))\n val += delta\n print(val)\n>>> import math\n>>> tol, val, delta = 1e-5, 0.5, float('inf')\n>>> exec(py_str)\n1.1121416371\n0.909672693737\n0.867263818209\n0.865477135298\n0.865474033111\n>>> print('%3.1g' % (math.cos(val) - val**3))\n-3e-11 \n```", "```py\n>>> from sympy import fcode\n>>> print(fcode(whl, standard=2003, source_format='free'))\ndo while (abs(delta) > tol)\n delta = (val**3 - cos(val))/(-3*val**2 - sin(val))\n val = val + delta\n print *, val\nend do \n```", "```py\nclass sympy.codegen.ast.Assignment(lhs, rhs)\n```", "```py\n>>> from sympy import symbols, MatrixSymbol, Matrix\n>>> from sympy.codegen.ast import Assignment\n>>> x, y, z = symbols('x, y, z')\n>>> Assignment(x, y)\nAssignment(x, y)\n>>> Assignment(x, 0)\nAssignment(x, 0)\n>>> A = MatrixSymbol('A', 1, 3)\n>>> mat = Matrix([x, y, z]).T\n>>> Assignment(A, mat)\nAssignment(A, Matrix([[x, y, z]]))\n>>> Assignment(A[0, 1], x)\nAssignment(A[0, 1], x) \n```", "```py\nclass sympy.codegen.ast.AssignmentBase(lhs, rhs)\n```", "```py\nclass sympy.codegen.ast.Attribute(possibly parametrized)\n```", "```py\n>>> from sympy.codegen.ast import Attribute\n>>> volatile = Attribute('volatile')\n>>> volatile\nvolatile\n>>> print(repr(volatile))\nAttribute(String('volatile'))\n>>> a = Attribute('foo', [1, 2, 3])\n>>> a\nfoo(1, 2, 3)\n>>> a.parameters == (1, 2, 3)\nTrue \n```", "```py\nclass sympy.codegen.ast.AugmentedAssignment(lhs, rhs)\n```", "```py\nclass sympy.codegen.ast.BreakToken(*args, **kwargs)\n```", "```py\n>>> from sympy import ccode, fcode\n>>> from sympy.codegen.ast import break_\n>>> ccode(break_)\n'break'\n>>> fcode(break_, source_format='free')\n'exit' \n```", "```py\nclass sympy.codegen.ast.CodeBlock(*args)\n```", "```py\n>>> from sympy import symbols, ccode\n>>> from sympy.codegen.ast import CodeBlock, Assignment\n>>> x, y = symbols('x y')\n>>> c = CodeBlock(Assignment(x, 1), Assignment(y, x + 1))\n>>> print(ccode(c))\nx = 1;\ny = x + 1; \n```", "```py\ncse(symbols=None, optimizations=None, postprocess=None, order='canonical')\n```", "```py\n>>> from sympy import symbols, sin\n>>> from sympy.codegen.ast import CodeBlock, Assignment\n>>> x, y, z = symbols('x y z') \n```", "```py\n>>> c = CodeBlock(\n...     Assignment(x, 1),\n...     Assignment(y, sin(x) + 1),\n...     Assignment(z, sin(x) - 1),\n... )\n...\n>>> c.cse()\nCodeBlock(\n Assignment(x, 1),\n Assignment(x0, sin(x)),\n Assignment(y, x0 + 1),\n Assignment(z, x0 - 1)\n) \n```", "```py\nclassmethod topological_sort(assignments)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.codegen.ast import CodeBlock, Assignment\n>>> x, y, z = symbols('x y z') \n```", "```py\n>>> assignments = [\n...     Assignment(x, y + z),\n...     Assignment(y, z + 1),\n...     Assignment(z, 2),\n... ]\n>>> CodeBlock.topological_sort(assignments)\nCodeBlock(\n Assignment(z, 2),\n Assignment(y, z + 1),\n Assignment(x, y + z)\n) \n```", "```py\nclass sympy.codegen.ast.Comment(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.ComplexType(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.ContinueToken(*args, **kwargs)\n```", "```py\n>>> from sympy import ccode, fcode\n>>> from sympy.codegen.ast import continue_\n>>> ccode(continue_)\n'continue'\n>>> fcode(continue_, source_format='free')\n'cycle' \n```", "```py\nclass sympy.codegen.ast.Declaration(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Declaration, NoneToken, untyped\n>>> z = Declaration('z')\n>>> z.variable.type == untyped\nTrue\n>>> # value is special NoneToken() which must be tested with == operator\n>>> z.variable.value is None  # won't work\nFalse\n>>> z.variable.value == None  # not PEP-8 compliant\nTrue\n>>> z.variable.value == NoneToken()  # OK\nTrue \n```", "```py\nclass sympy.codegen.ast.Element(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Element\n>>> elem = Element('x', 'ijk')\n>>> elem.symbol.name == 'x'\nTrue\n>>> elem.indices\n(i, j, k)\n>>> from sympy import ccode\n>>> ccode(elem)\n'x[i][j][k]'\n>>> ccode(Element('x', 'ijk', strides='lmn', offset='o'))\n'x[i*l + j*m + k*n + o]' \n```", "```py\nclass sympy.codegen.ast.FloatBaseType(*args, **kwargs)\n```", "```py\ncast_nocheck\n```", "```py\nclass sympy.codegen.ast.FloatType(*args, **kwargs)\n```", "```py\n>>> from sympy import S\n>>> from sympy.codegen.ast import FloatType\n>>> half_precision = FloatType('f16', nbits=16, nmant=10, nexp=5)\n>>> half_precision.max\n65504\n>>> half_precision.tiny == S(2)**-14\nTrue\n>>> half_precision.eps == S(2)**-10\nTrue\n>>> half_precision.dig == 3\nTrue\n>>> half_precision.decimal_dig == 5\nTrue\n>>> half_precision.cast_check(1.0)\n1.0\n>>> half_precision.cast_check(1e5)  \nTraceback (most recent call last):\n  ...\nValueError: Maximum value for data type smaller than new value. \n```", "```py\ncast_nocheck(value)\n```", "```py\nproperty decimal_dig\n```", "```py\nproperty dig\n```", "```py\nproperty eps\n```", "```py\nproperty max\n```", "```py\nproperty max_exponent\n```", "```py\nproperty min_exponent\n```", "```py\nproperty tiny\n```", "```py\nclass sympy.codegen.ast.For(*args, **kwargs)\n```", "```py\n>>> from sympy import symbols, Range\n>>> from sympy.codegen.ast import aug_assign, For\n>>> x, i, j, k = symbols('x i j k')\n>>> for_i = For(i, Range(10), [aug_assign(x, '+', i*j*k)])\n>>> for_i  \nFor(i, iterable=Range(0, 10, 1), body=CodeBlock(\n AddAugmentedAssignment(x, i*j*k)\n))\n>>> for_ji = For(j, Range(7), [for_i])\n>>> for_ji  \nFor(j, iterable=Range(0, 7, 1), body=CodeBlock(\n For(i, iterable=Range(0, 10, 1), body=CodeBlock(\n AddAugmentedAssignment(x, i*j*k)\n ))\n))\n>>> for_kji =For(k, Range(5), [for_ji])\n>>> for_kji  \nFor(k, iterable=Range(0, 5, 1), body=CodeBlock(\n For(j, iterable=Range(0, 7, 1), body=CodeBlock(\n For(i, iterable=Range(0, 10, 1), body=CodeBlock(\n AddAugmentedAssignment(x, i*j*k)\n ))\n ))\n)) \n```", "```py\nclass sympy.codegen.ast.FunctionCall(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import FunctionCall\n>>> from sympy import pycode\n>>> fcall = FunctionCall('foo', 'bar baz'.split())\n>>> print(pycode(fcall))\nfoo(bar, baz) \n```", "```py\nclass sympy.codegen.ast.FunctionDefinition(*args, **kwargs)\n```", "```py\n>>> from sympy import ccode, symbols\n>>> from sympy.codegen.ast import real, FunctionPrototype\n>>> x, y = symbols('x y', real=True)\n>>> fp = FunctionPrototype(real, 'foo', [x, y])\n>>> ccode(fp)\n'double foo(double x, double y)'\n>>> from sympy.codegen.ast import FunctionDefinition, Return\n>>> body = [Return(x*y)]\n>>> fd = FunctionDefinition.from_FunctionPrototype(fp, body)\n>>> print(ccode(fd))\ndouble foo(double x, double y){\n return x*y;\n} \n```", "```py\nclass sympy.codegen.ast.FunctionPrototype(*args, **kwargs)\n```", "```py\n>>> from sympy import ccode, symbols\n>>> from sympy.codegen.ast import real, FunctionPrototype\n>>> x, y = symbols('x y', real=True)\n>>> fp = FunctionPrototype(real, 'foo', [x, y])\n>>> ccode(fp)\n'double foo(double x, double y)' \n```", "```py\nclass sympy.codegen.ast.IntBaseType(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Node(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Node, value_const, pointer_const\n>>> n1 = Node([value_const])\n>>> n1.attr_params('value_const')  # get the parameters of attribute (by name)\n()\n>>> from sympy.codegen.fnodes import dimension\n>>> n2 = Node([value_const, dimension(5, 3)])\n>>> n2.attr_params(value_const)  # get the parameters of attribute (by Attribute instance)\n()\n>>> n2.attr_params('dimension')  # get the parameters of attribute (by name)\n(5, 3)\n>>> n2.attr_params(pointer_const) is None\nTrue \n```", "```py\nattr_params(looking_for)\n```", "```py\nclass sympy.codegen.ast.NoneToken(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import none, Variable\n>>> from sympy import pycode\n>>> print(pycode(Variable('x').as_Declaration(value=none)))\nx = None \n```", "```py\nclass sympy.codegen.ast.Pointer(*args, **kwargs)\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.codegen.ast import Pointer\n>>> i = Symbol('i', integer=True)\n>>> p = Pointer('x')\n>>> p[i+1]\nElement(x, indices=(i + 1,)) \n```", "```py\nclass sympy.codegen.ast.Print(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Print\n>>> from sympy import pycode\n>>> print(pycode(Print('x y'.split(), \"coordinate: %12.5g  %12.5g\\\\n\")))\nprint(\"coordinate: %12.5g %12.5g\\n\" % (x, y), end=\"\") \n```", "```py\nclass sympy.codegen.ast.QuotedString(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Raise(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Return(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Return\n>>> from sympy.printing.pycode import pycode\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> print(pycode(Return(x)))\nreturn x \n```", "```py\nclass sympy.codegen.ast.RuntimeError_(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Scope(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.SignedIntType(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Stream(*args, **kwargs)\n```", "```py\n>>> from sympy import pycode, Symbol\n>>> from sympy.codegen.ast import Print, stderr, QuotedString\n>>> print(pycode(Print(['x'], file=stderr)))\nprint(x, file=sys.stderr)\n>>> x = Symbol('x')\n>>> print(pycode(Print([QuotedString('x')], file=stderr)))  # print literally \"x\"\nprint(\"x\", file=sys.stderr) \n```", "```py\nclass sympy.codegen.ast.String(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import String\n>>> f = String('foo')\n>>> f\nfoo\n>>> str(f)\n'foo'\n>>> f.text\n'foo'\n>>> print(repr(f))\nString('foo') \n```", "```py\nclass sympy.codegen.ast.Token(*args, **kwargs)\n```", "```py_fields`. The ``defaults```", "```py\nkwargs(exclude=(), apply=None)\n```", "```py\nclass sympy.codegen.ast.Type(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Type\n>>> t = Type.from_expr(42)\n>>> t\ninteger\n>>> print(repr(t))\nIntBaseType(String('integer'))\n>>> from sympy.codegen.ast import uint8\n>>> uint8.cast_check(-1)   \nTraceback (most recent call last):\n  ...\nValueError: Minimum value for data type bigger than new value.\n>>> from sympy.codegen.ast import float32\n>>> v6 = 0.123456\n>>> float32.cast_check(v6)\n0.123456\n>>> v10 = 12345.67894\n>>> float32.cast_check(v10)  \nTraceback (most recent call last):\n  ...\nValueError: Casting gives a significantly different value.\n>>> boost_mp50 = Type('boost::multiprecision::cpp_dec_float_50')\n>>> from sympy import cxxcode\n>>> from sympy.codegen.ast import Declaration, Variable\n>>> cxxcode(Declaration(Variable('x', type=boost_mp50)))\n'boost::multiprecision::cpp_dec_float_50 x' \n```", "```py\ncast_check(value, rtol=None, atol=0, precision_targets=None)\n```", "```py\n>>> from sympy.codegen.ast import integer, float32, int8\n>>> integer.cast_check(3.0) == 3\nTrue\n>>> float32.cast_check(1e-40)  \nTraceback (most recent call last):\n  ...\nValueError: Minimum value for data type bigger than new value.\n>>> int8.cast_check(256)  \nTraceback (most recent call last):\n  ...\nValueError: Maximum value for data type smaller than new value.\n>>> v10 = 12345.67894\n>>> float32.cast_check(v10)  \nTraceback (most recent call last):\n  ...\nValueError: Casting gives a significantly different value.\n>>> from sympy.codegen.ast import float64\n>>> float64.cast_check(v10)\n12345.67894\n>>> from sympy import Float\n>>> v18 = Float('0.123456789012345646')\n>>> float64.cast_check(v18)\nTraceback (most recent call last):\n  ...\nValueError: Casting gives a significantly different value.\n>>> from sympy.codegen.ast import float80\n>>> float80.cast_check(v18)\n0.123456789012345649 \n```", "```py\nclassmethod from_expr(expr)\n```", "```py\n>>> from sympy.codegen.ast import Type, integer, complex_\n>>> Type.from_expr(2) == integer\nTrue\n>>> from sympy import Symbol\n>>> Type.from_expr(Symbol('z', complex=True)) == complex_\nTrue\n>>> Type.from_expr(sum)  \nTraceback (most recent call last):\n  ...\nValueError: Could not deduce type from expr. \n```", "```py\nclass sympy.codegen.ast.UnsignedIntType(*args, **kwargs)\n```", "```py\nclass sympy.codegen.ast.Variable(*args, **kwargs)\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.codegen.ast import Variable, float32, integer\n>>> x = Symbol('x')\n>>> v = Variable(x, type=float32)\n>>> v.attrs\n()\n>>> v == Variable('x')\nFalse\n>>> v == Variable('x', type=float32)\nTrue\n>>> v\nVariable(x, type=float32) \n```", "```py\n>>> i = Symbol('i', integer=True)\n>>> v = Variable.deduced(i)\n>>> v.type == integer\nTrue\n>>> v == Variable('i')\nFalse\n>>> from sympy.codegen.ast import value_const\n>>> value_const in v.attrs\nFalse\n>>> w = Variable('w', attrs=[value_const])\n>>> w\nVariable(w, attrs=(value_const,))\n>>> value_const in w.attrs\nTrue\n>>> w.as_Declaration(value=42)\nDeclaration(Variable(w, value=42, attrs=(value_const,))) \n```", "```py\nas_Declaration(**kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Variable, NoneToken\n>>> x = Variable('x')\n>>> decl1 = x.as_Declaration()\n>>> # value is special NoneToken() which must be tested with == operator\n>>> decl1.variable.value is None  # won't work\nFalse\n>>> decl1.variable.value == None  # not PEP-8 compliant\nTrue\n>>> decl1.variable.value == NoneToken()  # OK\nTrue\n>>> decl2 = x.as_Declaration(value=42.0)\n>>> decl2.variable.value == 42.0\nTrue \n```", "```py\nclassmethod deduced(symbol, value=None, attrs=(), cast_check=True)\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.codegen.ast import Variable, complex_\n>>> n = Symbol('n', integer=True)\n>>> str(Variable.deduced(n).type)\n'integer'\n>>> x = Symbol('x', real=True)\n>>> v = Variable.deduced(x)\n>>> v.type\nreal\n>>> z = Symbol('z', complex=True)\n>>> Variable.deduced(z).type == complex_\nTrue \n```", "```py\nclass sympy.codegen.ast.While(*args, **kwargs)\n```", "```py\n>>> from sympy import symbols, Gt, Abs\n>>> from sympy.codegen import aug_assign, Assignment, While\n>>> x, dx = symbols('x dx')\n>>> expr = 1 - x**2\n>>> whl = While(Gt(Abs(dx), 1e-9), [\n...     Assignment(dx, -expr/expr.diff(x)),\n...     aug_assign(x, '+', dx)\n... ]) \n```", "```py\nsympy.codegen.ast.aug_assign(lhs, op, rhs)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.codegen.ast import aug_assign\n>>> x, y = symbols('x, y')\n>>> aug_assign(x, '+', y)\nAddAugmentedAssignment(x, y) \n```", "```py\nclass sympy.codegen.cfunctions.Cbrt(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import Cbrt\n>>> Cbrt(x)\nCbrt(x)\n>>> Cbrt(x).diff(x)\n1/(3*x**(2/3)) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.Sqrt(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import Sqrt\n>>> Sqrt(x)\nSqrt(x)\n>>> Sqrt(x).diff(x)\n1/(2*sqrt(x)) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.exp2(arg)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import exp2\n>>> exp2(2).evalf() == 4.0\nTrue\n>>> exp2(x).diff(x)\nlog(2)*exp2(x) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.expm1(arg)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import expm1\n>>> '%.0e' % expm1(1e-99).evalf()\n'1e-99'\n>>> from math import exp\n>>> exp(1e-99) - 1\n0.0\n>>> expm1(x).diff(x)\nexp(x) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.fma(*args)\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy.codegen.cfunctions import fma\n>>> fma(x, y, z).diff(x)\ny \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.hypot(*args)\n```", "```py\n>>> from sympy.abc import x, y\n>>> from sympy.codegen.cfunctions import hypot\n>>> hypot(3, 4).evalf() == 5.0\nTrue\n>>> hypot(x, y)\nhypot(x, y)\n>>> hypot(x, y).diff(x)\nx/hypot(x, y) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.log10(arg)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import log10\n>>> log10(100).evalf() == 2.0\nTrue\n>>> log10(x).diff(x)\n1/(x*log(10)) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.log1p(arg)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import log1p\n>>> from sympy import expand_log\n>>> '%.0e' % expand_log(log1p(1e-99)).evalf()\n'1e-99'\n>>> from math import log\n>>> log(1 + 1e-99)\n0.0\n>>> log1p(x).diff(x)\n1/(x + 1) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cfunctions.log2(arg)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cfunctions import log2\n>>> log2(4).evalf() == 2.0\nTrue\n>>> log2(x).diff(x)\n1/(x*log(2)) \n```", "```py\nfdiff(argindex=1)\n```", "```py\nclass sympy.codegen.cnodes.CommaOperator(*args)\n```", "```py\nclass sympy.codegen.cnodes.Label(*args, **kwargs)\n```", "```py\n>>> from sympy import ccode, Symbol\n>>> from sympy.codegen.cnodes import Label, PreIncrement\n>>> print(ccode(Label('foo')))\nfoo:\n>>> print(ccode(Label('bar', [PreIncrement(Symbol('a'))])))\nbar:\n++(a); \n```", "```py\nclass sympy.codegen.cnodes.PostDecrement(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cnodes import PostDecrement\n>>> from sympy import ccode\n>>> ccode(PostDecrement(x))\n'(x)--' \n```", "```py\nclass sympy.codegen.cnodes.PostIncrement(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cnodes import PostIncrement\n>>> from sympy import ccode\n>>> ccode(PostIncrement(x))\n'(x)++' \n```", "```py\nclass sympy.codegen.cnodes.PreDecrement(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cnodes import PreDecrement\n>>> from sympy import ccode\n>>> ccode(PreDecrement(x))\n'--(x)' \n```", "```py\nclass sympy.codegen.cnodes.PreIncrement(*args)\n```", "```py\n>>> from sympy.abc import x\n>>> from sympy.codegen.cnodes import PreIncrement\n>>> from sympy import ccode\n>>> ccode(PreIncrement(x))\n'++(x)' \n```", "```py\nsympy.codegen.cnodes.alignof(arg)\n```", "```py\nclass sympy.codegen.cnodes.goto(*args, **kwargs)\n```", "```py\nsympy.codegen.cnodes.sizeof(arg)\n```", "```py\n>>> from sympy.codegen.ast import real\n>>> from sympy.codegen.cnodes import sizeof\n>>> from sympy import ccode\n>>> ccode(sizeof(real))\n'sizeof(double)' \n```", "```py\nclass sympy.codegen.cnodes.struct(*args, **kwargs)\n```", "```py\nclass sympy.codegen.cnodes.union(*args, **kwargs)\n```", "```py\nclass sympy.codegen.cxxnodes.using(*args, **kwargs)\n```", "```py\nclass sympy.codegen.fnodes.ArrayConstructor(*args, **kwargs)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.fnodes import ArrayConstructor\n>>> ac = ArrayConstructor([1, 2, 3])\n>>> fcode(ac, standard=95, source_format='free')\n'(/1, 2, 3/)'\n>>> fcode(ac, standard=2003, source_format='free')\n'[1, 2, 3]' \n```", "```py\nclass sympy.codegen.fnodes.Do(*args, **kwargs)\n```", "```py\n>>> from sympy import fcode, symbols\n>>> from sympy.codegen.ast import aug_assign, Print\n>>> from sympy.codegen.fnodes import Do\n>>> i, n = symbols('i n', integer=True)\n>>> r = symbols('r', real=True)\n>>> body = [aug_assign(r, '+', 1/i), Print([i, r])]\n>>> do1 = Do(body, i, 1, n)\n>>> print(fcode(do1, source_format='free'))\ndo i = 1, n\n r = r + 1d0/i\n print *, i, r\nend do\n>>> do2 = Do(body, i, 1, n, 2)\n>>> print(fcode(do2, source_format='free'))\ndo i = 1, n, 2\n r = r + 1d0/i\n print *, i, r\nend do \n```", "```py\nclass sympy.codegen.fnodes.Extent(*args)\n```", "```py\n>>> from sympy.codegen.fnodes import Extent\n>>> e = Extent(-3, 3)  # -3, -2, -1, 0, 1, 2, 3\n>>> from sympy import fcode\n>>> fcode(e, source_format='free')\n'-3:3'\n>>> from sympy.codegen.ast import Variable, real\n>>> from sympy.codegen.fnodes import dimension, intent_out\n>>> dim = dimension(e, e)\n>>> arr = Variable('x', real, attrs=[dim, intent_out])\n>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)\n'real*8, dimension(-3:3, -3:3), intent(out) :: x' \n```", "```py\nclass sympy.codegen.fnodes.FortranReturn(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import FortranReturn\n>>> from sympy import fcode\n>>> fcode(FortranReturn('x'))\n'       return x' \n```", "```py\nclass sympy.codegen.fnodes.GoTo(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import GoTo\n>>> go = GoTo([10, 20, 30], 'i')\n>>> from sympy import fcode\n>>> fcode(go, source_format='free')\n'go to (10, 20, 30), i' \n```", "```py\nclass sympy.codegen.fnodes.ImpliedDoLoop(*args, **kwargs)\n```", "```py\n>>> from sympy import Symbol, fcode\n>>> from sympy.codegen.fnodes import ImpliedDoLoop, ArrayConstructor\n>>> i = Symbol('i', integer=True)\n>>> idl = ImpliedDoLoop(i**3, i, -3, 3, 2)  # -27, -1, 1, 27\n>>> ac = ArrayConstructor([-28, idl, 28]) # -28, -27, -1, 1, 27, 28\n>>> fcode(ac, standard=2003, source_format='free')\n'[-28, (i**3, i = -3, 3, 2), 28]' \n```", "```py\nclass sympy.codegen.fnodes.Module(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import Module\n>>> from sympy import fcode\n>>> print(fcode(Module('signallib', ['implicit none'], []), source_format='free'))\nmodule signallib\nimplicit none\n\ncontains\n\nend module \n```", "```py\nclass sympy.codegen.fnodes.Program(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.ast import Print\n>>> from sympy.codegen.fnodes import Program\n>>> prog = Program('myprogram', [Print([42])])\n>>> from sympy import fcode\n>>> print(fcode(prog, source_format='free'))\nprogram myprogram\n print *, 42\nend program \n```", "```py\nclass sympy.codegen.fnodes.Subroutine(*args, **kwargs)\n```", "```py\n>>> from sympy import fcode, symbols\n>>> from sympy.codegen.ast import Print\n>>> from sympy.codegen.fnodes import Subroutine\n>>> x, y = symbols('x y', real=True)\n>>> sub = Subroutine('mysub', [x, y], [Print([x**2 + y**2, x*y])])\n>>> print(fcode(sub, source_format='free', standard=2003))\nsubroutine mysub(x, y)\nreal*8 :: x\nreal*8 :: y\nprint *, x**2 + y**2, x*y\nend subroutine \n```", "```py\nclass sympy.codegen.fnodes.SubroutineCall(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import SubroutineCall\n>>> from sympy import fcode\n>>> fcode(SubroutineCall('mysub', 'x y'.split()))\n'       call mysub(x, y)' \n```", "```py\nsympy.codegen.fnodes.allocated(array)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.fnodes import allocated\n>>> alloc = allocated('x')\n>>> fcode(alloc, source_format='free')\n'allocated(x)' \n```", "```py\nsympy.codegen.fnodes.array(symbol, dim, intent=None, *, attrs=(), value=None, type=None)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.ast import integer, real\n>>> from sympy.codegen.fnodes import array\n>>> arr = array('a', '*', 'in', type=integer)\n>>> print(fcode(arr.as_Declaration(), source_format='free', standard=2003))\ninteger*4, dimension(*), intent(in) :: a\n>>> x = array('x', [3, ':', ':'], intent='out', type=real)\n>>> print(fcode(x.as_Declaration(value=1), source_format='free', standard=2003))\nreal*8, dimension(3, :, :), intent(out) :: x = 1 \n```", "```py\nsympy.codegen.fnodes.bind_C(name=None)\n```", "```py\n>>> from sympy import fcode, Symbol\n>>> from sympy.codegen.ast import FunctionDefinition, real, Return\n>>> from sympy.codegen.fnodes import array, sum_, bind_C\n>>> a = Symbol('a', real=True)\n>>> s = Symbol('s', integer=True)\n>>> arr = array(a, dim=[s], intent='in')\n>>> body = [Return((sum_(a**2)/s)**.5)]\n>>> fd = FunctionDefinition(real, 'rms', [arr, s], body, attrs=[bind_C('rms')])\n>>> print(fcode(fd, source_format='free', standard=2003))\nreal*8 function rms(a, s) bind(C, name=\"rms\")\nreal*8, dimension(s), intent(in) :: a\ninteger*4 :: s\nrms = sqrt(sum(a**2)/s)\nend function \n```", "```py\nclass sympy.codegen.fnodes.cmplx(*args)\n```", "```py\nsympy.codegen.fnodes.dimension(*args)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.fnodes import dimension, intent_in\n>>> dim = dimension('2', ':')  # 2 rows, runtime determined number of columns\n>>> from sympy.codegen.ast import Variable, integer\n>>> arr = Variable('a', integer, attrs=[dim, intent_in])\n>>> fcode(arr.as_Declaration(), source_format='free', standard=2003)\n'integer*4, dimension(2, :), intent(in) :: a' \n```", "```py\nclass sympy.codegen.fnodes.dsign(*args)\n```", "```py\nclass sympy.codegen.fnodes.isign(*args)\n```", "```py\nclass sympy.codegen.fnodes.kind(*args)\n```", "```py\nsympy.codegen.fnodes.lbound(array, dim=None, kind=None)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.fnodes import lbound\n>>> lb = lbound('arr', dim=2)\n>>> fcode(lb, source_format='free')\n'lbound(arr, 2)' \n```", "```py\nclass sympy.codegen.fnodes.literal_dp(num, dps=None, precision=None)\n```", "```py\nclass sympy.codegen.fnodes.literal_sp(num, dps=None, precision=None)\n```", "```py\nclass sympy.codegen.fnodes.merge(*args)\n```", "```py\nsympy.codegen.fnodes.reshape(source, shape, pad=None, order=None)\n```", "```py\nsympy.codegen.fnodes.shape(source, kind=None)\n```", "```py\n>>> from sympy import fcode\n>>> from sympy.codegen.fnodes import shape\n>>> shp = shape('x')\n>>> fcode(shp, source_format='free')\n'shape(x)' \n```", "```py\nsympy.codegen.fnodes.size(array, dim=None, kind=None)\n```", "```py\n>>> from sympy import fcode, Symbol\n>>> from sympy.codegen.ast import FunctionDefinition, real, Return\n>>> from sympy.codegen.fnodes import array, sum_, size\n>>> a = Symbol('a', real=True)\n>>> body = [Return((sum_(a**2)/size(a))**.5)]\n>>> arr = array(a, dim=[':'], intent='in')\n>>> fd = FunctionDefinition(real, 'rms', [arr], body)\n>>> print(fcode(fd, source_format='free', standard=2003))\nreal*8 function rms(a)\nreal*8, dimension(:), intent(in) :: a\nrms = sqrt(sum(a**2)*1d0/size(a))\nend function \n```", "```py\nclass sympy.codegen.fnodes.use(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import use\n>>> from sympy import fcode\n>>> fcode(use('signallib'), source_format='free')\n'use signallib'\n>>> fcode(use('signallib', [('metric', 'snr')]), source_format='free')\n'use signallib, metric => snr'\n>>> fcode(use('signallib', only=['snr', 'convolution2d']), source_format='free')\n'use signallib, only: snr, convolution2d' \n```", "```py\nclass sympy.codegen.fnodes.use_rename(*args, **kwargs)\n```", "```py\n>>> from sympy.codegen.fnodes import use_rename, use\n>>> from sympy import fcode\n>>> ren = use_rename(\"thingy\", \"convolution2d\")\n>>> print(fcode(ren, source_format='free'))\nthingy => convolution2d\n>>> full = use('signallib', only=['snr', ren])\n>>> print(fcode(full, source_format='free'))\nuse signallib, only: snr, thingy => convolution2d \n```", "```py\nsympy.codegen.algorithms.newtons_method(expr, wrt, atol=1e-12, delta=None, *, rtol=4e-16, debug=False, itermax=None, counter=None, delta_fn=<function <lambda>>, cse=False, handle_nan=None, bounds=None)\n```", "```py\n>>> from sympy import symbols, cos\n>>> from sympy.codegen.ast import Assignment\n>>> from sympy.codegen.algorithms import newtons_method\n>>> x, dx, atol = symbols('x dx atol')\n>>> expr = cos(x) - x**3\n>>> algo = newtons_method(expr, x, atol=atol, delta=dx)\n>>> algo.has(Assignment(dx, -expr/expr.diff(x)))\nTrue \n```", "```py\nsympy.codegen.algorithms.newtons_method_function(expr, wrt, params=None, func_name='newton', attrs=(), *, delta=None, **kwargs)\n```", "```py\n>>> from sympy import symbols, cos\n>>> from sympy.codegen.algorithms import newtons_method_function\n>>> from sympy.codegen.pyutils import render_as_module\n>>> x = symbols('x')\n>>> expr = cos(x) - x**3\n>>> func = newtons_method_function(expr, x)\n>>> py_mod = render_as_module(func)  # source code as string\n>>> namespace = {}\n>>> exec(py_mod, namespace, namespace)\n>>> res = eval('newton(0.5)', namespace)\n>>> abs(res - 0.865474033102) < 1e-12\nTrue \n```", "```py\nsympy.codegen.pyutils.render_as_module(content, standard='python3')\n```", "```py\nsympy.codegen.cutils.render_as_source_file(content, Printer=<class 'sympy.printing.c.C99CodePrinter'>, settings=None)\n```", "```py\nsympy.codegen.futils.render_as_module(definitions, name, declarations=(), printer_settings=None)\n```"]