- en: scipy.optimize.minimize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Minimization of scalar function of one or more variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The objective function to be minimized.
  prefs: []
  type: TYPE_NORMAL
- en: '`fun(x, *args) -> float`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `x` is a 1-D array with shape (n,) and `args` is a tuple of the fixed
    parameters needed to completely specify the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**ndarray, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess. Array of real elements of size (n,), where `n` is the number
    of independent variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments passed to the objective function and its derivatives (*fun*,
    *jac* and *hess* functions).
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str or callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Type of solver. Should be one of
  prefs: []
  type: TYPE_NORMAL
- en: ‘Nelder-Mead’ [(see here)](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘Powell’ [(see here)](../optimize.minimize-powell.html#optimize-minimize-powell)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘CG’ [(see here)](../optimize.minimize-cg.html#optimize-minimize-cg)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘BFGS’ [(see here)](../optimize.minimize-bfgs.html#optimize-minimize-bfgs)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘Newton-CG’ [(see here)](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘L-BFGS-B’ [(see here)](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘TNC’ [(see here)](../optimize.minimize-tnc.html#optimize-minimize-tnc)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘COBYLA’ [(see here)](../optimize.minimize-cobyla.html#optimize-minimize-cobyla)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘SLSQP’ [(see here)](../optimize.minimize-slsqp.html#optimize-minimize-slsqp)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-constr’[(see here)](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘dogleg’ [(see here)](../optimize.minimize-dogleg.html#optimize-minimize-dogleg)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-ncg’ [(see here)](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-exact’ [(see here)](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-krylov’ [(see here)](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: custom - a callable object, see below for description.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If not given, chosen to be one of `BFGS`, `L-BFGS-B`, `SLSQP`, depending on
    whether or not the problem has constraints or bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**jac**{callable, ‘2-point’, ‘3-point’, ‘cs’, bool}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method for computing the gradient vector. Only for CG, BFGS, Newton-CG, L-BFGS-B,
    TNC, SLSQP, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If
    it is a callable, it should be a function that returns the gradient vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jac(x, *args) -> array_like, shape (n,)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `x` is an array with shape (n,) and `args` is a tuple with the fixed parameters.
    If *jac* is a Boolean and is True, *fun* is assumed to return a tuple `(f, g)`
    containing the objective function and the gradient. Methods ‘Newton-CG’, ‘trust-ncg’,
    ‘dogleg’, ‘trust-exact’, and ‘trust-krylov’ require that either a callable be
    supplied, or that *fun* return the objective and gradient. If None or False, the
    gradient will be estimated using 2-point finite difference estimation with an
    absolute step size. Alternatively, the keywords {‘2-point’, ‘3-point’, ‘cs’} can
    be used to select a finite difference scheme for numerical estimation of the gradient
    with a relative step size. These finite difference schemes obey any specified
    *bounds*.
  prefs: []
  type: TYPE_NORMAL
- en: '**hess**{callable, ‘2-point’, ‘3-point’, ‘cs’, HessianUpdateStrategy}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method for computing the Hessian matrix. Only for Newton-CG, dogleg, trust-ncg,
    trust-krylov, trust-exact and trust-constr. If it is callable, it should return
    the Hessian matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'where `x` is a (n,) ndarray and `args` is a tuple with the fixed parameters.
    The keywords {‘2-point’, ‘3-point’, ‘cs’} can also be used to select a finite
    difference scheme for numerical estimation of the hessian. Alternatively, objects
    implementing the [`HessianUpdateStrategy`](scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") interface can be used to approximate the
    Hessian. Available quasi-Newton methods implementing this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`BFGS`](scipy.optimize.BFGS.html#scipy.optimize.BFGS "scipy.optimize.BFGS");'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`SR1`](scipy.optimize.SR1.html#scipy.optimize.SR1 "scipy.optimize.SR1").'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of the options are available for each of the methods; for availability
    refer to the notes.
  prefs: []
  type: TYPE_NORMAL
- en: '**hessp**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hessian of objective function times an arbitrary vector p. Only for Newton-CG,
    trust-ncg, trust-krylov, trust-constr. Only one of *hessp* or *hess* needs to
    be given. If *hess* is provided, then *hessp* will be ignored. *hessp* must compute
    the Hessian times an arbitrary vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hessp(x, p, *args) ->  ndarray shape (n,)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `x` is a (n,) ndarray, `p` is an arbitrary vector with dimension (n,)
    and `args` is a tuple with the fixed parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**sequence or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, trust-constr,
    and COBYLA methods. There are two ways to specify the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Sequence of `(min, max)` pairs for each element in *x*. None is used to specify
    no bound.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: '**constraints**{Constraint, dict} or List of {Constraint, dict}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints definition. Only for COBYLA, SLSQP and trust-constr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints for ‘trust-constr’ are defined as a single object or a list of
    objects specifying constraints to the optimization problem. Available constraints
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NonlinearConstraint`](scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constraints for COBYLA, SLSQP are defined as a list of dictionaries. Each dictionary
    with fields:'
  prefs: []
  type: TYPE_NORMAL
- en: typestr
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: funcallable
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function defining the constraint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: jaccallable, optional
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Jacobian of *fun* (only for SLSQP).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argssequence, optional
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extra arguments to be passed to the function and Jacobian.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equality constraint means that the constraint function result is to be zero
    whereas inequality means that it is to be non-negative. Note that COBYLA only
    supports inequality constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Tolerance for termination. When *tol* is specified, the selected minimization
    algorithm sets some relevant solver-specific tolerance(s) equal to *tol*. For
    detailed control, use solver-specific options.
  prefs: []
  type: TYPE_NORMAL
- en: '**options**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary of solver options. All methods except *TNC* accept the following
    generic options:'
  prefs: []
  type: TYPE_NORMAL
- en: maxiterint
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maximum number of iterations to perform. Depending on the method each iteration
    may use several function evaluations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For *TNC* use *maxfun* instead of *maxiter*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dispbool
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set to True to print convergence messages.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For method-specific options, see [`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options").
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A callable called after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'All methods except TNC, SLSQP, and COBYLA support a callable with the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback(intermediate_result: OptimizeResult)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `intermediate_result` is a keyword parameter containing an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") with attributes `x` and `fun`, the present values
    of the parameter vector and objective function. Note that the name of the parameter
    must be `intermediate_result` for the callback to be passed an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult"). These methods will also terminate if the callback
    raises `StopIteration`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All methods except trust-constr (also) support a signature like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback(xk)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `xk` is the current parameter vector.
  prefs: []
  type: TYPE_NORMAL
- en: Introspection is used to determine which of the signatures above to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**res**OptimizeResult'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optimization result represented as a `OptimizeResult` object. Important
    attributes are: `x` the solution array, `success` a Boolean flag indicating if
    the optimizer exited successfully and `message` which describes the cause of the
    termination. See [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") for a description of other attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimize_scalar`](scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: Interface to minimization algorithms for scalar univariate functions
  prefs: []
  type: TYPE_NORMAL
- en: '[`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options")'
  prefs: []
  type: TYPE_NORMAL
- en: Additional options accepted by the solvers
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the available solvers that can be selected by the ‘method’
    parameter. The default method is *BFGS*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unconstrained minimization**'
  prefs: []
  type: TYPE_NORMAL
- en: Method [CG](../optimize.minimize-cg.html#optimize-minimize-cg) uses a nonlinear
    conjugate gradient algorithm by Polak and Ribiere, a variant of the Fletcher-Reeves
    method described in [[5]](#rdd2e1855725e-5) pp.120-122\. Only the first derivatives
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Method [BFGS](../optimize.minimize-bfgs.html#optimize-minimize-bfgs) uses the
    quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [[5]](#rdd2e1855725e-5)
    pp. 136\. It uses the first derivatives only. BFGS has proven good performance
    even for non-smooth optimizations. This method also returns an approximation of
    the Hessian inverse, stored as *hess_inv* in the OptimizeResult object.
  prefs: []
  type: TYPE_NORMAL
- en: Method [Newton-CG](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
    uses a Newton-CG algorithm [[5]](#rdd2e1855725e-5) pp. 168 (also known as the
    truncated Newton method). It uses a CG method to the compute the search direction.
    See also *TNC* method for a box-constrained minimization with a similar algorithm.
    Suitable for large-scale problems.
  prefs: []
  type: TYPE_NORMAL
- en: Method [dogleg](../optimize.minimize-dogleg.html#optimize-minimize-dogleg) uses
    the dog-leg trust-region algorithm [[5]](#rdd2e1855725e-5) for unconstrained minimization.
    This algorithm requires the gradient and Hessian; furthermore the Hessian is required
    to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: Method [trust-ncg](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
    uses the Newton conjugate gradient trust-region algorithm [[5]](#rdd2e1855725e-5)
    for unconstrained minimization. This algorithm requires the gradient and either
    the Hessian or a function that computes the product of the Hessian with a given
    vector. Suitable for large-scale problems.
  prefs: []
  type: TYPE_NORMAL
- en: Method [trust-krylov](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)
    uses the Newton GLTR trust-region algorithm [[14]](#rdd2e1855725e-14), [[15]](#rdd2e1855725e-15)
    for unconstrained minimization. This algorithm requires the gradient and either
    the Hessian or a function that computes the product of the Hessian with a given
    vector. Suitable for large-scale problems. On indefinite problems it requires
    usually less iterations than the *trust-ncg* method and is recommended for medium
    and large-scale problems.
  prefs: []
  type: TYPE_NORMAL
- en: Method [trust-exact](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)
    is a trust-region method for unconstrained minimization in which quadratic subproblems
    are solved almost exactly [[13]](#rdd2e1855725e-13). This algorithm requires the
    gradient and the Hessian (which is *not* required to be positive definite). It
    is, in many situations, the Newton method to converge in fewer iterations and
    the most recommended for small and medium-size problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bound-Constrained minimization**'
  prefs: []
  type: TYPE_NORMAL
- en: Method [Nelder-Mead](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)
    uses the Simplex algorithm [[1]](#rdd2e1855725e-1), [[2]](#rdd2e1855725e-2). This
    algorithm is robust in many applications. However, if numerical computation of
    derivative can be trusted, other algorithms using the first and/or second derivatives
    information might be preferred for their better performance in general.
  prefs: []
  type: TYPE_NORMAL
- en: Method [L-BFGS-B](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)
    uses the L-BFGS-B algorithm [[6]](#rdd2e1855725e-6), [[7]](#rdd2e1855725e-7) for
    bound constrained minimization.
  prefs: []
  type: TYPE_NORMAL
- en: Method [Powell](../optimize.minimize-powell.html#optimize-minimize-powell) is
    a modification of Powell’s method [[3]](#rdd2e1855725e-3), [[4]](#rdd2e1855725e-4)
    which is a conjugate direction method. It performs sequential one-dimensional
    minimizations along each vector of the directions set (*direc* field in *options*
    and *info*), which is updated at each iteration of the main minimization loop.
    The function need not be differentiable, and no derivatives are taken. If bounds
    are not provided, then an unbounded line search will be used. If bounds are provided
    and the initial guess is within the bounds, then every function evaluation throughout
    the minimization procedure will be within the bounds. If bounds are provided,
    the initial guess is outside the bounds, and *direc* is full rank (default has
    full rank), then some function evaluations during the first iteration may be outside
    the bounds, but every function evaluation after the first iteration will be within
    the bounds. If *direc* is not full rank, then some parameters may not be optimized
    and the solution is not guaranteed to be within the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Method [TNC](../optimize.minimize-tnc.html#optimize-minimize-tnc) uses a truncated
    Newton algorithm [[5]](#rdd2e1855725e-5), [[8]](#rdd2e1855725e-8) to minimize
    a function with variables subject to bounds. This algorithm uses gradient information;
    it is also called Newton Conjugate-Gradient. It differs from the *Newton-CG* method
    described above as it wraps a C implementation and allows each variable to be
    given upper and lower bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constrained Minimization**'
  prefs: []
  type: TYPE_NORMAL
- en: Method [COBYLA](../optimize.minimize-cobyla.html#optimize-minimize-cobyla) uses
    the Constrained Optimization BY Linear Approximation (COBYLA) method [[9]](#rdd2e1855725e-9),
    [[10]](#rdd2e1855725e-10), [[11]](#rdd2e1855725e-11). The algorithm is based on
    linear approximations to the objective function and each constraint. The method
    wraps a FORTRAN implementation of the algorithm. The constraints functions ‘fun’
    may return either a single number or an array or list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Method [SLSQP](../optimize.minimize-slsqp.html#optimize-minimize-slsqp) uses
    Sequential Least SQuares Programming to minimize a function of several variables
    with any combination of bounds, equality and inequality constraints. The method
    wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft
    [[12]](#rdd2e1855725e-12). Note that the wrapper handles infinite values in bounds
    by converting them into large floating values.
  prefs: []
  type: TYPE_NORMAL
- en: Method [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    is a trust-region algorithm for constrained optimization. It switches between
    two implementations depending on the problem definition. It is the most versatile
    constrained minimization algorithm implemented in SciPy and the most appropriate
    for large-scale problems. For equality constrained problems it is an implementation
    of Byrd-Omojokun Trust-Region SQP method described in [[17]](#rdd2e1855725e-17)
    and in [[5]](#rdd2e1855725e-5), p. 549\. When inequality constraints are imposed
    as well, it switches to the trust-region interior point method described in [[16]](#rdd2e1855725e-16).
    This interior point algorithm, in turn, solves inequality constraints by introducing
    slack variables and solving a sequence of equality-constrained barrier problems
    for progressively smaller values of the barrier parameter. The previously described
    equality constrained SQP method is used to solve the subproblems with increasing
    levels of accuracy as the iterate gets closer to a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finite-Difference Options**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Method [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    the gradient and the Hessian may be approximated using three finite-difference
    schemes: {‘2-point’, ‘3-point’, ‘cs’}. The scheme ‘cs’ is, potentially, the most
    accurate but it requires the function to correctly handle complex inputs and to
    be differentiable in the complex plane. The scheme ‘3-point’ is more accurate
    than ‘2-point’ but requires twice as many operations. If the gradient is estimated
    via finite-differences the Hessian must be estimated using one of the quasi-Newton
    strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method specific options for the** *hess* **keyword**'
  prefs: []
  type: TYPE_NORMAL
- en: '| method/Hess | None | callable | ‘2-point/’3-point’/’cs’ | HUS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Newton-CG | x | (n, n) LO | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| dogleg |  | (n, n) |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| trust-ncg |  | (n, n) | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| trust-krylov |  | (n, n) | x | x |'
  prefs: []
  type: TYPE_TB
- en: '| trust-exact |  | (n, n) |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| trust-constr | x | (n, n) LO sp | x | x |'
  prefs: []
  type: TYPE_TB
- en: where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom minimizers**'
  prefs: []
  type: TYPE_NORMAL
- en: It may be useful to pass a custom minimization method, for example when using
    a frontend to this method such as [`scipy.optimize.basinhopping`](scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping") or a different library. You can simply pass a callable
    as the `method` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The callable is called as `method(fun, x0, args, **kwargs, **options)` where
    `kwargs` corresponds to any other parameters passed to [`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize") (such as *callback*, *hess*, etc.), except the *options*
    dict, which has its contents also passed as *method* parameters pair by pair.
    Also, if *jac* has been passed as a bool type, *jac* and *fun* are mangled so
    that *fun* returns just the function values and *jac* is converted to a function
    returning the Jacobian. The method shall return an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") object.
  prefs: []
  type: TYPE_NORMAL
- en: The provided *method* callable must be able to accept (and possibly ignore)
    arbitrary parameters; the set of parameters accepted by [`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize") may expand in future versions and then these parameters
    will be passed to the method. You can find an example in the scipy.optimize tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nelder, J A, and R Mead. 1965\. A Simplex Method for Function Minimization.
    The Computer Journal 7: 308-13.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wright M H. 1996\. Direct search methods: Once scorned, now respectable, in
    Numerical Analysis 1995: Proceedings of the 1995 Dundee Biennial Conference in
    Numerical Analysis (Eds. D F Griffiths and G A Watson). Addison Wesley Longman,
    Harlow, UK. 191-208.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Powell, M J D. 1964\. An efficient method for finding the minimum of a function
    of several variables without calculating derivatives. The Computer Journal 7:
    155-162.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[4](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: Press W, S A Teukolsky, W T Vetterling and B P Flannery. Numerical Recipes (any
    edition), Cambridge University Press.
  prefs: []
  type: TYPE_NORMAL
- en: '[5] ([1](#id1),[2](#id2),[3](#id3),[4](#id4),[5](#id5),[6](#id15),[7](#id22),[8](#id41))'
  prefs: []
  type: TYPE_NORMAL
- en: Nocedal, J, and S J Wright. 2006\. Numerical Optimization. Springer New York.
  prefs: []
  type: TYPE_NORMAL
- en: '[[6](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Byrd, R H and P Lu and J. Nocedal. 1995\. A Limited Memory Algorithm for Bound
    Constrained Optimization. SIAM Journal on Scientific and Statistical Computing
    16 (5): 1190-1208.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[7](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Zhu, C and R H Byrd and J Nocedal. 1997\. L-BFGS-B: Algorithm 778: L-BFGS-B,
    FORTRAN routines for large scale bound constrained optimization. ACM Transactions
    on Mathematical Software 23 (4): 550-560.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[8](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nash, S G. Newton-Type Minimization Via the Lanczos Method. 1984\. SIAM Journal
    of Numerical Analysis 21: 770-778.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[9](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: Powell, M J D. A direct search optimization method that models the objective
    and constraint functions by linear interpolation. 1994\. Advances in Optimization
    and Numerical Analysis, eds. S. Gomez and J-P Hennart, Kluwer Academic (Dordrecht),
    51-67.
  prefs: []
  type: TYPE_NORMAL
- en: '[[10](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Powell M J D. Direct search algorithms for optimization calculations. 1998\.
    Acta Numerica 7: 287-336.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[11](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: Powell M J D. A view of algorithms for optimization without derivatives. 2007.Cambridge
    University Technical Report DAMTP 2007/NA03
  prefs: []
  type: TYPE_NORMAL
- en: '[[12](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: Kraft, D. A software package for sequential quadratic programming. 1988\. Tech.
    Rep. DFVLR-FB 88-28, DLR German Aerospace Center – Institute for Flight Mechanics,
    Koln, Germany.
  prefs: []
  type: TYPE_NORMAL
- en: '[[13](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: Conn, A. R., Gould, N. I., and Toint, P. L. Trust region methods. 2000\. Siam.
    pp. 169-200.
  prefs: []
  type: TYPE_NORMAL
- en: '[[14](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'F. Lenders, C. Kirches, A. Potschka: “trlib: A vector-free implementation of
    the GLTR method for iterative solution of the trust region problem”, [arXiv:1611.04718](https://arxiv.org/abs/1611.04718)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[15](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'N. Gould, S. Lucidi, M. Roma, P. Toint: “Solving the Trust-Region Subproblem
    using the Lanczos Method”, SIAM J. Optim., 9(2), 504–525, (1999).'
  prefs: []
  type: TYPE_NORMAL
- en: '[[16](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999. An interior point
    algorithm for large-scale nonlinear programming. SIAM Journal on Optimization
    9.4: 877-900.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[17](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998\. On the implementation
    of an algorithm for large-scale equality constrained optimization. SIAM Journal
    on Optimization 8.3: 682-706.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider the problem of minimizing the Rosenbrock function. This function
    (and its respective derivatives) is implemented in [`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen
    "scipy.optimize.rosen") (resp. [`rosen_der`](scipy.optimize.rosen_der.html#scipy.optimize.rosen_der
    "scipy.optimize.rosen_der"), [`rosen_hess`](scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess
    "scipy.optimize.rosen_hess")) in the [`scipy.optimize`](../optimize.html#module-scipy.optimize
    "scipy.optimize").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple application of the *Nelder-Mead* method is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now using the *BFGS* algorithm, using the first derivative and a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, consider a minimization problem with several constraints (namely Example
    16.4 from [[5]](#rdd2e1855725e-5)). The objective function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three constraints defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And variables must be positive, hence the following bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The optimization problem is solved using the SLSQP method as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It should converge to the theoretical solution (1.4 ,1.7).
  prefs: []
  type: TYPE_NORMAL
