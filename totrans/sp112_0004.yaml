- en: Integration (scipy.integrate)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The [`scipy.integrate`](../reference/integrate.html#module-scipy.integrate
    "scipy.integrate") sub-package provides several integration techniques including
    an ordinary differential equation integrator. An overview of the module is provided
    by the help command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: General integration ([`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"))
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") is provided to integrate a function of one variable between
    two points. The points can be \(\pm\infty\) (\(\pm\) `inf`) to indicate infinite
    limits. For example, suppose you wish to integrate a bessel function `jv(2.5,
    x)` along the interval \([0, 4.5].\)
  prefs: []
  type: TYPE_NORMAL
- en: \[I=\int_{0}^{4.5}J_{2.5}\left(x\right)\, dx.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be computed using [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to quad is a “callable” Python object (i.e., a function,
    method, or class instance). Notice the use of a lambda- function in this case
    as the argument. The next two arguments are the limits of integration. The return
    value is a tuple, with the first element holding the estimated value of the integral
    and the second element holding an estimate of the absolute integration error.
    Notice, that in this case, the true value of this integral is
  prefs: []
  type: TYPE_NORMAL
- en: \[I=\sqrt{\frac{2}{\pi}}\left(\frac{18}{27}\sqrt{2}\cos\left(4.5\right)-\frac{4}{27}\sqrt{2}\sin\left(4.5\right)+\sqrt{2\pi}\textrm{Si}\left(\frac{3}{\sqrt{\pi}}\right)\right),\]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: \[\textrm{Si}\left(x\right)=\int_{0}^{x}\sin\left(\frac{\pi}{2}t^{2}\right)\,
    dt.\]
  prefs: []
  type: TYPE_NORMAL
- en: is the Fresnel sine integral. Note that the numerically-computed integral is
    within \(1.04\times10^{-11}\) of the exact result — well below the reported error
    estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the function to integrate takes additional parameters, they can be provided
    in the *args* argument. Suppose that the following integral shall be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: \[I(a,b)=\int_{0}^{1} ax^2+b \, dx.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'This integral can be evaluated by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Infinite inputs are also allowed in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") by using \(\pm\) `inf` as one of the arguments. For example,
    suppose that a numerical value for the exponential integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[E_{n}\left(x\right)=\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'is desired (and the fact that this integral can be computed as `special.expn(n,x)`
    is forgotten). The functionality of the function [`special.expn`](../reference/generated/scipy.special.expn.html#scipy.special.expn
    "scipy.special.expn") can be replicated by defining a new function `vec_expint`
    based on the routine [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function which is integrated can even use the quad argument (though the
    error bound may underestimate the error due to possible numerical error in the
    integrand from the use of [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") ). The integral in this case is
  prefs: []
  type: TYPE_NORMAL
- en: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}.\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This last example shows that multiple integration can be handled using repeated
    calls to [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad").
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerical integration algorithms sample the integrand at a finite number of
    points. Consequently, they cannot guarantee accurate results (or accuracy estimates)
    for arbitrary integrands and limits of integration. Consider the Gaussian integral,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the integrand is nearly zero except near the origin, we would expect
    large but finite limits of integration to yield the same result. However:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This happens because the adaptive quadrature routine implemented in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"), while working as designed, does not notice the small,
    important part of the function within such a large, finite interval. For best
    results, consider using integration limits that tightly surround the important
    part of the integrand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Integrands with several important regions can be broken into pieces as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: General multiple integration ([`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad"), [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad"), [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"))
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mechanics for double and triple integration have been wrapped up into the
    functions [`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad") and [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad"). These functions take the function to integrate and
    four, or six arguments, respectively. The limits of all inner integrals need to
    be defined as functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using double integration to compute several values of \(I_{n}\)
    is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As example for non-constant limits consider the integral
  prefs: []
  type: TYPE_NORMAL
- en: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'This integral can be evaluated using the expression below (Note the use of
    the non-constant lambda functions for the upper limit of the inner integral):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For n-fold integration, scipy provides the function [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"). The integration bounds are an iterable object: either
    a list of constant bounds, or a list of functions for the non-constant integration
    bounds. The order of integration (and therefore the bounds) is from the innermost
    integral to the outermost one.'
  prefs: []
  type: TYPE_NORMAL
- en: The integral from above
  prefs: []
  type: TYPE_NORMAL
- en: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: can be calculated as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of arguments for *f* must match the order of the integration
    bounds; i.e., the inner integral with respect to \(t\) is on the interval \([1,
    \infty]\) and the outer integral with respect to \(x\) is on the interval \([0,
    \infty]\).
  prefs: []
  type: TYPE_NORMAL
- en: Non-constant integration bounds can be treated in a similar manner; the example
    from above
  prefs: []
  type: TYPE_NORMAL
- en: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
  prefs: []
  type: TYPE_NORMAL
- en: can be evaluated by means of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: which is the same result as before.
  prefs: []
  type: TYPE_NORMAL
- en: Gaussian quadrature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few functions are also provided in order to perform simple Gaussian quadrature
    over a fixed interval. The first is [`fixed_quad`](../reference/generated/scipy.integrate.fixed_quad.html#scipy.integrate.fixed_quad
    "scipy.integrate.fixed_quad"), which performs fixed-order Gaussian quadrature.
    The second function is [`quadrature`](../reference/generated/scipy.integrate.quadrature.html#scipy.integrate.quadrature
    "scipy.integrate.quadrature"), which performs Gaussian quadrature of multiple
    orders until the difference in the integral estimate is beneath some tolerance
    supplied by the user. These functions both use the module `scipy.special.orthogonal`,
    which can calculate the roots and quadrature weights of a large variety of orthogonal
    polynomials (the polynomials themselves are available as special functions returning
    instances of the polynomial class — e.g., [`special.legendre`](../reference/generated/scipy.special.legendre.html#scipy.special.legendre
    "scipy.special.legendre")).
  prefs: []
  type: TYPE_NORMAL
- en: Romberg Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Romberg’s method [[WPR]](#wpr) is another method for numerically evaluating
    an integral. See the help function for [`romberg`](../reference/generated/scipy.integrate.romberg.html#scipy.integrate.romberg
    "scipy.integrate.romberg") for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating using Samples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the samples are equally-spaced and the number of samples available is \(2^{k}+1\)
    for some integer \(k\), then Romberg [`romb`](../reference/generated/scipy.integrate.romb.html#scipy.integrate.romb
    "scipy.integrate.romb") integration can be used to obtain high-precision estimates
    of the integral using the available samples. Romberg integration uses the trapezoid
    rule at step-sizes related by a power of two and then performs Richardson extrapolation
    on these estimates to approximate the integral with a higher degree of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: In case of arbitrary spaced samples, the two functions [`trapezoid`](../reference/generated/scipy.integrate.trapezoid.html#scipy.integrate.trapezoid
    "scipy.integrate.trapezoid") and [`simpson`](../reference/generated/scipy.integrate.simpson.html#scipy.integrate.simpson
    "scipy.integrate.simpson") are available. They are using Newton-Coates formulas
    of order 1 and 2 respectively to perform integration. The trapezoidal rule approximates
    the function as a straight line between adjacent points, while Simpson’s rule
    approximates the function between three adjacent points as a parabola.
  prefs: []
  type: TYPE_NORMAL
- en: For an odd number of samples that are equally spaced Simpson’s rule is exact
    if the function is a polynomial of order 3 or less. If the samples are not equally
    spaced, then the result is exact only if the function is a polynomial of order
    2 or less.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds exactly to
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{1}^{4} x^2 \, dx = 21,\]
  prefs: []
  type: TYPE_NORMAL
- en: whereas integrating the second function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: does not correspond to
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{1}^{4} x^3 \, dx = 63.75\]
  prefs: []
  type: TYPE_NORMAL
- en: because the order of the polynomial in f2 is larger than two.
  prefs: []
  type: TYPE_NORMAL
- en: '## Faster integration using low-level callback functions'
  prefs: []
  type: TYPE_NORMAL
- en: A user desiring reduced integration times may pass a C function pointer through
    [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") to [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"), [`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad"), [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad") or [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad") and it will be integrated and return a result in Python.
    The performance increase here arises from two factors. The primary improvement
    is faster function evaluation, which is provided by compilation of the function
    itself. Additionally we have a speedup provided by the removal of function calls
    between C and Python in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"). This method may provide a speed improvements of ~2x for
    trivial functions such as sine but can produce a much more noticeable improvements
    (10x+) for more complex functions. This feature then, is geared towards a user
    with numerically intensive integrations willing to write a little C to reduce
    computation time significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach can be used, for example, via [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)") in a few simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.) Write an integrand function in C with the function signature `double f(int
    n, double *x, void *user_data)`, where `x` is an array containing the point the
    function f is evaluated at, and `user_data` to arbitrary additional data you want
    to provide.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '2.) Now compile this file to a shared/dynamic library (a quick search will
    help with this as it is OS-dependent). The user must link any math libraries,
    etc., used. On linux this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output library will be referred to as `testlib.so`, but it may have a different
    file extension. A library has now been created that can be loaded into Python
    with [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "(in
    Python v3.12)").
  prefs: []
  type: TYPE_NORMAL
- en: '3.) Load shared library into Python using [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)") and set `restypes` and `argtypes` - this allows SciPy to
    interpret the function correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The last `void *user_data` in the function is optional and can be omitted (both
    in the C function and ctypes argtypes) if not needed. Note that the coordinates
    are passed in as an array of doubles rather than a separate argument.
  prefs: []
  type: TYPE_NORMAL
- en: '4.) Now integrate the library function as normally, here using [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Python tuple is returned as expected in a reduced amount of time. All optional
    parameters can be used with this method including specifying singularities, infinite
    bounds, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary differential equations ([`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"))
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integrating a set of ordinary differential equations (ODEs) given initial conditions
    is another useful example. The function [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") is available in SciPy for integrating a first-order
    vector differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{d\mathbf{y}}{dt}=\mathbf{f}\left(\mathbf{y},t\right),\]
  prefs: []
  type: TYPE_NORMAL
- en: given initial conditions \(\mathbf{y}\left(0\right)=y_{0}\), where \(\mathbf{y}\)
    is a length \(N\) vector and \(\mathbf{f}\) is a mapping from \(\mathcal{R}^{N}\)
    to \(\mathcal{R}^{N}.\) A higher-order ordinary differential equation can always
    be reduced to a differential equation of this type by introducing intermediate
    derivatives into the \(\mathbf{y}\) vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose it is desired to find the solution to the following second-order
    differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{d^{2}w}{dz^{2}}-zw(z)=0\]
  prefs: []
  type: TYPE_NORMAL
- en: with initial conditions \(w\left(0\right)=\frac{1}{\sqrt[3]{3^{2}}\Gamma\left(\frac{2}{3}\right)}\)
    and \(\left.\frac{dw}{dz}\right|_{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma\left(\frac{1}{3}\right)}.\)
    It is known that the solution to this differential equation with these boundary
    conditions is the Airy function
  prefs: []
  type: TYPE_NORMAL
- en: \[w=\textrm{Ai}\left(z\right),\]
  prefs: []
  type: TYPE_NORMAL
- en: which gives a means to check the integrator using [`special.airy`](../reference/generated/scipy.special.airy.html#scipy.special.airy
    "scipy.special.airy").
  prefs: []
  type: TYPE_NORMAL
- en: First, convert this ODE into standard form by setting \(\mathbf{y}=\left[\frac{dw}{dz},w\right]\)
    and \(t=z\). Thus, the differential equation becomes
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\frac{d\mathbf{y}}{dt}=\left[\begin{array}{c} ty_{1}\\ y_{0}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\left[\begin{array}{c} y_{0}\\ y_{1}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\mathbf{y}.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: In other words,
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{f}\left(\mathbf{y},t\right)=\mathbf{A}\left(t\right)\mathbf{y}.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'As an interesting reminder, if \(\mathbf{A}\left(t\right)\) commutes with \(\int_{0}^{t}\mathbf{A}\left(\tau\right)\,
    d\tau\) under matrix multiplication, then this linear differential equation has
    an exact solution using the matrix exponential:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{y}\left(t\right)=\exp\left(\int_{0}^{t}\mathbf{A}\left(\tau\right)d\tau\right)\mathbf{y}\left(0\right),\]
  prefs: []
  type: TYPE_NORMAL
- en: However, in this case, \(\mathbf{A}\left(t\right)\) and its integral do not
    commute.
  prefs: []
  type: TYPE_NORMAL
- en: This differential equation can be solved using the function [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"). It requires the derivative, *fprime*, the time span
    *[t_start, t_end]* and the initial conditions vector, *y0*, as input arguments
    and returns an object whose *y* field is an array with consecutive solution values
    as columns. The initial conditions are therefore given in the first output column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As it can be seen [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") determines its time steps automatically if not specified
    otherwise. To compare the solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") with the *airy* function the time vector created
    by [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") is passed to the *airy* function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") with its standard parameters shows a big deviation
    to the airy function. To minimize this deviation, relative and absolute tolerances
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To specify user defined time points for the solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"), [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") offers two possibilities that can also be used complementarily.
    By passing the *t_eval* option to the function call [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") returns the solutions of these time points of *t_eval*
    in its output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the jacobian matrix of function is known, it can be passed to the [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") to achieve better results. Please be aware however
    that the default integration method [`RK45`](../reference/generated/scipy.integrate.RK45.html#scipy.integrate.RK45
    "scipy.integrate.RK45") does not support jacobian matrices and thereby another
    integration method has to be chosen. One of the integration methods that support
    a jacobian matrix is the for example the [`Radau`](../reference/generated/scipy.integrate.Radau.html#scipy.integrate.Radau
    "scipy.integrate.Radau") method of following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Solving a system with a banded Jacobian matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") can be told that the Jacobian is *banded*. For a large
    system of differential equations that are known to be stiff, this can improve
    performance significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll solve the 1-D Gray-Scott partial differential equations
    using the method of lines [[MOL]](#mol). The Gray-Scott equations for the functions
    \(u(x, t)\) and \(v(x, t)\) on the interval \(x \in [0, L]\) are
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{split} \frac{\partial u}{\partial t} = D_u \frac{\partial^2
    u}{\partial x^2} - uv^2 + f(1-u) \\ \frac{\partial v}{\partial t} = D_v \frac{\partial^2
    v}{\partial x^2} + uv^2 - (f + k)v \\ \end{split}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(D_u\) and \(D_v\) are the diffusion coefficients of the components \(u\)
    and \(v\), respectively, and \(f\) and \(k\) are constants. (For more information
    about the system, see [http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/](http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/))
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll assume Neumann (i.e., “no flux”) boundary conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial u}{\partial x}(0,t) = 0, \quad \frac{\partial v}{\partial x}(0,t)
    = 0, \quad \frac{\partial u}{\partial x}(L,t) = 0, \quad \frac{\partial v}{\partial
    x}(L,t) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: To apply the method of lines, we discretize the \(x\) variable by defining the
    uniformly spaced grid of \(N\) points \(\left\{x_0, x_1, \ldots, x_{N-1}\right\}\),
    with \(x_0 = 0\) and \(x_{N-1} = L\). We define \(u_j(t) \equiv u(x_k, t)\) and
    \(v_j(t) \equiv v(x_k, t)\), and replace the \(x\) derivatives with finite differences.
    That is,
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial^2 u}{\partial x^2}(x_j, t) \rightarrow \frac{u_{j-1}(t) - 2
    u_{j}(t) + u_{j+1}(t)}{(\Delta x)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have a system of \(2N\) ordinary differential equations:'
  prefs: []
  type: TYPE_NORMAL
- en: (1)\[\begin{split} \begin{split} \frac{du_j}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(u_{j-1} - 2 u_{j} + u_{j+1}\right) -u_jv_j^2 + f(1 - u_j) \\ \frac{dv_j}{dt}
    = \frac{D_v}{(\Delta x)^2} \left(v_{j-1} - 2 v_{j} + v_{j+1}\right) + u_jv_j^2
    - (f + k)v_j \end{split}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, the \((t)\) arguments have been dropped.
  prefs: []
  type: TYPE_NORMAL
- en: To enforce the boundary conditions, we introduce “ghost” points \(x_{-1}\) and
    \(x_N\), and define \(u_{-1}(t) \equiv u_1(t)\), \(u_N(t) \equiv u_{N-2}(t)\);
    \(v_{-1}(t)\) and \(v_N(t)\) are defined analogously.
  prefs: []
  type: TYPE_NORMAL
- en: Then
  prefs: []
  type: TYPE_NORMAL
- en: (2)\[\begin{split} \begin{split} \frac{du_0}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(2u_{1} - 2 u_{0}\right) -u_0v_0^2 + f(1 - u_0) \\ \frac{dv_0}{dt} = \frac{D_v}{(\Delta
    x)^2} \left(2v_{1} - 2 v_{0}\right) + u_0v_0^2 - (f + k)v_0 \end{split}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: (3)\[\begin{split} \begin{split} \frac{du_{N-1}}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(2u_{N-2} - 2 u_{N-1}\right) -u_{N-1}v_{N-1}^2 + f(1 - u_{N-1}) \\ \frac{dv_{N-1}}{dt}
    = \frac{D_v}{(\Delta x)^2} \left(2v_{N-2} - 2 v_{N-1}\right) + u_{N-1}v_{N-1}^2
    - (f + k)v_{N-1} \end{split}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Our complete system of \(2N\) ordinary differential equations is [(1)](#equation-interior)
    for \(k = 1, 2, \ldots, N-2\), along with [(2)](#equation-boundary0) and [(3)](#equation-boundaryl).
  prefs: []
  type: TYPE_NORMAL
- en: We can now starting implementing this system in code. We must combine \(\{u_k\}\)
    and \(\{v_k\}\) into a single vector of length \(2N\). The two obvious choices
    are \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots, v_{N-1}\}\) and \(\{u_0,
    v_0, u_1, v_1, \ldots, u_{N-1}, v_{N-1}\}\). Mathematically, it does not matter,
    but the choice affects how efficiently [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") can solve the system. The reason is in how the order
    affects the pattern of the nonzero elements of the Jacobian matrix.
  prefs: []
  type: TYPE_NORMAL
- en: When the variables are ordered as \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots,
    v_{N-1}\}\), the pattern of nonzero elements of the Jacobian matrix is
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{smallmatrix} * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 \\ 0 & *
    & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 \\ 0 & 0 & * & * & * & 0 & 0 &
    0 & 0 & 0 & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0
    & 0 \\ 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 \\ 0 & 0 & 0 & 0
    & 0 & * & * & 0 & 0 & 0 & 0 & 0 & 0 & * \\ * & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    0 & 0 & 0 & 0 & 0 \\ 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 \\
    0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & 0 & 0
    & 0 & 0 & 0 & * & * & * & 0 & 0 \\ 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * &
    * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & ) & * & * \\ \end{smallmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: The Jacobian pattern with variables interleaved as \(\{u_0, v_0, u_1, v_1, \ldots,
    u_{N-1}, v_{N-1}\}\) is
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{smallmatrix} * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ * & 0
    & * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & * & * & * & 0 & * & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & 0
    & 0 \\ 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0
    & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & * & * & * & 0 &
    * & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & * & 0 & * & * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    * & 0 & * \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * \\ \end{smallmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, there are just five nontrivial diagonals, but when the variables
    are interleaved, the bandwidth is much smaller. That is, the main diagonal and
    the two diagonals immediately above and the two immediately below the main diagonal
    are the nonzero diagonals. This is important, because the inputs `mu` and `ml`
    of [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") are the upper and lower bandwidths of the Jacobian matrix.
    When the variables are interleaved, `mu` and `ml` are 2\. When the variables are
    stacked with \(\{v_k\}\) following \(\{u_k\}\), the upper and lower bandwidths
    are \(N\).
  prefs: []
  type: TYPE_NORMAL
- en: With that decision made, we can write the function that implements the system
    of differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the functions for the source and reaction terms of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the function that computes the right-hand side of the system
    of differential equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We won’t implement a function to compute the Jacobian, but we will tell [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") that the Jacobian matrix is banded. This allows the
    underlying solver (LSODA) to avoid computing values that it knows are zero. For
    a large system, this improves the performance significantly, as demonstrated in
    the following ipython session.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the required inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Time the computation without taking advantage of the banded structure of the
    Jacobian matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now set `ml=2` and `mu=2`, so [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") knows that the Jacobian matrix is banded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That is quite a bit faster!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ensure that they have computed the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[[WPR](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Romberg’s_method](https://en.wikipedia.org/wiki/Romberg''s_method)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[MOL](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Method_of_lines](https://en.wikipedia.org/wiki/Method_of_lines)'
  prefs: []
  type: TYPE_NORMAL
