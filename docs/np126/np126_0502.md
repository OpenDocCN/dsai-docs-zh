# numpy.fft.irfft

> 原文：[`numpy.org/doc/1.26/reference/generated/numpy.fft.irfft.html`](https://numpy.org/doc/1.26/reference/generated/numpy.fft.irfft.html)

```py
fft.irfft(a, n=None, axis=-1, norm=None)
```

计算`rfft`的逆。

此函数计算实输入的一维*n*点离散傅立叶变换的逆，该变换由`rfft`计算。换句话说，`irfft(rfft(a), len(a)) == a`在数值精度内成立。(请参阅下面的注意事项，了解为什么在此处需要`len(a)`。)

预期输入的形式为由`rfft`返回的，即实零频项，后跟按频率递增顺序的复正频率项。由于实输入的离散傅立叶变换是 Hermitian 对称的，因此负频率项被视为相应正频率项的复共轭。

参数:

**a**array_like

输入数组。

**n**int, 可选的

输出的变换轴的长度。对于*n*个输出点，需要`n//2+1`个输入点。如果输入比这更长，将被裁剪。如果短于此，则填充为零。如果未给出*n*，则将其视为`2*(m-1)`，其中`m`是由*axis*指定的轴上的输入长度。

**axis**int, 可选的

计算逆 FFT 的轴。如果不给定，则使用最后一个轴。

**norm**{“backward”, “ortho”, “forward”}, 可选的

1.10.0 版本中新增。

标准化模式(参见`numpy.fft`)。默认为“backward”。指示哪个方向的前向/后向变换配对被缩放，并具有什么标准化因子。

1.20.0 版本中新增: 添加了“backward”、“forward”值。

返回:

**out**ndarray

截断或零填充的输入，沿由*axis*指示的轴变换，或者如果未指定*axis*，则使用最后一个轴。变换后轴的长度为*n*，或者如果未给出*n*，则为`2*(m-1)`，其中`m`为输入的变换后轴的长度。要获得奇数个输出点，必须指定*n*。

引发:

IndexError

如果*axis*不是*a*的有效轴。

另请参见

`numpy.fft`

用于 DFT 的定义和约定。

`rfft`

实输入的一维 FFT，其中`irfft`是逆。

`fft`

一维 FFT。

`irfft2`

实输入的二维 FFT 的逆。

`irfftn`

实输入的*n*维 FFT 的逆。

注意

返回*a*的实值*n*点逆离散傅立叶变换，其中*a*包含共轭对称序列的非负频率项。*n*是结果的长度，而不是输入的长度。

如果指定一个*n*，使得*a*必须进行零填充或截断，额外/删除的值将被添加/删除在高频率。因此，可以通过傅里叶插值对一个系列进行* m*点重新采样：`a_resamp = irfft(rfft(a), m)`。

正确解释共轭输入取决于原始数据的长度，即*n*给出的长度。这是因为每个输入形状可能对应奇数或偶数长度的信号。默认情况下，`irfft`假设输出长度为偶数，将最后一个条目放在奈奎斯特频率上；与其对称的频率重复。根据共轭对称性，因此该值被视为纯实数。为了避免丢失信息，必须给出实际输入的正确长度。

示例

```py
>>> np.fft.ifft([1, -1j, -1, 1j])
array([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary
>>> np.fft.irfft([1, -1j, -1])
array([0.,  1.,  0.,  0.]) 
```

注意普通`ifft`输入中的最后一项是第二项的复共轭，并且输出在任何地方都没有虚部。调用`irfft`时，未指定负频率，输出数组纯粹是实数。
