- en: scipy.linalg.solve_circulant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_circulant.html#scipy.linalg.solve_circulant](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_circulant.html#scipy.linalg.solve_circulant)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solve C x = b for x, where C is a circulant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '*C* is the circulant matrix associated with the vector *c*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system is solved by doing division in Fourier space. The calculation is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where *fft* and *ifft* are the fast Fourier transform and its inverse, respectively.
    For a large vector *c*, this is *much* faster than solving the system with the
    full circulant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**c**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The coefficients of the circulant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**b**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Right-hand side matrix in `a x = b`.
  prefs: []
  type: TYPE_NORMAL
- en: '**singular**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: This argument controls how a near singular circulant matrix is handled. If *singular*
    is “raise” and the circulant matrix is near singular, a [`LinAlgError`](scipy.linalg.LinAlgError.html#scipy.linalg.LinAlgError
    "scipy.linalg.LinAlgError") is raised. If *singular* is “lstsq”, the least squares
    solution is returned. Default is “raise”.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If any eigenvalue of the circulant matrix has an absolute value that is less
    than or equal to *tol*, the matrix is considered to be near singular. If not given,
    *tol* is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: where *abs_eigs* is the array of absolute values of the eigenvalues of the circulant
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**caxis**int'
  prefs: []
  type: TYPE_NORMAL
- en: When *c* has dimension greater than 1, it is viewed as a collection of circulant
    vectors. In this case, *caxis* is the axis of *c* that holds the vectors of circulant
    coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: '**baxis**int'
  prefs: []
  type: TYPE_NORMAL
- en: When *b* has dimension greater than 1, it is viewed as a collection of vectors.
    In this case, *baxis* is the axis of *b* that holds the right-hand side vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '**outaxis**int'
  prefs: []
  type: TYPE_NORMAL
- en: When *c* or *b* are multidimensional, the value returned by [`solve_circulant`](#scipy.linalg.solve_circulant
    "scipy.linalg.solve_circulant") is multidimensional. In this case, *outaxis* is
    the axis of the result that holds the solution vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the system `C x = b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: If the circulant matrix associated with *c* is near singular.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`circulant`](scipy.linalg.circulant.html#scipy.linalg.circulant "scipy.linalg.circulant")'
  prefs: []
  type: TYPE_NORMAL
- en: circulant matrix
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For a 1-D vector *c* with length *m*, and an array *b* with shape `(m, ...)`,
  prefs: []
  type: TYPE_NORMAL
- en: solve_circulant(c, b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: returns the same result as
  prefs: []
  type: TYPE_NORMAL
- en: solve(circulant(c), b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where [`solve`](scipy.linalg.solve.html#scipy.linalg.solve "scipy.linalg.solve")
    and [`circulant`](scipy.linalg.circulant.html#scipy.linalg.circulant "scipy.linalg.circulant")
    are from [`scipy.linalg`](../linalg.html#module-scipy.linalg "scipy.linalg").
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.16.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that result to solving the system with [`scipy.linalg.solve`](scipy.linalg.solve.html#scipy.linalg.solve
    "scipy.linalg.solve"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A singular example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `solve_circulant(c, b)` will raise a [`LinAlgError`](scipy.linalg.LinAlgError.html#scipy.linalg.LinAlgError
    "scipy.linalg.LinAlgError"). For the least square solution, use the option `singular=''lstsq''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare to [`scipy.linalg.lstsq`](scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A broadcasting example:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have the vectors of two circulant matrices stored in an array with
    shape (2, 5), and three *b* vectors stored in an array with shape (3, 5). For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to solve all combinations of circulant matrices and *b* vectors, with
    the result stored in an array with shape (2, 3, 5). When we disregard the axes
    of *c* and *b* that hold the vectors of coefficients, the shapes of the collections
    are (2,) and (3,), respectively, which are not compatible for broadcasting. To
    have a broadcast result with shape (2, 3), we add a trivial dimension to *c*:
    `c[:, np.newaxis, :]` has shape (2, 1, 5). The last dimension holds the coefficients
    of the circulant matrices, so when we call [`solve_circulant`](#scipy.linalg.solve_circulant
    "scipy.linalg.solve_circulant"), we can use the default `caxis=-1`. The coefficients
    of the *b* vectors are in the last dimension of the array *b*, so we use `baxis=-1`.
    If we use the default *outaxis*, the result will have shape (5, 2, 3), so we’ll
    use `outaxis=-1` to put the solution vectors in the last dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Check by solving one pair of *c* and *b* vectors (cf. `x[1, 1, :]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
