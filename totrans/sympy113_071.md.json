["```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> len(PcGroup.pcgs)\n4\n>>> pc_series = PcGroup.pc_series\n>>> pc_series[0].equals(G)  # use equals, not literal `==`\nTrue\n>>> gen = pc_series[len(pc_series) - 1].generators[0]\n>>> gen.is_identity\nTrue\n>>> PcGroup.relative_order\n[2, 3, 2, 2] \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> G = SymmetricGroup(3)\n>>> PcGroup = G.polycyclic_group()\n>>> Collector = PcGroup.collector\n>>> Collector.free_group\n<free group on the generators (x0, x1)>\n>>> Collector.pc_presentation\n{x0**2: (), x1**3: (), x0**-1*x1*x0: x1**2} \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> from sympy.combinatorics.free_groups import free_group\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> F, x1, x2 = free_group(\"x1, x2\")\n>>> word = x2**2*x1**7\n>>> collector.minimal_uncollected_subword(word)\n((x2, 2),) \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> from sympy.combinatorics.free_groups import free_group\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> F, x1, x2 = free_group(\"x1, x2\")\n>>> word = x2**2*x1**7\n>>> w = x2**2*x1\n>>> collector.subword_index(word, w)\n(0, 3)\n>>> w = x1**7\n>>> collector.subword_index(word, w)\n(2, 9) \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> from sympy.combinatorics.perm_groups import PermutationGroup\n>>> from sympy.combinatorics.free_groups import free_group\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> F, x0, x1, x2, x3 = free_group(\"x0, x1, x2, x3\")\n>>> word = x3*x2*x1*x0\n>>> collected_word = collector.collected_word(word)\n>>> free_to_perm = {}\n>>> free_group = collector.free_group\n>>> for sym, gen in zip(free_group.symbols, collector.pcgs):\n...     free_to_perm[sym] = gen\n>>> G1 = PermutationGroup()\n>>> for w in word:\n...     sym = w[0]\n...     perm = free_to_perm[sym]\n...     G1 = PermutationGroup([perm] + G1.generators)\n>>> G2 = PermutationGroup()\n>>> for w in collected_word:\n...     sym = w[0]\n...     perm = free_to_perm[sym]\n...     G2 = PermutationGroup([perm] + G2.generators) \n```", "```py\n>>> G1 == G2\nFalse\n>>> G1.equals(G2)\nTrue \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> from sympy.combinatorics.permutations import Permutation\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> pcgs = PcGroup.pcgs\n>>> len(pcgs)\n4\n>>> free_group = collector.free_group\n>>> pc_resentation = collector.pc_presentation\n>>> free_to_perm = {}\n>>> for s, g in zip(free_group.symbols, pcgs):\n...     free_to_perm[s] = g\n>>> for k, v in pc_resentation.items():\n...     k_array = k.array_form\n...     if v != ():\n...        v_array = v.array_form\n...     lhs = Permutation()\n...     for gen in k_array:\n...         s = gen[0]\n...         e = gen[1]\n...         lhs = lhs*free_to_perm[s]**e\n...     if v == ():\n...         assert lhs.is_identity\n...         continue\n...     rhs = Permutation()\n...     for gen in v_array:\n...         s = gen[0]\n...         e = gen[1]\n...         rhs = rhs*free_to_perm[s]**e\n...     assert lhs == rhs \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> from sympy.combinatorics.permutations import Permutation\n>>> G = SymmetricGroup(4)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> pcgs = PcGroup.pcgs\n>>> collector.exponent_vector(G[0])\n[1, 0, 0, 0]\n>>> exp = collector.exponent_vector(G[1])\n>>> g = Permutation()\n>>> for i in range(len(exp)):\n...     g = g*pcgs[i]**exp[i] if exp[i] else g\n>>> assert g == G[1] \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> G = SymmetricGroup(3)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> collector.depth(G[0])\n2\n>>> collector.depth(G[1])\n1 \n```", "```py\n>>> from sympy.combinatorics.named_groups import SymmetricGroup\n>>> G = SymmetricGroup(3)\n>>> PcGroup = G.polycyclic_group()\n>>> collector = PcGroup.collector\n>>> collector.leading_exponent(G[1])\n1 \n```"]