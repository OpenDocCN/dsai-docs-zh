- en: scipy.optimize.NonlinearConstraint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Nonlinear constraint on the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constraint has the general inequality form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here the vector of independent variables x is passed as ndarray of shape (n,)
    and `fun` returns a vector with m components.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use equal bounds to represent an equality constraint or infinite
    bounds to represent a one-sided constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The function defining the constraint. The signature is `fun(x) -> array_like,
    shape (m,)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**lb, ub**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lower and upper bounds on the constraint. Each array must have the shape (m,)
    or be a scalar, in the latter case a bound will be the same for all components
    of the constraint. Use `np.inf` with an appropriate sign to specify a one-sided
    constraint. Set components of *lb* and *ub* equal to represent an equality constraint.
    Note that you can mix constraints of different types: interval, one-sided or equality,
    by setting different components of *lb* and *ub* as necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '**jac**{callable, ‘2-point’, ‘3-point’, ‘cs’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method of computing the Jacobian matrix (an m-by-n matrix, where element (i,
    j) is the partial derivative of f[i] with respect to x[j]). The keywords {‘2-point’,
    ‘3-point’, ‘cs’} select a finite difference scheme for the numerical estimation.
    A callable must have the following signature: `jac(x) -> {ndarray, sparse matrix},
    shape (m, n)`. Default is ‘2-point’.'
  prefs: []
  type: TYPE_NORMAL
- en: '**hess**{callable, ‘2-point’, ‘3-point’, ‘cs’, HessianUpdateStrategy, None},
    optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method for computing the Hessian matrix. The keywords {‘2-point’, ‘3-point’,
    ‘cs’} select a finite difference scheme for numerical estimation. Alternatively,
    objects implementing [`HessianUpdateStrategy`](scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") interface can be used to approximate the
    Hessian. Currently available implementations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`BFGS`](scipy.optimize.BFGS.html#scipy.optimize.BFGS "scipy.optimize.BFGS")
    (default option)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`SR1`](scipy.optimize.SR1.html#scipy.optimize.SR1 "scipy.optimize.SR1")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A callable must return the Hessian matrix of `dot(fun, v)` and must have the
    following signature: `hess(x, v) -> {LinearOperator, sparse matrix, array_like},
    shape (n, n)`. Here `v` is ndarray with shape (m,) containing Lagrange multipliers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**keep_feasible**array_like of bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to keep the constraint components feasible throughout iterations. A
    single value set this property for all components. Default is False. Has no effect
    for equality constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '**finite_diff_rel_step: None or array_like, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: Relative step size for the finite difference approximation. Default is None,
    which will select a reasonable value automatically depending on a finite difference
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '**finite_diff_jac_sparsity: {None, array_like, sparse matrix}, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the sparsity structure of the Jacobian matrix for finite difference
    estimation, its shape must be (m, n). If the Jacobian has only few non-zero elements
    in *each* row, providing the sparsity structure will greatly speed up the computations.
    A zero entry means that a corresponding element in the Jacobian is identically
    zero. If provided, forces the use of ‘lsmr’ trust-region solver. If None (default)
    then dense differencing will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Finite difference schemes {‘2-point’, ‘3-point’, ‘cs’} may be used for approximating
    either the Jacobian or the Hessian. We, however, do not allow its use for approximating
    both simultaneously. Hence whenever the Jacobian is estimated via finite-differences,
    we require the Hessian to be estimated using one of the quasi-Newton strategies.
  prefs: []
  type: TYPE_NORMAL
- en: The scheme ‘cs’ is potentially the most accurate, but requires the function
    to correctly handles complex inputs and be analytically continuable to the complex
    plane. The scheme ‘3-point’ is more accurate than ‘2-point’ but requires twice
    as many operations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Constrain `x[0] < sin(x[1]) + 1.9`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
