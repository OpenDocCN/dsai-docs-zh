["```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> v = 3*R.x + 4*R.y + 5*R.z \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> electric_potential = 2*R[0]**2*R[1]\n>>> electric_potential\n2*R_x**2*R_y \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> electric_potential = 2*R[0]**2*R[1]\n>>> from sympy import diff\n>>> diff(electric_potential, R[0])\n4*R_x*R_y \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> electric_potential = 2*R[0]**2*R[1]\n>>> from sympy.physics.vector import dynamicsymbols, express\n>>> q = dynamicsymbols('q')\n>>> R1 = R.orientnew('R1', rot_type = 'Axis', amounts = [q, R.z])\n>>> express(electric_potential, R1, variables=True)\n2*(R1_x*sin(q(t)) + R1_y*cos(q(t)))*(R1_x*cos(q(t)) - R1_y*sin(q(t)))**2 \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> electric_potential = 2*R[0]**2*R[1]\n>>> q = dynamicsymbols('q')\n>>> R1 = R.orientnew('R1', rot_type = 'Axis', amounts = [q, R.z])\n>>> from sympy.physics.vector import time_derivative\n>>> time_derivative(electric_potential, R)\n0\n>>> time_derivative(electric_potential, R1).simplify()\n2*(R1_x*cos(q(t)) - R1_y*sin(q(t)))*(3*R1_x**2*cos(2*q(t))/2 -\nR1_x**2/2 - 3*R1_x*R1_y*sin(2*q(t)) - 3*R1_y**2*cos(2*q(t))/2 -\nR1_y**2/2)*Derivative(q(t), t) \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> from sympy.physics.vector import curl\n>>> field = R[0]*R[1]*R[2]*R.x\n>>> curl(field, R)\nR_x*R_y*R.y - R_x*R_z*R.z \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> from sympy.physics.vector import divergence\n>>> field = R[0]*R[1]*R[2] * (R.x+R.y+R.z)\n>>> divergence(field, R)\nR_x*R_y + R_x*R_z + R_y*R_z \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame\n>>> R = ReferenceFrame('R')\n>>> from sympy.physics.vector import gradient\n>>> scalar_field = R[0]*R[1]*R[2]\n>>> gradient(scalar_field, R)\nR_y*R_z*R.x + R_x*R_z*R.y + R_x*R_y*R.z \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, is_conservative\n>>> R = ReferenceFrame('R')\n>>> field = R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z\n>>> is_conservative(field)\nTrue\n>>> curl(field, R)\n0 \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, is_solenoidal\n>>> R = ReferenceFrame('R')\n>>> field = R[1]*R[2]*R.x + R[0]*R[2]*R.y + R[0]*R[1]*R.z\n>>> is_solenoidal(field)\nTrue\n>>> divergence(field, R)\n0 \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, scalar_potential\n>>> R = ReferenceFrame('R')\n>>> conservative_field = 4*R[0]*R[1]*R[2]*R.x + 2*R[0]**2*R[2]*R.y + 2*R[0]**2*R[1]*R.z\n>>> scalar_potential(conservative_field, R)\n2*R_x**2*R_y*R_z \n```", "```py\n>>> from sympy.physics.vector import ReferenceFrame, Point\n>>> from sympy.physics.vector import scalar_potential_difference\n>>> R = ReferenceFrame('R')\n>>> O = Point('O')\n>>> P = O.locatenew('P', 1*R.x + 2*R.y + 3*R.z)\n>>> vectfield = 4*R[0]*R[1]*R.x + 2*R[0]**2*R.y\n>>> scalar_potential_difference(vectfield, R, O, P, O)\n4 \n```"]