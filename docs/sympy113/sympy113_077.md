# 使用 Meijer G 函数计算积分

> [https://docs.sympy.org/latest/modules/integrals/g-functions.html](https://docs.sympy.org/latest/modules/integrals/g-functions.html)

本文旨在详细描述使用 Meijer G 函数计算定积分和不定积分所涉及的步骤（及其微妙之处）。我们将完全忽略证明。

## 概述

计算 \(\int f(x) \mathrm{d}x\) 或 \(\int_0^\infty f(x) \mathrm{d}x\) 的算法通常包括三个步骤：

1.  使用 Meijer G 函数（有时一个或两个）重新写出被积函数。

1.  应用积分定理得到答案（通常表示为另一个 G 函数）。

1.  在命名的特殊函数中展开结果。

步骤 (3) 在函数 hyperexpand 中实现。步骤 (1) 和 (2) 如下所述。此外，G 函数通常是分支的。因此，我们首先描述了分支函数的处理方式。

有些其他积分（例如 \(\int_{-\infty}^\infty\)) 可以通过首先将它们重新表述为上述形式之一来计算。这里有很多选择，算法至多是一种启发式算法。

## 极数和分支函数

Meijer G 函数和超几何函数通常是分支的（可能的分支点为 \(0\)，\(\pm 1\)，\(\infty\)）。当例如将单个超几何函数展开为命名的特殊函数时，这并不是很重要，因为可以将分支问题留给人类用户。然而，这个算法操纵和转换 G 函数，要正确地做到这一点，至少需要一些关于所涉及分支的粗略理解。

首先，我们考虑集合 \(\mathcal{S} = \{(r, \theta) : r > 0, \theta \in \mathbb{R}\}\)。我们有一个映射 \(p: \mathcal{S} \rightarrow \mathbb{C}-\{0\}, (r, \theta) \mapsto r e^{i \theta}\)。将其定为局部双全纯映射给了 \(\mathcal{S}\) 一个拓扑和一个复结构。这个黎曼面通常被称为对数的黎曼面，原因如下：我们可以定义映射 \(\operatorname{Exp}: \mathbb{C} \rightarrow \mathcal{S}, (x + i y) \mapsto (\exp(x), y)\) 和 \(\operatorname{Log}: \mathcal{S} \rightarrow \mathbb{C}, (e^x, y) \mapsto x + iy\)。这两者都可以显示为全纯的，并且是互为逆映射。

有时我们还正式将点 “零” (\(0\)) 附加到 \(\mathcal{S}\) 上，并将结果对象称为 \(\mathcal{S}_0\)。显然，在 \(0\) 附近未定义复结构。一个基本的邻域系统由 \(\{\operatorname{Exp}(z) : \Re(z) < k\}\) 给出，至少定义了一个拓扑。 \(\mathcal{S}_0\) 的元素称为极数。我们进一步定义函数 \(\operatorname{Arg}: \mathcal{S} \rightarrow \mathbb{R}, (r, \theta) \mapsto \theta\) 和 \(|.|: \mathcal{S}_0 \rightarrow \mathbb{R}_{>0}, (r, \theta) \mapsto r\)。这些函数具有明显的意义，并且在所有地方都是连续的。

使用这些映射，许多操作可以从\(\mathbb{C}\)扩展到\(\mathcal{S}\)。我们定义\(\operatorname{Exp}(a) \operatorname{Exp}(b) = \operatorname{Exp}(a + b)\)对于\(a, b \in \mathbb{C}\)，同时对于\(a \in \mathcal{S}\)和\(b \in \mathbb{C}\)，我们定义\(a^b = \operatorname{Exp}(b \operatorname{Log}(a))\)。可以轻松地检验到，使用这些定义，许多代数性质（例如\((ab)^c = a^c b^c\))在正实数中适用（由于分支切割）在所有极坐标数中确实适用。

作为一种特殊性质，应当提到极坐标数的加法通常是未定义的。然而，极坐标数的形式和可以用来表达分支行为。例如，考虑函数\(F(z) = \sqrt{1 + z}\)和\(G(a, b) = \sqrt{a + b}\)，其中\(a, b, z\)为极坐标数。一般规则是，单个极坐标变量的函数定义为在圆上连续，并且与正实数的通常定义一致。因此，如果\(S(z)\)表示在\(\mathbb{C}\)上的平方根函数的标准分支，则我们被迫定义

\[\begin{split}F(z) = \begin{cases} S(p(z)) &: |z| < 1 \\ S(p(z)) &: -\pi < \operatorname{Arg}(z) + 4\pi n \le \pi \text{ for some } n \in \mathbb{Z} \\ -S(p(z)) &: \text{else} \end{cases}.\end{split}\]

(我们在这里省略了\( |z| = 1 \)，这对于积分不重要。) 最后我们定义\(G(a, b) = \sqrt{a}F(b/a)\)。

## 在阿干平面上表示分支函数

假设\(f: \mathcal{S} \to \mathbb{C}\)是一个全纯函数。我们希望在（部分）复数\(\mathbb{C}\)上定义一个函数\(F\)，尽可能地代表\(f\)。这个过程称为“引入分支切割”。在我们的情况下，实际上有一种标准做法（在SymPy的所有情况下都遵循），如下：引入“切割复平面”\(C = \mathbb{C} \setminus \mathbb{R}_{\le 0}\)。通过\(re^{i\theta} \mapsto r \operatorname{Exp}(i\theta)\)定义一个函数\(l: C \to \mathcal{S}\)。这里\(r > 0\)和\(-\pi < \theta \le \pi\)。然后\(l\)是全纯的，并且我们定义\(G = f \circ l\)。这称为在SymPy文档中的“提升到主分支”。

## 表查找和反梅林变换

假设我们有一个被积函数 \(f(x)\)，并尝试将其重写为一个单一的 G 函数。为此，我们首先将 \(f(x)\) 分解为 \(x^s g(x)\) 的形式（其中 \(g(x)\) 应该比 \(f(x)\) 简单）。这是通过函数 `_split_mul(f, x)` 完成的。然后我们将出现在 \(f\) 中的函数组装成一个元组（例如，如果 \(f(x) = e^x \cos{x}\)，我们将组装成 \((\cos, \exp)\)）。这是由函数 `_mytype(f, x)` 完成的。接下来，我们使用 `_create_lookup_table()` 创建一个查找表，并用这个元组索引它。这（希望地）会产生涉及这些函数的 Meijer G 函数公式的列表，然后我们尝试模式匹配它们。如果有一个匹配成功，我们就成功了；否则，我们需要尝试其他方法。

现在假设我们想将 \(f(x)\) 重写为两个 G 函数的乘积形式。为此，我们（试图）找出将 \(f(x)\) 分解为 \(f_1(x) f_2(x)\) 的所有不等价方式。我们可以按任意顺序尝试这些分解，但通常建议最小化 \(f_i(x)\) 中出现的幂次数和不同函数的数量。例如，给定 \(f(x) = \sin{x}\, e^{x} \sin{2x}\)，我们首先尝试 \(f_1(x) = \sin{x}\, \sin{2x}\)，\(f_2(x) = e^{x}\)。所有这些操作都由函数 `_mul_as_two_parts(f)` 完成。

最后，我们可以尝试递归的 Mellin 变换技术。由于 Meijer G 函数本质上被定义为某种反 Mellin 变换，如果我们想将函数 \(f(x)\) 写成一个 G 函数，我们可以计算它的 Mellin 变换 \(F(s)\)。如果 \(F(s)\) 符合要求的形式，那么 G 函数表达式可以直接得到。这种技术推广了许多标准的重写，例如 \(e^{ax} e^{bx} = e^{(a + b) x}\)。

一个小变化是，一些函数没有 Mellin 变换，尽管它们可以被写成 G 函数。例如，对于 \(f(x) = e^x \sin{x}\)（函数增长太快，没有 Mellin 变换）。然而，如果函数被认为是解析的，那么我们可以尝试计算 \(f(ax)\) 的 Mellin 变换（其中 \(a\) 是参数），并通过解析延拓推导出 G 函数表达式。（检查解析性是容易的。由于我们只能处理一定的函数子集，我们只需过滤掉那些不是解析的函数。）

函数 `_rewrite_single` 执行表查找和递归 Mellin 变换。函数 `_rewrite1` 和 `_rewrite2` 分别使用上述辅助函数和 `_rewrite_single` 来将它们的参数重写为一个或两个 G 函数。

## 应用积分定理

如果被积函数已经重新表达为G函数，那么评估积分就相对容易了。我们首先进行一些替换，以减少G函数参数的指数（分别参见 `_rewrite_saxena_1` 和 `_rewrite_saxena`，用于一个或两个G函数）。接下来，我们列出应用积分定理的条件列表。它可能失败基本有两个原因：要么积分不存在，要么在推导定理时的操作不允许（有关更多详细信息，请参见此处的 [[博客帖子]](#blogpost)）。

有时可以通过减少所涉及的G函数的参数来纠正这一点。例如，很明显，表示\(e^z\)的G函数满足对于所有\(z \in \mathcal{S}\)，有\(G(\operatorname{Exp}(2 \pi i)z) = G(z)\)。函数 `meijerg.get_period()` 可用于发现这一点，而函数 `functions/elementary/complexes.py` 中的 `principal_branch(z, period)` 可用于利用这些信息。这是由积分代码透明地完成的。

[[博客帖子](#id1)]

[https://nessgrh.wordpress.com/2011/07/07/tricky-branch-cuts/](https://nessgrh.wordpress.com/2011/07/07/tricky-branch-cuts/)

### G-函数积分定理

本节旨在详细展示代码中使用的确定积分定理。以下两个公式可以追溯到迈杰尔（实际上他证明了更一般的公式；事实上，在文献中，公式通常以更一般的形式陈述。然而，从我们在这里给出的公式中，推导出一般的公式非常容易。最好保持定理尽可能简单，因为它们本身非常复杂。）：

1.  \[\begin{split}\int_0^\infty G_{p, q}^{m, n} \left.\left(\begin{matrix} a_1, \cdots, a_p \\ b_1, \cdots, b_q \end{matrix} \right| \eta x \right) \mathrm{d}x = \frac{\prod_{j=1}^m \Gamma(b_j + 1) \prod_{j=1}^n \Gamma(-a_j)}{\eta \prod_{j=m+1}^q \Gamma(-b_j) \prod_{j=n+1}^p \Gamma(a_j + 1)}\end{split}\]

1.  \[\begin{split}\int_0^\infty G_{u, v}^{s, t} \left.\left(\begin{matrix} c_1, \cdots, c_u \\ d_1, \cdots, d_v \end{matrix} \right| \sigma x \right) G_{p, q}^{m, n} \left.\left(\begin{matrix} a_1, \cdots, a_p \\ b_1, \cdots, b_q \end{matrix} \right| \omega x \right) \mathrm{d}x = G_{v+p, u+q}^{m+t, n+s} \left.\left( \begin{matrix} a_1, \cdots, a_n, -d_1, \cdots, -d_v, a_{n+1}, \cdots, a_p \\ b_1, \cdots, b_m, -c_1, \cdots, -c_u, b_{m+1}, \cdots, b_q \end{matrix} \right| \frac{\omega}{\sigma} \right)\end{split}\]

更有趣的问题是在什么条件下这些公式是有效的。下面我们详细说明了SymPy中实施的条件。它们是在[[Prudnikov1990]](../simplify/hyperexpand.html#prudnikov1990)和[[Luke1969]](../simplify/hyperexpand.html#luke1969)中找到的条件的混合；如果您发现任何错误，请告诉我们。

## 收敛条件积分 (1)

我们可以假设没有一般性损失地认为 \(p \le q\)，因为指标 \(m, n, p, q\) 的 G 函数和指标 \(n, m, q, p\) 的 G 函数可以轻松相关联（见例如 [[Luke1969]](../simplify/hyperexpand.html#luke1969)，第 5.3 节）。我们引入以下符号：

\[\begin{split}\xi = m + n - p \\ \delta = m + n - \frac{p + q}{2}\end{split}\]\[\begin{split}C_3: -\Re(b_j) < 1 \text{ for } j=1, \ldots, m \\ 0 < -\Re(a_j) \text{ for } j=1, \ldots, n\end{split}\]\[\begin{split}C_3^*: -\Re(b_j) < 1 \text{ for } j=1, \ldots, q \\ 0 < -\Re(a_j) \text{ for } j=1, \ldots, p\end{split}\]\[C_4: -\Re(\delta) + \frac{q + 1 - p}{2} > q - p\]

收敛条件将在几个“情况”中详细说明，编号从一到五。为了以后的使用，将“无限远处”的条件与“零点”的条件分开将是有帮助的。我们所说的“无限远处”的条件是指仅依赖于积分被积函数在大正值 \(x\) 处的行为，而所说的“零点”的条件是指仅依赖于积分被积函数在 \((0, \epsilon)\) 内的行为，对于任意 \(\epsilon > 0\)。由于我们所有的条件都是用 G 函数的参数来指定的，这种区别并不立即可见。然而，在数学上它们是非常不同的；特别是无限远处的条件更难控制。

为了使积分定理有效，必须同时满足 \(n\) 在“零点”和“无限远处”的条件，对于某些 \(n\)。

这些是“无限远处”的条件：

1.  \[\delta > 0 \wedge |\arg(\eta)| < \delta \pi \wedge (A \vee B \vee C)\]

    其中

    \[A = 1 \le n \wedge p < q \wedge 1 \le m\]\[B = 1 \le p \wedge 1 \le m \wedge q = p+1 \wedge \neg (n = 0 \wedge m = p + 1 )\]\[C = 1 \le n \wedge q = p \wedge |\arg(\eta)| \ne (\delta - 2k)\pi \text{ for } k = 0, 1, \ldots \left\lceil \frac{\delta}{2} \right\rceil.\]

1.  \[n = 0 \wedge p + 1 \le m \wedge |\arg(\eta)| < \delta \pi\]

1.  \[(p < q \wedge 1 \le m \wedge \delta > 0 \wedge |\arg(\eta)| = \delta \pi) \vee (p \le q - 2 \wedge \delta = 0 \wedge \arg(\eta) = 0)\]

1.  \[p = q \wedge \delta = 0 \wedge \arg(\eta) = 0 \wedge \eta \ne 0 \wedge \Re\left(\sum_{j=1}^p b_j - a_j \right) < 0\]

1.  \[\delta > 0 \wedge |\arg(\eta)| < \delta \pi\]

而这些是“零点”的条件：

1.  \[\eta \ne 0 \wedge C_3\]

1.  \[C_3\]

1.  \[C_3 \wedge C_4\]

1.  \[C_3\]

1.  \[C_3\]

## 积分（2）的收敛条件

我们引入以下符号：

\[b^* = s + t - \frac{u + v}{2}\]\[c^* = m + n - \frac{p + q}{2}\]\[\rho = \sum_{j=1}^v d_j - \sum_{j=1}^u c_j + \frac{u - v}{2} + 1\]\[\mu = \sum_{j=1}^q b_j - \sum_{j=1}^p a_j + \frac{p - q}{2} + 1\]\[\phi = q - p - \frac{u - v}{2} + 1\]\[\eta = 1 - (v - u) - \mu - \rho\]\[\psi = \frac{\pi(q - m - n) + |\arg(\omega)|}{q - p}\]\[\theta = \frac{\pi(v - s - t) + |\arg(\sigma)|)}{v - u}\]\[\lambda_c = (q - p)|\omega|^{1/(q - p)} \cos{\psi} + (v - u)|\sigma|^{1/(v - u)} \cos{\theta}\]\[\lambda_{s0}(c_1, c_2) = c_1 (q - p)|\omega|^{1/(q - p)} \sin{\psi} + c_2 (v - u)|\sigma|^{1/(v - u)} \sin{\theta}\]\[\begin{split}\lambda_s = \begin{cases} \operatorname{\lambda_{s0}}\left(-1,-1\right) \operatorname{\lambda_{s0}}\left(1,1\right) & \text{for}\: \arg(\omega) = 0 \wedge \arg(\sigma) = 0 \\\operatorname{\lambda_{s0}}\left(\operatorname{sign}\left(\operatorname{\arg}\left(\omega\right)\right),-1\right) \operatorname{\lambda_{s0}}\left(\operatorname{sign}\left(\operatorname{\arg}\left(\omega\right)\right),1\right) & \text{for}\: \arg(\omega) \ne 0 \wedge \arg(\sigma) = 0 \\\operatorname{\lambda_{s0}}\left(-1,\operatorname{sign}\left(\operatorname{\arg}\left(\sigma\right)\right)\right) \operatorname{\lambda_{s0}}\left(1,\operatorname{sign}\left(\operatorname{\arg}\left(\sigma\right)\right)\right) & \text{for}\: \arg(\omega) = 0 \wedge \arg(\sigma) \ne 0) \\\operatorname{\lambda_{s0}}\left(\operatorname{sign}\left(\operatorname{\arg}\left(\omega\right)\right),\operatorname{sign}\left(\operatorname{\arg}\left(\sigma\right)\right)\right) & \text{otherwise} \end{cases}\end{split}\]\[z_0 = \frac{\omega}{\sigma} e^{-i\pi (b^* + c^*)}\]\[z_1 = \frac{\sigma}{\omega} e^{-i\pi (b^* + c^*)}\]

以下条件将会非常有帮助：

\[\begin{split}C_1: (a_i - b_j \notin \mathbb{Z}_{>0} \text{ for } i = 1, \ldots, n, j = 1, \ldots, m) \\ \wedge (c_i - d_j \notin \mathbb{Z}_{>0} \text{ for } i = 1, \ldots, t, j = 1, \ldots, s)\end{split}\]\[C_2: \Re(1 + b_i + d_j) > 0 \text{ for } i = 1, \ldots, m, j = 1, \ldots, s\]\[C_3: \Re(a_i + c_j) < 1 \text{ for } i = 1, \ldots, n, j = 1, \ldots, t\]\[C_4: (p - q)\Re(c_i) - \Re(\mu) > -\frac{3}{2} \text{ for } i=1, \ldots, t\]\[C_5: (p - q)\Re(1 + d_i) - \Re(\mu) > -\frac{3}{2} \text{ for } i=1, \ldots, s\]\[C_6: (u - v)\Re(a_i) - \Re(\rho) > -\frac{3}{2} \text{ for } i=1, \ldots, n\]\[C_7: (u - v)\Re(1 + b_i) - \Re(\rho) > -\frac{3}{2} \text{ for } i=1, \ldots, m\]\[C_8: 0 < \lvert{\phi}\rvert + 2 \Re\left(\left(\mu -1\right) \left(- u + v\right) + \left(- p + q\right) \left(\rho -1\right) + \left(- p + q\right) \left(- u + v\right)\right)\]\[C_9: 0 < \lvert{\phi}\rvert - 2 \Re\left(\left(\mu -1\right) \left(- u + v\right) + \left(- p + q\right) \left(\rho -1\right) + \left(- p + q\right) \left(- u + v\right)\right)\]\[C_{10}: \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi b^{*}\]\[C_{11}: \lvert{\operatorname{arg}\left(\sigma\right)}\rvert = \pi b^{*}\]\[C_{12}: |\arg(\omega)| < c^*\pi\]\[C_{13}: |\arg(\omega)| = c^*\pi\]\[C_{14}^1: \left(z_0 \ne 1 \wedge |\arg(1 - z_0)| < \pi \right) \vee \left(z_0 = 1 \wedge \Re(\mu + \rho - u + v) < 1 \right)\]\[C_{14}^2: \left(z_1 \ne 1 \wedge |\arg(1 - z_1)| < \pi \right) \vee \left(z_1 = 1 \wedge \Re(\mu + \rho - p + q) < 1 \right)\]\[C_{14}: \phi = 0 \wedge b^* + c^* \le 1 \wedge (C_{14}^1 \vee C_{14}^2)\]\[C_{15}: \lambda_c > 0 \vee (\lambda_c = 0 \wedge \lambda_s \ne 0 \wedge \Re(\eta) > -1) \vee (\lambda_c = 0 \wedge \lambda_s = 0 \wedge \Re(\eta) > 0)\]\[C_{16}: \int_0^\infty G_{u, v}^{s, t}(\sigma x) \mathrm{d} x \text{ 在无穷远处收敛 }\]\[C_{17}: \int_0^\infty G_{p, q}^{m, n}(\omega x) \mathrm{d} x \text{ 在无穷远处收敛 }\]

注意 \(C_{16}\) 和 \(C_{17}\) 是我们为积分 (1) 拆分收敛条件的原因。

确定了这些符号后，实施的收敛条件可以列举如下：

1.  \[m n s t \neq 0 \wedge 0 < b^{*} \wedge 0 < c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{10} \wedge C_{12}\]

1.  \[u = v \wedge b^{*} = 0 \wedge 0 < c^{*} \wedge 0 < \sigma \wedge \Re{\rho} < 1 \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{12}\]

1.  \[p = q \wedge u = v \wedge b^{*} = 0 \wedge c^{*} = 0 \wedge 0 < \sigma \wedge 0 < \omega \wedge \Re{\mu} < 1 \wedge \Re{\rho} < 1 \wedge \sigma \neq \omega \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[p = q \wedge u = v \wedge b^{*} = 0 \wedge c^{*} = 0 \wedge 0 < \sigma \wedge 0 < \omega \wedge \Re\left(\mu + \rho\right) < 1 \wedge \omega \neq \sigma \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[p = q \wedge u = v \wedge b^{*} = 0 \wedge c^{*} = 0 \wedge 0 < \sigma \wedge 0 < \omega \wedge \Re\left(\mu + \rho\right) < 1 \wedge \omega \neq \sigma \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[q < p \wedge 0 < s \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{5} \wedge C_{10} \wedge C_{13}\]

1.  \[p < q \wedge 0 < t \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{10} \wedge C_{13}\]

1.  \[v < u \wedge 0 < m \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{7} \wedge C_{11} \wedge C_{12}\]

1.  \[u < v \wedge 0 < n \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{6} \wedge C_{11} \wedge C_{12}\]

1.  \[q < p \wedge u = v \wedge b^{*} = 0 \wedge 0 \leq c^{*} \wedge 0 < \sigma \wedge \Re{\rho} < 1 \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{5} \wedge C_{13}\]

1.  \[p < q \wedge u = v \wedge b^{*} = 0 \wedge 0 \leq c^{*} \wedge 0 < \sigma \wedge \Re{\rho} < 1 \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{13}\]

1.  \[p = q \wedge v < u \wedge 0 \leq b^{*} \wedge c^{*} = 0 \wedge 0 < \omega \wedge \Re{\mu} < 1 \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{7} \wedge C_{11}\]

1.  \[p = q \wedge u < v \wedge 0 \leq b^{*} \wedge c^{*} = 0 \wedge 0 < \omega \wedge \Re{\mu} < 1 \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{6} \wedge C_{11}\]

1.  \[p < q \wedge v < u \wedge 0 \leq b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{7} \wedge C_{11} \wedge C_{13}\]

1.  \[q < p \wedge u < v \wedge 0 \leq b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{5} \wedge C_{6} \wedge C_{11} \wedge C_{13}\]

1.  \[q < p \wedge v < u \wedge 0 \leq b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{5} \wedge C_{7} \wedge C_{8} \wedge C_{11} \wedge C_{13} \wedge C_{14}\]

1.  \[p < q \wedge u < v \wedge 0 \leq b^{*} \wedge 0 \leq c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{4} \wedge C_{6} \wedge C_{9} \wedge C_{11} \wedge C_{13} \wedge C_{14}\]

1.  \[t = 0 \wedge 0 < s \wedge 0 < b^{*} \wedge 0 < \phi \wedge C_{1} \wedge C_{2} \wedge C_{10}\]

1.  \[s = 0 \wedge 0 < t \wedge 0 < b^{*} \wedge \phi < 0 \wedge C_{1} \wedge C_{3} \wedge C_{10}\]

1.  \[n = 0 \wedge 0 < m \wedge 0 < c^{*} \wedge \phi < 0 \wedge C_{1} \wedge C_{2} \wedge C_{12}\]

1.  \[m = 0 \wedge 0 < n \wedge 0 < c^{*} \wedge 0 < \phi \wedge C_{1} \wedge C_{3} \wedge C_{12}\]

1.  \[s t = 0 \wedge 0 < b^{*} \wedge 0 < c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{10} \wedge C_{12}\]

1.  \[m n = 0 \wedge 0 < b^{*} \wedge 0 < c^{*} \wedge C_{1} \wedge C_{2} \wedge C_{3} \wedge C_{10} \wedge C_{12}\]

1.  \[p < m + n \wedge t = 0 \wedge \phi = 0 \wedge 0 < s \wedge 0 < b^{*} \wedge c^{*} < 0 \wedge \lvert{\operatorname{arg}\left(\omega\right)}\rvert < \pi \left(m + n - p + 1\right) \wedge C_{1} \wedge C_{2} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[q < m + n \wedge s = 0 \wedge \phi = 0 \wedge 0 < t \wedge 0 < b^{*} \wedge c^{*} < 0 \wedge \lvert{\operatorname{arg}\left(\omega\right)}\rvert < \pi \left(m + n - q + 1\right) \wedge C_{1} \wedge C_{3} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[p = q -1 \wedge t = 0 \wedge \phi = 0 \wedge 0 < s \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge \pi c^{*} < \lvert{\operatorname{arg}\left(\omega\right)}\rvert \wedge C_{1} \wedge C_{2} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[p = q + 1 \wedge s = 0 \wedge \phi = 0 \wedge 0 < t \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge \pi c^{*} < \lvert{\operatorname{arg}\left(\omega\right)}\rvert \wedge C_{1} \wedge C_{3} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[p < q -1 \wedge t = 0 \wedge \phi = 0 \wedge 0 < s \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge \pi c^{*} < \lvert{\operatorname{arg}\left(\omega\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\omega\right)}\rvert < \pi \left(m + n - p + 1\right) \wedge C_{1} \wedge C_{2} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[q + 1 < p \wedge s = 0 \wedge \phi = 0 \wedge 0 < t \wedge 0 < b^{*} \wedge 0 \leq c^{*} \wedge \pi c^{*} < \lvert{\operatorname{arg}\left(\omega\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\omega\right)}\rvert < \pi \left(m + n - q + 1 \right) \wedge C_{1} \wedge C_{3} \wedge C_{10} \wedge C_{14} \wedge C_{15}\]

1.  \[n = 0 \wedge \phi = 0 \wedge 0 < s + t \wedge 0 < m \wedge 0 < c^{*} \wedge b^{*} < 0 \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(s + t - u + 1\right) \wedge C_{1} \wedge C_{2} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[m = 0 \wedge \phi = 0 \wedge v < s + t \wedge 0 < n \wedge 0 < c^{*} \wedge b^{*} < 0 \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(s + t - v + 1\right) \wedge C_{1} \wedge C_{3} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[n = 0 \wedge \phi = 0 \wedge u = v -1 \wedge 0 < m \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge \pi b^{*} < \lvert{\operatorname{arg}\left(\sigma\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(b^{*} + 1\right) \wedge C_{1} \wedge C_{2} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[m = 0 \wedge \phi = 0 \wedge u = v + 1 \wedge 0 < n \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge \pi b^{*} < \lvert{\operatorname{arg}\left(\sigma\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(b^{*} + 1\right) \wedge C_{1} \wedge C_{3} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[n = 0 \wedge \phi = 0 \wedge u < v -1 \wedge 0 < m \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge \pi b^{*} < \lvert{\operatorname{arg}\left(\sigma\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(s + t - u + 1\right) \wedge C_{1} \wedge C_{2} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[m = 0 \wedge \phi = 0 \wedge v + 1 < u \wedge 0 < n \wedge 0 < c^{*} \wedge 0 \leq b^{*} \wedge \pi b^{*} < \lvert{\operatorname{arg}\left(\sigma\right)}\rvert \wedge \lvert{\operatorname{arg}\left(\sigma\right)}\rvert < \pi \left(s + t - v + 1 \right) \wedge C_{1} \wedge C_{3} \wedge C_{12} \wedge C_{14} \wedge C_{15}\]

1.  \[C_{17} \wedge t = 0 \wedge u < s \wedge 0 < b^{*} \wedge C_{10} \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[C_{17} \wedge s = 0 \wedge v < t \wedge 0 < b^{*} \wedge C_{10} \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[C_{16} \wedge n = 0 \wedge p < m \wedge 0 < c^{*} \wedge C_{12} \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

1.  \[C_{16} \wedge m = 0 \wedge q < n \wedge 0 < c^{*} \wedge C_{12} \wedge C_{1} \wedge C_{2} \wedge C_{3}\]

### 一个 G-函数的拉普拉斯逆变换

Meijer G-函数的拉普拉斯逆变换可以表示为另一个 G-函数。这是计算该变换的一种非常通用的方法。然而，我在文献中找不到详细信息，所以在这里进行了推导。在 [[Luke1969]](../simplify/hyperexpand.html#luke1969) 的第5.6.3节中，给出了关于 G-函数的拉普拉斯逆变换的公式，同时也给出了收敛条件。然而，我们需要一个关于参数 \(bz^a\) 的公式，其中 \(a\) 是有理数。

我们被要求计算

\[f(t) = \frac{1}{2\pi i} \int_{c-i\infty}^{c+i\infty} e^{zt} G(bz^a) \mathrm{d}z,\]

对于正实数 \(t\)。三个问题出现：

1.  这个积分何时收敛？

1.  怎样计算积分？

1.  我们的计算何时有效？

## 如何计算积分

现在我们暂时形式化处理。用 \(\Delta(s)\) 表示在 \(G\) 的定义中出现的伽玛函数的乘积，因此

\[G(z) = \frac{1}{2\pi i} \int_L \Delta(s) z^s \mathrm{d}s.\]

因此

\[f(t) = \frac{1}{(2\pi i)^2} \int_{c - i\infty}^{c + i\infty} \int_L e^{zt} \Delta(s) b^s z^{as} \mathrm{d}s \mathrm{d}z.\]

我们交换积分的顺序得到

\[f(t) = \frac{1}{2\pi i} \int_L b^s \Delta(s) \int_{c-i\infty}^{c+i\infty} e^{zt} z^{as} \frac{\mathrm{d}z}{2\pi i} \mathrm{d}s.\]

内积分很容易看出为 \(\frac{1}{\Gamma(-as)} \frac{1}{t^{1+as}}\)。（使用柯西定理和约当引理使轮廓从 \(-\infty\) 变形到 \(-\infty\)，围绕 \(0\) 一次。对于实数且大于一的 \(as\)，这个轮廓可以推到负实轴上，并且积分被识别为正弦和伽玛函数的乘积。然后利用伽玛函数的函数方程证明该公式，并通过解析延拓到原积分的收敛域）因此我们得到

\[f(t) = \frac{1}{t} \frac{1}{2\pi i} \int_L \Delta(s) \frac{1}{\Gamma(-as)} \left(\frac{b}{t^a}\right)^s \mathrm{d}s,\]

这是所谓的 Fox H 函数（参数为 \(\frac{b}{t^a}\)）。对于有理数 \(a\)，这可以利用伽玛函数乘法定理表示为 Meijer G 函数。

## 当这个计算有效时

在这个计算中有很多障碍。只有当涉及的所有积分都绝对收敛时，积分的互换才有效。特别是内积分必须收敛。此外，为了正确地将最终积分识别为 Fox H / Meijer G 函数，新引入的伽玛函数的极点必须正确分离。

很容易检查内积分对于 \(\Re(as) < -1\) 绝对收敛。因此轮廓 \(L\) 必须位于线 \(\Re(as) = -1\) 的左侧。在这种条件下，新引入的伽玛函数的极点正确分离。

我们还需观察 Meijer G 函数是其参数的解析、无分支函数，以及系数 \(b\) 的解析。因此 \(f(t)\) 也是有效的最终计算，只要初始积分收敛，并且存在一组参数变化使计算有效。如果我们假设 w.l.o.g. \(a > 0\)，则后一条件在 \(G\) 沿着 [[Luke1969]](../simplify/hyperexpand.html#luke1969)，第 5.2 节的轮廓 (2) 或 (3) 收敛时成立，即 \(\delta \ge \frac{a}{2}\) 或 \(p \ge 1, p \ge q\)。

## 当积分存在时

使用 [[Luke1969]](../simplify/hyperexpand.html#luke1969)，第 5.10 节，对于任何给定的 Meijer G 函数，我们可以找到形如 \(z^a e^{bz^c}\) 的主导项（尽管由于抵消的原因，这个表达可能不是最佳的）。

因此，我们必须调查

\[\lim_{T \to \infty} \int_{c-iT}^{c+iT} e^{zt} z^a e^{bz^c} \mathrm{d}z.\]

（这个主值积分正是拉普拉斯反演定理中使用的确切陈述。）我们写成 \(z = c + i \tau\)。那么 \(arg(z) \to \pm \frac{\pi}{2}\)，因此 \(e^{zt} \sim e^{it \tau}\)（其中 \(\sim\) 总是意味着“渐近等价，直到正实数乘法常数为止”）。还有 \(z^{x + iy} \sim |\tau|^x e^{i y \log{|\tau|}} e^{\pm x i \frac{\pi}{2}}\)。

设定 \(\omega_{\pm} = b e^{\pm i \Re(c) \frac{\pi}{2}}\)。我们有三种情况：

1.  \(b=0\) 或 \(\Re(c) \le 0\)。在这种情况下，如果 \(\Re(a) \le -1\)，积分收敛。

1.  \(b \ne 0\), \(\Im(c) = 0\), \(\Re(c) > 0\)。在这种情况下，如果 \(\Re(\omega_{\pm}) < 0\)，则积分收敛。

1.  \(b \ne 0\), \(\Im(c) = 0\), \(\Re(c) > 0\), \(\Re(\omega_{\pm}) \le 0\), 并且至少一个 \(\Re(\omega_{\pm}) = 0\)。在这种情况下，与 (1) 中相同的条件适用。

### 实施的 G-函数公式

算法的一个重要部分是将各种函数表达为Meijer G函数的表格。实质上，这是一个掩盖着的Mellin变换表格。以下是自动生成的表格，显示了目前在SymPy中实现的公式。条目“generated”表示相应的G函数具有可变数量的参数。这张表格预计会在算法改进导出新公式的能力时缩减。当然，每当需要处理新的特殊函数类时，它也必须增长。

基本函数：

函数涉及\(\theta\left(z^{q} p - b\right)\)：

\[\begin{split}a = a {G_{1, 1}^{1, 0}\left(\begin{matrix} & 1 \\0 & \end{matrix} \middle| {z} \right)} + a {G_{1, 1}^{0, 1}\left(\begin{matrix} 1 & \\ & 0 \end{matrix} \middle| {z} \right)}\end{split}\]\[\begin{split}\left(z^{q} p + b\right)^{- a} = \frac{b^{- a} {G_{1, 1}^{1, 1}\left(\begin{matrix} 1 - a & \\0 & \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)}}{\Gamma\left(a\right)}\end{split}\]\[\begin{split}\frac{- b^{a} + \left(z^{q} p\right)^{a}}{z^{q} p - b} = \frac{b^{a - 1} {G_{2, 2}^{2, 2}\left(\begin{matrix} 0, a & \\0, a & \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \sin{\left(\pi a \right)}}{\pi}\end{split}\]\[\begin{split}\left(a + \sqrt{z^{q} p + a^{2}}\right)^{b} = - \frac{a^{b} b {G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{b}{2} + \frac{1}{2}, \frac{b}{2} + 1 & \\0 & b \end{matrix} \middle| {\frac{z^{q} p}{a^{2}}} \right)}}{2 \sqrt{\pi}}\end{split}\]\[\begin{split}\left(- a + \sqrt{z^{q} p + a^{2}}\right)^{b} = \frac{a^{b} b {G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{b}{2} + \frac{1}{2}, \frac{b}{2} + 1 & \\b & 0 \end{matrix} \middle| {\frac{z^{q} p}{a^{2}}} \right)}}{2 \sqrt{\pi}}\end{split}\]\[\begin{split}\frac{\left(a + \sqrt{z^{q} p + a^{2}}\right)^{b}}{\sqrt{z^{q} p + a^{2}}} = \frac{a^{b - 1} {G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{b}{2}, \frac{b}{2} + \frac{1}{2} & \\0 & b \end{matrix} \middle| {\frac{z^{q} p}{a^{2}}} \right)}}{\sqrt{\pi}}\end{split}\]\[\begin{split}\frac{\left(- a + \sqrt{z^{q} p + a^{2}}\right)^{b}}{\sqrt{z^{q} p + a^{2}}} = \frac{a^{b - 1} {G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{b}{2}, \frac{b}{2} + \frac{1}{2} & \\b & 0 \end{matrix} \middle| {\frac{z^{q} p}{a^{2}}} \right)}}{\sqrt{\pi}}\end{split}\]\[\begin{split}\left(z^{\frac{q}{2}} \sqrt{p} + \sqrt{z^{q} p + a}\right)^{b} = - \frac{a^{\frac{b}{2}} b {G_{2, 2}^{2, 1}\left(\begin{matrix} \frac{b}{2} + 1 & 1 - \frac{b}{2} \\0, \frac{1}{2} & \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}}{2 \sqrt{\pi}}\end{split}\]\[\begin{split}\left(- z^{\frac{q}{2}} \sqrt{p} + \sqrt{z^{q} p + a}\right)^{b} = \frac{a^{\frac{b}{2}} b {G_{2, 2}^{2, 1}\left(\begin{matrix} 1 - \frac{b}{2} & \frac{b}{2} + 1 \\0, \frac{1}{2} & \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}}{2 \sqrt{\pi}}\end{split}\]\[\begin{split}\frac{\left(z^{\frac{q}{2}} \sqrt{p} + \sqrt{z^{q} p + a}\right)^{b}}{\sqrt{z^{q} p + a}} = \frac{a^{\frac{b}{2} - \frac{1}{2}} {G_{2, 2}^{2, 1}\left(\begin{matrix} \frac{b}{2} + \frac{1}{2} & \frac{1}{2} - \frac{b}{2} \\0, \frac{1}{2} & \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}}{\sqrt{\pi}}\end{split}\]\[\begin{split}\frac{\left(- z^{\frac{q}{2}} \sqrt{p} + \sqrt{z^{q} p + a}\right)^{b}}{\sqrt{z^{q} p + a}} = \frac{a^{\frac{b}{2} - \frac{1}{2}} {G_{2, 2}^{2, 1}\left(\begin{matrix} \frac{1}{2} - \frac{b}{2} & \frac{b}{2} + \frac{1}{2} \\0, \frac{1}{2} & \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}}{\sqrt{\pi}}\end{split}\]

\[\begin{split}\left(z^{q} p - b\right)^{a - 1} \theta\left(z^{q} p - b\right) = b^{a - 1} {G_{1, 1}^{0, 1}\left(\begin{matrix} a & \\ & 0 \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \Gamma\left(a\right),\text{ if } b > 0\end{split}\]\[\begin{split}\left(- z^{q} p + b\right)^{a - 1} \theta\left(- z^{q} p + b\right) = b^{a - 1} {G_{1, 1}^{1, 0}\left(\begin{matrix} & a \\0 & \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \Gamma\left(a\right),\text{ if } b > 0\end{split}\]\[\begin{split}\left(z^{q} p - b\right)^{a - 1} \theta\left(z - \left(\frac{b}{p}\right)^{\frac{1}{q}}\right) = b^{a - 1} {G_{1, 1}^{0, 1}\left(\begin{matrix} a & \\ & 0 \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \Gamma\left(a\right),\text{ if } b > 0\end{split}\]\[\begin{split}\left(- z^{q} p + b\right)^{a - 1} \theta\left(- z + \left(\frac{b}{p}\right)^{\frac{1}{q}}\right) = b^{a - 1} {G_{1, 1}^{1, 0}\left(\begin{matrix} & a \\0 & \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \Gamma\left(a\right),\text{ if } b > 0\end{split}\]

涉及\(\left|{z^{q} p - b}\right|\)的函数：

\[\begin{split}\left|{z^{q} p - b}\right|^{- a} = 2 {G_{2, 2}^{1, 1}\left(\begin{matrix} 1 - a & \frac{1}{2} - \frac{a}{2} \\0 & \frac{1}{2} - \frac{a}{2} \end{matrix} \middle| {\frac{z^{q} p}{b}} \right)} \sin{\left(\frac{\pi a}{2} \right)} \left|{b}\right|^{- a} \Gamma\left(1 - a\right),\text{ if } \operatorname{re}{\left(a\right)} < 1\end{split}\]

涉及\(e^{z^{q} p e^{i \pi}}\)的函数：

\[\begin{split}e^{z^{q} p e^{i \pi}} = {G_{0, 1}^{1, 0}\left(\begin{matrix} & \\0 & \end{matrix} \middle| {z^{q} p} \right)}\end{split}\]

涉及\(\sinh{\left(z^{q} p \right)}\)的函数：

\[\begin{split}\sinh{\left(z^{q} p \right)} = \pi^{\frac{3}{2}} {G_{1, 3}^{1, 0}\left(\begin{matrix} & 1 \\\frac{1}{2} & 0, 1 \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

涉及\(\cosh{\left(z^{q} p \right)}\)的函数：

\[\begin{split}\cosh{\left(z^{q} p \right)} = \pi^{\frac{3}{2}} {G_{1, 3}^{1, 0}\left(\begin{matrix} & \frac{1}{2} \\0 & \frac{1}{2}, \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

涉及\(\sin{\left(z^{q} p \right)}\)的函数：

\[\begin{split}\sin{\left(z^{q} p \right)} = \sqrt{\pi} {G_{0, 2}^{1, 0}\left(\begin{matrix} & \\\frac{1}{2} & 0 \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

涉及\(\cos{\left(z^{q} p \right)}\)的函数：

\[\begin{split}\cos{\left(z^{q} p \right)} = \sqrt{\pi} {G_{0, 2}^{1, 0}\left(\begin{matrix} & \\0 & \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

涉及\(\operatorname{sinc}{\left(z^{q} p \right)}\)的函数：

\[\begin{split}\operatorname{sinc}{\left(z^{q} p \right)} = \frac{\sqrt{\pi} {G_{0, 2}^{1, 0}\left(\begin{matrix} & \\0 & - \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}}{2}\end{split}\]

涉及\(\log{\left(z^{q} p \right)}\), \(\theta\left(- z^{q} p + 1\right)\)的函数：

\[\log{\left(z^{q} p \right)}^{n} \theta\left(- z^{q} p + 1\right) = \text{生成}\]\[\log{\left(z^{q} p \right)}^{n} \theta\left(z^{q} p - 1\right) = \text{生成}\]

函数涉及 \(\log{\left(z^{q} p \right)}\):

\[\log{\left(z^{q} p \right)}^{n} = \text{生成}\]\[\begin{split}\log{\left(z^{q} p + a \right)} = {G_{1, 1}^{1, 0}\left(\begin{matrix} & 1 \\0 & \end{matrix} \middle| {z} \right)} \log{\left(a \right)} + {G_{1, 1}^{0, 1}\left(\begin{matrix} 1 & \\ & 0 \end{matrix} \middle| {z} \right)} \log{\left(a \right)} + {G_{2, 2}^{1, 2}\left(\begin{matrix} 1, 1 & \\1 & 0 \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}\end{split}\]\[\begin{split}\log{\left(\left|{z^{q} p - a}\right| \right)} = {G_{1, 1}^{1, 0}\left(\begin{matrix} & 1 \\0 & \end{matrix} \middle| {z} \right)} \log{\left(\left|{a}\right| \right)} + {G_{1, 1}^{0, 1}\left(\begin{matrix} 1 & \\ & 0 \end{matrix} \middle| {z} \right)} \log{\left(\left|{a}\right| \right)} + \pi {G_{3, 3}^{1, 2}\left(\begin{matrix} 1, 1 & \frac{1}{2} \\1 & 0, \frac{1}{2} \end{matrix} \middle| {\frac{z^{q} p}{a}} \right)}\end{split}\]

函数涉及 \(\operatorname{Ei}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{Ei}{\left(z^{q} p \right)} = - i \pi {G_{1, 1}^{1, 0}\left(\begin{matrix} & 1 \\0 & \end{matrix} \middle| {z} \right)} - {G_{1, 2}^{2, 0}\left(\begin{matrix} & 1 \\0, 0 & \end{matrix} \middle| {z^{q} p e^{i \pi}} \right)} - i \pi {G_{1, 1}^{0, 1}\left(\begin{matrix} 1 & \\ & 0 \end{matrix} \middle| {z} \right)}\end{split}\]

函数涉及 \(\operatorname{Si}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{Si}{\left(z^{q} p \right)} = \frac{\sqrt{\pi} {G_{1, 3}^{1, 1}\left(\begin{matrix} 1 & \\\frac{1}{2} & 0, 0 \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}}{2}\end{split}\]

函数涉及 \(\operatorname{Ci}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{Ci}{\left(z^{q} p \right)} = - \frac{\sqrt{\pi} {G_{1, 3}^{2, 0}\left(\begin{matrix} & 1 \\0, 0 & \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}}{2}\end{split}\]

函数涉及 \(\operatorname{Shi}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{Shi}{\left(z^{q} p \right)} = \frac{z^{q} \sqrt{\pi} p {G_{1, 3}^{1, 1}\left(\begin{matrix} \frac{1}{2} & \\0 & - \frac{1}{2}, - \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2} e^{i \pi}}{4}} \right)}}{4}\end{split}\]

函数涉及 \(\operatorname{Chi}\left(z^{q} p\right)\):

\[\begin{split}\operatorname{Chi}\left(z^{q} p\right) = - \frac{\pi^{\frac{3}{2}} {G_{2, 4}^{2, 0}\left(\begin{matrix} & \frac{1}{2}, 1 \\0, 0 & \frac{1}{2}, \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}}{2}\end{split}\]

函数涉及 \(\operatorname{E}_{a}\left(z^{q} p\right)\):

\[\begin{split}\operatorname{E}_{a}\left(z^{q} p\right) = {G_{1, 2}^{2, 0}\left(\begin{matrix} & a \\0, a - 1 & \end{matrix} \middle| {z^{q} p} \right)}\end{split}\]

函数涉及\(\operatorname{erf}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{erf}{\left(z^{q} p \right)} = \frac{{G_{1, 2}^{1, 1}\left(\begin{matrix} 1 & \\\frac{1}{2} & 0 \end{matrix} \middle| {z^{2 q} p^{2}} \right)}}{\sqrt{\pi}}\end{split}\]

函数涉及\(\operatorname{erfc}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{erfc}{\left(z^{q} p \right)} = \frac{{G_{1, 2}^{2, 0}\left(\begin{matrix} & 1 \\0, \frac{1}{2} & \end{matrix} \middle| {z^{2 q} p^{2}} \right)}}{\sqrt{\pi}}\end{split}\]

函数涉及\(\operatorname{erfi}{\left(z^{q} p \right)}\):

\[\begin{split}\operatorname{erfi}{\left(z^{q} p \right)} = \frac{z^{q} p {G_{1, 2}^{1, 1}\left(\begin{matrix} \frac{1}{2} & \\0 & - \frac{1}{2} \end{matrix} \middle| {- z^{2 q} p^{2}} \right)}}{\sqrt{\pi}}\end{split}\]

函数涉及\(S\left(z^{q} p\right)\):

\[\begin{split}S\left(z^{q} p\right) = \frac{{G_{1, 3}^{1, 1}\left(\begin{matrix} 1 & \\\frac{3}{4} & 0, \frac{1}{4} \end{matrix} \middle| {\frac{z^{4 q} \pi^{2} p^{4}}{16}} \right)}}{2}\end{split}\]

函数涉及\(C\left(z^{q} p\right)\):

\[\begin{split}C\left(z^{q} p\right) = \frac{{G_{1, 3}^{1, 1}\left(\begin{matrix} 1 & \\\frac{1}{4} & 0, \frac{3}{4} \end{matrix} \middle| {\frac{z^{4 q} \pi^{2} p^{4}}{16}} \right)}}{2}\end{split}\]

函数涉及\(J_{a}\left(z^{q} p\right)\):

\[\begin{split}J_{a}\left(z^{q} p\right) = {G_{0, 2}^{1, 0}\left(\begin{matrix} & \\\frac{a}{2} & - \frac{a}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

函数涉及\(Y_{a}\left(z^{q} p\right)\):

\[\begin{split}Y_{a}\left(z^{q} p\right) = {G_{1, 3}^{2, 0}\left(\begin{matrix} & - \frac{a}{2} - \frac{1}{2} \\- \frac{a}{2}, \frac{a}{2} & - \frac{a}{2} - \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

函数涉及\(I_{a}\left(z^{q} p\right)\):

\[\begin{split}I_{a}\left(z^{q} p\right) = \pi {G_{1, 3}^{1, 0}\left(\begin{matrix} & \frac{a}{2} + \frac{1}{2} \\\frac{a}{2} & - \frac{a}{2}, \frac{a}{2} + \frac{1}{2} \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}\end{split}\]

函数涉及\(K_{a}\left(z^{q} p\right)\):

\[\begin{split}K_{a}\left(z^{q} p\right) = \frac{{G_{0, 2}^{2, 0}\left(\begin{matrix} & \\- \frac{a}{2}, \frac{a}{2} & \end{matrix} \middle| {\frac{z^{2 q} p^{2}}{4}} \right)}}{2}\end{split}\]

函数涉及\(K\left(z^{q} p\right)\):

\[\begin{split}K\left(z^{q} p\right) = \frac{{G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{1}{2}, \frac{1}{2} & \\0 & 0 \end{matrix} \middle| {- z^{q} p} \right)}}{2}\end{split}\]

函数涉及\(E\left(z^{q} p\right)\):

\[\begin{split}E\left(z^{q} p\right) = - \frac{{G_{2, 2}^{1, 2}\left(\begin{matrix} \frac{1}{2}, \frac{3}{2} & \\0 & 0 \end{matrix} \middle| {- z^{q} p} \right)}}{4}\end{split}\] ### 内部 API 参考

通过将它们重写为 Meijer G 函数来积分函数。

有三个用户可见函数可以由 sympy 库的其他部分使用来解决各种积分问题：

+   meijerint_indefinite

+   meijerint_definite

+   meijerint_inversion

它们可以用于计算无穷大、实数线段上的定积分以及反拉普拉斯类型的积分（从 c-I*oo 到 c+I*oo）。详细信息请参见各自的文档字符串。

主要参考文献包括：

[L] 卢克，Y·L·（1969年），特殊函数及其近似，

卷1

[R] 凯利·B·罗奇。Meijer G 函数表示。

在：1997年国际符号和代数计算研讨会论文集，205-211页，纽约，1997年。ACM。

[P] A·P·普鲁德尼科夫，Yu·A·布里奇科夫和O·I·马里切夫（1990年）。

积分与级数：更多特殊函数，第3卷，戈登和布雷奇科科学出版社

```py
exception sympy.integrals.meijerint._CoeffExpValueError
```

_get_coeff_exp 引发的异常，仅供内部使用。

```py
sympy.integrals.meijerint._check_antecedents(g1, g2, x)
```

返回适用于积分定理的条件。

```py
sympy.integrals.meijerint._check_antecedents_1(g, x, helper=False)
```

返回使得 g 的 mellin 变换存在的条件。任何 x 的幂已经被吸收进 G 函数中，因此这只是 \(\int_0^\infty g\, dx\)。

见[L，第5.6.1节]。（注意 s=1。）

如果 `helper` 为 True，则仅检查无穷远处的 MT 是否存在，即是否存在 \(\int_1^\infty g\, dx\)。

```py
sympy.integrals.meijerint._check_antecedents_inversion(g, x)
```

检查拉普拉斯反演积分的前提条件。

```py
sympy.integrals.meijerint._condsimp(cond, first=True)
```

对 `cond` 进行天真的简化。

解释

请注意，此例程完全是特定应用的，简化规则是根据需要添加的，而不是遵循任何逻辑模式。

示例

```py
>>> from sympy.integrals.meijerint import _condsimp as simp
>>> from sympy import Or, Eq
>>> from sympy.abc import x, y
>>> simp(Or(x < y, Eq(x, y)))
x <= y 
```

```py
sympy.integrals.meijerint._create_lookup_table(table)
```

添加函数 -> meijerg 查询表格的公式。

```py
sympy.integrals.meijerint._dummy(name, token, expr, **kwargs)
```

返回一个虚拟值。如果请求同一 token+name 多次且它尚未在表达式中，则返回相同的虚拟值，这样做是为了更友好地使用缓存。

```py
sympy.integrals.meijerint._dummy_(name, token, **kwargs)
```

返回与名称和 token 关联的虚拟值。与全局声明效果相同。

```py
sympy.integrals.meijerint._eval_cond(cond)
```

重新评估条件。

```py
sympy.integrals.meijerint._exponents(expr, x)
```

在 `expr` 中找到 `x` 的指数（不包括零）。

示例

```py
>>> from sympy.integrals.meijerint import _exponents
>>> from sympy.abc import x, y
>>> from sympy import sin
>>> _exponents(x, x)
{1}
>>> _exponents(x**2, x)
{2}
>>> _exponents(x**2 + x, x)
{1, 2}
>>> _exponents(x**3*sin(x + x**y) + 1/x, x)
{-1, 1, 3, y} 
```

```py
sympy.integrals.meijerint._find_splitting_points(expr, x)
```

找到使得线性替换 x -> x + a（希望）简化表达式的数字 a。

示例

```py
>>> from sympy.integrals.meijerint import _find_splitting_points as fsp
>>> from sympy import sin
>>> from sympy.abc import x
>>> fsp(x, x)
{0}
>>> fsp((x-1)**3, x)
{1}
>>> fsp(sin(x+3)*x, x)
{-3, 0} 
```

```py
sympy.integrals.meijerint._flip_g(g)
```

将 G 函数转换为其逆参数之一（即 G(1/x) -> G’(x)）。

```py
sympy.integrals.meijerint._functions(expr, x)
```

找到 expr 中函数的类型，以估计其复杂性。

```py
sympy.integrals.meijerint._get_coeff_exp(expr, x)
```

当 expr 已知为形式 c*x**b 时，其中 c 和/或 b 可能为 1 时，返回 c, b。

示例

```py
>>> from sympy.abc import x, a, b
>>> from sympy.integrals.meijerint import _get_coeff_exp
>>> _get_coeff_exp(a*x**b, x)
(a, b)
>>> _get_coeff_exp(x, x)
(1, 1)
>>> _get_coeff_exp(2*x, x)
(2, 1)
>>> _get_coeff_exp(x**3, x)
(1, 3) 
```

```py
sympy.integrals.meijerint._guess_expansion(f, x)
```

尝试猜测积分被 f(x) 重写的合理方式。

```py
sympy.integrals.meijerint._inflate_fox_h(g, a)
```

设 d 表示 G 函数 `g` 的被积函数。考虑以相同方式定义的函数 H，但积分变为 d/Gamma(a*s)（遵循通常的轮廓惯例）。

如果 `a` 是有理数，则函数 H 可以写成 C*G，其中 C 是常数，G 函数是 G。

此函数返回 C, G。

```py
sympy.integrals.meijerint._inflate_g(g, n)
```

返回 C, h，使得 h 是参数 z**n 的 G 函数，且 g = C*h。

```py
sympy.integrals.meijerint._int0oo(g1, g2, x)
```

用 G 函数表示从零到无穷大的积分 g1*g2，假设满足必要条件。

示例

```py
>>> from sympy.integrals.meijerint import _int0oo
>>> from sympy.abc import s, t, m
>>> from sympy import meijerg, S
>>> g1 = meijerg([], [], [-S(1)/2, 0], [], s**2*t/4)
>>> g2 = meijerg([], [], [m/2], [-m/2], t/4)
>>> _int0oo(g1, g2, t)
4*meijerg(((0, 1/2), ()), ((m/2,), (-m/2,)), s**(-2))/s**2 
```

```py
sympy.integrals.meijerint._int0oo_1(g, x)
```

使用 G 函数计算 \(\int_0^\infty g\, dx\)，假设满足必要条件。

示例

```py
>>> from sympy.abc import a, b, c, d, x, y
>>> from sympy import meijerg
>>> from sympy.integrals.meijerint import _int0oo_1
>>> _int0oo_1(meijerg([a], [b], [c], [d], x*y), x)
gamma(-a)*gamma(c + 1)/(y*gamma(-d)*gamma(b + 1)) 
```

```py
sympy.integrals.meijerint._int_inversion(g, x, t)
```

计算拉普拉斯反演积分，假设公式适用。

```py
sympy.integrals.meijerint._is_analytic(f, x)
```

检查在正实数上使用 G 函数表示的 f(x) 是否实际上几乎处处与 G 函数相符。

```py
sympy.integrals.meijerint._meijerint_definite_2(f, x)
```

尝试从零到无穷大积分 f dx。

此函数的主体计算 f 的各种简化形式（例如通过调用 expand_mul()、trigexpand() - 见 _guess_expansion），并依次调用 _meijerint_definite_3。如果 _meijerint_definite_3 在任何简化函数上成功，则返回此结果。

```py
sympy.integrals.meijerint._meijerint_definite_3(f, x)
```

尝试从零到无穷大积分 f dx。

此函数调用 _meijerint_definite_4 尝试计算积分。如果失败，则尝试使用线性性。

```py
sympy.integrals.meijerint._meijerint_definite_4(f, x, only_double=False)
```

尝试从零到无穷大积分 f dx。

解释

此函数尝试应用文献中找到的积分定理，即尝试将 f 重写为一个或两个 G 函数的乘积。

参数 `only_double` 在递归算法中内部使用，以禁止将 f 试图重写为单个 G 函数。

```py
sympy.integrals.meijerint._meijerint_indefinite_1(f, x)
```

不尝试任何替换的辅助函数。

```py
sympy.integrals.meijerint._mul_args(f)
```

返回一个列表 `L`，使得 `Mul(*L) == f`。

如果 `f` 不是 `Mul` 或 `Pow`，`L=[f]`。如果 `f=g**n`，其中 n 是整数，`L=[g]*n`。如果 `f` 是 `Mul`，`L` 来自将 `_mul_args` 应用于 f 的所有因子。

```py
sympy.integrals.meijerint._mul_as_two_parts(f)
```

找到将 `f` 拆分为两项乘积的所有方式。失败时返回 None。

解释

尽管从 multiset_partitions 中的规范顺序来看，这不一定是处理项的最佳顺序。例如，如果去掉 len(gs) == 2 的情况，并允许 multiset 对项进行排序，某些测试会失败。

示例

```py
>>> from sympy.integrals.meijerint import _mul_as_two_parts
>>> from sympy import sin, exp, ordered
>>> from sympy.abc import x
>>> list(ordered(_mul_as_two_parts(x*sin(x)*exp(x))))
[(x, exp(x)*sin(x)), (x*exp(x), sin(x)), (x*sin(x), exp(x))] 
```

```py
sympy.integrals.meijerint._my_principal_branch(expr, period, full_pb=False)
```

通过去除多余的因子将 expr 接近其主分支。此函数不保证产生主分支，以避免引入不透明的 principal_branch() 对象，除非 full_pb=True。

```py
sympy.integrals.meijerint._mytype(f: Basic, x: Symbol) → tuple[type[Basic], ...]
```

创建描述 f 类型的可哈希实体。

```py
sympy.integrals.meijerint._rewrite1(f, x, recursive=True)
```

尝试使用参数 a*x**b 的单个 G 函数（或其和）重写 `f`。返回 fac, po, g，使得 f = fac*po*g，其中 fac 独立于 `x`，po = x**s。这里的 g 是 _rewrite_single 的结果。失败时返回 None。

```py
sympy.integrals.meijerint._rewrite2(f, x)
```

尝试将 `f` 重写为参数为 a*x**b 的两个 G 函数的乘积。返回 fac, po, g1, g2，使得 f = fac*po*g1*g2，其中 fac 独立于 x，po = x**s。这里的 g1 和 g2 是 _rewrite_single 的结果。失败时返回 None。

```py
sympy.integrals.meijerint._rewrite_inversion(fac, po, g, x)
```

吸收 `po` == x**s 到 g 中。

```py
sympy.integrals.meijerint._rewrite_saxena(fac, po, g1, g2, x, full_pb=False)
```

在参数为 `c*x` 的 G 函数项中，将从 0 到 oo 的积分 `fac*po*g1*g2` 重写为积分 `fac*G`。

解释

返回 C, f1, f2，使得从 0 到无穷大的积分 C f1 f2 等于从 0 到无穷大的积分 fac `po`, `g1`, `g2`。

示例

```py
>>> from sympy.integrals.meijerint import _rewrite_saxena
>>> from sympy.abc import s, t, m
>>> from sympy import meijerg
>>> g1 = meijerg([], [], [0], [], s*t)
>>> g2 = meijerg([], [], [m/2], [-m/2], t**2/4)
>>> r = _rewrite_saxena(1, t**0, g1, g2, t)
>>> r[0]
s/(4*sqrt(pi))
>>> r[1]
meijerg(((), ()), ((-1/2, 0), ()), s**2*t/4)
>>> r[2]
meijerg(((), ()), ((m/2,), (-m/2,)), t/4) 
```

```py
sympy.integrals.meijerint._rewrite_saxena_1(fac, po, g, x)
```

将从零到无穷大的积分 fac*po*g dx 重写为积分 fac*G，其中 G 的参数为 a*x。注意 po=x**s。返回 fac, G。

```py
sympy.integrals.meijerint._rewrite_single(f, x, recursive=True)
```

尝试将 f 重写为形式为 C*x**s*G(a*x**b) 的单个 G 函数的和，其中 b 是有理数且 C 与 x 无关。我们保证 result.argument.as_coeff_mul(x) 返回 (a, (x**b,)) 或 (a, ())。在失败时返回空列表。

```py
sympy.integrals.meijerint._split_mul(f, x)
```

将表达式 `f` 拆分为 fac、po、g，其中 fac 是常数因子，po = x**s（其中 s 与 s 独立）且 g 是“其余部分”。

示例

```py
>>> from sympy.integrals.meijerint import _split_mul
>>> from sympy import sin
>>> from sympy.abc import s, x
>>> _split_mul((3*x)**s*sin(x**2)*x, x)
(3**s, x*x**s, sin(x**2)) 
```

```py
sympy.integrals.meijerint.meijerint_definite(f, x, a, b)
```

对 `f` 在区间 [`a`, `b`] 上进行积分，通过将其重写为两个 G 函数的乘积或一个单一的 G 函数。

返回 res、cond，其中 cond 是收敛条件。

示例

```py
>>> from sympy.integrals.meijerint import meijerint_definite
>>> from sympy import exp, oo
>>> from sympy.abc import x
>>> meijerint_definite(exp(-x**2), x, -oo, oo)
(sqrt(pi), True) 
```

此函数实现为 meijerint_definite、_meijerint_definite_2、_meijerint_definite_3、_meijerint_definite_4 的一系列函数。列表中的每个函数多次调用下一个函数（可能）。这意味着调用 meijerint_definite 可能非常昂贵。

```py
sympy.integrals.meijerint.meijerint_indefinite(f, x)
```

通过将 `f` 重写为 G 函数的形式计算不定积分。

示例

```py
>>> from sympy.integrals.meijerint import meijerint_indefinite
>>> from sympy import sin
>>> from sympy.abc import x
>>> meijerint_indefinite(sin(x), x)
-cos(x) 
```

```py
sympy.integrals.meijerint.meijerint_inversion(f, x, t)
```

计算逆拉普拉斯变换 \(\int_{c+i\infty}^{c-i\infty} f(x) e^{tx}\, dx\)，其中 c 是大于 `f` 的所有奇点的实部的实数。

注意 `t` 始终假定为实数且为正数。

如果积分不存在或无法评估，则返回 None。

示例

```py
>>> from sympy.abc import x, t
>>> from sympy.integrals.meijerint import meijerint_inversion
>>> meijerint_inversion(1/x, x, t)
Heaviside(t) 
```
