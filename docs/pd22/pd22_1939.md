# 0.25.0 中的新功能（2019 年 7 月 18 日）

> 原文：[`pandas.pydata.org/docs/whatsnew/v0.25.0.html`](https://pandas.pydata.org/docs/whatsnew/v0.25.0.html)

警告

从 0.25.x 系列版本开始，pandas 仅支持 Python 3.5.3 及更高版本。详见 [放弃 Python 2.7](https://pandas.pydata.org/pandas-docs/version/0.24/install.html#install-dropping-27) 获取更多细节。

警告

最低支持的 Python 版本将在未来的发布中提升至 3.6。

警告

`Panel` 已被完全移除。对于 N-D 标记数据结构，请使用 [xarray](https://xarray.pydata.org/en/stable/)

警告

`read_pickle()` 和 `read_msgpack()` 仅向后兼容至 pandas 版本 0.20.3 ([GH 27082](https://github.com/pandas-dev/pandas/issues/27082))。

这些是 pandas 0.25.0 的变化。详见发布说明以获取包括其他版本的完整更改日志。

## 增强

### 带重命名的 GroupBy 聚合

pandas 添加了特殊的分组行为，称为“命名聚合”，用于在应用多个聚合函数到特定列时命名输出列（[GH 18366](https://github.com/pandas-dev/pandas/issues/18366), [GH 26512](https://github.com/pandas-dev/pandas/issues/26512)）。

```py
In [1]: animals = pd.DataFrame({'kind': ['cat', 'dog', 'cat', 'dog'],
 ...:                        'height': [9.1, 6.0, 9.5, 34.0],
 ...:                        'weight': [7.9, 7.5, 9.9, 198.0]})
 ...: 

In [2]: animals
Out[2]: 
 kind  height  weight
0  cat     9.1     7.9
1  dog     6.0     7.5
2  cat     9.5     9.9
3  dog    34.0   198.0

[4 rows x 3 columns]

In [3]: animals.groupby("kind").agg(
 ...:    min_height=pd.NamedAgg(column='height', aggfunc='min'),
 ...:    max_height=pd.NamedAgg(column='height', aggfunc='max'),
 ...:    average_weight=pd.NamedAgg(column='weight', aggfunc="mean"),
 ...: )
 ...: 
Out[3]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

将所需的列名称作为 `**kwargs` 传递给 `.agg`。`**kwargs` 的值应为元组，其中第一个元素是列选择，第二个元素是要应用的聚合函数。pandas 提供了 `pandas.NamedAgg` 命名元组以使函数的参数更清晰，但也接受普通元组。

```py
In [4]: animals.groupby("kind").agg(
 ...:    min_height=('height', 'min'),
 ...:    max_height=('height', 'max'),
 ...:    average_weight=('weight', 'mean'),
 ...: )
 ...: 
Out[4]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

命名聚合是被推荐用于取代已弃用的“字典-字典”方法来命名列特定聚合输出的方法（弃用 groupby.agg() 与字典的重命名）。

现在，对于 Series groupby 对象也可用类似的方法。因为不需要列选择，所以值可以是要应用的函数。

```py
In [5]: animals.groupby("kind").height.agg(
 ...:    min_height="min",
 ...:    max_height="max",
 ...: )
 ...: 
Out[5]: 
 min_height  max_height
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns] 
```

这种类型的聚合是将字典传递给 Series groupby 聚合时的推荐替代方法（弃用 groupby.agg() 与字典的重命名）。

更多详情见命名聚合。### 带多个 lambda 的 GroupBy 聚合

现在可以在 `GroupBy.agg` 中向列表形式的聚合提供多个 lambda 函数（[GH 26430](https://github.com/pandas-dev/pandas/issues/26430)）。

```py
In [6]: animals.groupby('kind').height.agg([
 ...:    lambda x: x.iloc[0], lambda x: x.iloc[-1]
 ...: ])
 ...: 
Out[6]: 
 <lambda_0>  <lambda_1>
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns]

In [7]: animals.groupby('kind').agg([
 ...:    lambda x: x.iloc[0] - x.iloc[1],
 ...:    lambda x: x.iloc[0] + x.iloc[1]
 ...: ])
 ...: 
Out[7]: 
 height                weight 
 <lambda_0> <lambda_1> <lambda_0> <lambda_1>
kind 
cat        -0.4       18.6       -2.0       17.8
dog       -28.0       40.0     -190.5      205.5

[2 rows x 4 columns] 
```

以前，这些会引发 `SpecificationError`。### 更好的 MultiIndex 表示形式

打印 `MultiIndex` 实例现在显示每行的元组，并确保元组项在垂直方向上对齐，因此现在更容易理解 `MultiIndex` 的结构。([GH 13480](https://github.com/pandas-dev/pandas/issues/13480))：

现在的显示形式如下：

```py
In [8]: pd.MultiIndex.from_product([['a', 'abc'], range(500)])
Out[8]: 
MultiIndex([(  'a',   0),
 (  'a',   1),
 (  'a',   2),
 (  'a',   3),
 (  'a',   4),
 (  'a',   5),
 (  'a',   6),
 (  'a',   7),
 (  'a',   8),
 (  'a',   9),
 ...
 ('abc', 490),
 ('abc', 491),
 ('abc', 492),
 ('abc', 493),
 ('abc', 494),
 ('abc', 495),
 ('abc', 496),
 ('abc', 497),
 ('abc', 498),
 ('abc', 499)],
 length=1000) 
```

以前，打印 `MultiIndex` 会显示所有 `MultiIndex` 的 `levels` 和 `codes`，这在视觉上不够吸引人，并且使得输出更难以导航。例如（将范围限制为 5）：

```py
In [1]: pd.MultiIndex.from_product([['a', 'abc'], range(5)])
Out[1]: MultiIndex(levels=[['a', 'abc'], [0, 1, 2, 3]],
 ...:           codes=[[0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 2, 3, 0, 1, 2, 3]]) 
```

在新的显示中，如果行数小于 `options.display.max_seq_items`（默认为 100 项），则将显示所有值。水平方向上，如果输出超过 `options.display.width`（默认为 80 个字符），则会截断。 ### 更短的 Series 和 DataFrame 的截断显示

目前，pandas 的默认显示选项保证了当 Series 或 DataFrame 的行数超过 60 行时，其显示会被截断到最多 60 行（`display.max_rows` 选项）。然而，这依然占据了大量垂直屏幕空间。因此，引入了一个新的选项 `display.min_rows`，默认为 10，确定了在截断的显示中显示的行数：

+   对于较小的 Series 或 DataFrame，显示最多 `max_rows` 行（默认为 60 行）。

+   对于长度超过 `max_rows` 的较大 Series 或 DataFrame，只显示 `min_rows` 行（默认为 10，即第一行和最后 5 行）。

这种双重选项允许仍然可以看到相对较小对象的完整内容（例如 `df.head(20)` 显示所有 20 行），同时对于大对象给出简要的显示。

要恢复以前的单一阈值行为，请将 `pd.options.display.min_rows = None`。 ### 带有 max_level 参数支持的 JSON 规范化

`json_normalize()` 函数将提供的输入字典规范化到所有嵌套级别。新的 `max_level` 参数提供了更多控制规范化结束级别的选项（[GH 23843](https://github.com/pandas-dev/pandas/issues/23843)）：

现在的显示形式如下：

```py
from pandas.io.json import json_normalize
data = [{
    'CreatedBy': {'Name': 'User001'},
    'Lookup': {'TextField': 'Some text',
               'UserField': {'Id': 'ID001', 'Name': 'Name001'}},
    'Image': {'a': 'b'}
}]
json_normalize(data, max_level=1) 
```  ### Series.explode 用于将类似列表的值拆分为行

`Series` 和 `DataFrame` 方法已经新增了 `DataFrame.explode()` 方法，以将类似列表的数据转换为单独的行。详见文档中的 Exploding list-like column 部分了解更多信息（[GH 16538](https://github.com/pandas-dev/pandas/issues/16538)，[GH 10511](https://github.com/pandas-dev/pandas/issues/10511)）

这里是一个典型的用例。你在一列中有逗号分隔的字符串。

```py
In [9]: df = pd.DataFrame([{'var1': 'a,b,c', 'var2': 1},
 ...:                   {'var1': 'd,e,f', 'var2': 2}])
 ...: 

In [10]: df
Out[10]: 
 var1  var2
0  a,b,c     1
1  d,e,f     2

[2 rows x 2 columns] 
```

使用链式操作现在可以轻松创建长格式的 `DataFrame`

```py
In [11]: df.assign(var1=df.var1.str.split(',')).explode('var1')
Out[11]: 
 var1  var2
0    a     1
0    b     1
0    c     1
1    d     2
1    e     2
1    f     2

[6 rows x 2 columns] 
```  ### 其他增强

+   `DataFrame.plot()` 关键字 `logy`、`logx` 和 `loglog` 现在可以接受值 `'sym'` 以进行对数对数缩放。([GH 24867](https://github.com/pandas-dev/pandas/issues/24867))

+   在使用 `to_datetime()` 解析日期时间时，增加了对 ISO 周年格式（‘%G-%V-%u’）的支持（[GH 16607](https://github.com/pandas-dev/pandas/issues/16607)）

+   `DataFrame` 和 `Series` 的索引现在接受零维 `np.ndarray`（[GH 24919](https://github.com/pandas-dev/pandas/issues/24919)）

+   `Timestamp.replace()` 现在支持 `fold` 参数以消除 DST 转换时间的歧义性（[GH 25017](https://github.com/pandas-dev/pandas/issues/25017)）

+   `DataFrame.at_time()` 和 `Series.at_time()` 现在支持带有时区的 [`datetime.time`](https://docs.python.org/3/library/datetime.html#datetime.time "(在 Python v3.12 中)") 对象（[GH 24043](https://github.com/pandas-dev/pandas/issues/24043)）

+   `DataFrame.pivot_table()` 现在接受一个 `observed` 参数，该参数传递给底层的 `DataFrame.groupby()` 调用，以加速分组分类数据。（[GH 24923](https://github.com/pandas-dev/pandas/issues/24923)）

+   `Series.str` 已经增加了 `Series.str.casefold()` 方法，以移除字符串中的所有大小写区别（[GH 25405](https://github.com/pandas-dev/pandas/issues/25405)）

+   `DataFrame.set_index()` 现在适用于 `abc.Iterator` 实例，只要它们的输出与调用帧的长度相同即可（[GH 22484](https://github.com/pandas-dev/pandas/issues/22484), [GH 24984](https://github.com/pandas-dev/pandas/issues/24984)）

+   `DatetimeIndex.union()` 现在支持 `sort` 参数。sort 参数的行为与 `Index.union()` 一致（[GH 24994](https://github.com/pandas-dev/pandas/issues/24994)）

+   `RangeIndex.union()` 现在支持 `sort` 参数。 如果 `sort=False`，则始终返回未排序的 `Int64Index`。 `sort=None` 是默认值，如果可能，则返回单调递增的 `RangeIndex`，如果不可能则返回排序的 `Int64Index` ([GH 24471](https://github.com/pandas-dev/pandas/issues/24471))

+   `TimedeltaIndex.intersection()` 现在还支持 `sort` 关键字 ([GH 24471](https://github.com/pandas-dev/pandas/issues/24471))

+   `DataFrame.rename()` 现在支持 `errors` 参数，在尝试重命名不存在的键时引发错误（[GH 13473](https://github.com/pandas-dev/pandas/issues/13473)）

+   添加了稀疏访问器，用于处理值为稀疏的 `DataFrame` ([GH 25681](https://github.com/pandas-dev/pandas/issues/25681))

+   `RangeIndex` 增加了 `start`、`stop` 和 `step` 属性 ([GH 25710](https://github.com/pandas-dev/pandas/issues/25710))

+   [`datetime.timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone "(在 Python v3.12 中)") 对象现在作为时区方法和构造函数的参数得到支持 ([GH 25065](https://github.com/pandas-dev/pandas/issues/25065))

+   `DataFrame.query()` 和 `DataFrame.eval()` 现在支持使用反引号引用具有空格的列名 ([GH 6508](https://github.com/pandas-dev/pandas/issues/6508))

+   `merge_asof()` 现在在合并键为不相等的分类变量时提供更清晰的错误消息 ([GH 26136](https://github.com/pandas-dev/pandas/issues/26136))

+   `Rolling()` 支持指数（或泊松）窗口类型 ([GH 21303](https://github.com/pandas-dev/pandas/issues/21303))

+   对于缺少所需导入的错误消息现在包括原始导入错误的文本 ([GH 23868](https://github.com/pandas-dev/pandas/issues/23868))

+   `DatetimeIndex` 和 `TimedeltaIndex` 现在具有 `mean` 方法 ([GH 24757](https://github.com/pandas-dev/pandas/issues/24757))

+   `DataFrame.describe()` 现在格式化整数百分位数时不带小数点 ([GH 26660](https://github.com/pandas-dev/pandas/issues/26660))

+   添加了使用 `read_spss()` 读取 SPSS .sav 文件的支持 ([GH 26537](https://github.com/pandas-dev/pandas/issues/26537))

+   添加了新选项 `plotting.backend`，可以选择与现有的 `matplotlib` 不同的绘图后端。使用 `pandas.set_option('plotting.backend', '<backend-module>')`，其中 `<backend-module>` 是实现 pandas 绘图 API 的库 ([GH 14130](https://github.com/pandas-dev/pandas/issues/14130))

+   `pandas.offsets.BusinessHour` 支持多个开放时间间隔 ([GH 15481](https://github.com/pandas-dev/pandas/issues/15481))

+   `read_excel()` 现在可以使用 `openpyxl` 通过 `engine='openpyxl'` 参数读取 Excel 文件。这将在将来的版本中成为默认设置 ([GH 11499](https://github.com/pandas-dev/pandas/issues/11499))

+   `pandas.io.excel.read_excel()` 支持读取 OpenDocument 表格。指定 `engine='odf'` 来启用。请参阅 IO 用户指南获取更多详情 ([GH 9070](https://github.com/pandas-dev/pandas/issues/9070))

+   `Interval`，`IntervalIndex` 和 `IntervalArray` 增加了 `is_empty` 属性，表示给定的区间是否为空 ([GH 27219](https://github.com/pandas-dev/pandas/issues/27219))  ## 向后不兼容的 API 更改

### 使用带有 UTC 偏移的日期字符串进行索引

使用带有 UTC 偏移的日期字符串对 `DataFrame` 或 `Series` 进行索引，先前会忽略 UTC 偏移。现在，索引中将尊重 UTC 偏移。 ([GH 24076](https://github.com/pandas-dev/pandas/issues/24076), [GH 16785](https://github.com/pandas-dev/pandas/issues/16785))

```py
In [12]: df = pd.DataFrame([0], index=pd.DatetimeIndex(['2019-01-01'], tz='US/Pacific'))

In [13]: df
Out[13]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```

*先前的行为*:

```py
In [3]: df['2019-01-01 00:00:00+04:00':'2019-01-01 01:00:00+04:00']
Out[3]:
 0
2019-01-01 00:00:00-08:00  0 
```

*新行为*:

```py
In [14]: df['2019-01-01 12:00:00+04:00':'2019-01-01 13:00:00+04:00']
Out[14]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```  ### 从级别和代码构建的 `MultiIndex`

使用 `NaN` 级别或代码值 < -1 构造 `MultiIndex` 先前是允许的。现在，不允许使用代码值 < -1 进行构造，并且 `NaN` 级别的相应代码将被重新分配为 -1\. ([GH 19387](https://github.com/pandas-dev/pandas/issues/19387))

*先前行为*:

```py
In [1]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ...:              codes=[[0, -1, 1, 2, 3, 4]])
 ...:
Out[1]: MultiIndex(levels=[[nan, None, NaT, 128, 2]],
 codes=[[0, -1, 1, 2, 3, 4]])

In [2]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
Out[2]: MultiIndex(levels=[[1, 2]],
 codes=[[0, -2]]) 
```

*新行为*:

```py
In [15]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ....:              codes=[[0, -1, 1, 2, 3, 4]])
 ....: 
Out[15]: 
MultiIndex([(nan,),
 (nan,),
 (nan,),
 (nan,),
 (128,),
 (  2,)],
 )

In [16]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
---------------------------------------------------------------------------
ValueError  Traceback (most recent call last)
Cell In[16], line 1
----> 1 pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:364, in MultiIndex.__new__(cls, levels, codes, sortorder, names, dtype, copy, name, verify_integrity)
  361     result.sortorder = sortorder
  363 if verify_integrity:
--> 364     new_codes = result._verify_integrity()
  365     result._codes = new_codes
  367 result._reset_identity()

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:451, in MultiIndex._verify_integrity(self, codes, levels, levels_to_verify)
  445     raise ValueError(
  446         f"On level {i}, code max ({level_codes.max()}) >= length of "
  447         f"level ({len(level)}). NOTE: this index is in an "
  448         "inconsistent state"
  449     )
  450 if len(level_codes) and level_codes.min() < -1:
--> 451     raise ValueError(f"On level {i}, code value ({level_codes.min()}) < -1")
  452 if not level.is_unique:
  453     raise ValueError(
  454         f"Level values must be unique: {list(level)} on level {i}"
  455     )

ValueError: On level 0, code value (-2) < -1 
```  ### `GroupBy.apply` 在 `DataFrame` 上只评估第一组一次

先前的 `DataFrameGroupBy.apply()` 实现在第一组上一致评估提供的函数两次，以推断是否可以使用快速代码路径。特别是对于具有副作用的函数，这是一种不希望的行为，可能会导致意外。 ([GH 2936](https://github.com/pandas-dev/pandas/issues/2936), [GH 2656](https://github.com/pandas-dev/pandas/issues/2656), [GH 7739](https://github.com/pandas-dev/pandas/issues/7739), [GH 10519](https://github.com/pandas-dev/pandas/issues/10519), [GH 12155](https://github.com/pandas-dev/pandas/issues/12155), [GH 20084](https://github.com/pandas-dev/pandas/issues/20084), [GH 21417](https://github.com/pandas-dev/pandas/issues/21417))

现在每个组只评估一次。

```py
In [17]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [18]: df
Out[18]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns]

In [19]: def func(group):
 ....:    print(group.name)
 ....:    return group
 ....: 
```

*先前行为*:

```py
In [3]: df.groupby('a').apply(func)
x
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*:

```py
In [3]: df.groupby('a').apply(func)
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

### 连接稀疏值

当传递值为稀疏的 DataFrame 时，`concat()` 现在将返回具有稀疏值的 `Series` 或 `DataFrame`，而不是 `SparseDataFrame` ([GH 25702](https://github.com/pandas-dev/pandas/issues/25702))。

```py
In [20]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 1])}) 
```

*先前行为*:

```py
In [2]: type(pd.concat([df, df]))
pandas.core.sparse.frame.SparseDataFrame 
```

*新行为*:

```py
In [21]: type(pd.concat([df, df]))
Out[21]: pandas.core.frame.DataFrame 
```

现在这与具有稀疏值的 `Series` 上的 `concat` 的现有行为相匹配。当所有值都是 `SparseDataFrame` 的实例时，`concat()` 将继续返回 `SparseDataFrame`。

此更改还影响了内部使用 `concat()` 的例程，例如 `get_dummies()`，现在在所有情况下返回 `DataFrame`（如果所有列都是虚拟编码，则以前返回 `SparseDataFrame`，否则返回 `DataFrame`）。

将任何`SparseSeries`或`SparseDataFrame`提供给`concat()`将导致返回`SparseSeries`或`SparseDataFrame`，与以前一样。

### `.str`-访问器执行更严格的类型检查

由于缺乏更细粒度的 dtype，`Series.str`目前只检查数据是否为`object` dtype。`Series.str`现在将在系列内推断 dtype 数据；特别是，仅有`'bytes'`数据将引发异常（除了`Series.str.decode()`, `Series.str.get()`, `Series.str.len()`, `Series.str.slice()`)，参见 [GH 23163](https://github.com/pandas-dev/pandas/issues/23163), [GH 23011](https://github.com/pandas-dev/pandas/issues/23011), [GH 23551](https://github.com/pandas-dev/pandas/issues/23551)。

*以前的行为*:

```py
In [1]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [2]: s
Out[2]:
0      b'a'
1     b'ba'
2    b'cba'
dtype: object

In [3]: s.str.startswith(b'a')
Out[3]:
0     True
1    False
2    False
dtype: bool 
```

*新行为*:

```py
In [22]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [23]: s
Out[23]: 
0      b'a'
1     b'ba'
2    b'cba'
Length: 3, dtype: object

In [24]: s.str.startswith(b'a')
---------------------------------------------------------------------------
TypeError  Traceback (most recent call last)
Cell In[24], line 1
----> 1 s.str.startswith(b'a')

File ~/work/pandas/pandas/pandas/core/strings/accessor.py:136, in forbid_nonstring_types.<locals>._forbid_nonstring_types.<locals>.wrapper(self, *args, **kwargs)
  131 if self._inferred_dtype not in allowed_types:
  132     msg = (
  133         f"Cannot use .str.{func_name} with values of "
  134         f"inferred dtype '{self._inferred_dtype}'."
  135     )
--> 136     raise TypeError(msg)
  137 return func(self, *args, **kwargs)

TypeError: Cannot use .str.startswith with values of inferred dtype 'bytes'. 
```

### 分类 dtype 在 GroupBy 期间得以保留

以前，作为分类的列，但不是 groupby 键的列，在 groupby 操作期间将转换为`object` dtype。现在，pandas 将保留这些 dtype。 ([GH 18502](https://github.com/pandas-dev/pandas/issues/18502))

```py
In [25]: cat = pd.Categorical(["foo", "bar", "bar", "qux"], ordered=True)

In [26]: df = pd.DataFrame({'payload': [-1, -2, -1, -2], 'col': cat})

In [27]: df
Out[27]: 
 payload  col
0       -1  foo
1       -2  bar
2       -1  bar
3       -2  qux

[4 rows x 2 columns]

In [28]: df.dtypes
Out[28]: 
payload       int64
col        category
Length: 2, dtype: object 
```

*以前的行为*:

```py
In [5]: df.groupby('payload').first().col.dtype
Out[5]: dtype('O') 
```

*新行为*:

```py
In [29]: df.groupby('payload').first().col.dtype
Out[29]: CategoricalDtype(categories=['bar', 'foo', 'qux'], ordered=True, categories_dtype=object) 
```  ### 不兼容的索引类型联合

当在不兼容 dtype 的对象之间执行`Index.union()`操作时，结果将是 dtype 为`object`的基本`Index`。对于以前将被禁止的`Index`对象之间的联合，此行为仍然有效。在执行联合操作之前，空`Index`对象的 dtype 现在将被评估，而不是简单地返回另一个`Index`对象。`Index.union()`现在可以被认为是可交换的，即`A.union(B) == B.union(A)` ([GH 23525](https://github.com/pandas-dev/pandas/issues/23525))。

*以前的行为*:

```py
In [1]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
...
ValueError: can only call with other PeriodIndex-ed objects

In [2]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[2]: Int64Index([1, 2, 3], dtype='int64') 
```

*新行为*:

```py
In [3]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
Out[3]: Index([1991-09-05, 1991-09-06, 1, 2, 3], dtype='object')
In [4]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[4]: Index([1, 2, 3], dtype='object') 
```

请注意，整数和浮点数索引被视为“兼容”。 整数值被强制转换为浮点数，这可能会导致精度损失。 更多信息请参见索引对象上的集合操作。

### `DataFrame` GroupBy ffill/bfill 不再返回组标签

`DataFrameGroupBy`的`ffill`，`bfill`，`pad`和`backfill`方法以前在返回值中包括了组标签，这与其他 groupby 转换不一致。 现在只返回填充值。 ([GH 21521](https://github.com/pandas-dev/pandas/issues/21521))

```py
In [30]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [31]: df
Out[31]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns] 
```

*先前的行为*:

```py
In [3]: df.groupby("a").ffill()
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*:

```py
In [32]: df.groupby("a").ffill()
Out[32]: 
 b
0  1
1  2

[2 rows x 1 columns] 
```

### `DataFrame`在空分类/对象列上描述将返回 top 和 freq

当在空分类/对象列上调用[`DataFrame.describe()`]时，以前会省略“top”和“freq”列，这与非空列的输出不一致。 现在“top”和“freq”列将始终包括在内，如果是空的`DataFrame`，则为`numpy.nan`（[GH 26397](https://github.com/pandas-dev/pandas/issues/26397)）

```py
In [33]: df = pd.DataFrame({"empty_col": pd.Categorical([])})

In [34]: df
Out[34]: 
Empty DataFrame
Columns: [empty_col]
Index: []

[0 rows x 1 columns] 
```

*先前的行为*:

```py
In [3]: df.describe()
Out[3]:
        empty_col
count           0
unique          0 
```

*新行为*:

```py
In [35]: df.describe()
Out[35]: 
 empty_col
count          0
unique         0
top          NaN
freq         NaN

[4 rows x 1 columns] 
```

### `__str__`方法现在调用`__repr__`而不是相反

到目前为止，pandas 主要在 pandas 对象的`__str__`/`__unicode__`/`__bytes__`方法中定义了字符串表示，并且如果没有找到特定的`__repr__`方法，则从`__repr__`方法中调用`__str__`。 这对于 Python3 不是必要的。 在 pandas 0.25 中，现在通常在`__repr__`中定义了 pandas 对象的字符串表示，并且通常现在调用`__str__`会将调用传递给`__repr__`，如果不存在特定的`__str__`方法，这是 Python 的标准。 这种变化对于直接使用 pandas 是向后兼容的，但是如果您对 pandas 对象进行子类化*并且*为您的子类提供了特定的`__str__`/`__repr__`方法，则可能需要调整您的`__str__`/`__repr__`方法 ([GH 26495](https://github.com/pandas-dev/pandas/issues/26495)).

### 使用`Interval`对象对`IntervalIndex`进行索引

对于`IntervalIndex`，索引方法已修改为仅对`Interval`查询需要精确匹配。 `IntervalIndex`方法以前匹配任何重叠的`Interval`。 使用标量点，例如使用整数进行查询，行为不变 ([GH 16316](https://github.com/pandas-dev/pandas/issues/16316)).

```py
In [36]: ii = pd.IntervalIndex.from_tuples([(0, 4), (1, 5), (5, 8)])

In [37]: ii
Out[37]: IntervalIndex([(0, 4], (1, 5], (5, 8]], dtype='interval[int64, right]') 
```

`in`运算符(`__contains__`)现在仅对`IntervalIndex`中的`Intervals`进行精确匹配返回`True`，而以前对于任何与`IntervalIndex`中的`Interval`重叠的`Interval`都会返回`True`。

*先前的行为*:

```py
In [4]: pd.Interval(1, 2, closed='neither') in ii
Out[4]: True

In [5]: pd.Interval(-10, 10, closed='both') in ii
Out[5]: True 
```

*新行为*:

```py
In [38]: pd.Interval(1, 2, closed='neither') in ii
Out[38]: False

In [39]: pd.Interval(-10, 10, closed='both') in ii
Out[39]: False 
```

`get_loc()`��法现在只返回`Interval`查询的精确匹配位置，而不是之前返回重叠匹配的位置。如果找不到精确匹配，将引发`KeyError`。

*之前的行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: array([0, 1])

In [7]: ii.get_loc(pd.Interval(2, 6))
Out[7]: array([0, 1, 2]) 
```

*新行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: 1

In [7]: ii.get_loc(pd.Interval(2, 6))
---------------------------------------------------------------------------
KeyError: Interval(2, 6, closed='right') 
```

同样，`get_indexer()`和`get_indexer_non_unique()`也只会返回精确匹配的位置给`Interval`查询，`-1`表示未找到精确匹配。

这些索引更改扩展到使用`IntervalIndex`索引查询`Series`或`DataFrame`。

```py
In [40]: s = pd.Series(list('abc'), index=ii)

In [41]: s
Out[41]: 
(0, 4]    a
(1, 5]    b
(5, 8]    c
Length: 3, dtype: object 
```

使用`[]`（`__getitem__`）或`loc`从`Series`或`DataFrame`中选择现在只返回`Interval`查询的精确匹配。

*之前的行为*：

```py
In [8]: s[pd.Interval(1, 5)]
Out[8]:
(0, 4]    a
(1, 5]    b
dtype: object

In [9]: s.loc[pd.Interval(1, 5)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新行为*：

```py
In [42]: s[pd.Interval(1, 5)]
Out[42]: 'b'

In [43]: s.loc[pd.Interval(1, 5)]
Out[43]: 'b' 
```

类似地，对于非精确匹配，将引发`KeyError`而不是返回重叠匹配。

*之前的行为*：

```py
In [9]: s[pd.Interval(2, 3)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object

In [10]: s.loc[pd.Interval(2, 3)]
Out[10]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新行为*：

```py
In [6]: s[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right')

In [7]: s.loc[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right') 
```

`overlaps()`方法可用于创建一个布尔索引器，复制之前返回重叠匹配的行为。

*新行为*：

```py
In [44]: idxr = s.index.overlaps(pd.Interval(2, 3))

In [45]: idxr
Out[45]: array([ True,  True, False])

In [46]: s[idxr]
Out[46]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object

In [47]: s.loc[idxr]
Out[47]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object 
```  ### Series 上的二进制 ufunc 现在对齐

现在应用类似`numpy.power()`这样的二进制 ufunc 时，当两者都是`Series`时会对齐输入（[GH 23293](https://github.com/pandas-dev/pandas/issues/23293)）。

```py
In [48]: s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s2 = pd.Series([3, 4, 5], index=['d', 'c', 'b'])

In [50]: s1
Out[50]: 
a    1
b    2
c    3
Length: 3, dtype: int64

In [51]: s2
Out[51]: 
d    3
c    4
b    5
Length: 3, dtype: int64 
```

*之前的行为*

```py
In [5]: np.power(s1, s2)
Out[5]:
a      1
b     16
c    243
dtype: int64 
```

*新行为*

```py
In [52]: np.power(s1, s2)
Out[52]: 
a     1.0
b    32.0
c    81.0
d     NaN
Length: 4, dtype: float64 
```

这与 pandas 中其他二进制操作的行为相匹配，如`Series.add()`。要保留之前的行为，请在应用 ufunc 之前将另一个`Series`转换为数组。

```py
In [53]: np.power(s1, s2.array)
Out[53]: 
a      1
b     16
c    243
Length: 3, dtype: int64 
```

### Categorical.argsort 现在将缺失值放在末尾

`Categorical.argsort()`现在将缺失值放在数组末尾，使其与 NumPy 和 pandas 的其余部分保持一致（[GH 21801](https://github.com/pandas-dev/pandas/issues/21801)）。

```py
In [54]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True) 
```

*之前的行为*

```py
In [2]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True)

In [3]: cat.argsort()
Out[3]: array([1, 2, 0])

In [4]: cat[cat.argsort()]
Out[4]:
[NaN, a, b]
categories (2, object): [a < b] 
```

*新行为*

```py
In [55]: cat.argsort()
Out[55]: array([2, 0, 1])

In [56]: cat[cat.argsort()]
Out[56]: 
['a', 'b', NaN]
Categories (2, object): ['a' < 'b'] 
```

### 传递字典列表给 DataFrame 时列顺序被保留

从 Python 3.7 开始，`dict`的键顺序是[有保证的](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)。实际上，自 Python 3.6 起就是如此。`DataFrame`构造函数现在将字典列表视为`OrderedDict`列表处理，即保留字典的顺序。此更改仅在 pandas 在 Python>=3.6 上运行时适用（[GH 27309](https://github.com/pandas-dev/pandas/issues/27309)）。

```py
In [57]: data = [
 ....:    {'name': 'Joe', 'state': 'NY', 'age': 18},
 ....:    {'name': 'Jane', 'state': 'KY', 'age': 19, 'hobby': 'Minecraft'},
 ....:    {'name': 'Jean', 'state': 'OK', 'age': 20, 'finances': 'good'}
 ....: ]
 ....: 
```

*之前的行为*:

以前按词典顺序对列进行了排序，

```py
In [1]: pd.DataFrame(data)
Out[1]:
   age finances      hobby  name state
0   18      NaN        NaN   Joe    NY
1   19      NaN  Minecraft  Jane    KY
2   20     good        NaN  Jean    OK 
```

*新行为*:

现在的列顺序与`dict`中键的插入顺序相匹配，考虑了从上到下的所有记录。 因此，与以前的 pandas 版本相比，生成的 DataFrame 的列顺序已更改。

```py
In [58]: pd.DataFrame(data)
Out[58]: 
 name state  age      hobby finances
0   Joe    NY   18        NaN      NaN
1  Jane    KY   19  Minecraft      NaN
2  Jean    OK   20        NaN     good

[3 rows x 5 columns] 
```  ### 增加了依赖项的最低版本

由于不再支持 Python 2.7，一些可选依赖项的最低版本已更新 ([GH 25725](https://github.com/pandas-dev/pandas/issues/25725)，[GH 24942](https://github.com/pandas-dev/pandas/issues/24942)，[GH 25752](https://github.com/pandas-dev/pandas/issues/25752))。 独立地，一些依赖项的最低受支持版本已更新 ([GH 23519](https://github.com/pandas-dev/pandas/issues/23519)，[GH 25554](https://github.com/pandas-dev/pandas/issues/25554))。 如果已安装，我们现在要求：

| 包 | 最低版本 | 要求 |
| --- | --- | --- |
| numpy | 1.13.3 | X |
| pytz | 2015.4 | X |
| python-dateutil | 2.6.1 | X |
| bottleneck | 1.2.1 |  |
| numexpr | 2.6.2 |  |
| pytest（开发） | 4.0.2 |  |

对于[可选库](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最新版本。 以下表格列出了 pandas 开发过程中当前正在测试的每个库的最低版本。 低于最低测试版本的可选库可能仍然可用，但不被视为受支持。

| 包 | 最低版本 |
| --- | --- |
| beautifulsoup4 | 4.6.0 |
| fastparquet | 0.2.1 |
| gcsfs | 0.2.2 |
| lxml | 3.8.0 |
| matplotlib | 2.2.2 |
| openpyxl | 2.4.8 |
| pyarrow | 0.9.0 |
| pymysql | 0.7.1 |
| pytables | 3.4.2 |
| scipy | 0.19.0 |
| sqlalchemy | 1.1.4 |
| xarray | 0.8.2 |
| xlrd | 1.1.0 |
| xlsxwriter | 0.9.8 |
| xlwt | 1.2.0 |

更多详情请参阅依赖项和可选依赖项。  ### 其他 API 更改

+   `DatetimeTZDtype` 现在将 pytz 时区标准化为通用时区实例 ([GH 24713](https://github.com/pandas-dev/pandas/issues/24713))

+   `Timestamp` 和 `Timedelta` 标量现在实现了 `to_numpy()` 方法，作为 `Timestamp.to_datetime64()` 和 `Timedelta.to_timedelta64()` 的别名，分别。 ([GH 24653](https://github.com/pandas-dev/pandas/issues/24653))

+   `Timestamp.strptime()` 现在会引发 `NotImplementedError`（[GH 25016](https://github.com/pandas-dev/pandas/issues/25016)）

+   将不受支持的对象与 `Timestamp` 进行比较现在会返回 [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "(在 Python v3.12 中)") 而不是引发 `TypeError`。这意味着不受支持的丰富比较被委托给其他对象，并且现在与 Python 3 中的 `datetime` 对象一致（[GH 24011](https://github.com/pandas-dev/pandas/issues/24011)）

+   `DatetimeIndex.snap()` 中的错误，未保留输入 `Index` 的 `name`（[GH 25575](https://github.com/pandas-dev/pandas/issues/25575)）

+   `DataFrameGroupBy.agg()` 中的 `arg` 参数已更名为 `func`（[GH 26089](https://github.com/pandas-dev/pandas/issues/26089)）

+   `Window.aggregate()` 中的 `arg` 参数已更名为 `func`（[GH 26372](https://github.com/pandas-dev/pandas/issues/26372)）

+   大多数 pandas 类都有一个 `__bytes__` 方法，用于获取对象的 python2 风格的字节串表示形式。此方法已作为放弃 Python2 的一部分而被移除（[GH 26447](https://github.com/pandas-dev/pandas/issues/26447)）

+   对于 1 级 `MultiIndex`，已禁用 `.str` 访问器，如有必要，请使用 `MultiIndex.to_flat_index()`（[GH 23679](https://github.com/pandas-dev/pandas/issues/23679)）

+   移除了 gtk 包对剪贴板的支持（[GH 26563](https://github.com/pandas-dev/pandas/issues/26563)）

+   使用不受支持的 Beautiful Soup 4 版本现在将引发 `ImportError` 而不是 `ValueError`（[GH 27063](https://github.com/pandas-dev/pandas/issues/27063)）

+   当保存时区感知数据时，`Series.to_excel()` 和 `DataFrame.to_excel()` 现在会引发 `ValueError`（[GH 27008](https://github.com/pandas-dev/pandas/issues/27008), [GH 7056](https://github.com/pandas-dev/pandas/issues/7056)）

+   `ExtensionArray.argsort()` 将 NA 值放置在已排序数组的末尾（[GH 21801](https://github.com/pandas-dev/pandas/issues/21801)）

+   `DataFrame.to_hdf()` 和 `Series.to_hdf()` 现在在保存带有扩展数据类型的 `MultiIndex` 到 `fixed` 格式时会引发 `NotImplementedError`。([GH 7775](https://github.com/pandas-dev/pandas/issues/7775))

+   在 `read_csv()` 中传递重复的 `names` 现在会引发 `ValueError` ([GH 17346](https://github.com/pandas-dev/pandas/issues/17346))  ## 废弃

### 稀疏子类

`SparseSeries` 和 `SparseDataFrame` 子类已经被废弃。它们的功能可以由具有稀疏值的 `Series` 或 `DataFrame` 更好地提供。

**之前的方式**

```py
df = pd.SparseDataFrame({"A": [0, 0, 1, 2]})
df.dtypes 
```

**新方式**

```py
In [59]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 0, 1, 2])})

In [60]: df.dtypes
Out[60]: 
A    Sparse[int64, 0]
Length: 1, dtype: object 
```

这两种方法的内存使用情况相同 ([GH 19239](https://github.com/pandas-dev/pandas/issues/19239)).

### msgpack 格式

从 0.25 版本开始，msgpack 格式已经不再推荐使用，并将在未来版本中移除。建议使用 pyarrow 进行 pandas 对象的传输。([GH 27084](https://github.com/pandas-dev/pandas/issues/27084))

### 其他废弃内容

+   废弃的 `.ix[]` 索引器现在会引发更明显的 `FutureWarning` 而不是 `DeprecationWarning` ([GH 26438](https://github.com/pandas-dev/pandas/issues/26438)).

+   废弃了 `units=M` (月) 和 `units=Y` (年) 参数，对于 `pandas.to_timedelta()`、`pandas.Timedelta()` 和 `pandas.TimedeltaIndex()` ([GH 16344](https://github.com/pandas-dev/pandas/issues/16344))

+   `pandas.concat()` 已经废弃了 `join_axes` 关键字。而应该在结果或输入上使用 `DataFrame.reindex()` 或 `DataFrame.reindex_like()` ([GH 21951](https://github.com/pandas-dev/pandas/issues/21951))

+   `SparseArray.values` 属性已经被废弃。你可以使用 `np.asarray(...)` 或 `SparseArray.to_dense()` 方法代替 ([GH 26421](https://github.com/pandas-dev/pandas/issues/26421)).

+   函数 `pandas.to_datetime()` 和 `pandas.to_timedelta()` 已弃用 `box` 关键字。请改用 `to_numpy()` 或 `Timestamp.to_datetime64()` 或 `Timedelta.to_timedelta64()` ([GH 24416](https://github.com/pandas-dev/pandas/issues/24416))。

+   `DataFrame.compound()` 和 `Series.compound()` 方法已被弃用，并将在将来的版本中删除 ([GH 26405](https://github.com/pandas-dev/pandas/issues/26405))。

+   `RangeIndex` 的内部属性 `_start`、`_stop` 和 `_step` 已经被弃用。请使用公共属性 `start`、`stop` 和 `step` 替代 ([GH 26581](https://github.com/pandas-dev/pandas/issues/26581))。

+   `Series.ftype()`、`Series.ftypes()` 和 `DataFrame.ftypes()` 方法已被弃用，并将在将来的版本中删除。请改用 `Series.dtype()` 和 `DataFrame.dtypes()` ([GH 26705](https://github.com/pandas-dev/pandas/issues/26705))。

+   `Series.get_values()`、`DataFrame.get_values()`、`Index.get_values()`、`SparseArray.get_values()` 和 `Categorical.get_values()` 方法已被弃用。可以使用 `np.asarray(..)` 或 `to_numpy()` 其中之一替代 ([GH 19617](https://github.com/pandas-dev/pandas/issues/19617))。

+   NumPy ufuncs 上的 ‘outer’ 方法，例如 `np.subtract.outer` 在 `Series` 对象上已被弃用。请先将输入转换为数组，然后再使用 `Series.array` ([GH 27186](https://github.com/pandas-dev/pandas/issues/27186))。

+   `Timedelta.resolution()`已弃用并替换为`Timedelta.resolution_string()`。 在将来的版本中，`Timedelta.resolution()`将更改为像标准库一样的行为[`datetime.timedelta.resolution`](https://docs.python.org/3/library/datetime.html#datetime.timedelta.resolution "(in Python v3.12)")（[GH 21344](https://github.com/pandas-dev/pandas/issues/21344)）

+   `read_table()`已经取消弃用。 （[GH 25220](https://github.com/pandas-dev/pandas/issues/25220)）

+   `Index.dtype_str`已弃用。 （[GH 18262](https://github.com/pandas-dev/pandas/issues/18262)）

+   `Series.imag`和`Series.real`已弃用。 （[GH 18262](https://github.com/pandas-dev/pandas/issues/18262)）

+   `Series.put()`已弃用。 （[GH 18262](https://github.com/pandas-dev/pandas/issues/18262)）

+   `Index.item()`和`Series.item()`已弃用。 （[GH 18262](https://github.com/pandas-dev/pandas/issues/18262)）

+   在`CategoricalDtype`中，默认值`ordered=None`已被弃用，而是使用`ordered=False`。 在转换分类类型时，必须显式传递`ordered=True`才能保留。 （[GH 26336](https://github.com/pandas-dev/pandas/issues/26336)）

+   `Index.contains()`已弃用。 使用`key in index`（`__contains__`）代替（[GH 17753](https://github.com/pandas-dev/pandas/issues/17753)）。

+   `DataFrame.get_dtype_counts()`已弃用。 （[GH 18262](https://github.com/pandas-dev/pandas/issues/18262)）

+   `Categorical.ravel()`将返回一个`Categorical`而不是一个`np.ndarray`（[GH 27199](https://github.com/pandas-dev/pandas/issues/27199)）  ## 移除了先前版本的弃用/更改

+   移除了`Panel`（[GH 25047](https://github.com/pandas-dev/pandas/issues/25047)，[GH 25191](https://github.com/pandas-dev/pandas/issues/25191)，[GH 25231](https://github.com/pandas-dev/pandas/issues/25231)）

+   移除了之前在`read_excel()`中弃用的`sheetname`关键字（[GH 16442](https://github.com/pandas-dev/pandas/issues/16442)，[GH 20938](https://github.com/pandas-dev/pandas/issues/20938)）

+   移除了之前被弃用的`TimeGrouper`（[GH 16942](https://github.com/pandas-dev/pandas/issues/16942)）

+   移除了之前在`read_excel()`中弃用的`parse_cols`关键字（[GH 16488](https://github.com/pandas-dev/pandas/issues/16488)）

+   移除了先前弃用的`pd.options.html.border`（[GH 16970](https://github.com/pandas-dev/pandas/issues/16970)）

+   移除了先前弃用的`convert_objects`（[GH 11221](https://github.com/pandas-dev/pandas/issues/11221)）

+   移除了先前弃用的`DataFrame`和`Series`的`select`方法（[GH 17633](https://github.com/pandas-dev/pandas/issues/17633)）

+   移除了先前弃用的在`rename_categories()`中将`Series`视为类似列表的行为（[GH 17982](https://github.com/pandas-dev/pandas/issues/17982)）

+   移除了先前弃用的`DataFrame.reindex_axis`和`Series.reindex_axis`（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   移除了先前弃用的通过`Series.rename_axis()`或`DataFrame.rename_axis()`修改列或索引标签的行为（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   移除了先前弃用的在`read_html()`、`read_csv()`和`DataFrame.to_csv()`中的`tupleize_cols`关键字参数（[GH 17877](https://github.com/pandas-dev/pandas/issues/17877)，[GH 17820](https://github.com/pandas-dev/pandas/issues/17820)）

+   移除了先前弃用的`DataFrame.from.csv`和`Series.from_csv`（[GH 17812](https://github.com/pandas-dev/pandas/issues/17812)）

+   移除了先前弃用的`DataFrame.where()`和`DataFrame.mask()`中`raise_on_error`关键字参数的行为（[GH 17744](https://github.com/pandas-dev/pandas/issues/17744)）

+   移除了先前弃用的`astype`中的`ordered`和`categories`关键字参数（[GH 17742](https://github.com/pandas-dev/pandas/issues/17742)）

+   移除了先前弃用的`cdate_range`（[GH 17691](https://github.com/pandas-dev/pandas/issues/17691)）

+   移除了先前弃用的`SeriesGroupBy.nth()`中`dropna`关键字参数的`True`选项（[GH 17493](https://github.com/pandas-dev/pandas/issues/17493)）

+   在`Series.take()`和`DataFrame.take()`中删除了先前弃用的`convert`关键字参数（[GH 17352](https://github.com/pandas-dev/pandas/issues/17352)）

+   删除了先前对`datetime.date`对象进行算术操作的弃用行为（[GH 21152](https://github.com/pandas-dev/pandas/issues/21152))  ## 性能改进

+   在`SparseArray`初始化中有显着加速，从而使大多数操作受益，并修复了在 v0.20.0 中引入的性能回归（[GH 24985](https://github.com/pandas-dev/pandas/issues/24985)）

+   使用任何字符串或非本机字节序列列输出数据时，`DataFrame.to_stata()`现在更快了（[GH 25045](https://github.com/pandas-dev/pandas/issues/25045)）

+   `Series.searchsorted()`的性能有所提升。当 dtype 为 int8/int16/int32 且搜索键在 dtype 的整数边界内时，加速尤为显著（[GH 22034](https://github.com/pandas-dev/pandas/issues/22034)）

+   `GroupBy.quantile()`的性能有所提升（[GH 20405](https://github.com/pandas-dev/pandas/issues/20405)）

+   对`RangeIndex`的切片和其他选定操作性能有所提升（[GH 26565](https://github.com/pandas-dev/pandas/issues/26565), [GH 26617](https://github.com/pandas-dev/pandas/issues/26617), [GH 26722](https://github.com/pandas-dev/pandas/issues/26722))

+   现在，`RangeIndex`执行标准查找而不实例化实际哈希表，因此节省了内存（[GH 16685](https://github.com/pandas-dev/pandas/issues/16685)）

+   通过更快的标记化和更快的小浮点数解析，改进了`read_csv()`的性能（[GH 25784](https://github.com/pandas-dev/pandas/issues/25784)）

+   通过更快地解析 N/A 和布尔值，改进了`read_csv()`的性能（[GH 25804](https://github.com/pandas-dev/pandas/issues/25804)）

+   通过删除转换为`MultiIndex`来改善`IntervalIndex.is_monotonic`、`IntervalIndex.is_monotonic_increasing`和`IntervalIndex.is_monotonic_decreasing`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813)）

+   在写入日期时间数据类型时，提高了`DataFrame.to_csv()`的性能（[GH 25708](https://github.com/pandas-dev/pandas/issues/25708)）

+   通过更快速解析`MM/YYYY`和`DD/MM/YYYY`日期时间格式，提高了`read_csv()`的性能（[GH 25922](https://github.com/pandas-dev/pandas/issues/25922)）

+   对于不能存储 NaN 的数据类型，通过不再需要垃圾收集来提高性能。对于`Series.all()`和`Series.any()`，速度提升尤为明显（[GH 25070](https://github.com/pandas-dev/pandas/issues/25070)）

+   对于分类系列上的字典映射，通过映射类别而不是映射所有值，提高了`Series.map()`的性能（[GH 23785](https://github.com/pandas-dev/pandas/issues/23785)）

+   改进了`IntervalIndex.intersection()`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813)）

+   通过更快速地连接日期列而不需要额外将整数/浮点数零和浮点数`NaN`转换为字符串，以及更快速地检查字符串是否可能是日期，提高了`read_csv()`的性能（[GH 25754](https://github.com/pandas-dev/pandas/issues/25754)）

+   通过删除转换为`MultiIndex`来提高了`IntervalIndex.is_unique`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813)）

+   通过重新启用专门的代码路径，恢复了`DatetimeIndex.__iter__()`的性能（[GH 26702](https://github.com/pandas-dev/pandas/issues/26702)）

+   在至少有一个`CategoricalIndex`级别的情况下构建`MultiIndex`时，提高了性能（[GH 22044](https://github.com/pandas-dev/pandas/issues/22044)）

+   在检查`SettingWithCopyWarning`时，通过不再需要垃圾收集来提高性能（[GH 27031](https://github.com/pandas-dev/pandas/issues/27031)）

+   对于`to_datetime()`，将缓存参数的默认值更改为`True`（[GH 26043](https://github.com/pandas-dev/pandas/issues/26043)）

+   针对非唯一、单调数据，提高了`DatetimeIndex`和`PeriodIndex`切片的性能（[GH 27136](https://github.com/pandas-dev/pandas/issues/27136))

+   改进了`pd.read_json()`对索引导向数据的性能。 ([GH 26773](https://github.com/pandas-dev/pandas/issues/26773))

+   改进了`MultiIndex.shape()`的性能 ([GH 27384](https://github.com/pandas-dev/pandas/issues/27384))。## Bug 修复

### 分类

+   修复了当索引为`CategoricalIndex`时，会引发异常的`DataFrame.at()`和`Series.at()` ([GH 20629](https://github.com/pandas-dev/pandas/issues/20629))

+   修复了包含缺失值的有序`Categorical`与标量进行比较时的错误，在某些情况下会错误地返回`True` ([GH 26504](https://github.com/pandas-dev/pandas/issues/26504))

+   修复了当`DataFrame`具有包含`Interval`对象的`CategoricalIndex`时，`DataFrame.dropna()`的错误，错误地引发了`TypeError` ([GH 25087](https://github.com/pandas-dev/pandas/issues/25087))

### 日期时间类

+   修复了在调用时会引发（错误的）`ValueError`的`to_datetime()`，当调用时指定了一个遥远的日期并且指定了`format`参数时，而不是引发`OutOfBoundsDatetime` ([GH 23830](https://github.com/pandas-dev/pandas/issues/23830))

+   修复了在调用时会引发`InvalidIndexError: Reindexing only valid with uniquely valued Index objects`的`to_datetime()`，当调用时`cache=True`，`arg`包含来自集合`{None, numpy.nan, pandas.NaT}`中至少两个不同元素时 ([GH 22305](https://github.com/pandas-dev/pandas/issues/22305))

+   修复了在时区感知数据为`dtype='datetime64[ns]`时，`DataFrame`和`Series`中的错误，未将其转换为无时区数据的错误 ([GH 25843](https://github.com/pandas-dev/pandas/issues/25843))

+   改进了各种日期时间函数中对`Timestamp`类型检查，以防止在使用子类化的`datetime`时引发异常 ([GH 25851](https://github.com/pandas-dev/pandas/issues/25851))

+   在 `Series` 和 `DataFrame` 的 repr 中，带有 `dtype=object` 的 `np.datetime64('NaT')` 和 `np.timedelta64('NaT')` 将被表示为 `NaN`。（[GH 25445](https://github.com/pandas-dev/pandas/issues/25445)）

+   `to_datetime()` 中的错误，在错误设置为 coerce 时未将无效参数替换为 `NaT`。（[GH 26122](https://github.com/pandas-dev/pandas/issues/26122)）

+   将非零月份的 `DateOffset` 添加到 `DatetimeIndex` 中会引发 `ValueError`。（[GH 26258](https://github.com/pandas-dev/pandas/issues/26258)）

+   在调用带有无效日期和 `NaN` 值混合的 `format='%Y%m%d'` 和 `error='coerce'` 时，`to_datetime()` 中引发未处理的 `OverflowError`。（[GH 25512](https://github.com/pandas-dev/pandas/issues/25512)）

+   `isin()` 在 datetimelike 索引中的错误；`DatetimeIndex`、`TimedeltaIndex` 和 `PeriodIndex` 中 `levels` 参数被忽略。（[GH 26675](https://github.com/pandas-dev/pandas/issues/26675)）

+   `to_datetime()` 中的错误，在调用格式为 `'%Y%m%d'` 的无效整数日期时，如果长度大于等于 6 位，则会引发 `TypeError`，`errors='ignore'`。

+   当与零维 numpy 数组进行比较时，`PeriodIndex` 中出现的错误。（[GH 26689](https://github.com/pandas-dev/pandas/issues/26689)）

+   在使用非 ns 单位和超出范围的时间戳构建 numpy `datetime64` 数组的 `Series` 或 `DataFrame` 时出现错误，将正确引发 `OutOfBoundsDatetime` 错误。（[GH 26206](https://github.com/pandas-dev/pandas/issues/26206)）。

+   在非常大或非常小的日期上使用 `date_range()` 时，出现不必要的 `OverflowError`。（[GH 26651](https://github.com/pandas-dev/pandas/issues/26651)）

+   在将 `Timestamp` 添加到 `np.timedelta64` 对象时，将引发错误而不是返回 `Timestamp`。（[GH 24775](https://github.com/pandas-dev/pandas/issues/24775)）

+   比较一个包含 `np.datetime64` 对象的零维 numpy 数组与 `Timestamp` 时，错误地引发 `TypeError` 的 Bug ([GH 26916](https://github.com/pandas-dev/pandas/issues/26916))

+   `to_datetime()` 中的 Bug，当以 `cache=True` 调用时，会引发 `ValueError: Tz-aware datetime.datetime cannot be converted to datetime64 unless utc=True`，其中 `arg` 包含具有不同偏移的日期时间字符串 ([GH 26097](https://github.com/pandas-dev/pandas/issues/26097))

### 时间增量

+   `TimedeltaIndex.intersection()` 中的 Bug，对于非单调索引，在某些情况下，当实际存在交集时，返回的是空的 `Index` ([GH 25913](https://github.com/pandas-dev/pandas/issues/25913))

+   在 `Timedelta` 与 `NaT` 之间比较时引发 `TypeError` 的 Bug ([GH 26039](https://github.com/pandas-dev/pandas/issues/26039))

+   在将 `BusinessHour` 添加或减去到与结果时间分别落在后续或前一个日期的 `Timestamp` 时的 Bug ([GH 26381](https://github.com/pandas-dev/pandas/issues/26381))

+   比较一个 `TimedeltaIndex` 与零维 numpy 数组时的 Bug ([GH 26689](https://github.com/pandas-dev/pandas/issues/26689))

### 时区

+   在 `DatetimeIndex.to_frame()` 中，时区感知数据会被转换为时区无关数据的 Bug ([GH 25809](https://github.com/pandas-dev/pandas/issues/25809))

+   带有 `utc=True` 的 `to_datetime()` 中的 Bug，以及会将先前解析的 UTC 偏移应用于后续参数的日期时间字符串 ([GH 24992](https://github.com/pandas-dev/pandas/issues/24992))

+   `Timestamp.tz_localize()` 和 `Timestamp.tz_convert()` 中存在的 Bug 未传播 `freq` ([GH 25241](https://github.com/pandas-dev/pandas/issues/25241))

+   在 `Series.at()` 中设定带时区的 `Timestamp` 时引发 `TypeError` 的 Bug ([GH 25506](https://github.com/pandas-dev/pandas/issues/25506))

+   Bug in `DataFrame.update()` 在使用带有时区信息的数据进行更新时，会返回时区无关的数据（[GH 25807](https://github.com/pandas-dev/pandas/issues/25807)）

+   Bug in `to_datetime()` 出现了一个问题，当传递一个带有混合 UTC 偏移的日期时间字符串的 naive `Timestamp`时，会引发一个无信息的`RuntimeError`（[GH 25978](https://github.com/pandas-dev/pandas/issues/25978)）

+   Bug in `to_datetime()` 中，使用`unit='ns'`会从解析的参数中删除时区信息（[GH 26168](https://github.com/pandas-dev/pandas/issues/26168)）

+   Bug in `DataFrame.join()` 在将带有时区信息的索引与带有时区信息的列进行连接时，会导致一列`NaN`（[GH 26335](https://github.com/pandas-dev/pandas/issues/26335)）

+   Bug in `date_range()` 中，模糊或不存在的开始或结束时间未被`ambiguous`或`nonexistent`关键字处理（[GH 27088](https://github.com/pandas-dev/pandas/issues/27088)）

+   在合并带有时区信息和不带时区信息的`DatetimeIndex`时，`DatetimeIndex.union()`存在 bug（[GH 21671](https://github.com/pandas-dev/pandas/issues/21671)）

+   当将 numpy 缩减函数（例如`numpy.minimum()`）应用于带有时区信息的`Series`时出现了 bug（[GH 15552](https://github.com/pandas-dev/pandas/issues/15552)）

### 数值

+   Bug in `to_numeric()` 中，大负数被错误处理（[GH 24910](https://github.com/pandas-dev/pandas/issues/24910))

+   Bug in `to_numeric()` 中，即使`errors`不是`coerce`，数字也被强制转换为浮点数（[GH 24910](https://github.com/pandas-dev/pandas/issues/24910)）

+   Bug in `to_numeric()` 中允许`errors`的无效值（[GH 26466](https://github.com/pandas-dev/pandas/issues/26466)）

+   在`format`中存在 bug，浮点复数数字未被格式化为正确的显示精度和修剪（[GH 25514](https://github.com/pandas-dev/pandas/issues/25514)）

+   `DataFrame.corr()` 和 `Series.corr()` 中错误消息的错误。增加了使用可调用对象的可能性。([GH 25729](https://github.com/pandas-dev/pandas/issues/25729))

+   `Series.divmod()` 和 `Series.rdivmod()` 中的错误，会引发（不正确的）`ValueError`，而不是返回一对`Series`对象作为结果。([GH 25557](https://github.com/pandas-dev/pandas/issues/25557))

+   当将非数值索引发送到需要数值索引的方法 `interpolate()` 时，引发一个有用的异常。([GH 21662](https://github.com/pandas-dev/pandas/issues/21662))

+   在使用标量运算符比较浮点数时，`eval()` 中的错误消息改进，例如：`x < -0.1`。([GH 25928](https://github.com/pandas-dev/pandas/issues/25928))

+   修复了将全布尔数组转换为整数扩展数组失败的错误。([GH 25211](https://github.com/pandas-dev/pandas/issues/25211))

+   包含零的 `Series` 对象中 `divmod` 中的错误，错误地引发 `AttributeError`。([GH 26987](https://github.com/pandas-dev/pandas/issues/26987))

+   `Series` floor-division (//) 和 `divmod` 中的不一致，用 `NaN` 填充正数//零，而不是 `Inf`。([GH 27321](https://github.com/pandas-dev/pandas/issues/27321))

### Conversion

+   在传递列和类型字典给 `DataFrame.astype()` 时，`errors` 参数被忽略的错误。([GH 25905](https://github.com/pandas-dev/pandas/issues/25905))

### Strings

+   `Series.str` 的几种方法中 `__name__` 属性的错误设置。([GH 23551](https://github.com/pandas-dev/pandas/issues/23551))

+   在将错误类型的`Series`传递给 `Series.str.cat()` 时，改进了错误消息。([GH 22722](https://github.com/pandas-dev/pandas/issues/22722))

### Interval

+   `Interval` 的构造仅限于数值、`Timestamp` 和 `Timedelta` 端点。([GH 23013](https://github.com/pandas-dev/pandas/issues/23013))

+   修复了`Series`/`DataFrame` 中不显示 `IntervalIndex` 中缺失值的 `NaN` 的 Bug（[GH 25984](https://github.com/pandas-dev/pandas/issues/25984)）。

+   `IntervalIndex.get_loc()` 存在 Bug，对于递减的`IntervalIndex`，会错误地引发 `KeyError`（[GH 25860](https://github.com/pandas-dev/pandas/issues/25860)）。

+   在`Index` 构造函数中存在 Bug，传入混合的封闭 `Interval` 对象将导致 `ValueError` 而不是 `object` dtype `Index`（[GH 27172](https://github.com/pandas-dev/pandas/issues/27172)）。

### 索引

+   在调用 `DataFrame.iloc()` 时，当传入非数值对象列表时，改进了异常消息（[GH 25753](https://github.com/pandas-dev/pandas/issues/25753)）。

+   当使用长度不同的布尔索引器调用`.iloc` 或 `.loc` 时，改进了异常消息（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   `KeyError` 异常消息中的错误在索引`MultiIndex`时，当使用一个不存在的键时没有显示原始键值（[GH 27250](https://github.com/pandas-dev/pandas/issues/27250)）。

+   在使用布尔索引器的`.iloc` 和 `.loc` 中存在 Bug，当传递的项目太少时未引发 `IndexError`（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   在 `DataFrame.loc()` 和 `Series.loc()` 中存在 Bug，当键值小于或等于`MultiIndex` 中级别数量时，未对 `MultiIndex` 引发 `KeyError`（[GH 14885](https://github.com/pandas-dev/pandas/issues/14885)）。

+   存在 Bug，在 `DataFrame.append()` 产生错误警告，指示未来将在要附加的数据包含新列时引发 `KeyError`（[GH 22252](https://github.com/pandas-dev/pandas/issues/22252)）。

+   修复了当索引为单级`MultiIndex`时，`DataFrame.to_csv()` 在重新索引的数据帧上导致段错误的 bug（[GH 26303](https://github.com/pandas-dev/pandas/issues/26303)）。

+   修复了将`arrays.PandasArray`分配给`DataFrame`会引发错误的 bug（[GH 26390](https://github.com/pandas-dev/pandas/issues/26390)）。

+   允许在 `DataFrame.query()` 字符串中使用可调用本地引用的关键字参数（[GH 26426](https://github.com/pandas-dev/pandas/issues/26426)）。

+   修复了在包含恰好一个丢失标签的列表的情况下，对`MultiIndex` 级进行索引时出现`KeyError`的 bug（[GH 27148](https://github.com/pandas-dev/pandas/issues/27148)）。

+   修复了在 `MultiIndex` 中部分匹配`Timestamp` 时产生`AttributeError`的 bug（[GH 26944](https://github.com/pandas-dev/pandas/issues/26944)）。

+   修复了在使用与`Interval`值不可比较的对象使用 `in` 运算符 (`__contains__`) 时，`Categorical` 和 `CategoricalIndex` 中的 bug（[GH 23705](https://github.com/pandas-dev/pandas/issues/23705)）。

+   修复了在具有单个时区感知的 datetime64[ns] 列的 `DataFrame` 上使用`DataFrame.loc()` 和 `DataFrame.iloc()` 错误地返回标量而不是`Series` 的 bug（[GH 27110](https://github.com/pandas-dev/pandas/issues/27110)）。

+   修复了当使用 `in` 运算符 (`__contains__`) 传递列表时，`CategoricalIndex` 和 `Categorical` 错误地引发`ValueError`而不是`TypeError`的 bug（[GH 21729](https://github.com/pandas-dev/pandas/issues/21729)）。

+   在 `Series` 中设置新值时，使用 `Timedelta` 对象错误地将值转换为整数（[GH 22717](https://github.com/pandas-dev/pandas/issues/22717)）

+   在使用时区感知日期时间设置新键（`__setitem__`）时，`Series` 错误地引发 `ValueError`（[GH 12862](https://github.com/pandas-dev/pandas/issues/12862)）

+   在使用只读索引器进行索引时，`DataFrame.iloc()` 中的错误（[GH 17192](https://github.com/pandas-dev/pandas/issues/17192)）

+   在使用时区感知日期时间值设置现有元组键（`__setitem__`）时，`Series` 错误地引发 `TypeError`（[GH 20441](https://github.com/pandas-dev/pandas/issues/20441)）

### 缺失

+   如果需要参数 `order` 但未提供时，`Series.interpolate()` 中的误导性异常消息已修复（[GH 10633](https://github.com/pandas-dev/pandas/issues/10633), [GH 24014](https://github.com/pandas-dev/pandas/issues/24014)）

+   如果传递无效的 `axis` 参数，`DataFrame.dropna()` 中的异常消息中显示的类类型已修复（[GH 25555](https://github.com/pandas-dev/pandas/issues/25555)）

+   当 `limit` 不是正整数时，`DataFrame.fillna()` 现在会引发 `ValueError`（[GH 27042](https://github.com/pandas-dev/pandas/issues/27042)）

### 多重索引

+   `Timedelta` 在测试 `MultiIndex` 的成员资格时引发了错误异常（[GH 24570](https://github.com/pandas-dev/pandas/issues/24570)）

### IO

+   `DataFrame.to_html()` 中的错误，值被截断使用显示选项而不是输出完整内容（[GH 17004](https://github.com/pandas-dev/pandas/issues/17004)）

+   在 Python 3 的 Windows 上复制 utf-16 字符时，使用 `to_clipboard()` 时缺失文本的错误已修复（[GH 25040](https://github.com/pandas-dev/pandas/issues/25040)）

+   在尝试默认推断 dtype 时，`read_json()` 存在 bug，因为 dtype 已在 JSON 模式中定义（[GH 21345](https://github.com/pandas-dev/pandas/issues/21345)）

+   在`orient='table'`和浮点索引的情况下，`read_json()` 存在 bug，因为它默认推断索引 dtype，而 JSON 模式中已经定义了索引 dtype（[GH 25433](https://github.com/pandas-dev/pandas/issues/25433)）

+   在`orient='table'`和浮点列名字符串的情况下，`read_json()` 存在 bug，因为它会将列名类型转换为 `Timestamp`，这不适用于 JSON 模式中已经定义了列名的情况（[GH 25435](https://github.com/pandas-dev/pandas/issues/25435)）

+   在`errors='ignore'`的情况下，`json_normalize()` 中存在 bug，输入数据中的缺失值会在结果 `DataFrame` 中被填充为字符串 `"nan"` 而不是 `numpy.nan`（[GH 25468](https://github.com/pandas-dev/pandas/issues/25468)）

+   当使用无效类型的 `classes` 参数时，`DataFrame.to_html()` 现在会引发 `TypeError` 而不是 `AssertionError`（[GH 25608](https://github.com/pandas-dev/pandas/issues/25608)）

+   当使用 `header` 关键字时，`DataFrame.to_string()` 和 `DataFrame.to_latex()` 存在 bug，会导致输出不正确（[GH 16718](https://github.com/pandas-dev/pandas/issues/16718)）

+   在 Windows 上的 Python 3.6+ 中，`read_csv()` 不能正确解释 UTF8 编码的文件名（[GH 15086](https://github.com/pandas-dev/pandas/issues/15086)）

+   在转换具有缺失值的列时，`pandas.read_stata()` 和 `pandas.io.stata.StataReader` 的性能得到了改善（[GH 25772](https://github.com/pandas-dev/pandas/issues/25772)）

+   `DataFrame.to_html()` 存在一个 bug，当四舍五入时，表头数字会忽略显示选项（[GH 17280](https://github.com/pandas-dev/pandas/issues/17280)）

+   `read_hdf()` 中的 Bug，直接使用 PyTables 写入的 HDF5 文件读取表时，通过 `start` 或 `stop` 参数进行子选择会导致 `ValueError` 错误（[GH 11188](https://github.com/pandas-dev/pandas/issues/11188))

+   `read_hdf()` 中的 Bug 在引发 `KeyError` 后未正确关闭存储（[GH 25766](https://github.com/pandas-dev/pandas/issues/25766))

+   改进了在 Stata dta 文件中重复使用值标签时的失败解释，并提出了解决方法（[GH 25772](https://github.com/pandas-dev/pandas/issues/25772))

+   改进了 `pandas.read_stata()` 和 `pandas.io.stata.StataReader`，以读取由 Stata 保存的格式错误的 118 格式文件（[GH 25960](https://github.com/pandas-dev/pandas/issues/25960))

+   在 `DataFrame.to_html()` 中改进了 `col_space` 参数，以接受字符串，从而可以正确设置 CSS 长度值（[GH 25941](https://github.com/pandas-dev/pandas/issues/25941))

+   修复了从 S3 加载包含 URL 中 `#` 字符的对象时的 Bug（[GH 25945](https://github.com/pandas-dev/pandas/issues/25945))

+   向 `read_gbq()` 添加了 `use_bqstorage_api` 参数，以加快大型数据框的下载速度。该功能还需要 `pandas-gbq` 库的 0.10.0 版本以及 `google-cloud-bigquery-storage` 和 `fastavro` 库（[GH 26104](https://github.com/pandas-dev/pandas/issues/26104))

+   在处理数值数据时，修复了 `DataFrame.to_json()` 中的内存泄漏问题（[GH 24889](https://github.com/pandas-dev/pandas/issues/24889))

+   在 `read_json()` 中修复了日期字符串中带有 `Z` 的情况未转换为 UTC 时区的 Bug（[GH 26168](https://github.com/pandas-dev/pandas/issues/26168))

+   向 `read_csv()` 添加了 `cache_dates=True` 参数，允许在解析时缓存唯一日期（[GH 25990](https://github.com/pandas-dev/pandas/issues/25990))

+   当调用者的维度超出 Excel 限制时，`DataFrame.to_excel()` 现在会引发 `ValueError` 错误（[GH 26051](https://github.com/pandas-dev/pandas/issues/26051))

+   修复了当存在 BOM 时 `pandas.read_csv()` 使用 engine=’python’ 会导致错误解析的错误（[GH 26545](https://github.com/pandas-dev/pandas/issues/26545)）

+   当输入类型为 `pandas.io.excel.ExcelFile` 且传递了 `engine` 参数时，`read_excel()` 现在会引发 `ValueError`，因为 `pandas.io.excel.ExcelFile` 已经定义了一个引擎（[GH 26566](https://github.com/pandas-dev/pandas/issues/26566)）

+   选择 `HDFStore` 中指定了 `where=''` 时存在的错误（[GH 26610](https://github.com/pandas-dev/pandas/issues/26610)）

+   在 `DataFrame.to_excel()` 中存在的错误，即合并单元格中的自定义对象（即 `PeriodIndex`）未被转换为 Excel 写入器安全类型的错误（[GH 27006](https://github.com/pandas-dev/pandas/issues/27006)）

+   在 `read_hdf()` 中存在的错误，即读取带有时区信息的 `DatetimeIndex` 时会引发 `TypeError` 的错误（[GH 11926](https://github.com/pandas-dev/pandas/issues/11926)）

+   在 `to_msgpack()` 和 `read_msgpack()` 中存在的错误，会引发 `FileNotFoundError` 而不是无效路径时会引发 `ValueError`（[GH 27160](https://github.com/pandas-dev/pandas/issues/27160)）

+   修复了当数据框没有列时 `DataFrame.to_parquet()` 会引发 `ValueError` 的错误（[GH 27339](https://github.com/pandas-dev/pandas/issues/27339)）

+   在使用 `read_csv()` 时允许解析 `PeriodDtype` 列（[GH 26934](https://github.com/pandas-dev/pandas/issues/26934))

### 绘图

+   修复了 `api.extensions.ExtensionArray` 无法在 matplotlib 绘图中使用的错误（[GH 25587](https://github.com/pandas-dev/pandas/issues/25587)）

+   在 `DataFrame.plot()` 中的错误消息中存在一个错误。如果传递给 `DataFrame.plot()` 的是非数值数据，则改进错误消息（[GH 25481](https://github.com/pandas-dev/pandas/issues/25481)）

+   当绘制非数字/非日期时间索引时，修复了 ticklabel 位置不正确的错误([GH 7612](https://github.com/pandas-dev/pandas/issues/7612), [GH 15912](https://github.com/pandas-dev/pandas/issues/15912), [GH 22334](https://github.com/pandas-dev/pandas/issues/22334))

+   修复了一个错误，导致绘制`PeriodIndex`时间序列失败，如果频率是频率规则代码的倍数([GH 14763](https://github.com/pandas-dev/pandas/issues/14763))

+   修复了在使用`datetime.timezone.utc`时区时绘制`DatetimeIndex`时的错误([GH 17173](https://github.com/pandas-dev/pandas/issues/17173))

### GroupBy/resample/rolling

+   在具有时区感知索引的`Resampler.agg()`中修复了一个错误，当传递函数列表时会引发`OverflowError`的错误([GH 22660](https://github.com/pandas-dev/pandas/issues/22660))

+   修复了`DataFrameGroupBy.nunique()`中列级别名称丢失的错误([GH 23222](https://github.com/pandas-dev/pandas/issues/23222))

+   在将聚合函数应用于时区感知数据时，修复了`GroupBy.agg()`中的错误([GH 23683](https://github.com/pandas-dev/pandas/issues/23683))

+   在`GroupBy.first()`和`GroupBy.last()`中修复了时区信息丢失的错误([GH 21603](https://github.com/pandas-dev/pandas/issues/21603))

+   当只对 NA 值进行分组时，修复了`GroupBy.size()`中的错误([GH 23050](https://github.com/pandas-dev/pandas/issues/23050))

+   修复了`Series.groupby()`中`observed`关键字参数以前被忽略的错误([GH 24880](https://github.com/pandas-dev/pandas/issues/24880))

+   修复了在使用`MultiIndex` Series 的标签列表等于系列长度时，使用`groupby`导致不正确分组的错误([GH 25704](https://github.com/pandas-dev/pandas/issues/25704))

+   确保在所有 Python 版本中`groupby`聚合函数的输出排序是一致的([GH 25692](https://github.com/pandas-dev/pandas/issues/25692))

+   确保在有序`Categorical`上进行分组并指定`observed=True`时，结果组的顺序是正确的([GH 25871](https://github.com/pandas-dev/pandas/issues/25871), [GH 25167](https://github.com/pandas-dev/pandas/issues/25167))

+   在 `Rolling.min()` 和 `Rolling.max()` 中存在一个 bug，导致内存泄漏（[GH 25893](https://github.com/pandas-dev/pandas/issues/25893)）

+   在 `Rolling.count()` 和 `.Expanding.count` 中存在一个 bug，先前忽略了 `axis` 关键字（[GH 13503](https://github.com/pandas-dev/pandas/issues/13503)）

+   在 `GroupBy.idxmax()` 和 `GroupBy.idxmin()` 中存在一个 bug，datetime 列会返回不正确的 dtype（[GH 25444](https://github.com/pandas-dev/pandas/issues/25444), [GH 15306](https://github.com/pandas-dev/pandas/issues/15306)）

+   在 `GroupBy.cumsum()`、`GroupBy.cumprod()`、`GroupBy.cummin()` 和 `GroupBy.cummax()` 中存在一个 bug，在具有缺失类别的分类列时，会返回不正确的结果或 segfault（[GH 16771](https://github.com/pandas-dev/pandas/issues/16771)）

+   在 `GroupBy.nth()` 中存在一个 bug，在分组中的 NA 值会返回不正确的结果（[GH 26011](https://github.com/pandas-dev/pandas/issues/26011)）

+   在 `SeriesGroupBy.transform()` 中存在一个 bug，对空分组进行转换会引发 `ValueError`（[GH 26208](https://github.com/pandas-dev/pandas/issues/26208)）

+   在 `DataFrame.groupby()` 中存在一个 bug，当传递一个 `Grouper` 时，使用 `.groups` 访问器会返回不正确的分组（[GH 26326](https://github.com/pandas-dev/pandas/issues/26326)）

+   在 `GroupBy.agg()` 中存在一个 bug，对于 uint64 列返回不正确的结果（[GH 26310](https://github.com/pandas-dev/pandas/issues/26310)）

+   在 `Rolling.median()` 和 `Rolling.quantile()` 中存在一个 bug，在空窗口时会引发 MemoryError（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   `Rolling.median()`和`Rolling.quantile()`中存在一个问题，即当`closed='left'`和`closed='neither'`时返回的结果不正确（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）。

+   改进了`Rolling`、`Window`和`ExponentialMovingWindow`函数，以从结果中排除无关的列而不是引发错误，并且只有当所有列都是无关的时才引发`DataError`（[GH 12537](https://github.com/pandas-dev/pandas/issues/12537)）。

+   `Rolling.max()`和`Rolling.min()`中存在一个问题，即当变量窗口为空时返回的结果不正确（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）。

+   当使用不支持的加权窗口函数作为`Window.aggregate()`的参数时，会引发一个有用的异常（[GH 26597](https://github.com/pandas-dev/pandas/issues/26597)）。

### 重塑

+   在`pandas.merge()`中存在一个问题，即如果在后缀中分配了`None`，则会添加一个`None`的字符串，而不是保留列名不变（[GH 24782](https://github.com/pandas-dev/pandas/issues/24782)）。

+   在按索引名称合并时，`merge()`有时会导致索引编号错误（现在缺失的索引值将被分配为 NA）（[GH 24212](https://github.com/pandas-dev/pandas/issues/24212)，[GH 25009](https://github.com/pandas-dev/pandas/issues/25009)）。

+   `to_records()`现在接受`column_dtypes`参数的数据类型（[GH 24895](https://github.com/pandas-dev/pandas/issues/24895)）。

+   `concat()`中存在一个问题，即无法尊重`OrderedDict`（以及 Python 3.6+中的`dict`）的顺序，当作为`objs`参数传入时（[GH 21510](https://github.com/pandas-dev/pandas/issues/21510)）。

+   `pivot_table()`中存在一个问题，即带有`NaN`值的列即使`dropna`参数为`False`，当`aggfunc`参数包含一个`list`时也会被删除（[GH 22159](https://github.com/pandas-dev/pandas/issues/22159)）。

+   `concat()` 中存在 Bug，两个具有相同 `freq` 的 `DatetimeIndex` 合并后 `freq` 会被丢弃 ([GH 3232](https://github.com/pandas-dev/pandas/issues/3232))。

+   `merge()` 中存在 Bug，相同的分类数据类型合并会引发错误 ([GH 22501](https://github.com/pandas-dev/pandas/issues/22501))。

+   使用迭代器或生成器的字典实例化 `DataFrame` 时会引发错误（例如 `pd.DataFrame({'A': reversed(range(3))})`） ([GH 26349](https://github.com/pandas-dev/pandas/issues/26349))。

+   `DataFrame` 使用 `range` 实例化时会引发错误（例如 `pd.DataFrame(range(3))`） ([GH 26342](https://github.com/pandas-dev/pandas/issues/26342))。

+   `DataFrame` 构造函数中传递非空元组会导致分段错误 ([GH 25691](https://github.com/pandas-dev/pandas/issues/25691))。

+   `Series.apply()` 中存在 Bug，当系列为时区感知的 `DatetimeIndex` 时会失败 ([GH 25959](https://github.com/pandas-dev/pandas/issues/25959))。

+   `pandas.cut()` 中存在 Bug，大的分箱可能由于整数溢出而错误地引发错误 ([GH 26045](https://github.com/pandas-dev/pandas/issues/26045))。

+   `DataFrame.sort_index()` 中存在 Bug，当多级索引的 `DataFrame` 在所有级别上都按顺序排序时，最初的级别排序最后会引发错误 ([GH 26053](https://github.com/pandas-dev/pandas/issues/26053))。

+   `Series.nlargest()` 中存在 Bug，将 `True` 视为小于 `False` ([GH 26154](https://github.com/pandas-dev/pandas/issues/26154))。

+   `DataFrame.pivot_table()` 中存在 Bug，使用 `IntervalIndex` 作为透视索引会引发 `TypeError` ([GH 25814](https://github.com/pandas-dev/pandas/issues/25814))。

+   在使用`orient='index'`时，`DataFrame.from_dict()`忽略了`OrderedDict`的顺序（[GH 8425](https://github.com/pandas-dev/pandas/issues/8425)）

+   在对具有时区信息的日期时间列进行转置时，`DataFrame.transpose()`会错误地引发`ValueError`（[GH 26825](https://github.com/pandas-dev/pandas/issues/26825)）

+   在将时区感知列作为`values`进行数据透视时，在`pivot_table()`中会删除时区信息（[GH 14948](https://github.com/pandas-dev/pandas/issues/14948)）

+   在指定多个`by`列且其中一个是`datetime64[ns, tz]` dtype 时，在`merge_asof()`中存在错误（[GH 26649](https://github.com/pandas-dev/pandas/issues/26649)）

### 稀疏

+   在`SparseArray`初始化中显著加快速度，有利于大多数操作，修复了 v0.20.0 引入的性能回归（[GH 24985](https://github.com/pandas-dev/pandas/issues/24985)）

+   在`SparseFrame`构造函数中，将`None`作为数据传递会导致`default_fill_value`被忽略的错误（[GH 16807](https://github.com/pandas-dev/pandas/issues/16807)）

+   在向`SparseDataFrame`添加列时，如果值的长度与索引的长度不匹配，则会引发`AssertionError`而不是`ValueError`（[GH 25484](https://github.com/pandas-dev/pandas/issues/25484)）

+   在`Series.sparse.from_coo()`中引入更好的错误消息，以便对不是 coo 矩阵的输入返回`TypeError`（[GH 26554](https://github.com/pandas-dev/pandas/issues/26554)）

+   在`SparseArray`上使用`numpy.modf()`存在错误。现在返回`SparseArray`的元组（[GH 26946](https://github.com/pandas-dev/pandas/issues/26946)）

### 构建更改

+   修复在 macOS 上使用 PyPy 安装时的错误（[GH 26536](https://github.com/pandas-dev/pandas/issues/26536)）

### ExtensionArray

+   在使用自定义`na_sentinel`的`ExtensionArray`时，`factorize()`存在错误（[GH 25696](https://github.com/pandas-dev/pandas/issues/25696)）

+   `Series.count()`在 ExtensionArrays 中错误计算 NA 值（[GH 26835](https://github.com/pandas-dev/pandas/issues/26835)）

+   添加了`Series.__array_ufunc__`以更好地处理��用于由扩展数组支持的 Series 的 NumPy ufuncs（[GH 23293](https://github.com/pandas-dev/pandas/issues/23293)）

+   关键字参数 `deep` 已从 `ExtensionArray.copy()` 中移除 ([GH 27083](https://github.com/pandas-dev/pandas/issues/27083))

### 其他

+   从供应的 UltraJSON 实现中删除未使用的 C 函数 ([GH 26198](https://github.com/pandas-dev/pandas/issues/26198))

+   允许 `Index` 和 `RangeIndex` 被传递到 numpy 的 `min` 和 `max` 函数中 ([GH 26125](https://github.com/pandas-dev/pandas/issues/26125))

+   在 `Series` 子类的空对象的 repr 中使用实际的类名 ([GH 27001](https://github.com/pandas-dev/pandas/issues/27001))。

+   `DataFrame` 存在错误，传递时区感知的 `datetime` 对象的对象数组会错误地引发 `ValueError` ([GH 13287](https://github.com/pandas-dev/pandas/issues/13287))  ## 贡献者

总共有 231 人为此版本贡献了补丁。名字后面带有“+”的人第一次贡献了补丁。

+   1_x7 +

+   Abdullah İhsan Seçer +

+   Adam Bull +

+   Adam Hooper

+   Albert Villanova del Moral

+   Alex Watt +

+   AlexTereshenkov +

+   Alexander Buchkovsky

+   Alexander Hendorf +

+   Alexander Nordin +

+   Alexander Ponomaroff

+   Alexandre Batisse +

+   Alexandre Decan +

+   Allen Downey +

+   Alyssa Fu Ward +

+   Andrew Gaspari +

+   Andrew Wood +

+   Antoine Viscardi +

+   Antonio Gutierrez +

+   Arno Veenstra +

+   ArtinSarraf

+   Batalex +

+   Baurzhan Muftakhidinov

+   Benjamin Rowell

+   Bharat Raghunathan +

+   Bhavani Ravi +

+   Big Head +

+   Brett Randall +

+   Bryan Cutler +

+   C John Klehm +

+   Caleb Braun +

+   Cecilia +

+   Chris Bertinato +

+   Chris Stadler +

+   Christian Haege +

+   Christian Hudon

+   Christopher Whelan

+   Chuanzhu Xu +

+   Clemens Brunner

+   Damian Kula +

+   Daniel Hrisca +

+   Daniel Luis Costa +

+   Daniel Saxton

+   DanielFEvans +

+   David Liu +

+   Deepyaman Datta +

+   Denis Belavin +

+   Devin Petersohn +

+   Diane Trout +

+   EdAbati +

+   Enrico Rotundo +

+   EternalLearner42 +

+   Evan +

+   Evan Livelo +

+   Fabian Rost +

+   Flavien Lambert +

+   Florian Rathgeber +

+   Frank Hoang +

+   Gaibo Zhang +

+   Gioia Ballin

+   Giuseppe Romagnuolo +

+   Gordon Blackadder +

+   Gregory Rome +

+   Guillaume Gay

+   HHest +

+   Hielke Walinga +

+   How Si Wei +

+   Hubert

+   Huize Wang +

+   Hyukjin Kwon +

+   Ian Dunn +

+   Inevitable-Marzipan +

+   Irv Lustig

+   JElfner +

+   Jacob Bundgaard +

+   James Cobon-Kerr +

+   Jan-Philip Gehrcke +

+   Jarrod Millman +

+   Jayanth Katuri +

+   Jeff Reback

+   Jeremy Schendel

+   Jiang Yue +

+   Joel Ostblom

+   Johan von Forstner +

+   Johnny Chiu +

+   Jonas +

+   Jonathon Vandezande +

+   Jop Vermeer +

+   Joris Van den Bossche

+   Josh

+   Josh Friedlander +

+   Justin Zheng

+   Kaiqi Dong

+   Kane +

+   Kapil Patel +

+   Kara de la Marck +

+   Katherine Surta +

+   Katrin Leinweber +

+   Kendall Masse

+   Kevin Sheppard

+   Kyle Kosic +

+   Lorenzo Stella +

+   Maarten Rietbergen +

+   Mak Sze Chun

+   Marc Garcia

+   Mateusz Woś

+   Matias Heikkilä

+   Mats Maiwald +

+   Matthew Roeschke

+   Max Bolingbroke +

+   Max Kovalovs +

+   Max van Deursen +

+   Michael

+   Michael Davis +

+   Michael P. Moran +

+   Mike Cramblett +

+   Min ho Kim +

+   Misha Veldhoen +

+   Mukul Ashwath Ram +

+   MusTheDataGuy +

+   Nanda H Krishna +

+   Nicholas Musolino

+   Noam Hershtig +

+   Noora Husseini +

+   Paul

+   Paul Reidy

+   Pauli Virtanen

+   Pav A +

+   Peter Leimbigler +

+   Philippe Ombredanne +

+   Pietro Battiston

+   Richard Eames +

+   Roman Yurchak

+   Ruijing Li

+   Ryan

+   Ryan Joyce +

+   Ryan Nazareth

+   Ryan Rehman +

+   Sakar Panta +

+   Samuel Sinayoko

+   Sandeep Pathak +

+   Sangwoong Yoon

+   Saurav Chakravorty

+   Scott Talbert +

+   Sergey Kopylov +

+   Shantanu Gontia +

+   Shivam Rana +

+   Shorokhov Sergey +

+   Simon Hawkins

+   Soyoun(Rose) Kim

+   Stephan Hoyer

+   Stephen Cowley +

+   Stephen Rauch

+   Sterling Paramore +

+   Steven +

+   Stijn Van Hoey

+   Sumanau Sareen +

+   Takuya N +

+   Tan Tran +

+   Tao He +

+   Tarbo Fukazawa

+   Terji Petersen +

+   Thein Oo

+   ThibTrip +

+   Thijs Damsma +

+   Thiviyan Thanapalasingam

+   Thomas A Caswell

+   Thomas Kluiters +

+   Tilen Kusterle +

+   Tim Gates +

+   Tim Hoffmann

+   Tim Swast

+   Tom Augspurger

+   Tom Neep +

+   Tomáš Chvátal +

+   Tyler Reddy

+   Vaibhav Vishal +

+   Vasily Litvinov +

+   Vibhu Agarwal +

+   Vikramjeet Das +

+   Vladislav +

+   Víctor Moron Tejero +

+   Wenhuan

+   Will Ayd +

+   William Ayd

+   Wouter De Coster +

+   Yoann Goular +

+   Zach Angell +

+   alimcmaster1

+   anmyachev +

+   chris-b1

+   danielplawrence +

+   endenis +

+   enisnazif +

+   ezcitron +

+   fjetter

+   froessler

+   gfyoung

+   gwrome +

+   h-vetinari

+   haison +

+   hannah-c +

+   heckeop +

+   iamshwin +

+   jamesoliverh +

+   jbrockmendel

+   jkovacevic +

+   killerontherun1 +

+   knuu +

+   kpapdac +

+   kpflugshaupt +

+   krsnik93 +

+   leerssej +

+   lrjball +

+   mazayo +

+   nathalier +

+   nrebena +

+   nullptr +

+   pilkibun +

+   pmaxey83 +

+   rbenes +

+   robbuckley

+   shawnbrown +

+   sudhir mohanraj +

+   tadeja +

+   tamuhey +

+   thatneat

+   topper-123

+   willweil +

+   yehia67 +

+   yhaque1213 +

## Enhancements

### 带重命名的 GroupBy 聚合

pandas 已经添加了特殊的分组行为，称为“命名聚合”，用于在对特定列应用多个聚合函数时命名输出列（[GH 18366](https://github.com/pandas-dev/pandas/issues/18366)，[GH 26512](https://github.com/pandas-dev/pandas/issues/26512)）。

```py
In [1]: animals = pd.DataFrame({'kind': ['cat', 'dog', 'cat', 'dog'],
 ...:                        'height': [9.1, 6.0, 9.5, 34.0],
 ...:                        'weight': [7.9, 7.5, 9.9, 198.0]})
 ...: 

In [2]: animals
Out[2]: 
 kind  height  weight
0  cat     9.1     7.9
1  dog     6.0     7.5
2  cat     9.5     9.9
3  dog    34.0   198.0

[4 rows x 3 columns]

In [3]: animals.groupby("kind").agg(
 ...:    min_height=pd.NamedAgg(column='height', aggfunc='min'),
 ...:    max_height=pd.NamedAgg(column='height', aggfunc='max'),
 ...:    average_weight=pd.NamedAgg(column='weight', aggfunc="mean"),
 ...: )
 ...: 
Out[3]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

将所需的列名称作为 `**kwargs` 传递给 `.agg`。`**kwargs` 的值应该是元组，第一个元素是列选择，第二个元素是要应用的聚合函数。pandas 提供了 `pandas.NamedAgg` 命名元组，以使函数的参数更清晰，但也接受普通元组。

```py
In [4]: animals.groupby("kind").agg(
 ...:    min_height=('height', 'min'),
 ...:    max_height=('height', 'max'),
 ...:    average_weight=('weight', 'mean'),
 ...: )
 ...: 
Out[4]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

命名聚合是用于命名列特定聚合输出的“字典-字典”方法的推荐替代方法（Deprecate groupby.agg() with a dictionary when renaming）。

现在对 Series 分组对象也可以使用类似的方法。由于不需要选择列，所以值可以直接是要应用的函数

```py
In [5]: animals.groupby("kind").height.agg(
 ...:    min_height="min",
 ...:    max_height="max",
 ...: )
 ...: 
Out[5]: 
 min_height  max_height
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns] 
```

这种类型的聚合是在向 Series 分组聚合传递字典时重命名的推荐替代方法（Deprecate groupby.agg() with a dictionary when renaming）。

更多信息，请参阅命名聚合  ### 使用多个 lambda 函数进行 GroupBy 聚合

现在，您可以在`GroupBy.agg`中提供多个 lambda 函数以进行类似列表的聚合（[GH 26430](https://github.com/pandas-dev/pandas/issues/26430)）。

```py
In [6]: animals.groupby('kind').height.agg([
 ...:    lambda x: x.iloc[0], lambda x: x.iloc[-1]
 ...: ])
 ...: 
Out[6]: 
 <lambda_0>  <lambda_1>
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns]

In [7]: animals.groupby('kind').agg([
 ...:    lambda x: x.iloc[0] - x.iloc[1],
 ...:    lambda x: x.iloc[0] + x.iloc[1]
 ...: ])
 ...: 
Out[7]: 
 height                weight 
 <lambda_0> <lambda_1> <lambda_0> <lambda_1>
kind 
cat        -0.4       18.6       -2.0       17.8
dog       -28.0       40.0     -190.5      205.5

[2 rows x 4 columns] 
```

以前，这些引发了一个`SpecificationError`。  ### 更好的 MultiIndex repr

打印`MultiIndex`实例现在显示每行的元组，并确保元组项在垂直方向上对齐，因此更容易理解`MultiIndex`的结构。 ([GH 13480](https://github.com/pandas-dev/pandas/issues/13480))：

现在的 repr 看起来是这样的：

```py
In [8]: pd.MultiIndex.from_product([['a', 'abc'], range(500)])
Out[8]: 
MultiIndex([(  'a',   0),
 (  'a',   1),
 (  'a',   2),
 (  'a',   3),
 (  'a',   4),
 (  'a',   5),
 (  'a',   6),
 (  'a',   7),
 (  'a',   8),
 (  'a',   9),
 ...
 ('abc', 490),
 ('abc', 491),
 ('abc', 492),
 ('abc', 493),
 ('abc', 494),
 ('abc', 495),
 ('abc', 496),
 ('abc', 497),
 ('abc', 498),
 ('abc', 499)],
 length=1000) 
```

以前，输出`MultiIndex`打印了`MultiIndex`的所有`levels`和`codes`，这在视觉上不吸引人，并使输出更难以导航。 例如（将范围限制为 5）：

```py
In [1]: pd.MultiIndex.from_product([['a', 'abc'], range(5)])
Out[1]: MultiIndex(levels=[['a', 'abc'], [0, 1, 2, 3]],
 ...:           codes=[[0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 2, 3, 0, 1, 2, 3]]) 
```

在新的 repr 中，如果行数小于`options.display.max_seq_items`（默认为 100 个项目），则会显示所有值。 在水平方向上，如果它的宽度超过`options.display.width`（默认为 80 个字符），则会截断输出。  ### 更短的 Series 和 DataFrame 的截断 repr

目前，pandas 的默认显示选项确保当 Series 或 DataFrame 的行数超过 60 行时，其 repr 被截断为最大的 60 行（`display.max_rows`选项）。 但是，这仍然会导致 repr 占据大部分垂直屏幕空间。 因此，引入了一个新选项`display.min_rows`，默认为 10，确定在截断 repr 中显示的行数：

+   对于较小的 Series 或 DataFrame，最多显示`max_rows`行数（默认为 60）。

+   对于长度超过`max_rows`的较大 Series 或 DataFrame，只显示`min_rows`行数（默认为 10，即第一行和最后 5 行）。

这个双选项允许仍然看到相对较小对象的完整内容（例如`df.head(20)`显示所有 20 行），同时为大对象提供简要的 repr。

要恢复单一阈值的先前行为，请设置`pd.options.display.min_rows = None`。  ### 带有 max_level 参数支持的 JSON normalize

`json_normalize()`将提供的输入字典归一化到所有嵌套级别。 新的 max_level 参数提供了更多对于何时结束归一化的控制（[GH 23843](https://github.com/pandas-dev/pandas/issues/23843)）：

现在的 repr 看起来是这样的：

```py
from pandas.io.json import json_normalize
data = [{
    'CreatedBy': {'Name': 'User001'},
    'Lookup': {'TextField': 'Some text',
               'UserField': {'Id': 'ID001', 'Name': 'Name001'}},
    'Image': {'a': 'b'}
}]
json_normalize(data, max_level=1) 
```  ### Series.explode 以将类似列表的值拆分为行

`Series` 和 `DataFrame` 增加了 `DataFrame.explode()` 方法，以将类似列表的数据转换为单独的行。有关更多信息，请参阅文档中的 Exploding list-like column 部分（[GH 16538](https://github.com/pandas-dev/pandas/issues/16538), [GH 10511](https://github.com/pandas-dev/pandas/issues/10511)）

这里是一个典型的用例。您在一列中有逗号分隔的字符串。

```py
In [9]: df = pd.DataFrame([{'var1': 'a,b,c', 'var2': 1},
 ...:                   {'var1': 'd,e,f', 'var2': 2}])
 ...: 

In [10]: df
Out[10]: 
 var1  var2
0  a,b,c     1
1  d,e,f     2

[2 rows x 2 columns] 
```

使用连锁操作创建长格式 `DataFrame` 现在变得简单

```py
In [11]: df.assign(var1=df.var1.str.split(',')).explode('var1')
Out[11]: 
 var1  var2
0    a     1
0    b     1
0    c     1
1    d     2
1    e     2
1    f     2

[6 rows x 2 columns] 
```  ### 其他增强

+   `DataFrame.plot()` 关键字 `logy`、`logx` 和 `loglog` 现在可以接受值 `'sym'` 以进行对数对数缩放。（[GH 24867](https://github.com/pandas-dev/pandas/issues/24867)）

+   在使用 `to_datetime()` 解析日期时间时，现在支持 ISO 周年份格式（‘%G-%V-%u’）（[GH 16607](https://github.com/pandas-dev/pandas/issues/16607)）

+   `DataFrame` 和 `Series` 的索引现在接受零维 `np.ndarray`（[GH 24919](https://github.com/pandas-dev/pandas/issues/24919)）

+   `Timestamp.replace()` 现在支持 `fold` 参数以消除夏令时转换时间的歧义（[GH 25017](https://github.com/pandas-dev/pandas/issues/25017)）

+   `DataFrame.at_time()` 和 `Series.at_time()` 现在支持带时区的 [`datetime.time`](https://docs.python.org/3/library/datetime.html#datetime.time "(in Python v3.12)") 对象（[GH 24043](https://github.com/pandas-dev/pandas/issues/24043)）

+   `DataFrame.pivot_table()` 现在接受一个 `observed` 参数，该参数传递给底层调用的 `DataFrame.groupby()` 以加速对分类数据的分组。（[GH 24923](https://github.com/pandas-dev/pandas/issues/24923)）

+   `Series.str` 增加了 `Series.str.casefold()` 方法，用于移除字符串中的所有大小写区别（[GH 25405](https://github.com/pandas-dev/pandas/issues/25405)）

+   `DataFrame.set_index()` 现在适用于`abc.Iterator`的实例，前提是它们的输出长度与调用帧的长度相同（[GH 22484](https://github.com/pandas-dev/pandas/issues/22484), [GH 24984](https://github.com/pandas-dev/pandas/issues/24984)）

+   `DatetimeIndex.union()` 现在支持 `sort` 参数。`sort` 参数的行为与 `Index.union()` 相匹配（[GH 24994](https://github.com/pandas-dev/pandas/issues/24994)）

+   `RangeIndex.union()` 现在支持 `sort` 参数。如果 `sort=False`，则始终返回未排序的`Int64Index`。`sort=None` 是默认值，如果可能的话返回单调递增的`RangeIndex`，否则返回排序的`Int64Index`（[GH 24471](https://github.com/pandas-dev/pandas/issues/24471)）

+   `TimedeltaIndex.intersection()` 现在也支持 `sort` 关键字（[GH 24471](https://github.com/pandas-dev/pandas/issues/24471)）

+   `DataFrame.rename()` 现在支持 `errors` 参数，在尝试重命名不存在的键时引发错误（[GH 13473](https://github.com/pandas-dev/pandas/issues/13473)）

+   为了处理值为稀疏的`DataFrame`，增加了稀疏访问器（[GH 25681](https://github.com/pandas-dev/pandas/issues/25681)）

+   `RangeIndex` 增加了 `start`、`stop` 和 `step` 属性（[GH 25710](https://github.com/pandas-dev/pandas/issues/25710)）

+   [`datetime.timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone "(in Python v3.12)") 对象现在作为时区方法和构造函数的参数得到支持（[GH 25065](https://github.com/pandas-dev/pandas/issues/25065)）

+   `DataFrame.query()` 和 `DataFrame.eval()` 现在支持使用反引号引用具有空格的列名（[GH 6508](https://github.com/pandas-dev/pandas/issues/6508)）

+   `merge_asof()` 现在在合并键为不相等的分类变量时会给出更清晰的错误消息（[GH 26136](https://github.com/pandas-dev/pandas/issues/26136)）

+   `Rolling()` 支持指数（或泊松）窗口类型（[GH 21303](https://github.com/pandas-dev/pandas/issues/21303)）

+   丢失必需导入的错误消息现在包括原始导入错误的文本（[GH 23868](https://github.com/pandas-dev/pandas/issues/23868)）

+   `DatetimeIndex` 和 `TimedeltaIndex` 现在有一个 `mean` 方法（[GH 24757](https://github.com/pandas-dev/pandas/issues/24757)）

+   `DataFrame.describe()` 现在对整数百分位数进行格式化，不显示小数点（[GH 26660](https://github.com/pandas-dev/pandas/issues/26660)）

+   新增了对读取 SPSS .sav 文件的支持，使用 `read_spss()`（[GH 26537](https://github.com/pandas-dev/pandas/issues/26537)）

+   新增了新选项 `plotting.backend`，可以选择与现有的 `matplotlib` 不同的绘图后端。使用 `pandas.set_option('plotting.backend', '<backend-module>')`，其中 `<backend-module>` 是实现 pandas 绘图 API 的库（[GH 14130](https://github.com/pandas-dev/pandas/issues/14130)）

+   `pandas.offsets.BusinessHour` 支持多个开放时间间隔（[GH 15481](https://github.com/pandas-dev/pandas/issues/15481)）

+   `read_excel()` 现在可以使用 `openpyxl` 来读取 Excel 文件，通过参数 `engine='openpyxl'`。这将在将来的版本中成为默认值（[GH 11499](https://github.com/pandas-dev/pandas/issues/11499)）

+   `pandas.io.excel.read_excel()` 支持读取 OpenDocument 表格。指定 `engine='odf'` 来启用。更多详情请参阅 IO 用户指南（[GH 9070](https://github.com/pandas-dev/pandas/issues/9070)）

+   `Interval`、`IntervalIndex` 和 `IntervalArray` 增加了一个 `is_empty` 属性，表示给定的间隔是否为空（[GH 27219](https://github.com/pandas-dev/pandas/issues/27219)）### 带重新标记的 GroupBy 聚合

pandas 添加了特殊的分组聚合行为，称为“命名聚合”，用于在对特定列应用多个聚合函数时命名输出列（[GH 18366](https://github.com/pandas-dev/pandas/issues/18366), [GH 26512](https://github.com/pandas-dev/pandas/issues/26512)）

```py
In [1]: animals = pd.DataFrame({'kind': ['cat', 'dog', 'cat', 'dog'],
 ...:                        'height': [9.1, 6.0, 9.5, 34.0],
 ...:                        'weight': [7.9, 7.5, 9.9, 198.0]})
 ...: 

In [2]: animals
Out[2]: 
 kind  height  weight
0  cat     9.1     7.9
1  dog     6.0     7.5
2  cat     9.5     9.9
3  dog    34.0   198.0

[4 rows x 3 columns]

In [3]: animals.groupby("kind").agg(
 ...:    min_height=pd.NamedAgg(column='height', aggfunc='min'),
 ...:    max_height=pd.NamedAgg(column='height', aggfunc='max'),
 ...:    average_weight=pd.NamedAgg(column='weight', aggfunc="mean"),
 ...: )
 ...: 
Out[3]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

将所需的列名作为 `**kwargs` 传递给 `.agg`。`**kwargs` 的值应该是元组，其中第一个元素是列选择，第二个元素是要应用的聚合函数。pandas 提供了 `pandas.NamedAgg` 命名元组，以清晰地表明函数的参数是什么，但也接受普通元组。

```py
In [4]: animals.groupby("kind").agg(
 ...:    min_height=('height', 'min'),
 ...:    max_height=('height', 'max'),
 ...:    average_weight=('weight', 'mean'),
 ...: )
 ...: 
Out[4]: 
 min_height  max_height  average_weight
kind 
cat          9.1         9.5            8.90
dog          6.0        34.0          102.75

[2 rows x 3 columns] 
```

命名聚合是推荐的替代方式，用于命名列特定聚合的输出的过时“字典-字典”方法（弃用 groupby.agg() 与重命名时的字典）。

现在，对于 Series groupby 对象也提供了类似的方法。因为不需要进行列选择，所以值可以直接是要应用的函数。

```py
In [5]: animals.groupby("kind").height.agg(
 ...:    min_height="min",
 ...:    max_height="max",
 ...: )
 ...: 
Out[5]: 
 min_height  max_height
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns] 
```

这种聚合类型是将字典传递给 Series groupby 聚合时的推荐替代方法（弃用 groupby.agg() 与重命名时的字典）。

更多信息请参见命名聚合。

### 使用多个 lambdas 进行 GroupBy 聚合

您现在可以在 `GroupBy.agg` 中的列表式聚合中提供多个 lambda 函数（[GH 26430](https://github.com/pandas-dev/pandas/issues/26430)）。

```py
In [6]: animals.groupby('kind').height.agg([
 ...:    lambda x: x.iloc[0], lambda x: x.iloc[-1]
 ...: ])
 ...: 
Out[6]: 
 <lambda_0>  <lambda_1>
kind 
cat          9.1         9.5
dog          6.0        34.0

[2 rows x 2 columns]

In [7]: animals.groupby('kind').agg([
 ...:    lambda x: x.iloc[0] - x.iloc[1],
 ...:    lambda x: x.iloc[0] + x.iloc[1]
 ...: ])
 ...: 
Out[7]: 
 height                weight 
 <lambda_0> <lambda_1> <lambda_0> <lambda_1>
kind 
cat        -0.4       18.6       -2.0       17.8
dog       -28.0       40.0     -190.5      205.5

[2 rows x 4 columns] 
```

以前，这些会引发`SpecificationError`。

### 更好的 MultiIndex repr

现在，打印 `MultiIndex` 实例会显示每行的元组，并确保元组项垂直对齐，因此现在更容易理解 `MultiIndex` 的结构。([GH 13480](https://github.com/pandas-dev/pandas/issues/13480))：

现在 repr 如下所示：

```py
In [8]: pd.MultiIndex.from_product([['a', 'abc'], range(500)])
Out[8]: 
MultiIndex([(  'a',   0),
 (  'a',   1),
 (  'a',   2),
 (  'a',   3),
 (  'a',   4),
 (  'a',   5),
 (  'a',   6),
 (  'a',   7),
 (  'a',   8),
 (  'a',   9),
 ...
 ('abc', 490),
 ('abc', 491),
 ('abc', 492),
 ('abc', 493),
 ('abc', 494),
 ('abc', 495),
 ('abc', 496),
 ('abc', 497),
 ('abc', 498),
 ('abc', 499)],
 length=1000) 
```

以前，输出 `MultiIndex` 会打印出 `MultiIndex` 的所有 `levels` 和 `codes`，这在视觉上不够吸引人，并且使输出更难以导航。例如（将范围限制为 5）：

```py
In [1]: pd.MultiIndex.from_product([['a', 'abc'], range(5)])
Out[1]: MultiIndex(levels=[['a', 'abc'], [0, 1, 2, 3]],
 ...:           codes=[[0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 2, 3, 0, 1, 2, 3]]) 
```

在新的 repr 中，如果行数小于`options.display.max_seq_items`（默认值：100 项），则将显示所有值。水平上，输出将被截断，如果它比`options.display.width`（默认值：80 个字符）更宽。

### 更短的 Series 和 DataFrame 的截断 repr

目前，pandas 的默认显示选项确保当 Series 或 DataFrame 的行数超过 60 行时，其 repr 会被截断为最多 60 行（`display.max_rows` 选项）。然而，这仍然会占据大部分垂直屏幕空间的 repr。因此，引入了一个新选项 `display.min_rows`，默认为 10，确定截断 repr 中显示的行数：

+   对于小型 Series 或 DataFrame，显示最多`max_rows`行（默认值：60）。

+   对于长度超过 `max_rows` 的较大 Series 或 DataFrame，只显示 `min_rows` 行（默认为 10，即第一行和最后 5 行）。

此双重选项允许仍然查看相对较小对象的完整内容（例如 `df.head(20)` 显示所有 20 行），同时为较大对象提供简要的 repr。

要恢复以前的单一阈值行为，请设置 `pd.options.display.min_rows = None`。

### 带有 max_level 参数支持的 JSON 标准化

`json_normalize()` 将提供的输入字典标准化到所有嵌套级别。新的 max_level 参数提供了对标准化结束级别的更多控制 ([GH 23843](https://github.com/pandas-dev/pandas/issues/23843))：

现在 `repr` 看起来是这样的：

```py
from pandas.io.json import json_normalize
data = [{
    'CreatedBy': {'Name': 'User001'},
    'Lookup': {'TextField': 'Some text',
               'UserField': {'Id': 'ID001', 'Name': 'Name001'}},
    'Image': {'a': 'b'}
}]
json_normalize(data, max_level=1) 
```

### `Series.explode` 将列表类似值拆分为行

`Series` 和 `DataFrame` 现在具有 `DataFrame.explode()` 方法将列表类似对象转换为单独的行。有关更多信息，请参见文档中关于列表类似列拆分的部分 ([GH 16538](https://github.com/pandas-dev/pandas/issues/16538), [GH 10511](https://github.com/pandas-dev/pandas/issues/10511))

这是一个典型的用例。您在一列中有逗号分隔的字符串。

```py
In [9]: df = pd.DataFrame([{'var1': 'a,b,c', 'var2': 1},
 ...:                   {'var1': 'd,e,f', 'var2': 2}])
 ...: 

In [10]: df
Out[10]: 
 var1  var2
0  a,b,c     1
1  d,e,f     2

[2 rows x 2 columns] 
```

使用链式操作创建长格式 `DataFrame` 现在变得简单

```py
In [11]: df.assign(var1=df.var1.str.split(',')).explode('var1')
Out[11]: 
 var1  var2
0    a     1
0    b     1
0    c     1
1    d     2
1    e     2
1    f     2

[6 rows x 2 columns] 
```

### 其他增强

+   `DataFrame.plot()` 关键字 `logy`、`logx` 和 `loglog` 现在可以接受值 `'sym'` 进行对数对数缩放。 ([GH 24867](https://github.com/pandas-dev/pandas/issues/24867))

+   在使用 `to_datetime()` 解析日期时间时，添加了对 ISO 周年份格式（‘%G-%V-%u’）的支持（[GH 16607](https://github.com/pandas-dev/pandas/issues/16607)）

+   `DataFrame` 和 `Series` 的索引现在接受零维 `np.ndarray` ([GH 24919](https://github.com/pandas-dev/pandas/issues/24919))

+   `Timestamp.replace()` 现在支持 `fold` 参数以消除 DST 过渡时间 ([GH 25017](https://github.com/pandas-dev/pandas/issues/25017))

+   `DataFrame.at_time()` 和 `Series.at_time()` 现在支持带有时区的 [`datetime.time`](https://docs.python.org/3/library/datetime.html#datetime.time "(in Python v3.12)") 对象 ([GH 24043](https://github.com/pandas-dev/pandas/issues/24043))

+   `DataFrame.pivot_table()` 现在接受一个 `observed` 参数，该参数传递给底层调用 `DataFrame.groupby()` 来加快对分类数据的分组速度 ([GH 24923](https://github.com/pandas-dev/pandas/issues/24923))

+   `Series.str` 增加了 `Series.str.casefold()` 方法，用于消除字符串中存在的所有大小写区别 ([GH 25405](https://github.com/pandas-dev/pandas/issues/25405))

+   `DataFrame.set_index()` 现在可以用于 `abc.Iterator` 的实例，前提是它们的输出与调用框架的长度相同 ([GH 22484](https://github.com/pandas-dev/pandas/issues/22484), [GH 24984](https://github.com/pandas-dev/pandas/issues/24984))

+   `DatetimeIndex.union()` 现在支持 `sort` 参数。sort 参数的行为与 `Index.union()` 一致 ([GH 24994](https://github.com/pandas-dev/pandas/issues/24994))

+   `RangeIndex.union()` 现在支持 `sort` 参数。如果 `sort=False`，则始终返回未排序的 `Int64Index`。`sort=None` 是默认值，如果可能的话返回单调递增的 `RangeIndex`，如果不可能则返回排序的 `Int64Index` ([GH 24471](https://github.com/pandas-dev/pandas/issues/24471))

+   `TimedeltaIndex.intersection()` 现在还支持 `sort` 关键字 ([GH 24471](https://github.com/pandas-dev/pandas/issues/24471))

+   `DataFrame.rename()` 现在支持 `errors` 参数，在尝试重命名不存在的键时引发错误 ([GH 13473](https://github.com/pandas-dev/pandas/issues/13473))

+   增加了 Sparse accessor 来处理值为稀疏的 `DataFrame` ([GH 25681](https://github.com/pandas-dev/pandas/issues/25681))

+   `RangeIndex` 增加了 `start`, `stop`, 和 `step` 属性 ([GH 25710](https://github.com/pandas-dev/pandas/issues/25710))

+   现在支持将 [`datetime.timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone "(在 Python v3.12 中)") 对象作为时区方法和构造函数的参数 ([GH 25065](https://github.com/pandas-dev/pandas/issues/25065))

+   `DataFrame.query()` 和 `DataFrame.eval()` 现在支持用反引号引用带空格的列名 ([GH 6508](https://github.com/pandas-dev/pandas/issues/6508))

+   `merge_asof()` 在合并键为不相等的分类变量时现在提供更清晰的错误消息 ([GH 26136](https://github.com/pandas-dev/pandas/issues/26136))

+   `Rolling()` 支持指数（或泊松）窗口类型 ([GH 21303](https://github.com/pandas-dev/pandas/issues/21303))

+   缺少所需导入时的错误消息现在包含原始导入错误的文本 ([GH 23868](https://github.com/pandas-dev/pandas/issues/23868))

+   `DatetimeIndex` 和 `TimedeltaIndex` 现在具有 `mean` 方法 ([GH 24757](https://github.com/pandas-dev/pandas/issues/24757))

+   `DataFrame.describe()` 现在在格式化整数百分位数时不包含小数点 ([GH 26660](https://github.com/pandas-dev/pandas/issues/26660))

+   增加了使用 `read_spss()` 读取 SPSS .sav 文件的支持 ([GH 26537](https://github.com/pandas-dev/pandas/issues/26537))

+   新增了新选项 `plotting.backend`，可以选择与现有的 `matplotlib` 不同的绘图后端。使用 `pandas.set_option('plotting.backend', '<backend-module>')`，其中 `<backend-module>` 是实现 pandas 绘图 API 的库 ([GH 14130](https://github.com/pandas-dev/pandas/issues/14130))

+   `pandas.offsets.BusinessHour` 支持多个开放时间间隔 ([GH 15481](https://github.com/pandas-dev/pandas/issues/15481))

+   现在，`read_excel()` 可以通过 `engine='openpyxl'` 参数使用 `openpyxl` 读取 Excel 文件。这将在将来的版本中成为默认设置 ([GH 11499](https://github.com/pandas-dev/pandas/issues/11499))

+   `pandas.io.excel.read_excel()` 支持读取 OpenDocument 表格。指定 `engine='odf'` 来启用。请参阅 IO 用户指南 获取更多详细信息 ([GH 9070](https://github.com/pandas-dev/pandas/issues/9070))

+   `Interval`，`IntervalIndex`和`IntervalArray`获得了一个`is_empty`属性，表示给定的区间是否为空([GH 27219](https://github.com/pandas-dev/pandas/issues/27219))

## 不兼容的 API 更改

### 使用带有 UTC 偏移量的日期字符串进行索引

使用带有日期字符串的`DataFrame`或`Series`的`DatetimeIndex`进行索引，以前会忽略 UTC 偏移量。现在，索引时会尊重 UTC 偏移量。([GH 24076](https://github.com/pandas-dev/pandas/issues/24076), [GH 16785](https://github.com/pandas-dev/pandas/issues/16785))

```py
In [12]: df = pd.DataFrame([0], index=pd.DatetimeIndex(['2019-01-01'], tz='US/Pacific'))

In [13]: df
Out[13]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```

*先前的行为*:

```py
In [3]: df['2019-01-01 00:00:00+04:00':'2019-01-01 01:00:00+04:00']
Out[3]:
 0
2019-01-01 00:00:00-08:00  0 
```

*新行为*:

```py
In [14]: df['2019-01-01 12:00:00+04:00':'2019-01-01 13:00:00+04:00']
Out[14]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```  ### 从级别和代码构建的`MultiIndex`

构建带有`NaN`级别或代码值< -1 的`MultiIndex`以前是允许的。现在，不允许使用代码值< -1 进行构建，并且`NaN`级别的对应代码将被重新分配为-1。([GH 19387](https://github.com/pandas-dev/pandas/issues/19387))

*先前��行为*:

```py
In [1]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ...:              codes=[[0, -1, 1, 2, 3, 4]])
 ...:
Out[1]: MultiIndex(levels=[[nan, None, NaT, 128, 2]],
 codes=[[0, -1, 1, 2, 3, 4]])

In [2]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
Out[2]: MultiIndex(levels=[[1, 2]],
 codes=[[0, -2]]) 
```

*新行为*:

```py
In [15]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ....:              codes=[[0, -1, 1, 2, 3, 4]])
 ....: 
Out[15]: 
MultiIndex([(nan,),
 (nan,),
 (nan,),
 (nan,),
 (128,),
 (  2,)],
 )

In [16]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
---------------------------------------------------------------------------
ValueError  Traceback (most recent call last)
Cell In[16], line 1
----> 1 pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:364, in MultiIndex.__new__(cls, levels, codes, sortorder, names, dtype, copy, name, verify_integrity)
  361     result.sortorder = sortorder
  363 if verify_integrity:
--> 364     new_codes = result._verify_integrity()
  365     result._codes = new_codes
  367 result._reset_identity()

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:451, in MultiIndex._verify_integrity(self, codes, levels, levels_to_verify)
  445     raise ValueError(
  446         f"On level {i}, code max ({level_codes.max()}) >= length of "
  447         f"level ({len(level)}). NOTE: this index is in an "
  448         "inconsistent state"
  449     )
  450 if len(level_codes) and level_codes.min() < -1:
--> 451     raise ValueError(f"On level {i}, code value ({level_codes.min()}) < -1")
  452 if not level.is_unique:
  453     raise ValueError(
  454         f"Level values must be unique: {list(level)} on level {i}"
  455     )

ValueError: On level 0, code value (-2) < -1 
```  ### 在`DataFrame`上使用`GroupBy.apply`仅评估第一组一次

先前对`DataFrameGroupBy.apply()`的实现在第一组上一致评估提供的函数两次，以推断是否可以使用快速代码路径。特别是对于具有副作用的函数，这是一种不希望的行为，可能会导致意外。([GH 2936](https://github.com/pandas-dev/pandas/issues/2936), [GH 2656](https://github.com/pandas-dev/pandas/issues/2656), [GH 7739](https://github.com/pandas-dev/pandas/issues/7739), [GH 10519](https://github.com/pandas-dev/pandas/issues/10519), [GH 12155](https://github.com/pandas-dev/pandas/issues/12155), [GH 20084](https://github.com/pandas-dev/pandas/issues/20084), [GH 21417](https://github.com/pandas-dev/pandas/issues/21417))

现在每个组仅评估一次。

```py
In [17]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [18]: df
Out[18]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns]

In [19]: def func(group):
 ....:    print(group.name)
 ....:    return group
 ....: 
```

*先前的行为*:

```py
In [3]: df.groupby('a').apply(func)
x
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*:

```py
In [3]: df.groupby('a').apply(func)
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

### 连接稀疏值

当传递值为稀疏的 DataFrame 时，`concat()` 现在将返回具有稀疏值的 `Series` 或 `DataFrame`，而不是 `SparseDataFrame`（[GH 25702](https://github.com/pandas-dev/pandas/issues/25702))。

```py
In [20]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 1])}) 
```

*先前的行为*：

```py
In [2]: type(pd.concat([df, df]))
pandas.core.sparse.frame.SparseDataFrame 
```

*新的行为*：

```py
In [21]: type(pd.concat([df, df]))
Out[21]: pandas.core.frame.DataFrame 
```

现在这与对稀疏值 `Series` 的 `concat` 现有行为相匹配。当所有值都是 `SparseDataFrame` 的实例时，`concat()` 将继续返回 `SparseDataFrame`。

此更改还影响到内部使用 `concat()` 的例程，例如 `get_dummies()`，它现在在所有情况下返回一个 `DataFrame`（如果所有列都是虚拟编码，则以前返回 `SparseDataFrame`，否则返回 `DataFrame`）。

将任何 `SparseSeries` 或 `SparseDataFrame` 提供给 `concat()` 将导致返回 `SparseSeries` 或 `SparseDataFrame`，与以前相同。

### `.str` 访问器执行更严格的类型检查。

由于缺乏更细粒度的数据类型，`Series.str` 到目前为止仅检查数据是否为 `object` 数据类型。`Series.str` 现在将在 Series 内推断数据类型；特别是，仅 `'bytes'` 数据将引发异常（除了 `Series.str.decode()`、`Series.str.get()`、`Series.str.len()`、`Series.str.slice()`），参见 [GH 23163](https://github.com/pandas-dev/pandas/issues/23163)、[GH 23011](https://github.com/pandas-dev/pandas/issues/23011)、[GH 23551](https://github.com/pandas-dev/pandas/issues/23551)。

*先前的行为*：

```py
In [1]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [2]: s
Out[2]:
0      b'a'
1     b'ba'
2    b'cba'
dtype: object

In [3]: s.str.startswith(b'a')
Out[3]:
0     True
1    False
2    False
dtype: bool 
```

*新的行为*：

```py
In [22]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [23]: s
Out[23]: 
0      b'a'
1     b'ba'
2    b'cba'
Length: 3, dtype: object

In [24]: s.str.startswith(b'a')
---------------------------------------------------------------------------
TypeError  Traceback (most recent call last)
Cell In[24], line 1
----> 1 s.str.startswith(b'a')

File ~/work/pandas/pandas/pandas/core/strings/accessor.py:136, in forbid_nonstring_types.<locals>._forbid_nonstring_types.<locals>.wrapper(self, *args, **kwargs)
  131 if self._inferred_dtype not in allowed_types:
  132     msg = (
  133         f"Cannot use .str.{func_name} with values of "
  134         f"inferred dtype '{self._inferred_dtype}'."
  135     )
--> 136     raise TypeError(msg)
  137 return func(self, *args, **kwargs)

TypeError: Cannot use .str.startswith with values of inferred dtype 'bytes'. 
```

### 分组后保留分类数据类型

以前，被归类为分类，但不是 groupby 键的列在 groupby 操作期间将被转换为 `object` dtype。现在 pandas 将保留这些 dtype。([GH 18502](https://github.com/pandas-dev/pandas/issues/18502))

```py
In [25]: cat = pd.Categorical(["foo", "bar", "bar", "qux"], ordered=True)

In [26]: df = pd.DataFrame({'payload': [-1, -2, -1, -2], 'col': cat})

In [27]: df
Out[27]: 
 payload  col
0       -1  foo
1       -2  bar
2       -1  bar
3       -2  qux

[4 rows x 2 columns]

In [28]: df.dtypes
Out[28]: 
payload       int64
col        category
Length: 2, dtype: object 
```

*先前的行为*：

```py
In [5]: df.groupby('payload').first().col.dtype
Out[5]: dtype('O') 
```

*新行为*：

```py
In [29]: df.groupby('payload').first().col.dtype
Out[29]: CategoricalDtype(categories=['bar', 'foo', 'qux'], ordered=True, categories_dtype=object) 
```  ### 不兼容的索引类型联合

在不兼容 dtype 的对象之间执行 `Index.union()` 操作时，结果将是 dtype 为 `object` 的基本 `Index`。对于以前被禁止的 `Index` 对象之间的联合，此行为仍然成立。现在将在执行联合操作之前评估空 `Index` 对象的 dtype，而不仅仅返回另一个 `Index` 对象。现在可以认为 `Index.union()` 是可交换的，即 `A.union(B) == B.union(A)` ([GH 23525](https://github.com/pandas-dev/pandas/issues/23525))。

*先前的行为*：

```py
In [1]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
...
ValueError: can only call with other PeriodIndex-ed objects

In [2]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[2]: Int64Index([1, 2, 3], dtype='int64') 
```

*新行为*：

```py
In [3]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
Out[3]: Index([1991-09-05, 1991-09-06, 1, 2, 3], dtype='object')
In [4]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[4]: Index([1, 2, 3], dtype='object') 
```

请注意，整数和浮点数索引被视为“兼容的”。整数值被强制转换为浮点数，这可能导致精度丢失。更多信息请参见 Index 对象上的集合操作。

### `DataFrame` GroupBy ffill/bfill 不再返回组标签

`DataFrameGroupBy` 的方法 `ffill`、`bfill`、`pad` 和 `backfill` 以前在返回值中包括了组标签，这与其他 groupby 转换不一致。现在只返回填充值。([GH 21521](https://github.com/pandas-dev/pandas/issues/21521))

```py
In [30]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [31]: df
Out[31]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns] 
```

*先前的行为*：

```py
In [3]: df.groupby("a").ffill()
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*：

```py
In [32]: df.groupby("a").ffill()
Out[32]: 
 b
0  1
1  2

[2 rows x 1 columns] 
```

### `DataFrame` 在空的分类 / 对象列上进行描述将返回顶部和频率

当在空的分类 / 对象列上调用 `DataFrame.describe()` 时，“top” 和 “freq” 列以前会被省略，这与非空列的输出不一致。现在，“top” 和 “freq” 列将始终包括在内，在空 `DataFrame` 的情况下为 `numpy.nan` ([GH 26397](https://github.com/pandas-dev/pandas/issues/26397))。

```py
In [33]: df = pd.DataFrame({"empty_col": pd.Categorical([])})

In [34]: df
Out[34]: 
Empty DataFrame
Columns: [empty_col]
Index: []

[0 rows x 1 columns] 
```

*先前的行为*：

```py
In [3]: df.describe()
Out[3]:
        empty_col
count           0
unique          0 
```

*新行为*：

```py
In [35]: df.describe()
Out[35]: 
 empty_col
count          0
unique         0
top          NaN
freq         NaN

[4 rows x 1 columns] 
```

### `__str__` 方法现在调用 `__repr__` 而不是反过来

到目前为止，pandas 主要在 pandas 对象的 `__str__`/`__unicode__`/`__bytes__` 方法中定义字符串表示，并在 `__repr__` 方法中调用 `__str__`，如果没有找到特定的 `__repr__` 方法。对于 Python3 不再需要这样做。在 pandas 0.25 中，pandas 对象的字符串表示现在通常在 `__repr__` 中定义，并且一般现在调用 `__str__` 的调用会传递给 `__repr__`，如果没有找到特定的 `__str__` 方法，这是 Python 的标准做法。这个变化对于直接使用 pandas 是向后兼容的，但是如果你子类化了 pandas 对象 *并且* 给你的子类特定的 `__str__`/`__repr__` 方法，你可能需要调整你的 `__str__`/`__repr__` 方法（[GH 26495](https://github.com/pandas-dev/pandas/issues/26495)）。

### 使用 `Interval` 对象索引 `IntervalIndex`

`IntervalIndex` 的索引方法已经修改，现在只对 `Interval` 查询要求精确匹配。`IntervalIndex` 方法以前会匹配任何重叠的 `Interval`。对于标量点（例如使用整数查询），行为不变（[GH 16316](https://github.com/pandas-dev/pandas/issues/16316)）。

```py
In [36]: ii = pd.IntervalIndex.from_tuples([(0, 4), (1, 5), (5, 8)])

In [37]: ii
Out[37]: IntervalIndex([(0, 4], (1, 5], (5, 8]], dtype='interval[int64, right]') 
```

`in` 运算符 (`__contains__`) 现在只对 `IntervalIndex` 中的 `Interval` 进行精确匹配返回 `True`，而以前对于任何重叠于 `IntervalIndex` 中的 `Interval` 的 `Interval` 将返回 `True`。

*之前的行为*：

```py
In [4]: pd.Interval(1, 2, closed='neither') in ii
Out[4]: True

In [5]: pd.Interval(-10, 10, closed='both') in ii
Out[5]: True 
```

*新的行为*：

```py
In [38]: pd.Interval(1, 2, closed='neither') in ii
Out[38]: False

In [39]: pd.Interval(-10, 10, closed='both') in ii
Out[39]: False 
```

`get_loc()` 方法现在只返回与 `Interval` 查询的精确匹配的位置，而不是以前的返回重叠匹配的位置。如果找不到精确匹配，将引发 `KeyError`。

*之前的行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: array([0, 1])

In [7]: ii.get_loc(pd.Interval(2, 6))
Out[7]: array([0, 1, 2]) 
```

*新的行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: 1

In [7]: ii.get_loc(pd.Interval(2, 6))
---------------------------------------------------------------------------
KeyError: Interval(2, 6, closed='right') 
```

同样，`get_indexer()` 和 `get_indexer_non_unique()` 现在也只对 `Interval` 查询的精确匹配返回位置，使用 `-1` 表示找不到精确匹配。

这些索引更改扩展到使用 `IntervalIndex` 索引查询 `Series` 或 `DataFrame`。

```py
In [40]: s = pd.Series(list('abc'), index=ii)

In [41]: s
Out[41]: 
(0, 4]    a
(1, 5]    b
(5, 8]    c
Length: 3, dtype: object 
```

使用 `[]` (`__getitem__`) 或 `loc` 从 `Series` 或 `DataFrame` 中进行选择现在只返回 `Interval` 查询的精确匹配。

*之前的行为*：

```py
In [8]: s[pd.Interval(1, 5)]
Out[8]:
(0, 4]    a
(1, 5]    b
dtype: object

In [9]: s.loc[pd.Interval(1, 5)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新的行为*：

```py
In [42]: s[pd.Interval(1, 5)]
Out[42]: 'b'

In [43]: s.loc[pd.Interval(1, 5)]
Out[43]: 'b' 
```

类似地，对于非精确匹配，将引发 `KeyError` 而不是返回重叠匹配。

*之前的行为*：

```py
In [9]: s[pd.Interval(2, 3)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object

In [10]: s.loc[pd.Interval(2, 3)]
Out[10]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新的行为*：

```py
In [6]: s[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right')

In [7]: s.loc[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right') 
```

`overlaps()` 方��可用于创建一个布尔索引器，复制以前返回重叠匹配的行为。

*新行为*:

```py
In [44]: idxr = s.index.overlaps(pd.Interval(2, 3))

In [45]: idxr
Out[45]: array([ True,  True, False])

In [46]: s[idxr]
Out[46]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object

In [47]: s.loc[idxr]
Out[47]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object 
```  ### Series 上的二进制 ufuncs 现在对齐

现在应用类似 `numpy.power()` 的二进制 ufunc 时，当两者都是 `Series` 时会对齐输入（[GH 23293](https://github.com/pandas-dev/pandas/issues/23293)）。

```py
In [48]: s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s2 = pd.Series([3, 4, 5], index=['d', 'c', 'b'])

In [50]: s1
Out[50]: 
a    1
b    2
c    3
Length: 3, dtype: int64

In [51]: s2
Out[51]: 
d    3
c    4
b    5
Length: 3, dtype: int64 
```

*先前行为*

```py
In [5]: np.power(s1, s2)
Out[5]:
a      1
b     16
c    243
dtype: int64 
```

*新行为*

```py
In [52]: np.power(s1, s2)
Out[52]: 
a     1.0
b    32.0
c    81.0
d     NaN
Length: 4, dtype: float64 
```

这与 pandas 中其他二进制操作的行为相匹配，比如 `Series.add()`。要保留先前的行为，将另一个 `Series` 转换为数组后再应用 ufunc。

```py
In [53]: np.power(s1, s2.array)
Out[53]: 
a      1
b     16
c    243
Length: 3, dtype: int64 
```

### Categorical.argsort 现在将缺失值放在末尾

`Categorical.argsort()` 现在将缺失值放在数组末尾，使其与 NumPy 和 pandas 的其余部分保持一致（[GH 21801](https://github.com/pandas-dev/pandas/issues/21801)）。

```py
In [54]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True) 
```

*先前行为*

```py
In [2]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True)

In [3]: cat.argsort()
Out[3]: array([1, 2, 0])

In [4]: cat[cat.argsort()]
Out[4]:
[NaN, a, b]
categories (2, object): [a < b] 
```

*新行为*

```py
In [55]: cat.argsort()
Out[55]: array([2, 0, 1])

In [56]: cat[cat.argsort()]
Out[56]: 
['a', 'b', NaN]
Categories (2, object): ['a' < 'b'] 
```

### 传递字典列表到 DataFrame 时保留列顺序

从 Python 3.7 开始，`dict` 的键顺序是[有保证的](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)。实际上，自 Python 3.6 起就是如此。`DataFrame` 构造函数现在将字典列表与 `OrderedDict` 列表一样对待，即保留字典的顺序。此更改仅在 pandas 运行在 Python>=3.6 时适用（[GH 27309](https://github.com/pandas-dev/pandas/issues/27309)）。

```py
In [57]: data = [
 ....:    {'name': 'Joe', 'state': 'NY', 'age': 18},
 ....:    {'name': 'Jane', 'state': 'KY', 'age': 19, 'hobby': 'Minecraft'},
 ....:    {'name': 'Jean', 'state': 'OK', 'age': 20, 'finances': 'good'}
 ....: ]
 ....: 
```

*先前行为*:

先前列是按字典顺序排序的，

```py
In [1]: pd.DataFrame(data)
Out[1]:
   age finances      hobby  name state
0   18      NaN        NaN   Joe    NY
1   19      NaN  Minecraft  Jane    KY
2   20     good        NaN  Jean    OK 
```

*新行为*:

现在列顺序与 `dict` 中键的插入顺序匹配，考虑从上到下的所有记录。因此，与以前的 pandas 版本相比，生成的 DataFrame 的列顺序已更改。

```py
In [58]: pd.DataFrame(data)
Out[58]: 
 name state  age      hobby finances
0   Joe    NY   18        NaN      NaN
1  Jane    KY   19  Minecraft      NaN
2  Jean    OK   20        NaN     good

[3 rows x 5 columns] 
```  ### 依赖项的最低版本增加

由于不再支持 Python 2.7，一些可选依赖项的最低版本已更新（[GH 25725](https://github.com/pandas-dev/pandas/issues/25725)，[GH 24942](https://github.com/pandas-dev/pandas/issues/24942)，[GH 25752](https://github.com/pandas-dev/pandas/issues/25752)）。此外，一些依赖项的最低支持版本已更新（[GH 23519](https://github.com/pandas-dev/pandas/issues/23519)，[GH 25554](https://github.com/pandas-dev/pandas/issues/25554)）。如果已安装，我们现在要求：

| 包 | 最低版本 | 必需 |
| --- | --- | --- |
| numpy | 1.13.3 | X |
| pytz | 2015.4 | X |
| python-dateutil | 2.6.1 | X |
| bottleneck | 1.2.1 |  |
| numexpr | 2.6.2 |  |
| pytest (dev) | 4.0.2 |  |

对于[可选库](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最新版本。以下表格列出了在 pandas 开发过程中当前正在测试的每个库的最低版本。低于最低测试版本的可选库可能仍然可用，但不被视为受支持的。

| 包 | 最低版本 |
| --- | --- |
| beautifulsoup4 | 4.6.0 |
| fastparquet | 0.2.1 |
| gcsfs | 0.2.2 |
| lxml | 3.8.0 |
| matplotlib | 2.2.2 |
| openpyxl | 2.4.8 |
| pyarrow | 0.9.0 |
| pymysql | 0.7.1 |
| pytables | 3.4.2 |
| scipy | 0.19.0 |
| sqlalchemy | 1.1.4 |
| xarray | 0.8.2 |
| xlrd | 1.1.0 |
| xlsxwriter | 0.9.8 |
| xlwt | 1.2.0 |

请参阅依赖项和可选依赖项了解更多信息。 ### 其他 API 更改

+   `DatetimeTZDtype`现在将 pytz 时区标准化为一个公共时区实例（[GH 24713](https://github.com/pandas-dev/pandas/issues/24713)）

+   `Timestamp`和`Timedelta`标量现在实现了`to_numpy()`方法，作为`Timestamp.to_datetime64()`和`Timedelta.to_timedelta64()`的别名。 （[GH 24653](https://github.com/pandas-dev/pandas/issues/24653)）

+   `Timestamp.strptime()`现在将引发`NotImplementedError`（[GH 25016](https://github.com/pandas-dev/pandas/issues/25016)）

+   将`Timestamp`与不支持的对象进行比较现在返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "(in Python v3.12)")，而不是引发`TypeError`。这意味着不受支持的丰富比较被委托给其他对象，并且现在与 Python 3 中的`datetime`对象一致行为（[GH 24011](https://github.com/pandas-dev/pandas/issues/24011)）

+   `DatetimeIndex.snap()`中的错误，没有保留输入`Index`的`name`（[GH 25575](https://github.com/pandas-dev/pandas/issues/25575)）

+   `DataFrameGroupBy.agg()` 中的 `arg` 参数已重命名为 `func` ([GH 26089](https://github.com/pandas-dev/pandas/issues/26089))

+   `Window.aggregate()` 中的 `arg` 参数已重命名为 `func` ([GH 26372](https://github.com/pandas-dev/pandas/issues/26372))

+   大多数 pandas 类都有一个 `__bytes__` 方法，用于获取对象的 python2 风格的字节串表示。这个方法已经被移除，作为放弃 Python2 的一部分 ([GH 26447](https://github.com/pandas-dev/pandas/issues/26447))

+   对于 1 级 `MultiIndex`，已禁用 `.str` 访问器，如果需要，使用 `MultiIndex.to_flat_index()` ([GH 23679](https://github.com/pandas-dev/pandas/issues/23679))

+   移除了对 gtk 包在剪贴板上的支持 ([GH 26563](https://github.com/pandas-dev/pandas/issues/26563))

+   使用不受支持的 Beautiful Soup 4 版本现在会引发 `ImportError` 而不是 `ValueError` ([GH 27063](https://github.com/pandas-dev/pandas/issues/27063))

+   `Series.to_excel()` 和 `DataFrame.to_excel()` 在保存时区感知数据时现在会引发 `ValueError` ([GH 27008](https://github.com/pandas-dev/pandas/issues/27008), [GH 7056](https://github.com/pandas-dev/pandas/issues/7056))

+   `ExtensionArray.argsort()` 将 NA 值放在排序后的数组末尾。 ([GH 21801](https://github.com/pandas-dev/pandas/issues/21801))

+   `DataFrame.to_hdf()` 和 `Series.to_hdf()` 在保存带有扩展数据类型的 `fixed` 格式的 `MultiIndex` 时现在会引发 `NotImplementedError` ([GH 7775](https://github.com/pandas-dev/pandas/issues/7775))

+   在 `read_csv()` 中传递重复的 `names` 现在会引发 `ValueError` ([GH 17346](https://github.com/pandas-dev/pandas/issues/17346))  ### 使用带有 UTC 偏移的日期字符串进行索引

使用带有日期字符串的带有 UTC 偏移的 `DatetimeIndex` 索引 `DataFrame` 或 `Series` 以前会忽略 UTC 偏移。现在，UTC 偏移在索引中受到尊重。 ([GH 24076](https://github.com/pandas-dev/pandas/issues/24076), [GH 16785](https://github.com/pandas-dev/pandas/issues/16785))

```py
In [12]: df = pd.DataFrame([0], index=pd.DatetimeIndex(['2019-01-01'], tz='US/Pacific'))

In [13]: df
Out[13]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```

*先前的行为*:

```py
In [3]: df['2019-01-01 00:00:00+04:00':'2019-01-01 01:00:00+04:00']
Out[3]:
 0
2019-01-01 00:00:00-08:00  0 
```

*新行为*:

```py
In [14]: df['2019-01-01 12:00:00+04:00':'2019-01-01 13:00:00+04:00']
Out[14]: 
 0
2019-01-01 00:00:00-08:00  0

[1 rows x 1 columns] 
```

### 从级别和代码构建的 `MultiIndex`

先前允许使用 `NaN` 级别或代码值 < -1 构建 `MultiIndex`。现在，不允许使用代码值 < -1 进行构建，并且 `NaN` 级别的相应代码将被重新分配为 -1\. ([GH 19387](https://github.com/pandas-dev/pandas/issues/19387))

*先前的行为*:

```py
In [1]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ...:              codes=[[0, -1, 1, 2, 3, 4]])
 ...:
Out[1]: MultiIndex(levels=[[nan, None, NaT, 128, 2]],
 codes=[[0, -1, 1, 2, 3, 4]])

In [2]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
Out[2]: MultiIndex(levels=[[1, 2]],
 codes=[[0, -2]]) 
```

*新行为*:

```py
In [15]: pd.MultiIndex(levels=[[np.nan, None, pd.NaT, 128, 2]],
 ....:              codes=[[0, -1, 1, 2, 3, 4]])
 ....: 
Out[15]: 
MultiIndex([(nan,),
 (nan,),
 (nan,),
 (nan,),
 (128,),
 (  2,)],
 )

In [16]: pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])
---------------------------------------------------------------------------
ValueError  Traceback (most recent call last)
Cell In[16], line 1
----> 1 pd.MultiIndex(levels=[[1, 2]], codes=[[0, -2]])

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:364, in MultiIndex.__new__(cls, levels, codes, sortorder, names, dtype, copy, name, verify_integrity)
  361     result.sortorder = sortorder
  363 if verify_integrity:
--> 364     new_codes = result._verify_integrity()
  365     result._codes = new_codes
  367 result._reset_identity()

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:451, in MultiIndex._verify_integrity(self, codes, levels, levels_to_verify)
  445     raise ValueError(
  446         f"On level {i}, code max ({level_codes.max()}) >= length of "
  447         f"level ({len(level)}). NOTE: this index is in an "
  448         "inconsistent state"
  449     )
  450 if len(level_codes) and level_codes.min() < -1:
--> 451     raise ValueError(f"On level {i}, code value ({level_codes.min()}) < -1")
  452 if not level.is_unique:
  453     raise ValueError(
  454         f"Level values must be unique: {list(level)} on level {i}"
  455     )

ValueError: On level 0, code value (-2) < -1 
```

### `GroupBy.apply` 在 `DataFrame` 上仅评估第一组一次

先前对 `DataFrameGroupBy.apply()` 的实现在第一组上一致两次评估提供的函数，以推断是否可以使用快速代码路径。特别是对于具有副作用的函数，这是一种不希望的行为，可能会导致意外情况。 ([GH 2936](https://github.com/pandas-dev/pandas/issues/2936), [GH 2656](https://github.com/pandas-dev/pandas/issues/2656), [GH 7739](https://github.com/pandas-dev/pandas/issues/7739), [GH 10519](https://github.com/pandas-dev/pandas/issues/10519), [GH 12155](https://github.com/pandas-dev/pandas/issues/12155), [GH 20084](https://github.com/pandas-dev/pandas/issues/20084), [GH 21417](https://github.com/pandas-dev/pandas/issues/21417))

现在每个组仅评估一次。

```py
In [17]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [18]: df
Out[18]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns]

In [19]: def func(group):
 ....:    print(group.name)
 ....:    return group
 ....: 
```

*先前的行为*:

```py
In [3]: df.groupby('a').apply(func)
x
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*:

```py
In [3]: df.groupby('a').apply(func)
x
y
Out[3]:
   a  b
0  x  1
1  y  2 
```

### 连接稀疏值

当传递值为稀疏的数据框时，`concat()` 现在将返回一个具有稀疏值的 `Series` 或 `DataFrame`，而不是一个 `SparseDataFrame` ([GH 25702](https://github.com/pandas-dev/pandas/issues/25702))。

```py
In [20]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 1])}) 
```

*先前的行为*:

```py
In [2]: type(pd.concat([df, df]))
pandas.core.sparse.frame.SparseDataFrame 
```

*新行为*:

```py
In [21]: type(pd.concat([df, df]))
Out[21]: pandas.core.frame.DataFrame 
```

这现在与具有稀疏值的 `Series` 上的 `concat` 的现有行为相匹配。当所有值都是 `SparseDataFrame` 的实例时，`concat()` 将继续返回 `SparseDataFrame`。

此更改还会影响内部使用`concat()`的例程，如`get_dummies()`，它现在在所有情况下都返回一个`DataFrame`（如果所有列都是虚拟编码，则以前返回`SparseDataFrame`，否则返回`DataFrame`）。

向 `concat()` 提供任何 `SparseSeries` 或 `SparseDataFrame` 将导致返回 `SparseSeries` 或 `SparseDataFrame`，与以前一样。

### `.str` 访问器执行更严格的类型检查

由于缺乏更精细的数据类型，`Series.str` 迄今仅检查数据是否为 `object` 数据类型。 `Series.str` 现在将推断序列内的数据类型；特别是，仅 `'bytes'` 数据将引发异常（除了 `Series.str.decode()`、`Series.str.get()`、`Series.str.len()`、`Series.str.slice()`)，参见 [GH 23163](https://github.com/pandas-dev/pandas/issues/23163)、[GH 23011](https://github.com/pandas-dev/pandas/issues/23011)、[GH 23551](https://github.com/pandas-dev/pandas/issues/23551)。

*之前的行为*：

```py
In [1]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [2]: s
Out[2]:
0      b'a'
1     b'ba'
2    b'cba'
dtype: object

In [3]: s.str.startswith(b'a')
Out[3]:
0     True
1    False
2    False
dtype: bool 
```

*新的行为*：

```py
In [22]: s = pd.Series(np.array(['a', 'ba', 'cba'], 'S'), dtype=object)

In [23]: s
Out[23]: 
0      b'a'
1     b'ba'
2    b'cba'
Length: 3, dtype: object

In [24]: s.str.startswith(b'a')
---------------------------------------------------------------------------
TypeError  Traceback (most recent call last)
Cell In[24], line 1
----> 1 s.str.startswith(b'a')

File ~/work/pandas/pandas/pandas/core/strings/accessor.py:136, in forbid_nonstring_types.<locals>._forbid_nonstring_types.<locals>.wrapper(self, *args, **kwargs)
  131 if self._inferred_dtype not in allowed_types:
  132     msg = (
  133         f"Cannot use .str.{func_name} with values of "
  134         f"inferred dtype '{self._inferred_dtype}'."
  135     )
--> 136     raise TypeError(msg)
  137 return func(self, *args, **kwargs)

TypeError: Cannot use .str.startswith with values of inferred dtype 'bytes'. 
```

### 分类数据类型在 GroupBy 操作期间保留

以前，作为分类的列，但不是 groupby 键的列在 groupby 操作期间会转换为 `object` 数据类型。现在 pandas 将保留这些数据类型。 ([GH 18502](https://github.com/pandas-dev/pandas/issues/18502))

```py
In [25]: cat = pd.Categorical(["foo", "bar", "bar", "qux"], ordered=True)

In [26]: df = pd.DataFrame({'payload': [-1, -2, -1, -2], 'col': cat})

In [27]: df
Out[27]: 
 payload  col
0       -1  foo
1       -2  bar
2       -1  bar
3       -2  qux

[4 rows x 2 columns]

In [28]: df.dtypes
Out[28]: 
payload       int64
col        category
Length: 2, dtype: object 
```

*之前的行为*：

```py
In [5]: df.groupby('payload').first().col.dtype
Out[5]: dtype('O') 
```

*新的行为*：

```py
In [29]: df.groupby('payload').first().col.dtype
Out[29]: CategoricalDtype(categories=['bar', 'foo', 'qux'], ordered=True, categories_dtype=object) 
```

### 不兼容的索引类型联合

在不兼容 dtypes 的对象之间执行 `Index.union()` 操作时，结果将是 dtype 为 `object` 的基础 `Index`。此行为适用于以前将被禁止的 `Index` 对象之间的联合。现在将在执行联合操作之前评估空的 `Index` 对象的 dtype，而不仅仅返回其他 `Index` 对象。`Index.union()` 现在可以被认为是可交换的，这样 `A.union(B) == B.union(A)` ([GH 23525](https://github.com/pandas-dev/pandas/issues/23525))。

*先前的行为*：

```py
In [1]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
...
ValueError: can only call with other PeriodIndex-ed objects

In [2]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[2]: Int64Index([1, 2, 3], dtype='int64') 
```

*新行为*：

```py
In [3]: pd.period_range('19910905', periods=2).union(pd.Int64Index([1, 2, 3]))
Out[3]: Index([1991-09-05, 1991-09-06, 1, 2, 3], dtype='object')
In [4]: pd.Index([], dtype=object).union(pd.Index([1, 2, 3]))
Out[4]: Index([1, 2, 3], dtype='object') 
```

请注意，整数和浮点型索引被视为“兼容”。整数值被强制转换为浮点数，可能会导致精度损失。有关更多信息，请参见索引对象上的集合操作。

### `DataFrame` GroupBy 的 ffill/bfill 现在不再返回分组标签。

`DataFrameGroupBy` 的 `ffill`、`bfill`、`pad` 和 `backfill` 方法以前在返回值中包括分组标签，这与其他 groupby 转换不一致。现在只返回填充的值。([GH 21521](https://github.com/pandas-dev/pandas/issues/21521))

```py
In [30]: df = pd.DataFrame({"a": ["x", "y"], "b": [1, 2]})

In [31]: df
Out[31]: 
 a  b
0  x  1
1  y  2

[2 rows x 2 columns] 
```

*先前的行为*：

```py
In [3]: df.groupby("a").ffill()
Out[3]:
   a  b
0  x  1
1  y  2 
```

*新行为*：

```py
In [32]: df.groupby("a").ffill()
Out[32]: 
 b
0  1
1  2

[2 rows x 1 columns] 
```

### 在空的分类 / 对象列上对 `DataFrame` 进行描述将返回 top 和 freq。

当在空的分类 / 对象列上调用 `DataFrame.describe()` 时，先前会省略 'top' 和 'freq' 列，这与非空列的输出不一致。现在 'top' 和 'freq' 列将始终包含在内，在空的 `DataFrame` 中用 `numpy.nan` 表示（[GH 26397](https://github.com/pandas-dev/pandas/issues/26397)）。

```py
In [33]: df = pd.DataFrame({"empty_col": pd.Categorical([])})

In [34]: df
Out[34]: 
Empty DataFrame
Columns: [empty_col]
Index: []

[0 rows x 1 columns] 
```

*先前的行为*：

```py
In [3]: df.describe()
Out[3]:
        empty_col
count           0
unique          0 
```

*新行为*：

```py
In [35]: df.describe()
Out[35]: 
 empty_col
count          0
unique         0
top          NaN
freq         NaN

[4 rows x 1 columns] 
```

### `__str__` 方法现在调用 `__repr__` 而不是相反。

到目前为止，pandas 在 pandas 对象的 `__str__`/`__unicode__`/`__bytes__` 方法中定义字符串表示大多数情况，并且在没有找到特定 `__repr__` 方法时从 `__repr__` 方法中调用 `__str__`。对于 Python3 不再需要这样做。在 pandas 0.25 中，pandas 对象的字符串表示现在通常在 `__repr__` 中定义，并且一般情况下现在将 `__str__` 的调用传递给 `__repr__`，如果没有找到特定的 `__str__` 方法，这符合 Python 的标准。这个变化对于直接使用 pandas 是向后兼容的，但是如果你子类化 pandas 对象 *并且* 给你的子类特定的 `__str__`/`__repr__` 方法，你可能需要调整你的 `__str__`/`__repr__` 方法（[GH 26495](https://github.com/pandas-dev/pandas/issues/26495)）。

### 使用 `Interval` 对象索引 `IntervalIndex`

对于 `IntervalIndex` 的索引方法已经修改，现在只对 `Interval` 查询要求精确匹配。`IntervalIndex` 方法先前在任何重叠的 `Interval` 上匹配。与标量点的行为，例如使用整数查询，保持不变（[GH 16316](https://github.com/pandas-dev/pandas/issues/16316)）。

```py
In [36]: ii = pd.IntervalIndex.from_tuples([(0, 4), (1, 5), (5, 8)])

In [37]: ii
Out[37]: IntervalIndex([(0, 4], (1, 5], (5, 8]], dtype='interval[int64, right]') 
```

`in` 操作符 (`__contains__`) 现在只对 `IntervalIndex` 中 `Intervals` 的精确匹配返回 `True`，而以前对于任何与 `IntervalIndex` 中的 `Interval` 重叠的 `Interval` 也会返回 `True`。

*先前的行为*：

```py
In [4]: pd.Interval(1, 2, closed='neither') in ii
Out[4]: True

In [5]: pd.Interval(-10, 10, closed='both') in ii
Out[5]: True 
```

*新行为*：

```py
In [38]: pd.Interval(1, 2, closed='neither') in ii
Out[38]: False

In [39]: pd.Interval(-10, 10, closed='both') in ii
Out[39]: False 
```

`get_loc()` 方法现在只对 `Interval` 查询的精确匹配返回位置，而不是以前的重叠匹配。如果找不到精确匹配，将引发 `KeyError`。

*先前的行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: array([0, 1])

In [7]: ii.get_loc(pd.Interval(2, 6))
Out[7]: array([0, 1, 2]) 
```

*新行为*：

```py
In [6]: ii.get_loc(pd.Interval(1, 5))
Out[6]: 1

In [7]: ii.get_loc(pd.Interval(2, 6))
---------------------------------------------------------------------------
KeyError: Interval(2, 6, closed='right') 
```

同样地，`get_indexer()` 和 `get_indexer_non_unique()` 现在也只对 `Interval` 查询的精确匹配返回位置，其中 `-1` 表示找不到精确匹配。

这些索引变化延伸到使用 `IntervalIndex` 索引查询 `Series` 或 `DataFrame`。

```py
In [40]: s = pd.Series(list('abc'), index=ii)

In [41]: s
Out[41]: 
(0, 4]    a
(1, 5]    b
(5, 8]    c
Length: 3, dtype: object 
```

使用 `[]` (`__getitem__`) 或 `loc` 从 `Series` 或 `DataFrame` 中选择时，现在只对 `Interval` 查询返回精确匹配。

*先前的行为*：

```py
In [8]: s[pd.Interval(1, 5)]
Out[8]:
(0, 4]    a
(1, 5]    b
dtype: object

In [9]: s.loc[pd.Interval(1, 5)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新行为*：

```py
In [42]: s[pd.Interval(1, 5)]
Out[42]: 'b'

In [43]: s.loc[pd.Interval(1, 5)]
Out[43]: 'b' 
```

类似地，对于非精确匹配，将引发 `KeyError`，而不是返回重叠匹配。

*先前的行为*：

```py
In [9]: s[pd.Interval(2, 3)]
Out[9]:
(0, 4]    a
(1, 5]    b
dtype: object

In [10]: s.loc[pd.Interval(2, 3)]
Out[10]:
(0, 4]    a
(1, 5]    b
dtype: object 
```

*新行为*：

```py
In [6]: s[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right')

In [7]: s.loc[pd.Interval(2, 3)]
---------------------------------------------------------------------------
KeyError: Interval(2, 3, closed='right') 
```

`overlaps()`方法可用于创建一个布尔索引器，复制以前返回重叠匹配的行为。

*新行为*：

```py
In [44]: idxr = s.index.overlaps(pd.Interval(2, 3))

In [45]: idxr
Out[45]: array([ True,  True, False])

In [46]: s[idxr]
Out[46]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object

In [47]: s.loc[idxr]
Out[47]: 
(0, 4]    a
(1, 5]    b
Length: 2, dtype: object 
```

### Series 上的二进制 ufunc 现在对齐

应用二进制 ufunc，如`numpy.power()`，现在在两者都是`Series`时会对齐输入（[GH 23293](https://github.com/pandas-dev/pandas/issues/23293)）。

```py
In [48]: s1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s2 = pd.Series([3, 4, 5], index=['d', 'c', 'b'])

In [50]: s1
Out[50]: 
a    1
b    2
c    3
Length: 3, dtype: int64

In [51]: s2
Out[51]: 
d    3
c    4
b    5
Length: 3, dtype: int64 
```

*先前行为*

```py
In [5]: np.power(s1, s2)
Out[5]:
a      1
b     16
c    243
dtype: int64 
```

*新行为*

```py
In [52]: np.power(s1, s2)
Out[52]: 
a     1.0
b    32.0
c    81.0
d     NaN
Length: 4, dtype: float64 
```

这与 pandas 中的其他二进制操作的行为相匹配，如`Series.add()`。要保留先前的行为，在应用 ufunc 之前将另一个`Series`转换为数组。

```py
In [53]: np.power(s1, s2.array)
Out[53]: 
a      1
b     16
c    243
Length: 3, dtype: int64 
```

### Categorical.argsort 现在将缺失值放在末尾

`Categorical.argsort()`现在将缺失值放在数组末尾，使其与 NumPy 和 pandas 的其余部分一致（[GH 21801](https://github.com/pandas-dev/pandas/issues/21801)）。

```py
In [54]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True) 
```

*先前行为*

```py
In [2]: cat = pd.Categorical(['b', None, 'a'], categories=['a', 'b'], ordered=True)

In [3]: cat.argsort()
Out[3]: array([1, 2, 0])

In [4]: cat[cat.argsort()]
Out[4]:
[NaN, a, b]
categories (2, object): [a < b] 
```

*新行为*

```py
In [55]: cat.argsort()
Out[55]: array([2, 0, 1])

In [56]: cat[cat.argsort()]
Out[56]: 
['a', 'b', NaN]
Categories (2, object): ['a' < 'b'] 
```

### 传递字典列表到 DataFrame 时列顺序被保留

从 Python 3.7 开始，`dict`的键顺序是[有保证的](https://mail.python.org/pipermail/python-dev/2017-December/151283.html)。实际上，自 Python 3.6 以来一直如此。`DataFrame`构造函数现在以与`OrderedDict`相同的方式处理字典列表，即保留字典的顺序。此更改仅在 pandas 在 Python>=3.6 上运行时适用（[GH 27309](https://github.com/pandas-dev/pandas/issues/27309)）。

```py
In [57]: data = [
 ....:    {'name': 'Joe', 'state': 'NY', 'age': 18},
 ....:    {'name': 'Jane', 'state': 'KY', 'age': 19, 'hobby': 'Minecraft'},
 ....:    {'name': 'Jean', 'state': 'OK', 'age': 20, 'finances': 'good'}
 ....: ]
 ....: 
```

*先前行为*：

先前列是按字典顺序排序的，

```py
In [1]: pd.DataFrame(data)
Out[1]:
   age finances      hobby  name state
0   18      NaN        NaN   Joe    NY
1   19      NaN  Minecraft  Jane    KY
2   20     good        NaN  Jean    OK 
```

*新行为*：

现在列顺序与`dict`中键的插入顺序匹配，考虑从上到下的所有记录。因此，与先前的 pandas 版本相比，生成的 DataFrame 的列顺序已更改。

```py
In [58]: pd.DataFrame(data)
Out[58]: 
 name state  age      hobby finances
0   Joe    NY   18        NaN      NaN
1  Jane    KY   19  Minecraft      NaN
2  Jean    OK   20        NaN     good

[3 rows x 5 columns] 
```

### 增加了依赖项的最低版本

由于不再支持 Python 2.7，一些可选依赖项的最低版本已更新（[GH 25725](https://github.com/pandas-dev/pandas/issues/25725)，[GH 24942](https://github.com/pandas-dev/pandas/issues/24942)，[GH 25752](https://github.com/pandas-dev/pandas/issues/25752)）。此外，一些依赖项的最低支持版本已更新（[GH 23519](https://github.com/pandas-dev/pandas/issues/23519)，[GH 25554](https://github.com/pandas-dev/pandas/issues/25554)）。如果已安装，我们现在要求：

| 包 | 最低版本 | 必需 |
| --- | --- | --- |
| numpy | 1.13.3 | X |
| pytz | 2015.4 | X |
| python-dateutil | 2.6.1 | X |
| bottleneck | 1.2.1 |  |
| numexpr | 2.6.2 |  |
| pytest (dev) | 4.0.2 |  |

对于[可选库](https://pandas.pydata.org/docs/getting_started/install.html)，一般建议使用最新版本。以下表格列出了在 pandas 开发过程中当前正在测试的每个库的最低版本。低于最低测试版本的可选库可能仍然可用，但不被视为受支持。

| 包 | 最低版本 |
| --- | --- |
| beautifulsoup4 | 4.6.0 |
| fastparquet | 0.2.1 |
| gcsfs | 0.2.2 |
| lxml | 3.8.0 |
| matplotlib | 2.2.2 |
| openpyxl | 2.4.8 |
| pyarrow | 0.9.0 |
| pymysql | 0.7.1 |
| pytables | 3.4.2 |
| scipy | 0.19.0 |
| sqlalchemy | 1.1.4 |
| xarray | 0.8.2 |
| xlrd | 1.1.0 |
| xlsxwriter | 0.9.8 |
| xlwt | 1.2.0 |

查看依赖项和可选依赖项以获取更多信息。

### 其他 API 更改

+   `DatetimeTZDtype`现在将 pytz 时区标准化为一个公共时区实例。([GH 24713](https://github.com/pandas-dev/pandas/issues/24713))

+   `Timestamp`和`Timedelta`标量现在实现了`to_numpy()`方法，作为`Timestamp.to_datetime64()`和`Timedelta.to_timedelta64()`的别名。([GH 24653](https://github.com/pandas-dev/pandas/issues/24653))

+   `Timestamp.strptime()`现在会引发`NotImplementedError`([GH 25016](https://github.com/pandas-dev/pandas/issues/25016))

+   将`Timestamp`与不支持的对象进行比较现在会返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented "(在 Python v3.12 中)")，而不是引发`TypeError`。这意味着不支持的丰富比较被委托给其他对象，并且现在与 Python 3 中`datetime`对象的行为一致。([GH 24011](https://github.com/pandas-dev/pandas/issues/24011))

+   `DatetimeIndex.snap()`中的错误，未保留输入`Index`的`name`（[GH 25575](https://github.com/pandas-dev/pandas/issues/25575)）

+   在 `DataFrameGroupBy.agg()` 中的 `arg` 参数已更名为 `func` ([GH 26089](https://github.com/pandas-dev/pandas/issues/26089))

+   在 `Window.aggregate()` 中的 `arg` 参数已更名为 `func` ([GH 26372](https://github.com/pandas-dev/pandas/issues/26372))

+   大多数 pandas 类都有一个 `__bytes__` 方法，用于获取对象的 python2 风格的字节串表示。这个方法已被移除，作为放弃 Python2 的一部分 ([GH 26447](https://github.com/pandas-dev/pandas/issues/26447))

+   对于 1 级 `MultiIndex`，`.str` 访问器已被禁用，如果必要，使用 `MultiIndex.to_flat_index()` ([GH 23679](https://github.com/pandas-dev/pandas/issues/23679))

+   移除了对 gtk 包的剪贴板支持 ([GH 26563](https://github.com/pandas-dev/pandas/issues/26563))

+   使用不受支持的 Beautiful Soup 4 版本现在会引发 `ImportError` 而不是 `ValueError` ([GH 27063](https://github.com/pandas-dev/pandas/issues/27063))

+   `Series.to_excel()` 和 `DataFrame.to_excel()` 现在在保存时会引发 `ValueError`，当数据带有时区信息时。([GH 27008](https://github.com/pandas-dev/pandas/issues/27008), [GH 7056](https://github.com/pandas-dev/pandas/issues/7056))

+   `ExtensionArray.argsort()` 将 NA 值放在排序后的数组末尾。([GH 21801](https://github.com/pandas-dev/pandas/issues/21801))

+   `DataFrame.to_hdf()` 和 `Series.to_hdf()` 现在在保存带有扩展数据类型的 `fixed` 格式的 `MultiIndex` 时会引发 `NotImplementedError`。([GH 7775](https://github.com/pandas-dev/pandas/issues/7775))

+   在 `read_csv()` 中传递重复的 `names` 现在会引发 `ValueError` ([GH 17346](https://github.com/pandas-dev/pandas/issues/17346))

## 弃用

### 稀疏子类

`SparseSeries` 和 `SparseDataFrame` 子类已被弃用。它们的功能由带有稀疏值的 `Series` 或 `DataFrame` 更好地提供。

**之前的方式**

```py
df = pd.SparseDataFrame({"A": [0, 0, 1, 2]})
df.dtypes 
```

**新方式**

```py
In [59]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 0, 1, 2])})

In [60]: df.dtypes
Out[60]: 
A    Sparse[int64, 0]
Length: 1, dtype: object 
```

两种方���的内存使用量是相同的 ([GH 19239](https://github.com/pandas-dev/pandas/issues/19239)).

### msgpack 格式

自 0.25 版本开始，msgpack 格式已被弃用，并将在将来的版本中删除。建议使用 pyarrow 来传输 pandas 对象。 ([GH 27084](https://github.com/pandas-dev/pandas/issues/27084))

### 其他弃用内容

+   弃用的 `.ix[]` 索引器现在会引发更显眼的 `FutureWarning` 而不是 `DeprecationWarning`（[GH 26438](https://github.com/pandas-dev/pandas/issues/26438)）。

+   `pandas.to_timedelta()` 的 `units=M`（月）和 `units=Y`（年）参数已经被弃用，以及 `pandas.Timedelta()` 和 `pandas.TimedeltaIndex()` 的 `units` 参数（[GH 16344](https://github.com/pandas-dev/pandas/issues/16344)）。

+   `pandas.concat()` 已经弃用了 `join_axes` 关键字。请在结果或输入上使用 `DataFrame.reindex()` 或 `DataFrame.reindex_like()`（[GH 21951](https://github.com/pandas-dev/pandas/issues/21951)）。

+   `SparseArray.values` 属性已经被弃用。您可以使用 `np.asarray(...)` 或 `SparseArray.to_dense()` 方法代替（[GH 26421](https://github.com/pandas-dev/pandas/issues/26421)）。

+   `pandas.to_datetime()` 和 `pandas.to_timedelta()` 函数已经弃用 `box` 关键字。请使用 `to_numpy()` 或 `Timestamp.to_datetime64()` 或 `Timedelta.to_timedelta64()`（[GH 24416](https://github.com/pandas-dev/pandas/issues/24416)）。

+   `DataFrame.compound()` 和 `Series.compound()` 方法已经被弃用，并将在将来的版本中删除（[GH 26405](https://github.com/pandas-dev/pandas/issues/26405)）。

+   `RangeIndex`的内部属性`_start`、`_stop`和`_step`已被弃用。请使用公共属性`start`、`stop`和`step`代替([GH 26581](https://github.com/pandas-dev/pandas/issues/26581)).

+   `Series.ftype()`、`Series.ftypes()`和`DataFrame.ftypes()`方法已被弃用，并将在将来的版本中删除。相反，使用`Series.dtype()`和`DataFrame.dtypes()`（[GH 26705](https://github.com/pandas-dev/pandas/issues/26705)).

+   `Series.get_values()`、`DataFrame.get_values()`、`Index.get_values()`、`SparseArray.get_values()`和`Categorical.get_values()`方法已被弃用。可以使用`np.asarray(..)`或`to_numpy()`中的一个代替([GH 19617](https://github.com/pandas-dev/pandas/issues/19617)).

+   NumPy ufuncs 上的‘outer’方法，例如`np.subtract.outer`在`Series`对象上已被弃用。首先将输入转换为数组，然后使用`Series.array`（[GH 27186](https://github.com/pandas-dev/pandas/issues/27186))

+   `Timedelta.resolution()`已被弃用，并替换为`Timedelta.resolution_string()`。在未来的版本中，`Timedelta.resolution()`将被更改为像标准库中的[`datetime.timedelta.resolution`](https://docs.python.org/3/library/datetime.html#datetime.timedelta.resolution "(in Python v3.12)")一样的行为（[GH 21344](https://github.com/pandas-dev/pandas/issues/21344))

+   `read_table()`已被取消弃用。([GH 25220](https://github.com/pandas-dev/pandas/issues/25220))

+   `Index.dtype_str`已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Series.imag`和`Series.real`已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Series.put()`已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Index.item()` 和 `Series.item()` 已经被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `CategoricalDtype` 中默认值 `ordered=None` 已被弃用，推荐使用 `ordered=False`。在转换分类类型时，必须显式传递 `ordered=True` 以便保留。([GH 26336](https://github.com/pandas-dev/pandas/issues/26336))

+   `Index.contains()` 已弃用。使用 `key in index` (`__contains__`) 代替 ([GH 17753](https://github.com/pandas-dev/pandas/issues/17753)).

+   `DataFrame.get_dtype_counts()` 已弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Categorical.ravel()` 将返回一个 `Categorical` 而不是一个 `np.ndarray` ([GH 27199](https://github.com/pandas-dev/pandas/issues/27199))

### 稀疏子类

`SparseSeries` 和 `SparseDataFrame` 子类已被弃用。它们的功能由稀疏值的 `Series` 或 `DataFrame` 更好地提供。

**以前的方法**

```py
df = pd.SparseDataFrame({"A": [0, 0, 1, 2]})
df.dtypes 
```

**新的方法**

```py
In [59]: df = pd.DataFrame({"A": pd.arrays.SparseArray([0, 0, 1, 2])})

In [60]: df.dtypes
Out[60]: 
A    Sparse[int64, 0]
Length: 1, dtype: object 
```

这两种方法的内存使用情况相同 ([GH 19239](https://github.com/pandas-dev/pandas/issues/19239)).

### msgpack 格式

截至版本 0.25，msgpack 格式已被弃用，并将在未来版本中删除。建议使用 pyarrow 在 pandas 对象的传输中进行线上传输。([GH 27084](https://github.com/pandas-dev/pandas/issues/27084))

### 其他弃用

+   弃用的 `.ix[]` 索引器现在会引发更明显的 `FutureWarning` 而不是 `DeprecationWarning` ([GH 26438](https://github.com/pandas-dev/pandas/issues/26438)).

+   弃用了 `units=M`（月）和 `units=Y`（年）参数，用于 `pandas.to_timedelta()`, `pandas.Timedelta()` 和 `pandas.TimedeltaIndex()` 的 `units` ([GH 16344](https://github.com/pandas-dev/pandas/issues/16344))

+   `pandas.concat()` 已弃用 `join_axes` 关键字。建议在结果或输入上使用 `DataFrame.reindex()` 或 `DataFrame.reindex_like()` 代替 ([GH 21951](https://github.com/pandas-dev/pandas/issues/21951))

+   `SparseArray.values` 属性已弃用。您可以使用 `np.asarray(...)` 或 `SparseArray.to_dense()` 方法代替 ([GH 26421](https://github.com/pandas-dev/pandas/issues/26421)).

+   函数 `pandas.to_datetime()` 和 `pandas.to_timedelta()` 已弃用 `box` 关键字。请使用 `to_numpy()` 或 `Timestamp.to_datetime64()` 或 `Timedelta.to_timedelta64()`。（[GH 24416](https://github.com/pandas-dev/pandas/issues/24416)）。

+   `DataFrame.compound()` 和 `Series.compound()` 方法已被弃用，并将在将来的版本中移除（[GH 26405](https://github.com/pandas-dev/pandas/issues/26405)）。

+   `RangeIndex` 的内部属性 `_start`、`_stop` 和 `_step` 已被弃用。请使用公共属性 `start`、`stop` 和 `step`（[GH 26581](https://github.com/pandas-dev/pandas/issues/26581)）。

+   `Series.ftype()`、`Series.ftypes()` 和 `DataFrame.ftypes()` 方法已被弃用，并将在将来的版本中移除。请使用 `Series.dtype()` 和 `DataFrame.dtypes()` 代替（[GH 26705](https://github.com/pandas-dev/pandas/issues/26705)）。

+   `Series.get_values()`、`DataFrame.get_values()`、`Index.get_values()`、`SparseArray.get_values()` 和 `Categorical.get_values()` 方法已被弃用。可以使用 `np.asarray(..)` 或 `to_numpy()` 之一代替（[GH 19617](https://github.com/pandas-dev/pandas/issues/19617)）。

+   NumPy ufuncs 的 'outer' 方法，例如 `np.subtract.outer` 已在 `Series` 对象上被弃用。请先使用 `Series.array` 将输入转换为数组（[GH 27186](https://github.com/pandas-dev/pandas/issues/27186)）。

+   `Timedelta.resolution()` 已被弃用，并已被 `Timedelta.resolution_string()` 取代。在将来的版本中，`Timedelta.resolution()` 将被更改为与标准库 [`datetime.timedelta.resolution`](https://docs.python.org/3/library/datetime.html#datetime.timedelta.resolution "(in Python v3.12)") 的行为相同。([GH 21344](https://github.com/pandas-dev/pandas/issues/21344))

+   `read_table()` 已取消弃用。([GH 25220](https://github.com/pandas-dev/pandas/issues/25220))

+   `Index.dtype_str` 已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Series.imag` 和 `Series.real` 已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Series.put()` 已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Index.item()` 和 `Series.item()` 已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   在 `CategoricalDtype` 中，`ordered=None` 的默认值已被弃用，取而代之的是 `ordered=False`。在转换分类类型时，必须显式传递 `ordered=True` 以保留顺序。([GH 26336](https://github.com/pandas-dev/pandas/issues/26336))

+   `Index.contains()` 已被弃用。请使用 `key in index` (`__contains__`)。([GH 17753](https://github.com/pandas-dev/pandas/issues/17753))。

+   `DataFrame.get_dtype_counts()` 已被弃用。([GH 18262](https://github.com/pandas-dev/pandas/issues/18262))

+   `Categorical.ravel()` 将返回一个 `Categorical` 而不是一个 `np.ndarray`。([GH 27199](https://github.com/pandas-dev/pandas/issues/27199))

## 移除之前版本的弃用/更改

+   移除了 `Panel`。([GH 25047](https://github.com/pandas-dev/pandas/issues/25047), [GH 25191](https://github.com/pandas-dev/pandas/issues/25191), [GH 25231](https://github.com/pandas-dev/pandas/issues/25231))

+   在 `read_excel()` 中移除了先前弃用的 `sheetname` 关键字。([GH 16442](https://github.com/pandas-dev/pandas/issues/16442), [GH 20938](https://github.com/pandas-dev/pandas/issues/20938))

+   移除了先前弃用的 `TimeGrouper`。([GH 16942](https://github.com/pandas-dev/pandas/issues/16942))

+   在 `read_excel()` 中移除了先前弃用的 `parse_cols` 关键字。([GH 16488](https://github.com/pandas-dev/pandas/issues/16488))

+   移除了先前废弃的`pd.options.html.border`（[GH 16970](https://github.com/pandas-dev/pandas/issues/16970)）

+   移除了先前废弃的`convert_objects`（[GH 11221](https://github.com/pandas-dev/pandas/issues/11221)）

+   移除了`DataFrame`和`Series`的先前废弃的`select`方法（[GH 17633](https://github.com/pandas-dev/pandas/issues/17633)）

+   移除了`rename_categories()`中`Series`被视为类似列表的先前废弃行为（[GH 17982](https://github.com/pandas-dev/pandas/issues/17982)）

+   移除了先前废弃的`DataFrame.reindex_axis`和`Series.reindex_axis`（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   移除了用`Series.rename_axis()`或`DataFrame.rename_axis()`更改列或索引标签的先前废弃行为（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   移除了`read_html()`、`read_csv()`和`DataFrame.to_csv()`中先前废弃的`tupleize_cols`关键字参数（[GH 17877](https://github.com/pandas-dev/pandas/issues/17877)，[GH 17820](https://github.com/pandas-dev/pandas/issues/17820)）

+   移除了先前废弃的`DataFrame.from.csv`和`Series.from_csv`（[GH 17812](https://github.com/pandas-dev/pandas/issues/17812)）

+   移除了`DataFrame.where()`和`DataFrame.mask()`中先前废弃的`raise_on_error`关键字参数（[GH 17744](https://github.com/pandas-dev/pandas/issues/17744)）

+   移除了`astype`中先前废弃的`ordered`和`categories`关键字参数（[GH 17742](https://github.com/pandas-dev/pandas/issues/17742)）

+   移除了先前废弃的`cdate_range`（[GH 17691](https://github.com/pandas-dev/pandas/issues/17691)）

+   移除了`SeriesGroupBy.nth()`中先前废弃的`dropna`关键字参数的`True`选项（[GH 17493](https://github.com/pandas-dev/pandas/issues/17493)）

+   删除了先前在`Series.take()`和`DataFrame.take()`中弃用的`convert`关键字参数（[GH 17352](https://github.com/pandas-dev/pandas/issues/17352)）

+   删除了先前与`datetime.date`对象进行算术运算的行为（[GH 21152](https://github.com/pandas-dev/pandas/issues/21152)）

## 性能改进

+   `SparseArray`初始化的显着加速，使大多数操作受益，修复了 v0.20.0 中引入的性能回归（[GH 24985](https://github.com/pandas-dev/pandas/issues/24985)）

+   当输出带有任何字符串或非本机字节顺序列的数据时，`DataFrame.to_stata()`现在更快了（[GH 25045](https://github.com/pandas-dev/pandas/issues/25045)）

+   改进了`Series.searchsorted()`的性能。当 dtype 为 int8/int16/int32 且搜索键在 dtype 的整数边界内时，速度提升尤其大（[GH 22034](https://github.com/pandas-dev/pandas/issues/22034)）

+   改进了`GroupBy.quantile()`的性能（[GH 20405](https://github.com/pandas-dev/pandas/issues/20405)）

+   对`RangeIndex`的切片和其他选定操作的性能改进（[GH 26565](https://github.com/pandas-dev/pandas/issues/26565)，[GH 26617](https://github.com/pandas-dev/pandas/issues/26617)，[GH 26722](https://github.com/pandas-dev/pandas/issues/26722)）

+   现在，`RangeIndex`在不实例化实际哈希表的情况下执行标准查找，因此节省了内存（[GH 16685](https://github.com/pandas-dev/pandas/issues/16685)）

+   通过更快的标记化和更快的解析小浮点数，改进了`read_csv()`的性能（[GH 25784](https://github.com/pandas-dev/pandas/issues/25784)）

+   通过更快地解析 N/A 和布尔值，改进了`read_csv()`的性能（[GH 25804](https://github.com/pandas-dev/pandas/issues/25804)）

+   通过删除转换为`MultiIndex`来改进`IntervalIndex.is_monotonic`、`IntervalIndex.is_monotonic_increasing`和`IntervalIndex.is_monotonic_decreasing`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813)）

+   在写入日期时间数据类型时，改进了`DataFrame.to_csv()`的性能（[GH 25708](https://github.com/pandas-dev/pandas/issues/25708))

+   通过更快地解析`MM/YYYY`和`DD/MM/YYYY`日期时间格式，改进了`read_csv()`的性能（[GH 25922](https://github.com/pandas-dev/pandas/issues/25922))

+   对于无法存储 NaN 的数据类型，通过改进 nanops 的性能。特别是对于`Series.all()`和`Series.any()`，速度提升尤为显著（[GH 25070](https://github.com/pandas-dev/pandas/issues/25070))

+   通过将类别映射到类别而不是映射所有值，改进了在分类系列上的字典映射器的`Series.map()`的性能（[GH 23785](https://github.com/pandas-dev/pandas/issues/23785))

+   改进了`IntervalIndex.intersection()`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813))

+   通过更快地连接日期列而无需额外转换为整数/浮点零和浮点`NaN`的字符串，以及更快地检查字符串是否可能是日期，改进了`read_csv()`的性能（[GH 25754](https://github.com/pandas-dev/pandas/issues/25754))

+   通过删除转换为`MultiIndex`来改进`IntervalIndex.is_unique`的性能（[GH 24813](https://github.com/pandas-dev/pandas/issues/24813))

+   通过重新启用专门的代码路径，恢复了`DatetimeIndex.__iter__()`的性能（[GH 26702](https://github.com/pandas-dev/pandas/issues/26702))

+   当构建至少一个`CategoricalIndex`级别的`MultiIndex`时，通过消除垃圾回收来改进性能（[GH 22044](https://github.com/pandas-dev/pandas/issues/22044))

+   通过在检查`SettingWithCopyWarning`时消除垃圾回收的需要来改进性能（[GH 27031](https://github.com/pandas-dev/pandas/issues/27031))

+   对于`to_datetime()`，将 cache 参数的默认值更改为`True`（[GH 26043](https://github.com/pandas-dev/pandas/issues/26043))

+   在给定非唯一、单调数据的情况下，通过改进`DatetimeIndex`和`PeriodIndex`的切片性能（[GH 27136](https://github.com/pandas-dev/pandas/issues/27136))

+   改进了针对面向索引的数据的`pd.read_json()`的性能。 ([GH 26773](https://github.com/pandas-dev/pandas/issues/26773))

+   改进了`MultiIndex.shape()`的性能 ([GH 27384](https://github.com/pandas-dev/pandas/issues/27384))

## 问题修复

### 类别

+   修复了`DataFrame.at()`和`Series.at()`中的错误，如果索引是一个`CategoricalIndex`会引发异常（[GH 20629](https://github.com/pandas-dev/pandas/issues/20629)）

+   修复了包含缺失值的有序`Categorical`与标量进行比较时的错误，有时会错误地结果为`True`（[GH 26504](https://github.com/pandas-dev/pandas/issues/26504)）

+   修复了当`DataFrame`具有包含`Interval`对象的`CategoricalIndex`时，`DataFrame.dropna()`中的错误，错误地引发了`TypeError`（[GH 25087](https://github.com/pandas-dev/pandas/issues/25087)）

### 日期时间类

+   修复了`to_datetime()`中的错误，当使用`format`参数指定一个远期日期时，会引发（不正确的）`ValueError`而不是引发`OutOfBoundsDatetime`（[GH 23830](https://github.com/pandas-dev/pandas/issues/23830)）

+   修复了`to_datetime()`中的错误，在使用`cache=True`调用时会引发`InvalidIndexError: Reindexing only valid with uniquely valued Index objects`，`arg`至少包含来自集合`{None, numpy.nan, pandas.NaT}`中的两个不同元素时会出现此错误（[GH 22305](https://github.com/pandas-dev/pandas/issues/22305)）

+   修复了当时区感知数据具有`dtype='datetime64[ns]`时，`DataFrame`和`Series`中的错误，未转换为朴素的问题（[GH 25843](https://github.com/pandas-dev/pandas/issues/25843)）

+   在各种日期时间函数中改进了对`Timestamp`类型的检查，以防止在使用子类化的`datetime`时引发异常（[GH 25851](https://github.com/pandas-dev/pandas/issues/25851)）

+   在 `Series` 和 `DataFrame` 的 repr 中，`np.datetime64('NaT')` 和 `np.timedelta64('NaT')` 以 `dtype=object` 表示为 `NaN`。([GH 25445](https://github.com/pandas-dev/pandas/issues/25445))

+   `to_datetime()` 中的错误，当错误设置为 coerce 时，无法用 `NaT` 替换无效参数。([GH 26122](https://github.com/pandas-dev/pandas/issues/26122))

+   向 `DatetimeIndex` 添加非零月份的 `DateOffset` 会引发 `ValueError`。([GH 26258](https://github.com/pandas-dev/pandas/issues/26258))

+   在使用混合无效日期和 `NaN` 值以及 `format='%Y%m%d'` 和 `error='coerce'` 时，调用 `to_datetime()` 会引发未处理的 `OverflowError`。([GH 25512](https://github.com/pandas-dev/pandas/issues/25512))

+   `isin()` 在日期时间索引中的错误；`DatetimeIndex`、`TimedeltaIndex` 和 `PeriodIndex` 中 `levels` 参数被忽略。([GH 26675](https://github.com/pandas-dev/pandas/issues/26675))

+   在使用 `format='%Y%m%d'` 时，对长度大于等于 6 位的无效整数日期调用 `to_datetime()` 会引发 `TypeError`，并且 `errors='ignore'` 时不会处理。

+   比较 `PeriodIndex` 和零维 numpy 数组时出现错误。([GH 26689](https://github.com/pandas-dev/pandas/issues/26689))

+   从 numpy `datetime64` 数组构建 `Series` 或 `DataFrame` 时，如果时间单位不是纳秒且时间戳超出范围，则会生成垃圾数据，现在将正确引发 `OutOfBoundsDatetime` 错误。([GH 26206](https://github.com/pandas-dev/pandas/issues/26206))

+   在 `date_range()` 中，对非常大或非常小的日期引发不必要的 `OverflowError`。([GH 26651](https://github.com/pandas-dev/pandas/issues/26651))

+   将 `Timestamp` 添加到 `np.timedelta64` 对象中会引发错误，而不是返回 `Timestamp`。([GH 24775](https://github.com/pandas-dev/pandas/issues/24775))

+   当将包含`np.datetime64`对象的零维 numpy 数组与`Timestamp`进行比较时出现错误，将不正确引发`TypeError`（[GH 26916](https://github.com/pandas-dev/pandas/issues/26916)）

+   在`to_datetime()`中存在错误，当调用时使用`cache=True`，`arg`包含具有不同偏移量的日期时间字符串时，会引发`ValueError: Tz-aware datetime.datetime cannot be converted to datetime64 unless utc=True`（[GH 26097](https://github.com/pandas-dev/pandas/issues/26097)）

### 时间差

+   `TimedeltaIndex.intersection()`中的错误，在某些情况下，非单调索引返回空`Index`，而实际上存在交集（[GH 25913](https://github.com/pandas-dev/pandas/issues/25913)）

+   在`Timedelta`与`NaT`之间进行比较时出现错误，引发`TypeError`（[GH 26039](https://github.com/pandas-dev/pandas/issues/26039)）

+   在将`BusinessHour`添加或减去到`Timestamp`时出现错误，导致结果时间分别落在后续或前一天（[GH 26381](https://github.com/pandas-dev/pandas/issues/26381)）

+   在将`TimedeltaIndex`与零维 numpy 数组进行比较时出现错误（[GH 26689](https://github.com/pandas-dev/pandas/issues/26689)）

### 时区

+   在`DatetimeIndex.to_frame()`中存在错误，其中时区感知数据将转换为时区无关数据（[GH 25809](https://github.com/pandas-dev/pandas/issues/25809)）

+   在`to_datetime()`中存在错误，当`utc=True`和日期时间字符串一起使用时，会将先前解析的 UTC 偏移应用于后续参数（[GH 24992](https://github.com/pandas-dev/pandas/issues/24992)）

+   `Timestamp.tz_localize()`和`Timestamp.tz_convert()`中存在错误，不会传播`freq`（[GH 25241](https://github.com/pandas-dev/pandas/issues/25241)）

+   在`Series.at()`中存在错误，设置带有时区的`Timestamp`会引发`TypeError`（[GH 25506](https://github.com/pandas-dev/pandas/issues/25506)）

+   在使用时区感知数据更新 `DataFrame.update()` 时会返回时区无关的数据的错误（[GH 25807](https://github.com/pandas-dev/pandas/issues/25807)）

+   在 `to_datetime()` 中的错误，在其中传递了混合 UTC 偏移的日期时间字符串时会引发无信息的 `RuntimeError`（[GH 25978](https://github.com/pandas-dev/pandas/issues/25978)）

+   在 `unit='ns'` 时会从解析参数中删除时区信息的 `to_datetime()` 中的错误（[GH 26168](https://github.com/pandas-dev/pandas/issues/26168)）

+   在将时区感知索引与时区感知列连接时，`DataFrame.join()` 会导致 NaN 列的错误（[GH 26335](https://github.com/pandas-dev/pandas/issues/26335)）

+   在 `date_range()` 中没有处理模糊或不存在的起始或结束时间的错误，分别由 `ambiguous` 或 `nonexistent` 关键字引起（[GH 27088](https://github.com/pandas-dev/pandas/issues/27088)）

+   在组合时区感知和时区无关的 `DatetimeIndex` 时的 `DatetimeIndex.union()` 中出现的错误（[GH 21671](https://github.com/pandas-dev/pandas/issues/21671)）

+   应用 numpy 缩减函数（例如 `numpy.minimum()`）到时区感知的 `Series` 时出现的错误（[GH 15552](https://github.com/pandas-dev/pandas/issues/15552)）

### 数值

+   在 `to_numeric()` 中的错误，在其中大负数被不正确处理（[GH 24910](https://github.com/pandas-dev/pandas/issues/24910)）

+   在 `to_numeric()` 中的错误，在其中数字被强制转换为浮点数，即使 `errors` 不是 `coerce`（[GH 24910](https://github.com/pandas-dev/pandas/issues/24910)）

+   在 `to_numeric()` 中的错误，允许了 `errors` 的无效值（[GH 26466](https://github.com/pandas-dev/pandas/issues/26466)）

+   在格式化中的错误，在其中浮点复数数字没有被格式化为正确的显示精度和修剪（[GH 25514](https://github.com/pandas-dev/pandas/issues/25514)）

+   在`DataFrame.corr()` 和 `Series.corr()` 中的错误消息中存在 Bug。增加了使用可调用对象的可能性。([GH 25729](https://github.com/pandas-dev/pandas/issues/25729))

+   `Series.divmod()` 和 `Series.rdivmod()` 中的 Bug 会引发（错误的）`ValueError`，而不是返回一对`Series`对象作为结果（[GH 25557](https://github.com/pandas-dev/pandas/issues/25557)）

+   当非数值索引被发送到需要数值索引的 `interpolate()` 方法时，会引发一个有用的异常。([GH 21662](https://github.com/pandas-dev/pandas/issues/21662))

+   在使用浮点数标量运算符比较浮点数时，`eval()` 中的 Bug，例如：`x < -0.1`（[GH 25928](https://github.com/pandas-dev/pandas/issues/25928)）

+   修复了将全布尔数组转换为整数扩展数组失败的 Bug（[GH 25211](https://github.com/pandas-dev/pandas/issues/25211)）

+   `divmod` 中的 Bug，包含零的 `Series` 对象错误地引发 `AttributeError`（[GH 26987](https://github.com/pandas-dev/pandas/issues/26987)）

+   `Series` floor-division (//) 和 `divmod` 填充正数//零为 `NaN` 而不是 `Inf` 的不一致性（[GH 27321](https://github.com/pandas-dev/pandas/issues/27321)）

### Conversion

+   在传递列和类型字典时，`DataFrame.astype()` 中的 Bug，`errors` 参数被忽略。([GH 25905](https://github.com/pandas-dev/pandas/issues/25905))

### 字符串

+   `Series.str` 的几种方法的 `__name__` 属性中的 Bug，设置不正确（[GH 23551](https://github.com/pandas-dev/pandas/issues/23551)）

+   当将错误类型的`Series`传递给 `Series.str.cat()` 时，改进了错误消息。([GH 22722](https://github.com/pandas-dev/pandas/issues/22722))

### Interval

+   构造`Interval` 仅限于数值、`Timestamp` 和 `Timedelta` 端点（[GH 23013](https://github.com/pandas-dev/pandas/issues/23013)）

+   修复了在具有缺失值的 `IntervalIndex` 中 `Series`/`DataFrame` 中不显示 `NaN` 的 Bug（[GH 25984](https://github.com/pandas-dev/pandas/issues/25984)）。

+   Bug：`IntervalIndex.get_loc()` 中的 Bug，对于递减的 `IntervalIndex` 会错误地引发 `KeyError`（[GH 25860](https://github.com/pandas-dev/pandas/issues/25860)）。

+   `Index` 构造函数中的 Bug，传递混合的闭合 `Interval` 对象会导致 `ValueError` 而不是 `object` dtype `Index`（[GH 27172](https://github.com/pandas-dev/pandas/issues/27172））。

### 索引

+   在使用非数字对象列表调用 `DataFrame.iloc()` 时改进了异常消息（[GH 25753](https://github.com/pandas-dev/pandas/issues/25753)）。

+   在使用不同长度的布尔索引器调用 `.iloc` 或 `.loc` 时改进了异常消息（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   Bug：在索引 `MultiIndex` 时的 `KeyError` 异常消息中，当使用不存在的键时不显示原始键（[GH 27250](https://github.com/pandas-dev/pandas/issues/27250)）。

+   Bug：在使用布尔索引器调用 `.iloc` 和 `.loc` 时，当传递的项目太少时不会引发 `IndexError`（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   `DataFrame.loc()` 和 `Series.loc()` 中的 Bug，当键小于或等于 `MultiIndex` 中的级数时，不会为 `MultiIndex` 抛出 `KeyError`（[GH 14885](https://github.com/pandas-dev/pandas/issues/14885)）。

+   Bug：`DataFrame.append()` 产生错误警告，指示将来在要附加的数据中包含新列时会抛出 `KeyError`（[GH 22252](https://github.com/pandas-dev/pandas/issues/22252)）。

+   在重新索引的数据帧上使用`DataFrame.to_csv()`时导致段错误的错误，当索引是单级`MultiIndex`时（[GH 26303](https://github.com/pandas-dev/pandas/issues/26303))

+   将`arrays.PandasArray`分配给`DataFrame`时引发错误的错误已修复（[GH 26390](https://github.com/pandas-dev/pandas/issues/26390))

+   允许在`DataFrame.query()`字符串中使用可调用本地引用的关键字参数（[GH 26426](https://github.com/pandas-dev/pandas/issues/26426))

+   当使用包含确切一个缺失标签的列表索引`MultiIndex`级别时，修复了`KeyError`（[GH 27148](https://github.com/pandas-dev/pandas/issues/27148))

+   在`MultiIndex`中部分匹配`Timestamp`时产生`AttributeError`的错误（[GH 26944](https://github.com/pandas-dev/pandas/issues/26944))

+   当使用`Interval`中不可比较的对象使用`in`运算符（`__contains__`）时，`Categorical`和`CategoricalIndex`中的`Interval`值中的错误（[GH 23705](https://github.com/pandas-dev/pandas/issues/23705))

+   在带有单个时区感知的 datetime64[ns]列的`DataFrame.loc()`和`DataFrame.iloc()`中的错误，错误地返回标量而不是`Series`（[GH 27110](https://github.com/pandas-dev/pandas/issues/27110))

+   在使用`in`运算符（`__contains__`）传递列表时，`CategoricalIndex`和`Categorical`错误地引发`ValueError`而不是`TypeError`的错误（[GH 21729](https://github.com/pandas-dev/pandas/issues/21729))

+   在使用`Timedelta`对象设��`Series`中的新值时，不正确地将值转换为整数的错误已被修复（[GH 22717](https://github.com/pandas-dev/pandas/issues/22717))

+   在使用带有时区信息的日期时间设置新键(`__setitem__`)时，`Series`存在错误，会不正确地引发`ValueError`（[GH 12862](https://github.com/pandas-dev/pandas/issues/12862)）

+   在使用只读索引器进行索引时，`DataFrame.iloc()`存在错误，会引发`ValueError`（[GH 17192](https://github.com/pandas-dev/pandas/issues/17192)）

+   在使用带有时区信息的日期时间值设置现有元组键(`__setitem__`)时，`Series`存在错误，会不正确地引发`TypeError`（[GH 20441](https://github.com/pandas-dev/pandas/issues/20441)）

### 缺失

+   如果需要参数`order`但未提供时，在`Series.interpolate()`中的误导性异常消息已被修复（[GH 10633](https://github.com/pandas-dev/pandas/issues/10633)，[GH 24014](https://github.com/pandas-dev/pandas/issues/24014)）

+   如果传递了无效的`axis`参数，`DataFrame.dropna()`中的异常消息中显示的类类型已被修复（[GH 25555](https://github.com/pandas-dev/pandas/issues/25555)）

+   当`limit`不是正整数时，`DataFrame.fillna()`现在会引发`ValueError`（[GH 27042](https://github.com/pandas-dev/pandas/issues/27042)）

### 多重索引

+   在测试`MultiIndex`的成员资格时，`Timedelta`引发不正确异常的错误已被修复（[GH 24570](https://github.com/pandas-dev/pandas/issues/24570)）

### 输入/输出

+   在使用显示选项截断值而不是输出完整内容时，`DataFrame.to_html()`存在错误已被修复（[GH 17004](https://github.com/pandas-dev/pandas/issues/17004)）

+   在 Python 3 的 Windows 上，如果复制 utf-16 字符时，使用`to_clipboard()`会导致缺少文本的错误已被修复（[GH 25040](https://github.com/pandas-dev/pandas/issues/25040)）

+   在`read_json()`中存在的错误，对于`orient='table'`，当尝试默认推断 dtype 时，这是不适用的，因为 dtype 已在 JSON 模式中定义（[GH 21345](https://github.com/pandas-dev/pandas/issues/21345))

+   在`read_json()`中存在的错误，对于`orient='table'`和浮点索引，因为默认推断索引 dtype，这是不适用的，因为索引 dtype 已在 JSON 模式中定义（[GH 25433](https://github.com/pandas-dev/pandas/issues/25433))

+   在`read_json()`中存在的错误，对于`orient='table'`和浮点数列名字符串，它会将列名类型转换为`Timestamp`，这是不适用的，因为列名已在 JSON 模式中定义（[GH 25435](https://github.com/pandas-dev/pandas/issues/25435))

+   在`json_normalize()`中存在的错误，对于`errors='ignore'`，输入数据中缺少的值会在结果`DataFrame`中填充字符串`"nan"`而不是`numpy.nan`（[GH 25468](https://github.com/pandas-dev/pandas/issues/25468))

+   `DataFrame.to_html()`现在在使用无效类型的`classes`参数时会引发`TypeError`，而不是`AssertionError`（[GH 25608](https://github.com/pandas-dev/pandas/issues/25608))

+   在`DataFrame.to_string()`和`DataFrame.to_latex()`中存在的错误，当使用`header`关键字时会导致输出不正确（[GH 16718](https://github.com/pandas-dev/pandas/issues/16718))

+   在`read_csv()`中存在的错误，未能正确解释 UTF8 编码的文件名在 Windows 上的 Python 3.6+中的情况（[GH 15086](https://github.com/pandas-dev/pandas/issues/15086))

+   在转换具有缺失值的列时，在`pandas.read_stata()`和`pandas.io.stata.StataReader`中的性能得到了改进（[GH 25772](https://github.com/pandas-dev/pandas/issues/25772))

+   在`DataFrame.to_html()`中存在的错误，当四舍五入时，头部数字会忽略显示选项（[GH 17280](https://github.com/pandas-dev/pandas/issues/17280))

+   `read_hdf()` 中的 bug，直接使用 PyTables 写入的 HDF5 文件读取表时，通过 `start` 或 `stop` 参数进行子选择会导致 `ValueError` 错误 ([GH 11188](https://github.com/pandas-dev/pandas/issues/11188))

+   `read_hdf()` 中的 bug，在引发 `KeyError` 后未正确关闭存储 ([GH 25766](https://github.com/pandas-dev/pandas/issues/25766))

+   改进了在 Stata dta 文件中数值标签重复时的失败解释，并建议解决方法 ([GH 25772](https://github.com/pandas-dev/pandas/issues/25772))

+   改进了 `pandas.read_stata()` 和 `pandas.io.stata.StataReader`，以读取 Stata 保存的格式不正确的 118 格式文件 ([GH 25960](https://github.com/pandas-dev/pandas/issues/25960))

+   改进了 `DataFrame.to_html()` 中的 `col_space` 参数，接受字符串以便正确设置 CSS 长度值 ([GH 25941](https://github.com/pandas-dev/pandas/issues/25941))

+   修复了从 S3 加载包含 URL 中 `#` 字符的对象时的 bug ([GH 25945](https://github.com/pandas-dev/pandas/issues/25945))

+   在 `read_gbq()` 中添加了 `use_bqstorage_api` 参数，以加快大型数据帧的下载速度。此功能需要 `pandas-gbq` 库的 0.10.0 版本以及 `google-cloud-bigquery-storage` 和 `fastavro` 库。 ([GH 26104](https://github.com/pandas-dev/pandas/issues/26104))

+   修复了在处理数值数据时 `DataFrame.to_json()` 中的内存泄漏 ([GH 24889](https://github.com/pandas-dev/pandas/issues/24889))

+   `read_json()` 中的 bug，日期字符串中带有 `Z` 的未转换为 UTC 时区 ([GH 26168](https://github.com/pandas-dev/pandas/issues/26168))

+   在 `read_csv()` 中添加了 `cache_dates=True` 参数，允许在解析日期时缓存唯一日期 ([GH 25990](https://github.com/pandas-dev/pandas/issues/25990))

+   `DataFrame.to_excel()` 现在在调用者的维度超出 Excel 限制时会引发 `ValueError` ([GH 26051](https://github.com/pandas-dev/pandas/issues/26051))

+   修复了 `pandas.read_csv()` 中的 bug，其中 BOM 会导致使用 engine=’python’ 时解析错误 ([GH 26545](https://github.com/pandas-dev/pandas/issues/26545))

+   当输入为类型为 `pandas.io.excel.ExcelFile` 且传递了 `engine` 参数时，`read_excel()` 现在会引发 `ValueError`，因为 `pandas.io.excel.ExcelFile` 已定义了一个引擎 ([GH 26566](https://github.com/pandas-dev/pandas/issues/26566))

+   选择`HDFStore`时出现 bug，指定了`where=''` ([GH 26610](https://github.com/pandas-dev/pandas/issues/26610)).

+   修复了 `DataFrame.to_excel()` 中的 bug，即合并单元格中的自定义对象（即 `PeriodIndex`）未被转换为 Excel 写入器安全类型 ([GH 27006](https://github.com/pandas-dev/pandas/issues/27006))

+   在 `read_hdf()` 中的 bug，在读取时区感知的 `DatetimeIndex` 时会引发 `TypeError` ([GH 11926](https://github.com/pandas-dev/pandas/issues/11926))

+   在 `to_msgpack()` 和 `read_msgpack()` 中的 bug，会引发 `ValueError` 而不是无效路径的 `FileNotFoundError` ([GH 27160](https://github.com/pandas-dev/pandas/issues/27160))

+   修复了 `DataFrame.to_parquet()` 中的 bug，在 dataframe 没有列时会引发 `ValueError` ([GH 27339](https://github.com/pandas-dev/pandas/issues/27339))

+   在使用 `read_csv()` 时，允许解析 `PeriodDtype` 列 ([GH 26934](https://github.com/pandas-dev/pandas/issues/26934))

### 绘图

+   修复了`api.extensions.ExtensionArray`在 matplotlib 绘图中无法使用的 bug ([GH 25587](https://github.com/pandas-dev/pandas/issues/25587))

+   在 `DataFrame.plot()` 中的错误消息中存在 bug。如果向 `DataFrame.plot()` 传递了非数字，则改进了错误消息 ([GH 25481](https://github.com/pandas-dev/pandas/issues/25481))

+   在绘制非数值/非日期时间索引时，ticklabel 位置不正确的错误（[GH 7612](https://github.com/pandas-dev/pandas/issues/7612), [GH 15912](https://github.com/pandas-dev/pandas/issues/15912), [GH 22334](https://github.com/pandas-dev/pandas/issues/22334))

+   修复了`PeriodIndex`时间序列绘图的错误，如果频率是频率规则代码的倍数，则会失败（[GH 14763](https://github.com/pandas-dev/pandas/issues/14763))

+   修复了使用`datetime.timezone.utc`时区绘制`DatetimeIndex`时的错误（[GH 17173](https://github.com/pandas-dev/pandas/issues/17173))

### GroupBy/resample/rolling

+   在具有时区感知索引的`Resampler.agg()`中存在的错误，当传递函数列表时会引发`OverflowError`（[GH 22660](https://github.com/pandas-dev/pandas/issues/22660))

+   在`DataFrameGroupBy.nunique()`中存在的错误，其中列级别的名称丢失了（[GH 23222](https://github.com/pandas-dev/pandas/issues/23222))

+   在将聚合函数应用于时区感知数据时，`GroupBy.agg()`中存在的错误（[GH 23683](https://github.com/pandas-dev/pandas/issues/23683))

+   在`GroupBy.first()`和`GroupBy.last()`中存在的错误，其中时区信息将被丢弃（[GH 21603](https://github.com/pandas-dev/pandas/issues/21603))

+   在仅对 NA 值进行分组时，`GroupBy.size()`中存在的错误（[GH 23050](https://github.com/pandas-dev/pandas/issues/23050))

+   在`Series.groupby()`中存在的错误，先前忽略了`observed` kwarg（[GH 24880](https://github.com/pandas-dev/pandas/issues/24880))

+   在使用具有与系列长度相等的标签列表的`MultiIndex`系列进行错误分组的`Series.groupby()`中存在的错误（[GH 25704](https://github.com/pandas-dev/pandas/issues/25704))

+   确保在所有 Python 版本中，`groupby`聚合函数的输出顺序是一致的（[GH 25692](https://github.com/pandas-dev/pandas/issues/25692))

+   确保在对有序`Categorical`进行分组并指定`observed=True`时，结果组顺序是正确的（[GH 25871](https://github.com/pandas-dev/pandas/issues/25871), [GH 25167](https://github.com/pandas-dev/pandas/issues/25167))

+   在 `Rolling.min()` 和 `Rolling.max()` 函数中存在的 Bug 导致内存泄漏 ([GH 25893](https://github.com/pandas-dev/pandas/issues/25893))

+   在使用 `Rolling.count()` 和 `.Expanding.count` 函数时，之前会忽略 `axis` 关键字参数 ([GH 13503](https://github.com/pandas-dev/pandas/issues/13503))

+   在使用 `GroupBy.idxmax()` 和 `GroupBy.idxmin()` 函数时，如果使用 datetime 列，可能会返回不正确的数据类型 ([GH 25444](https://github.com/pandas-dev/pandas/issues/25444), [GH 15306](https://github.com/pandas-dev/pandas/issues/15306))

+   在分类列中使用 `GroupBy.cumsum()`、`GroupBy.cumprod()`、`GroupBy.cummin()` 和 `GroupBy.cummax()` 函数时出现的 Bug，如果分类列中存在缺失的类别，可能会返回不正确的结果或导致段错误 ([GH 16771](https://github.com/pandas-dev/pandas/issues/16771))

+   在使用 `GroupBy.nth()` 函数时，如果分组中存在 NA 值，可能会返回不正确的结果 ([GH 26011](https://github.com/pandas-dev/pandas/issues/26011))

+   在使用 `SeriesGroupBy.transform()` 函数时，如果对一个空组进行转换，则会引发 `ValueError` ([GH 26208](https://github.com/pandas-dev/pandas/issues/26208))

+   在使用 `DataFrame.groupby()` 函数时，如果传递一个 `Grouper` 对象，则在使用 `.groups` 属性访问器时可能会返回不正确的分组 ([GH 26326](https://github.com/pandas-dev/pandas/issues/26326))

+   在使用 `GroupBy.agg()` 函数时，对于 uint64 类型的列可能会返回不正确的结果。([GH 26310](https://github.com/pandas-dev/pandas/issues/26310))

+   Bug in `Rolling.median()` 和 `Rolling.quantile()` 函数中出现内存错误，当窗口为空时会抛出 MemoryError 异常 ([GH 26005](https://github.com/pandas-dev/pandas/issues/26005))

+   在`Rolling.median()`和`Rolling.quantile()`中存在 bug，当`closed='left'`和`closed='neither'`时返回不正确的结果（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   改进了`Rolling`、`Window`和`ExponentialMovingWindow`函数，以排除结果中的无关列，而不是引发错误，并仅在所有列都是无关列时引发`DataError`（[GH 12537](https://github.com/pandas-dev/pandas/issues/12537)）

+   在`Rolling.max()`和`Rolling.min()`中存在 bug，当变量窗口为空时返回不正确的结果（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   当使用不支持的加权窗口函数作为`Window.aggregate()`的参数时，引发一个有用的异常（[GH 26597](https://github.com/pandas-dev/pandas/issues/26597)）

### 重新塑造

+   在`pandas.merge()`中存在 bug，在后缀中赋值为`None`时添加一个`None`字符串，而不是保留列名不变（[GH 24782](https://github.com/pandas-dev/pandas/issues/24782)）

+   在按索引名称合并时存在 bug，有时会导致索引编号不正确（缺少索引值现在被分配为 NA）（[GH 24212](https://github.com/pandas-dev/pandas/issues/24212)，[GH 25009](https://github.com/pandas-dev/pandas/issues/25009)）

+   `to_records()`现在接受其`column_dtypes`参数的数据类型（[GH 24895](https://github.com/pandas-dev/pandas/issues/24895)）

+   在`concat()`中存在 bug，当作为`objs`参数传递时，不尊重`OrderedDict`（以及 Python 3.6+中的`dict`）的顺序（[GH 21510](https://github.com/pandas-dev/pandas/issues/21510)）

+   在`pivot_table()`中存在 bug，即使`dropna`参数为`False`，当`aggfunc`参数包含一个`list`时，也会删除具有`NaN`值的列（[GH 22159](https://github.com/pandas-dev/pandas/issues/22159)）

+   在两个具有相同`freq`的`DatetimeIndex`的连接结果中，`concat()` 中的 Bug 会丢弃`freq`（[GH 3232](https://github.com/pandas-dev/pandas/issues/3232))。

+   `merge()` 中的 Bug，在与等价的 Categorical 类型合并时会引发错误（[GH 22501](https://github.com/pandas-dev/pandas/issues/22501))。

+   在使用迭代器或生成器的字典（例如`pd.DataFrame({'A': reversed(range(3))})`）实例化`DataFrame` 时会引发错误（[GH 26349](https://github.com/pandas-dev/pandas/issues/26349))。

+   使用`range`（例如`pd.DataFrame(range(3))`）实例化`DataFrame` 时会引发错误（[GH 26342](https://github.com/pandas-dev/pandas/issues/26342))。

+   在传递非空元组时，`DataFrame` 构造函数会导致分段错误（[GH 25691](https://github.com/pandas-dev/pandas/issues/25691))。

+   当系列是时区感知的`DatetimeIndex`时，`Series.apply()` 中的 Bug 会失败（[GH 25959](https://github.com/pandas-dev/pandas/issues/25959))。

+   在`pandas.cut()` 中，大型 bin 由于整数溢出而错误地引发错误（[GH 26045](https://github.com/pandas-dev/pandas/issues/26045))。

+   `DataFrame.sort_index()` 中的 Bug，在多级索引的`DataFrame`上对所有级别进行排序时，初始级别的排序在最后时会引发错误（[GH 26053](https://github.com/pandas-dev/pandas/issues/26053))。

+   `Series.nlargest()` 中的 Bug 将`True`视为小于`False`（[GH 26154](https://github.com/pandas-dev/pandas/issues/26154))。

+   在使用 `IntervalIndex` 作为透视索引时，`DataFrame.pivot_table()` 中的 Bug 会引发`TypeError`（[GH 25814](https://github.com/pandas-dev/pandas/issues/25814))。

+   当 `orient='index'` 时 `DataFrame.from_dict()` 忽略了 `OrderedDict` 的顺序的错误 ([GH 8425](https://github.com/pandas-dev/pandas/issues/8425)).

+   在 `DataFrame.transpose()` 中的错误，在转置具有时区感知的日期时间列的 DataFrame 时，会错误地引发 `ValueError` ([GH 26825](https://github.com/pandas-dev/pandas/issues/26825))

+   在 `pivot_table()` 中的错误，在将时区感知列作为 `values` 枢轴时，会删除时区信息 ([GH 14948](https://github.com/pandas-dev/pandas/issues/14948))

+   在指定多个 `by` 列且其中一个是 `datetime64[ns, tz]` dtype 时的 `merge_asof()` 中的错误 ([GH 26649](https://github.com/pandas-dev/pandas/issues/26649))

### Sparse

+   在 `SparseArray` 初始化中的显着加速，使大多数操作受益，修复了 v0.20.0 中引入的性能回归 ([GH 24985](https://github.com/pandas-dev/pandas/issues/24985))

+   在 `SparseFrame` 构造函数中的错误，在将 `None` 作为数据传递时，会导致 `default_fill_value` 被忽略 ([GH 16807](https://github.com/pandas-dev/pandas/issues/16807))

+   在添加列时的 `SparseDataFrame` 中的错误，其中值的长度与索引的长度不匹配时，会引发 `AssertionError` 而不是引发 `ValueError` ([GH 25484](https://github.com/pandas-dev/pandas/issues/25484))

+   在 `Series.sparse.from_coo()` 中引入更好的错误消息，以便对于不是 coo 矩阵的输入返回 `TypeError` ([GH 26554](https://github.com/pandas-dev/pandas/issues/26554))

+   在 `SparseArray` 上的 `numpy.modf()` 中的错误。现在返回一个 `SparseArray` 的元组 ([GH 26946](https://github.com/pandas-dev/pandas/issues/26946)).

### 构建更改

+   修复了在 macOS 上使用 PyPy 安装时的错误 ([GH 26536](https://github.com/pandas-dev/pandas/issues/26536))

### ExtensionArray

+   在传递具有自定义 `na_sentinel` 的 `ExtensionArray` 时 `factorize()` 中的错误 ([GH 25696](https://github.com/pandas-dev/pandas/issues/25696)).

+   在 ExtensionArrays 中的 `Series.count()` 中错误地计算 NA 值 ([GH 26835](https://github.com/pandas-dev/pandas/issues/26835))

+   添加了 `Series.__array_ufunc__` 来更好地处理应用于由扩展数组支持的 Series 的 NumPy ufuncs ([GH 23293](https://github.com/pandas-dev/pandas/issues/23293)).

+   关键字参数`deep`已从`ExtensionArray.copy()`中删除（[GH 27083](https://github.com/pandas-dev/pandas/issues/27083)）。

### 其他

+   从供应的 UltraJSON 实现中删除了未使用的 C 函数（[GH 26198](https://github.com/pandas-dev/pandas/issues/26198)）。

+   允许将`Index`和`RangeIndex`传递给 numpy 的`min`和`max`函数（[GH 26125](https://github.com/pandas-dev/pandas/issues/26125)）。

+   使用`Series`子类的空对象的`repr`中使用实际的类名（[GH 27001](https://github.com/pandas-dev/pandas/issues/27001)）。

+   修复了`DataFrame`中的一个错误，在传递了一个时区感知的`datetime`对象的对象数组时，错误地引发了`ValueError`（[GH 13287](https://github.com/pandas-dev/pandas/issues/13287)）。

### Categorical

+   修复了`DataFrame.at()`和`Series.at()`中的一个错误，当索引是一个`CategoricalIndex`时，会引发异常（[GH 20629](https://github.com/pandas-dev/pandas/issues/20629)）。

+   修复了一个问题，当包含缺失值的有序`Categorical`与一个标量进行比较时，有时会错误地结果为`True`（[GH 26504](https://github.com/pandas-dev/pandas/issues/26504)）。

+   修复了`DataFrame.dropna()`中的一个错误，当`DataFrame`有一个包含`Interval`对象的`CategoricalIndex`时，错误地引发了`TypeError`（[GH 25087](https://github.com/pandas-dev/pandas/issues/25087)）。

### Datetimelike

+   修复了`to_datetime()`中的一个错误，当调用一个远期日期和指定了`format`参数时，会抛出一个（错误的）`ValueError`，而不是引发`OutOfBoundsDatetime`（[GH 23830](https://github.com/pandas-dev/pandas/issues/23830)）。

+   修复了`to_datetime()`中的一个错误，当以`cache=True`调用，`arg`包含来自集合`{None, numpy.nan, pandas.NaT}`至少两个不同元素时，会引发`InvalidIndexError: Reindexing only valid with uniquely valued Index objects`（[GH 22305](https://github.com/pandas-dev/pandas/issues/22305)）。

+   `DataFrame` 和 `Series` 中的错误，其中带有`dtype='datetime64[ns]`的时区感知数据未被转换为朴素时间。([GH 25843](https://github.com/pandas-dev/pandas/issues/25843))

+   在各种日期时间函数中改进了 `Timestamp` 类型检查，以防止在使用子类化的 `datetime` 时引发异常。([GH 25851](https://github.com/pandas-dev/pandas/issues/25851))

+   在 `Series` 和 `DataFrame` 的 repr 中的错误，其中`np.datetime64('NaT')`和`np.timedelta64('NaT')`带有`dtype=object`将被表示为`NaN`。([GH 25445](https://github.com/pandas-dev/pandas/issues/25445))

+   在 `to_datetime()` 中的错误，当错误设置为强制时，不会将无效参数替换为`NaT`。([GH 26122](https://github.com/pandas-dev/pandas/issues/26122))

+   在将非零月份的`DateOffset`添加到 `DatetimeIndex` 中会引发`ValueError`。([GH 26258](https://github.com/pandas-dev/pandas/issues/26258))

+   在使用无效日期和`NaN`值的混合调用时，当`format='%Y%m%d'`和`error='coerce'`时，`to_datetime()` 中会引发未处理的`OverflowError`。([GH 25512](https://github.com/pandas-dev/pandas/issues/25512))

+   在 `isin()` 中出现的错误，用于 datetimelike 索引；`DatetimeIndex`，`TimedeltaIndex` 和 `PeriodIndex` 中 `levels` 参数被忽略了。([GH 26675](https://github.com/pandas-dev/pandas/issues/26675))

+   在为长度大于或等于 6 位的无效整数日期调用时，`format='%Y%m%d'`将引发`TypeError`，`errors='ignore'`时。([GH 25512](https://github.com/pandas-dev/pandas/issues/25512))

+   在将 `PeriodIndex` 与零维 numpy 数组进行比较时出现的错误。([GH 26689](https://github.com/pandas-dev/pandas/issues/26689))

+   在使用非 ns 单位和超出范围的时间戳构造 numpy `datetime64` 数组的 `Series` 或 `DataFrame` 中出现错误，这将正确引发`OutOfBoundsDatetime`错误。([GH 26206](https://github.com/pandas-dev/pandas/issues/26206)).

+   在非常大或非常小的日期上调用`date_range()`时会引发不必要的`OverflowError`的错误（[GH 26651](https://github.com/pandas-dev/pandas/issues/26651)）

+   将`Timestamp`添加到`np.timedelta64`对象时会引发错误而不是返回`Timestamp`的错误（[GH 24775](https://github.com/pandas-dev/pandas/issues/24775)）

+   比较包含`np.datetime64`对象的零维 numpy 数组与`Timestamp`时会错误引发`TypeError`的错误（[GH 26916](https://github.com/pandas-dev/pandas/issues/26916)）

+   `to_datetime()`中的错误，当使用`cache=True`调用时会引发`ValueError: Tz-aware datetime.datetime cannot be converted to datetime64 unless utc=True`，`arg`包含具有不同偏移的日期时间字符串时（[GH 26097](https://github.com/pandas-dev/pandas/issues/26097)）

### 时间增量

+   `TimedeltaIndex.intersection()`中的错误，在某些情况下，对于非单调索引，当实际上存在交集时，返回一个空的`Index`（[GH 25913](https://github.com/pandas-dev/pandas/issues/25913)）

+   比较`Timedelta`和`NaT`时引发`TypeError`的错误（[GH 26039](https://github.com/pandas-dev/pandas/issues/26039)）

+   将`BusinessHour`添加或减去到`Timestamp`时，结果时间分别落在后续或前一天时引发错误的错误（[GH 26381](https://github.com/pandas-dev/pandas/issues/26381))

+   比较`TimedeltaIndex`与零维 numpy 数组时的错误（[GH 26689](https://github.com/pandas-dev/pandas/issues/26689)）

### 时区

+   `DatetimeIndex.to_frame()`中的错误，将时区感知数据转换为时区无关数据（[GH 25809](https://github.com/pandas-dev/pandas/issues/25809)）

+   `to_datetime()`中的错误，使用`utc=True`和日期时间字符串时，会将先前解析的 UTC 偏移应用于后续参数（[GH 24992](https://github.com/pandas-dev/pandas/issues/24992)）

+   在使用`Timestamp.tz_localize()`和`Timestamp.tz_convert()`时存在 bug，无法传播`freq`（[GH 25241](https://github.com/pandas-dev/pandas/issues/25241)）

+   在使用`Series.at()`时存在 bug，当设置带有时区的`Timestamp`时会引发`TypeError`（[GH 25506](https://github.com/pandas-dev/pandas/issues/25506)）

+   在使用`DataFrame.update()`时存在 bug，使用带有时区信息的数据进行更新会返回时区无关的数据���[GH 25807](https://github.com/pandas-dev/pandas/issues/25807)）

+   在使用`to_datetime()`时存在 bug，当传递带有混合 UTC 偏移的日期时间字符串的时候，会引发一个无信息的`RuntimeError`（[GH 25978](https://github.com/pandas-dev/pandas/issues/25978)）

+   在使用`unit='ns'`的情况下，`to_datetime()`会从解析的参数中删除时区信息（[GH 26168](https://github.com/pandas-dev/pandas/issues/26168)）

+   在使用`DataFrame.join()`时存在 bug，将具有时区信息的索引与具有时区信息的列进行连接会导致一列`NaN`（[GH 26335](https://github.com/pandas-dev/pandas/issues/26335)）

+   在使用`date_range()`时存在 bug，当开始或结束时间模糊或不存在时，`ambiguous`或`nonexistent`关键字无法处理（[GH 27088](https://github.com/pandas-dev/pandas/issues/27088)）

+   在合并具有时区感知和时区无关的`DatetimeIndex`时，`DatetimeIndex.union()`存在 bug（[GH 21671](https://github.com/pandas-dev/pandas/issues/21671)）

+   在将 numpy 缩减函数（例如`numpy.minimum()`）应用于具有时区感知的`Series`时存在 bug（[GH 15552](https://github.com/pandas-dev/pandas/issues/15552)）

### 数值

+   在使用`to_numeric()`时存在 bug，大的负数被错误处理（[GH 24910](https://github.com/pandas-dev/pandas/issues/24910)）

+   `to_numeric()` 中的一个 bug，即使 `errors` 不是 `coerce`，数字也被强制转换为浮点数 ([GH 24910](https://github.com/pandas-dev/pandas/issues/24910))

+   `to_numeric()` 中 `errors` 的无效值被允许的 bug ([GH 26466](https://github.com/pandas-dev/pandas/issues/26466))

+   `format` 中的 bug，浮点复数数值未被格式化为正确的显示精度和修剪 ([GH 25514](https://github.com/pandas-dev/pandas/issues/25514))

+   `DataFrame.corr()` 和 `Series.corr()` 中的错误消息的 bug。增加了使用可调用对象的可能性。 ([GH 25729](https://github.com/pandas-dev/pandas/issues/25729))

+   `Series.divmod()` 和 `Series.rdivmod()` 中的 bug，它们会引发（错误的）`ValueError` 而不是返回一对 `Series` 对象作为结果 ([GH 25557](https://github.com/pandas-dev/pandas/issues/25557))

+   当非数值索引被发送到 `interpolate()` 时，引发一个有用的异常，这些方法需要数值索引。 ([GH 21662](https://github.com/pandas-dev/pandas/issues/21662))

+   当比较浮点数与标量运算符时，`eval()` 中的 bug，例如：`x < -0.1` ([GH 25928](https://github.com/pandas-dev/pandas/issues/25928))

+   修复了将全布尔数组转换为整数扩展数组失败的 bug ([GH 25211](https://github.com/pandas-dev/pandas/issues/25211))

+   `divmod` 中的 bug，其中包含零的 `Series` 对象错误地引发 `AttributeError` ([GH 26987](https://github.com/pandas-dev/pandas/issues/26987))

+   `Series` 的 floor-division (//) 和 `divmod` 不一致，将正数//零填充为 `NaN` 而不是 `Inf` ([GH 27321](https://github.com/pandas-dev/pandas/issues/27321))

### 转换

+   当传递一个列和类型字典时，`DataFrame.astype()` 中的 bug，`errors` 参数被忽略。 ([GH 25905](https://github.com/pandas-dev/pandas/issues/25905))

### 字符串

+   `Series.str` 的几种方法中 `__name__` 属性设置错误的 bug ([GH 23551](https://github.com/pandas-dev/pandas/issues/23551))

+   在将错误 dtype 的`Series`传递给`Series.str.cat()`时改进了错误消息（[GH 22722](https://github.com/pandas-dev/pandas/issues/22722)）。

### 区间

+   `Interval`的构造限制为数值、`Timestamp`和`Timedelta`端点（[GH 23013](https://github.com/pandas-dev/pandas/issues/23013)）。

+   修复了在`IntervalIndex`中未显示`NaN`的`Series`/`DataFrame`中的错误，其中存在缺失值（[GH 25984](https://github.com/pandas-dev/pandas/issues/25984)）。

+   修复了在`IntervalIndex.get_loc()`中，对于递减的`IntervalIndex`会错误地引发`KeyError`的错误（[GH 25860](https://github.com/pandas-dev/pandas/issues/25860)）。

+   修复了在`Index`构造函数中传递混合封闭`Interval`对象会导致`ValueError`而不是`object` dtype `Index`的错误（[GH 27172](https://github.com/pandas-dev/pandas/issues/27172)）。

### 索引

+   在使用非数字对象列表调用`DataFrame.iloc()`时改进了异常消息（[GH 25753](https://github.com/pandas-dev/pandas/issues/25753)）。

+   在使用不同长度的布尔索引器调用`.iloc`或`.loc`时改进了异常消息（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   修复了在使用不存在的键索引`MultiIndex`时`KeyError`异常消息中不显示原始键的错误（[GH 27250](https://github.com/pandas-dev/pandas/issues/27250)）。

+   在使用布尔索引器时，当传递的项目太少时，`.iloc`和`.loc`不会引发`IndexError`的错误（[GH 26658](https://github.com/pandas-dev/pandas/issues/26658)）。

+   `DataFrame.loc()` 和 `Series.loc()` 中的 bug，当键小于或等于 `MultiIndex` 中级别的数量时，不会为 `MultiIndex` 抛出 `KeyError` ([GH 14885](https://github.com/pandas-dev/pandas/issues/14885)).

+   `DataFrame.append()` 产生错误警告的 bug，指示将来在要附加的数据包含新列时将抛出 `KeyError` ([GH 22252](https://github.com/pandas-dev/pandas/issues/22252)).

+   `DataFrame.to_csv()` 导致重新索引的数据帧出现 segfault 的 bug，当索引是单级 `MultiIndex` 时 ([GH 26303](https://github.com/pandas-dev/pandas/issues/26303)).

+   修复了将 `arrays.PandasArray` 赋值给 `DataFrame` 会引发错误的 bug ([GH 26390](https://github.com/pandas-dev/pandas/issues/26390))

+   允许在 `DataFrame.query()` 字符串中使用的可调用本地引用使用关键字参数 ([GH 26426](https://github.com/pandas-dev/pandas/issues/26426))

+   修复了当索引一个包含仅一个标签的列表的 `MultiIndex` 级别时出现的 `KeyError`，该标签缺失的问题 ([GH 27148](https://github.com/pandas-dev/pandas/issues/27148))

+   在部分匹配 `MultiIndex` 中的 `Timestamp` 时产生 `AttributeError` 的 bug ([GH 26944](https://github.com/pandas-dev/pandas/issues/26944))

+   在使用不可与 `Interval` 中的值进行比较的对象使用 `in` 运算符 (`__contains`) 时，`Categorical` 和 `CategoricalIndex` 中的 bug， `Interval` 值 ([GH 23705](https://github.com/pandas-dev/pandas/issues/23705))

+   在单个带有时区感知的 datetime64[ns] 列的`DataFrame.loc()`和`DataFrame.iloc()`中的错误，错误地返回标量而不是`Series`对象（[GH 27110](https://github.com/pandas-dev/pandas/issues/27110))

+   当传递列表时，`CategoricalIndex`和`Categorical`对象在使用 `in` 运算符 (`__contains__`) 时错误地引发 `ValueError` 而不是 `TypeError`（[GH 21729](https://github.com/pandas-dev/pandas/issues/21729))

+   在使用`Series`对象设置新值时出现的错误，将`Timedelta`对象错误地转换为整数（[GH 22717](https://github.com/pandas-dev/pandas/issues/22717))

+   在设置具有时区感知 datetime 的新键（`__setitem__`）时，`Series`中的错误错误地引发 `ValueError`（[GH 12862](https://github.com/pandas-dev/pandas/issues/12862))

+   在使用只读索引器进行索引时，`DataFrame.iloc()`中的错误（[GH 17192](https://github.com/pandas-dev/pandas/issues/17192))

+   当使用时区感知 datetime 值设置现有元组键（`__setitem__`）时，在`Series`中错误地引发 `TypeError`（[GH 20441](https://github.com/pandas-dev/pandas/issues/20441))

### 缺失

+   如果参数 `order` 是必需的但被省略，则在`Series.interpolate()`中修正了误导性异常消息（[GH 10633](https://github.com/pandas-dev/pandas/issues/10633), [GH 24014](https://github.com/pandas-dev/pandas/issues/24014)）。

+   在`DataFrame.dropna()`中，如果传递了无效的 `axis` 参数，则修正了异常消息中显示的类类型（[GH 25555](https://github.com/pandas-dev/pandas/issues/25555))

+   当 `limit` 不是正整数时，`DataFrame.fillna()` 现在会引发 `ValueError`（[GH 27042](https://github.com/pandas-dev/pandas/issues/27042))

### 多重索引

+   当测试 `MultiIndex` 的成员资格时，`Timedelta` 引发了错误的异常（[GH 24570](https://github.com/pandas-dev/pandas/issues/24570)）

### IO

+   在 `DataFrame.to_html()` 中存在 bug，使用显示选项截断值而不是输出完整内容（[GH 17004](https://github.com/pandas-dev/pandas/issues/17004)）

+   修复了在 Python 3 上使用 `to_clipboard()` 时，在 Windows 上复制 utf-16 字符时丢失文本的错误（[GH 25040](https://github.com/pandas-dev/pandas/issues/25040)）

+   在 `read_json()` 中存在 bug，当默认情况下尝试推断数据类型时，因为数据类型已经在 JSON 架构中定义，因此不适用（[GH 21345](https://github.com/pandas-dev/pandas/issues/21345)）

+   在 `read_json()` 中存在 bug，针对 `orient='table'` 和浮点索引，因为默认情况下它会推断索引的数据类型，而在 JSON 架构中已经定义了索引数据类型，因此不适用（[GH 25433](https://github.com/pandas-dev/pandas/issues/25433)）

+   在 `read_json()` 中存在 bug，针对 `orient='table'` 和浮点列名字符串，因为它将列名类型转换为 `Timestamp`，而列名已经在 JSON 架构中定义，因此不适用（[GH 25435](https://github.com/pandas-dev/pandas/issues/25435)）

+   在 `json_normalize()` 中存在 bug，针对 `errors='ignore'`，在输入数据中缺少值时，结果 `DataFrame` 中的缺失值被填充为字符串 `"nan"` 而不是 `numpy.nan`（[GH 25468](https://github.com/pandas-dev/pandas/issues/25468)）

+   在使用无效类型的 `classes` 参数时，`DataFrame.to_html()` 现在引发 `TypeError` 而不是 `AssertionError`（[GH 25608](https://github.com/pandas-dev/pandas/issues/25608))

+   在使用 `header` 关键字时，`DataFrame.to_string()` 和 `DataFrame.to_latex()` 中存在 bug，导致输出不正确（[GH 16718](https://github.com/pandas-dev/pandas/issues/16718)）

+   在 Windows 上的 Python 3.6+ 中，`read_csv()` 中的一个 Bug 未能正确解释 UTF8 编码的文件名 ([GH 15086](https://github.com/pandas-dev/pandas/issues/15086))

+   在转换具有缺失值的列时，改进了 `pandas.read_stata()` 和 `pandas.io.stata.StataReader` 的性能 ([GH 25772](https://github.com/pandas-dev/pandas/issues/25772))

+   在 `DataFrame.to_html()` 中存在 Bug，头部编号在四舍五入时会忽略显示选项 ([GH 17280](https://github.com/pandas-dev/pandas/issues/17280))

+   在使用 `start` 或 `stop` 参数进行子选择时，`read_hdf()` 中存在 Bug，导致无法从直接使用 PyTables 写入的 HDF5 文件中读取表时出现 `ValueError` ([GH 11188](https://github.com/pandas-dev/pandas/issues/11188))

+   在引发 `KeyError` 后，`read_hdf()` 未正确关闭存储的 Bug 已修复 ([GH 25766](https://github.com/pandas-dev/pandas/issues/25766))

+   改进了当 Stata dta 文件中的值标签重复时失败的说明，并提出了解决方法 ([GH 25772](https://github.com/pandas-dev/pandas/issues/25772))

+   改进了 `pandas.read_stata()` 和 `pandas.io.stata.StataReader`，以读取由 Stata 保存的格式错误的 118 格式文件 ([GH 25960](https://github.com/pandas-dev/pandas/issues/25960))

+   改进了 `DataFrame.to_html()` 中的 `col_space` 参数，使其接受字符串，以便正确设置 CSS 长度值 ([GH 25941](https://github.com/pandas-dev/pandas/issues/25941))

+   修复了从 S3 加载包含 URL 中的 `#` 字符的对象时的 Bug ([GH 25945](https://github.com/pandas-dev/pandas/issues/25945))

+   向 `read_gbq()` 添加了 `use_bqstorage_api` 参数，以加速大型数据帧的下载。此功能还需要 `pandas-gbq` 库的版本 0.10.0，以及 `google-cloud-bigquery-storage` 和 `fastavro` 库。 ([GH 26104](https://github.com/pandas-dev/pandas/issues/26104))

+   修复了在处理数值数据时 `DataFrame.to_json()` 中的内存泄漏问题 ([GH 24889](https://github.com/pandas-dev/pandas/issues/24889))

+   `read_json()` 存在一个 bug，日期字符串带有 `Z` 时未转换为 UTC 时区（[GH 26168](https://github.com/pandas-dev/pandas/issues/26168)）

+   在 `read_csv()` 中添加了 `cache_dates=True` 参数，允许在解析时缓存唯一日期（[GH 25990](https://github.com/pandas-dev/pandas/issues/25990)）

+   当调用者的维度超出 Excel 限制时，`DataFrame.to_excel()` 现在会引发 `ValueError` 错误（[GH 26051](https://github.com/pandas-dev/pandas/issues/26051)）

+   在 `pandas.read_csv()` 中修复了一个 bug，使用 `engine='python'` 时，BOM 会导致解析错误（[GH 26545](https://github.com/pandas-dev/pandas/issues/26545)）

+   当输入为 `pandas.io.excel.ExcelFile` 类型并传递了 `engine` 参数时，`read_excel()` 现在会引发 `ValueError` 错误，因为 `pandas.io.excel.ExcelFile` 已定义了一个引擎（[GH 26566](https://github.com/pandas-dev/pandas/issues/26566)）

+   在指定 `where=''` 的情况下从 `HDFStore` 中选择时存在 bug（[GH 26610](https://github.com/pandas-dev/pandas/issues/26610)）

+   在 `DataFrame.to_excel()` 中修复了一个 bug，合并单元格内的自定义对象（即 `PeriodIndex`）未转换为 Excel 写入器安全类型的错误（[GH 27006](https://github.com/pandas-dev/pandas/issues/27006)）

+   在 `read_hdf()` 中存在一个 bug，读取带时区的 `DatetimeIndex` 会引发 `TypeError` 错误（[GH 11926](https://github.com/pandas-dev/pandas/issues/11926)）

+   `to_msgpack()` 和 `read_msgpack()` 中存在一个 bug，对于无效路径，它们会引发 `ValueError` 而不是 `FileNotFoundError` 错误（[GH 27160](https://github.com/pandas-dev/pandas/issues/27160)）

+   `DataFrame.to_parquet()` 中修复了一个 bug，当 dataframe 没有列时会引发 `ValueError` 错误（[GH 27339](https://github.com/pandas-dev/pandas/issues/27339)）

+   当使用 `read_csv()` 时，允许解析 `PeriodDtype` 列（[GH 26934](https://github.com/pandas-dev/pandas/issues/26934)）

### 绘图

+   修复了 `api.extensions.ExtensionArray` 无法在 matplotlib 绘图中使用的错误（[GH 25587](https://github.com/pandas-dev/pandas/issues/25587))

+   `DataFrame.plot()` 中的错误消息中存在错误。如果向 `DataFrame.plot()` 传递了非数字，则改进了错误消息（[GH 25481](https://github.com/pandas-dev/pandas/issues/25481))

+   绘制非数值 / 非日期时间索引时，刻度标签位置不正确的错误已修复（[GH 7612](https://github.com/pandas-dev/pandas/issues/7612), [GH 15912](https://github.com/pandas-dev/pandas/issues/15912), [GH 22334](https://github.com/pandas-dev/pandas/issues/22334))

+   修复了绘制 `PeriodIndex` 时间序列时，如果频率是频率规则代码的倍数，则会失败的错误（[GH 14763](https://github.com/pandas-dev/pandas/issues/14763))

+   修复了使用 `datetime.timezone.utc` 时区绘制 `DatetimeIndex` 时的错误（[GH 17173](https://github.com/pandas-dev/pandas/issues/17173))

### GroupBy/resample/rolling

+   `Resampler.agg()` 在具有时区感知索引的情况下存在错误，传递函数列表时会引发 `OverflowError`（[GH 22660](https://github.com/pandas-dev/pandas/issues/22660))

+   在 `DataFrameGroupBy.nunique()` 中存在错误，导致列级别的名称丢失（[GH 23222](https://github.com/pandas-dev/pandas/issues/23222))

+   在对具有时区感知数据应用聚合函数时，`GroupBy.agg()` 中存在错误（[GH 23683](https://github.com/pandas-dev/pandas/issues/23683))

+   `GroupBy.first()` 和 `GroupBy.last()` 中存在时区信息丢失的错误（[GH 21603](https://github.com/pandas-dev/pandas/issues/21603))

+   在仅对 NA 值分组时，`GroupBy.size()` 中存在错误（[GH 23050](https://github.com/pandas-dev/pandas/issues/23050))

+   在 `Series.groupby()` 中，之前忽略了 `observed` kwarg 的错误已修复（[GH 24880](https://github.com/pandas-dev/pandas/issues/24880))

+   `Series.groupby()` 中存在错误，使用 `MultiIndex` Series 进行 `groupby`，标签列表长度等于序列长度时会导致错误的分组 ([GH 25704](https://github.com/pandas-dev/pandas/issues/25704))

+   确保在所有 Python 版本中 `groupby` 聚合函数的输出顺序一致 ([GH 25692](https://github.com/pandas-dev/pandas/issues/25692))

+   当在有序的 `Categorical` 上进行分组并指定 `observed=True` 时，确保结果组的顺序正确 ([GH 25871](https://github.com/pandas-dev/pandas/issues/25871), [GH 25167](https://github.com/pandas-dev/pandas/issues/25167))

+   `Rolling.min()` 和 `Rolling.max()` 中存在错误，会导致内存泄漏 ([GH 25893](https://github.com/pandas-dev/pandas/issues/25893))

+   `Rolling.count()` 和 `.Expanding.count` 中存在错误，先前忽略了 `axis` 关键字 ([GH 13503](https://github.com/pandas-dev/pandas/issues/13503))

+   `GroupBy.idxmax()` 和 `GroupBy.idxmin()` 在 datetime 列中存在错误，会返回不正确的 dtype ([GH 25444](https://github.com/pandas-dev/pandas/issues/25444), [GH 15306](https://github.com/pandas-dev/pandas/issues/15306))

+   `GroupBy.cumsum()`、`GroupBy.cumprod()`、`GroupBy.cummin()` 和 `GroupBy.cummax()` 中存在错误，对于具有缺失类别的分类列，会返回不正确的结果或分段错误 ([GH 16771](https://github.com/pandas-dev/pandas/issues/16771))

+   `GroupBy.nth()` 中存在错误，分组中的 NA 值会返回不正确的结果 ([GH 26011](https://github.com/pandas-dev/pandas/issues/26011))

+   `SeriesGroupBy.transform()` 中存在错误，对空组进行转换会引发 `ValueError` ([GH 26208](https://github.com/pandas-dev/pandas/issues/26208))

+   `DataFrame.groupby()` 中存在错误，当使用 `.groups` 访问器时传递 `Grouper` 会返回不正确的组 ([GH 26326](https://github.com/pandas-dev/pandas/issues/26326))

+   `GroupBy.agg()` 中存在错误，对于 uint64 列会返回不正确的结果。([GH 26310](https://github.com/pandas-dev/pandas/issues/26310))

+   在 `Rolling.median()` 和 `Rolling.quantile()` 中存在的错误，当窗口为空时引发 MemoryError（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   在 `Rolling.median()` 和 `Rolling.quantile()` 中存在的错误，使用 `closed='left'` 和 `closed='neither'` 时返回不正确的结果（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   改进了 `Rolling`、`Window` 和 `ExponentialMovingWindow` 函数，以排除结果中的无关列，而不是引发错误，并且只有当所有列都是无关列时才引发 `DataError`（[GH 12537](https://github.com/pandas-dev/pandas/issues/12537)）

+   在 `Rolling.max()` 和 `Rolling.min()` 中存在的错误，当变量窗口为空时返回不正确的结果（[GH 26005](https://github.com/pandas-dev/pandas/issues/26005)）

+   当 `Window.aggregate()` 的参数中使用不受支持的加权窗口函数时，引发一个有用的异常（[GH 26597](https://github.com/pandas-dev/pandas/issues/26597)）

### 重塑

+   在 `pandas.merge()` 中存在的错误，如果在后缀中分配了 `None`，则会添加一个 `None` 的字符串，而不是保留列名不变（[GH 24782](https://github.com/pandas-dev/pandas/issues/24782)）

+   在按索引名称合并时，`merge()` 中的错误导致索引编号错误（现在缺失的索引值被分配为 NA）（[GH 24212](https://github.com/pandas-dev/pandas/issues/24212), [GH 25009](https://github.com/pandas-dev/pandas/issues/25009)）

+   `to_records()` 现在可以接受其 `column_dtypes` 参数的数据类型（[GH 24895](https://github.com/pandas-dev/pandas/issues/24895)）

+   在 `concat()` 中存在的错误，当作为 `objs` 参数传入时，不尊重 `OrderedDict`（以及 Python 3.6+ 中的 `dict`）的顺序（[GH 21510](https://github.com/pandas-dev/pandas/issues/21510)）

+   在 `pivot_table()` 中的错误，当 `aggfunc` 参数包含一个 `list` 时，即使 `dropna` 参数为 `False`，仍会丢弃具有 `NaN` 值的列（[GH 22159](https://github.com/pandas-dev/pandas/issues/22159)）。

+   在 `concat()` 中的错误，会导致两个具有相同 `freq` 的 `DatetimeIndex` 的结果 `freq` 被丢弃（[GH 3232](https://github.com/pandas-dev/pandas/issues/3232)）。

+   在 `merge()` 中的错误，当与等效的 Categorical dtypes 合并时会引发错误（[GH 22501](https://github.com/pandas-dev/pandas/issues/22501)）。

+   使用迭代器或生成器字典（例如 `pd.DataFrame({'A': reversed(range(3))})`）实例化 `DataFrame` 时会引发错误（[GH 26349](https://github.com/pandas-dev/pandas/issues/26349)）。

+   使用 `range` 实例化 `DataFrame` 时出现错误（例如 `pd.DataFrame(range(3))`）会引发错误（[GH 26342](https://github.com/pandas-dev/pandas/issues/26342)）。

+   当传递非空元组时，`DataFrame` 构造函数会导致分段错误（[GH 25691](https://github.com/pandas-dev/pandas/issues/25691)）。

+   在 `Series.apply()` 中的错误，当系列是时区感知的 `DatetimeIndex` 时会失败（[GH 25959](https://github.com/pandas-dev/pandas/issues/25959)）。

+   在 `pandas.cut()` 中的错误，当大型 bin 由于整数溢出而不正确引发错误时（[GH 26045](https://github.com/pandas-dev/pandas/issues/26045)）。

+   在 `DataFrame.sort_index()` 中的错误，在对初始级别进行最后排序时，当对多级索引的 `DataFrame` 进行所有级别的排序时会抛出错误（[GH 26053](https://github.com/pandas-dev/pandas/issues/26053)）。

+   在 `Series.nlargest()` 中的错误，将 `True` 视为小于 `False`（[GH 26154](https://github.com/pandas-dev/pandas/issues/26154)）。

+   在将`IntervalIndex`作为透视索引进行数据透视时，在`DataFrame.pivot_table()`中存在错误，会引发`TypeError` ([GH 25814](https://github.com/pandas-dev/pandas/issues/25814))

+   在`DataFrame.from_dict()`中存在错误，当`orient='index'`时，忽略了`OrderedDict`的顺序 ([GH 8425](https://github.com/pandas-dev/pandas/issues/8425))

+   在具有时区感知日期时间列的 DataFrame 转置时，在`DataFrame.transpose()`中存在错误，将错误地引发`ValueError` ([GH 26825](https://github.com/pandas-dev/pandas/issues/26825))

+   在将时区感知列作为`values`进行数据透视时，在`pivot_table()`中存在错误，会删除时区信息 ([GH 14948](https://github.com/pandas-dev/pandas/issues/14948))

+   在指定多个`by`列且其中一个是`datetime64[ns, tz]` dtype 时，在`merge_asof()`中存在错误 ([GH 26649](https://github.com/pandas-dev/pandas/issues/26649))

### 稀疏

+   `SparseArray`初始化速度显著提升，使大多数操作受益，修复了 v0.20.0 中引入的性能回归 ([GH 24985](https://github.com/pandas-dev/pandas/issues/24985))

+   在`SparseFrame`构造函数中存在错误，当将`None`作为数据传递时，将会忽略`default_fill_value` ([GH 16807](https://github.com/pandas-dev/pandas/issues/16807))

+   在添加长度与索引长度不匹配的列时存在`SparseDataFrame`中存在错误，将引发`AssertionError`而不是引发`ValueError` ([GH 25484](https://github.com/pandas-dev/pandas/issues/25484))

+   在`Series.sparse.from_coo()`中引入更好的错误消息，以便对不是 coo 矩阵的输入返回`TypeError` ([GH 26554](https://github.com/pandas-dev/pandas/issues/26554))

+   在`SparseArray`上的`numpy.modf()`中存在错误。现在会返回`SparseArray`的元组 ([GH 26946](https://github.com/pandas-dev/pandas/issues/26946))

### 构建更改

+   修复在 macOS 上使用 PyPy 安装时的错误 ([GH 26536](https://github.com/pandas-dev/pandas/issues/26536))

### ExtensionArray

+   在传递具有自定义`na_sentinel`的`ExtensionArray`时，在`factorize()`中存在错误 ([GH 25696](https://github.com/pandas-dev/pandas/issues/25696))

+   `Series.count()`在 ExtensionArrays 中错误计算 NA 值（[GH 26835](https://github.com/pandas-dev/pandas/issues/26835)）

+   添加了`Series.__array_ufunc__`以更好地处理应用于由扩展数组支持的 Series 的 NumPy ufuncs（[GH 23293](https://github.com/pandas-dev/pandas/issues/23293)）。

+   `ExtensionArray.copy()`中已删除关键字参数`deep`（[GH 27083](https://github.com/pandas-dev/pandas/issues/27083)）

### 其他

+   从供应的 UltraJSON 实现中删除了未使用的 C 函数（[GH 26198](https://github.com/pandas-dev/pandas/issues/26198)）

+   允许`Index`和`RangeIndex`传递给 numpy 的`min`和`max`函数（[GH 26125](https://github.com/pandas-dev/pandas/issues/26125)）

+   在`Series`子类的空对象的 repr 中使用实际类名（[GH 27001](https://github.com/pandas-dev/pandas/issues/27001)）。

+   `DataFrame`中的一个错误，在传递一个时区感知的`datetime`对象的对象数组时，会错误地引发`ValueError`（[GH 13287](https://github.com/pandas-dev/pandas/issues/13287)）

## 贡献者

总共有 231 人为这个版本贡献了补丁。名字后面带有“+”的人第一次贡献了补丁。

+   1_x7 +

+   Abdullah İhsan Seçer +

+   Adam Bull +

+   Adam Hooper

+   Albert Villanova del Moral

+   Alex Watt +

+   AlexTereshenkov +

+   Alexander Buchkovsky

+   Alexander Hendorf +

+   Alexander Nordin +

+   Alexander Ponomaroff

+   Alexandre Batisse +

+   Alexandre Decan +

+   Allen Downey +

+   Alyssa Fu Ward +

+   Andrew Gaspari +

+   Andrew Wood +

+   Antoine Viscardi +

+   Antonio Gutierrez +

+   Arno Veenstra +

+   ArtinSarraf

+   Batalex +

+   Baurzhan Muftakhidinov

+   Benjamin Rowell

+   Bharat Raghunathan +

+   Bhavani Ravi +

+   Big Head +

+   Brett Randall +

+   Bryan Cutler +

+   C John Klehm +

+   Caleb Braun +

+   Cecilia +

+   Chris Bertinato +

+   Chris Stadler +

+   Christian Haege +

+   Christian Hudon

+   Christopher Whelan

+   Chuanzhu Xu +

+   Clemens Brunner

+   Damian Kula +

+   Daniel Hrisca +

+   Daniel Luis Costa +

+   Daniel Saxton

+   DanielFEvans +

+   David Liu +

+   Deepyaman Datta +

+   Denis Belavin +

+   Devin Petersohn +

+   Diane Trout +

+   EdAbati +

+   Enrico Rotundo +

+   EternalLearner42 +

+   Evan +

+   Evan Livelo +

+   Fabian Rost +

+   Flavien Lambert +

+   Florian Rathgeber +

+   Frank Hoang +

+   Gaibo Zhang +

+   Gioia Ballin

+   Giuseppe Romagnuolo +

+   Gordon Blackadder +

+   Gregory Rome +

+   Guillaume Gay

+   HHest +

+   Hielke Walinga +

+   How Si Wei +

+   Hubert

+   Huize Wang +

+   Hyukjin Kwon +

+   Ian Dunn +

+   Inevitable-Marzipan +

+   Irv Lustig

+   JElfner +

+   Jacob Bundgaard +

+   James Cobon-Kerr +

+   Jan-Philip Gehrcke +

+   Jarrod Millman +

+   Jayanth Katuri +

+   Jeff Reback

+   Jeremy Schendel

+   Jiang Yue +

+   Joel Ostblom

+   Johan von Forstner +

+   Johnny Chiu +

+   Jonas +

+   Jonathon Vandezande +

+   Jop Vermeer +

+   Joris Van den Bossche

+   Josh

+   Josh Friedlander +

+   Justin Zheng

+   Kaiqi Dong

+   Kane +

+   Kapil Patel +

+   Kara de la Marck +

+   Katherine Surta +

+   Katrin Leinweber +

+   Kendall Masse

+   Kevin Sheppard

+   Kyle Kosic +

+   Lorenzo Stella +

+   Maarten Rietbergen +

+   Mak Sze Chun

+   Marc Garcia

+   Mateusz Woś

+   Matias Heikkilä

+   Mats Maiwald +

+   Matthew Roeschke

+   Max Bolingbroke +

+   Max Kovalovs +

+   Max van Deursen +

+   Michael

+   Michael Davis +

+   Michael P. Moran +

+   Mike Cramblett +

+   Min ho Kim +

+   Misha Veldhoen +

+   Mukul Ashwath Ram +

+   MusTheDataGuy +

+   Nanda H Krishna +

+   Nicholas Musolino

+   Noam Hershtig +

+   Noora Husseini +

+   Paul

+   Paul Reidy

+   Pauli Virtanen

+   Pav A +

+   Peter Leimbigler +

+   Philippe Ombredanne +

+   Pietro Battiston

+   Richard Eames +

+   Roman Yurchak

+   Ruijing Li

+   Ryan

+   Ryan Joyce +

+   Ryan Nazareth

+   Ryan Rehman +

+   Sakar Panta +

+   Samuel Sinayoko

+   Sandeep Pathak +

+   Sangwoong Yoon

+   Saurav Chakravorty

+   Scott Talbert +

+   Sergey Kopylov +

+   Shantanu Gontia +

+   Shivam Rana +

+   Shorokhov Sergey +

+   Simon Hawkins

+   Soyoun(Rose) Kim

+   Stephan Hoyer

+   Stephen Cowley +

+   Stephen Rauch

+   Sterling Paramore +

+   Steven +

+   Stijn Van Hoey

+   Sumanau Sareen +

+   Takuya N +

+   Tan Tran +

+   Tao He +

+   Tarbo Fukazawa

+   Terji Petersen +

+   Thein Oo

+   ThibTrip +

+   Thijs Damsma +

+   Thiviyan Thanapalasingam

+   Thomas A Caswell

+   Thomas Kluiters +

+   Tilen Kusterle +

+   Tim Gates +

+   Tim Hoffmann

+   Tim Swast

+   Tom Augspurger

+   Tom Neep +

+   Tomáš Chvátal +

+   Tyler Reddy

+   Vaibhav Vishal +

+   Vasily Litvinov +

+   Vibhu Agarwal +

+   Vikramjeet Das +

+   Vladislav +

+   Víctor Moron Tejero +

+   Wenhuan

+   Will Ayd +

+   William Ayd

+   Wouter De Coster +

+   Yoann Goular +

+   Zach Angell +

+   alimcmaster1

+   anmyachev +

+   chris-b1

+   danielplawrence +

+   endenis +

+   enisnazif +

+   ezcitron +

+   fjetter

+   froessler

+   gfyoung

+   gwrome +

+   h-vetinari

+   haison +

+   hannah-c +

+   heckeop +

+   iamshwin +

+   jamesoliverh +

+   jbrockmendel

+   jkovacevic +

+   killerontherun1 +

+   knuu +

+   kpapdac +

+   kpflugshaupt +

+   krsnik93 +

+   leerssej +

+   lrjball +

+   mazayo +

+   nathalier +

+   nrebena +

+   nullptr +

+   pilkibun +

+   pmaxey83 +

+   rbenes +

+   robbuckley

+   shawnbrown +

+   sudhir mohanraj +

+   tadeja +

+   tamuhey +

+   thatneat

+   topper-123

+   willweil +

+   yehia67 +

+   yhaque1213 +
