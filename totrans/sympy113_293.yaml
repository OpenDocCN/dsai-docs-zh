- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/crypto.html](https://docs.sympy.org/latest/modules/crypto.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This module is intended for educational purposes only. Do not use the functions
    in this module for real cryptographic applications. If you wish to encrypt real
    data, we recommend using something like the [cryptography](https://cryptography.io/en/latest/)
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encryption is the process of hiding a message and a cipher is a means of doing
    so. Included in this module are both block and stream ciphers:'
  prefs: []
  type: TYPE_NORMAL
- en: Shift cipher
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Affine cipher
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: substitution ciphers
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Vigenere’s cipher
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Hill’s cipher
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bifid ciphers
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RSA
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Kid RSA
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: linear-feedback shift registers (for stream ciphers)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ElGamal encryption
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: In a *substitution cipher* “units” (not necessarily single characters) of plaintext
    are replaced with ciphertext according to a regular system.
  prefs: []
  type: TYPE_NORMAL
- en: A *transposition cipher* is a method of encryption by which the positions held
    by “units” of plaintext are replaced by a permutation of the plaintext. That is,
    the order of the units is changed using a bijective function on the position of
    the characters to perform the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: A *monoalphabetic cipher* uses fixed substitution over the entire message, whereas
    a *polyalphabetic cipher* uses a number of substitutions at different times in
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return the letters of `s` in uppercase. In case more than one string is passed,
    each of them will be processed and a list of upper case strings will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`check_and_join`](#sympy.crypto.crypto.check_and_join "sympy.crypto.crypto.check_and_join")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Return a string of the distinct characters of `symbols` with those of `key`
    appearing first. A ValueError is raised if a) there are duplicate characters in
    `symbols` or b) there are characters in `key` that are not in `symbols`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Joins characters of `phrase` and if `symbols` is given, raises an error if any
    character in `phrase` is not in `symbols`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**phrase**'
  prefs: []
  type: TYPE_NORMAL
- en: String or list of strings to be returned as a string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: Iterable of characters allowed in `phrase`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `symbols` is `None`, no checking is performed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Returns the elements of the list `range(n)` shifted to the left by `k` (so the
    list starts with `k` (mod `n`)).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Performs shift cipher encryption on plaintext msg, and returns the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The secret key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**msg** : str'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext of upper-case letters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext of upper-case letters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To decipher the shifted text, change the sign of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a convenience function that does this with the original key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L1` of corresponding integers.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L1` a new list `L2`, given by adding `(k mod 26)` to
    each element in `L1`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L2` a string `ct` of corresponding letters.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: The shift cipher is also called the Caesar cipher, after Julius Caesar, who,
    according to Suetonius, used it with a shift of three to protect messages of military
    significance. Caesar’s nephew Augustus reportedly used a similar cipher, but with
    a right shift of 1.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_shift`](#sympy.crypto.crypto.decipher_shift "sympy.crypto.crypto.decipher_shift")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R151](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Caesar_cipher](https://en.wikipedia.org/wiki/Caesar_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R152](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/CaesarsMethod.html](https://mathworld.wolfram.com/CaesarsMethod.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Return the text by shifting the characters of `msg` to the left by the amount
    given by `key`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To decipher the shifted text, change the sign of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use this function with the original key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Performs the ROT13 encryption on a given plaintext `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: ROT13 is a substitution cipher which substitutes each letter in the plaintext
    message for the letter furthest away from it in the English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: Equivalently, it is just a Caeser (shift) cipher with a shift key of 13 (midway
    point of the alphabet).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_rot13`](#sympy.crypto.crypto.decipher_rot13 "sympy.crypto.crypto.decipher_rot13"),
    [`encipher_shift`](#sympy.crypto.crypto.encipher_shift "sympy.crypto.crypto.encipher_shift")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R153](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/ROT13](https://en.wikipedia.org/wiki/ROT13)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Performs the ROT13 decryption on a given plaintext `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`decipher_rot13` is equivalent to `encipher_rot13` as both `decipher_shift`
    with a key of 13 and `encipher_shift` key with a key of 13 will return the same
    results. Nonetheless, `decipher_rot13` has nonetheless been explicitly defined
    here for consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Performs the affine cipher encryption on plaintext `msg`, and returns the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg** : str'
  prefs: []
  type: TYPE_NORMAL
- en: Characters that appear in `symbols`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**a, b** : int, int'
  prefs: []
  type: TYPE_NORMAL
- en: A pair integers, with `gcd(a, N) = 1` (the secret key).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: String of characters (default = uppercase letters).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When no symbols are given, `msg` is converted to upper case letters and all
    other characters are ignored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: ct
  prefs: []
  type: TYPE_NORMAL
- en: String of characters (the ciphertext message)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is based on the map \(x \rightarrow ax+b\) (mod \(N\)) where `N`
    is the number of characters in the alphabet. Decryption is based on the map \(x
    \rightarrow cx+d\) (mod \(N\)), where \(c = a^{-1}\) (mod \(N\)) and \(d = -a^{-1}b\)
    (mod \(N\)). In particular, for the map to be invertible, we need \(\mathrm{gcd}(a,
    N) = 1\) and an error will be raised if this is not true.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L1` of corresponding integers.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L1` a new list `L2`, given by replacing `x` by `a*x +
    b (mod N)`, for each element `x` in `L1`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L2` a string `ct` of corresponding letters.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a straightforward generalization of the shift cipher with the added
    complexity of requiring 2 characters to be deciphered in order to recover the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_affine`](#sympy.crypto.crypto.decipher_affine "sympy.crypto.crypto.decipher_affine")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R154](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Affine_cipher](https://en.wikipedia.org/wiki/Affine_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the deciphered text that was made from the mapping, \(x \rightarrow
    ax+b\) (mod \(N\)), where `N` is the number of characters in the alphabet. Deciphering
    is done by reciphering with a new key: \(x \rightarrow cx+d\) (mod \(N\)), where
    \(c = a^{-1}\) (mod \(N\)) and \(d = -a^{-1}b\) (mod \(N\)).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`encipher_affine`](#sympy.crypto.crypto.encipher_affine "sympy.crypto.crypto.encipher_affine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Enciphers a given `msg` into its Atbash ciphertext and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Atbash is a substitution cipher originally used to encrypt the Hebrew alphabet.
    Atbash works on the principle of mapping each alphabet to its reverse / counterpart
    (i.e. a would map to z, b to y etc.)
  prefs: []
  type: TYPE_NORMAL
- en: Atbash is functionally equivalent to the affine cipher with `a = 25` and `b
    = 25`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_atbash`](#sympy.crypto.crypto.decipher_atbash "sympy.crypto.crypto.decipher_atbash")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Deciphers a given `msg` using Atbash cipher and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`decipher_atbash` is functionally equivalent to `encipher_atbash`. However,
    it has still been added as a separate function to maintain consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`encipher_atbash`](#sympy.crypto.crypto.encipher_atbash "sympy.crypto.crypto.encipher_atbash")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R155](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Atbash](https://en.wikipedia.org/wiki/Atbash)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Returns the ciphertext obtained by replacing each character that appears in
    `old` with the corresponding character in `new`. If `old` is a mapping, then new
    is ignored and the replacements defined by `old` are used.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is a more general than the affine cipher in that the key can only be recovered
    by determining the mapping for each symbol. Though in practice, once a few symbols
    are recognized the mappings for other characters can be quickly guessed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt a substitution, reverse the last two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the special case where `old` and `new` are a permutation of order 2 (representing
    a transposition of characters) their order is immaterial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The substitution cipher, in general, is a method whereby “units” (not necessarily
    single characters) of plaintext are replaced with ciphertext according to a regular
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R156](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Substitution_cipher](https://en.wikipedia.org/wiki/Substitution_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Vigenere cipher encryption on plaintext `msg`, and returns the
    ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Section 1 of the Kryptos sculpture at the CIA headquarters uses this cipher
    and also changes the order of the alphabet [[R158]](#r158). Here is the first
    line of that section of the sculpture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Vigenere cipher is named after Blaise de Vigenere, a sixteenth century diplomat
    and cryptographer, by a historical accident. Vigenere actually invented a different
    and more complicated cipher. The so-called *Vigenere cipher* was actually invented
    by Giovan Batista Belaso in 1553.
  prefs: []
  type: TYPE_NORMAL
- en: This cipher was used in the 1800’s, for example, during the American Civil War.
    The Confederacy used a brass cipher disk to implement the Vigenere cipher (now
    on display in the NSA Museum in Fort Meade) [[R157]](#r157).
  prefs: []
  type: TYPE_NORMAL
- en: The Vigenere cipher is a generalization of the shift cipher. Whereas the shift
    cipher shifts each letter by the same amount (that amount being the key of the
    shift cipher) the Vigenere cipher shifts a letter by an amount determined by the
    key (which is a word or phrase known only to the sender and receiver).
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the key was a single letter, such as “C”, then the so-called
    Vigenere cipher is actually a shift cipher with a shift of \(2\) (since “C” is
    the 2nd letter of the alphabet, if you start counting at \(0\)). If the key was
    a word with two letters, such as “CA”, then the so-called Vigenere cipher will
    shift letters in even positions by \(2\) and letters in odd positions are left
    alone (shifted by \(0\), since “A” is the 0th letter, if you start counting at
    \(0\)).
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'INPUT:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`msg`: string of characters that appear in `symbols` (the plaintext)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`key`: a string of characters that appear in `symbols` (the secret key)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`symbols`: a string of letters defining the alphabet'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OUTPUT:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ct`: string of characters (the ciphertext message)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `key` a list `L1` of corresponding integers. Let `n1
    = len(L1)`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L2` of corresponding integers. Let `n2
    = len(L2)`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Break `L2` up sequentially into sublists of size `n1`; the last sublist may
    be smaller than `n1`
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For each of these sublists `L` of `L2`, compute a new list `C` given by `C[i]
    = L[i] + L1[i] (mod N)` to the `i`-th element in the sublist, for each `i`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Assemble these lists `C` by concatenation into a new list of length `n2`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the new list a string `ct` of corresponding letters.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it is known that the key is, say, \(n\) characters long, frequency analysis
    can be applied to every \(n\)-th letter of the ciphertext to determine the plaintext.
    This method is called *Kasiski examination* (although it was first discovered
    by Babbage). If they key is as long as the message and is comprised of randomly
    selected characters – a one-time pad – the message is theoretically unbreakable.
  prefs: []
  type: TYPE_NORMAL
- en: The cipher Vigenere actually discovered is an “auto-key” cipher described as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'INPUT:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`key`: a string of letters (the secret key)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`msg`: string of letters (the plaintext message)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OUTPUT:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ct`: string of upper-case letters (the ciphertext message)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L2` of corresponding integers. Let `n2
    = len(L2)`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `n1` be the length of the key. Append to the string `key` the first `n2
    - n1` characters of the plaintext message. Compute from this string (also of length
    `n2`) a list `L1` of integers corresponding to the letter numbers in the first
    step.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute a new list `C` given by `C[i] = L1[i] + L2[i] (mod N)`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the new list a string `ct` of letters corresponding to the new
    integers.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To decipher the auto-key ciphertext, the key is used to decipher the first
    `n1` characters and then those characters become the key to decipher the next
    `n1` characters, etc…:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R157] ([1](#id9),[2](#id10))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Vigenere_cipher](https://en.wikipedia.org/wiki/Vigenere_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R158] ([1](#id8),[2](#id11))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html](https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html)
    (short URL: [https://goo.gl/ijr22d](https://goo.gl/ijr22d))'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Decode using the Vigenere cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return the Hill cipher encryption of `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext message of \(n\) upper-case letters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: A \(k \times k\) invertible matrix \(K\), all of whose entries are in \(Z_{26}\)
    (or whatever number of symbols are being used).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**pad**'
  prefs: []
  type: TYPE_NORMAL
- en: Character (default “Q”) to use to make length of text be a multiple of `k`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: ct
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext of upper-case letters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Hill cipher [[R159]](#r159), invented by Lester S. Hill in the 1920’s [[R160]](#r160),
    was the first polygraphic cipher in which it was practical (though barely) to
    operate on more than three symbols at once. The following discussion assumes an
    elementary knowledge of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, each letter is first encoded as a number starting with 0. Suppose your
    message \(msg\) consists of \(n\) capital letters, with no spaces. This may be
    regarded an \(n\)-tuple M of elements of \(Z_{26}\) (if the letters are those
    of the English alphabet). A key in the Hill cipher is a \(k x k\) matrix \(K\),
    all of whose entries are in \(Z_{26}\), such that the matrix \(K\) is invertible
    (i.e., the linear transformation \(K: Z_{N}^k \rightarrow Z_{N}^k\) is one-to-one).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L` of corresponding integers. Let `n =
    len(L)`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Break the list `L` up into `t = ceiling(n/k)` sublists `L_1`, …, `L_t` of size
    `k` (with the last list “padded” to ensure its size is `k`).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute new list `C_1`, …, `C_t` given by `C[i] = K*L_i` (arithmetic is done
    mod N), for each `i`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Concatenate these into a list `C = C_1 + ... + C_t`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from `C` a string `ct` of corresponding letters. This has length `k*t`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_hill`](#sympy.crypto.crypto.decipher_hill "sympy.crypto.crypto.decipher_hill")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R159] ([1](#id12),[2](#id14))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Hill_cipher](https://en.wikipedia.org/wiki/Hill_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[R160] ([1](#id13),[2](#id15))'
  prefs: []
  type: TYPE_NORMAL
- en: Lester S. Hill, Cryptography in an Algebraic Alphabet, The American Mathematical
    Monthly Vol.36, June-July 1929, pp.306-312.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Deciphering is the same as enciphering but using the inverse of the key matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When the length of the plaintext (stripped of invalid characters) is not a multiple
    of the key dimension, extra characters will appear at the end of the enciphered
    and deciphered text. In order to decipher the text, those characters must be included
    in the text to be deciphered. In the following, the key has a dimension of 4 but
    the text is 2 short of being a multiple of 4 so two characters will be added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If the last two characters of the ciphertext were ignored in either case, the
    wrong plaintext would be recovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`encipher_hill`](#sympy.crypto.crypto.encipher_hill "sympy.crypto.crypto.encipher_hill")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses an \(n \times n\) Polybius
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duplicate characters are ignored and then it is padded with the characters in
    `symbols` that were not in the short key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: \(n \times n\) characters defining the alphabet.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (default is string.printable)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext using Bifid5 cipher without spaces.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_bifid`](#sympy.crypto.crypto.decipher_bifid "sympy.crypto.crypto.decipher_bifid"),
    [`encipher_bifid5`](#sympy.crypto.crypto.encipher_bifid5 "sympy.crypto.crypto.encipher_bifid5"),
    [`encipher_bifid6`](#sympy.crypto.crypto.encipher_bifid6 "sympy.crypto.crypto.encipher_bifid6")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R161](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bifid_cipher](https://en.wikipedia.org/wiki/Bifid_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Bifid cipher decryption on ciphertext `msg`, and returns the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses the \(n \times n\) Polybius
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duplicate characters are ignored and then it is padded with the characters in
    symbols that were not in the short key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols**'
  prefs: []
  type: TYPE_NORMAL
- en: \(n \times n\) characters defining the alphabet.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (default=string.printable, a \(10 \times 10\) matrix)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: deciphered
  prefs: []
  type: TYPE_NORMAL
- en: Deciphered text.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Do an encryption using the bifid5 alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When entering the text or ciphertext, spaces are ignored so it can be formatted
    as desired. Re-entering the ciphertext from the preceding, putting 4 characters
    per line and padding with an extra J, does not cause problems for the deciphering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When no alphabet is given, all 100 printable characters will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is changed, a different encryption is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the key used to decrypt the message is not exact, the original text
    will not be perfectly obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 5x5 Polybius square.
  prefs: []
  type: TYPE_NORMAL
- en: Produce the Polybius square for the \(5 \times 5\) Bifid cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg** : str'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Converted to upper case and filtered of anything but all letters except J.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key; non-alphabetic letters, J and duplicated characters are
    ignored and then, if the length is less than 25 characters, it is padded with
    other letters of the alphabet (in alphabetical order).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: ct
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext (all caps, no spaces).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses the \(5 \times 5\) Polybius
    square. The letter “J” is ignored so it must be replaced with something else (traditionally
    an “I”) before encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'ALGORITHM: (5x5 case)'
  prefs: []
  type: TYPE_NORMAL
- en: 'STEPS:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create the \(5 \times 5\) Polybius square `S` associated to `key` as follows:'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: moving from left-to-right, top-to-bottom, place the letters of the key into
    a \(5 \times 5\) matrix,
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: if the key has less than 25 letters, add the letters of the alphabet not in
    the key until the \(5 \times 5\) square is filled.
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a list `P` of pairs of numbers which are the coordinates in the Polybius
    square of the letters in `msg`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `L1` be the list of all first coordinates of `P` (length of `L1 = n`), let
    `L2` be the list of all second coordinates of `P` (so the length of `L2` is also
    `n`).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `L` be the concatenation of `L1` and `L2` (length `L = 2*n`), except that
    consecutive numbers are paired `(L[2*i], L[2*i + 1])`. You can regard `L` as a
    list of pairs of length `n`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `C` be the list of all letters which are of the form `S[i, j]`, for all
    `(i, j)` in `L`. As a string, this is the ciphertext of `msg`.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '“J” will be omitted unless it is replaced with something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The Bifid cipher was invented around 1901 by Felix Delastelle. It is a *fractional
    substitution* cipher, where letters are replaced by pairs of symbols from a smaller
    alphabet. The cipher uses a \(5 \times 5\) square filled with some ordering of
    the alphabet, except that “J” is replaced with “I” (this is a so-called Polybius
    square; there is a \(6 \times 6\) analog if you add back in “J” and also append
    onto the usual 26 letter alphabet, the digits 0, 1, …, 9). According to Helen
    Gaines’ book *Cryptanalysis*, this type of cipher was used in the field by the
    German Army during World War I.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_bifid5`](#sympy.crypto.crypto.decipher_bifid5 "sympy.crypto.crypto.decipher_bifid5"),
    [`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid "sympy.crypto.crypto.encipher_bifid")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Return the Bifid cipher decryption of `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key; duplicated characters are ignored and if the length is
    less then 25 characters, it will be padded with other letters from the alphabet
    omitting “J”. Non-alphabetic characters are ignored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: plaintext
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext from Bifid5 cipher (all caps, no spaces).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses the \(5 \times 5\) Polybius
    square; the letter “J” is ignored unless a `key` of length 25 is used.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses the \(6 \times 6\) Polybius
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext string (digits okay).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key (digits okay).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `key` is less than 36 characters long, the square will be filled with letters
    A through Z and digits 0 through 9.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: ciphertext
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext from Bifid cipher (all caps, no spaces).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`decipher_bifid6`](#sympy.crypto.crypto.decipher_bifid6 "sympy.crypto.crypto.decipher_bifid6"),
    [`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid "sympy.crypto.crypto.encipher_bifid")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Performs the Bifid cipher decryption on ciphertext `msg`, and returns the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: This is the version of the Bifid cipher that uses the \(6 \times 6\) Polybius
    square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: Ciphertext string (digits okay); converted to upper case
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Short string for key (digits okay).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `key` is less than 36 characters long, the square will be filled with letters
    A through Z and digits 0 through 9. All letters are converted to uppercase.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: plaintext
  prefs: []
  type: TYPE_NORMAL
- en: Plaintext from Bifid cipher (all caps, no spaces).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 6x6 Polybius square.
  prefs: []
  type: TYPE_NORMAL
- en: Produces the Polybius square for the \(6 \times 6\) Bifid cipher. Assumes alphabet
    of symbols is “A”, …, “Z”, “0”, …, “9”.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Return the RSA *public key* pair, \((n, e)\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**args** : naturals'
  prefs: []
  type: TYPE_NORMAL
- en: If specified as \(p, q, e\) where \(p\) and \(q\) are distinct primes and \(e\)
    is a desired public exponent of the RSA, \(n = p q\) and \(e\) will be verified
    against the totient \(\phi(n)\) (Euler totient) or \(\lambda(n)\) (Carmichael
    totient) to be \(\gcd(e, \phi(n)) = 1\) or \(\gcd(e, \lambda(n)) = 1\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If specified as \(p_1, p_2, \dots, p_n, e\) where \(p_1, p_2, \dots, p_n\) are
    specified as primes, and \(e\) is specified as a desired public exponent of the
    RSA, it will be able to form a multi-prime RSA, which is a more generalized form
    of the popular 2-prime RSA.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can also be possible to form a single-prime RSA by specifying the argument
    as \(p, e\), which can be considered a trivial case of a multiprime RSA.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, it can be possible to form a multi-power RSA by specifying two
    or more pairs of the primes to be same. However, unlike the two-distinct prime
    RSA or multi-prime RSA, not every numbers in the complete residue system (\(\mathbb{Z}_n\))
    will be decryptable since the mapping \(\mathbb{Z}_{n} \rightarrow \mathbb{Z}_{n}\)
    will not be bijective. (Only except for the trivial case when \(e = 1\) or more
    generally,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[e \in \left \{ 1 + k \lambda(n) \mid k \in \mathbb{Z} \land k \geq 0 \right
    \}\]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: when RSA reduces to the identity.) However, the RSA can still be decryptable
    for the numbers in the reduced residue system (\(\mathbb{Z}_n^{\times}\)), since
    the mapping \(\mathbb{Z}_{n}^{\times} \rightarrow \mathbb{Z}_{n}^{\times}\) can
    still be bijective.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you pass a non-prime integer to the arguments \(p_1, p_2, \dots, p_n\), the
    particular number will be prime-factored and it will become either a multi-prime
    RSA or a multi-power RSA in its canonical form, depending on whether the product
    equals its radical or not. \(p_1 p_2 \dots p_n = \text{rad}(p_1 p_2 \dots p_n)\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**totient** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `'Euler'`, it uses Euler’s totient \(\phi(n)\) which is [`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") in SymPy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'Carmichael'`, it uses Carmichael’s totient \(\lambda(n)\) which is [`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") in SymPy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlike private key generation, this is a trivial keyword for public key generation
    because \(\gcd(e, \phi(n)) = 1 \iff \gcd(e, \lambda(n)) = 1\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**index** : nonnegative integer, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an arbitrary solution of a RSA public key at the index specified at
    \(0, 1, 2, \dots\). This parameter needs to be specified along with `totient='Carmichael'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similarly to the non-uniquenss of a RSA private key as described in the `index`
    parameter documentation in [`rsa_private_key()`](#sympy.crypto.crypto.rsa_private_key
    "sympy.crypto.crypto.rsa_private_key"), RSA public key is also not unique and
    there is an infinite number of RSA public exponents which can behave in the same
    manner.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From any given RSA public exponent \(e\), there are can be an another RSA public
    exponent \(e + k \lambda(n)\) where \(k\) is an integer, \(\lambda\) is a Carmichael’s
    totient function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, considering only the positive cases, there can be a principal solution
    of a RSA public exponent \(e_0\) in \(0 < e_0 < \lambda(n)\), and all the other
    solutions can be canonicalzed in a form of \(e_0 + k \lambda(n)\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`index` specifies the \(k\) notation to yield any possible value an RSA public
    key can have.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of computing any arbitrary RSA public key:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**multipower** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Any pair of non-distinct primes found in the RSA specification will restrict
    the domain of the cryptosystem, as noted in the explanation of the parameter `args`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SymPy RSA key generator may give a warning before dispatching it as a multi-power
    RSA, however, you can disable the warning if you pass `True` to this keyword.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(n, e)** : int, int'
  prefs: []
  type: TYPE_NORMAL
- en: \(n\) is a product of any arbitrary number of primes given as the argument.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(e\) is relatively prime (coprime) to the Euler totient \(\phi(n)\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: Returned if less than two arguments are given, or \(e\) is not relatively prime
    to the modulus.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'A public key of a two-prime RSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A public key of a multiprime RSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although the RSA can be generalized over any modulus \(n\), using two large
    primes had became the most popular specification because a product of two large
    primes is usually the hardest to factor relatively to the digits of \(n\) can
    have.
  prefs: []
  type: TYPE_NORMAL
- en: However, it may need further understanding of the time complexities of each
    prime-factoring algorithms to verify the claim.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsa_private_key`](#sympy.crypto.crypto.rsa_private_key "sympy.crypto.crypto.rsa_private_key"),
    [`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa"),
    [`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R162](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R163](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R164](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R165](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Return the RSA *private key* pair, \((n, d)\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**args** : naturals'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword is identical to the `args` in [`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key
    "sympy.crypto.crypto.rsa_public_key").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**totient** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `'Euler'`, it uses Euler’s totient convention \(\phi(n)\) which is [`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") in SymPy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'Carmichael'`, it uses Carmichael’s totient convention \(\lambda(n)\) which
    is [`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") in SymPy.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There can be some output differences for private key generation as examples
    below.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example using Euler’s totient:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example using Carmichael’s totient:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**index** : nonnegative integer, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an arbitrary solution of a RSA private key at the index specified at
    \(0, 1, 2, \dots\). This parameter needs to be specified along with `totient='Carmichael'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RSA private exponent is a non-unique solution of \(e d \mod \lambda(n) = 1\)
    and it is possible in any form of \(d + k \lambda(n)\), where \(d\) is an another
    already-computed private exponent, and \(\lambda\) is a Carmichael’s totient function,
    and \(k\) is any integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, considering only the positive cases, there can be a principal solution
    of a RSA private exponent \(d_0\) in \(0 < d_0 < \lambda(n)\), and all the other
    solutions can be canonicalzed in a form of \(d_0 + k \lambda(n)\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`index` specifies the \(k\) notation to yield any possible value an RSA private
    key can have.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of computing any arbitrary RSA private key:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**multipower** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword is identical to the `multipower` in [`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key
    "sympy.crypto.crypto.rsa_public_key").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(n, d)** : int, int'
  prefs: []
  type: TYPE_NORMAL
- en: \(n\) is a product of any arbitrary number of primes given as the argument.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(d\) is the inverse of \(e\) (mod \(\phi(n)\)) where \(e\) is the exponent
    given, and \(\phi\) is a Euler totient.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'False'
  prefs: []
  type: TYPE_NORMAL
- en: Returned if less than two arguments are given, or \(e\) is not relatively prime
    to the totient of the modulus.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A private key of a two-prime RSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A private key of a multiprime RSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsa_public_key`](#sympy.crypto.crypto.rsa_public_key "sympy.crypto.crypto.rsa_public_key"),
    [`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa"),
    [`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R166](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R167](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R168](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R169](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Encrypt the plaintext with RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: The plaintext to be encrypted for.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key** : (n, e) where n, e are integers'
  prefs: []
  type: TYPE_NORMAL
- en: \(n\) is the modulus of the key and \(e\) is the exponent of the key. The encryption
    is computed by \(i^e \bmod n\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key can either be a public key or a private key, however, the message encrypted
    by a public key can only be decrypted by a private key, and vice versa, as RSA
    is an asymmetric cryptography system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**factors** : list of coprime integers'
  prefs: []
  type: TYPE_NORMAL
- en: This is identical to the keyword `factors` in [`decipher_rsa()`](#sympy.crypto.crypto.decipher_rsa
    "sympy.crypto.crypto.decipher_rsa").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Some specifications may make the RSA not cryptographically meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: For example, \(0\), \(1\) will remain always same after taking any number of
    exponentiation, thus, should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if \(i^e < n\), \(i\) may easily be figured out by taking \(e\)
    th root.
  prefs: []
  type: TYPE_NORMAL
- en: And also, specifying the exponent as \(1\) or in more generalized form as \(1
    + k \lambda(n)\) where \(k\) is an nonnegative integer, \(\lambda\) is a carmichael
    totient, the RSA becomes an identity mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Public Key Encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Private Key Encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Encryption using chinese remainder theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Decrypt the ciphertext with RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : integer'
  prefs: []
  type: TYPE_NORMAL
- en: The ciphertext to be decrypted for.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key** : (n, d) where n, d are integers'
  prefs: []
  type: TYPE_NORMAL
- en: \(n\) is the modulus of the key and \(d\) is the exponent of the key. The decryption
    is computed by \(i^d \bmod n\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key can either be a public key or a private key, however, the message encrypted
    by a public key can only be decrypted by a private key, and vice versa, as RSA
    is an asymmetric cryptography system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**factors** : list of coprime integers'
  prefs: []
  type: TYPE_NORMAL
- en: As the modulus \(n\) created from RSA key generation is composed of arbitrary
    prime factors \(n = {p_1}^{k_1}{p_2}^{k_2}\dots{p_n}^{k_n}\) where \(p_1, p_2,
    \dots, p_n\) are distinct primes and \(k_1, k_2, \dots, k_n\) are positive integers,
    chinese remainder theorem can be used to compute \(i^d \bmod n\) from the fragmented
    modulo operations like
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[i^d \bmod {p_1}^{k_1}, i^d \bmod {p_2}^{k_2}, \dots, i^d \bmod {p_n}^{k_n}\]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: or like
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[i^d \bmod {p_1}^{k_1}{p_2}^{k_2}, i^d \bmod {p_3}^{k_3}, \dots , i^d \bmod
    {p_n}^{k_n}\]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: as long as every moduli does not share any common divisor each other.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The raw primes used in generating the RSA key pair can be a good option.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the speed advantage of using this is only viable for very large cases
    (Like 2048-bit RSA keys) since the overhead of using pure Python implementation
    of [`sympy.ntheory.modular.crt()`](ntheory.html#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")
    may overcompensate the theoretical speed advantage.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: See the `Notes` section in the documentation of [`encipher_rsa()`](#sympy.crypto.crypto.encipher_rsa
    "sympy.crypto.crypto.encipher_rsa")
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Public Key Encryption and Decryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Private Key Encryption and Decryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Decryption using chinese remainder theorem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Kid RSA is a version of RSA useful to teach grade school children since it does
    not involve exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice wants to talk to Bob. Bob generates keys as follows. Key generation:'
  prefs: []
  type: TYPE_NORMAL
- en: Select positive integers \(a, b, A, B\) at random.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1)//M\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *public key* is \((n, e)\). Bob sends these to Alice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *private key* is \((n, d)\), which Bob keeps secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encryption: If \(p\) is the plaintext message then the ciphertext is \(c =
    p e \pmod n\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption: If \(c\) is the ciphertext message then the plaintext is \(p =
    c d \pmod n\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Compute \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1) /
    M\). The *private key* is \(d\), which Bob keeps secret.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here `msg` is the plaintext and `key` is the public key.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here `msg` is the plaintext and `key` is the private key.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Encodes a plaintext into popular Morse Code with letters separated by `sep`
    and words by a double `sep`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R170](#id25)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Decodes a Morse Code with letters separated by `sep` (default is ‘|’) and words
    by \(word_sep\) (default is ‘||) into plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R171](#id26)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This function creates an LFSR sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key** : list'
  prefs: []
  type: TYPE_NORMAL
- en: A list of finite field elements, \([c_0, c_1, \ldots, c_k].\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fill** : list'
  prefs: []
  type: TYPE_NORMAL
- en: The list of the initial terms of the LFSR sequence, \([x_0, x_1, \ldots, x_k].\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of terms of the sequence that the function returns.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: L
  prefs: []
  type: TYPE_NORMAL
- en: The LFSR sequence defined by \(x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}\), for
    \(n \leq k\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: S. Golomb [[G171]](#g171) gives a list of three statistical properties a sequence
    of numbers \(a = \{a_n\}_{n=1}^\infty\), \(a_n \in \{0,1\}\), should display to
    be considered “random”. Define the autocorrelation of \(a\) to be
  prefs: []
  type: TYPE_NORMAL
- en: \[C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n
    + a_{n+k}}.\]
  prefs: []
  type: TYPE_NORMAL
- en: In the case where \(a\) is periodic with period \(P\) then this reduces to
  prefs: []
  type: TYPE_NORMAL
- en: \[C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.\]
  prefs: []
  type: TYPE_NORMAL
- en: Assume \(a\) is periodic with period \(P\).
  prefs: []
  type: TYPE_NORMAL
- en: 'balance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \[\left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.\]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'low autocorrelation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \[\begin{split}C(k) = \left\{ \begin{array}{cc} 1,& k = 0,\\ \epsilon, & k \ne
    0\. \end{array} \right.\end{split}\]
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: (For sequences satisfying these first two properties, it is known that \(\epsilon
    = -1/P\) must hold.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'proportional runs property: In each period, half the runs have length \(1\),
    one-fourth have length \(2\), etc. Moreover, there are as many runs of \(1\)’s
    as there are of \(0\)’s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[G171] ([1](#id27),[2](#id28))'
  prefs: []
  type: TYPE_NORMAL
- en: Solomon Golomb, Shift register sequences, Aegean Park Press, Laguna Hills, Ca,
    1967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This function computes the LFSR autocorrelation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**L**'
  prefs: []
  type: TYPE_NORMAL
- en: A periodic sequence of elements of \(GF(2)\). L must have length larger than
    P.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**P**'
  prefs: []
  type: TYPE_NORMAL
- en: The period of L.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**k** : int'
  prefs: []
  type: TYPE_NORMAL
- en: An integer \(k\) (\(0 < k < P\)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: autocorrelation
  prefs: []
  type: TYPE_NORMAL
- en: The k-th value of the autocorrelation of the LFSR L.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This function computes the LFSR connection polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of elements of even length, with entries in a finite field.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: C(x)
  prefs: []
  type: TYPE_NORMAL
- en: The connection polynomial of a minimal LFSR yielding s.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This implements the algorithm in section 3 of J. L. Massey’s article [[M172]](#m172).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[M172] ([1](#id29),[2](#id30))'
  prefs: []
  type: TYPE_NORMAL
- en: James L. Massey, “Shift-Register Synthesis and BCH Decoding.” IEEE Trans. on
    Information Theory, vol. 15(1), pp. 122-127, Jan 1969.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Return three number tuple as public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key** : (p, r, e)'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple generated by `elgamal_private_key`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (p, r, e)'
  prefs: []
  type: TYPE_NORMAL
- en: \(e = r**d \bmod p\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(d\) is a random number in private key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Return three number tuple as private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**digit** : int'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum number of binary digits for key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (p, r, d)'
  prefs: []
  type: TYPE_NORMAL
- en: p = prime number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r = primitive root.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d = random number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Elgamal encryption is based on the mathematical problem called the Discrete
    Logarithm Problem (DLP). For example,
  prefs: []
  type: TYPE_NORMAL
- en: \(a^{b} \equiv c \pmod p\)
  prefs: []
  type: TYPE_NORMAL
- en: In general, if `a` and `b` are known, `ct` is easily calculated. If `b` is unknown,
    it is hard to use `a` and `ct` to get `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Encrypt message with public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**msg**'
  prefs: []
  type: TYPE_NORMAL
- en: int of encoded message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key**'
  prefs: []
  type: TYPE_NORMAL
- en: Public key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (c1, c2)'
  prefs: []
  type: TYPE_NORMAL
- en: Encipher into two number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`i` is a plaintext message expressed as an integer. `key` is public key (p,
    r, e). In order to encrypt a message, a random number `a` in `range(2, p)` is
    generated and the encryped message is returned as \(c_{1}\) and \(c_{2}\) where:'
  prefs: []
  type: TYPE_NORMAL
- en: \(c_{1} \equiv r^{a} \pmod p\)
  prefs: []
  type: TYPE_NORMAL
- en: \(c_{2} \equiv m e^{a} \pmod p\)
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Decrypt message with private key.
  prefs: []
  type: TYPE_NORMAL
- en: \(msg = (c_{1}, c_{2})\)
  prefs: []
  type: TYPE_NORMAL
- en: \(key = (p, r, d)\)
  prefs: []
  type: TYPE_NORMAL
- en: According to extended Eucliden theorem, \(u c_{1}^{d} + p n = 1\)
  prefs: []
  type: TYPE_NORMAL
- en: \(u \equiv 1/{{c_{1}}^d} \pmod p\)
  prefs: []
  type: TYPE_NORMAL
- en: \(u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod
    p\)
  prefs: []
  type: TYPE_NORMAL
- en: \(\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod
    p\)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return three number tuple as public key.
  prefs: []
  type: TYPE_NORMAL
- en: This is the tuple that Alice sends to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key** : (p, g, a)'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple generated by `dh_private_key`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : int, int, int'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple of \((p, g, g^a \mod p)\) with \(p\), \(g\) and \(a\) given as parameters.s
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Return three integer tuple as private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**digit**'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum number of binary digits required in key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (p, g, a)'
  prefs: []
  type: TYPE_NORMAL
- en: p = prime number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: g = primitive root of p.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a = random number from 2 through p - 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Diffie-Hellman key exchange is based on the mathematical problem called the
    Discrete Logarithm Problem (see ElGamal).
  prefs: []
  type: TYPE_NORMAL
- en: 'Diffie-Hellman key exchange is divided into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob agree on a base that consist of a prime `p` and a primitive root
    of `p` called `g`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice choses a number `a` and Bob choses a number `b` where `a` and `b` are
    random numbers in range \([2, p)\). These are their private keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice then publicly sends Bob \(g^{a} \pmod p\) while Bob sends Alice \(g^{b}
    \pmod p\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They both raise the received value to their secretly chosen number (`a` or `b`)
    and now have both as their shared key \(g^{ab} \pmod p\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Return an integer that is the shared key.
  prefs: []
  type: TYPE_NORMAL
- en: This is what Bob and Alice can both calculate using the public keys they received
    from each other and their private keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**key** : (p, g, x)'
  prefs: []
  type: TYPE_NORMAL
- en: Tuple \((p, g, x)\) generated by `dh_public_key`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b**'
  prefs: []
  type: TYPE_NORMAL
- en: Random number in the range of \(2\) to \(p - 1\) (Chosen by second key exchange
    member (Bob)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: A shared key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Compute public keys for `p` and `q`. Note that in Goldwasser-Micali Encryption,
    public keys are randomly selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p, q, a** : int, int, int'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (a, N)'
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is the input `a` if it is not `None` otherwise some random integer coprime
    to `p` and `q`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`N` is the product of `p` and `q`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Check if `p` and `q` can be used as private keys for the Goldwasser-Micali encryption.
    The method works roughly as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p, q, a**'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**tuple** : (p, q)'
  prefs: []
  type: TYPE_NORMAL
- en: The input value `p` and `q`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `p` and `q` are not distinct odd primes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Pick two large primes \(p\) and \(q\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call their product \(N\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a message as an integer \(i\), write \(i\) in its bit representation \(b_0,
    \dots, b_n\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each \(k\),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'if \(b_k = 0\):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: let \(a_k\) be a random square (quadratic residue) modulo \(p q\) such that
    `jacobi_symbol(a, p*q) = 1`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if \(b_k = 1\):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: let \(a_k\) be a random non-square (non-quadratic residue) modulo \(p q\) such
    that `jacobi_symbol(a, p*q) = 1`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: returns \(\left[a_1, a_2, \dots\right]\)
  prefs: []
  type: TYPE_NORMAL
- en: \(b_k\) can be recovered by checking whether or not \(a_k\) is a residue. And
    from the \(b_k\)’s, the message can be reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that, while `jacobi_symbol(a, p*q)` can be easily computed (and
    when it is equal to \(-1\) will tell you that \(a\) is not a square mod \(p q\)),
    quadratic residuosity modulo a composite number is hard to compute without knowing
    its factorization.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, approximately half the numbers coprime to \(p q\) have [`jacobi_symbol()`](ntheory.html#sympy.ntheory.residue_ntheory.jacobi_symbol
    "sympy.ntheory.residue_ntheory.jacobi_symbol") equal to \(1\) . And among those,
    approximately half are residues and approximately half are not. This maximizes
    the entropy of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Encrypt integer ‘i’ using public_key ‘key’ Note that gm uses random encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The message to encrypt.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key** : (a, N)'
  prefs: []
  type: TYPE_NORMAL
- en: The public key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**list** : list of int'
  prefs: []
  type: TYPE_NORMAL
- en: The randomized encrypted message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Decrypt message ‘message’ using public_key ‘key’.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**message** : list of int'
  prefs: []
  type: TYPE_NORMAL
- en: The randomized encrypted message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**key** : (p, q)'
  prefs: []
  type: TYPE_NORMAL
- en: The private key.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: The encrypted message.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Performs Railfence Encryption on plaintext and returns ciphertext
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**message** : string, the message to encrypt.'
  prefs: []
  type: TYPE_NORMAL
- en: '**rails** : int, the number of rails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The Encrypted string message.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R174](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Decrypt the message using the given rails
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**message** : string, the message to encrypt.'
  prefs: []
  type: TYPE_NORMAL
- en: '**rails** : int, the number of rails.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The Decrypted string message.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
