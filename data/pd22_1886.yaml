- en: Extending pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展pandas
- en: 原文：[https://pandas.pydata.org/docs/development/extending.html](https://pandas.pydata.org/docs/development/extending.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pandas.pydata.org/docs/development/extending.html](https://pandas.pydata.org/docs/development/extending.html)
- en: While pandas provides a rich set of methods, containers, and data types, your
    needs may not be fully satisfied. pandas offers a few options for extending pandas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然pandas提供���丰富的方法、容器和数据类型，但您的需求可能无法完全满足。pandas提供了几种扩展pandas的选项。
- en: '## Registering custom accessors'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '## 注册自定义访问器'
- en: 'Libraries can use the decorators [`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor"), [`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor"), and [`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor"), to add additional “namespaces”
    to pandas objects. All of these follow a similar convention: you decorate a class,
    providing the name of attribute to add. The class’s `__init__` method gets the
    object being decorated. For example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以使用装饰器[`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor")、[`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor")和[`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor")，向pandas对象添加额外的“命名空间”。所有这些都遵循类似的约定：您装饰一个类，提供要添加的属性名称。类的`__init__`方法获取被装饰的对象。例如：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now users can access your methods using the `geo` namespace:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以使用`geo`命名空间访问您的方法：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This can be a convenient way to extend pandas objects without subclassing them.
    If you write a custom accessor, make a pull request adding it to our [ecosystem](https://pandas.pydata.org/community/ecosystem.html)
    page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一种方便的方式来扩展pandas对象，而无需对其进行子类化。如果您编写了自定义访问器，请发起拉取请求将其添加到我们的[生态系统](https://pandas.pydata.org/community/ecosystem.html)页面。
- en: 'We highly recommend validating the data in your accessor’s `__init__`. In our
    `GeoAccessor`, we validate that the data contains the expected columns, raising
    an `AttributeError` when the validation fails. For a `Series` accessor, you should
    validate the `dtype` if the accessor applies only to certain dtypes.  ## Extension
    types'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '我们强烈建议在访问器的`__init__`中验证数据。在我们的`GeoAccessor`中，我们验证数据是否包含预期的列，当验证失败时会引发`AttributeError`。对于`Series`访问器，如果访问器仅适用于特定的数据类型，应验证`dtype`。  ##
    扩展类型'
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") and [`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") APIs were experimental prior to pandas
    1.5\. Starting with version 1.5, future changes will follow the [pandas deprecation
    policy](policies.html#policies-version).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")和[`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")的API在pandas 1.5之前是实验性的。从版本1.5开始，未来的更改将遵循[pandas弃用政策](policies.html#policies-version)。'
- en: pandas defines an interface for implementing data types and arrays that *extend*
    NumPy’s type system. pandas itself uses the extension system for some types that
    aren’t built into NumPy (categorical, period, interval, datetime with timezone).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: pandas定义了一个接口，用于实现扩展NumPy类型系统的数据类型和数组。pandas本身使用扩展系统来处理一些不内置于NumPy中的类型（分类、周期、间隔、带时区的日期时间）。
- en: Libraries can define a custom array and data type. When pandas encounters these
    objects, they will be handled properly (i.e. not converted to an ndarray of objects).
    Many methods like [`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna") will dispatch to the extension type’s implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以定义自定义数组和数据类型。当pandas遇到这些对象时，它们将被正确处理（即不会转换为对象的ndarray）。许多方法，如[`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna")，将分派到扩展类型的实现。
- en: If you’re building a library that implements the interface, please publicize
    it on [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建实现该接口的库，请在 [生态系统页面](https://pandas.pydata.org/community/ecosystem.html)
    上宣传它。
- en: The interface consists of two classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接口由两个类组成。
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 类似于 `numpy.dtype` 对象。它描述了数据类型。实现者负责一些独特的项目，比如名称。'
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的一项是 `type` 属性。这应该是您数据的标量类型的类。例如，如果您正在为 IP 地址数据编写扩展数组，则可能是 `ipaddress.IPv4Address`。
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [扩展 dtype 源代码](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    以获取接口定义。
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 可以注册到 pandas 中，以允许通过字符串 dtype 名称进行创建。这允许使用注册的字符串名称实例化
    `Series` 和 `.astype()`，例如，`''category''` 是 `CategoricalDtype` 的注册字符串访问器。'
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [扩展 dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    以获取有关如何注册 dtypes 的更多信息。
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供了所有类似数组的功能。ExtensionArrays 限制为 1 维。ExtensionArray 通过 `dtype` 属性与 ExtensionDtype
    关联。
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 对通过其 `__new__` 或 `__init__` 创建扩展数组的方式没有限制，并且对如何存储数据也没有限制。我们要求您的数组可以转换为
    NumPy 数组，即使这可能相对昂贵（就像对于 `Categorical` 一样）。
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以由零个、一个或多个 NumPy 数组支持。例如，[`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") 是由两个数组支持的扩展数组，一个用于代码，一个用于类别。IPv6 地址数组可以由具有两个字段的 NumPy 结构化数组支持，一个用于低
    64 位，一个用于高 64 位。或者它们可以由其他某种存储类型支持，比如 Python 列表。
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [扩展数组源代码](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    以获取接口定义。文档字符串和注释包含有关正确实现接口的指导。
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") 运算符支持'
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")没有定义任何运算符。提供ExtensionArray运算符支持的两种方法：
- en: Define each of the operators on your `ExtensionArray` subclass.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`ExtensionArray`子类上定义每个运算符。
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个依赖于ExtensionArray的基础元素（标量）上已经定义的运算符的pandas中的运算符实现。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用哪种方法，如果希望在与NumPy数组进行二元运算时调用你的实现，可能需要设置`__array_priority__`。
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，你需要定义所选运算符，例如，`__add__`，`__le__`等，你希望你的`ExtensionArray`子类支持。
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法假设`ExtensionArray`的基础元素（即标量类型）已经定义了各自的运算符。换句话说，如果你的名为`MyExtensionArray`的`ExtensionArray`被实现为每个元素都是`MyExtensionElement`类的实例，那么如果为`MyExtensionElement`定义了运算符，第二种方法将自动为`MyExtensionArray`定义运算符。
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个混合类，`ExtensionScalarOpsMixin`支持这第二种方法。如果开发一个`ExtensionArray`子类，例如`MyExtensionArray`，只需将`ExtensionScalarOpsMixin`作为`MyExtensionArray`的父类之一，并调用方法`_add_arithmetic_ops()`和/或`_add_comparison_ops()`将运算符连接到你的`MyExtensionArray`类中，如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pandas`会自动逐个元素调用底层运算符，这可能不如直接在`ExtensionArray`上实现相关运算符的性能好。
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于算术运算，此实现将尝试使用元素级操作的结果重建一个新的`ExtensionArray`。是否成功取决于操作是否返回对`ExtensionArray`有效的结果。如果无法重建`ExtensionArray`，则返回包含返回标量的ndarray。
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便实现和与pandas和NumPy ndarray之间的操作一致性，我们建议*不*在你的二元运算中处理Series和Indexes。相反，你应该检测这些情况并返回`NotImplemented`。当pandas遇到像`op(Series,
    ExtensionArray)`这样的操作时，pandas会
- en: unbox the array from the `Series` (`Series.array`)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Series`中解包数组（`Series.array`）
- en: call `result = op(values, ExtensionArray)`
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`result = op(values, ExtensionArray)`
- en: 're-box the result in a `Series`  ### NumPy universal functions'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将结果重新封装在`Series`中  ### NumPy通用函数'
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")实现了`__array_ufunc__`。作为实现的一部分，pandas
    从 [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")中拆箱`ExtensionArray`，应用
    ufunc，并在必要时重新装箱。'
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，强烈建议您在扩展数组中实现`__array_ufunc__`，以避免强制转换为 ndarray。参见[NumPy文档](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)中的示例。
- en: 'As part of your implementation, we require that you defer to pandas when a
    pandas container ([`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")) is detected in `inputs`. If any of those is present, you should
    return `NotImplemented`. pandas will take care of unboxing the array from the
    container and re-calling the ufunc with the unwrapped input.  ### Testing extension
    arrays'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为您的实现的一部分，当在`inputs`中检测到 pandas 容器（[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")、[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")、[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")）时，我们要求您转交给 pandas。如果有任何一个存在，则应返回`NotImplemented`。pandas 将负责从容器中解包数组并重新调用
    ufunc，以解包输入。
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个测试套件，用于确保您的扩展数组满足预期的行为。要使用测试套件，您必须提供几个 pytest fixtures 并继承基本测试类。所需的 fixtures
    在[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py)中找到。
- en: 'To use a test, subclass it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用测试，必须对其进行子类化：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.  ### Compatibility with Apache Arrow'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)中查看所有可用测试的列表。###
    与Apache Arrow兼容性
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionArray`可以通过实现两个方法支持转换为/从`pyarrow`数组（因此支持例如序列化到 Parquet 文件格式）：`ExtensionArray.__arrow_array__`和`ExtensionDtype.__from_arrow__`。'
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionArray.__arrow_array__`确保`pyarrow`知道如何将特定的扩展数组转换为`pyarrow.Array`（即使作为
    pandas DataFrame 中的列包含）：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`ExtensionDtype.__from_arrow__`方法控制从 pyarrow 返回到 pandas ExtensionArray 的转换。该方法仅接收一个
    pyarrow `Array`或`ChunkedArray`作为参数，并且预期返回此dtype和传递值的适当pandas`ExtensionArray`：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Arrow文档](https://arrow.apache.org/docs/python/extending_types.html)中查看更多信息。
- en: 'Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.  ## Subclassing pandas data structures'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法已经为 pandas 中包含的可空整数和字符串扩展 dtype 实现，并确保与 pyarrow 和 Parquet 文件格式的往返。## 子类化
    pandas 数据结构
- en: Warning
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: There are some easier alternatives before considering subclassing `pandas` data
    structures.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑子类化 `pandas` 数据结构之前，有一些更简单的替代方案。
- en: Extensible method chains with [pipe](../user_guide/basics.html#basics-pipe)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[pipe](../user_guide/basics.html#basics-pipe)进行可扩展的方法链。
- en: Use *composition*. See [here](https://en.wikipedia.org/wiki/Composition_over_inheritance).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*组合*。参见[这里](https://en.wikipedia.org/wiki/Composition_over_inheritance)。
- en: Extending by [registering an accessor](#extending-register-accessors)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[注册访问器](#extending-register-accessors)进行扩展
- en: Extending by [extension type](#extending-extension-types)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[扩展类型](#extending-extension-types)扩展
- en: 'This section describes how to subclass `pandas` data structures to meet more
    specific needs. There are two points that need attention:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何对`pandas`数据结构进行子类化以满足更具体的需求。有两点需要注意：
- en: Override constructor properties.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖构造函数属性。
- en: Define original properties
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义原始属性
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a nice example in [geopandas](https://github.com/geopandas/geopandas)
    project.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[geopandas](https://github.com/geopandas/geopandas)项目中找到一个很好的例子。
- en: Override constructor properties
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖构造函数属性
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据结构都有几个*构造函数属性*，用于返回操作的结果作为一个新的数据结构。通过覆盖这些属性，你可以通过`pandas`数据操作保留子类。
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 子类上可以定义3种可能的构造函数属性：
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame/Series._constructor`：当一个操作结果与原始数据具有相同的维度时使用。'
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame._constructor_sliced`：当一个`DataFrame`（子类）操作结果应该是一个`Series`（子类）时使用。'
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series._constructor_expanddim`：当一个`Series`（子类）操作结果应该是一个`DataFrame`（子类）时使用，例如`Series.to_frame()`。'
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了如何定义`SubclassedSeries`和`SubclassedDataFrame`覆盖构造函数属性。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Define original properties
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义原始属性
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要让原始数据结构具有额外的属性，你应该让`pandas`知道添加了哪些属性。`pandas`将未知属性映射到数据名称，覆盖`__getattribute__`。定义原始属性可以通过以下两种方式之一完成：
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为临时属性定义`_internal_names`和`_internal_names_set`，这些属性不会传递给操作结果。
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为普通属性定义`_metadata`，这些属性将传递给操作结果。
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，定义了两个原始属性，“internal_cache”作为临时属性，以及“added_property”作为普通属性
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]  ## Plotting backends'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]## 绘图后端'
- en: 'pandas can be extended with third-party plotting backends. The main idea is
    letting users select a plotting backend different than the provided one based
    on Matplotlib. For example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: pandas可以通过第三方绘图后端进行扩展。主要思想是让用户选择一个基于Matplotlib提供的绘图后端之外的绘图后端。例如：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This would be more or less equivalent to:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更或多或少等同于：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The backend module can then use other visualization tools (Bokeh, Altair,…)
    to generate the plots.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 后端模块可以使用其他可视化工具（Bokeh、Altair等）来生成图表。
- en: Libraries implementing the plotting backend should use [entry points](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)
    to make their backend discoverable to pandas. The key is `"pandas_plotting_backends"`.
    For example, pandas registers the default “matplotlib” backend as follows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实现绘图后端的库应该使用[入口点](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)来使其后端对pandas可发现。关键是`"pandas_plotting_backends"`。例如，pandas将默认的“matplotlib”后端注册如下。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'More information on how to implement a third-party plotting backend can be
    found at [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1).  ##
    Arithmetic with 3rd party types'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现第三方绘图后端的更多信息，请参见[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1)。##
    与第三方类型的算术
- en: In order to control how arithmetic works between a custom type and a pandas
    type, implement `__pandas_priority__`. Similar to numpy’s `__array_priority__`
    semantics, arithmetic methods on [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") objects will delegate to `other`, if it has an attribute `__pandas_priority__`
    with a higher value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制自定义类型与 pandas 类型之间的算术操作方式，实现`__pandas_priority__`。类似于 numpy 的`__array_priority__`语义，[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")、[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")和[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")对象上的算术方法将委托给`other`，如果它具有较高值的`__pandas_priority__`属性。
- en: 'By default, pandas objects try to operate with other objects, even if they
    are not types known to pandas:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pandas 对象尝试与其他对象进行操作，即使它们不是 pandas 已知的类型：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the example above, if `[10, 20]` was a custom type that can be understood
    as a list, pandas objects will still operate with it in the same way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，如果`[10, 20]`是可以理解为列表的自定义类型，pandas 对象仍然会以相同的方式与其进行操作。
- en: In some cases, it is useful to delegate to the other type the operation. For
    example, consider I implement a custom list object, and I want the result of adding
    my custom list with a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") to be an instance of my list and not a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") as seen in the previous example. This is now possible by defining
    the `__pandas_priority__` attribute of my custom list, and setting it to a higher
    value, than the priority of the pandas objects I want to operate with.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将操作委托给另一种类型是有用的。例如，考虑我实现了一个自定义列表对象，并且我希望将我的自定义列表与 pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") 相加的结果是我的列表的一个实例，而不是前面示例中所见的 [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")。通过定义我自定义列表的`__pandas_priority__`属性，并将其设置为较高的值，比我想要与之进行操作的 pandas
    对象的优先级更高，现在可以实现这一点。
- en: The `__pandas_priority__` of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") are `4000`, `3000`, and `2000` respectively. The base `ExtensionArray.__pandas_priority__`
    is `1000`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")、[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")和[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")的`__pandas_priority__`分别为`4000`、`3000`和`2000`。基本的`ExtensionArray.__pandas_priority__`为`1000`。'
- en: '[PRE14]  ## Registering custom accessors'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]  ## 注册自定义访问器'
- en: 'Libraries can use the decorators [`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor"), [`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor"), and [`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor"), to add additional “namespaces”
    to pandas objects. All of these follow a similar convention: you decorate a class,
    providing the name of attribute to add. The class’s `__init__` method gets the
    object being decorated. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以使用装饰器[`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor")、[`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor")和[`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor")来为 pandas 对象添加额外的“命名空间”。所有这些都遵循类似的约定：您装饰一个类，提供要添加的属性名称。类的`__init__`方法获取被装饰的对象。例如：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now users can access your methods using the `geo` namespace:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以使用`geo`命名空间访问您的方法：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This can be a convenient way to extend pandas objects without subclassing them.
    If you write a custom accessor, make a pull request adding it to our [ecosystem](https://pandas.pydata.org/community/ecosystem.html)
    page.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一种方便的方法，用于扩展 pandas 对象而不是将它们子类化。如果您编写了一个自定义访问器，请提交一个拉取请求将其添加到我们的 [生态系统](https://pandas.pydata.org/community/ecosystem.html)
    页面。
- en: We highly recommend validating the data in your accessor’s `__init__`. In our
    `GeoAccessor`, we validate that the data contains the expected columns, raising
    an `AttributeError` when the validation fails. For a `Series` accessor, you should
    validate the `dtype` if the accessor applies only to certain dtypes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议在访问器的 `__init__` 中验证数据。在我们的 `GeoAccessor` 中，我们验证数据包含预期的列，当验证失败时引发 `AttributeError`。对于
    `Series` 访问器，如果访问器仅适用于某些 dtype，则应验证 `dtype`。
- en: '## Extension types'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '## 扩展类型'
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") and [`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") APIs were experimental prior to pandas
    1.5\. Starting with version 1.5, future changes will follow the [pandas deprecation
    policy](policies.html#policies-version).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 和 [`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") API 在 pandas 1.5 之前是实验性的。从 1.5 版本开始，未来的更改将遵循
    [pandas 弃用策略](policies.html#policies-version)。'
- en: pandas defines an interface for implementing data types and arrays that *extend*
    NumPy’s type system. pandas itself uses the extension system for some types that
    aren’t built into NumPy (categorical, period, interval, datetime with timezone).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 定义了一种接口，用于实现扩展 NumPy 的类型系统的数据类型和数组。pandas 本身使用扩展系统来处理一些不内置于 NumPy 中的类型（分类、周期、区间、带时区的日期时间）。
- en: Libraries can define a custom array and data type. When pandas encounters these
    objects, they will be handled properly (i.e. not converted to an ndarray of objects).
    Many methods like [`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna") will dispatch to the extension type’s implementation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 库可以定义自定义数组和数据类型。当 pandas 遇到这些对象时，它们将被正确处理（即不会转换为对象的 ndarray）。许多方法，如 [`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna")，将分派到扩展类型的实现。
- en: If you’re building a library that implements the interface, please publicize
    it on [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个实现该接口的库，请在 [生态系统页面](https://pandas.pydata.org/community/ecosystem.html)
    上宣传它。
- en: The interface consists of two classes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接口由两个类组成。
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 类似于一个 `numpy.dtype` 对象。它描述了数据类型。实现者负责一些唯一的项目，如名称。
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的一项是 `type` 属性。这应该是您数据的标量类型的类。例如，如果您正在为 IP 地址数据编写扩展数组，则可能是 `ipaddress.IPv4Address`。
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有关接口定义，请参阅 [扩展 dtype 源](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)。
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 可以注册到 pandas 中，以允许通过字符串 dtype 名称进行创建。这允许使用注册的字符串名称，例如`''category''`是`CategoricalDtype`的注册字符串访问器，来实例化`Series`和`.astype()`。'
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[扩展 dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)以获取有关如何注册
    dtypes 的更多信息。
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此类提供所有类似数组的功能。ExtensionArrays 限制为 1 维。通过`dtype`属性，ExtensionArray 与 ExtensionDtype
    相关联。
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 对通过其`__new__`或`__init__`创建扩展数组没有任何限制，并且不限制您存储数据的方式。我们要求您的数组可以转换为 NumPy
    数组，即使这可能相对昂贵（就像`Categorical`一样）。
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以由零个、一个或多个 NumPy 数组支持。例如，[`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical")是由两个数组支持的扩展数组，一个用于代码，一个用于类别。一个 IPv6 地址数组可以由一个具有两个字段的 NumPy
    结构化数组支持，一个用于低 64 位，一个用于高 64 位。或者它们可以由其他存储类型支持，比如 Python 列表。
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[扩展数组源代码](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)以获取接口定义。文档字符串和注释包含了正确实现接口的指导。
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") 操作符支持'
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")没有定义任何操作符。提供 ExtensionArray 操作符支持有两种方法：
- en: Define each of the operators on your `ExtensionArray` subclass.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`ExtensionArray`子类上定义每个操作符。
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 中依赖于底层元素（标量）已定义的操作符的操作符实现。
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采取哪种方法，如果希望在与 NumPy 数组进行二进制操作时调用您的实现，可能需要设置`__array_priority__`。
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，您需要定义所选操作符，例如`__add__`，`__le__`等，以便您的`ExtensionArray`子类支持。
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法假设`ExtensionArray`的底层元素（即标量类型）已经定义了各个运算符。换句话说，如果你的`ExtensionArray`命名为`MyExtensionArray`，并且每个元素都是`MyExtensionElement`类的一个实例，那么如果为`MyExtensionElement`定义了运算符，第二种方法将自动为`MyExtensionArray`定义运算符。
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个混合类，`ExtensionScalarOpsMixin`支持这第二种方法。如果开发一个`ExtensionArray`子类，例如`MyExtensionArray`，只需将`ExtensionScalarOpsMixin`包含为`MyExtensionArray`的父类，并调用方法`_add_arithmetic_ops()`和/或`_add_comparison_ops()`将运算符挂接到你的`MyExtensionArray`类中，如下所示：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pandas`自动逐个调用每个元素上的底层运算符，这可能不如直接在`ExtensionArray`上实现相关运算符的版本性能好。
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于算术运算，这个实现将尝试用逐元素操作的结果重构一个新的`ExtensionArray`。是否成功取决于操作是否返回了对`ExtensionArray`有效的结果。如果无法重构`ExtensionArray`，则返回一个包含返回标量的
    ndarray。
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于实现并与 pandas 和 NumPy ndarrays 之间的操作保持一致，我们建议*不要*在二进制操作中处理 Series 和 Indexes。相反，你应该检测这些情况并返回`NotImplemented`。当
    pandas 遇到像`op(Series, ExtensionArray)`这样的操作时，pandas 将
- en: unbox the array from the `Series` (`Series.array`)
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Series`中解包数组（`Series.array`）
- en: call `result = op(values, ExtensionArray)`
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`result = op(values, ExtensionArray)`
- en: 're-box the result in a `Series`  ### NumPy universal functions'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`Series`中重新封装结果  ### NumPy 通用函数'
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")实现了`__array_ufunc__`。作为实现的一部分，pandas
    从[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")中解包`ExtensionArray`，应用
    ufunc，并在必要时重新封装它。'
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，我们强烈建议你在你的扩展数组中实现`__array_ufunc__`，以避免强制转换为 ndarray。请参阅[NumPy 文档](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)以获取示例。
- en: 'As part of your implementation, we require that you defer to pandas when a
    pandas container ([`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")) is detected in `inputs`. If any of those is present, you should
    return `NotImplemented`. pandas will take care of unboxing the array from the
    container and re-calling the ufunc with the unwrapped input.  ### Testing extension
    arrays'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '作为您实现的一部分，当检测到pandas容器（[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")、[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")、[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")）时，我们要求您将其推迟到pandas。如果其中任何一个存在，则应返回`NotImplemented`。pandas将负责从容器中解包数组并重新调用ufunc以获取未包装的输入。  ###
    测试扩展数组'
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个测试套件，用于确保您的扩展数组满足预期的行为。要使用测试套件，必须提供几个pytest fixtures并继承基础测试类。所需的固定装置在[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py)中找到。
- en: 'To use a test, subclass it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用测试，需要对其进行子类化：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.  ### Compatibility with Apache Arrow'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '参见[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)以获取所有可用测试的列表。  ###
    与Apache Arrow的兼容性'
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现两种方法，`ExtensionArray`可以支持与`pyarrow`数组的转换（因此支持例如序列化为Parquet文件格式）：`ExtensionArray.__arrow_array__`和`ExtensionDtype.__from_arrow__`。
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionArray.__arrow_array__`确保`pyarrow`知道如何将特定扩展数组转换为`pyarrow.Array`（即使作为pandas
    DataFrame中的列包含）：'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionDtype.__from_arrow__`方法然后控制了从pyarrow回到pandas ExtensionArray的转换。此方法仅接收一个pyarrow
    `Array`或`ChunkedArray`作为参数，并预期返回此dtype和传递值的适当pandas `ExtensionArray`：'
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 查看更多内容请参阅[Arrow文档](https://arrow.apache.org/docs/python/extending_types.html)。
- en: Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法已经为包含在pandas中的可空整数和字符串扩展dtype实现，并确保与pyarrow和Parquet文件格式的往返。
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")类似于`numpy.dtype`对象。它描述了数据类型。实现者需要负责一些独特的项目，如名称。'
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 特别重要的一项是`type`属性。这应该是您的数据的标量类型的类。例如，如果您正在为IP地址数据编写扩展数组，则可能是`ipaddress.IPv4Address`。
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[扩展dtype源](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)以获取接口定义。
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") 可以注册到 pandas 中，以允许通过字符串 dtype 名称进行创建。这允许使用注册的字符串名称实例化
    `Series` 和 `.astype()`，例如 `''category''` 是 `CategoricalDtype` 的注册字符串访问器。'
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [扩展 dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    以获取有关如何注册 dtypes 的更多信息。
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了所有类似数组的功能。ExtensionArrays 限制为 1 维。通过 `dtype` 属性，ExtensionArray 与 ExtensionDtype
    相关联。
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 对通过其 `__new__` 或 `__init__` 创建扩展数组没有任何限制，并且不对数据存储方式施加任何限制。我们要求您的数组可以转换为
    NumPy 数组，即使这可能相对昂贵（比如对于 `Categorical`）。
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以由零个、一个或多个 NumPy 数组支持。例如，[`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") 是由两个数组支持的扩展数组，一个用于代码，一个用于类别。一个 IPv6 地址数组可以由一个具有两个字段的 NumPy
    结构化数组支持，一个用于低 64 位，一个用于高 64 位。或者它们可以由其他存储类型支持，比如 Python 列表。
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [扩展数组源代码](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    以获取接口定义。文档字符串和注释包含了正确实现接口的指导。
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") 运算符支持'
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对于类 [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") 没有定义运算符。提供您的 ExtensionArray 运算符支持有两种方法：
- en: Define each of the operators on your `ExtensionArray` subclass.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `ExtensionArray` 子类上定义每个运算符。
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 pandas 中依赖于底层元素（标量）已定义的运算符的运算符实现。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用哪种方法，如果希望在与 NumPy 数组进行二元操作时调用您的实现，可能需要设置 `__array_priority__`。
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，您可以定义所选运算符，例如 `__add__`，`__le__` 等，您希望您的 `ExtensionArray` 子类支持。
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法假定`ExtensionArray`的基础元素（即标量类型）已经定义了各个运算符。换句话说，如果你的`ExtensionArray`名为`MyExtensionArray`，并且实现为每个元素都是`MyExtensionElement`类的实例，那么如果为`MyExtensionElement`定义了运算符，第二种方法将自动为`MyExtensionArray`定义运算符。
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类`ExtensionScalarOpsMixin`支持这种第二种方法。例如，如果开发一个`ExtensionArray`子类，比如`MyExtensionArray`，只需将`ExtensionScalarOpsMixin`包含为`MyExtensionArray`的父类，并调用方法`_add_arithmetic_ops()`和/或`_add_comparison_ops()`将运算符挂接到你的`MyExtensionArray`类中，如下所示：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pandas`自动逐个调用每个元素上的基础运算符，这可能不如直接在`ExtensionArray`上实现相关运算符的版本性能好。
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于算术运算，此实现将尝试使用元素级操作的结果重构一个新的`ExtensionArray`。是否成功取决于操作是否返回适用于`ExtensionArray`的结果。如果无法重建`ExtensionArray`，则返回包含返回标量的
    ndarray。
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便实现和与 pandas 和 NumPy ndarray 之间的操作一致，我们建议*不*在你的二进制运算中处理 Series 和 Indexes。相反，你应该检测这些情况并返回`NotImplemented`。当
    pandas 遇到类似`op(Series, ExtensionArray)`的操作时，pandas 将
- en: unbox the array from the `Series` (`Series.array`)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Series`（`Series.array`）中解封数组。
- en: call `result = op(values, ExtensionArray)`
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`result = op(values, ExtensionArray)`
- en: re-box the result in a `Series`
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Series`中重新装箱结果。
- en: '### NumPy universal functions'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '### NumPy 通用函数'
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")实现了`__array_ufunc__`。作为实现的一部分，pandas
    从[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")中解封`ExtensionArray`，应用
    ufunc，并在必要时重新装箱。'
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果适用，我们强烈建议你在扩展数组中实现`__array_ufunc__`以避免强制转换为 ndarray。参见[NumPy文档](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)中的示例。
- en: As part of your implementation, we require that you defer to pandas when a pandas
    container ([`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"),
    [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")) is
    detected in `inputs`. If any of those is present, you should return `NotImplemented`.
    pandas will take care of unboxing the array from the container and re-calling
    the ufunc with the unwrapped input.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为你实现的一部分，我们要求当在`inputs`中检测到一个 pandas 容器（[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")、[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")、[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")）时，你应该委托给 pandas。如果其中任何一个存在，你应该返回`NotImplemented`。pandas 将负责从容器中解封数组并重新调用
    ufunc。
- en: '### Testing extension arrays'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '### 测试扩展数组'
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为确保您的扩展数组满足预期行为提供了一个测试套件。要使用测试套件，您必须提供几个pytest固定装置并继承基本测试类。所需的固定装置可以在[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py)中找到。
- en: 'To use a test, subclass it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用测试，必须将其子类化：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 查看所有可用测试的列表，请参阅[pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)。
- en: '### Compatibility with Apache Arrow'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与Apache Arrow的兼容性'
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`ExtensionArray`可以通过实现两种方法来支持与`pyarrow`数组的转换（从而支持例如序列化为Parquet文件格式）：`ExtensionArray.__arrow_array__`
    和 `ExtensionDtype.__from_arrow__`。
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionArray.__arrow_array__` 确保 `pyarrow` 知道如何将特定的扩展数组转换为 `pyarrow.Array`（当作为pandas
    DataFrame中的列包含时也是如此）：'
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExtensionDtype.__from_arrow__` 方法然后控制从pyarrow到pandas ExtensionArray的转换。此方法接收一个pyarrow
    `Array`或`ChunkedArray`作为唯一参数，并期望返回适用于此dtype和传递的值的适当pandas `ExtensionArray`：'
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Arrow文档](https://arrow.apache.org/docs/python/extending_types.html)中了解更多信息。
- en: Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法已经针对pandas中包含的可空整数和字符串扩展dtype进行了实现，并确保与pyarrow和Parquet文件格式的往返。
- en: '## Subclassing pandas data structures'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '## 子类化 pandas 数据结构'
- en: Warning
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: There are some easier alternatives before considering subclassing `pandas` data
    structures.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑子类化`pandas`数据结构之前，有一些更简单的替代方法。
- en: Extensible method chains with [pipe](../user_guide/basics.html#basics-pipe)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[pipe](../user_guide/basics.html#basics-pipe)进行可扩展的方法链
- en: Use *composition*. See [here](https://en.wikipedia.org/wiki/Composition_over_inheritance).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*组合*。参见[此处](https://en.wikipedia.org/wiki/Composition_over_inheritance)。
- en: Extending by [registering an accessor](#extending-register-accessors)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[注册访问器](#extending-register-accessors)进行扩展
- en: Extending by [extension type](#extending-extension-types)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过[扩展类型](#extending-extension-types)进行扩展
- en: 'This section describes how to subclass `pandas` data structures to meet more
    specific needs. There are two points that need attention:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述如何对`pandas`数据结构进行子类化以满足更具体的需求。有两点需要注意：
- en: Override constructor properties.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖构造函数属性。
- en: Define original properties
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义原始属性
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a nice example in [geopandas](https://github.com/geopandas/geopandas)
    project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[geopandas](https://github.com/geopandas/geopandas)项目中找到一个很好的例子。
- en: Override constructor properties
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖构造函数属性
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据结构都有几个*构造函数属性*，用于返回作为操作结果的新数据结构。通过覆盖这些属性，您可以通过`pandas`数据操作保留子类。
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有3个可能需要在子类上定义的构造函数属性：
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame/Series._constructor`: 用于当操作结果与原始数据具有相同维度时。'
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame._constructor_sliced`: 用于当`DataFrame`（子类）操作的结果应该是一个`Series`（子类）时。'
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series._constructor_expanddim`: 用于当`Series`（子类）操作的结果应该是一个`DataFrame`（子类）时，例如`Series.to_frame()`。'
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何定义`SubclassedSeries`和`SubclassedDataFrame`，覆盖构造函数属性。
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Define original properties
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义原始属性
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要让原始数据结构具有额外属性，你应该让`pandas`知道添加了哪些属性。`pandas`将未知属性映射到数据名称，覆盖`__getattribute__`。定义原始属性可以通过以下两种方式之一完成：
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为临时属性定义`_internal_names`和`_internal_names_set`，这些属性**不会**传递给操作结果。
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将传递给操作结果的普通属性定义`_metadata`。
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，定义了两个原始属性，“internal_cache”作为临时属性，“added_property”作为普通属性
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Override constructor properties
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖构造函数属性
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据结构都有几个*构造函数属性*，用于返回操作结果的新数据结构。通过覆盖这些属性，你可以通过`pandas`数据操作保留子类。
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 子类上可以定义3种可能的构造函数属性：
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame/Series._constructor`：当操作结果与原始数据具有相同维度时使用。'
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataFrame._constructor_sliced`：当`DataFrame`（子类）操作结果应为`Series`（子类）时使用。'
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Series._constructor_expanddim`：当`Series`（子类）操作结果应为`DataFrame`（子类），例如`Series.to_frame()`时使用。'
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何定义`SubclassedSeries`和`SubclassedDataFrame`，覆盖构造函数属性。
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Define original properties
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义原始属性
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要让原始数据结构具有额外属性，你应该让`pandas`知道添加了哪些属性。`pandas`将未知属性映射到数据名称，覆盖`__getattribute__`。定义原始属性可以通过以下两种方式之一完成：
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为临时属性定义`_internal_names`和`_internal_names_set`，这些属性**不会**传递给操作结果。
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为将传递给操作结果的普通属性定义`_metadata`。
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，定义了两个原始属性，“internal_cache”作为临时属性，“added_property”作为普通属性
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '## Plotting backends'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '## 绘图后端'
- en: 'pandas can be extended with third-party plotting backends. The main idea is
    letting users select a plotting backend different than the provided one based
    on Matplotlib. For example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: pandas可以通过第三方绘图后端进行扩展。主要思想是让用户选择一个基于Matplotlib提供的绘图后端之外的绘图后端。例如：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This would be more or less equivalent to:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上等同于：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The backend module can then use other visualization tools (Bokeh, Altair,…)
    to generate the plots.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，后端模块可以使用其他可视化工具（Bokeh、Altair等）生成图表。
- en: Libraries implementing the plotting backend should use [entry points](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)
    to make their backend discoverable to pandas. The key is `"pandas_plotting_backends"`.
    For example, pandas registers the default “matplotlib” backend as follows.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实现绘图后端的库应该使用[入口点](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)来使其后端可被
    pandas 发现。关键是`"pandas_plotting_backends"`。例如，pandas将默认的“matplotlib”后端注册如下。
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: More information on how to implement a third-party plotting backend can be found
    at [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何实现第三方绘图后端的更多信息，请参阅 [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1)。
- en: '## Arithmetic with 3rd party types'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用第三方类型进行算术运算'
- en: In order to control how arithmetic works between a custom type and a pandas
    type, implement `__pandas_priority__`. Similar to numpy’s `__array_priority__`
    semantics, arithmetic methods on [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") objects will delegate to `other`, if it has an attribute `__pandas_priority__`
    with a higher value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制自定义类型与 pandas 类型之间的算术运算方式，请实现 `__pandas_priority__`。类似于 numpy 的 `__array_priority__`
    语义，[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")、[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") 和 [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    对象上的算术方法将委托给 `other`，如果它具有一个属性 `__pandas_priority__`，其值比较高。
- en: 'By default, pandas objects try to operate with other objects, even if they
    are not types known to pandas:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pandas 对象尝试与其他对象进行操作，即使它们不是 pandas 所知的类型：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the example above, if `[10, 20]` was a custom type that can be understood
    as a list, pandas objects will still operate with it in the same way.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，如果 `[10, 20]` 是一个可以被理解为列表的自定义类型，pandas 对象仍然会以相同的方式与其进行操作。
- en: In some cases, it is useful to delegate to the other type the operation. For
    example, consider I implement a custom list object, and I want the result of adding
    my custom list with a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") to be an instance of my list and not a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") as seen in the previous example. This is now possible by defining
    the `__pandas_priority__` attribute of my custom list, and setting it to a higher
    value, than the priority of the pandas objects I want to operate with.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将操作委托给另一种类型是有用的。例如，考虑我实现了一个自定义列表对象，我希望将我的自定义列表与pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") 相加的结果是我的列表的一个实例，而不是前面示例中看到的 [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")。通过定义我的自定义列表的 `__pandas_priority__` 属性，并将其设置为比我想要操作的 pandas 对象的优先级更高的值，现在可以实现这一点。
- en: The `__pandas_priority__` of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") are `4000`, `3000`, and `2000` respectively. The base `ExtensionArray.__pandas_priority__`
    is `1000`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")、[`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") 和 [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    的 `__pandas_priority__` 分别为 `4000`、`3000` 和 `2000`。基础的 `ExtensionArray.__pandas_priority__`
    是 `1000`。'
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
