["```py\n[[1., 0., 0.],\n [0., 1., 2.]] \n```", "```py\n>>> import numpy as np\n>>> a = np.arange(15).reshape(3, 5)\n>>> a\narray([[ 0,  1,  2,  3,  4],\n [ 5,  6,  7,  8,  9],\n [10, 11, 12, 13, 14]])\n>>> a.shape\n(3, 5)\n>>> a.ndim\n2\n>>> a.dtype.name\n'int64'\n>>> a.itemsize\n8\n>>> a.size\n15\n>>> type(a)\n<class 'numpy.ndarray'>\n>>> b = np.array([6, 7, 8])\n>>> b\narray([6, 7, 8])\n>>> type(b)\n<class 'numpy.ndarray'> \n```", "```py\n>>> import numpy as np\n>>> a = np.array([2, 3, 4])\n>>> a\narray([2, 3, 4])\n>>> a.dtype\ndtype('int64')\n>>> b = np.array([1.2, 3.5, 5.1])\n>>> b.dtype\ndtype('float64') \n```", "```py\n>>> a = np.array(1, 2, 3, 4)    # WRONG\nTraceback (most recent call last):\n  ...\nTypeError: array() takes from 1 to 2 positional arguments but 4 were given\n>>> a = np.array([1, 2, 3, 4])  # RIGHT \n```", "```py\n>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])\n>>> b\narray([[1.5, 2\\. , 3\\. ],\n [4\\. , 5\\. , 6\\. ]]) \n```", "```py\n>>> c = np.array([[1, 2], [3, 4]], dtype=complex)\n>>> c\narray([[1.+0.j, 2.+0.j],\n [3.+0.j, 4.+0.j]]) \n```", "```py\n>>> np.zeros((3, 4))\narray([[0., 0., 0., 0.],\n [0., 0., 0., 0.],\n [0., 0., 0., 0.]])\n>>> np.ones((2, 3, 4), dtype=np.int16)\narray([[[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]],\n\n [[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]]], dtype=int16)\n>>> np.empty((2, 3)) \narray([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],  # may vary\n [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) \n```", "```py\n>>> np.arange(10, 30, 5)\narray([10, 15, 20, 25])\n>>> np.arange(0, 2, 0.3)  # it accepts float arguments\narray([0\\. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) \n```", "```py\n>>> from numpy import pi\n>>> np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2\narray([0\\.  , 0.25, 0.5 , 0.75, 1\\.  , 1.25, 1.5 , 1.75, 2\\.  ])\n>>> x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points\n>>> f = np.sin(x) \n```", "```py\n>>> a = np.arange(6)                    # 1d array\n>>> print(a)\n[0 1 2 3 4 5]\n>>>\n>>> b = np.arange(12).reshape(4, 3)     # 2d array\n>>> print(b)\n[[ 0  1  2]\n [ 3  4  5]\n [ 6  7  8]\n [ 9 10 11]]\n>>>\n>>> c = np.arange(24).reshape(2, 3, 4)  # 3d array\n>>> print(c)\n[[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n [[12 13 14 15]\n [16 17 18 19]\n [20 21 22 23]]] \n```", "```py\n>>> print(np.arange(10000))\n[   0    1    2 ... 9997 9998 9999]\n>>>\n>>> print(np.arange(10000).reshape(100, 100))\n[[   0    1    2 ...   97   98   99]\n [ 100  101  102 ...  197  198  199]\n [ 200  201  202 ...  297  298  299]\n ...\n [9700 9701 9702 ... 9797 9798 9799]\n [9800 9801 9802 ... 9897 9898 9899]\n [9900 9901 9902 ... 9997 9998 9999]] \n```", "```py\n>>> np.set_printoptions(threshold=sys.maxsize)  # sys module should be imported \n```", "```py\n>>> a = np.array([20, 30, 40, 50])\n>>> b = np.arange(4)\n>>> b\narray([0, 1, 2, 3])\n>>> c = a - b\n>>> c\narray([20, 29, 38, 47])\n>>> b**2\narray([0, 1, 4, 9])\n>>> 10 * np.sin(a)\narray([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])\n>>> a < 35\narray([ True,  True, False, False]) \n```", "```py\n>>> A = np.array([[1, 1],\n...               [0, 1]])\n>>> B = np.array([[2, 0],\n...               [3, 4]])\n>>> A * B     # elementwise product\narray([[2, 0],\n [0, 4]])\n>>> A @ B     # matrix product\narray([[5, 4],\n [3, 4]])\n>>> A.dot(B)  # another matrix product\narray([[5, 4],\n [3, 4]]) \n```", "```py\n>>> rg = np.random.default_rng(1)  # create instance of default random number generator\n>>> a = np.ones((2, 3), dtype=int)\n>>> b = rg.random((2, 3))\n>>> a *= 3\n>>> a\narray([[3, 3, 3],\n [3, 3, 3]])\n>>> b += a\n>>> b\narray([[3.51182162, 3.9504637 , 3.14415961],\n [3.94864945, 3.31183145, 3.42332645]])\n>>> a += b  # b is not automatically converted to integer type\nTraceback (most recent call last):\n  ...\nnumpy.core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' \n```", "```py\n>>> a = np.ones(3, dtype=np.int32)\n>>> b = np.linspace(0, pi, 3)\n>>> b.dtype.name\n'float64'\n>>> c = a + b\n>>> c\narray([1\\.        , 2.57079633, 4.14159265])\n>>> c.dtype.name\n'float64'\n>>> d = np.exp(c * 1j)\n>>> d\narray([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,\n -0.54030231-0.84147098j])\n>>> d.dtype.name\n'complex128' \n```", "```py\n>>> a = rg.random((2, 3))\n>>> a\narray([[0.82770259, 0.40919914, 0.54959369],\n [0.02755911, 0.75351311, 0.53814331]])\n>>> a.sum()\n3.1057109529998157\n>>> a.min()\n0.027559113243068367\n>>> a.max()\n0.8277025938204418 \n```", "```py\n>>> b = np.arange(12).reshape(3, 4)\n>>> b\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> b.sum(axis=0)     # sum of each column\narray([12, 15, 18, 21])\n>>>\n>>> b.min(axis=1)     # min of each row\narray([0, 4, 8])\n>>>\n>>> b.cumsum(axis=1)  # cumulative sum along each row\narray([[ 0,  1,  3,  6],\n [ 4,  9, 15, 22],\n [ 8, 17, 27, 38]]) \n```", "```py\n>>> B = np.arange(3)\n>>> B\narray([0, 1, 2])\n>>> np.exp(B)\narray([1\\.        , 2.71828183, 7.3890561 ])\n>>> np.sqrt(B)\narray([0\\.        , 1\\.        , 1.41421356])\n>>> C = np.array([2., -1., 4.])\n>>> np.add(B, C)\narray([2., 0., 6.]) \n```", "```py\n>>> a = np.arange(10)**3\n>>> a\narray([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])\n>>> a[2]\n8\n>>> a[2:5]\narray([ 8, 27, 64])\n>>> # equivalent to a[0:6:2] = 1000;\n>>> # from start to position 6, exclusive, set every 2nd element to 1000\n>>> a[:6:2] = 1000\n>>> a\narray([1000,    1, 1000,   27, 1000,  125,  216,  343,  512,  729])\n>>> a[::-1]  # reversed a\narray([ 729,  512,  343,  216,  125, 1000,   27, 1000,    1, 1000])\n>>> for i in a:\n...     print(i**(1 / 3.))\n...\n9.999999999999998  # may vary\n1.0\n9.999999999999998\n3.0\n9.999999999999998\n4.999999999999999\n5.999999999999999\n6.999999999999999\n7.999999999999999\n8.999999999999998 \n```", "```py\n>>> def f(x, y):\n...     return 10 * x + y\n...\n>>> b = np.fromfunction(f, (5, 4), dtype=int)\n>>> b\narray([[ 0,  1,  2,  3],\n [10, 11, 12, 13],\n [20, 21, 22, 23],\n [30, 31, 32, 33],\n [40, 41, 42, 43]])\n>>> b[2, 3]\n23\n>>> b[0:5, 1]  # each row in the second column of b\narray([ 1, 11, 21, 31, 41])\n>>> b[:, 1]    # equivalent to the previous example\narray([ 1, 11, 21, 31, 41])\n>>> b[1:3, :]  # each column in the second and third row of b\narray([[10, 11, 12, 13],\n [20, 21, 22, 23]]) \n```", "```py\n>>> b[-1]   # the last row. Equivalent to b[-1, :]\narray([40, 41, 42, 43]) \n```", "```py\n>>> c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)\n...                [ 10, 12, 13]],\n...               [[100, 101, 102],\n...                [110, 112, 113]]])\n>>> c.shape\n(2, 2, 3)\n>>> c[1, ...]  # same as c[1, :, :] or c[1]\narray([[100, 101, 102],\n [110, 112, 113]])\n>>> c[..., 2]  # same as c[:, :, 2]\narray([[  2,  13],\n [102, 113]]) \n```", "```py\n>>> for row in b:\n...     print(row)\n...\n[0 1 2 3]\n[10 11 12 13]\n[20 21 22 23]\n[30 31 32 33]\n[40 41 42 43] \n```", "```py\n>>> for element in b.flat:\n...     print(element)\n...\n0\n1\n2\n3\n10\n11\n12\n13\n20\n21\n22\n23\n30\n31\n32\n33\n40\n41\n42\n43 \n```", "```py\n>>> a = np.floor(10 * rg.random((3, 4)))\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a.ravel()  # returns the array, flattened\narray([3., 7., 3., 4., 1., 4., 2., 2., 7., 2., 4., 9.])\n>>> a.reshape(6, 2)  # returns the array with a modified shape\narray([[3., 7.],\n [3., 4.],\n [1., 4.],\n [2., 2.],\n [7., 2.],\n [4., 9.]])\n>>> a.T  # returns the array, transposed\narray([[3., 1., 7.],\n [7., 4., 2.],\n [3., 2., 4.],\n [4., 2., 9.]])\n>>> a.T.shape\n(4, 3)\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.resize((2, 6))\n>>> a\narray([[3., 7., 3., 4., 1., 4.],\n [2., 2., 7., 2., 4., 9.]]) \n```", "```py\n>>> a.reshape(3, -1)\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 2)))\n>>> a\narray([[9., 7.],\n [5., 2.]])\n>>> b = np.floor(10 * rg.random((2, 2)))\n>>> b\narray([[1., 9.],\n [5., 1.]])\n>>> np.vstack((a, b))\narray([[9., 7.],\n [5., 2.],\n [1., 9.],\n [5., 1.]])\n>>> np.hstack((a, b))\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]]) \n```", "```py\n>>> from numpy import newaxis\n>>> np.column_stack((a, b))  # with 2D arrays\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]])\n>>> a = np.array([4., 2.])\n>>> b = np.array([3., 8.])\n>>> np.column_stack((a, b))  # returns a 2D array\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a, b))        # the result is different\narray([4., 2., 3., 8.])\n>>> a[:, newaxis]  # view `a` as a 2D column vector\narray([[4.],\n [2.]])\n>>> np.column_stack((a[:, newaxis], b[:, newaxis]))\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same\narray([[4., 3.],\n [2., 8.]]) \n```", "```py\n>>> np.column_stack is np.hstack\nFalse\n>>> np.row_stack is np.vstack\nTrue \n```", "```py\n>>> np.r_[1:4, 0, 4]\narray([1, 2, 3, 0, 4]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 12)))\n>>> a\narray([[6., 7., 6., 9., 0., 5., 4., 0., 6., 8., 5., 2.],\n [8., 5., 5., 7., 1., 8., 6., 7., 1., 8., 1., 0.]])\n>>> # Split `a` into 3\n>>> np.hsplit(a, 3)\n[array([[6., 7., 6., 9.],\n [8., 5., 5., 7.]]), array([[0., 5., 4., 0.],\n [1., 8., 6., 7.]]), array([[6., 8., 5., 2.],\n [1., 8., 1., 0.]])]\n>>> # Split `a` after the third and the fourth column\n>>> np.hsplit(a, (3, 4))\n[array([[6., 7., 6.],\n [8., 5., 5.]]), array([[9.],\n [7.]]), array([[0., 5., 4., 0., 6., 8., 5., 2.],\n [1., 8., 6., 7., 1., 8., 1., 0.]])] \n```", "```py\n>>> a = np.array([[ 0,  1,  2,  3],\n...               [ 4,  5,  6,  7],\n...               [ 8,  9, 10, 11]])\n>>> b = a            # no new object is created\n>>> b is a           # a and b are two names for the same ndarray object\nTrue \n```", "```py\n>>> def f(x):\n...     print(id(x))\n...\n>>> id(a)  # id is a unique identifier of an object \n148293216  # may vary\n>>> f(a)   \n148293216  # may vary \n```", "```py\n>>> c = a.view()\n>>> c is a\nFalse\n>>> c.base is a            # c is a view of the data owned by a\nTrue\n>>> c.flags.owndata\nFalse\n>>>\n>>> c = c.reshape((2, 6))  # a's shape doesn't change\n>>> a.shape\n(3, 4)\n>>> c[0, 4] = 1234         # a's data changes\n>>> a\narray([[   0,    1,    2,    3],\n [1234,    5,    6,    7],\n [   8,    9,   10,   11]]) \n```", "```py\n>>> s = a[:, 1:3]\n>>> s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> d = a.copy()  # a new array object with new data is created\n>>> d is a\nFalse\n>>> d.base is a  # d doesn't share anything with a\nFalse\n>>> d[0, 0] = 9999\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> a = np.arange(int(1e8))\n>>> b = a[:100].copy()\n>>> del a  # the memory of ``a`` can be released. \n```", "```py\n>>> a = np.arange(12)**2  # the first 12 square numbers\n>>> i = np.array([1, 1, 3, 8, 5])  # an array of indices\n>>> a[i]  # the elements of `a` at the positions `i`\narray([ 1,  1,  9, 64, 25])\n>>>\n>>> j = np.array([[3, 4], [9, 7]])  # a bidimensional array of indices\n>>> a[j]  # the same shape as `j`\narray([[ 9, 16],\n [81, 49]]) \n```", "```py\n>>> palette = np.array([[0, 0, 0],         # black\n...                     [255, 0, 0],       # red\n...                     [0, 255, 0],       # green\n...                     [0, 0, 255],       # blue\n...                     [255, 255, 255]])  # white\n>>> image = np.array([[0, 1, 2, 0],  # each value corresponds to a color in the palette\n...                   [0, 3, 4, 0]])\n>>> palette[image]  # the (2, 4, 3) color image\narray([[[  0,   0,   0],\n [255,   0,   0],\n [  0, 255,   0],\n [  0,   0,   0]],\n\n [[  0,   0,   0],\n [  0,   0, 255],\n [255, 255, 255],\n [  0,   0,   0]]]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>> i = np.array([[0, 1],  # indices for the first dim of `a`\n...               [1, 2]])\n>>> j = np.array([[2, 1],  # indices for the second dim\n...               [3, 3]])\n>>>\n>>> a[i, j]  # i and j must have equal shape\narray([[ 2,  5],\n [ 7, 11]])\n>>>\n>>> a[i, 2]\narray([[ 2,  6],\n [ 6, 10]])\n>>>\n>>> a[:, j]\narray([[[ 2,  1],\n [ 3,  3]],\n\n [[ 6,  5],\n [ 7,  7]],\n\n [[10,  9],\n [11, 11]]]) \n```", "```py\n>>> l = (i, j)\n>>> # equivalent to a[i, j]\n>>> a[l]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> s = np.array([i, j])\n>>> # not what we want\n>>> a[s]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: index 3 is out of bounds for axis 0 with size 3\n>>> # same as `a[i, j]`\n>>> a[tuple(s)]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> time = np.linspace(20, 145, 5)  # time scale\n>>> data = np.sin(np.arange(20)).reshape(5, 4)  # 4 time-dependent series\n>>> time\narray([ 20\\.  ,  51.25,  82.5 , 113.75, 145\\.  ])\n>>> data\narray([[ 0\\.        ,  0.84147098,  0.90929743,  0.14112001],\n [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],\n [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],\n [-0.53657292,  0.42016704,  0.99060736,  0.65028784],\n [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])\n>>> # index of the maxima for each series\n>>> ind = data.argmax(axis=0)\n>>> ind\narray([2, 0, 3, 1])\n>>> # times corresponding to the maxima\n>>> time_max = time[ind]\n>>>\n>>> data_max = data[ind, range(data.shape[1])]  # => data[ind[0], 0], data[ind[1], 1]...\n>>> time_max\narray([ 82.5 ,  20\\.  , 113.75,  51.25])\n>>> data_max\narray([0.98935825, 0.84147098, 0.99060736, 0.6569866 ])\n>>> np.all(data_max == data.max(axis=0))\nTrue \n```", "```py\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a[[1, 3, 4]] = 0\n>>> a\narray([0, 0, 2, 0, 0]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] = [1, 2, 3]\n>>> a\narray([2, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] += 1\n>>> a\narray([1, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b = a > 4\n>>> b  # `b` is a boolean with `a`'s shape\narray([[False, False, False, False],\n [False,  True,  True,  True],\n [ True,  True,  True,  True]])\n>>> a[b]  # 1d array with the selected elements\narray([ 5,  6,  7,  8,  9, 10, 11]) \n```", "```py\n>>> a[b] = 0  # All elements of `a` higher than 4 become 0\n>>> a\narray([[0, 1, 2, 3],\n [4, 0, 0, 0],\n [0, 0, 0, 0]]) \n```", "```py\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> def mandelbrot(h, w, maxit=20, r=2):\n...  \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\"\n...     x = np.linspace(-2.5, 1.5, 4*h+1)\n...     y = np.linspace(-1.5, 1.5, 3*w+1)\n...     A, B = np.meshgrid(x, y)\n...     C = A + B*1j\n...     z = np.zeros_like(C)\n...     divtime = maxit + np.zeros(z.shape, dtype=int)\n...\n...     for i in range(maxit):\n...         z = z**2 + C\n...         diverge = abs(z) > r                    # who is diverging\n...         div_now = diverge & (divtime == maxit)  # who is diverging now\n...         divtime[div_now] = i                    # note when\n...         z[diverge] = r                          # avoid diverging too much\n...\n...     return divtime\n>>> plt.clf()\n>>> plt.imshow(mandelbrot(400, 400)) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b1 = np.array([False, True, True])         # first dim selection\n>>> b2 = np.array([True, False, True, False])  # second dim selection\n>>>\n>>> a[b1, :]                                   # selecting rows\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[b1]                                      # same thing\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[:, b2]                                   # selecting columns\narray([[ 0,  2],\n [ 4,  6],\n [ 8, 10]])\n>>>\n>>> a[b1, b2]                                  # a weird thing to do\narray([ 4, 10]) \n```", "```py\n>>> a = np.array([2, 3, 4, 5])\n>>> b = np.array([8, 5, 4])\n>>> c = np.array([5, 4, 6, 8, 3])\n>>> ax, bx, cx = np.ix_(a, b, c)\n>>> ax\narray([[[2]],\n\n [[3]],\n\n [[4]],\n\n [[5]]])\n>>> bx\narray([[[8],\n [5],\n [4]]])\n>>> cx\narray([[[5, 4, 6, 8, 3]]])\n>>> ax.shape, bx.shape, cx.shape\n((4, 1, 1), (1, 3, 1), (1, 1, 5))\n>>> result = ax + bx * cx\n>>> result\narray([[[42, 34, 50, 66, 26],\n [27, 22, 32, 42, 17],\n [22, 18, 26, 34, 14]],\n\n [[43, 35, 51, 67, 27],\n [28, 23, 33, 43, 18],\n [23, 19, 27, 35, 15]],\n\n [[44, 36, 52, 68, 28],\n [29, 24, 34, 44, 19],\n [24, 20, 28, 36, 16]],\n\n [[45, 37, 53, 69, 29],\n [30, 25, 35, 45, 20],\n [25, 21, 29, 37, 17]]])\n>>> result[3, 2, 4]\n17\n>>> a[3] + b[2] * c[4]\n17 \n```", "```py\n>>> def ufunc_reduce(ufct, *vectors):\n...    vs = np.ix_(*vectors)\n...    r = ufct.identity\n...    for v in vs:\n...        r = ufct(r, v)\n...    return r \n```", "```py\n>>> ufunc_reduce(np.add, a, b, c)\narray([[[15, 14, 16, 18, 13],\n [12, 11, 13, 15, 10],\n [11, 10, 12, 14,  9]],\n\n [[16, 15, 17, 19, 14],\n [13, 12, 14, 16, 11],\n [12, 11, 13, 15, 10]],\n\n [[17, 16, 18, 20, 15],\n [14, 13, 15, 17, 12],\n [13, 12, 14, 16, 11]],\n\n [[18, 17, 19, 21, 16],\n [15, 14, 16, 18, 13],\n [14, 13, 15, 17, 12]]]) \n```", "```py\n>>> a = np.arange(30)\n>>> b = a.reshape((2, -1, 3))  # -1 means \"whatever is needed\"\n>>> b.shape\n(2, 5, 3)\n>>> b\narray([[[ 0,  1,  2],\n [ 3,  4,  5],\n [ 6,  7,  8],\n [ 9, 10, 11],\n [12, 13, 14]],\n\n [[15, 16, 17],\n [18, 19, 20],\n [21, 22, 23],\n [24, 25, 26],\n [27, 28, 29]]]) \n```", "```py\n>>> x = np.arange(0, 10, 2)\n>>> y = np.arange(5)\n>>> m = np.vstack([x, y])\n>>> m\narray([[0, 2, 4, 6, 8],\n [0, 1, 2, 3, 4]])\n>>> xy = np.hstack([x, y])\n>>> xy\narray([0, 2, 4, 6, 8, 0, 1, 2, 3, 4]) \n```", "```py\n>>> import numpy as np\n>>> rg = np.random.default_rng(1)\n>>> import matplotlib.pyplot as plt\n>>> # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2\n>>> mu, sigma = 2, 0.5\n>>> v = rg.normal(mu, sigma, 10000)\n>>> # Plot a normalized histogram with 50 bins\n>>> plt.hist(v, bins=50, density=True)       # matplotlib version (plot)\n(array...)\n>>> # Compute the histogram with numpy and then plot it\n>>> (n, bins) = np.histogram(v, bins=50, density=True)  # NumPy version (no plot)\n>>> plt.plot(.5 * (bins[1:] + bins[:-1]), n) \n```", "```py\n[[1., 0., 0.],\n [0., 1., 2.]] \n```", "```py\n>>> import numpy as np\n>>> a = np.arange(15).reshape(3, 5)\n>>> a\narray([[ 0,  1,  2,  3,  4],\n [ 5,  6,  7,  8,  9],\n [10, 11, 12, 13, 14]])\n>>> a.shape\n(3, 5)\n>>> a.ndim\n2\n>>> a.dtype.name\n'int64'\n>>> a.itemsize\n8\n>>> a.size\n15\n>>> type(a)\n<class 'numpy.ndarray'>\n>>> b = np.array([6, 7, 8])\n>>> b\narray([6, 7, 8])\n>>> type(b)\n<class 'numpy.ndarray'> \n```", "```py\n>>> import numpy as np\n>>> a = np.array([2, 3, 4])\n>>> a\narray([2, 3, 4])\n>>> a.dtype\ndtype('int64')\n>>> b = np.array([1.2, 3.5, 5.1])\n>>> b.dtype\ndtype('float64') \n```", "```py\n>>> a = np.array(1, 2, 3, 4)    # WRONG\nTraceback (most recent call last):\n  ...\nTypeError: array() takes from 1 to 2 positional arguments but 4 were given\n>>> a = np.array([1, 2, 3, 4])  # RIGHT \n```", "```py\n>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])\n>>> b\narray([[1.5, 2\\. , 3\\. ],\n [4\\. , 5\\. , 6\\. ]]) \n```", "```py\n>>> c = np.array([[1, 2], [3, 4]], dtype=complex)\n>>> c\narray([[1.+0.j, 2.+0.j],\n [3.+0.j, 4.+0.j]]) \n```", "```py\n>>> np.zeros((3, 4))\narray([[0., 0., 0., 0.],\n [0., 0., 0., 0.],\n [0., 0., 0., 0.]])\n>>> np.ones((2, 3, 4), dtype=np.int16)\narray([[[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]],\n\n [[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]]], dtype=int16)\n>>> np.empty((2, 3)) \narray([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],  # may vary\n [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) \n```", "```py\n>>> np.arange(10, 30, 5)\narray([10, 15, 20, 25])\n>>> np.arange(0, 2, 0.3)  # it accepts float arguments\narray([0\\. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) \n```", "```py\n>>> from numpy import pi\n>>> np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2\narray([0\\.  , 0.25, 0.5 , 0.75, 1\\.  , 1.25, 1.5 , 1.75, 2\\.  ])\n>>> x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points\n>>> f = np.sin(x) \n```", "```py\n>>> a = np.arange(6)                    # 1d array\n>>> print(a)\n[0 1 2 3 4 5]\n>>>\n>>> b = np.arange(12).reshape(4, 3)     # 2d array\n>>> print(b)\n[[ 0  1  2]\n [ 3  4  5]\n [ 6  7  8]\n [ 9 10 11]]\n>>>\n>>> c = np.arange(24).reshape(2, 3, 4)  # 3d array\n>>> print(c)\n[[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n [[12 13 14 15]\n [16 17 18 19]\n [20 21 22 23]]] \n```", "```py\n>>> print(np.arange(10000))\n[   0    1    2 ... 9997 9998 9999]\n>>>\n>>> print(np.arange(10000).reshape(100, 100))\n[[   0    1    2 ...   97   98   99]\n [ 100  101  102 ...  197  198  199]\n [ 200  201  202 ...  297  298  299]\n ...\n [9700 9701 9702 ... 9797 9798 9799]\n [9800 9801 9802 ... 9897 9898 9899]\n [9900 9901 9902 ... 9997 9998 9999]] \n```", "```py\n>>> np.set_printoptions(threshold=sys.maxsize)  # sys module should be imported \n```", "```py\n>>> a = np.array([20, 30, 40, 50])\n>>> b = np.arange(4)\n>>> b\narray([0, 1, 2, 3])\n>>> c = a - b\n>>> c\narray([20, 29, 38, 47])\n>>> b**2\narray([0, 1, 4, 9])\n>>> 10 * np.sin(a)\narray([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])\n>>> a < 35\narray([ True,  True, False, False]) \n```", "```py\n>>> A = np.array([[1, 1],\n...               [0, 1]])\n>>> B = np.array([[2, 0],\n...               [3, 4]])\n>>> A * B     # elementwise product\narray([[2, 0],\n [0, 4]])\n>>> A @ B     # matrix product\narray([[5, 4],\n [3, 4]])\n>>> A.dot(B)  # another matrix product\narray([[5, 4],\n [3, 4]]) \n```", "```py\n>>> rg = np.random.default_rng(1)  # create instance of default random number generator\n>>> a = np.ones((2, 3), dtype=int)\n>>> b = rg.random((2, 3))\n>>> a *= 3\n>>> a\narray([[3, 3, 3],\n [3, 3, 3]])\n>>> b += a\n>>> b\narray([[3.51182162, 3.9504637 , 3.14415961],\n [3.94864945, 3.31183145, 3.42332645]])\n>>> a += b  # b is not automatically converted to integer type\nTraceback (most recent call last):\n  ...\nnumpy.core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' \n```", "```py\n>>> a = np.ones(3, dtype=np.int32)\n>>> b = np.linspace(0, pi, 3)\n>>> b.dtype.name\n'float64'\n>>> c = a + b\n>>> c\narray([1\\.        , 2.57079633, 4.14159265])\n>>> c.dtype.name\n'float64'\n>>> d = np.exp(c * 1j)\n>>> d\narray([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,\n -0.54030231-0.84147098j])\n>>> d.dtype.name\n'complex128' \n```", "```py\n>>> a = rg.random((2, 3))\n>>> a\narray([[0.82770259, 0.40919914, 0.54959369],\n [0.02755911, 0.75351311, 0.53814331]])\n>>> a.sum()\n3.1057109529998157\n>>> a.min()\n0.027559113243068367\n>>> a.max()\n0.8277025938204418 \n```", "```py\n>>> b = np.arange(12).reshape(3, 4)\n>>> b\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> b.sum(axis=0)     # sum of each column\narray([12, 15, 18, 21])\n>>>\n>>> b.min(axis=1)     # min of each row\narray([0, 4, 8])\n>>>\n>>> b.cumsum(axis=1)  # cumulative sum along each row\narray([[ 0,  1,  3,  6],\n [ 4,  9, 15, 22],\n [ 8, 17, 27, 38]]) \n```", "```py\n>>> B = np.arange(3)\n>>> B\narray([0, 1, 2])\n>>> np.exp(B)\narray([1\\.        , 2.71828183, 7.3890561 ])\n>>> np.sqrt(B)\narray([0\\.        , 1\\.        , 1.41421356])\n>>> C = np.array([2., -1., 4.])\n>>> np.add(B, C)\narray([2., 0., 6.]) \n```", "```py\n>>> a = np.arange(10)**3\n>>> a\narray([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])\n>>> a[2]\n8\n>>> a[2:5]\narray([ 8, 27, 64])\n>>> # equivalent to a[0:6:2] = 1000;\n>>> # from start to position 6, exclusive, set every 2nd element to 1000\n>>> a[:6:2] = 1000\n>>> a\narray([1000,    1, 1000,   27, 1000,  125,  216,  343,  512,  729])\n>>> a[::-1]  # reversed a\narray([ 729,  512,  343,  216,  125, 1000,   27, 1000,    1, 1000])\n>>> for i in a:\n...     print(i**(1 / 3.))\n...\n9.999999999999998  # may vary\n1.0\n9.999999999999998\n3.0\n9.999999999999998\n4.999999999999999\n5.999999999999999\n6.999999999999999\n7.999999999999999\n8.999999999999998 \n```", "```py\n>>> def f(x, y):\n...     return 10 * x + y\n...\n>>> b = np.fromfunction(f, (5, 4), dtype=int)\n>>> b\narray([[ 0,  1,  2,  3],\n [10, 11, 12, 13],\n [20, 21, 22, 23],\n [30, 31, 32, 33],\n [40, 41, 42, 43]])\n>>> b[2, 3]\n23\n>>> b[0:5, 1]  # each row in the second column of b\narray([ 1, 11, 21, 31, 41])\n>>> b[:, 1]    # equivalent to the previous example\narray([ 1, 11, 21, 31, 41])\n>>> b[1:3, :]  # each column in the second and third row of b\narray([[10, 11, 12, 13],\n [20, 21, 22, 23]]) \n```", "```py\n>>> b[-1]   # the last row. Equivalent to b[-1, :]\narray([40, 41, 42, 43]) \n```", "```py\n>>> c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)\n...                [ 10, 12, 13]],\n...               [[100, 101, 102],\n...                [110, 112, 113]]])\n>>> c.shape\n(2, 2, 3)\n>>> c[1, ...]  # same as c[1, :, :] or c[1]\narray([[100, 101, 102],\n [110, 112, 113]])\n>>> c[..., 2]  # same as c[:, :, 2]\narray([[  2,  13],\n [102, 113]]) \n```", "```py\n>>> for row in b:\n...     print(row)\n...\n[0 1 2 3]\n[10 11 12 13]\n[20 21 22 23]\n[30 31 32 33]\n[40 41 42 43] \n```", "```py\n>>> for element in b.flat:\n...     print(element)\n...\n0\n1\n2\n3\n10\n11\n12\n13\n20\n21\n22\n23\n30\n31\n32\n33\n40\n41\n42\n43 \n```", "```py\n>>> import numpy as np\n>>> a = np.arange(15).reshape(3, 5)\n>>> a\narray([[ 0,  1,  2,  3,  4],\n [ 5,  6,  7,  8,  9],\n [10, 11, 12, 13, 14]])\n>>> a.shape\n(3, 5)\n>>> a.ndim\n2\n>>> a.dtype.name\n'int64'\n>>> a.itemsize\n8\n>>> a.size\n15\n>>> type(a)\n<class 'numpy.ndarray'>\n>>> b = np.array([6, 7, 8])\n>>> b\narray([6, 7, 8])\n>>> type(b)\n<class 'numpy.ndarray'> \n```", "```py\n>>> import numpy as np\n>>> a = np.array([2, 3, 4])\n>>> a\narray([2, 3, 4])\n>>> a.dtype\ndtype('int64')\n>>> b = np.array([1.2, 3.5, 5.1])\n>>> b.dtype\ndtype('float64') \n```", "```py\n>>> a = np.array(1, 2, 3, 4)    # WRONG\nTraceback (most recent call last):\n  ...\nTypeError: array() takes from 1 to 2 positional arguments but 4 were given\n>>> a = np.array([1, 2, 3, 4])  # RIGHT \n```", "```py\n>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])\n>>> b\narray([[1.5, 2\\. , 3\\. ],\n [4\\. , 5\\. , 6\\. ]]) \n```", "```py\n>>> c = np.array([[1, 2], [3, 4]], dtype=complex)\n>>> c\narray([[1.+0.j, 2.+0.j],\n [3.+0.j, 4.+0.j]]) \n```", "```py\n>>> np.zeros((3, 4))\narray([[0., 0., 0., 0.],\n [0., 0., 0., 0.],\n [0., 0., 0., 0.]])\n>>> np.ones((2, 3, 4), dtype=np.int16)\narray([[[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]],\n\n [[1, 1, 1, 1],\n [1, 1, 1, 1],\n [1, 1, 1, 1]]], dtype=int16)\n>>> np.empty((2, 3)) \narray([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],  # may vary\n [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]]) \n```", "```py\n>>> np.arange(10, 30, 5)\narray([10, 15, 20, 25])\n>>> np.arange(0, 2, 0.3)  # it accepts float arguments\narray([0\\. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) \n```", "```py\n>>> from numpy import pi\n>>> np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2\narray([0\\.  , 0.25, 0.5 , 0.75, 1\\.  , 1.25, 1.5 , 1.75, 2\\.  ])\n>>> x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points\n>>> f = np.sin(x) \n```", "```py\n>>> a = np.arange(6)                    # 1d array\n>>> print(a)\n[0 1 2 3 4 5]\n>>>\n>>> b = np.arange(12).reshape(4, 3)     # 2d array\n>>> print(b)\n[[ 0  1  2]\n [ 3  4  5]\n [ 6  7  8]\n [ 9 10 11]]\n>>>\n>>> c = np.arange(24).reshape(2, 3, 4)  # 3d array\n>>> print(c)\n[[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n\n [[12 13 14 15]\n [16 17 18 19]\n [20 21 22 23]]] \n```", "```py\n>>> print(np.arange(10000))\n[   0    1    2 ... 9997 9998 9999]\n>>>\n>>> print(np.arange(10000).reshape(100, 100))\n[[   0    1    2 ...   97   98   99]\n [ 100  101  102 ...  197  198  199]\n [ 200  201  202 ...  297  298  299]\n ...\n [9700 9701 9702 ... 9797 9798 9799]\n [9800 9801 9802 ... 9897 9898 9899]\n [9900 9901 9902 ... 9997 9998 9999]] \n```", "```py\n>>> np.set_printoptions(threshold=sys.maxsize)  # sys module should be imported \n```", "```py\n>>> a = np.array([20, 30, 40, 50])\n>>> b = np.arange(4)\n>>> b\narray([0, 1, 2, 3])\n>>> c = a - b\n>>> c\narray([20, 29, 38, 47])\n>>> b**2\narray([0, 1, 4, 9])\n>>> 10 * np.sin(a)\narray([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])\n>>> a < 35\narray([ True,  True, False, False]) \n```", "```py\n>>> A = np.array([[1, 1],\n...               [0, 1]])\n>>> B = np.array([[2, 0],\n...               [3, 4]])\n>>> A * B     # elementwise product\narray([[2, 0],\n [0, 4]])\n>>> A @ B     # matrix product\narray([[5, 4],\n [3, 4]])\n>>> A.dot(B)  # another matrix product\narray([[5, 4],\n [3, 4]]) \n```", "```py\n>>> rg = np.random.default_rng(1)  # create instance of default random number generator\n>>> a = np.ones((2, 3), dtype=int)\n>>> b = rg.random((2, 3))\n>>> a *= 3\n>>> a\narray([[3, 3, 3],\n [3, 3, 3]])\n>>> b += a\n>>> b\narray([[3.51182162, 3.9504637 , 3.14415961],\n [3.94864945, 3.31183145, 3.42332645]])\n>>> a += b  # b is not automatically converted to integer type\nTraceback (most recent call last):\n  ...\nnumpy.core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind' \n```", "```py\n>>> a = np.ones(3, dtype=np.int32)\n>>> b = np.linspace(0, pi, 3)\n>>> b.dtype.name\n'float64'\n>>> c = a + b\n>>> c\narray([1\\.        , 2.57079633, 4.14159265])\n>>> c.dtype.name\n'float64'\n>>> d = np.exp(c * 1j)\n>>> d\narray([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,\n -0.54030231-0.84147098j])\n>>> d.dtype.name\n'complex128' \n```", "```py\n>>> a = rg.random((2, 3))\n>>> a\narray([[0.82770259, 0.40919914, 0.54959369],\n [0.02755911, 0.75351311, 0.53814331]])\n>>> a.sum()\n3.1057109529998157\n>>> a.min()\n0.027559113243068367\n>>> a.max()\n0.8277025938204418 \n```", "```py\n>>> b = np.arange(12).reshape(3, 4)\n>>> b\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> b.sum(axis=0)     # sum of each column\narray([12, 15, 18, 21])\n>>>\n>>> b.min(axis=1)     # min of each row\narray([0, 4, 8])\n>>>\n>>> b.cumsum(axis=1)  # cumulative sum along each row\narray([[ 0,  1,  3,  6],\n [ 4,  9, 15, 22],\n [ 8, 17, 27, 38]]) \n```", "```py\n>>> B = np.arange(3)\n>>> B\narray([0, 1, 2])\n>>> np.exp(B)\narray([1\\.        , 2.71828183, 7.3890561 ])\n>>> np.sqrt(B)\narray([0\\.        , 1\\.        , 1.41421356])\n>>> C = np.array([2., -1., 4.])\n>>> np.add(B, C)\narray([2., 0., 6.]) \n```", "```py\n>>> a = np.arange(10)**3\n>>> a\narray([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])\n>>> a[2]\n8\n>>> a[2:5]\narray([ 8, 27, 64])\n>>> # equivalent to a[0:6:2] = 1000;\n>>> # from start to position 6, exclusive, set every 2nd element to 1000\n>>> a[:6:2] = 1000\n>>> a\narray([1000,    1, 1000,   27, 1000,  125,  216,  343,  512,  729])\n>>> a[::-1]  # reversed a\narray([ 729,  512,  343,  216,  125, 1000,   27, 1000,    1, 1000])\n>>> for i in a:\n...     print(i**(1 / 3.))\n...\n9.999999999999998  # may vary\n1.0\n9.999999999999998\n3.0\n9.999999999999998\n4.999999999999999\n5.999999999999999\n6.999999999999999\n7.999999999999999\n8.999999999999998 \n```", "```py\n>>> def f(x, y):\n...     return 10 * x + y\n...\n>>> b = np.fromfunction(f, (5, 4), dtype=int)\n>>> b\narray([[ 0,  1,  2,  3],\n [10, 11, 12, 13],\n [20, 21, 22, 23],\n [30, 31, 32, 33],\n [40, 41, 42, 43]])\n>>> b[2, 3]\n23\n>>> b[0:5, 1]  # each row in the second column of b\narray([ 1, 11, 21, 31, 41])\n>>> b[:, 1]    # equivalent to the previous example\narray([ 1, 11, 21, 31, 41])\n>>> b[1:3, :]  # each column in the second and third row of b\narray([[10, 11, 12, 13],\n [20, 21, 22, 23]]) \n```", "```py\n>>> b[-1]   # the last row. Equivalent to b[-1, :]\narray([40, 41, 42, 43]) \n```", "```py\n>>> c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)\n...                [ 10, 12, 13]],\n...               [[100, 101, 102],\n...                [110, 112, 113]]])\n>>> c.shape\n(2, 2, 3)\n>>> c[1, ...]  # same as c[1, :, :] or c[1]\narray([[100, 101, 102],\n [110, 112, 113]])\n>>> c[..., 2]  # same as c[:, :, 2]\narray([[  2,  13],\n [102, 113]]) \n```", "```py\n>>> for row in b:\n...     print(row)\n...\n[0 1 2 3]\n[10 11 12 13]\n[20 21 22 23]\n[30 31 32 33]\n[40 41 42 43] \n```", "```py\n>>> for element in b.flat:\n...     print(element)\n...\n0\n1\n2\n3\n10\n11\n12\n13\n20\n21\n22\n23\n30\n31\n32\n33\n40\n41\n42\n43 \n```", "```py\n>>> a = np.floor(10 * rg.random((3, 4)))\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a.ravel()  # returns the array, flattened\narray([3., 7., 3., 4., 1., 4., 2., 2., 7., 2., 4., 9.])\n>>> a.reshape(6, 2)  # returns the array with a modified shape\narray([[3., 7.],\n [3., 4.],\n [1., 4.],\n [2., 2.],\n [7., 2.],\n [4., 9.]])\n>>> a.T  # returns the array, transposed\narray([[3., 1., 7.],\n [7., 4., 2.],\n [3., 2., 4.],\n [4., 2., 9.]])\n>>> a.T.shape\n(4, 3)\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.resize((2, 6))\n>>> a\narray([[3., 7., 3., 4., 1., 4.],\n [2., 2., 7., 2., 4., 9.]]) \n```", "```py\n>>> a.reshape(3, -1)\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 2)))\n>>> a\narray([[9., 7.],\n [5., 2.]])\n>>> b = np.floor(10 * rg.random((2, 2)))\n>>> b\narray([[1., 9.],\n [5., 1.]])\n>>> np.vstack((a, b))\narray([[9., 7.],\n [5., 2.],\n [1., 9.],\n [5., 1.]])\n>>> np.hstack((a, b))\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]]) \n```", "```py\n>>> from numpy import newaxis\n>>> np.column_stack((a, b))  # with 2D arrays\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]])\n>>> a = np.array([4., 2.])\n>>> b = np.array([3., 8.])\n>>> np.column_stack((a, b))  # returns a 2D array\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a, b))        # the result is different\narray([4., 2., 3., 8.])\n>>> a[:, newaxis]  # view `a` as a 2D column vector\narray([[4.],\n [2.]])\n>>> np.column_stack((a[:, newaxis], b[:, newaxis]))\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same\narray([[4., 3.],\n [2., 8.]]) \n```", "```py\n>>> np.column_stack is np.hstack\nFalse\n>>> np.row_stack is np.vstack\nTrue \n```", "```py\n>>> np.r_[1:4, 0, 4]\narray([1, 2, 3, 0, 4]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 12)))\n>>> a\narray([[6., 7., 6., 9., 0., 5., 4., 0., 6., 8., 5., 2.],\n [8., 5., 5., 7., 1., 8., 6., 7., 1., 8., 1., 0.]])\n>>> # Split `a` into 3\n>>> np.hsplit(a, 3)\n[array([[6., 7., 6., 9.],\n [8., 5., 5., 7.]]), array([[0., 5., 4., 0.],\n [1., 8., 6., 7.]]), array([[6., 8., 5., 2.],\n [1., 8., 1., 0.]])]\n>>> # Split `a` after the third and the fourth column\n>>> np.hsplit(a, (3, 4))\n[array([[6., 7., 6.],\n [8., 5., 5.]]), array([[9.],\n [7.]]), array([[0., 5., 4., 0., 6., 8., 5., 2.],\n [1., 8., 6., 7., 1., 8., 1., 0.]])] \n```", "```py\n>>> a = np.floor(10 * rg.random((3, 4)))\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a.ravel()  # returns the array, flattened\narray([3., 7., 3., 4., 1., 4., 2., 2., 7., 2., 4., 9.])\n>>> a.reshape(6, 2)  # returns the array with a modified shape\narray([[3., 7.],\n [3., 4.],\n [1., 4.],\n [2., 2.],\n [7., 2.],\n [4., 9.]])\n>>> a.T  # returns the array, transposed\narray([[3., 1., 7.],\n [7., 4., 2.],\n [3., 2., 4.],\n [4., 2., 9.]])\n>>> a.T.shape\n(4, 3)\n>>> a.shape\n(3, 4) \n```", "```py\n>>> a\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]])\n>>> a.resize((2, 6))\n>>> a\narray([[3., 7., 3., 4., 1., 4.],\n [2., 2., 7., 2., 4., 9.]]) \n```", "```py\n>>> a.reshape(3, -1)\narray([[3., 7., 3., 4.],\n [1., 4., 2., 2.],\n [7., 2., 4., 9.]]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 2)))\n>>> a\narray([[9., 7.],\n [5., 2.]])\n>>> b = np.floor(10 * rg.random((2, 2)))\n>>> b\narray([[1., 9.],\n [5., 1.]])\n>>> np.vstack((a, b))\narray([[9., 7.],\n [5., 2.],\n [1., 9.],\n [5., 1.]])\n>>> np.hstack((a, b))\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]]) \n```", "```py\n>>> from numpy import newaxis\n>>> np.column_stack((a, b))  # with 2D arrays\narray([[9., 7., 1., 9.],\n [5., 2., 5., 1.]])\n>>> a = np.array([4., 2.])\n>>> b = np.array([3., 8.])\n>>> np.column_stack((a, b))  # returns a 2D array\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a, b))        # the result is different\narray([4., 2., 3., 8.])\n>>> a[:, newaxis]  # view `a` as a 2D column vector\narray([[4.],\n [2.]])\n>>> np.column_stack((a[:, newaxis], b[:, newaxis]))\narray([[4., 3.],\n [2., 8.]])\n>>> np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same\narray([[4., 3.],\n [2., 8.]]) \n```", "```py\n>>> np.column_stack is np.hstack\nFalse\n>>> np.row_stack is np.vstack\nTrue \n```", "```py\n>>> np.r_[1:4, 0, 4]\narray([1, 2, 3, 0, 4]) \n```", "```py\n>>> a = np.floor(10 * rg.random((2, 12)))\n>>> a\narray([[6., 7., 6., 9., 0., 5., 4., 0., 6., 8., 5., 2.],\n [8., 5., 5., 7., 1., 8., 6., 7., 1., 8., 1., 0.]])\n>>> # Split `a` into 3\n>>> np.hsplit(a, 3)\n[array([[6., 7., 6., 9.],\n [8., 5., 5., 7.]]), array([[0., 5., 4., 0.],\n [1., 8., 6., 7.]]), array([[6., 8., 5., 2.],\n [1., 8., 1., 0.]])]\n>>> # Split `a` after the third and the fourth column\n>>> np.hsplit(a, (3, 4))\n[array([[6., 7., 6.],\n [8., 5., 5.]]), array([[9.],\n [7.]]), array([[0., 5., 4., 0., 6., 8., 5., 2.],\n [1., 8., 6., 7., 1., 8., 1., 0.]])] \n```", "```py\n>>> a = np.array([[ 0,  1,  2,  3],\n...               [ 4,  5,  6,  7],\n...               [ 8,  9, 10, 11]])\n>>> b = a            # no new object is created\n>>> b is a           # a and b are two names for the same ndarray object\nTrue \n```", "```py\n>>> def f(x):\n...     print(id(x))\n...\n>>> id(a)  # id is a unique identifier of an object \n148293216  # may vary\n>>> f(a)   \n148293216  # may vary \n```", "```py\n>>> c = a.view()\n>>> c is a\nFalse\n>>> c.base is a            # c is a view of the data owned by a\nTrue\n>>> c.flags.owndata\nFalse\n>>>\n>>> c = c.reshape((2, 6))  # a's shape doesn't change\n>>> a.shape\n(3, 4)\n>>> c[0, 4] = 1234         # a's data changes\n>>> a\narray([[   0,    1,    2,    3],\n [1234,    5,    6,    7],\n [   8,    9,   10,   11]]) \n```", "```py\n>>> s = a[:, 1:3]\n>>> s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> d = a.copy()  # a new array object with new data is created\n>>> d is a\nFalse\n>>> d.base is a  # d doesn't share anything with a\nFalse\n>>> d[0, 0] = 9999\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> a = np.arange(int(1e8))\n>>> b = a[:100].copy()\n>>> del a  # the memory of ``a`` can be released. \n```", "```py\n>>> a = np.array([[ 0,  1,  2,  3],\n...               [ 4,  5,  6,  7],\n...               [ 8,  9, 10, 11]])\n>>> b = a            # no new object is created\n>>> b is a           # a and b are two names for the same ndarray object\nTrue \n```", "```py\n>>> def f(x):\n...     print(id(x))\n...\n>>> id(a)  # id is a unique identifier of an object \n148293216  # may vary\n>>> f(a)   \n148293216  # may vary \n```", "```py\n>>> c = a.view()\n>>> c is a\nFalse\n>>> c.base is a            # c is a view of the data owned by a\nTrue\n>>> c.flags.owndata\nFalse\n>>>\n>>> c = c.reshape((2, 6))  # a's shape doesn't change\n>>> a.shape\n(3, 4)\n>>> c[0, 4] = 1234         # a's data changes\n>>> a\narray([[   0,    1,    2,    3],\n [1234,    5,    6,    7],\n [   8,    9,   10,   11]]) \n```", "```py\n>>> s = a[:, 1:3]\n>>> s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> d = a.copy()  # a new array object with new data is created\n>>> d is a\nFalse\n>>> d.base is a  # d doesn't share anything with a\nFalse\n>>> d[0, 0] = 9999\n>>> a\narray([[   0,   10,   10,    3],\n [1234,   10,   10,    7],\n [   8,   10,   10,   11]]) \n```", "```py\n>>> a = np.arange(int(1e8))\n>>> b = a[:100].copy()\n>>> del a  # the memory of ``a`` can be released. \n```", "```py\n>>> a = np.arange(12)**2  # the first 12 square numbers\n>>> i = np.array([1, 1, 3, 8, 5])  # an array of indices\n>>> a[i]  # the elements of `a` at the positions `i`\narray([ 1,  1,  9, 64, 25])\n>>>\n>>> j = np.array([[3, 4], [9, 7]])  # a bidimensional array of indices\n>>> a[j]  # the same shape as `j`\narray([[ 9, 16],\n [81, 49]]) \n```", "```py\n>>> palette = np.array([[0, 0, 0],         # black\n...                     [255, 0, 0],       # red\n...                     [0, 255, 0],       # green\n...                     [0, 0, 255],       # blue\n...                     [255, 255, 255]])  # white\n>>> image = np.array([[0, 1, 2, 0],  # each value corresponds to a color in the palette\n...                   [0, 3, 4, 0]])\n>>> palette[image]  # the (2, 4, 3) color image\narray([[[  0,   0,   0],\n [255,   0,   0],\n [  0, 255,   0],\n [  0,   0,   0]],\n\n [[  0,   0,   0],\n [  0,   0, 255],\n [255, 255, 255],\n [  0,   0,   0]]]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>> i = np.array([[0, 1],  # indices for the first dim of `a`\n...               [1, 2]])\n>>> j = np.array([[2, 1],  # indices for the second dim\n...               [3, 3]])\n>>>\n>>> a[i, j]  # i and j must have equal shape\narray([[ 2,  5],\n [ 7, 11]])\n>>>\n>>> a[i, 2]\narray([[ 2,  6],\n [ 6, 10]])\n>>>\n>>> a[:, j]\narray([[[ 2,  1],\n [ 3,  3]],\n\n [[ 6,  5],\n [ 7,  7]],\n\n [[10,  9],\n [11, 11]]]) \n```", "```py\n>>> l = (i, j)\n>>> # equivalent to a[i, j]\n>>> a[l]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> s = np.array([i, j])\n>>> # not what we want\n>>> a[s]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: index 3 is out of bounds for axis 0 with size 3\n>>> # same as `a[i, j]`\n>>> a[tuple(s)]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> time = np.linspace(20, 145, 5)  # time scale\n>>> data = np.sin(np.arange(20)).reshape(5, 4)  # 4 time-dependent series\n>>> time\narray([ 20\\.  ,  51.25,  82.5 , 113.75, 145\\.  ])\n>>> data\narray([[ 0\\.        ,  0.84147098,  0.90929743,  0.14112001],\n [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],\n [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],\n [-0.53657292,  0.42016704,  0.99060736,  0.65028784],\n [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])\n>>> # index of the maxima for each series\n>>> ind = data.argmax(axis=0)\n>>> ind\narray([2, 0, 3, 1])\n>>> # times corresponding to the maxima\n>>> time_max = time[ind]\n>>>\n>>> data_max = data[ind, range(data.shape[1])]  # => data[ind[0], 0], data[ind[1], 1]...\n>>> time_max\narray([ 82.5 ,  20\\.  , 113.75,  51.25])\n>>> data_max\narray([0.98935825, 0.84147098, 0.99060736, 0.6569866 ])\n>>> np.all(data_max == data.max(axis=0))\nTrue \n```", "```py\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a[[1, 3, 4]] = 0\n>>> a\narray([0, 0, 2, 0, 0]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] = [1, 2, 3]\n>>> a\narray([2, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] += 1\n>>> a\narray([1, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b = a > 4\n>>> b  # `b` is a boolean with `a`'s shape\narray([[False, False, False, False],\n [False,  True,  True,  True],\n [ True,  True,  True,  True]])\n>>> a[b]  # 1d array with the selected elements\narray([ 5,  6,  7,  8,  9, 10, 11]) \n```", "```py\n>>> a[b] = 0  # All elements of `a` higher than 4 become 0\n>>> a\narray([[0, 1, 2, 3],\n [4, 0, 0, 0],\n [0, 0, 0, 0]]) \n```", "```py\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> def mandelbrot(h, w, maxit=20, r=2):\n...  \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\"\n...     x = np.linspace(-2.5, 1.5, 4*h+1)\n...     y = np.linspace(-1.5, 1.5, 3*w+1)\n...     A, B = np.meshgrid(x, y)\n...     C = A + B*1j\n...     z = np.zeros_like(C)\n...     divtime = maxit + np.zeros(z.shape, dtype=int)\n...\n...     for i in range(maxit):\n...         z = z**2 + C\n...         diverge = abs(z) > r                    # who is diverging\n...         div_now = diverge & (divtime == maxit)  # who is diverging now\n...         divtime[div_now] = i                    # note when\n...         z[diverge] = r                          # avoid diverging too much\n...\n...     return divtime\n>>> plt.clf()\n>>> plt.imshow(mandelbrot(400, 400)) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b1 = np.array([False, True, True])         # first dim selection\n>>> b2 = np.array([True, False, True, False])  # second dim selection\n>>>\n>>> a[b1, :]                                   # selecting rows\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[b1]                                      # same thing\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[:, b2]                                   # selecting columns\narray([[ 0,  2],\n [ 4,  6],\n [ 8, 10]])\n>>>\n>>> a[b1, b2]                                  # a weird thing to do\narray([ 4, 10]) \n```", "```py\n>>> a = np.array([2, 3, 4, 5])\n>>> b = np.array([8, 5, 4])\n>>> c = np.array([5, 4, 6, 8, 3])\n>>> ax, bx, cx = np.ix_(a, b, c)\n>>> ax\narray([[[2]],\n\n [[3]],\n\n [[4]],\n\n [[5]]])\n>>> bx\narray([[[8],\n [5],\n [4]]])\n>>> cx\narray([[[5, 4, 6, 8, 3]]])\n>>> ax.shape, bx.shape, cx.shape\n((4, 1, 1), (1, 3, 1), (1, 1, 5))\n>>> result = ax + bx * cx\n>>> result\narray([[[42, 34, 50, 66, 26],\n [27, 22, 32, 42, 17],\n [22, 18, 26, 34, 14]],\n\n [[43, 35, 51, 67, 27],\n [28, 23, 33, 43, 18],\n [23, 19, 27, 35, 15]],\n\n [[44, 36, 52, 68, 28],\n [29, 24, 34, 44, 19],\n [24, 20, 28, 36, 16]],\n\n [[45, 37, 53, 69, 29],\n [30, 25, 35, 45, 20],\n [25, 21, 29, 37, 17]]])\n>>> result[3, 2, 4]\n17\n>>> a[3] + b[2] * c[4]\n17 \n```", "```py\n>>> def ufunc_reduce(ufct, *vectors):\n...    vs = np.ix_(*vectors)\n...    r = ufct.identity\n...    for v in vs:\n...        r = ufct(r, v)\n...    return r \n```", "```py\n>>> ufunc_reduce(np.add, a, b, c)\narray([[[15, 14, 16, 18, 13],\n [12, 11, 13, 15, 10],\n [11, 10, 12, 14,  9]],\n\n [[16, 15, 17, 19, 14],\n [13, 12, 14, 16, 11],\n [12, 11, 13, 15, 10]],\n\n [[17, 16, 18, 20, 15],\n [14, 13, 15, 17, 12],\n [13, 12, 14, 16, 11]],\n\n [[18, 17, 19, 21, 16],\n [15, 14, 16, 18, 13],\n [14, 13, 15, 17, 12]]]) \n```", "```py\n>>> a = np.arange(12)**2  # the first 12 square numbers\n>>> i = np.array([1, 1, 3, 8, 5])  # an array of indices\n>>> a[i]  # the elements of `a` at the positions `i`\narray([ 1,  1,  9, 64, 25])\n>>>\n>>> j = np.array([[3, 4], [9, 7]])  # a bidimensional array of indices\n>>> a[j]  # the same shape as `j`\narray([[ 9, 16],\n [81, 49]]) \n```", "```py\n>>> palette = np.array([[0, 0, 0],         # black\n...                     [255, 0, 0],       # red\n...                     [0, 255, 0],       # green\n...                     [0, 0, 255],       # blue\n...                     [255, 255, 255]])  # white\n>>> image = np.array([[0, 1, 2, 0],  # each value corresponds to a color in the palette\n...                   [0, 3, 4, 0]])\n>>> palette[image]  # the (2, 4, 3) color image\narray([[[  0,   0,   0],\n [255,   0,   0],\n [  0, 255,   0],\n [  0,   0,   0]],\n\n [[  0,   0,   0],\n [  0,   0, 255],\n [255, 255, 255],\n [  0,   0,   0]]]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> a\narray([[ 0,  1,  2,  3],\n [ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>> i = np.array([[0, 1],  # indices for the first dim of `a`\n...               [1, 2]])\n>>> j = np.array([[2, 1],  # indices for the second dim\n...               [3, 3]])\n>>>\n>>> a[i, j]  # i and j must have equal shape\narray([[ 2,  5],\n [ 7, 11]])\n>>>\n>>> a[i, 2]\narray([[ 2,  6],\n [ 6, 10]])\n>>>\n>>> a[:, j]\narray([[[ 2,  1],\n [ 3,  3]],\n\n [[ 6,  5],\n [ 7,  7]],\n\n [[10,  9],\n [11, 11]]]) \n```", "```py\n>>> l = (i, j)\n>>> # equivalent to a[i, j]\n>>> a[l]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> s = np.array([i, j])\n>>> # not what we want\n>>> a[s]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: index 3 is out of bounds for axis 0 with size 3\n>>> # same as `a[i, j]`\n>>> a[tuple(s)]\narray([[ 2,  5],\n [ 7, 11]]) \n```", "```py\n>>> time = np.linspace(20, 145, 5)  # time scale\n>>> data = np.sin(np.arange(20)).reshape(5, 4)  # 4 time-dependent series\n>>> time\narray([ 20\\.  ,  51.25,  82.5 , 113.75, 145\\.  ])\n>>> data\narray([[ 0\\.        ,  0.84147098,  0.90929743,  0.14112001],\n [-0.7568025 , -0.95892427, -0.2794155 ,  0.6569866 ],\n [ 0.98935825,  0.41211849, -0.54402111, -0.99999021],\n [-0.53657292,  0.42016704,  0.99060736,  0.65028784],\n [-0.28790332, -0.96139749, -0.75098725,  0.14987721]])\n>>> # index of the maxima for each series\n>>> ind = data.argmax(axis=0)\n>>> ind\narray([2, 0, 3, 1])\n>>> # times corresponding to the maxima\n>>> time_max = time[ind]\n>>>\n>>> data_max = data[ind, range(data.shape[1])]  # => data[ind[0], 0], data[ind[1], 1]...\n>>> time_max\narray([ 82.5 ,  20\\.  , 113.75,  51.25])\n>>> data_max\narray([0.98935825, 0.84147098, 0.99060736, 0.6569866 ])\n>>> np.all(data_max == data.max(axis=0))\nTrue \n```", "```py\n>>> a = np.arange(5)\n>>> a\narray([0, 1, 2, 3, 4])\n>>> a[[1, 3, 4]] = 0\n>>> a\narray([0, 0, 2, 0, 0]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] = [1, 2, 3]\n>>> a\narray([2, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(5)\n>>> a[[0, 0, 2]] += 1\n>>> a\narray([1, 1, 3, 3, 4]) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b = a > 4\n>>> b  # `b` is a boolean with `a`'s shape\narray([[False, False, False, False],\n [False,  True,  True,  True],\n [ True,  True,  True,  True]])\n>>> a[b]  # 1d array with the selected elements\narray([ 5,  6,  7,  8,  9, 10, 11]) \n```", "```py\n>>> a[b] = 0  # All elements of `a` higher than 4 become 0\n>>> a\narray([[0, 1, 2, 3],\n [4, 0, 0, 0],\n [0, 0, 0, 0]]) \n```", "```py\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> def mandelbrot(h, w, maxit=20, r=2):\n...  \"\"\"Returns an image of the Mandelbrot fractal of size (h,w).\"\"\"\n...     x = np.linspace(-2.5, 1.5, 4*h+1)\n...     y = np.linspace(-1.5, 1.5, 3*w+1)\n...     A, B = np.meshgrid(x, y)\n...     C = A + B*1j\n...     z = np.zeros_like(C)\n...     divtime = maxit + np.zeros(z.shape, dtype=int)\n...\n...     for i in range(maxit):\n...         z = z**2 + C\n...         diverge = abs(z) > r                    # who is diverging\n...         div_now = diverge & (divtime == maxit)  # who is diverging now\n...         divtime[div_now] = i                    # note when\n...         z[diverge] = r                          # avoid diverging too much\n...\n...     return divtime\n>>> plt.clf()\n>>> plt.imshow(mandelbrot(400, 400)) \n```", "```py\n>>> a = np.arange(12).reshape(3, 4)\n>>> b1 = np.array([False, True, True])         # first dim selection\n>>> b2 = np.array([True, False, True, False])  # second dim selection\n>>>\n>>> a[b1, :]                                   # selecting rows\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[b1]                                      # same thing\narray([[ 4,  5,  6,  7],\n [ 8,  9, 10, 11]])\n>>>\n>>> a[:, b2]                                   # selecting columns\narray([[ 0,  2],\n [ 4,  6],\n [ 8, 10]])\n>>>\n>>> a[b1, b2]                                  # a weird thing to do\narray([ 4, 10]) \n```", "```py\n>>> a = np.array([2, 3, 4, 5])\n>>> b = np.array([8, 5, 4])\n>>> c = np.array([5, 4, 6, 8, 3])\n>>> ax, bx, cx = np.ix_(a, b, c)\n>>> ax\narray([[[2]],\n\n [[3]],\n\n [[4]],\n\n [[5]]])\n>>> bx\narray([[[8],\n [5],\n [4]]])\n>>> cx\narray([[[5, 4, 6, 8, 3]]])\n>>> ax.shape, bx.shape, cx.shape\n((4, 1, 1), (1, 3, 1), (1, 1, 5))\n>>> result = ax + bx * cx\n>>> result\narray([[[42, 34, 50, 66, 26],\n [27, 22, 32, 42, 17],\n [22, 18, 26, 34, 14]],\n\n [[43, 35, 51, 67, 27],\n [28, 23, 33, 43, 18],\n [23, 19, 27, 35, 15]],\n\n [[44, 36, 52, 68, 28],\n [29, 24, 34, 44, 19],\n [24, 20, 28, 36, 16]],\n\n [[45, 37, 53, 69, 29],\n [30, 25, 35, 45, 20],\n [25, 21, 29, 37, 17]]])\n>>> result[3, 2, 4]\n17\n>>> a[3] + b[2] * c[4]\n17 \n```", "```py\n>>> def ufunc_reduce(ufct, *vectors):\n...    vs = np.ix_(*vectors)\n...    r = ufct.identity\n...    for v in vs:\n...        r = ufct(r, v)\n...    return r \n```", "```py\n>>> ufunc_reduce(np.add, a, b, c)\narray([[[15, 14, 16, 18, 13],\n [12, 11, 13, 15, 10],\n [11, 10, 12, 14,  9]],\n\n [[16, 15, 17, 19, 14],\n [13, 12, 14, 16, 11],\n [12, 11, 13, 15, 10]],\n\n [[17, 16, 18, 20, 15],\n [14, 13, 15, 17, 12],\n [13, 12, 14, 16, 11]],\n\n [[18, 17, 19, 21, 16],\n [15, 14, 16, 18, 13],\n [14, 13, 15, 17, 12]]]) \n```", "```py\n>>> a = np.arange(30)\n>>> b = a.reshape((2, -1, 3))  # -1 means \"whatever is needed\"\n>>> b.shape\n(2, 5, 3)\n>>> b\narray([[[ 0,  1,  2],\n [ 3,  4,  5],\n [ 6,  7,  8],\n [ 9, 10, 11],\n [12, 13, 14]],\n\n [[15, 16, 17],\n [18, 19, 20],\n [21, 22, 23],\n [24, 25, 26],\n [27, 28, 29]]]) \n```", "```py\n>>> x = np.arange(0, 10, 2)\n>>> y = np.arange(5)\n>>> m = np.vstack([x, y])\n>>> m\narray([[0, 2, 4, 6, 8],\n [0, 1, 2, 3, 4]])\n>>> xy = np.hstack([x, y])\n>>> xy\narray([0, 2, 4, 6, 8, 0, 1, 2, 3, 4]) \n```", "```py\n>>> import numpy as np\n>>> rg = np.random.default_rng(1)\n>>> import matplotlib.pyplot as plt\n>>> # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2\n>>> mu, sigma = 2, 0.5\n>>> v = rg.normal(mu, sigma, 10000)\n>>> # Plot a normalized histogram with 50 bins\n>>> plt.hist(v, bins=50, density=True)       # matplotlib version (plot)\n(array...)\n>>> # Compute the histogram with numpy and then plot it\n>>> (n, bins) = np.histogram(v, bins=50, density=True)  # NumPy version (no plot)\n>>> plt.plot(.5 * (bins[1:] + bins[:-1]), n) \n```", "```py\n>>> a = np.arange(30)\n>>> b = a.reshape((2, -1, 3))  # -1 means \"whatever is needed\"\n>>> b.shape\n(2, 5, 3)\n>>> b\narray([[[ 0,  1,  2],\n [ 3,  4,  5],\n [ 6,  7,  8],\n [ 9, 10, 11],\n [12, 13, 14]],\n\n [[15, 16, 17],\n [18, 19, 20],\n [21, 22, 23],\n [24, 25, 26],\n [27, 28, 29]]]) \n```", "```py\n>>> x = np.arange(0, 10, 2)\n>>> y = np.arange(5)\n>>> m = np.vstack([x, y])\n>>> m\narray([[0, 2, 4, 6, 8],\n [0, 1, 2, 3, 4]])\n>>> xy = np.hstack([x, y])\n>>> xy\narray([0, 2, 4, 6, 8, 0, 1, 2, 3, 4]) \n```", "```py\n>>> import numpy as np\n>>> rg = np.random.default_rng(1)\n>>> import matplotlib.pyplot as plt\n>>> # Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2\n>>> mu, sigma = 2, 0.5\n>>> v = rg.normal(mu, sigma, 10000)\n>>> # Plot a normalized histogram with 50 bins\n>>> plt.hist(v, bins=50, density=True)       # matplotlib version (plot)\n(array...)\n>>> # Compute the histogram with numpy and then plot it\n>>> (n, bins) = np.histogram(v, bins=50, density=True)  # NumPy version (no plot)\n>>> plt.plot(.5 * (bins[1:] + bins[:-1]), n) \n```"]