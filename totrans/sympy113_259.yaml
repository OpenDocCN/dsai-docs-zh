- en: Parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/parsing.html](https://docs.sympy.org/latest/modules/parsing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Parsing Functions Reference'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Converts the string `s` to a SymPy expression, in `local_dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**s** : str'
  prefs: []
  type: TYPE_NORMAL
- en: The string to parse.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**local_dict** : dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of local variables to use when parsing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**global_dict** : dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of global variables. By default, this is initialized with `from
    sympy import *`; provide this parameter to override this behavior (for instance,
    to parse `"Q & S"`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**transformations** : tuple or str'
  prefs: []
  type: TYPE_NORMAL
- en: A tuple of transformation functions used to modify the tokens of the parsed
    expression before evaluation. The default transformations convert numeric literals
    into their SymPy equivalents, convert undefined variables into SymPy symbols,
    and allow the use of standard mathematical factorial notation (e.g. `x!`). Selection
    via string is available (see below).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**evaluate** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: When False, the order of the arguments will remain as they were in the string
    and automatic simplification that would normally occur is suppressed. (see examples)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When evaluate=False, some automatic simplifications will not occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition the order of the arguments will not be made canonical. This feature
    allows one to tell exactly how the expression was entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, however, that when these expressions are printed they will appear the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convenience, transformations can be seen by printing `transformations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `T` object provides a way to select these transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you print it, you will see the same list as shown above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Standard slicing will return a tuple of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So `T` can be used to specify the parsing transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As a further convenience, strings ‘implicit’ and ‘all’ can be used to select
    0-5 and all the transformations, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`stringify_expr`](#sympy.parsing.sympy_parser.stringify_expr "sympy.parsing.sympy_parser.stringify_expr"),
    [`eval_expr`](#sympy.parsing.sympy_parser.eval_expr "sympy.parsing.sympy_parser.eval_expr"),
    [`standard_transformations`](#sympy.parsing.sympy_parser.standard_transformations
    "sympy.parsing.sympy_parser.standard_transformations"), [`implicit_multiplication_application`](#sympy.parsing.sympy_parser.implicit_multiplication_application
    "sympy.parsing.sympy_parser.implicit_multiplication_application")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Converts the string `s` to Python code, in `local_dict`
  prefs: []
  type: TYPE_NORMAL
- en: Generally, `parse_expr` should be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate Python code generated by `stringify_expr`.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, `parse_expr` should be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Translate a string containing a Wolfram Mathematica expression to a SymPy expression.
  prefs: []
  type: TYPE_NORMAL
- en: If the translator is unable to find a suitable SymPy expression, the `FullForm`
    of the Mathematica expression will be output, using SymPy `Function` objects as
    nodes of the syntax tree.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Both standard input form and Mathematica full form are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a matrix from Wolfram’s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the translation into equivalent SymPy expressions fails, an SymPy expression
    equivalent to Wolfram Mathematica’s “FullForm” will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Transformations Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A transformation is a function that accepts the arguments `tokens, local_dict,
    global_dict` and returns a list of transformed tokens. They can be used by passing
    a list of functions to [`parse_expr()`](#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr") and are applied in the order given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Standard transformations for [`parse_expr()`](#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). Inserts calls to [`Symbol`](core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"), [`Integer`](core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), and other SymPy datatypes and allows the use of
    standard factorial notation (e.g. `x!`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Splits symbol names for implicit multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Intended to let expressions like `xyz` be parsed as `x*y*z`. Does not split
    Greek character names, so `theta` will *not* become `t*h*e*t*a`. Generally this
    should be used with `implicit_multiplication`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creates a transformation that splits symbol names.
  prefs: []
  type: TYPE_NORMAL
- en: '`predicate` should return True if the symbol name is to be split.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to retain the default behavior but avoid splitting certain symbol
    names, a predicate like this would work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Makes the multiplication operator optional in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Use this before [`implicit_application()`](#sympy.parsing.sympy_parser.implicit_application
    "sympy.parsing.sympy_parser.implicit_application"), otherwise expressions like
    `sin 2x` will be parsed as `x * sin(2)` rather than `sin(2*x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Makes parentheses optional in some cases for function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Use this after [`implicit_multiplication()`](#sympy.parsing.sympy_parser.implicit_multiplication
    "sympy.parsing.sympy_parser.implicit_multiplication"), otherwise expressions like
    `sin 2x` will be parsed as `x * sin(2)` rather than `sin(2*x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Allows functions to be exponentiated, e.g. `cos**2(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Allows a slightly relaxed syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses for single-argument method calls are optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplication is implicit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol names can be split (i.e. spaces are not needed between symbols).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be exponentiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Converts floats into `Rational`. Run AFTER `auto_number`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Treats XOR, `^`, as exponentiation, `**`.
  prefs: []
  type: TYPE_NORMAL
- en: These are included in [`sympy.parsing.sympy_parser.standard_transformations`](#sympy.parsing.sympy_parser.standard_transformations
    "sympy.parsing.sympy_parser.standard_transformations") and generally don’t need
    to be manually added by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Substitutes “lambda” with its SymPy equivalent Lambda(). However, the conversion
    does not take place if only “lambda” is passed because that is a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Inserts calls to `Symbol`/`Function` for undefined variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Allows 0.2[1] notation to represent the repeated decimal 0.2111… (19/90)
  prefs: []
  type: TYPE_NORMAL
- en: Run this before auto_number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Converts numeric literals to use SymPy equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers use `I`, integer literals use `Integer`, and float literals
    use `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Allows standard notation for factorial.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental \(\mathrm{\LaTeX}\) Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current implementations are experimental. The behavior, parser backend(s)
    and API might change in the future. Unlike some of the other parsers, \(\mathrm{\LaTeX}\)
    is designed as a *type-setting* language, not a *computer algebra system* and
    so can contain typographical conventions that might be interpreted multiple ways.
  prefs: []
  type: TYPE_NORMAL
- en: \(\mathrm{\LaTeX}\) Parsing Functions Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Converts the input LaTeX string `s` to a SymPy `Expr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**s** : str'
  prefs: []
  type: TYPE_NORMAL
- en: The LaTeX string to parse. In Python source containing LaTeX, *raw strings*
    (denoted with `r"`, like this one) are preferred, as LaTeX makes liberal use of
    the `\` character, which would trigger escaping in normal Python strings.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**backend** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are two backends supported: ANTLR, and Lark. The default setting
    is to use the ANTLR backend, which can be changed to Lark if preferred.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use `backend="antlr"` for the ANTLR-based parser, and `backend="lark"` for the
    Lark-based parser.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `backend` option is case-sensitive, and must be in all lowercase.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**strict** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: This option is only available with the ANTLR backend.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If True, raise an exception if the string cannot be parsed as valid LaTeX. If
    False, try to recover gracefully from common mistakes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: ANTLR Backend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ANTLR-based \(\mathrm{\LaTeX}\) parser was ported from [latex2sympy](https://github.com/augustt198/latex2sympy).
    While functional and its API should remain stable, the parsing behavior or backend
    may change in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ANTLR \(\mathrm{\LaTeX}\) Parser Caveats'
  prefs: []
  type: TYPE_NORMAL
- en: 'In its current definition, the parser may fail to fully parse an expression,
    yet not throw a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: will simply find `x`. What is covered by this behavior will almost certainly
    change between releases, and become stricter, more relaxed, or some mix.
  prefs: []
  type: TYPE_NORMAL
- en: Lark Backend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Lark-based LaTeX parser is newer, and is intended to eventually completely
    replace the ANTLR-based parser. It has most of the features that the ANTLR-based
    parser provides, with some extras.
  prefs: []
  type: TYPE_NORMAL
- en: Lark \(\mathrm{\LaTeX}\) Parser Features
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One thing to note is that the Lark backend does not support ill-formed expressions,
    and it does not try to fix any sort of common mistakes that may have occured.
    For example, as mentioned in [the earlier section](#antlr-parser-caveats), the
    ANTLR-based parser would simply find `x` if we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: will raise an `lark.exceptions.UnexpectedEOF` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from that, there are a couple of extra things that the Lark-based parser
    supports that the ANTLR-based parser does not. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting ambiguous expressions, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowing user-customization of the \(\mathrm{\LaTeX}\) grammar at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expressions like \(f(x)\) are technically ambiguous \(\mathrm{\LaTeX}\) expressions
    because the \(f\) might be a function or a variable name. Lark has the capability
    to point out these ambiguities and notify the user, or even return all possible
    interpretations.
  prefs: []
  type: TYPE_NORMAL
- en: The Lark-based parser exposes a number of internals which allow the user to
    customize the parser’s behavior. For example, the user can specify their own \(\mathrm{\LaTeX}\)
    grammar by passing the path to the grammar file to the `LarkLaTeXParser` while
    instantiating the parser.
  prefs: []
  type: TYPE_NORMAL
- en: The user can also specify their own custom transformer class to the \(LarkLaTeXParser\)
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The two examples mentioned above can be found in the [test_custom_latex.py](https://github.com/sympy/sympy/blob/395e820b114d2b169483354f1f4ee2f439faa292/sympy/parsing/tests/test_custom_latex.py)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Lark \(\mathrm{\LaTeX}\) Parser Capabilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to use the Lark-based LaTeX parser, it is important to know what it
    can and cannot do. As the parser is still experimental, it supports many things,
    but some features are still only partially implemented, or not available.
  prefs: []
  type: TYPE_NORMAL
- en: As such, we will list the types of expressions that it can parse, and then list
    some expression types of interest where it may fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the things which are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols which consist of one letter, e.g., `a`, `b`, `x`, etc. Greek symbols
    and symbols with subscripts are also supported. Numbers are also supported, as
    is `\infty`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbols with multiple letters are supported, as long as they are wrapped in
    `\mathit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions with \(+\), \(-\), \(*\), \(/\), and alternative operators like
    `\cdot`, `\times`, `\div`, etc. If two expressions are next to each other, like
    \(xy\) or \((\sin x)(\cos t)\), then it is treated as implicit multiplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relations with \(<\), \(>\), \(\le\), \(\ge\), \(=\), and \(\ne\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used functions like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Square roots,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: factorials,
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: complex conjugation (like \(\overline{z}\))
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\log\),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\ln\),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\exp\),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: absolute value (e.g., \(|x|\)). Note that \(||x||\) is parsed as `Abs(Abs(x))`.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: floor (e.g., \(\lfloor x \rfloor\)) and ceiling (e.g., \(\lceil x \rceil\)),
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\min\) and \(\max\).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: All the trigonometric functions and their inverses trigonometric functions.
    Powers like `\sin^4` are also supported. The power \(-1\) is interpreted as the
    inverse function (i.e., `\sin^{-1} x` is interpreted as `\arcsin x`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hyperbolic trigonometric functions (currently only \(\sinh\), \(\cosh\), and
    \(\tanh\)) and their inverses. As mentioned in the previous point, powers like
    `\tanh^2` are also supported, and \(-1\) is interpreted as the inverse function
    (i.e., `\tanh^{-1} x` is interpreted as `\arctanh x`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppliedFunctions`, like \(f(x, y, z)\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All types of fractions (`\frac`, `\tfrac`, `\dfrac`, `\nicefrac`) and binomials
    (`\binom`, `\tbinom`, `\dbinom`) are supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrals, both definite and indefinite. When the integrand is a fraction, having
    the differential in the numerator is allowed. The differential is allowed to be
    `d`, `\text{d}`, or `\mathrm{d}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives in one variable. I.e., things like \(\dfrac{d}{dx} (\sin x)\). Higher
    order derivatives and partial derivatives are not supported yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits in one variable. E.g., \(\lim\limits_{t\to 3^{+}} \sin t\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sums and products with simple conditions. For example, \(\sum\limits_{k=0}^n
    k^2\) is allowed because the condition on \(k\) is simple. An expression like
    \(\sum\limits_{d \mid n} d^2\) is not allowed because the condition on \(d\) in
    the subscript is complicated. Expressions with the index variable specified in
    the superscript are also allowed. For example, \(\prod\limits_{k=0}^{k=n} k^2\)
    is parsed correctly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bra (e.g., \(| x \rangle\)), and Ket (e.g., \(\langle p |\)) notation. Parsing
    Inner (e.g., \(\langle x | y \rangle\)) and Outer Products (e.g., \(| y \rangle
    \langle x |\)) is also supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a(n incomplete) list of things which are currently not supported, which
    may be added in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrices. Stuff like `\begin{env}...\end{env}`, where `env` is any of `matrix`,
    `bmatrix`, `pmatrix`, `smallmatrix`, and `array`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix operations like matrix-matrix addition, scalar-matrix multiplication,
    matrix-matrix multiplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher order derivatives and partial derivatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double and triple integrals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lark \(\mathrm{\LaTeX}\) Parser Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Experimental LaTeX parser using Lark.
  prefs: []
  type: TYPE_NORMAL
- en: This function is still under development and its API may change with the next
    releases of SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Lark \(\mathrm{\LaTeX}\) Parser Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Class for converting input \(\mathrm{\LaTeX}\) strings into SymPy Expressions.
    It holds all the necessary internal data for doing so, and exposes hooks for customizing
    its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**print_debug_output** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `True`, prints debug output to the logger. Defaults to `False`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**transform** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `True`, the class runs the Transformer class on the parse tree generated
    by running `Lark.parse` on the input string. Defaults to `True`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Setting it to `False` can help with debugging the \(\mathrm{\LaTeX}\) grammar.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**grammar_file** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The path to the grammar file that the parser should use. If set to `None`, it
    uses the default grammar, which is in `grammar/latex.lark`, relative to the `sympy/parsing/latex/lark/`
    directory.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**transformer** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Transformer class to use. If set to `None`, it uses the default
    transformer class, which is [`TransformToSymPyExpr()`](#sympy.parsing.latex.lark.TransformToSymPyExpr
    "sympy.parsing.latex.lark.TransformToSymPyExpr").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Returns a SymPy expression that is generated by traversing the `lark.Tree` passed
    to the `.transform()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**visit_tokens** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: For information about what this option does, see [here](https://lark-parser.readthedocs.io/en/latest/visitors.html#lark.visitors.Transformer).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the option must be set to `True` for the default parser to work.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '**This class is never supposed to be used directly.**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to tweak the behavior of this class, it has to be subclassed and then
    after the required modifications are made, the name of the new class should be
    passed to the [`LarkLaTeXParser`](#sympy.parsing.latex.lark.LarkLaTeXParser "sympy.parsing.latex.lark.LarkLaTeXParser")
    class by using the `transformer` argument in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: \(\mathrm{\LaTeX}\) Parsing Exceptions Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '## SymPy Expression Reference'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Class to store and handle SymPy expressions
  prefs: []
  type: TYPE_NORMAL
- en: This class will hold SymPy Expressions and handle the API for the conversion
    to and from different languages.
  prefs: []
  type: TYPE_NORMAL
- en: It works with the C and the Fortran Parser to generate SymPy expressions which
    are stored here and which can be converted to multiple language’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The module and its API are currently under development and experimental and
    can be changed during development.
  prefs: []
  type: TYPE_NORMAL
- en: The Fortran parser does not support numeric assignments, so all the variables
    have been Initialized to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module also depends on external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: LFortran which is required to use the Fortran parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang which is required for the C parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of parsing C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of variable definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of Assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list with the c source code for the SymPy expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Converts the given source code to SymPy Expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| src_code | (String) the source code or filename of the source code that is
    to be converted |'
  prefs: []
  type: TYPE_TB
- en: '| mode: String | the mode to determine which parser is to be used according
    to the language of the source code f or F for Fortran c or C for C/C++ |'
  prefs: []
  type: TYPE_TB
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list with the fortran source code for the SymPy expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list with Python code for the SymPy expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Returns the expression list
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Runtime Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The currently-packaged LaTeX parser backend is partially generated with [ANTLR4](https://www.antlr.org/),
    but to use the parser, you only need the `antlr4` Python package available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your package manager, you can install the right package with,
    for example, `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'or `conda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The C parser depends on `clang` and the Fortran parser depends on `LFortran`.
    You can install these packages using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
