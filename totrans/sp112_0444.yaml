- en: scipy.optimize.differential_evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Finds the global minimum of a multivariate function.
  prefs: []
  type: TYPE_NORMAL
- en: The differential evolution method [[1]](#r108fc14fa019-1) is stochastic in nature.
    It does not use gradient methods to find the minimum, and can search large areas
    of candidate space, but often requires larger numbers of function evaluations
    than conventional gradient-based techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is due to Storn and Price [[2]](#r108fc14fa019-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The objective function to be minimized. Must be in the form `f(x, *args)`, where
    `x` is the argument in the form of a 1-D array and `args` is a tuple of any additional
    fixed parameters needed to completely specify the function. The number of parameters,
    N, is equal to `len(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**sequence or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bounds for variables. There are two ways to specify the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(min, max)` pairs for each element in `x`, defining the finite lower and upper
    bounds for the optimizing argument of *func*.'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: The total number of bounds is used to determine the number of parameters, N.
    If there are parameters whose bounds are equal the total number of free parameters
    is `N - N_equal`.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Any additional fixed parameters needed to completely specify the objective function.
  prefs: []
  type: TYPE_NORMAL
- en: '**strategy**{str, callable}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'The differential evolution strategy to use. Should be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘best1bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best1exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand1bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand1exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand2bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand2exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘randtobest1bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘randtobest1exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘currenttobest1bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘currenttobest1exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best2exp’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best2bin’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default is ‘best1bin’. Strategies that may be implemented are outlined
    in ‘Notes’. Alternatively the differential evolution strategy can be customized
    by providing a callable that constructs a trial vector. The callable must have
    the form `strategy(candidate: int, population: np.ndarray, rng=None)`, where `candidate`
    is an integer specifying which entry of the population is being evolved, `population`
    is an array of shape `(S, N)` containing all the population members (where S is
    the total population size), and `rng` is the random number generator being used
    within the solver. `candidate` will be in the range `[0, S)`. `strategy` must
    return a trial vector with shape *(N,)*. The fitness of this trial vector is compared
    against the fitness of `population[candidate]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.12.0: Customization of evolution strategy via a callable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum number of generations over which the entire population is evolved.
    The maximum number of function evaluations (with no polishing) is: `(maxiter +
    1) * popsize * (N - N_equal)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**popsize**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A multiplier for setting the total population size. The population has `popsize
    * (N - N_equal)` individuals. This keyword is overridden if an initial population
    is supplied via the *init* keyword. When using `init='sobol'` the population size
    is calculated as the next power of 2 after `popsize * (N - N_equal)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative tolerance for convergence, the solving stops when `np.std(pop) <= atol
    + tol * np.abs(np.mean(population_energies))`, where and *atol* and *tol* are
    the absolute and relative tolerance respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**mutation**float or tuple(float, float), optional'
  prefs: []
  type: TYPE_NORMAL
- en: The mutation constant. In the literature this is also known as differential
    weight, being denoted by F. If specified as a float it should be in the range
    [0, 2]. If specified as a tuple `(min, max)` dithering is employed. Dithering
    randomly changes the mutation constant on a generation by generation basis. The
    mutation constant for that generation is taken from `U[min, max)`. Dithering can
    help speed convergence significantly. Increasing the mutation constant increases
    the search radius, but will slow down convergence.
  prefs: []
  type: TYPE_NORMAL
- en: '**recombination**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The recombination constant, should be in the range [0, 1]. In the literature
    this is also known as the crossover probability, being denoted by CR. Increasing
    this value allows a larger number of mutants to progress into the next generation,
    but at the risk of population stability.
  prefs: []
  type: TYPE_NORMAL
- en: '**seed**{None, int, [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)"), [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)")}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *seed* is None (or *np.random*), the [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)") singleton is used. If *seed* is an int, a new `RandomState`
    instance is used, seeded with *seed*. If *seed* is already a `Generator` or `RandomState`
    instance then that instance is used. Specify *seed* for repeatable minimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Prints the evaluated *func* at every iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'A callable called after each iteration. Has the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback(intermediate_result: OptimizeResult)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `intermediate_result` is a keyword parameter containing an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") with attributes `x` and `fun`, the best solution
    found so far and the objective function. Note that the name of the parameter must
    be `intermediate_result` for the callback to be passed an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback also supports a signature like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback(x, convergence: float=val)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`val` represents the fractional value of the population convergence. When `val`
    is greater than `1.0`, the function halts.'
  prefs: []
  type: TYPE_NORMAL
- en: Introspection is used to determine which of the signatures is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Global minimization will halt if the callback raises `StopIteration` or returns
    `True`; any polishing is still carried out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.12.0: callback accepts the `intermediate_result` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '**polish**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True (default), then [`scipy.optimize.minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") with the *L-BFGS-B* method is used to polish the best
    population member at the end, which can improve the minimization slightly. If
    a constrained problem is being studied then the *trust-constr* method is used
    instead. For large problems with many constraints, polishing can take a long time
    due to the Jacobian computations.
  prefs: []
  type: TYPE_NORMAL
- en: '**init**str or array-like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify which type of population initialization is performed. Should be one
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘latinhypercube’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘sobol’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘halton’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘random’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: array specifying the initial population. The array should have shape `(S, N)`,
    where S is the total population size and N is the number of parameters. *init*
    is clipped to *bounds* before use.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: The default is ‘latinhypercube’. Latin Hypercube sampling tries to maximize
    coverage of the available parameter space.
  prefs: []
  type: TYPE_NORMAL
- en: ‘sobol’ and ‘halton’ are superior alternatives and maximize even more the parameter
    space. ‘sobol’ will enforce an initial population size which is calculated as
    the next power of 2 after `popsize * (N - N_equal)`. ‘halton’ has no requirements
    but is a bit less efficient. See [`scipy.stats.qmc`](../stats.qmc.html#module-scipy.stats.qmc
    "scipy.stats.qmc") for more details.
  prefs: []
  type: TYPE_NORMAL
- en: ‘random’ initializes the population randomly - this has the drawback that clustering
    can occur, preventing the whole of parameter space being covered. Use of an array
    to specify a population could be used, for example, to create a tight bunch of
    initial guesses in an location where the solution is known to exist, thereby reducing
    time for convergence.
  prefs: []
  type: TYPE_NORMAL
- en: '**atol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute tolerance for convergence, the solving stops when `np.std(pop) <= atol
    + tol * np.abs(np.mean(population_energies))`, where and *atol* and *tol* are
    the absolute and relative tolerance respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**updating**{‘immediate’, ‘deferred’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `'immediate'`, the best solution vector is continuously updated within a
    single generation [[4]](#r108fc14fa019-4). This can lead to faster convergence
    as trial vectors can take advantage of continuous improvements in the best solution.
    With `'deferred'`, the best solution vector is updated once per generation. Only
    `'deferred'` is compatible with parallelization or vectorization, and the *workers*
    and *vectorized* keywords can over-ride this option.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**workers**int or map-like callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *workers* is an int the population is subdivided into *workers* sections
    and evaluated in parallel (uses [`multiprocessing.Pool`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(in Python v3.12)")). Supply -1 to use all available CPU cores. Alternatively
    supply a map-like callable, such as *multiprocessing.Pool.map* for evaluating
    the population in parallel. This evaluation is carried out as `workers(func, iterable)`.
    This option will override the *updating* keyword to `updating='deferred'` if `workers
    != 1`. This option overrides the *vectorized* keyword if `workers != 1`. Requires
    that *func* be pickleable.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**constraints**{NonLinearConstraint, LinearConstraint, Bounds}'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints on the solver, over and above those applied by the *bounds* kwd.
    Uses the approach by Lampinen [[5]](#r108fc14fa019-5).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**None or array-like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Provides an initial guess to the minimization. Once the population has been
    initialized this vector replaces the first (best) member. This replacement is
    done even if *init* is given an initial population. `x0.shape == (N,)`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**integrality**1-D array, optional'
  prefs: []
  type: TYPE_NORMAL
- en: For each decision variable, a boolean value indicating whether the decision
    variable is constrained to integer values. The array is broadcast to `(N,)`. If
    any decision variables are constrained to be integral, they will not be changed
    during polishing. Only integer values lying between the lower and upper bounds
    are used. If there are no integer values lying between the bounds then a *ValueError*
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**vectorized**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `vectorized is True`, *func* is sent an *x* array with `x.shape == (N, S)`,
    and is expected to return an array of shape `(S,)`, where *S* is the number of
    solution vectors to be calculated. If constraints are applied, each of the functions
    used to construct a *Constraint* object should accept an *x* array with `x.shape
    == (N, S)`, and return an array of shape `(M, S)`, where *M* is the number of
    constraint components. This option is an alternative to the parallelization offered
    by *workers*, and may help in optimization speed by reducing interpreter overhead
    from multiple function calls. This keyword is ignored if `workers != 1`. This
    option will override the *updating* keyword to `updating='deferred'`. See the
    notes section for further discussion on when to use `'vectorized'`, and when to
    use `'workers'`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**res**OptimizeResult'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optimization result represented as a [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") object. Important attributes are: `x` the solution
    array, `success` a Boolean flag indicating if the optimizer exited successfully,
    `message` which describes the cause of the termination, `population` the solution
    vectors present in the population, and `population_energies` the value of the
    objective function for each entry in `population`. See [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") for a description of other attributes. If *polish*
    was employed, and a lower minimum was obtained by the polishing, then OptimizeResult
    also contains the `jac` attribute. If the eventual solution does not satisfy the
    applied constraints `success` will be *False*.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Differential evolution is a stochastic population based method that is useful
    for global optimization problems. At each pass through the population the algorithm
    mutates each candidate solution by mixing with other candidate solutions to create
    a trial candidate. There are several strategies [[3]](#r108fc14fa019-3) for creating
    trial candidates, which suit some problems more than others. The ‘best1bin’ strategy
    is a good starting point for many systems. In this strategy two members of the
    population are randomly chosen. Their difference is used to mutate the best member
    (the ‘best’ in ‘best1bin’), \(x_0\), so far:'
  prefs: []
  type: TYPE_NORMAL
- en: \[b' = x_0 + mutation * (x_{r_0} - x_{r_1})\]
  prefs: []
  type: TYPE_NORMAL
- en: A trial vector is then constructed. Starting with a randomly chosen ith parameter
    the trial is sequentially filled (in modulo) with parameters from `b'` or the
    original candidate. The choice of whether to use `b'` or the original candidate
    is made with a binomial distribution (the ‘bin’ in ‘best1bin’) - a random number
    in [0, 1) is generated. If this number is less than the *recombination* constant
    then the parameter is loaded from `b'`, otherwise it is loaded from the original
    candidate. The final parameter is always loaded from `b'`. Once the trial candidate
    is built its fitness is assessed. If the trial is better than the original candidate
    then it takes its place. If it is also better than the best overall candidate
    it also replaces that.
  prefs: []
  type: TYPE_NORMAL
- en: The other strategies available are outlined in Qiang and Mitchell (2014) [[3]](#r108fc14fa019-3).
  prefs: []
  type: TYPE_NORMAL
- en: '\[ \begin{align}\begin{aligned}rand1* : b'' = x_{r_0} + mutation*(x_{r_1} -
    x_{r_2})\\rand2* : b'' = x_{r_0} + mutation*(x_{r_1} + x_{r_2} - x_{r_3} - x_{r_4})\\best1*
    : b'' = x_0 + mutation*(x_{r_0} - x_{r_1})\\best2* : b'' = x_0 + mutation*(x_{r_0}
    + x_{r_1} - x_{r_2} - x_{r_3})\\currenttobest1* : b'' = x_i + mutation*(x_0 -
    x_i + x_{r_0} - x_{r_1})\\randtobest1* : b'' = x_{r_0} + mutation*(x_0 - x_{r_0}
    + x_{r_1} - x_{r_2})\end{aligned}\end{align} \]'
  prefs: []
  type: TYPE_NORMAL
- en: where the integers \(r_0, r_1, r_2, r_3, r_4\) are chosen randomly from the
    interval [0, NP) with *NP* being the total population size and the original candidate
    having index *i*. The user can fully customize the generation of the trial candidates
    by supplying a callable to `strategy`.
  prefs: []
  type: TYPE_NORMAL
- en: To improve your chances of finding a global minimum use higher *popsize* values,
    with higher *mutation* and (dithering), but lower *recombination* values. This
    has the effect of widening the search radius, but slowing convergence.
  prefs: []
  type: TYPE_NORMAL
- en: By default the best solution vector is updated continuously within a single
    iteration (`updating='immediate'`). This is a modification [[4]](#r108fc14fa019-4)
    of the original differential evolution algorithm which can lead to faster convergence
    as trial vectors can immediately benefit from improved solutions. To use the original
    Storn and Price behaviour, updating the best solution once per iteration, set
    `updating='deferred'`. The `'deferred'` approach is compatible with both parallelization
    and vectorization (`'workers'` and `'vectorized'` keywords). These may improve
    minimization speed by using computer resources more efficiently. The `'workers'`
    distribute calculations over multiple processors. By default the Python [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(in Python v3.12)") module is used, but other approaches are also possible, such
    as the Message Passing Interface (MPI) used on clusters [[6]](#r108fc14fa019-6)
    [[7]](#r108fc14fa019-7). The overhead from these approaches (creating new Processes,
    etc) may be significant, meaning that computational speed doesn’t necessarily
    scale with the number of processors used. Parallelization is best suited to computationally
    expensive objective functions. If the objective function is less expensive, then
    `'vectorized'` may aid by only calling the objective function once per iteration,
    rather than multiple times for all the population members; the interpreter overhead
    is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.15.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Differential evolution, Wikipedia, [http://en.wikipedia.org/wiki/Differential_evolution](http://en.wikipedia.org/wiki/Differential_evolution)
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: Storn, R and Price, K, Differential Evolution - a Simple and Efficient Heuristic
    for Global Optimization over Continuous Spaces, Journal of Global Optimization,
    1997, 11, 341 - 359.
  prefs: []
  type: TYPE_NORMAL
- en: '[3] ([1](#id5),[2](#id6))'
  prefs: []
  type: TYPE_NORMAL
- en: Qiang, J., Mitchell, C., A Unified Differential Evolution Algorithm for Global
    Optimization, 2014, [https://www.osti.gov/servlets/purl/1163659](https://www.osti.gov/servlets/purl/1163659)
  prefs: []
  type: TYPE_NORMAL
- en: '[4] ([1](#id3),[2](#id7))'
  prefs: []
  type: TYPE_NORMAL
- en: Wormington, M., Panaccione, C., Matney, K. M., Bowen, D. K., - Characterization
    of structures from X-ray scattering data using genetic algorithms, Phil. Trans.
    R. Soc. Lond. A, 1999, 357, 2827-2848
  prefs: []
  type: TYPE_NORMAL
- en: '[[5](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: Lampinen, J., A constraint handling approach for the differential evolution
    algorithm. Proceedings of the 2002 Congress on Evolutionary Computation. CEC’02
    (Cat. No. 02TH8600). Vol. 2\. IEEE, 2002.
  prefs: []
  type: TYPE_NORMAL
- en: '[[6](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mpi4py.readthedocs.io/en/stable/](https://mpi4py.readthedocs.io/en/stable/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[7](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://schwimmbad.readthedocs.io/en/latest/](https://schwimmbad.readthedocs.io/en/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider the problem of minimizing the Rosenbrock function. This function
    is implemented in [`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen "scipy.optimize.rosen")
    in [`scipy.optimize`](../optimize.html#module-scipy.optimize "scipy.optimize").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now repeat, but with parallelization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s do a constrained minimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the constraint that the sum of `x[0]` and `x[1]` must be less than or
    equal to 1.9\. This is a linear constraint, which may be written `A @ x <= 1.9`,
    where `A = array([[1, 1]])`. This can be encoded as a [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Specify limits using a [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds") object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next find the minimum of the Ackley function ([https://en.wikipedia.org/wiki/Test_functions_for_optimization](https://en.wikipedia.org/wiki/Test_functions_for_optimization)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Ackley function is written in a vectorized manner, so the `'vectorized'`
    keyword can be employed. Note the reduced number of function evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following custom strategy function mimics ‘best1bin’:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
