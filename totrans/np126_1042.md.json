["```py\n>>> import numpy\n>>> numpy.test(label='slow') \n```", "```py\n>>> numpy.test(label='full', verbose=2)  # or numpy.test('full', 2) \n```", "```py\n>>> numpy.core.test() \n```", "```py\n$ spin test -m full \n```", "```py\n$ spin test -t numpy/core/tests \n```", "```py\ndef test_zzz():\n    assert zzz() == 'Hello from zzz' \n```", "```py\nimport pytest\n\n# import xxx symbols\nfrom numpy.xxx.yyy import zzz\nimport pytest\n\nclass TestZzz:\n    def test_simple(self):\n        assert zzz() == 'Hello from zzz'\n\n    def test_invalid_parameter(self):\n        with pytest.raises(ValueError, match='.*some matching regex.*'):\n            ... \n```", "```py\nnumpy.testing.extbuild.build_and_import_extension(modname, functions, *, prologue='', build_dir=None, include_dirs=[], more_init='')\n```", "```py\n>>> functions = [(\"test_bytes\", \"METH_O\", \"\"\"\n if ( !PyBytesCheck(args)) {\n Py_RETURN_FALSE;\n }\n Py_RETURN_TRUE;\n\"\"\")]\n>>> mod = build_and_import_extension(\"testme\", functions)\n>>> assert not mod.test_bytes(u'abc')\n>>> assert mod.test_bytes(b'abc') \n```", "```py\nimport pytest\n\n@pytest.mark.slow\ndef test_big(self):\n    print('Big, slow test') \n```", "```py\nclass test_zzz:\n    @pytest.mark.slow\n    def test_simple(self):\n        assert_(zzz() == 'Hello from zzz') \n```", "```py\ndef setup_module():\n  \"\"\"Module-level setup\"\"\"\n    print('doing setup')\n\ndef teardown_module():\n  \"\"\"Module-level teardown\"\"\"\n    print('doing teardown')\n\nclass TestMe:\n    def setup_method(self):\n  \"\"\"Class-level setup\"\"\"\n        print('doing setup')\n\n    def teardown_method():\n  \"\"\"Class-level teardown\"\"\"\n        print('doing teardown') \n```", "```py\n>>> import numpy as np\n>>> np.lib.test(doctests=True) \n```", "```py\npython test_yyy.py \n```", "```py\n>>> import test_yyy\n>>> test_yyy.test() \n```", "```py\n...\ndef test(level=1, verbosity=1):\n    from numpy.testing import Tester\n    return Tester().test(level, verbosity) \n```", "```py\n...\ndef configuration(parent_package='', top_path=None):\n    ...\n    config.add_subpackage('tests')\n    return config\n... \n```", "```py\n>>> import numpy\n>>> numpy.xxx.test() \n```", "```py\n>>> import numpy\n>>> numpy.test()\n# your tests are included and run automatically! \n```", "```py\nclass LinalgTestCase:\n    def test_single(self):\n        a = array([[1., 2.], [3., 4.]], dtype=single)\n        b = array([2., 1.], dtype=single)\n        self.do(a, b)\n\n    def test_double(self):\n        a = array([[1., 2.], [3., 4.]], dtype=double)\n        b = array([2., 1.], dtype=double)\n        self.do(a, b)\n\n    ...\n\nclass TestSolve(LinalgTestCase):\n    def do(self, a, b):\n        x = linalg.solve(a, b)\n        assert_allclose(b, dot(a, x))\n        assert imply(isinstance(b, matrix), isinstance(x, matrix))\n\nclass TestInv(LinalgTestCase):\n    def do(self, a, b):\n        a_inv = linalg.inv(a)\n        assert_allclose(dot(a, a_inv), identity(asarray(a).shape[0]))\n        assert imply(isinstance(a, matrix), isinstance(a_inv, matrix)) \n```", "```py\nimport pytest\n\n@pytest.mark.skipif(SkipMyTest, reason=\"Skipping this test because...\")\ndef test_something(foo):\n    ... \n```", "```py\nimport pytest\n\n@pytest.mark.xfail(MyTestFails, reason=\"This test is known to fail because...\")\ndef test_something_else(foo):\n    ... \n```", "```py\nnumpy.test(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, durations=-1, tests=None)\n```", "```py\nfrom numpy._pytesttester import PytestTester\ntest = PytestTester(__name__).test\ndel PytestTester \n```", "```py\n>>> import numpy\n>>> numpy.test(label='slow') \n```", "```py\n>>> numpy.test(label='full', verbose=2)  # or numpy.test('full', 2) \n```", "```py\n>>> numpy.core.test() \n```", "```py\n$ spin test -m full \n```", "```py\n$ spin test -t numpy/core/tests \n```", "```py\n>>> import numpy\n>>> numpy.test(label='slow') \n```", "```py\n>>> numpy.test(label='full', verbose=2)  # or numpy.test('full', 2) \n```", "```py\n>>> numpy.core.test() \n```", "```py\n$ spin test -m full \n```", "```py\n$ spin test -t numpy/core/tests \n```", "```py\ndef test_zzz():\n    assert zzz() == 'Hello from zzz' \n```", "```py\nimport pytest\n\n# import xxx symbols\nfrom numpy.xxx.yyy import zzz\nimport pytest\n\nclass TestZzz:\n    def test_simple(self):\n        assert zzz() == 'Hello from zzz'\n\n    def test_invalid_parameter(self):\n        with pytest.raises(ValueError, match='.*some matching regex.*'):\n            ... \n```", "```py\nnumpy.testing.extbuild.build_and_import_extension(modname, functions, *, prologue='', build_dir=None, include_dirs=[], more_init='')\n```", "```py\n>>> functions = [(\"test_bytes\", \"METH_O\", \"\"\"\n if ( !PyBytesCheck(args)) {\n Py_RETURN_FALSE;\n }\n Py_RETURN_TRUE;\n\"\"\")]\n>>> mod = build_and_import_extension(\"testme\", functions)\n>>> assert not mod.test_bytes(u'abc')\n>>> assert mod.test_bytes(b'abc') \n```", "```py\nimport pytest\n\n@pytest.mark.slow\ndef test_big(self):\n    print('Big, slow test') \n```", "```py\nclass test_zzz:\n    @pytest.mark.slow\n    def test_simple(self):\n        assert_(zzz() == 'Hello from zzz') \n```", "```py\ndef setup_module():\n  \"\"\"Module-level setup\"\"\"\n    print('doing setup')\n\ndef teardown_module():\n  \"\"\"Module-level teardown\"\"\"\n    print('doing teardown')\n\nclass TestMe:\n    def setup_method(self):\n  \"\"\"Class-level setup\"\"\"\n        print('doing setup')\n\n    def teardown_method():\n  \"\"\"Class-level teardown\"\"\"\n        print('doing teardown') \n```", "```py\n>>> import numpy as np\n>>> np.lib.test(doctests=True) \n```", "```py\npython test_yyy.py \n```", "```py\n>>> import test_yyy\n>>> test_yyy.test() \n```", "```py\n...\ndef test(level=1, verbosity=1):\n    from numpy.testing import Tester\n    return Tester().test(level, verbosity) \n```", "```py\n...\ndef configuration(parent_package='', top_path=None):\n    ...\n    config.add_subpackage('tests')\n    return config\n... \n```", "```py\n>>> import numpy\n>>> numpy.xxx.test() \n```", "```py\n>>> import numpy\n>>> numpy.test()\n# your tests are included and run automatically! \n```", "```py\nnumpy.testing.extbuild.build_and_import_extension(modname, functions, *, prologue='', build_dir=None, include_dirs=[], more_init='')\n```", "```py\n>>> functions = [(\"test_bytes\", \"METH_O\", \"\"\"\n if ( !PyBytesCheck(args)) {\n Py_RETURN_FALSE;\n }\n Py_RETURN_TRUE;\n\"\"\")]\n>>> mod = build_and_import_extension(\"testme\", functions)\n>>> assert not mod.test_bytes(u'abc')\n>>> assert mod.test_bytes(b'abc') \n```", "```py\nimport pytest\n\n@pytest.mark.slow\ndef test_big(self):\n    print('Big, slow test') \n```", "```py\nclass test_zzz:\n    @pytest.mark.slow\n    def test_simple(self):\n        assert_(zzz() == 'Hello from zzz') \n```", "```py\ndef setup_module():\n  \"\"\"Module-level setup\"\"\"\n    print('doing setup')\n\ndef teardown_module():\n  \"\"\"Module-level teardown\"\"\"\n    print('doing teardown')\n\nclass TestMe:\n    def setup_method(self):\n  \"\"\"Class-level setup\"\"\"\n        print('doing setup')\n\n    def teardown_method():\n  \"\"\"Class-level teardown\"\"\"\n        print('doing teardown') \n```", "```py\n>>> import numpy as np\n>>> np.lib.test(doctests=True) \n```", "```py\npython test_yyy.py \n```", "```py\n>>> import test_yyy\n>>> test_yyy.test() \n```", "```py\n...\ndef test(level=1, verbosity=1):\n    from numpy.testing import Tester\n    return Tester().test(level, verbosity) \n```", "```py\n...\ndef configuration(parent_package='', top_path=None):\n    ...\n    config.add_subpackage('tests')\n    return config\n... \n```", "```py\n>>> import numpy\n>>> numpy.xxx.test() \n```", "```py\n>>> import numpy\n>>> numpy.test()\n# your tests are included and run automatically! \n```", "```py\nclass LinalgTestCase:\n    def test_single(self):\n        a = array([[1., 2.], [3., 4.]], dtype=single)\n        b = array([2., 1.], dtype=single)\n        self.do(a, b)\n\n    def test_double(self):\n        a = array([[1., 2.], [3., 4.]], dtype=double)\n        b = array([2., 1.], dtype=double)\n        self.do(a, b)\n\n    ...\n\nclass TestSolve(LinalgTestCase):\n    def do(self, a, b):\n        x = linalg.solve(a, b)\n        assert_allclose(b, dot(a, x))\n        assert imply(isinstance(b, matrix), isinstance(x, matrix))\n\nclass TestInv(LinalgTestCase):\n    def do(self, a, b):\n        a_inv = linalg.inv(a)\n        assert_allclose(dot(a, a_inv), identity(asarray(a).shape[0]))\n        assert imply(isinstance(a, matrix), isinstance(a_inv, matrix)) \n```", "```py\nimport pytest\n\n@pytest.mark.skipif(SkipMyTest, reason=\"Skipping this test because...\")\ndef test_something(foo):\n    ... \n```", "```py\nimport pytest\n\n@pytest.mark.xfail(MyTestFails, reason=\"This test is known to fail because...\")\ndef test_something_else(foo):\n    ... \n```", "```py\nnumpy.test(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, durations=-1, tests=None)\n```", "```py\nfrom numpy._pytesttester import PytestTester\ntest = PytestTester(__name__).test\ndel PytestTester \n```", "```py\nclass LinalgTestCase:\n    def test_single(self):\n        a = array([[1., 2.], [3., 4.]], dtype=single)\n        b = array([2., 1.], dtype=single)\n        self.do(a, b)\n\n    def test_double(self):\n        a = array([[1., 2.], [3., 4.]], dtype=double)\n        b = array([2., 1.], dtype=double)\n        self.do(a, b)\n\n    ...\n\nclass TestSolve(LinalgTestCase):\n    def do(self, a, b):\n        x = linalg.solve(a, b)\n        assert_allclose(b, dot(a, x))\n        assert imply(isinstance(b, matrix), isinstance(x, matrix))\n\nclass TestInv(LinalgTestCase):\n    def do(self, a, b):\n        a_inv = linalg.inv(a)\n        assert_allclose(dot(a, a_inv), identity(asarray(a).shape[0]))\n        assert imply(isinstance(a, matrix), isinstance(a_inv, matrix)) \n```", "```py\nimport pytest\n\n@pytest.mark.skipif(SkipMyTest, reason=\"Skipping this test because...\")\ndef test_something(foo):\n    ... \n```", "```py\nimport pytest\n\n@pytest.mark.xfail(MyTestFails, reason=\"This test is known to fail because...\")\ndef test_something_else(foo):\n    ... \n```", "```py\nnumpy.test(label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, durations=-1, tests=None)\n```", "```py\nfrom numpy._pytesttester import PytestTester\ntest = PytestTester(__name__).test\ndel PytestTester \n```"]