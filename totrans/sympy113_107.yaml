- en: Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: The logic module for SymPy allows to form and manipulate logic expressions using
    symbolic and Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Forming logical expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can build Boolean expressions with the standard python operators `&` ([`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And")), `|` ([`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")),
    `~` ([`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not")):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also form implications with `>>` and `<<`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Like most types in SymPy, Boolean expressions inherit from [`Basic`](core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic module also includes the following functions to derive boolean expressions
    from their truth tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The SOPform function uses simplified_pairs and a redundant group- eliminating
    algorithm to convert the list of all input combos that generate ‘1’ (the minterms)
    into the smallest sum-of-products form.
  prefs: []
  type: TYPE_NORMAL
- en: The variables must be given as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Return a logical [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or") function
    (i.e., the “sum of products” or “SOP” form) that gives the desired outcome. If
    there are inputs that can be ignored, pass them as a list, too.
  prefs: []
  type: TYPE_NORMAL
- en: The result will be one of the (perhaps many) functions that satisfy the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The terms can also be represented as integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be specified using dicts, which does not have to be fully specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`POSform`](#sympy.logic.boolalg.POSform "sympy.logic.boolalg.POSform")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R600](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm](https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R601](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The POSform function uses simplified_pairs and a redundant-group eliminating
    algorithm to convert the list of all input combinations that generate ‘1’ (the
    minterms) into the smallest product-of-sums form.
  prefs: []
  type: TYPE_NORMAL
- en: The variables must be given as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Return a logical [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")
    function (i.e., the “product of sums” or “POS” form) that gives the desired outcome.
    If there are inputs that can be ignored, pass them as a list, too.
  prefs: []
  type: TYPE_NORMAL
- en: The result will be one of the (perhaps many) functions that satisfy the conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The terms can also be represented as integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be specified using dicts, which does not have to be fully specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`SOPform`](#sympy.logic.boolalg.SOPform "sympy.logic.boolalg.SOPform")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R602](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm](https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R603](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ANFform function converts the list of truth values to Algebraic Normal Form
    (ANF).
  prefs: []
  type: TYPE_NORMAL
- en: The variables must be given as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Return True, False, logical [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")
    function (i.e., the “Zhegalkin monomial”) or logical [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor") function (i.e., the “Zhegalkin polynomial”). When True
    and False are represented by 1 and 0, respectively, then [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And") is multiplication and [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor") is addition.
  prefs: []
  type: TYPE_NORMAL
- en: Formally a “Zhegalkin monomial” is the product (logical And) of a finite set
    of distinct variables, including the empty set whose product is denoted 1 (True).
    A “Zhegalkin polynomial” is the sum (logical Xor) of a set of Zhegalkin monomials,
    with the empty set denoted by 0 (False).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables** : list of variables'
  prefs: []
  type: TYPE_NORMAL
- en: '**truthvalues** : list of 1’s and 0’s (result column of truth table)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R604](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Zhegalkin_polynomial](https://en.wikipedia.org/wiki/Zhegalkin_polynomial)'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A Boolean object is an object for which logic operations make sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Rewrites Boolean expression in terms of real sets.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Returns `True` if the given formulas have the same truth table. For two formulas
    to be equal they must have the same literals.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: SymPy version of `True`, a singleton that can be accessed via `S.true`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SymPy version of `True`, for use in the logic module. The primary
    advantage of using `true` instead of `True` is that shorthand Boolean operations
    like `~` and `>>` will work as expected on this class, whereas with True they
    act bitwise on 1\. Functions in the logic module will return this class when they
    evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There is liable to be some confusion as to when `True` should be used and when
    `S.true` should be used in various contexts throughout SymPy. An important thing
    to remember is that `sympify(True)` returns `S.true`. This means that for the
    most part, you can just use `True` and it will automatically be converted to `S.true`
    when necessary, similar to how you can generally use 1 instead of `S.One`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule of thumb is:'
  prefs: []
  type: TYPE_NORMAL
- en: “If the boolean in question can be replaced by an arbitrary symbolic `Boolean`,
    like `Or(x, y)` or `x > 1`, use `S.true`. Otherwise, use `True`”
  prefs: []
  type: TYPE_NORMAL
- en: In other words, use `S.true` only on those contexts where the boolean is being
    used as a symbolic representation of truth. For example, if the object ends up
    in the `.args` of any expression, then it must necessarily be `S.true` instead
    of `True`, as elements of `.args` must be `Basic`. On the other hand, `==` is
    not a symbolic operation in SymPy, since it always returns `True` or `False`,
    and does so in terms of structural equality rather than mathematical, so it should
    return `True`. The assumptions system should use `True` and `False`. Aside from
    not satisfying the above rule of thumb, the assumptions system uses a three-valued
    logic (`True`, `False`, `None`), whereas `S.true` and `S.false` represent a two-valued
    logic. When in doubt, use `True`.
  prefs: []
  type: TYPE_NORMAL
- en: “`S.true == True is True`.”
  prefs: []
  type: TYPE_NORMAL
- en: 'While “`S.true is True`” is `False`, “`S.true == True`” is `True`, so if there
    is any doubt over whether a function or expression will return `S.true` or `True`,
    just use `==` instead of `is` to do the comparison, and it will work in either
    case. Finally, for boolean flags, it’s better to just use `if x` instead of `if
    x is True`. To quote PEP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not compare boolean values to `True` or `False` using `==`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes: `if greeting:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No: `if greeting == True:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Worse: `if greeting is True:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Python operators give a boolean result for true but a bitwise result for True
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.logic.boolalg.BooleanFalse`](#sympy.logic.boolalg.BooleanFalse "sympy.logic.boolalg.BooleanFalse")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Rewrite logic operators and relationals in terms of real sets.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: SymPy version of `False`, a singleton that can be accessed via `S.false`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SymPy version of `False`, for use in the logic module. The primary
    advantage of using `false` instead of `False` is that shorthand Boolean operations
    like `~` and `>>` will work as expected on this class, whereas with `False` they
    act bitwise on 0\. Functions in the logic module will return this class when they
    evaluate to false.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: See the notes section in [`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue
    "sympy.logic.boolalg.BooleanTrue")
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Python operators give a boolean result for false but a bitwise result for False
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue "sympy.logic.boolalg.BooleanTrue")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Rewrite logic operators and relationals in terms of real sets.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Logical AND function.
  prefs: []
  type: TYPE_NORMAL
- en: It evaluates its arguments in order, returning false immediately when an argument
    is false and true if they are all true.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The `&` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise and. Hence, `And(a,
    b)` and `a & b` will produce different results if `a` and `b` are integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Logical OR function
  prefs: []
  type: TYPE_NORMAL
- en: It evaluates its arguments in order, returning true immediately when an argument
    is true, and false if they are all false.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The `|` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise or. Hence, `Or(a, b)`
    and `a | b` will return different things if `a` and `b` are integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Logical Not function (negation)
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the statement is `false` or `False`. Returns `false` if the
    statement is `true` or `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The `~` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise not. In particular,
    `~a` and `Not(a)` will be different if `a` is an integer. Furthermore, since bools
    in Python subclass from `int`, `~True` is the same as `~1` which is `-2`, which
    has a boolean value of True. To avoid this issue, use the SymPy boolean types
    `true` and `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of Python 3.12, the bitwise not operator `~` used on a Python `bool` is deprecated
    and will emit a warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Logical XOR (exclusive OR) function.
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if an odd number of the arguments are True and the rest are False.
  prefs: []
  type: TYPE_NORMAL
- en: Returns False if an even number of the arguments are True and the rest are False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The `^` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise xor. In particular,
    `a ^ b` and `Xor(a, b)` will be different if `a` and `b` are integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Logical NAND function.
  prefs: []
  type: TYPE_NORMAL
- en: It evaluates its arguments in order, giving True immediately if any of them
    are False, and False if they are all True.
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if any of the arguments are False Returns False if all arguments
    are True
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Logical NOR function.
  prefs: []
  type: TYPE_NORMAL
- en: It evaluates its arguments in order, giving False immediately if any of them
    are True, and True if they are all False.
  prefs: []
  type: TYPE_NORMAL
- en: Returns False if any argument is True Returns True if all arguments are False
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Logical XNOR function.
  prefs: []
  type: TYPE_NORMAL
- en: Returns False if an odd number of the arguments are True and the rest are False.
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if an even number of the arguments are True and the rest are False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Logical implication.
  prefs: []
  type: TYPE_NORMAL
- en: A implies B is equivalent to if A then B. Mathematically, it is written as \(A
    \Rightarrow B\) and is equivalent to \(\neg A \vee B\) or `~A | B`.
  prefs: []
  type: TYPE_NORMAL
- en: Accepts two Boolean arguments; A and B. Returns False if A is True and B is
    False Returns True otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The `>>` and `<<` operators are provided as a convenience, but note that their
    use here is different from their normal use in Python, which is bit shifts. Hence,
    `Implies(a, b)` and `a >> b` will return different things if `a` and `b` are integers.
    In particular, since Python considers `True` and `False` to be integers, `True
    >> True` will be the same as `1 >> 1`, i.e., 0, which has a truth value of False.
    To avoid this issue, use the SymPy objects `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Equivalence relation.
  prefs: []
  type: TYPE_NORMAL
- en: '`Equivalent(A, B)` is True iff A and B are both True or both False.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if all of the arguments are logically equivalent. Returns False
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: For two arguments, this is equivalent to [`Xnor`](#sympy.logic.boolalg.Xnor
    "sympy.logic.boolalg.Xnor").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If-then-else clause.
  prefs: []
  type: TYPE_NORMAL
- en: '`ITE(A, B, C)` evaluates and returns the result of B if A is true else it returns
    the result of C. All args must be Booleans.'
  prefs: []
  type: TYPE_NORMAL
- en: From a logic gate perspective, ITE corresponds to a 2-to-1 multiplexer, where
    A is the select signal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to use non-Boolean args will generate a TypeError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: True if only one or no argument is true.
  prefs: []
  type: TYPE_NORMAL
- en: '`Exclusive(A, B, C)` is equivalent to `~(A & B) & ~(A & C) & ~(B & C)`.'
  prefs: []
  type: TYPE_NORMAL
- en: For two arguments, this is equivalent to [`Xor`](#sympy.logic.boolalg.Xor "sympy.logic.boolalg.Xor").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following functions can be used to handle Algebraic, Conjunctive, Disjunctive,
    and Negated Normal forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Converts expr to Algebraic Normal Form (ANF).
  prefs: []
  type: TYPE_NORMAL
- en: ANF is a canonical normal form, which means that two equivalent formulas will
    convert to the same ANF.
  prefs: []
  type: TYPE_NORMAL
- en: A logical expression is in ANF if it has the form
  prefs: []
  type: TYPE_NORMAL
- en: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
  prefs: []
  type: TYPE_NORMAL
- en: 'i.e. it can be:'
  prefs: []
  type: TYPE_NORMAL
- en: purely true,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: purely false,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conjunction of variables,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exclusive disjunction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exclusive disjunction can only contain true, variables or conjunction of
    variables. No negations are permitted.
  prefs: []
  type: TYPE_NORMAL
- en: If `deep` is `False`, arguments of the boolean expression are considered variables,
    i.e. only the top-level expression is converted to ANF.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert a propositional logical sentence `expr` to conjunctive normal form:
    `((A | ~B | ...) & (B | C | ...) & ...)`. If `simplify` is `True`, `expr` is evaluated
    to its simplest CNF form using the Quine-McCluskey algorithm; this may take a
    long time. If there are more than 8 variables the `force` flag must be set to
    `True` to simplify (default is `False`).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert a propositional logical sentence `expr` to disjunctive normal form:
    `((A & ~B & ...) | (B & C & ...) | ...)`. If `simplify` is `True`, `expr` is evaluated
    to its simplest DNF form using the Quine-McCluskey algorithm; this may take a
    long time. If there are more than 8 variables, the `force` flag must be set to
    `True` to simplify (default is `False`).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Converts `expr` to Negation Normal Form (NNF).
  prefs: []
  type: TYPE_NORMAL
- en: A logical expression is in NNF if it contains only [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"), and [`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not") is applied only to literals. If `simplify` is `True`,
    the result contains no redundant clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Checks if `expr` is in Algebraic Normal Form (ANF).
  prefs: []
  type: TYPE_NORMAL
- en: A logical expression is in ANF if it has the form
  prefs: []
  type: TYPE_NORMAL
- en: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
  prefs: []
  type: TYPE_NORMAL
- en: i.e. it is purely true, purely false, conjunction of variables or exclusive
    disjunction. The exclusive disjunction can only contain true, variables or conjunction
    of variables. No negations are permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Test whether or not an expression is in conjunctive normal form.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Test whether or not an expression is in disjunctive normal form.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Checks if `expr` is in Negation Normal Form (NNF).
  prefs: []
  type: TYPE_NORMAL
- en: A logical expression is in NNF if it contains only [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"), and [`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not") is applied only to literals. If `simplified` is `True`,
    checks if result contains no redundant clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Return the total number of inputs for the logic gates realizing the Boolean
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Number of gate inputs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all Boolean functions count as gate here, only those that are considered
    to be standard gates. These are: [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And"),
    [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or"), [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor"), [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"),
    and [`ITE`](#sympy.logic.boolalg.ITE "sympy.logic.boolalg.ITE") (multiplexer).
    [`Nand`](#sympy.logic.boolalg.Nand "sympy.logic.boolalg.Nand"), [`Nor`](#sympy.logic.boolalg.Nor
    "sympy.logic.boolalg.Nor"), and [`Xnor`](#sympy.logic.boolalg.Xnor "sympy.logic.boolalg.Xnor")
    will be evaluated to `Not(And())` etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Nand` is automatically evaluated to `Not(And())` so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Although this can be avoided by using `evaluate=False`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that a comparison will count as a Boolean variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'As will a symbol: >>> gateinputcount(x) 0'
  prefs: []
  type: TYPE_NORMAL
- en: Simplification and equivalence-testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This function simplifies a boolean function to its simplified version in SOP
    or POS form. The return type is an [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    or [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And") object in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: '**form** : string (`''cnf''` or `''dnf''`) or `None` (default).'
  prefs: []
  type: TYPE_NORMAL
- en: If `'cnf'` or `'dnf'`, the simplest expression in the corresponding normal form
    is returned; if `None`, the answer is returned according to the form with fewest
    args (in CNF by default).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**deep** : bool (default `True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates whether to recursively simplify any non-boolean functions contained
    within the input.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**force** : bool (default `False`)'
  prefs: []
  type: TYPE_NORMAL
- en: As the simplifications require exponential time in the number of variables,
    there is by default a limit on expressions with 8 variables. When the expression
    has more than 8 variables only symbolical simplification (controlled by `deep`)
    is made. By setting `force` to `True`, this limit is removed. Be aware that this
    can lead to very long simplification times.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**dontcare** : Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: Optimize expression under the assumption that inputs where this expression is
    true are don’t care. This is useful in e.g. Piecewise conditions, where later
    conditions do not need to consider inputs that are converted by previous conditions.
    For example, if a previous condition is `And(A, B)`, the simplification of expr
    can be made with don’t cares for `And(A, B)`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R605](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy’s [`simplify()`](simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") function can also be used to simplify logic
    expressions to their simplest forms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Return the simplified version of *bool1*, and the mapping of variables that
    makes the two expressions *bool1* and *bool2* represent the same logical behaviour
    for some correspondence between the variables of each. If more than one mappings
    of this sort exist, one of them is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `And(x, y)` is logically equivalent to `And(a, b)` for the mapping
    `{x: a, y: b}` or `{x: b, y: a}`. If no such mapping exists, return `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are not necessarily unique, but they are canonical. Here, `(w,
    z)` could be `(a, d)` or `(d, a)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following functions can be used to manipulate Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Given a sentence `expr` consisting of conjunctions and disjunctions of literals,
    return an equivalent sentence in CNF.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Given a sentence `expr` consisting of conjunctions and disjunctions of literals,
    return an equivalent sentence in DNF.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output is NOT simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Given a sentence `expr` consisting of conjunction and exclusive disjunctions
    of literals, return an equivalent exclusive disjunction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output is NOT simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Change [`Implies`](#sympy.logic.boolalg.Implies "sympy.logic.boolalg.Implies")
    and [`Equivalent`](#sympy.logic.boolalg.Equivalent "sympy.logic.boolalg.Equivalent")
    into [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or"), and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not").
    That is, return an expression that is equivalent to `expr`, but has only `&`,
    `|`, and `~` as logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Truth tables and related functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to create a truth table for a Boolean function with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Return a generator of all possible configurations of the input variables, and
    the result of the boolean expression for those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : Boolean expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables** : list of variables'
  prefs: []
  type: TYPE_NORMAL
- en: '**input** : bool (default `True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates whether to return the input combinations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If `input` is `False`, `truth_table` returns only a list of truth values. In
    this case, the corresponding input values of variables can be deduced from the
    index of a given output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'For mapping between integer representations of truth table positions, lists
    of zeros and ones and symbols, the following functions can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of length `bits` corresponding to the binary value of `n` with
    small bits to the right (last). If bits is omitted, the length will be the number
    required to represent `n`. If the bits are desired in reversed order, use the
    `[::-1]` slice of the returned list.
  prefs: []
  type: TYPE_NORMAL
- en: If a sequence of all bits-length lists starting from `[0, 0,..., 0]` through
    `[1, 1, ..., 1]` are desired, pass a non-integer for bits, e.g. `'all'`.
  prefs: []
  type: TYPE_NORMAL
- en: If the bit *string* is desired pass `str=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'If all lists corresponding to 0 to 2**n - 1, pass a non-integer for bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'If a bit string is desired of a given length, use str=True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Return an integer corresponding to the base-2 digits given by *term*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**term** : a string or list of ones and zeros'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Return the k-th maxterm.
  prefs: []
  type: TYPE_NORMAL
- en: Each maxterm is assigned an index based on the opposite conventional binary
    encoding used for minterms. The maxterm convention assigns the value 0 to the
    direct form and 1 to the complemented form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : int or list of 1’s and 0’s (complementation pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables** : list of variables'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R606](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms](https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return the k-th minterm.
  prefs: []
  type: TYPE_NORMAL
- en: Minterms are numbered by a binary encoding of the complementation pattern of
    the variables. This convention assigns the value 1 to the direct form and 0 to
    the complemented form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : int or list of 1’s and 0’s (complementation pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables** : list of variables'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R607](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms](https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return the k-th monomial.
  prefs: []
  type: TYPE_NORMAL
- en: Monomials are numbered by a binary encoding of the presence and absences of
    the variables. This convention assigns the value 1 to the presence of variable
    and 0 to the absence of variable.
  prefs: []
  type: TYPE_NORMAL
- en: Each boolean function can be uniquely represented by a Zhegalkin Polynomial
    (Algebraic Normal Form). The Zhegalkin Polynomial of the boolean function with
    \(n\) variables can contain up to \(2^n\) monomials. We can enumerate all the
    monomials. Each monomial is fully specified by the presence or absence of each
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, boolean function with four variables `(a, b, c, d)` can contain
    up to \(2^4 = 16\) monomials. The 13-th monomial is the product `a & b & d`, because
    13 in binary is 1, 1, 0, 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : int or list of 1’s and 0’s'
  prefs: []
  type: TYPE_NORMAL
- en: '**variables** : list of variables'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Convert a list of truth values of some boolean expression to the list of coefficients
    of the polynomial mod 2 (exclusive disjunction) representing the boolean expression
    in ANF (i.e., the “Zhegalkin polynomial”).
  prefs: []
  type: TYPE_NORMAL
- en: There are \(2^n\) possible Zhegalkin monomials in \(n\) variables, since each
    monomial is fully specified by the presence or absence of each variable.
  prefs: []
  type: TYPE_NORMAL
- en: We can enumerate all the monomials. For example, boolean function with four
    variables `(a, b, c, d)` can contain up to \(2^4 = 16\) monomials. The 13-th monomial
    is the product `a & b & d`, because 13 in binary is 1, 1, 0, 1.
  prefs: []
  type: TYPE_NORMAL
- en: A given monomial’s presence or absence in a polynomial corresponds to that monomial’s
    coefficient being 1 or 0 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Takes clauses in CNF format and puts them into an integer representation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '## Inference'
  prefs: []
  type: TYPE_NORMAL
- en: This module implements some inference routines in propositional logic.
  prefs: []
  type: TYPE_NORMAL
- en: The function satisfiable will test that a given Boolean expression is satisfiable,
    that is, you can assign values to the variables to make the sentence `True`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the expression `x & ~x` is not satisfiable, since there are no
    values for `x` that make this sentence `True`. On the other hand, `(x | y) & (x
    | ~y) & (~x | y)` is satisfiable with both `x` and `y` being `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: As you see, when a sentence is satisfiable, it returns a model that makes that
    sentence `True`. If it is not satisfiable it will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Check satisfiability of a propositional sentence. Returns a model when it succeeds.
    Returns {true: true} for trivially true expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: On setting all_models to True, if given expr is satisfiable then returns a generator
    of models. However, if expr is unsatisfiable then returns a generator containing
    the single element False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
