["```py\n>>> help(integrate)\n Methods for Integrating Functions given function object.\n\n quad          -- General purpose integration.\n dblquad       -- General purpose double integration.\n tplquad       -- General purpose triple integration.\n fixed_quad    -- Integrate func(x) using Gaussian quadrature of order n.\n quadrature    -- Integrate with given tolerance using Gaussian quadrature.\n romberg       -- Integrate func using Romberg integration.\n\n Methods for Integrating Functions given fixed samples.\n\n trapezoid            -- Use trapezoidal rule to compute integral.\n cumulative_trapezoid -- Use trapezoidal rule to cumulatively compute integral.\n simpson              -- Use Simpson's rule to compute integral from samples.\n romb                 -- Use Romberg Integration to compute integral from\n -- (2**k + 1) evenly-spaced samples.\n\n See the special module's orthogonal polynomials (special) for Gaussian\n quadrature roots and weights for other weighting factors and regions.\n\n Interface to numerical integrators of ODE systems.\n\n odeint        -- General integration of ordinary differential equations.\n ode           -- Integrate ODE using VODE and ZVODE routines. \n```", "```py\n>>> import scipy.integrate as integrate\n>>> import scipy.special as special\n>>> result = integrate.quad(lambda x: special.jv(2.5,x), 0, 4.5)\n>>> result\n(1.1178179380783249, 7.8663172481899801e-09) \n```", "```py\n>>> from numpy import sqrt, sin, cos, pi\n>>> I = sqrt(2/pi)*(18.0/27*sqrt(2)*cos(4.5) - 4.0/27*sqrt(2)*sin(4.5) +\n...                 sqrt(2*pi) * special.fresnel(3/sqrt(pi))[0])\n>>> I\n1.117817938088701 \n```", "```py\n>>> print(abs(result[0]-I))\n1.03761443881e-11 \n```", "```py\n>>> from scipy.integrate import quad\n>>> def integrand(x, a, b):\n...     return a*x**2 + b\n...\n>>> a = 2\n>>> b = 1\n>>> I = quad(integrand, 0, 1, args=(a,b))\n>>> I\n(1.6666666666666667, 1.8503717077085944e-14) \n```", "```py\n>>> from scipy.integrate import quad\n>>> import numpy as np\n>>> def integrand(t, n, x):\n...     return np.exp(-x*t) / t**n\n... \n```", "```py\n>>> def expint(n, x):\n...     return quad(integrand, 1, np.inf, args=(n, x))[0]\n... \n```", "```py\n>>> vec_expint = np.vectorize(expint) \n```", "```py\n>>> vec_expint(3, np.arange(1.0, 4.0, 0.5))\narray([ 0.1097,  0.0567,  0.0301,  0.0163,  0.0089,  0.0049])\n>>> import scipy.special as special\n>>> special.expn(3, np.arange(1.0,4.0,0.5))\narray([ 0.1097,  0.0567,  0.0301,  0.0163,  0.0089,  0.0049]) \n```", "```py\n>>> result = quad(lambda x: expint(3, x), 0, np.inf)\n>>> print(result)\n(0.33333333324560266, 2.8548934485373678e-09) \n```", "```py\n>>> I3 = 1.0/3.0\n>>> print(I3)\n0.333333333333 \n```", "```py\n>>> print(I3 - result[0])\n8.77306560731e-11 \n```", "```py\n>>> def gaussian(x):\n...     return np.exp(-x**2)\n>>> res = integrate.quad(gaussian, -np.inf, np.inf)\n>>> res\n(1.7724538509055159, 1.4202636756659625e-08)\n>>> np.allclose(res[0], np.sqrt(np.pi))  # compare against theoretical result\nTrue \n```", "```py\n>>> integrate.quad(gaussian, -10000, 10000)\n(1.975190562208035e-203, 0.0) \n```", "```py\n>>> integrate.quad(gaussian, -15, 15)\n(1.772453850905516, 8.476526631214648e-11) \n```", "```py\n>>> from scipy.integrate import quad, dblquad\n>>> def I(n):\n...     return dblquad(lambda t, x: np.exp(-x*t)/t**n, 0, np.inf, lambda x: 1, lambda x: np.inf)\n... \n```", "```py\n>>> print(I(4))\n(0.2500000000043577, 1.29830334693681e-08)\n>>> print(I(3))\n(0.33333333325010883, 1.3888461883425516e-08)\n>>> print(I(2))\n(0.4999999999985751, 1.3894083651858995e-08) \n```", "```py\n>>> from scipy.integrate import dblquad\n>>> area = dblquad(lambda x, y: x*y, 0, 0.5, lambda x: 0, lambda x: 1-2*x)\n>>> area\n(0.010416666666666668, 1.1564823173178715e-16) \n```", "```py\n>>> from scipy import integrate\n>>> N = 5\n>>> def f(t, x):\n...    return np.exp(-x*t) / t**N\n...\n>>> integrate.nquad(f, [[1, np.inf],[0, np.inf]])\n(0.20000000000002294, 1.2239614263187945e-08) \n```", "```py\n>>> from scipy import integrate\n>>> def f(x, y):\n...     return x*y\n...\n>>> def bounds_y():\n...     return [0, 0.5]\n...\n>>> def bounds_x(y):\n...     return [0, 1-2*y]\n...\n>>> integrate.nquad(f, [bounds_x, bounds_y])\n(0.010416666666666668, 4.101620128472366e-16) \n```", "```py\n>>> import numpy as np\n>>> def f1(x):\n...    return x**2\n...\n>>> def f2(x):\n...    return x**3\n...\n>>> x = np.array([1,3,4])\n>>> y1 = f1(x)\n>>> from scipy import integrate\n>>> I1 = integrate.simpson(y1, x)\n>>> print(I1)\n21.0 \n```", "```py\n>>> y2 = f2(x)\n>>> I2 = integrate.simpson(y2, x)\n>>> print(I2)\n61.5 \n```", "```py\n/* testlib.c */\ndouble  f(int  n,  double  *x,  void  *user_data)  {\n  double  c  =  *(double  *)user_data;\n  return  c  +  x[0]  -  x[1]  *  x[2];  /* corresponds to c + x - y * z */\n} \n```", "```py\n$ gcc -shared -fPIC -o testlib.so testlib.c \n```", "```py\nimport os, ctypes\nfrom scipy import integrate, LowLevelCallable\n\nlib = ctypes.CDLL(os.path.abspath('testlib.so'))\nlib.f.restype = ctypes.c_double\nlib.f.argtypes = (ctypes.c_int, ctypes.POINTER(ctypes.c_double), ctypes.c_void_p)\n\nc = ctypes.c_double(1.0)\nuser_data = ctypes.cast(ctypes.pointer(c), ctypes.c_void_p)\n\nfunc = LowLevelCallable(lib.f, user_data) \n```", "```py\n>>> integrate.nquad(func, [[0, 10], [-10, 0], [-1, 1]])\n(1200.0, 1.1102230246251565e-11) \n```", "```py\n>>> from scipy.integrate import solve_ivp\n>>> from scipy.special import gamma, airy\n>>> y1_0 = +1 / 3**(2/3) / gamma(2/3)\n>>> y0_0 = -1 / 3**(1/3) / gamma(1/3)\n>>> y0 = [y0_0, y1_0]\n>>> def func(t, y):\n...     return [t*y[1],y[0]]\n...\n>>> t_span = [0, 4]\n>>> sol1 = solve_ivp(func, t_span, y0)\n>>> print(\"sol1.t: {}\".format(sol1.t))\nsol1.t:    [0\\.         0.10097672 1.04643602 1.91060117 2.49872472 3.08684827\n 3.62692846 4\\.        ] \n```", "```py\n>>> print(\"sol1.y[1]: {}\".format(sol1.y[1]))\nsol1.y[1]: [0.35502805 0.328952   0.12801343 0.04008508 0.01601291 0.00623879\n 0.00356316 0.00405982]\n>>> print(\"airy(sol.t)[0]: {}\".format(airy(sol1.t)[0]))\nairy(sol.t)[0]: [0.35502805 0.328952   0.12804768 0.03995804 0.01575943 0.00562799\n 0.00201689 0.00095156] \n```", "```py\n>>> rtol, atol = (1e-8, 1e-8)\n>>> sol2 = solve_ivp(func, t_span, y0, rtol=rtol, atol=atol)\n>>> print(\"sol2.y[1][::6]: {}\".format(sol2.y[1][0::6]))\nsol2.y[1][::6]: [0.35502805 0.19145234 0.06368989 0.0205917  0.00554734 0.00106409]\n>>> print(\"airy(sol2.t)[0][::6]: {}\".format(airy(sol2.t)[0][::6]))\nairy(sol2.t)[0][::6]: [0.35502805 0.19145234 0.06368989 0.0205917  0.00554733 0.00106406] \n```", "```py\n>>> import numpy as np\n>>> t = np.linspace(0, 4, 100)\n>>> sol3 = solve_ivp(func, t_span, y0, t_eval=t) \n```", "```py\n>>> def gradient(t, y):\n...     return [[0,t], [1,0]]\n>>> sol4 = solve_ivp(func, t_span, y0, method='Radau', jac=gradient) \n```", "```py\ndef G(u, v, f, k):\n    return f * (1 - u) - u*v**2\n\ndef H(u, v, f, k):\n    return -(f + k) * v + u*v**2 \n```", "```py\ndef grayscott1d(y, t, f, k, Du, Dv, dx):\n  \"\"\"\n Differential equations for the 1-D Gray-Scott equations.\n\n The ODEs are derived using the method of lines.\n \"\"\"\n    # The vectors u and v are interleaved in y.  We define\n    # views of u and v by slicing y.\n    u = y[::2]\n    v = y[1::2]\n\n    # dydt is the return value of this function.\n    dydt = np.empty_like(y)\n\n    # Just like u and v are views of the interleaved vectors\n    # in y, dudt and dvdt are views of the interleaved output\n    # vectors in dydt.\n    dudt = dydt[::2]\n    dvdt = dydt[1::2]\n\n    # Compute du/dt and dv/dt.  The end points and the interior points\n    # are handled separately.\n    dudt[0]    = G(u[0],    v[0],    f, k) + Du * (-2.0*u[0] + 2.0*u[1]) / dx**2\n    dudt[1:-1] = G(u[1:-1], v[1:-1], f, k) + Du * np.diff(u,2) / dx**2\n    dudt[-1]   = G(u[-1],   v[-1],   f, k) + Du * (- 2.0*u[-1] + 2.0*u[-2]) / dx**2\n    dvdt[0]    = H(u[0],    v[0],    f, k) + Dv * (-2.0*v[0] + 2.0*v[1]) / dx**2\n    dvdt[1:-1] = H(u[1:-1], v[1:-1], f, k) + Dv * np.diff(v,2) / dx**2\n    dvdt[-1]   = H(u[-1],   v[-1],   f, k) + Dv * (-2.0*v[-1] + 2.0*v[-2]) / dx**2\n\n    return dydt \n```", "```py\nIn [30]: rng = np.random.default_rng()\n\nIn [31]: y0 = rng.standard_normal(5000)\n\nIn [32]: t = np.linspace(0, 50, 11)\n\nIn [33]: f = 0.024\n\nIn [34]: k = 0.055\n\nIn [35]: Du = 0.01\n\nIn [36]: Dv = 0.005\n\nIn [37]: dx = 0.025 \n```", "```py\nIn [38]: %timeit sola = odeint(grayscott1d, y0, t, args=(f, k, Du, Dv, dx))\n1 loop, best of 3: 25.2 s per loop \n```", "```py\nIn [39]: %timeit solb = odeint(grayscott1d, y0, t, args=(f, k, Du, Dv, dx), ml=2, mu=2)\n10 loops, best of 3: 191 ms per loop \n```", "```py\nIn [41]: np.allclose(sola, solb)\nOut[41]: True \n```"]