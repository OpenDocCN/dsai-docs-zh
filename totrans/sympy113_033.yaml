- en: Solve a Matrix Equation Algebraically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/solve-matrix-equation.html](https://docs.sympy.org/latest/guides/solving/solve-matrix-equation.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use SymPy to solve a matrix (linear) equation. For example, solving \( \left[\begin{array}{cc}
    c & d\\1 & -e\end{array}\right] \left[\begin{array}{cc} x\\y\end{array}\right]
    = \left[\begin{array}{cc} 2\\0\end{array}\right] \) yields \( \left[\begin{array}{cc}
    x\\y\end{array}\right] = \left[\begin{array}{cc} \frac{2e}{ce+d}\\\frac{2}{ce+d}\end{array}\right]\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Consider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your matrix and constant vector contain only numbers, not symbols, for example
    \(\left[\begin{array}{cc} 1 & 2\\3 & 4\end{array}\right] \left[\begin{array}{cc}
    x\\y\end{array}\right] = \left[\begin{array}{cc} 2\\0\end{array}\right]\), you
    can use one of these other free and open-source packages instead of SymPy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy’s [`numpy.linalg.solve()`](https://numpy.org/doc/stable/reference/generated/numpy.linalg.solve.html#numpy.linalg.solve
    "(in NumPy v1.26)")
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy’s [`scipy.linalg.solve()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve
    "(in SciPy v1.13.1)")
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: mpmath’s [lu_solve()](https://mpmath.org/doc/current/matrices.html#linear-equations)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving a matrix equation is equivalent to solving a system of linear equations,
    so if you prefer you can [Solve a System of Equations Algebraically](solve-system-of-equations-algebraically.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you formulated your problem as a system of linear equations, and want to
    convert it to matrix form, you can use [`linear_eq_to_matrix()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.linear_eq_to_matrix
    "sympy.solvers.solveset.linear_eq_to_matrix") and then follow the procedures in
    this guide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve a Matrix Equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is an example of solving a matrix equation with SymPy’s [`sympy.matrices.matrixbase.MatrixBase.solve()`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.solve
    "sympy.matrices.matrixbase.MatrixBase.solve"). We use the standard matrix equation
    formulation \(Ax=b\) where
  prefs: []
  type: TYPE_NORMAL
- en: \(A\) is the matrix representing the coefficients in the linear equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(x\) is the column vector of unknowns to be solved for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(b\) is the column vector of constants, where each row is the value of an equation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Guidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrix Usually Must Be Square
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The matrix \(A\) usually must be square to represent a system of linear equations
    with the same number of unknowns as equations. If not, SymPy will give the error
    ``ShapeError: `self` and `rhs` must have the same number of rows.``'
  prefs: []
  type: TYPE_NORMAL
- en: The exception to the requirement that a matrix be square comes from SymPy’s
    use of the [`Moore-Penrose pseudoinverse`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.pinv
    "sympy.matrices.matrixbase.MatrixBase.pinv").
  prefs: []
  type: TYPE_NORMAL
- en: Methods for Solving Matrix Equations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SymPy’s matrix solving method, [`sympy.matrices.matrixbase.MatrixBase.solve()`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.solve
    "sympy.matrices.matrixbase.MatrixBase.solve"), can use several different methods,
    which are listed at that API reference link. Depending on the nature of the matrix,
    a given method may be more efficient. By default, [Gauss-Jordan elimination](https://en.wikipedia.org/wiki/Gaussian_elimination)
    will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a method in solve is equivalent to using a specialized solving function.
    For example, using `solve` with `method='LU'` calls [`LUsolve()`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve").
  prefs: []
  type: TYPE_NORMAL
- en: Solving Several Matrix Equations With the Same Matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to repeatedly solve matrix equations with the same matrix \(A\)
    but different constant vectors \(b\), it is more efficient to use one of the following
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition)
    via [`LUsolve()`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach is to compute the inverse matrix, but this is almost always
    slower, and significantly slower for larger matrices. If efficient computation
    is not a priority, you can use [`inv()`](../../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.inv
    "sympy.matrices.matrixbase.MatrixBase.inv"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Determining the inverse of a large symbolic matrix may not be computationally
    tractable.
  prefs: []
  type: TYPE_NORMAL
- en: Work With Symbolic Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The computational complexity of manipulating symbolic matrices can increase
    rapidly with matrix size. For example, the number of terms in the determinant
    of a symbolic matrix increases with the factorial of the matrix dimension. As
    a result, the maximum dimensionality of matrices that can be solved is more limited
    than for numerical matrices. For example, the determinant of this 4x4 symbolic
    matrix has 24 terms with four elements in each term:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and solving a matrix equation of it takes about a minute, whereas the analogous
    3x3 matrix takes less than one second. The more unrelated, symbolic entries in
    a matrix, the more likely it is to be slow to manipulate. This example, finding
    a general solution to a matrix where all elements are independent symbols, is
    the extreme case and thus the slowest for a matrix of its size.
  prefs: []
  type: TYPE_NORMAL
- en: Speed up Solving Matrix Equations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: If matrix elements are zero, ensure that they are recognized as zero. You can
    do this by either making them zero or by applying [assumptions](../../modules/assumptions/index.html#assumptions-module).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a solve method suited to the properties of the matrix, for example
    hermitian, symmetric, or triangular. Refer to [Methods for Solving Matrix Equations](#methods-for-solving-matrix-equations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the [`DomainMatrix`](../../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") class, which can be faster to
    operate on because it limits the domain of matrix elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Solution Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Solution as a Vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the solution result as a vector. For example, to prove that the
    solution \(x\) is correct, you can multiply it the matrix \(A\) and verify that
    it produces the constants vector \(b\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we had to use [`simplify()`](../../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") to make SymPy simplify the expression in a
    matrix element to make it immediately obvious that the solution is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Extract Elements From the Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you can iterate through the elements in a column vector, you can extract
    its elements using standard Python techniques. For example, you can create a list
    of the elements using list comprehension
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: or you can extract individual elements by subscripting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Equations With No Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the determinant of a matrix is zero, matrix equations with it have no solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find a bug with matrix-solving functions, please post the problem on
    the [SymPy mailing list](https://groups.google.com/g/sympy). Until the issue is
    resolved, you can use a different method listed in [Alternatives to Consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
