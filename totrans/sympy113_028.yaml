- en: Solve an Equation Algebraically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/solve-equation-algebraically.html](https://docs.sympy.org/latest/guides/solving/solve-equation-algebraically.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use SymPy to solve an equation algebraically (symbolically). For example, solving
    \(x^2 = y\) for \(x\) yields \(x \in \{-\sqrt{y},\sqrt{y}\}\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to consider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy can also [solve many other types of problems including sets of equations](index.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some equations cannot be solved algebraically (either at all or by SymPy), so
    you may have to [`solve your equation numerically`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve
    "sympy.solvers.solvers.nsolve") instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two high-level functions to solve equations, [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset"). Here is an example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are recommendations on when to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to get explicit symbolic representations of the different values a
    variable could take that would satisfy the equation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to substitute those explicit solution values into other equations or
    expressions involving the same variable using [`subs()`](../../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs")
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to represent the solutions in a mathematically precise way, using [mathematical
    sets](../../modules/sets.html).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want a representation of all the solutions, including if there are infinitely
    many.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want a consistent input interface.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to limit the domain of the solutions to any arbitrary set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You do not need to programmatically extract solutions from the solution set:
    solution sets cannot necessarily be interrogated programmatically.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Include the Variable to be Solved for in the Function Call](solving-guidance.html#include-the-variable-to-be-solved-for-in-the-function-call)
    and [Ensure Consistent Formatting From solve()](solving-guidance.html#ensure-consistent-formatting-from-solve).
  prefs: []
  type: TYPE_NORMAL
- en: Solve an Equation Algebraically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can solve an equation in several ways. The examples below demonstrate using
    both [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") where applicable. You can choose the function
    best suited to your equation.
  prefs: []
  type: TYPE_NORMAL
- en: Make Your Equation Into an Expression That Equals Zero
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the fact that any expression not in an `Eq` (equation) is automatically
    assumed to equal zero (0) by the solving functions. You can rearrange the equation
    \(x^2 = y\) to \(x^2 - y = 0\), and solve that expression. This approach is convenient
    if you are interactively solving an expression which already equals zero, or an
    equation that you do not mind rearranging to \(expression = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Put Your Equation Into `Eq` Form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Put your equation into `Eq` form, then solve the `Eq`. This approach is convenient
    if you are interactively solving an equation which you already have in the form
    of an equation, or which you think of as an equality. It also helps to prevent
    sign errors when subtracting one side from the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Restrict the Domain of Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, SymPy will return solutions in the complex domain, which also includes
    purely real and imaginary values. Here, the first two solutions are real, and
    the last two are imaginary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To restrict returned solutions to real numbers, or another domain or range,
    the different solving functions use different methods.
  prefs: []
  type: TYPE_NORMAL
- en: For [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"), place an assumption on the symbol to be solved
    for, \(x\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'or restrict the solutions with standard Python techniques for filtering a list
    such as a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset"), limit the output domain in the function call
    by setting a domain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or by restricting returned solutions to any arbitrary set, including an interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'and if you restrict the solutions to a domain in which there are no solutions,
    [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") will return the empty set, [EmptySet](../../modules/sets.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly Represent Infinite Sets of Possible Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") [can represent infinite sets of possible solutions](../../modules/solvers/solveset.html#why-solveset)
    and express them in standard mathematical notation, for example \(\sin(x) = 0\)
    for \(x = n * \pi\) for every integer value of \(n\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will return only a finite number of solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") tries to return just enough solutions so that all
    (infinitely many) solutions can generated from the returned solutions by adding
    integer multiples of the [`periodicity()`](../../modules/calculus/index.html#sympy.calculus.util.periodicity
    "sympy.calculus.util.periodicity") of the equation, here \(2\pi\).'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Solution Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Substitute Solutions From [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") Into an Expression
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can substitute solutions from [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") into an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use case is finding the critical points and values for a function
    \(f\). At the critical points, the [`Derivative`](../../modules/core.html#sympy.core.function.Derivative
    "sympy.core.function.Derivative") equals zero (or is undefined). You can then
    obtain the function values at those critical points by substituting the critical
    points back into the function using [`subs()`](../../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs"). You can also tell if the critical point is a maxima
    or minima by substituting the values into the expression for the second derivative:
    a negative value indicates a maximum, and a positive value indicates a minimum.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") Solution Sets Cannot Necessarily Be Interrogated
    Programmatically'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") returns a finite set (class [`FiniteSet`](../../modules/sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet")), you can iterate through the solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for more complex results, it may not be possible to list the solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it is because, if \(y\) is negative, its square root would be
    imaginary rather than real and therefore outside the declared domain of the solution
    set. By declaring \(y\) to be real and positive, SymPy can determine that its
    square root is real, and thus resolve the intersection between the solutions and
    the set of real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can extract the sets from the solution set using [`args`](../../modules/core.html#sympy.core.basic.Basic.args
    "sympy.core.basic.Basic.args"), then create a list from the set containing the
    symbolic solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Options That Can Speed up [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [solving guidance](solving-guidance.html#options-that-can-speed-up-solve).
  prefs: []
  type: TYPE_NORMAL
- en: Not All Equations Can Be Solved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equations With No Closed-Form Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some equations have no closed-form solution, in which case SymPy may return
    an empty set or give an error. For example, the following [transcendental equation](https://en.wikipedia.org/wiki/Transcendental_equation)
    has no closed-form solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Equations Which Have a Closed-Form Solution, and SymPy Cannot Solve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible that there is an algebraic solution to your equation, and
    SymPy has not implemented an appropriate algorithm. If that happens, or SymPy
    returns an empty set or list when there is a mathematical solution (indicating
    a bug in SymPy), please post it on the [mailing list](https://groups.google.com/g/sympy),
    or open an issue on [SymPy’s GitHub page](https://github.com/sympy/sympy/issues).
    Until the issue is resolved, you can [`solve your equation numerically`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve
    "sympy.solvers.solvers.nsolve") instead.
  prefs: []
  type: TYPE_NORMAL
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find a bug with a solving function, please post the problem on the [SymPy
    mailing list](https://groups.google.com/g/sympy). Until the issue is resolved,
    you can use a different method listed in [Alternatives to consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
