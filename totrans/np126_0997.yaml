- en: numpy.percentile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.percentile.html](https://numpy.org/doc/1.26/reference/generated/numpy.percentile.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute the q-th percentile of the data along the specified axis.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the q-th percentile(s) of the array elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**array_like of real numbers'
  prefs: []
  type: TYPE_NORMAL
- en: Input array or object that can be converted to an array.
  prefs: []
  type: TYPE_NORMAL
- en: '**q**array_like of float'
  prefs: []
  type: TYPE_NORMAL
- en: Percentage or sequence of percentages for the percentiles to compute. Values
    must be between 0 and 100 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**{int, tuple of int, None}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Axis or axes along which the percentiles are computed. The default is to compute
    the percentile(s) along a flattened version of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.9.0: A tuple of axes is supported'
  prefs: []
  type: TYPE_NORMAL
- en: '**out**ndarray, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative output array in which to place the result. It must have the same
    shape and buffer length as the expected output, but the type (of the output) will
    be cast if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_input**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, then allow the input array *a* to be modified by intermediate calculations,
    to save memory. In this case, the contents of the input *a* after this function
    completes is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter specifies the method to use for estimating the percentile. There
    are many different methods, some unique to NumPy. See the notes for explanation.
    The options sorted by their R type as summarized in the H&F paper [[1]](#r08bde0ebf37b-1)
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘inverted_cdf’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘averaged_inverted_cdf’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘closest_observation’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘interpolated_inverted_cdf’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘hazen’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘weibull’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘linear’ (default)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘median_unbiased’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‘normal_unbiased’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first three methods are discontinuous. NumPy further defines the following
    discontinuous variations of the default ‘linear’ (7.) option:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘lower’
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘higher’,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘midpoint’
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘nearest’
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 1.22.0: This argument was previously called “interpolation”
    and only offered the “linear” default and last four options.'
  prefs: []
  type: TYPE_NORMAL
- en: '**keepdims**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If this is set to True, the axes which are reduced are left in the result as
    dimensions with size one. With this option, the result will broadcast correctly
    against the original array *a*.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.9.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**interpolation**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated name for the method keyword argument.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.22.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**percentile**scalar or ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: If *q* is a single percentile and *axis=None*, then the result is a scalar.
    If multiple percentiles are given, first axis of the result corresponds to the
    percentiles. The other axes are the axes that remain after the reduction of *a*.
    If the input contains integers or floats smaller than `float64`, the output data-type
    is `float64`. Otherwise, the output data-type is the same as that of the input.
    If *out* is specified, that array is returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`mean`](numpy.mean.html#numpy.mean "numpy.mean")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`median`](numpy.median.html#numpy.median "numpy.median")'
  prefs: []
  type: TYPE_NORMAL
- en: equivalent to `percentile(..., 50)`
  prefs: []
  type: TYPE_NORMAL
- en: '[`nanpercentile`](numpy.nanpercentile.html#numpy.nanpercentile "numpy.nanpercentile")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](numpy.quantile.html#numpy.quantile "numpy.quantile")'
  prefs: []
  type: TYPE_NORMAL
- en: equivalent to percentile, except q in the range [0, 1].
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Given a vector `V` of length `n`, the q-th percentile of `V` is the value `q/100`
    of the way from the minimum to the maximum in a sorted copy of `V`. The values
    and distances of the two nearest neighbors as well as the *method* parameter will
    determine the percentile if the normalized ranking does not match the location
    of `q` exactly. This function is the same as the median if `q=50`, the same as
    the minimum if `q=0` and the same as the maximum if `q=100`.
  prefs: []
  type: TYPE_NORMAL
- en: The optional *method* parameter specifies the method to use when the desired
    percentile lies between two indexes `i` and `j = i + 1`. In that case, we first
    determine `i + g`, a virtual index that lies between `i` and `j`, where `i` is
    the floor and `g` is the fractional part of the index. The final result is, then,
    an interpolation of `a[i]` and `a[j]` based on `g`. During the computation of
    `g`, `i` and `j` are modified using correction constants `alpha` and `beta` whose
    choices depend on the `method` used. Finally, note that since Python uses 0-based
    indexing, the code subtracts another 1 from the index internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following formula determines the virtual index `i + g`, the location of
    the percentile in the sorted sample:'
  prefs: []
  type: TYPE_NORMAL
- en: \[i + g = (q / 100) * ( n - alpha - beta + 1 ) + alpha\]
  prefs: []
  type: TYPE_NORMAL
- en: The different methods then work as follows
  prefs: []
  type: TYPE_NORMAL
- en: 'inverted_cdf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 1 of H&F [[1]](#r08bde0ebf37b-1). This method gives discontinuous results:'
  prefs: []
  type: TYPE_NORMAL
- en: if g > 0 ; then take j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if g = 0 ; then take i
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'averaged_inverted_cdf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 2 of H&F [[1]](#r08bde0ebf37b-1). This method give discontinuous results:'
  prefs: []
  type: TYPE_NORMAL
- en: if g > 0 ; then take j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if g = 0 ; then average between bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'closest_observation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 3 of H&F [[1]](#r08bde0ebf37b-1). This method give discontinuous results:'
  prefs: []
  type: TYPE_NORMAL
- en: if g > 0 ; then take j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if g = 0 and index is odd ; then take j
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if g = 0 and index is even ; then take i
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'interpolated_inverted_cdf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 4 of H&F [[1]](#r08bde0ebf37b-1). This method give continuous results
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'hazen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 5 of H&F [[1]](#r08bde0ebf37b-1). This method give continuous results
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 1/2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 1/2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'weibull:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 6 of H&F [[1]](#r08bde0ebf37b-1). This method give continuous results
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'linear:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 7 of H&F [[1]](#r08bde0ebf37b-1). This method give continuous results
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'median_unbiased:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 8 of H&F [[1]](#r08bde0ebf37b-1). This method is probably the best method
    if the sample distribution function is unknown (see reference). This method give
    continuous results using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 1/3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 1/3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'normal_unbiased:'
  prefs: []
  type: TYPE_NORMAL
- en: 'method 9 of H&F [[1]](#r08bde0ebf37b-1). This method is probably the best method
    if the sample distribution function is known to be normal. This method give continuous
    results using:'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = 3/8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beta = 3/8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'lower:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy method kept for backwards compatibility. Takes `i` as the interpolation
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'higher:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy method kept for backwards compatibility. Takes `j` as the interpolation
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'nearest:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy method kept for backwards compatibility. Takes `i` or `j`, whichever is
    nearest.
  prefs: []
  type: TYPE_NORMAL
- en: 'midpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy method kept for backwards compatibility. Uses `(i + j) / 2`.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id1),[2](#id2),[3](#id3),[4](#id4),[5](#id5),[6](#id6),[7](#id7),[8](#id8),[9](#id9),[10](#id10))'
  prefs: []
  type: TYPE_NORMAL
- en: R. J. Hyndman and Y. Fan, “Sample quantiles in statistical packages,” The American
    Statistician, 50(4), pp. 361-365, 1996
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The different methods can be visualized graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/numpy-percentile-1.png](../Images/4cf1493b6c5d3e859ccb2b0487d3609b.png)'
  prefs: []
  type: TYPE_IMG
