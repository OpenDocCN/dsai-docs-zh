- en: scipy.optimize.fmin_l_bfgs_b
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_l_bfgs_b.html#scipy.optimize.fmin_l_bfgs_b](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_l_bfgs_b.html#scipy.optimize.fmin_l_bfgs_b)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Minimize a function func using the L-BFGS-B algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable f(x,*args)'
  prefs: []
  type: TYPE_NORMAL
- en: Function to minimize.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess.
  prefs: []
  type: TYPE_NORMAL
- en: '**fprime**callable fprime(x,*args), optional'
  prefs: []
  type: TYPE_NORMAL
- en: The gradient of *func*. If None, then *func* returns the function value and
    the gradient (`f, g = func(x, *args)`), unless *approx_grad* is True in which
    case *func* returns only `f`.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**sequence, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments to pass to *func* and *fprime*.
  prefs: []
  type: TYPE_NORMAL
- en: '**approx_grad**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to approximate the gradient numerically (in which case *func* returns
    only the function value).
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**list, optional'
  prefs: []
  type: TYPE_NORMAL
- en: '`(min, max)` pairs for each element in `x`, defining the bounds on that parameter.
    Use None or +-inf for one of `min` or `max` when there is no bound in that direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**m**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum number of variable metric corrections used to define the limited
    memory matrix. (The limited memory BFGS method does not store the full hessian
    but uses this many terms in an approximation to it.)
  prefs: []
  type: TYPE_NORMAL
- en: '**factr**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'The iteration stops when `(f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr *
    eps`, where `eps` is the machine precision, which is automatically generated by
    the code. Typical values for *factr* are: 1e12 for low accuracy; 1e7 for moderate
    accuracy; 10.0 for extremely high accuracy. See Notes for relationship to *ftol*,
    which is exposed (instead of *factr*) by the [`scipy.optimize.minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") interface to L-BFGS-B.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pgtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The iteration will stop when `max{|proj g_i | i = 1, ..., n} <= pgtol` where
    `proj g_i` is the i-th component of the projected gradient.
  prefs: []
  type: TYPE_NORMAL
- en: '**epsilon**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Step size used when *approx_grad* is True, for numerically calculating the gradient
  prefs: []
  type: TYPE_NORMAL
- en: '**iprint**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Controls the frequency of output. `iprint < 0` means no output; `iprint = 0`
    print only one line at the last iteration; `0 < iprint < 99` print also f and
    `|proj g|` every iprint iterations; `iprint = 99` print details of every iteration
    except n-vectors; `iprint = 100` print also the changes of active set and final
    x; `iprint > 100` print details of every iteration including x and g.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If zero, then no output. If a positive number, then this over-rides *iprint*
    (i.e., *iprint* gets the value of *disp*).
  prefs: []
  type: TYPE_NORMAL
- en: '**maxfun**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of function evaluations. Note that this function may violate
    the limit because of evaluating gradients by numerical differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Called after each iteration, as `callback(xk)`, where `xk` is the current parameter
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxls**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of line search steps (per iteration). Default is 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Estimated position of the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '**f**float'
  prefs: []
  type: TYPE_NORMAL
- en: Value of *func* at the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '**d**dict'
  prefs: []
  type: TYPE_NORMAL
- en: Information dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: d[‘warnflag’] is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 if converged,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 if too many function evaluations or too many iterations,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 if stopped for another reason, given in d[‘task’]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: d[‘grad’] is the gradient at the minimum (should be 0 ish)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d[‘funcalls’] is the number of function calls made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d[‘nit’] is the number of iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface to minimization algorithms for multivariate functions. See the ‘L-BFGS-B’
    *method* in particular. Note that the *ftol* option is made available via that
    interface, while *factr* is provided via this interface, where *factr* is the
    factor multiplying the default machine floating-point precision to arrive at *ftol*:
    `ftol = factr * numpy.finfo(float).eps`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'License of L-BFGS-B (FORTRAN code):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The version included here (in fortran code) is 3.0 (released April 25, 2011).
    It was written by Ciyou Zhu, Richard Byrd, and Jorge Nocedal <[nocedal@ece.nwu.edu](mailto:nocedal%40ece.nwu.edu)>.
    It carries the following condition for use:'
  prefs: []
  type: TYPE_NORMAL
- en: This software is freely available, but we expect that all publications describing
    work using this software, or all commercial products using it, quote at least
    one of the references given below. This software is released under the BSD License.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: R. H. Byrd, P. Lu and J. Nocedal. A Limited Memory Algorithm for Bound Constrained
    Optimization, (1995), SIAM Journal on Scientific and Statistical Computing, 16,
    5, pp. 1190-1208.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C. Zhu, R. H. Byrd and J. Nocedal. L-BFGS-B: Algorithm 778: L-BFGS-B, FORTRAN
    routines for large scale bound constrained optimization (1997), ACM Transactions
    on Mathematical Software, 23, 4, pp. 550 - 560.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'J.L. Morales and J. Nocedal. L-BFGS-B: Remark on Algorithm 778: L-BFGS-B, FORTRAN
    routines for large scale bound constrained optimization (2011), ACM Transactions
    on Mathematical Software, 38, 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
