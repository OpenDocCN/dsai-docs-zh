["```py\nIn [1]: arrays = [\n ...:    [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n ...:    [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n ...: ]\n ...: \n\nIn [2]: tuples = list(zip(*arrays))\n\nIn [3]: tuples\nOut[3]: \n[('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')]\n\nIn [4]: index = pd.MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"])\n\nIn [5]: index\nOut[5]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second'])\n\nIn [6]: s = pd.Series(np.random.randn(8), index=index)\n\nIn [7]: s\nOut[7]: \nfirst  second\nbar    one       0.469112\n two      -0.282863\nbaz    one      -1.509059\n two      -1.135632\nfoo    one       1.212112\n two      -0.173215\nqux    one       0.119209\n two      -1.044236\ndtype: float64 \n```", "```py\nIn [8]: iterables = [[\"bar\", \"baz\", \"foo\", \"qux\"], [\"one\", \"two\"]]\n\nIn [9]: pd.MultiIndex.from_product(iterables, names=[\"first\", \"second\"])\nOut[9]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [10]: df = pd.DataFrame(\n ....:    [[\"bar\", \"one\"], [\"bar\", \"two\"], [\"foo\", \"one\"], [\"foo\", \"two\"]],\n ....:    columns=[\"first\", \"second\"],\n ....: )\n ....: \n\nIn [11]: pd.MultiIndex.from_frame(df)\nOut[11]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('foo', 'one'),\n ('foo', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [12]: arrays = [\n ....:    np.array([\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"]),\n ....:    np.array([\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"]),\n ....: ]\n ....: \n\nIn [13]: s = pd.Series(np.random.randn(8), index=arrays)\n\nIn [14]: s\nOut[14]: \nbar  one   -0.861849\n two   -2.104569\nbaz  one   -0.494929\n two    1.071804\nfoo  one    0.721555\n two   -0.706771\nqux  one   -1.039575\n two    0.271860\ndtype: float64\n\nIn [15]: df = pd.DataFrame(np.random.randn(8, 4), index=arrays)\n\nIn [16]: df\nOut[16]: \n 0         1         2         3\nbar one -0.424972  0.567020  0.276232 -1.087401\n two -0.673690  0.113648 -1.478427  0.524988\nbaz one  0.404705  0.577046 -1.715002 -1.039268\n two -0.370647 -1.157892 -1.344312  0.844885\nfoo one  1.075770 -0.109050  1.643563 -1.469388\n two  0.357021 -0.674600 -1.776904 -0.968914\nqux one -1.294524  0.413738  0.276662 -0.472035\n two -0.013960 -0.362543 -0.006154 -0.923061 \n```", "```py\nIn [17]: df.index.names\nOut[17]: FrozenList([None, None]) \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(3, 8), index=[\"A\", \"B\", \"C\"], columns=index)\n\nIn [19]: df\nOut[19]: \nfirst        bar                 baz  ...       foo       qux \nsecond       one       two       one  ...       two       one       two\nA       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169\nB       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737\nC      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747\n\n[3 rows x 8 columns]\n\nIn [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])\nOut[20]: \nfirst              bar                 baz                 foo \nsecond             one       two       one       two       one       two\nfirst second \nbar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804\n two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734\nbaz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738\n two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849\nfoo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232\n two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441 \n```", "```py\nIn [21]: with pd.option_context(\"display.multi_sparse\", False):\n ....:    df\n ....: \n```", "```py\nIn [22]: pd.Series(np.random.randn(8), index=tuples)\nOut[22]: \n(bar, one)   -1.236269\n(bar, two)    0.896171\n(baz, one)   -0.487602\n(baz, two)   -0.082240\n(foo, one)   -2.182937\n(foo, two)    0.380396\n(qux, one)    0.084844\n(qux, two)    0.432390\ndtype: float64 \n```", "```py\nIn [23]: index.get_level_values(0)\nOut[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')\n\nIn [24]: index.get_level_values(\"second\")\nOut[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second') \n```", "```py\nIn [25]: df[\"bar\"]\nOut[25]: \nsecond       one       two\nA       0.895717  0.805244\nB       0.410835  0.813850\nC      -1.413681  1.607920\n\nIn [26]: df[\"bar\", \"one\"]\nOut[26]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64\n\nIn [27]: df[\"bar\"][\"one\"]\nOut[27]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: one, dtype: float64\n\nIn [28]: s[\"qux\"]\nOut[28]: \none   -1.039575\ntwo    0.271860\ndtype: float64 \n```", "```py\nIn [29]: df.columns.levels  # original MultiIndex\nOut[29]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']])\n\nIn [30]: df[[\"foo\",\"qux\"]].columns.levels  # sliced\nOut[30]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [31]: df[[\"foo\", \"qux\"]].columns.to_numpy()\nOut[31]: \narray([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],\n dtype=object)\n\n# for a specific level\nIn [32]: df[[\"foo\", \"qux\"]].columns.get_level_values(0)\nOut[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first') \n```", "```py\nIn [33]: new_mi = df[[\"foo\", \"qux\"]].columns.remove_unused_levels()\n\nIn [34]: new_mi.levels\nOut[34]: FrozenList([['foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [35]: s + s[:-2]\nOut[35]: \nbar  one   -1.723698\n two   -4.209138\nbaz  one   -0.989859\n two    2.143608\nfoo  one    1.443110\n two   -1.413542\nqux  one         NaN\n two         NaN\ndtype: float64\n\nIn [36]: s + s[::2]\nOut[36]: \nbar  one   -1.723698\n two         NaN\nbaz  one   -0.989859\n two         NaN\nfoo  one    1.443110\n two         NaN\nqux  one   -2.079150\n two         NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex(index[:3])\nOut[37]: \nfirst  second\nbar    one      -0.861849\n two      -2.104569\nbaz    one      -0.494929\ndtype: float64\n\nIn [38]: s.reindex([(\"foo\", \"two\"), (\"bar\", \"one\"), (\"qux\", \"one\"), (\"baz\", \"one\")])\nOut[38]: \nfoo  two   -0.706771\nbar  one   -0.861849\nqux  one   -1.039575\nbaz  one   -0.494929\ndtype: float64 \n```", "```py\nIn [39]: df = df.T\n\nIn [40]: df\nOut[40]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\n two     0.805244  0.813850  1.607920\nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n two    -0.226169 -1.436737 -2.006747\n\nIn [41]: df.loc[(\"bar\", \"two\")]\nOut[41]: \nA    0.805244\nB    0.813850\nC    1.607920\nName: (bar, two), dtype: float64 \n```", "```py\nIn [42]: df.loc[(\"bar\", \"two\"), \"A\"]\nOut[42]: 0.8052440253863785 \n```", "```py\nIn [43]: df.loc[\"bar\"]\nOut[43]: \n A         B         C\nsecond \none     0.895717  0.410835 -1.413681\ntwo     0.805244  0.813850  1.607920 \n```", "```py\nIn [44]: df.loc[\"baz\":\"foo\"]\nOut[44]: \n A         B         C\nfirst second \nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372 \n```", "```py\nIn [45]: df.loc[(\"baz\", \"two\"):(\"qux\", \"one\")]\nOut[45]: \n A         B         C\nfirst second \nbaz   two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n\nIn [46]: df.loc[(\"baz\", \"two\"):\"foo\"]\nOut[46]: \n A         B         C\nfirst second \nbaz   two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372 \n```", "```py\nIn [47]: df.loc[[(\"bar\", \"two\"), (\"qux\", \"one\")]]\nOut[47]: \n A         B         C\nfirst second \nbar   two     0.805244  0.813850  1.607920\nqux   one    -1.170299  1.130127  0.974466 \n```", "```py\nIn [48]: s = pd.Series(\n ....:    [1, 2, 3, 4, 5, 6],\n ....:    index=pd.MultiIndex.from_product([[\"A\", \"B\"], [\"c\", \"d\", \"e\"]]),\n ....: )\n ....: \n\nIn [49]: s.loc[[(\"A\", \"c\"), (\"B\", \"d\")]]  # list of tuples\nOut[49]: \nA  c    1\nB  d    5\ndtype: int64\n\nIn [50]: s.loc[([\"A\", \"B\"], [\"c\", \"d\"])]  # tuple of lists\nOut[50]: \nA  c    1\n d    2\nB  c    4\n d    5\ndtype: int64 \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...), :]  # noqa: E999 \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...)]  # noqa: E999 \n```", "```py\nIn [51]: def mklbl(prefix, n):\n ....:    return [\"%s%s\" % (prefix, i) for i in range(n)]\n ....: \n\nIn [52]: miindex = pd.MultiIndex.from_product(\n ....:    [mklbl(\"A\", 4), mklbl(\"B\", 2), mklbl(\"C\", 4), mklbl(\"D\", 2)]\n ....: )\n ....: \n\nIn [53]: micolumns = pd.MultiIndex.from_tuples(\n ....:    [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")], names=[\"lvl0\", \"lvl1\"]\n ....: )\n ....: \n\nIn [54]: dfmi = (\n ....:    pd.DataFrame(\n ....:        np.arange(len(miindex) * len(micolumns)).reshape(\n ....:            (len(miindex), len(micolumns))\n ....:        ),\n ....:        index=miindex,\n ....:        columns=micolumns,\n ....:    )\n ....:    .sort_index()\n ....:    .sort_index(axis=1)\n ....: )\n ....: \n\nIn [55]: dfmi\nOut[55]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0    9    8   11   10\n D1   13   12   15   14\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  237  236  239  238\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[64 rows x 4 columns] \n```", "```py\nIn [56]: dfmi.loc[(slice(\"A1\", \"A3\"), slice(None), [\"C1\", \"C3\"]), :]\nOut[56]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA1 B0 C1 D0   73   72   75   74\n D1   77   76   79   78\n C3 D0   89   88   91   90\n D1   93   92   95   94\n B1 C1 D0  105  104  107  106\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[24 rows x 4 columns] \n```", "```py\nIn [57]: idx = pd.IndexSlice\n\nIn [58]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[58]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [59]: dfmi.loc[\"A1\", (slice(None), \"foo\")]\nOut[59]: \nlvl0        a    b\nlvl1      foo  foo\nB0 C0 D0   64   66\n D1   68   70\n C1 D0   72   74\n D1   76   78\n C2 D0   80   82\n...       ...  ...\nB1 C1 D1  108  110\n C2 D0  112  114\n D1  116  118\n C3 D0  120  122\n D1  124  126\n\n[16 rows x 2 columns]\n\nIn [60]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[60]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [61]: mask = dfmi[(\"a\", \"foo\")] > 200\n\nIn [62]: dfmi.loc[idx[mask, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[62]: \nlvl0           a    b\nlvl1         foo  foo\nA3 B0 C1 D1  204  206\n C3 D0  216  218\n D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254 \n```", "```py\nIn [63]: dfmi.loc(axis=0)[:, :, [\"C1\", \"C3\"]]\nOut[63]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C1 D0    9    8   11   10\n D1   13   12   15   14\n C3 D0   25   24   27   26\n D1   29   28   31   30\n B1 C1 D0   41   40   43   42\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[32 rows x 4 columns] \n```", "```py\nIn [64]: df2 = dfmi.copy()\n\nIn [65]: df2.loc(axis=0)[:, :, [\"C1\", \"C3\"]] = -10\n\nIn [66]: df2\nOut[66]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  -10  -10  -10  -10\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n\n[64 rows x 4 columns] \n```", "```py\nIn [67]: df2 = dfmi.copy()\n\nIn [68]: df2.loc[idx[:, :, [\"C1\", \"C3\"]], :] = df2 * 1000\n\nIn [69]: df2\nOut[69]: \nlvl0              a               b \nlvl1            bar     foo     bah     foo\nA0 B0 C0 D0       1       0       3       2\n D1       5       4       7       6\n C1 D0    9000    8000   11000   10000\n D1   13000   12000   15000   14000\n C2 D0      17      16      19      18\n...             ...     ...     ...     ...\nA3 B1 C1 D1  237000  236000  239000  238000\n C2 D0     241     240     243     242\n D1     245     244     247     246\n C3 D0  249000  248000  251000  250000\n D1  253000  252000  255000  254000\n\n[64 rows x 4 columns] \n```", "```py\nIn [70]: df\nOut[70]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\n two     0.805244  0.813850  1.607920\nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n two    -0.226169 -1.436737 -2.006747\n\nIn [71]: df.xs(\"one\", level=\"second\")\nOut[71]: \n A         B         C\nfirst \nbar    0.895717  0.410835 -1.413681\nbaz   -1.206412  0.132003  1.024180\nfoo    1.431256 -0.076467  0.875906\nqux   -1.170299  1.130127  0.974466 \n```", "```py\n# using the slicers\nIn [72]: df.loc[(slice(None), \"one\"), :]\nOut[72]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\nbaz   one    -1.206412  0.132003  1.024180\nfoo   one     1.431256 -0.076467  0.875906\nqux   one    -1.170299  1.130127  0.974466 \n```", "```py\nIn [73]: df = df.T\n\nIn [74]: df.xs(\"one\", level=\"second\", axis=1)\nOut[74]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\n# using the slicers\nIn [75]: df.loc[:, (slice(None), \"one\")]\nOut[75]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [76]: df.xs((\"one\", \"bar\"), level=(\"second\", \"first\"), axis=1)\nOut[76]: \nfirst        bar\nsecond       one\nA       0.895717\nB       0.410835\nC      -1.413681 \n```", "```py\n# using the slicers\nIn [77]: df.loc[:, (\"bar\", \"one\")]\nOut[77]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64 \n```", "```py\nIn [78]: df.xs(\"one\", level=\"second\", axis=1, drop_level=False)\nOut[78]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [79]: df.xs(\"one\", level=\"second\", axis=1, drop_level=True)\nOut[79]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [80]: midx = pd.MultiIndex(\n ....:    levels=[[\"zero\", \"one\"], [\"x\", \"y\"]], codes=[[1, 1, 0, 0], [1, 0, 1, 0]]\n ....: )\n ....: \n\nIn [81]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)\n\nIn [82]: df\nOut[82]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [83]: df2 = df.groupby(level=0).mean()\n\nIn [84]: df2\nOut[84]: \n 0         1\none   1.060074 -0.109716\nzero  1.271532  0.713416\n\nIn [85]: df2.reindex(df.index, level=0)\nOut[85]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416\n\n# aligning\nIn [86]: df_aligned, df2_aligned = df.align(df2, level=0)\n\nIn [87]: df_aligned\nOut[87]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [88]: df2_aligned\nOut[88]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416 \n```", "```py\nIn [89]: df[:5]\nOut[89]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [90]: df[:5].swaplevel(0, 1, axis=0)\nOut[90]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [91]: df[:5].reorder_levels([1, 0], axis=0)\nOut[91]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [92]: df.rename(columns={0: \"col0\", 1: \"col1\"})\nOut[92]: \n col0      col1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [93]: df.rename(index={\"one\": \"two\", \"y\": \"z\"})\nOut[93]: \n 0         1\ntwo  z  1.519970 -0.493662\n x  0.600178  0.274230\nzero z  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [94]: df.rename_axis(index=[\"abc\", \"def\"])\nOut[94]: \n 0         1\nabc  def \none  y    1.519970 -0.493662\n x    0.600178  0.274230\nzero y    0.132885 -0.023688\n x    2.410179  1.450520 \n```", "```py\nIn [95]: df.rename_axis(columns=\"Cols\").columns\nOut[95]: RangeIndex(start=0, stop=2, step=1, name='Cols') \n```", "```py\nIn [96]: mi = pd.MultiIndex.from_product([[1, 2], [\"a\", \"b\"]], names=[\"x\", \"y\"])\n\nIn [97]: mi.names\nOut[97]: FrozenList(['x', 'y'])\n\nIn [98]: mi2 = mi.rename(\"new name\", level=0)\n\nIn [99]: mi2\nOut[99]: \nMultiIndex([(1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['new name', 'y']) \n```", "```py\nIn [100]: mi.levels[0].name = \"name via level\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[100], line 1\n----> 1 mi.levels[0].name = \"name via level\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead. \n```", "```py\nIn [101]: import random\n\nIn [102]: random.shuffle(tuples)\n\nIn [103]: s = pd.Series(np.random.randn(8), index=pd.MultiIndex.from_tuples(tuples))\n\nIn [104]: s\nOut[104]: \nqux  two    0.206053\nbar  one   -0.251905\nfoo  one   -2.213588\nqux  one    1.063327\nfoo  two    1.266143\nbaz  two    0.299368\nbar  two   -0.863838\nbaz  one    0.408204\ndtype: float64\n\nIn [105]: s.sort_index()\nOut[105]: \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [106]: s.sort_index(level=0)\nOut[106]: \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [107]: s.sort_index(level=1)\nOut[107]: \nbar  one   -0.251905\nbaz  one    0.408204\nfoo  one   -2.213588\nqux  one    1.063327\nbar  two   -0.863838\nbaz  two    0.299368\nfoo  two    1.266143\nqux  two    0.206053\ndtype: float64 \n```", "```py\nIn [108]: s.index = s.index.set_names([\"L1\", \"L2\"])\n\nIn [109]: s.sort_index(level=\"L1\")\nOut[109]: \nL1   L2 \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [110]: s.sort_index(level=\"L2\")\nOut[110]: \nL1   L2 \nbar  one   -0.251905\nbaz  one    0.408204\nfoo  one   -2.213588\nqux  one    1.063327\nbar  two   -0.863838\nbaz  two    0.299368\nfoo  two    1.266143\nqux  two    0.206053\ndtype: float64 \n```", "```py\nIn [111]: df.T.sort_index(level=1, axis=1)\nOut[111]: \n one      zero       one      zero\n x         x         y         y\n0  0.600178  2.410179  1.519970  0.132885\n1  0.274230  1.450520 -0.493662 -0.023688 \n```", "```py\nIn [112]: dfm = pd.DataFrame(\n .....:    {\"jim\": [0, 0, 1, 1], \"joe\": [\"x\", \"x\", \"z\", \"y\"], \"jolie\": np.random.rand(4)}\n .....: )\n .....: \n\nIn [113]: dfm = dfm.set_index([\"jim\", \"joe\"])\n\nIn [114]: dfm\nOut[114]: \n jolie\njim joe \n0   x    0.490671\n x    0.120248\n1   z    0.537020\n y    0.110968\n\nIn [115]: dfm.loc[(1, 'z')]\nOut[115]: \n jolie\njim joe \n1   z    0.53702 \n```", "```py\nIn [116]: dfm.loc[(0, 'y'):(1, 'z')]\n---------------------------------------------------------------------------\nUnsortedIndexError  Traceback (most recent call last)\nCell In[116], line 1\n----> 1 dfm.loc[(0, 'y'):(1, 'z')]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2904, in MultiIndex.slice_locs(self, start, end, step)\n  2852  \"\"\"\n  2853 For an ordered MultiIndex, compute the slice locations for input\n  2854 labels.\n (...)\n  2900 sequence of such.\n  2901 \"\"\"\n  2902 # This function adds nothing to its parent implementation (the magic\n  2903 # happens in get_slice_bound method), but it adds meaningful doc.\n-> 2904 return super().slice_locs(start, end, step)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n  6877 start_slice = None\n  6878 if start is not None:\n-> 6879     start_slice = self.get_slice_bound(start, \"left\")\n  6880 if start_slice is None:\n  6881     start_slice = 0\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2848, in MultiIndex.get_slice_bound(self, label, side)\n  2846 if not isinstance(label, tuple):\n  2847     label = (label,)\n-> 2848 return self._partial_tup_index(label, side=side)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2908, in MultiIndex._partial_tup_index(self, tup, side)\n  2906 def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n  2907     if len(tup) > self._lexsort_depth:\n-> 2908         raise UnsortedIndexError(\n  2909             f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n  2910             f\"({self._lexsort_depth})\"\n  2911         )\n  2913     n = len(tup)\n  2914     start, end = 0, len(self)\n\nUnsortedIndexError: 'Key length (2) was greater than MultiIndex lexsort depth (1)' \n```", "```py\nIn [117]: dfm.index.is_monotonic_increasing\nOut[117]: False \n```", "```py\nIn [118]: dfm = dfm.sort_index()\n\nIn [119]: dfm\nOut[119]: \n jolie\njim joe \n0   x    0.490671\n x    0.120248\n1   y    0.110968\n z    0.537020\n\nIn [120]: dfm.index.is_monotonic_increasing\nOut[120]: True \n```", "```py\nIn [121]: dfm.loc[(0, \"y\"):(1, \"z\")]\nOut[121]: \n jolie\njim joe \n1   y    0.110968\n z    0.537020 \n```", "```py\nIn [122]: index = pd.Index(np.random.randint(0, 1000, 10))\n\nIn [123]: index\nOut[123]: Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype='int64')\n\nIn [124]: positions = [0, 9, 3]\n\nIn [125]: index[positions]\nOut[125]: Index([214, 329, 567], dtype='int64')\n\nIn [126]: index.take(positions)\nOut[126]: Index([214, 329, 567], dtype='int64')\n\nIn [127]: ser = pd.Series(np.random.randn(10))\n\nIn [128]: ser.iloc[positions]\nOut[128]: \n0   -0.179666\n9    1.824375\n3    0.392149\ndtype: float64\n\nIn [129]: ser.take(positions)\nOut[129]: \n0   -0.179666\n9    1.824375\n3    0.392149\ndtype: float64 \n```", "```py\nIn [130]: frm = pd.DataFrame(np.random.randn(5, 3))\n\nIn [131]: frm.take([1, 4, 3])\nOut[131]: \n 0         1         2\n1 -1.237881  0.106854 -1.276829\n4  0.629675 -1.425966  1.857704\n3  0.979542 -1.633678  0.615855\n\nIn [132]: frm.take([0, 2], axis=1)\nOut[132]: \n 0         2\n0  0.595974  0.601544\n1 -1.237881 -1.276829\n2 -0.767101  1.499591\n3  0.979542  0.615855\n4  0.629675  1.857704 \n```", "```py\nIn [133]: arr = np.random.randn(10)\n\nIn [134]: arr.take([False, False, True, True])\nOut[134]: array([-1.1935, -1.1935,  0.6775,  0.6775])\n\nIn [135]: arr[[0, 1]]\nOut[135]: array([-1.1935,  0.6775])\n\nIn [136]: ser = pd.Series(np.random.randn(10))\n\nIn [137]: ser.take([False, False, True, True])\nOut[137]: \n0    0.233141\n0    0.233141\n1   -0.223540\n1   -0.223540\ndtype: float64\n\nIn [138]: ser.iloc[[0, 1]]\nOut[138]: \n0    0.233141\n1   -0.223540\ndtype: float64 \n```", "```py\nIn [139]: arr = np.random.randn(10000, 5)\n\nIn [140]: indexer = np.arange(10000)\n\nIn [141]: random.shuffle(indexer)\n\nIn [142]: %timeit arr[indexer]\n .....: %timeit arr.take(indexer, axis=0)\n .....: \n257 us +- 4.44 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each)\n79.7 us +- 1.15 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each) \n```", "```py\nIn [143]: ser = pd.Series(arr[:, 0])\n\nIn [144]: %timeit ser.iloc[indexer]\n .....: %timeit ser.take(indexer)\n .....: \n144 us +- 3.69 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each)\n129 us +- 2 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each) \n```", "```py\nIn [145]: from pandas.api.types import CategoricalDtype\n\nIn [146]: df = pd.DataFrame({\"A\": np.arange(6), \"B\": list(\"aabbca\")})\n\nIn [147]: df[\"B\"] = df[\"B\"].astype(CategoricalDtype(list(\"cab\")))\n\nIn [148]: df\nOut[148]: \n A  B\n0  0  a\n1  1  a\n2  2  b\n3  3  b\n4  4  c\n5  5  a\n\nIn [149]: df.dtypes\nOut[149]: \nA       int64\nB    category\ndtype: object\n\nIn [150]: df[\"B\"].cat.categories\nOut[150]: Index(['c', 'a', 'b'], dtype='object') \n```", "```py\nIn [151]: df2 = df.set_index(\"B\")\n\nIn [152]: df2.index\nOut[152]: CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [153]: df2.loc[\"a\"]\nOut[153]: \n A\nB \na  0\na  1\na  5 \n```", "```py\nIn [154]: df2.loc[\"a\"].index\nOut[154]: CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [155]: df2.sort_index()\nOut[155]: \n A\nB \nc  4\na  0\na  1\na  5\nb  2\nb  3 \n```", "```py\nIn [156]: df2.groupby(level=0, observed=True).sum()\nOut[156]: \n A\nB \nc  4\na  6\nb  5\n\nIn [157]: df2.groupby(level=0, observed=True).sum().index\nOut[157]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [158]: df3 = pd.DataFrame(\n .....:    {\"A\": np.arange(3), \"B\": pd.Series(list(\"abc\")).astype(\"category\")}\n .....: )\n .....: \n\nIn [159]: df3 = df3.set_index(\"B\")\n\nIn [160]: df3\nOut[160]: \n A\nB \na  0\nb  1\nc  2 \n```", "```py\nIn [161]: df3.reindex([\"a\", \"e\"])\nOut[161]: \n A\nB \na  0.0\ne  NaN\n\nIn [162]: df3.reindex([\"a\", \"e\"]).index\nOut[162]: Index(['a', 'e'], dtype='object', name='B')\n\nIn [163]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\")))\nOut[163]: \n A\nB \na  0.0\ne  NaN\n\nIn [164]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\"))).index\nOut[164]: CategoricalIndex(['a', 'e'], categories=['a', 'b', 'e'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [165]: df4 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"ba\")})\n\nIn [166]: df4[\"B\"] = df4[\"B\"].astype(CategoricalDtype(list(\"ab\")))\n\nIn [167]: df4 = df4.set_index(\"B\")\n\nIn [168]: df4.index\nOut[168]: CategoricalIndex(['b', 'a'], categories=['a', 'b'], ordered=False, dtype='category', name='B')\n\nIn [169]: df5 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"bc\")})\n\nIn [170]: df5[\"B\"] = df5[\"B\"].astype(CategoricalDtype(list(\"bc\")))\n\nIn [171]: df5 = df5.set_index(\"B\")\n\nIn [172]: df5.index\nOut[172]: CategoricalIndex(['b', 'c'], categories=['b', 'c'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [173]: pd.concat([df4, df5])\nOut[173]: \n A\nB \nb  0\na  1\nb  0\nc  1 \n```", "```py\nIn [174]: idx = pd.RangeIndex(5)\n\nIn [175]: idx\nOut[175]: RangeIndex(start=0, stop=5, step=1) \n```", "```py\nIn [176]: ser = pd.Series([1, 2, 3])\n\nIn [177]: ser.index\nOut[177]: RangeIndex(start=0, stop=3, step=1)\n\nIn [178]: df = pd.DataFrame([[1, 2], [3, 4]])\n\nIn [179]: df.index\nOut[179]: RangeIndex(start=0, stop=2, step=1)\n\nIn [180]: df.columns\nOut[180]: RangeIndex(start=0, stop=2, step=1) \n```", "```py\nIn [181]: idx[[0, 2]]\nOut[181]: Index([0, 2], dtype='int64') \n```", "```py\nIn [182]: df = pd.DataFrame(\n .....:    {\"A\": [1, 2, 3, 4]}, index=pd.IntervalIndex.from_breaks([0, 1, 2, 3, 4])\n .....: )\n .....: \n\nIn [183]: df\nOut[183]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [184]: df.loc[2]\nOut[184]: \nA    2\nName: (1, 2], dtype: int64\n\nIn [185]: df.loc[[2, 3]]\nOut[185]: \n A\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [186]: df.loc[2.5]\nOut[186]: \nA    3\nName: (2, 3], dtype: int64\n\nIn [187]: df.loc[[2.5, 3.5]]\nOut[187]: \n A\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [188]: df.loc[pd.Interval(1, 2)]\nOut[188]: \nA    2\nName: (1, 2], dtype: int64 \n```", "```py\nIn [189]: df.loc[pd.Interval(0.5, 2.5)]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[189], line 1\n----> 1 df.loc[pd.Interval(0.5, 2.5)]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1431, in _LocIndexer._getitem_axis(self, key, axis)\n  1429 # fall thru to straight lookup\n  1430 self._validate_key(key, axis)\n-> 1431 return self._get_label(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1381, in _LocIndexer._get_label(self, label, axis)\n  1379 def _get_label(self, label, axis: AxisInt):\n  1380     # GH#5567 this will fail if the label is not present in the axis.\n-> 1381     return self.obj.xs(label, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4301, in NDFrame.xs(self, key, axis, level, drop_level)\n  4299             new_index = index[loc]\n  4300 else:\n-> 4301     loc = index.get_loc(key)\n  4303     if isinstance(loc, np.ndarray):\n  4304         if loc.dtype == np.bool_:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/interval.py:678, in IntervalIndex.get_loc(self, key)\n  676 matches = mask.sum()\n  677 if matches == 0:\n--> 678     raise KeyError(key)\n  679 if matches == 1:\n  680     return mask.argmax()\n\nKeyError: Interval(0.5, 2.5, closed='right') \n```", "```py\nIn [190]: idxr = df.index.overlaps(pd.Interval(0.5, 2.5))\n\nIn [191]: idxr\nOut[191]: array([ True,  True,  True, False])\n\nIn [192]: df[idxr]\nOut[192]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [193]: c = pd.cut(range(4), bins=2)\n\nIn [194]: c\nOut[194]: \n[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]]\n\nIn [195]: c.categories\nOut[195]: IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], dtype='interval[float64, right]') \n```", "```py\nIn [196]: pd.cut([0, 3, 5, 1], bins=c.categories)\nOut[196]: \n[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]] \n```", "```py\nIn [197]: pd.interval_range(start=0, end=5)\nOut[197]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype='interval[int64, right]')\n\nIn [198]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4)\nOut[198]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-02 00:00:00],\n (2017-01-02 00:00:00, 2017-01-03 00:00:00],\n (2017-01-03 00:00:00, 2017-01-04 00:00:00],\n (2017-01-04 00:00:00, 2017-01-05 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [199]: pd.interval_range(end=pd.Timedelta(\"3 days\"), periods=3)\nOut[199]: \nIntervalIndex([(0 days 00:00:00, 1 days 00:00:00],\n (1 days 00:00:00, 2 days 00:00:00],\n (2 days 00:00:00, 3 days 00:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [200]: pd.interval_range(start=0, periods=5, freq=1.5)\nOut[200]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]], dtype='interval[float64, right]')\n\nIn [201]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4, freq=\"W\")\nOut[201]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-08 00:00:00],\n (2017-01-08 00:00:00, 2017-01-15 00:00:00],\n (2017-01-15 00:00:00, 2017-01-22 00:00:00],\n (2017-01-22 00:00:00, 2017-01-29 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [202]: pd.interval_range(start=pd.Timedelta(\"0 days\"), periods=3, freq=\"9h\")\nOut[202]: \nIntervalIndex([(0 days 00:00:00, 0 days 09:00:00],\n (0 days 09:00:00, 0 days 18:00:00],\n (0 days 18:00:00, 1 days 03:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [203]: pd.interval_range(start=0, end=4, closed=\"both\")\nOut[203]: IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]], dtype='interval[int64, both]')\n\nIn [204]: pd.interval_range(start=0, end=4, closed=\"neither\")\nOut[204]: IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)], dtype='interval[int64, neither]') \n```", "```py\nIn [205]: pd.interval_range(start=0, end=6, periods=4)\nOut[205]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], dtype='interval[float64, right]')\n\nIn [206]: pd.interval_range(pd.Timestamp(\"2018-01-01\"), pd.Timestamp(\"2018-02-28\"), periods=3)\nOut[206]: \nIntervalIndex([(2018-01-01 00:00:00, 2018-01-20 08:00:00],\n (2018-01-20 08:00:00, 2018-02-08 16:00:00],\n (2018-02-08 16:00:00, 2018-02-28 00:00:00]],\n dtype='interval[datetime64[ns], right]') \n```", "```py\nIn [207]: s = pd.Series(range(5))\n\nIn [208]: s[-1]\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)\n  412 try:\n--> 413     return self._range.index(new_key)\n  414 except ValueError as err:\n\nValueError: -1 is not in range\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[208], line 1\n----> 1 s[-1]\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)\n  1118     return self._values[key]\n  1120 elif key_is_scalar:\n-> 1121     return self._get_value(key)\n  1123 # Convert generator to list before going through hashable part\n  1124 # (We will iterate through the generator there to check for slices)\n  1125 if is_iterator(key):\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)\n  1234     return self._values[label]\n  1236 # Similar to Index.get_value, but we do not fall back to positional\n-> 1237 loc = self.index.get_loc(label)\n  1239 if is_integer(loc):\n  1240     return self._values[loc]\n\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)\n  413         return self._range.index(new_key)\n  414     except ValueError as err:\n--> 415         raise KeyError(key) from err\n  416 if isinstance(key, Hashable):\n  417     raise KeyError(key)\n\nKeyError: -1\n\nIn [209]: df = pd.DataFrame(np.random.randn(5, 4))\n\nIn [210]: df\nOut[210]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221\n\nIn [211]: df.loc[-2:]\nOut[211]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221 \n```", "```py\nIn [212]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=[\"data\"], data=list(range(5)))\n\nIn [213]: df.index.is_monotonic_increasing\nOut[213]: True\n\n# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:\nIn [214]: df.loc[0:4, :]\nOut[214]: \n data\n2     0\n3     1\n3     2\n4     3\n\n# slice is are outside the index, so empty DataFrame is returned\nIn [215]: df.loc[13:15, :]\nOut[215]: \nEmpty DataFrame\nColumns: [data]\nIndex: [] \n```", "```py\nIn [216]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5], columns=[\"data\"], data=list(range(6)))\n\nIn [217]: df.index.is_monotonic_increasing\nOut[217]: False\n\n# OK because 2 and 4 are in the index\nIn [218]: df.loc[2:4, :]\nOut[218]: \n data\n2     0\n3     1\n1     2\n4     3 \n```", "```py\n # 0 is not in the index\nIn [219]: df.loc[0:4, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n  3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n  3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:191, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:234, in pandas._libs.index.IndexEngine._get_loc_duplicates()\n\nFile index.pyx:242, in pandas._libs.index.IndexEngine._maybe_get_bool_indexer()\n\nFile index.pyx:134, in pandas._libs.index._unpack_bool_indexer()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[219], line 1\n----> 1 df.loc[0:4, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n  6877 start_slice = None\n  6878 if start is not None:\n-> 6879     start_slice = self.get_slice_bound(start, \"left\")\n  6880 if start_slice is None:\n  6881     start_slice = 0\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6804, in Index.get_slice_bound(self, label, side)\n  6801         return self._searchsorted_monotonic(label, side)\n  6802     except ValueError:\n  6803         # raise the original KeyError\n-> 6804         raise err\n  6806 if isinstance(slc, np.ndarray):\n  6807     # get_loc may return a boolean array, which\n  6808     # is OK as long as they are representable by a slice.\n  6809     assert is_bool_dtype(slc.dtype)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6798, in Index.get_slice_bound(self, label, side)\n  6796 # we need to look up the label\n  6797 try:\n-> 6798     slc = self.get_loc(label)\n  6799 except KeyError as err:\n  6800     try:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n  3807     if isinstance(casted_key, slice) or (\n  3808         isinstance(casted_key, abc.Iterable)\n  3809         and any(isinstance(x, slice) for x in casted_key)\n  3810     ):\n  3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n  3813 except TypeError:\n  3814     # If we have a listlike key, _check_indexing_error will raise\n  3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n  3816     #  the TypeError.\n  3817     self._check_indexing_error(key)\n\nKeyError: 0\n\n # 3 is not a unique label\nIn [220]: df.loc[2:3, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[220], line 1\n----> 1 df.loc[2:3, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6885, in Index.slice_locs(self, start, end, step)\n  6883 end_slice = None\n  6884 if end is not None:\n-> 6885     end_slice = self.get_slice_bound(end, \"right\")\n  6886 if end_slice is None:\n  6887     end_slice = len(self)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6812, in Index.get_slice_bound(self, label, side)\n  6810     slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n  6811     if isinstance(slc, np.ndarray):\n-> 6812         raise KeyError(\n  6813             f\"Cannot get {side} slice bound for non-unique \"\n  6814             f\"label: {repr(original_label)}\"\n  6815         )\n  6817 if isinstance(slc, slice):\n  6818     if side == \"left\":\n\nKeyError: 'Cannot get right slice bound for non-unique label: 3' \n```", "```py\nIn [221]: weakly_monotonic = pd.Index([\"a\", \"b\", \"c\", \"c\"])\n\nIn [222]: weakly_monotonic\nOut[222]: Index(['a', 'b', 'c', 'c'], dtype='object')\n\nIn [223]: weakly_monotonic.is_monotonic_increasing\nOut[223]: True\n\nIn [224]: weakly_monotonic.is_monotonic_increasing & weakly_monotonic.is_unique\nOut[224]: False \n```", "```py\nIn [225]: s = pd.Series(np.random.randn(6), index=list(\"abcdef\"))\n\nIn [226]: s\nOut[226]: \na   -0.101684\nb   -0.734907\nc   -0.130121\nd   -0.476046\ne    0.759104\nf    0.213379\ndtype: float64 \n```", "```py\nIn [227]: s[2:5]\nOut[227]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [228]: s.loc['c':'e' + 1]\n---------------------------------------------------------------------------\nTypeError  Traceback (most recent call last)\nCell In[228], line 1\n----> 1 s.loc['c':'e' + 1]\n\nTypeError: can only concatenate str (not \"int\") to str \n```", "```py\nIn [229]: s.loc[\"c\":\"e\"]\nOut[229]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [230]: series1 = pd.Series([1, 2, 3])\n\nIn [231]: series1.dtype\nOut[231]: dtype('int64')\n\nIn [232]: res = series1.reindex([0, 4])\n\nIn [233]: res.dtype\nOut[233]: dtype('float64')\n\nIn [234]: res\nOut[234]: \n0    1.0\n4    NaN\ndtype: float64 \n```", "```py\nIn [235]: series2 = pd.Series([True])\n\nIn [236]: series2.dtype\nOut[236]: dtype('bool')\n\nIn [237]: res = series2.reindex_like(series1)\n\nIn [238]: res.dtype\nOut[238]: dtype('O')\n\nIn [239]: res\nOut[239]: \n0    True\n1     NaN\n2     NaN\ndtype: object \n```", "```py\nIn [1]: arrays = [\n ...:    [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n ...:    [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n ...: ]\n ...: \n\nIn [2]: tuples = list(zip(*arrays))\n\nIn [3]: tuples\nOut[3]: \n[('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')]\n\nIn [4]: index = pd.MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"])\n\nIn [5]: index\nOut[5]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second'])\n\nIn [6]: s = pd.Series(np.random.randn(8), index=index)\n\nIn [7]: s\nOut[7]: \nfirst  second\nbar    one       0.469112\n two      -0.282863\nbaz    one      -1.509059\n two      -1.135632\nfoo    one       1.212112\n two      -0.173215\nqux    one       0.119209\n two      -1.044236\ndtype: float64 \n```", "```py\nIn [8]: iterables = [[\"bar\", \"baz\", \"foo\", \"qux\"], [\"one\", \"two\"]]\n\nIn [9]: pd.MultiIndex.from_product(iterables, names=[\"first\", \"second\"])\nOut[9]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [10]: df = pd.DataFrame(\n ....:    [[\"bar\", \"one\"], [\"bar\", \"two\"], [\"foo\", \"one\"], [\"foo\", \"two\"]],\n ....:    columns=[\"first\", \"second\"],\n ....: )\n ....: \n\nIn [11]: pd.MultiIndex.from_frame(df)\nOut[11]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('foo', 'one'),\n ('foo', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [12]: arrays = [\n ....:    np.array([\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"]),\n ....:    np.array([\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"]),\n ....: ]\n ....: \n\nIn [13]: s = pd.Series(np.random.randn(8), index=arrays)\n\nIn [14]: s\nOut[14]: \nbar  one   -0.861849\n two   -2.104569\nbaz  one   -0.494929\n two    1.071804\nfoo  one    0.721555\n two   -0.706771\nqux  one   -1.039575\n two    0.271860\ndtype: float64\n\nIn [15]: df = pd.DataFrame(np.random.randn(8, 4), index=arrays)\n\nIn [16]: df\nOut[16]: \n 0         1         2         3\nbar one -0.424972  0.567020  0.276232 -1.087401\n two -0.673690  0.113648 -1.478427  0.524988\nbaz one  0.404705  0.577046 -1.715002 -1.039268\n two -0.370647 -1.157892 -1.344312  0.844885\nfoo one  1.075770 -0.109050  1.643563 -1.469388\n two  0.357021 -0.674600 -1.776904 -0.968914\nqux one -1.294524  0.413738  0.276662 -0.472035\n two -0.013960 -0.362543 -0.006154 -0.923061 \n```", "```py\nIn [17]: df.index.names\nOut[17]: FrozenList([None, None]) \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(3, 8), index=[\"A\", \"B\", \"C\"], columns=index)\n\nIn [19]: df\nOut[19]: \nfirst        bar                 baz  ...       foo       qux \nsecond       one       two       one  ...       two       one       two\nA       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169\nB       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737\nC      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747\n\n[3 rows x 8 columns]\n\nIn [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])\nOut[20]: \nfirst              bar                 baz                 foo \nsecond             one       two       one       two       one       two\nfirst second \nbar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804\n two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734\nbaz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738\n two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849\nfoo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232\n two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441 \n```", "```py\nIn [21]: with pd.option_context(\"display.multi_sparse\", False):\n ....:    df\n ....: \n```", "```py\nIn [22]: pd.Series(np.random.randn(8), index=tuples)\nOut[22]: \n(bar, one)   -1.236269\n(bar, two)    0.896171\n(baz, one)   -0.487602\n(baz, two)   -0.082240\n(foo, one)   -2.182937\n(foo, two)    0.380396\n(qux, one)    0.084844\n(qux, two)    0.432390\ndtype: float64 \n```", "```py\nIn [23]: index.get_level_values(0)\nOut[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')\n\nIn [24]: index.get_level_values(\"second\")\nOut[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second') \n```", "```py\nIn [25]: df[\"bar\"]\nOut[25]: \nsecond       one       two\nA       0.895717  0.805244\nB       0.410835  0.813850\nC      -1.413681  1.607920\n\nIn [26]: df[\"bar\", \"one\"]\nOut[26]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64\n\nIn [27]: df[\"bar\"][\"one\"]\nOut[27]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: one, dtype: float64\n\nIn [28]: s[\"qux\"]\nOut[28]: \none   -1.039575\ntwo    0.271860\ndtype: float64 \n```", "```py\nIn [29]: df.columns.levels  # original MultiIndex\nOut[29]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']])\n\nIn [30]: df[[\"foo\",\"qux\"]].columns.levels  # sliced\nOut[30]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [31]: df[[\"foo\", \"qux\"]].columns.to_numpy()\nOut[31]: \narray([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],\n dtype=object)\n\n# for a specific level\nIn [32]: df[[\"foo\", \"qux\"]].columns.get_level_values(0)\nOut[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first') \n```", "```py\nIn [33]: new_mi = df[[\"foo\", \"qux\"]].columns.remove_unused_levels()\n\nIn [34]: new_mi.levels\nOut[34]: FrozenList([['foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [35]: s + s[:-2]\nOut[35]: \nbar  one   -1.723698\n two   -4.209138\nbaz  one   -0.989859\n two    2.143608\nfoo  one    1.443110\n two   -1.413542\nqux  one         NaN\n two         NaN\ndtype: float64\n\nIn [36]: s + s[::2]\nOut[36]: \nbar  one   -1.723698\n two         NaN\nbaz  one   -0.989859\n two         NaN\nfoo  one    1.443110\n two         NaN\nqux  one   -2.079150\n two         NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex(index[:3])\nOut[37]: \nfirst  second\nbar    one      -0.861849\n two      -2.104569\nbaz    one      -0.494929\ndtype: float64\n\nIn [38]: s.reindex([(\"foo\", \"two\"), (\"bar\", \"one\"), (\"qux\", \"one\"), (\"baz\", \"one\")])\nOut[38]: \nfoo  two   -0.706771\nbar  one   -0.861849\nqux  one   -1.039575\nbaz  one   -0.494929\ndtype: float64 \n```", "```py\nIn [1]: arrays = [\n ...:    [\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"],\n ...:    [\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"],\n ...: ]\n ...: \n\nIn [2]: tuples = list(zip(*arrays))\n\nIn [3]: tuples\nOut[3]: \n[('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')]\n\nIn [4]: index = pd.MultiIndex.from_tuples(tuples, names=[\"first\", \"second\"])\n\nIn [5]: index\nOut[5]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second'])\n\nIn [6]: s = pd.Series(np.random.randn(8), index=index)\n\nIn [7]: s\nOut[7]: \nfirst  second\nbar    one       0.469112\n two      -0.282863\nbaz    one      -1.509059\n two      -1.135632\nfoo    one       1.212112\n two      -0.173215\nqux    one       0.119209\n two      -1.044236\ndtype: float64 \n```", "```py\nIn [8]: iterables = [[\"bar\", \"baz\", \"foo\", \"qux\"], [\"one\", \"two\"]]\n\nIn [9]: pd.MultiIndex.from_product(iterables, names=[\"first\", \"second\"])\nOut[9]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('baz', 'one'),\n ('baz', 'two'),\n ('foo', 'one'),\n ('foo', 'two'),\n ('qux', 'one'),\n ('qux', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [10]: df = pd.DataFrame(\n ....:    [[\"bar\", \"one\"], [\"bar\", \"two\"], [\"foo\", \"one\"], [\"foo\", \"two\"]],\n ....:    columns=[\"first\", \"second\"],\n ....: )\n ....: \n\nIn [11]: pd.MultiIndex.from_frame(df)\nOut[11]: \nMultiIndex([('bar', 'one'),\n ('bar', 'two'),\n ('foo', 'one'),\n ('foo', 'two')],\n names=['first', 'second']) \n```", "```py\nIn [12]: arrays = [\n ....:    np.array([\"bar\", \"bar\", \"baz\", \"baz\", \"foo\", \"foo\", \"qux\", \"qux\"]),\n ....:    np.array([\"one\", \"two\", \"one\", \"two\", \"one\", \"two\", \"one\", \"two\"]),\n ....: ]\n ....: \n\nIn [13]: s = pd.Series(np.random.randn(8), index=arrays)\n\nIn [14]: s\nOut[14]: \nbar  one   -0.861849\n two   -2.104569\nbaz  one   -0.494929\n two    1.071804\nfoo  one    0.721555\n two   -0.706771\nqux  one   -1.039575\n two    0.271860\ndtype: float64\n\nIn [15]: df = pd.DataFrame(np.random.randn(8, 4), index=arrays)\n\nIn [16]: df\nOut[16]: \n 0         1         2         3\nbar one -0.424972  0.567020  0.276232 -1.087401\n two -0.673690  0.113648 -1.478427  0.524988\nbaz one  0.404705  0.577046 -1.715002 -1.039268\n two -0.370647 -1.157892 -1.344312  0.844885\nfoo one  1.075770 -0.109050  1.643563 -1.469388\n two  0.357021 -0.674600 -1.776904 -0.968914\nqux one -1.294524  0.413738  0.276662 -0.472035\n two -0.013960 -0.362543 -0.006154 -0.923061 \n```", "```py\nIn [17]: df.index.names\nOut[17]: FrozenList([None, None]) \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(3, 8), index=[\"A\", \"B\", \"C\"], columns=index)\n\nIn [19]: df\nOut[19]: \nfirst        bar                 baz  ...       foo       qux \nsecond       one       two       one  ...       two       one       two\nA       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169\nB       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737\nC      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747\n\n[3 rows x 8 columns]\n\nIn [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])\nOut[20]: \nfirst              bar                 baz                 foo \nsecond             one       two       one       two       one       two\nfirst second \nbar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804\n two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734\nbaz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738\n two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849\nfoo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232\n two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441 \n```", "```py\nIn [21]: with pd.option_context(\"display.multi_sparse\", False):\n ....:    df\n ....: \n```", "```py\nIn [22]: pd.Series(np.random.randn(8), index=tuples)\nOut[22]: \n(bar, one)   -1.236269\n(bar, two)    0.896171\n(baz, one)   -0.487602\n(baz, two)   -0.082240\n(foo, one)   -2.182937\n(foo, two)    0.380396\n(qux, one)    0.084844\n(qux, two)    0.432390\ndtype: float64 \n```", "```py\nIn [23]: index.get_level_values(0)\nOut[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')\n\nIn [24]: index.get_level_values(\"second\")\nOut[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second') \n```", "```py\nIn [25]: df[\"bar\"]\nOut[25]: \nsecond       one       two\nA       0.895717  0.805244\nB       0.410835  0.813850\nC      -1.413681  1.607920\n\nIn [26]: df[\"bar\", \"one\"]\nOut[26]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64\n\nIn [27]: df[\"bar\"][\"one\"]\nOut[27]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: one, dtype: float64\n\nIn [28]: s[\"qux\"]\nOut[28]: \none   -1.039575\ntwo    0.271860\ndtype: float64 \n```", "```py\nIn [29]: df.columns.levels  # original MultiIndex\nOut[29]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']])\n\nIn [30]: df[[\"foo\",\"qux\"]].columns.levels  # sliced\nOut[30]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [31]: df[[\"foo\", \"qux\"]].columns.to_numpy()\nOut[31]: \narray([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],\n dtype=object)\n\n# for a specific level\nIn [32]: df[[\"foo\", \"qux\"]].columns.get_level_values(0)\nOut[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first') \n```", "```py\nIn [33]: new_mi = df[[\"foo\", \"qux\"]].columns.remove_unused_levels()\n\nIn [34]: new_mi.levels\nOut[34]: FrozenList([['foo', 'qux'], ['one', 'two']]) \n```", "```py\nIn [35]: s + s[:-2]\nOut[35]: \nbar  one   -1.723698\n two   -4.209138\nbaz  one   -0.989859\n two    2.143608\nfoo  one    1.443110\n two   -1.413542\nqux  one         NaN\n two         NaN\ndtype: float64\n\nIn [36]: s + s[::2]\nOut[36]: \nbar  one   -1.723698\n two         NaN\nbaz  one   -0.989859\n two         NaN\nfoo  one    1.443110\n two         NaN\nqux  one   -2.079150\n two         NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex(index[:3])\nOut[37]: \nfirst  second\nbar    one      -0.861849\n two      -2.104569\nbaz    one      -0.494929\ndtype: float64\n\nIn [38]: s.reindex([(\"foo\", \"two\"), (\"bar\", \"one\"), (\"qux\", \"one\"), (\"baz\", \"one\")])\nOut[38]: \nfoo  two   -0.706771\nbar  one   -0.861849\nqux  one   -1.039575\nbaz  one   -0.494929\ndtype: float64 \n```", "```py\nIn [39]: df = df.T\n\nIn [40]: df\nOut[40]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\n two     0.805244  0.813850  1.607920\nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n two    -0.226169 -1.436737 -2.006747\n\nIn [41]: df.loc[(\"bar\", \"two\")]\nOut[41]: \nA    0.805244\nB    0.813850\nC    1.607920\nName: (bar, two), dtype: float64 \n```", "```py\nIn [42]: df.loc[(\"bar\", \"two\"), \"A\"]\nOut[42]: 0.8052440253863785 \n```", "```py\nIn [43]: df.loc[\"bar\"]\nOut[43]: \n A         B         C\nsecond \none     0.895717  0.410835 -1.413681\ntwo     0.805244  0.813850  1.607920 \n```", "```py\nIn [44]: df.loc[\"baz\":\"foo\"]\nOut[44]: \n A         B         C\nfirst second \nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372 \n```", "```py\nIn [45]: df.loc[(\"baz\", \"two\"):(\"qux\", \"one\")]\nOut[45]: \n A         B         C\nfirst second \nbaz   two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n\nIn [46]: df.loc[(\"baz\", \"two\"):\"foo\"]\nOut[46]: \n A         B         C\nfirst second \nbaz   two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372 \n```", "```py\nIn [47]: df.loc[[(\"bar\", \"two\"), (\"qux\", \"one\")]]\nOut[47]: \n A         B         C\nfirst second \nbar   two     0.805244  0.813850  1.607920\nqux   one    -1.170299  1.130127  0.974466 \n```", "```py\nIn [48]: s = pd.Series(\n ....:    [1, 2, 3, 4, 5, 6],\n ....:    index=pd.MultiIndex.from_product([[\"A\", \"B\"], [\"c\", \"d\", \"e\"]]),\n ....: )\n ....: \n\nIn [49]: s.loc[[(\"A\", \"c\"), (\"B\", \"d\")]]  # list of tuples\nOut[49]: \nA  c    1\nB  d    5\ndtype: int64\n\nIn [50]: s.loc[([\"A\", \"B\"], [\"c\", \"d\"])]  # tuple of lists\nOut[50]: \nA  c    1\n d    2\nB  c    4\n d    5\ndtype: int64 \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...), :]  # noqa: E999 \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...)]  # noqa: E999 \n```", "```py\nIn [51]: def mklbl(prefix, n):\n ....:    return [\"%s%s\" % (prefix, i) for i in range(n)]\n ....: \n\nIn [52]: miindex = pd.MultiIndex.from_product(\n ....:    [mklbl(\"A\", 4), mklbl(\"B\", 2), mklbl(\"C\", 4), mklbl(\"D\", 2)]\n ....: )\n ....: \n\nIn [53]: micolumns = pd.MultiIndex.from_tuples(\n ....:    [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")], names=[\"lvl0\", \"lvl1\"]\n ....: )\n ....: \n\nIn [54]: dfmi = (\n ....:    pd.DataFrame(\n ....:        np.arange(len(miindex) * len(micolumns)).reshape(\n ....:            (len(miindex), len(micolumns))\n ....:        ),\n ....:        index=miindex,\n ....:        columns=micolumns,\n ....:    )\n ....:    .sort_index()\n ....:    .sort_index(axis=1)\n ....: )\n ....: \n\nIn [55]: dfmi\nOut[55]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0    9    8   11   10\n D1   13   12   15   14\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  237  236  239  238\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[64 rows x 4 columns] \n```", "```py\nIn [56]: dfmi.loc[(slice(\"A1\", \"A3\"), slice(None), [\"C1\", \"C3\"]), :]\nOut[56]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA1 B0 C1 D0   73   72   75   74\n D1   77   76   79   78\n C3 D0   89   88   91   90\n D1   93   92   95   94\n B1 C1 D0  105  104  107  106\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[24 rows x 4 columns] \n```", "```py\nIn [57]: idx = pd.IndexSlice\n\nIn [58]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[58]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [59]: dfmi.loc[\"A1\", (slice(None), \"foo\")]\nOut[59]: \nlvl0        a    b\nlvl1      foo  foo\nB0 C0 D0   64   66\n D1   68   70\n C1 D0   72   74\n D1   76   78\n C2 D0   80   82\n...       ...  ...\nB1 C1 D1  108  110\n C2 D0  112  114\n D1  116  118\n C3 D0  120  122\n D1  124  126\n\n[16 rows x 2 columns]\n\nIn [60]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[60]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [61]: mask = dfmi[(\"a\", \"foo\")] > 200\n\nIn [62]: dfmi.loc[idx[mask, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[62]: \nlvl0           a    b\nlvl1         foo  foo\nA3 B0 C1 D1  204  206\n C3 D0  216  218\n D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254 \n```", "```py\nIn [63]: dfmi.loc(axis=0)[:, :, [\"C1\", \"C3\"]]\nOut[63]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C1 D0    9    8   11   10\n D1   13   12   15   14\n C3 D0   25   24   27   26\n D1   29   28   31   30\n B1 C1 D0   41   40   43   42\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[32 rows x 4 columns] \n```", "```py\nIn [64]: df2 = dfmi.copy()\n\nIn [65]: df2.loc(axis=0)[:, :, [\"C1\", \"C3\"]] = -10\n\nIn [66]: df2\nOut[66]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  -10  -10  -10  -10\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n\n[64 rows x 4 columns] \n```", "```py\nIn [67]: df2 = dfmi.copy()\n\nIn [68]: df2.loc[idx[:, :, [\"C1\", \"C3\"]], :] = df2 * 1000\n\nIn [69]: df2\nOut[69]: \nlvl0              a               b \nlvl1            bar     foo     bah     foo\nA0 B0 C0 D0       1       0       3       2\n D1       5       4       7       6\n C1 D0    9000    8000   11000   10000\n D1   13000   12000   15000   14000\n C2 D0      17      16      19      18\n...             ...     ...     ...     ...\nA3 B1 C1 D1  237000  236000  239000  238000\n C2 D0     241     240     243     242\n D1     245     244     247     246\n C3 D0  249000  248000  251000  250000\n D1  253000  252000  255000  254000\n\n[64 rows x 4 columns] \n```", "```py\nIn [70]: df\nOut[70]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\n two     0.805244  0.813850  1.607920\nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n two    -0.226169 -1.436737 -2.006747\n\nIn [71]: df.xs(\"one\", level=\"second\")\nOut[71]: \n A         B         C\nfirst \nbar    0.895717  0.410835 -1.413681\nbaz   -1.206412  0.132003  1.024180\nfoo    1.431256 -0.076467  0.875906\nqux   -1.170299  1.130127  0.974466 \n```", "```py\n# using the slicers\nIn [72]: df.loc[(slice(None), \"one\"), :]\nOut[72]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\nbaz   one    -1.206412  0.132003  1.024180\nfoo   one     1.431256 -0.076467  0.875906\nqux   one    -1.170299  1.130127  0.974466 \n```", "```py\nIn [73]: df = df.T\n\nIn [74]: df.xs(\"one\", level=\"second\", axis=1)\nOut[74]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\n# using the slicers\nIn [75]: df.loc[:, (slice(None), \"one\")]\nOut[75]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [76]: df.xs((\"one\", \"bar\"), level=(\"second\", \"first\"), axis=1)\nOut[76]: \nfirst        bar\nsecond       one\nA       0.895717\nB       0.410835\nC      -1.413681 \n```", "```py\n# using the slicers\nIn [77]: df.loc[:, (\"bar\", \"one\")]\nOut[77]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64 \n```", "```py\nIn [78]: df.xs(\"one\", level=\"second\", axis=1, drop_level=False)\nOut[78]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [79]: df.xs(\"one\", level=\"second\", axis=1, drop_level=True)\nOut[79]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [80]: midx = pd.MultiIndex(\n ....:    levels=[[\"zero\", \"one\"], [\"x\", \"y\"]], codes=[[1, 1, 0, 0], [1, 0, 1, 0]]\n ....: )\n ....: \n\nIn [81]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)\n\nIn [82]: df\nOut[82]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [83]: df2 = df.groupby(level=0).mean()\n\nIn [84]: df2\nOut[84]: \n 0         1\none   1.060074 -0.109716\nzero  1.271532  0.713416\n\nIn [85]: df2.reindex(df.index, level=0)\nOut[85]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416\n\n# aligning\nIn [86]: df_aligned, df2_aligned = df.align(df2, level=0)\n\nIn [87]: df_aligned\nOut[87]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [88]: df2_aligned\nOut[88]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416 \n```", "```py\nIn [89]: df[:5]\nOut[89]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [90]: df[:5].swaplevel(0, 1, axis=0)\nOut[90]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [91]: df[:5].reorder_levels([1, 0], axis=0)\nOut[91]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [92]: df.rename(columns={0: \"col0\", 1: \"col1\"})\nOut[92]: \n col0      col1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [93]: df.rename(index={\"one\": \"two\", \"y\": \"z\"})\nOut[93]: \n 0         1\ntwo  z  1.519970 -0.493662\n x  0.600178  0.274230\nzero z  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [94]: df.rename_axis(index=[\"abc\", \"def\"])\nOut[94]: \n 0         1\nabc  def \none  y    1.519970 -0.493662\n x    0.600178  0.274230\nzero y    0.132885 -0.023688\n x    2.410179  1.450520 \n```", "```py\nIn [95]: df.rename_axis(columns=\"Cols\").columns\nOut[95]: RangeIndex(start=0, stop=2, step=1, name='Cols') \n```", "```py\nIn [96]: mi = pd.MultiIndex.from_product([[1, 2], [\"a\", \"b\"]], names=[\"x\", \"y\"])\n\nIn [97]: mi.names\nOut[97]: FrozenList(['x', 'y'])\n\nIn [98]: mi2 = mi.rename(\"new name\", level=0)\n\nIn [99]: mi2\nOut[99]: \nMultiIndex([(1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['new name', 'y']) \n```", "```py\nIn [100]: mi.levels[0].name = \"name via level\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[100], line 1\n----> 1 mi.levels[0].name = \"name via level\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead. \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...), :]  # noqa: E999 \n```", "```py\ndf.loc[(slice(\"A1\", \"A3\"), ...)]  # noqa: E999 \n```", "```py\nIn [51]: def mklbl(prefix, n):\n ....:    return [\"%s%s\" % (prefix, i) for i in range(n)]\n ....: \n\nIn [52]: miindex = pd.MultiIndex.from_product(\n ....:    [mklbl(\"A\", 4), mklbl(\"B\", 2), mklbl(\"C\", 4), mklbl(\"D\", 2)]\n ....: )\n ....: \n\nIn [53]: micolumns = pd.MultiIndex.from_tuples(\n ....:    [(\"a\", \"foo\"), (\"a\", \"bar\"), (\"b\", \"foo\"), (\"b\", \"bah\")], names=[\"lvl0\", \"lvl1\"]\n ....: )\n ....: \n\nIn [54]: dfmi = (\n ....:    pd.DataFrame(\n ....:        np.arange(len(miindex) * len(micolumns)).reshape(\n ....:            (len(miindex), len(micolumns))\n ....:        ),\n ....:        index=miindex,\n ....:        columns=micolumns,\n ....:    )\n ....:    .sort_index()\n ....:    .sort_index(axis=1)\n ....: )\n ....: \n\nIn [55]: dfmi\nOut[55]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0    9    8   11   10\n D1   13   12   15   14\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  237  236  239  238\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[64 rows x 4 columns] \n```", "```py\nIn [56]: dfmi.loc[(slice(\"A1\", \"A3\"), slice(None), [\"C1\", \"C3\"]), :]\nOut[56]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA1 B0 C1 D0   73   72   75   74\n D1   77   76   79   78\n C3 D0   89   88   91   90\n D1   93   92   95   94\n B1 C1 D0  105  104  107  106\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[24 rows x 4 columns] \n```", "```py\nIn [57]: idx = pd.IndexSlice\n\nIn [58]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[58]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [59]: dfmi.loc[\"A1\", (slice(None), \"foo\")]\nOut[59]: \nlvl0        a    b\nlvl1      foo  foo\nB0 C0 D0   64   66\n D1   68   70\n C1 D0   72   74\n D1   76   78\n C2 D0   80   82\n...       ...  ...\nB1 C1 D1  108  110\n C2 D0  112  114\n D1  116  118\n C3 D0  120  122\n D1  124  126\n\n[16 rows x 2 columns]\n\nIn [60]: dfmi.loc[idx[:, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[60]: \nlvl0           a    b\nlvl1         foo  foo\nA0 B0 C1 D0    8   10\n D1   12   14\n C3 D0   24   26\n D1   28   30\n B1 C1 D0   40   42\n...          ...  ...\nA3 B0 C3 D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254\n\n[32 rows x 2 columns] \n```", "```py\nIn [61]: mask = dfmi[(\"a\", \"foo\")] > 200\n\nIn [62]: dfmi.loc[idx[mask, :, [\"C1\", \"C3\"]], idx[:, \"foo\"]]\nOut[62]: \nlvl0           a    b\nlvl1         foo  foo\nA3 B0 C1 D1  204  206\n C3 D0  216  218\n D1  220  222\n B1 C1 D0  232  234\n D1  236  238\n C3 D0  248  250\n D1  252  254 \n```", "```py\nIn [63]: dfmi.loc(axis=0)[:, :, [\"C1\", \"C3\"]]\nOut[63]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C1 D0    9    8   11   10\n D1   13   12   15   14\n C3 D0   25   24   27   26\n D1   29   28   31   30\n B1 C1 D0   41   40   43   42\n...          ...  ...  ...  ...\nA3 B0 C3 D1  221  220  223  222\n B1 C1 D0  233  232  235  234\n D1  237  236  239  238\n C3 D0  249  248  251  250\n D1  253  252  255  254\n\n[32 rows x 4 columns] \n```", "```py\nIn [64]: df2 = dfmi.copy()\n\nIn [65]: df2.loc(axis=0)[:, :, [\"C1\", \"C3\"]] = -10\n\nIn [66]: df2\nOut[66]: \nlvl0           a         b \nlvl1         bar  foo  bah  foo\nA0 B0 C0 D0    1    0    3    2\n D1    5    4    7    6\n C1 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n C2 D0   17   16   19   18\n...          ...  ...  ...  ...\nA3 B1 C1 D1  -10  -10  -10  -10\n C2 D0  241  240  243  242\n D1  245  244  247  246\n C3 D0  -10  -10  -10  -10\n D1  -10  -10  -10  -10\n\n[64 rows x 4 columns] \n```", "```py\nIn [67]: df2 = dfmi.copy()\n\nIn [68]: df2.loc[idx[:, :, [\"C1\", \"C3\"]], :] = df2 * 1000\n\nIn [69]: df2\nOut[69]: \nlvl0              a               b \nlvl1            bar     foo     bah     foo\nA0 B0 C0 D0       1       0       3       2\n D1       5       4       7       6\n C1 D0    9000    8000   11000   10000\n D1   13000   12000   15000   14000\n C2 D0      17      16      19      18\n...             ...     ...     ...     ...\nA3 B1 C1 D1  237000  236000  239000  238000\n C2 D0     241     240     243     242\n D1     245     244     247     246\n C3 D0  249000  248000  251000  250000\n D1  253000  252000  255000  254000\n\n[64 rows x 4 columns] \n```", "```py\nIn [70]: df\nOut[70]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\n two     0.805244  0.813850  1.607920\nbaz   one    -1.206412  0.132003  1.024180\n two     2.565646 -0.827317  0.569605\nfoo   one     1.431256 -0.076467  0.875906\n two     1.340309 -1.187678 -2.211372\nqux   one    -1.170299  1.130127  0.974466\n two    -0.226169 -1.436737 -2.006747\n\nIn [71]: df.xs(\"one\", level=\"second\")\nOut[71]: \n A         B         C\nfirst \nbar    0.895717  0.410835 -1.413681\nbaz   -1.206412  0.132003  1.024180\nfoo    1.431256 -0.076467  0.875906\nqux   -1.170299  1.130127  0.974466 \n```", "```py\n# using the slicers\nIn [72]: df.loc[(slice(None), \"one\"), :]\nOut[72]: \n A         B         C\nfirst second \nbar   one     0.895717  0.410835 -1.413681\nbaz   one    -1.206412  0.132003  1.024180\nfoo   one     1.431256 -0.076467  0.875906\nqux   one    -1.170299  1.130127  0.974466 \n```", "```py\nIn [73]: df = df.T\n\nIn [74]: df.xs(\"one\", level=\"second\", axis=1)\nOut[74]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\n# using the slicers\nIn [75]: df.loc[:, (slice(None), \"one\")]\nOut[75]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [76]: df.xs((\"one\", \"bar\"), level=(\"second\", \"first\"), axis=1)\nOut[76]: \nfirst        bar\nsecond       one\nA       0.895717\nB       0.410835\nC      -1.413681 \n```", "```py\n# using the slicers\nIn [77]: df.loc[:, (\"bar\", \"one\")]\nOut[77]: \nA    0.895717\nB    0.410835\nC   -1.413681\nName: (bar, one), dtype: float64 \n```", "```py\nIn [78]: df.xs(\"one\", level=\"second\", axis=1, drop_level=False)\nOut[78]: \nfirst        bar       baz       foo       qux\nsecond       one       one       one       one\nA       0.895717 -1.206412  1.431256 -1.170299\nB       0.410835  0.132003 -0.076467  1.130127\nC      -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [79]: df.xs(\"one\", level=\"second\", axis=1, drop_level=True)\nOut[79]: \nfirst       bar       baz       foo       qux\nA      0.895717 -1.206412  1.431256 -1.170299\nB      0.410835  0.132003 -0.076467  1.130127\nC     -1.413681  1.024180  0.875906  0.974466 \n```", "```py\nIn [80]: midx = pd.MultiIndex(\n ....:    levels=[[\"zero\", \"one\"], [\"x\", \"y\"]], codes=[[1, 1, 0, 0], [1, 0, 1, 0]]\n ....: )\n ....: \n\nIn [81]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)\n\nIn [82]: df\nOut[82]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [83]: df2 = df.groupby(level=0).mean()\n\nIn [84]: df2\nOut[84]: \n 0         1\none   1.060074 -0.109716\nzero  1.271532  0.713416\n\nIn [85]: df2.reindex(df.index, level=0)\nOut[85]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416\n\n# aligning\nIn [86]: df_aligned, df2_aligned = df.align(df2, level=0)\n\nIn [87]: df_aligned\nOut[87]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [88]: df2_aligned\nOut[88]: \n 0         1\none  y  1.060074 -0.109716\n x  1.060074 -0.109716\nzero y  1.271532  0.713416\n x  1.271532  0.713416 \n```", "```py\nIn [89]: df[:5]\nOut[89]: \n 0         1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520\n\nIn [90]: df[:5].swaplevel(0, 1, axis=0)\nOut[90]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [91]: df[:5].reorder_levels([1, 0], axis=0)\nOut[91]: \n 0         1\ny one   1.519970 -0.493662\nx one   0.600178  0.274230\ny zero  0.132885 -0.023688\nx zero  2.410179  1.450520 \n```", "```py\nIn [92]: df.rename(columns={0: \"col0\", 1: \"col1\"})\nOut[92]: \n col0      col1\none  y  1.519970 -0.493662\n x  0.600178  0.274230\nzero y  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [93]: df.rename(index={\"one\": \"two\", \"y\": \"z\"})\nOut[93]: \n 0         1\ntwo  z  1.519970 -0.493662\n x  0.600178  0.274230\nzero z  0.132885 -0.023688\n x  2.410179  1.450520 \n```", "```py\nIn [94]: df.rename_axis(index=[\"abc\", \"def\"])\nOut[94]: \n 0         1\nabc  def \none  y    1.519970 -0.493662\n x    0.600178  0.274230\nzero y    0.132885 -0.023688\n x    2.410179  1.450520 \n```", "```py\nIn [95]: df.rename_axis(columns=\"Cols\").columns\nOut[95]: RangeIndex(start=0, stop=2, step=1, name='Cols') \n```", "```py\nIn [96]: mi = pd.MultiIndex.from_product([[1, 2], [\"a\", \"b\"]], names=[\"x\", \"y\"])\n\nIn [97]: mi.names\nOut[97]: FrozenList(['x', 'y'])\n\nIn [98]: mi2 = mi.rename(\"new name\", level=0)\n\nIn [99]: mi2\nOut[99]: \nMultiIndex([(1, 'a'),\n (1, 'b'),\n (2, 'a'),\n (2, 'b')],\n names=['new name', 'y']) \n```", "```py\nIn [100]: mi.levels[0].name = \"name via level\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[100], line 1\n----> 1 mi.levels[0].name = \"name via level\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead. \n```", "```py\nIn [101]: import random\n\nIn [102]: random.shuffle(tuples)\n\nIn [103]: s = pd.Series(np.random.randn(8), index=pd.MultiIndex.from_tuples(tuples))\n\nIn [104]: s\nOut[104]: \nqux  two    0.206053\nbar  one   -0.251905\nfoo  one   -2.213588\nqux  one    1.063327\nfoo  two    1.266143\nbaz  two    0.299368\nbar  two   -0.863838\nbaz  one    0.408204\ndtype: float64\n\nIn [105]: s.sort_index()\nOut[105]: \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [106]: s.sort_index(level=0)\nOut[106]: \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [107]: s.sort_index(level=1)\nOut[107]: \nbar  one   -0.251905\nbaz  one    0.408204\nfoo  one   -2.213588\nqux  one    1.063327\nbar  two   -0.863838\nbaz  two    0.299368\nfoo  two    1.266143\nqux  two    0.206053\ndtype: float64 \n```", "```py\nIn [108]: s.index = s.index.set_names([\"L1\", \"L2\"])\n\nIn [109]: s.sort_index(level=\"L1\")\nOut[109]: \nL1   L2 \nbar  one   -0.251905\n two   -0.863838\nbaz  one    0.408204\n two    0.299368\nfoo  one   -2.213588\n two    1.266143\nqux  one    1.063327\n two    0.206053\ndtype: float64\n\nIn [110]: s.sort_index(level=\"L2\")\nOut[110]: \nL1   L2 \nbar  one   -0.251905\nbaz  one    0.408204\nfoo  one   -2.213588\nqux  one    1.063327\nbar  two   -0.863838\nbaz  two    0.299368\nfoo  two    1.266143\nqux  two    0.206053\ndtype: float64 \n```", "```py\nIn [111]: df.T.sort_index(level=1, axis=1)\nOut[111]: \n one      zero       one      zero\n x         x         y         y\n0  0.600178  2.410179  1.519970  0.132885\n1  0.274230  1.450520 -0.493662 -0.023688 \n```", "```py\nIn [112]: dfm = pd.DataFrame(\n .....:    {\"jim\": [0, 0, 1, 1], \"joe\": [\"x\", \"x\", \"z\", \"y\"], \"jolie\": np.random.rand(4)}\n .....: )\n .....: \n\nIn [113]: dfm = dfm.set_index([\"jim\", \"joe\"])\n\nIn [114]: dfm\nOut[114]: \n jolie\njim joe \n0   x    0.490671\n x    0.120248\n1   z    0.537020\n y    0.110968\n\nIn [115]: dfm.loc[(1, 'z')]\nOut[115]: \n jolie\njim joe \n1   z    0.53702 \n```", "```py\nIn [116]: dfm.loc[(0, 'y'):(1, 'z')]\n---------------------------------------------------------------------------\nUnsortedIndexError  Traceback (most recent call last)\nCell In[116], line 1\n----> 1 dfm.loc[(0, 'y'):(1, 'z')]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2904, in MultiIndex.slice_locs(self, start, end, step)\n  2852  \"\"\"\n  2853 For an ordered MultiIndex, compute the slice locations for input\n  2854 labels.\n (...)\n  2900 sequence of such.\n  2901 \"\"\"\n  2902 # This function adds nothing to its parent implementation (the magic\n  2903 # happens in get_slice_bound method), but it adds meaningful doc.\n-> 2904 return super().slice_locs(start, end, step)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n  6877 start_slice = None\n  6878 if start is not None:\n-> 6879     start_slice = self.get_slice_bound(start, \"left\")\n  6880 if start_slice is None:\n  6881     start_slice = 0\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2848, in MultiIndex.get_slice_bound(self, label, side)\n  2846 if not isinstance(label, tuple):\n  2847     label = (label,)\n-> 2848 return self._partial_tup_index(label, side=side)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/multi.py:2908, in MultiIndex._partial_tup_index(self, tup, side)\n  2906 def _partial_tup_index(self, tup: tuple, side: Literal[\"left\", \"right\"] = \"left\"):\n  2907     if len(tup) > self._lexsort_depth:\n-> 2908         raise UnsortedIndexError(\n  2909             f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n  2910             f\"({self._lexsort_depth})\"\n  2911         )\n  2913     n = len(tup)\n  2914     start, end = 0, len(self)\n\nUnsortedIndexError: 'Key length (2) was greater than MultiIndex lexsort depth (1)' \n```", "```py\nIn [117]: dfm.index.is_monotonic_increasing\nOut[117]: False \n```", "```py\nIn [118]: dfm = dfm.sort_index()\n\nIn [119]: dfm\nOut[119]: \n jolie\njim joe \n0   x    0.490671\n x    0.120248\n1   y    0.110968\n z    0.537020\n\nIn [120]: dfm.index.is_monotonic_increasing\nOut[120]: True \n```", "```py\nIn [121]: dfm.loc[(0, \"y\"):(1, \"z\")]\nOut[121]: \n jolie\njim joe \n1   y    0.110968\n z    0.537020 \n```", "```py\nIn [122]: index = pd.Index(np.random.randint(0, 1000, 10))\n\nIn [123]: index\nOut[123]: Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype='int64')\n\nIn [124]: positions = [0, 9, 3]\n\nIn [125]: index[positions]\nOut[125]: Index([214, 329, 567], dtype='int64')\n\nIn [126]: index.take(positions)\nOut[126]: Index([214, 329, 567], dtype='int64')\n\nIn [127]: ser = pd.Series(np.random.randn(10))\n\nIn [128]: ser.iloc[positions]\nOut[128]: \n0   -0.179666\n9    1.824375\n3    0.392149\ndtype: float64\n\nIn [129]: ser.take(positions)\nOut[129]: \n0   -0.179666\n9    1.824375\n3    0.392149\ndtype: float64 \n```", "```py\nIn [130]: frm = pd.DataFrame(np.random.randn(5, 3))\n\nIn [131]: frm.take([1, 4, 3])\nOut[131]: \n 0         1         2\n1 -1.237881  0.106854 -1.276829\n4  0.629675 -1.425966  1.857704\n3  0.979542 -1.633678  0.615855\n\nIn [132]: frm.take([0, 2], axis=1)\nOut[132]: \n 0         2\n0  0.595974  0.601544\n1 -1.237881 -1.276829\n2 -0.767101  1.499591\n3  0.979542  0.615855\n4  0.629675  1.857704 \n```", "```py\nIn [133]: arr = np.random.randn(10)\n\nIn [134]: arr.take([False, False, True, True])\nOut[134]: array([-1.1935, -1.1935,  0.6775,  0.6775])\n\nIn [135]: arr[[0, 1]]\nOut[135]: array([-1.1935,  0.6775])\n\nIn [136]: ser = pd.Series(np.random.randn(10))\n\nIn [137]: ser.take([False, False, True, True])\nOut[137]: \n0    0.233141\n0    0.233141\n1   -0.223540\n1   -0.223540\ndtype: float64\n\nIn [138]: ser.iloc[[0, 1]]\nOut[138]: \n0    0.233141\n1   -0.223540\ndtype: float64 \n```", "```py\nIn [139]: arr = np.random.randn(10000, 5)\n\nIn [140]: indexer = np.arange(10000)\n\nIn [141]: random.shuffle(indexer)\n\nIn [142]: %timeit arr[indexer]\n .....: %timeit arr.take(indexer, axis=0)\n .....: \n257 us +- 4.44 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each)\n79.7 us +- 1.15 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each) \n```", "```py\nIn [143]: ser = pd.Series(arr[:, 0])\n\nIn [144]: %timeit ser.iloc[indexer]\n .....: %timeit ser.take(indexer)\n .....: \n144 us +- 3.69 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each)\n129 us +- 2 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each) \n```", "```py\nIn [145]: from pandas.api.types import CategoricalDtype\n\nIn [146]: df = pd.DataFrame({\"A\": np.arange(6), \"B\": list(\"aabbca\")})\n\nIn [147]: df[\"B\"] = df[\"B\"].astype(CategoricalDtype(list(\"cab\")))\n\nIn [148]: df\nOut[148]: \n A  B\n0  0  a\n1  1  a\n2  2  b\n3  3  b\n4  4  c\n5  5  a\n\nIn [149]: df.dtypes\nOut[149]: \nA       int64\nB    category\ndtype: object\n\nIn [150]: df[\"B\"].cat.categories\nOut[150]: Index(['c', 'a', 'b'], dtype='object') \n```", "```py\nIn [151]: df2 = df.set_index(\"B\")\n\nIn [152]: df2.index\nOut[152]: CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [153]: df2.loc[\"a\"]\nOut[153]: \n A\nB \na  0\na  1\na  5 \n```", "```py\nIn [154]: df2.loc[\"a\"].index\nOut[154]: CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [155]: df2.sort_index()\nOut[155]: \n A\nB \nc  4\na  0\na  1\na  5\nb  2\nb  3 \n```", "```py\nIn [156]: df2.groupby(level=0, observed=True).sum()\nOut[156]: \n A\nB \nc  4\na  6\nb  5\n\nIn [157]: df2.groupby(level=0, observed=True).sum().index\nOut[157]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [158]: df3 = pd.DataFrame(\n .....:    {\"A\": np.arange(3), \"B\": pd.Series(list(\"abc\")).astype(\"category\")}\n .....: )\n .....: \n\nIn [159]: df3 = df3.set_index(\"B\")\n\nIn [160]: df3\nOut[160]: \n A\nB \na  0\nb  1\nc  2 \n```", "```py\nIn [161]: df3.reindex([\"a\", \"e\"])\nOut[161]: \n A\nB \na  0.0\ne  NaN\n\nIn [162]: df3.reindex([\"a\", \"e\"]).index\nOut[162]: Index(['a', 'e'], dtype='object', name='B')\n\nIn [163]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\")))\nOut[163]: \n A\nB \na  0.0\ne  NaN\n\nIn [164]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\"))).index\nOut[164]: CategoricalIndex(['a', 'e'], categories=['a', 'b', 'e'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [165]: df4 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"ba\")})\n\nIn [166]: df4[\"B\"] = df4[\"B\"].astype(CategoricalDtype(list(\"ab\")))\n\nIn [167]: df4 = df4.set_index(\"B\")\n\nIn [168]: df4.index\nOut[168]: CategoricalIndex(['b', 'a'], categories=['a', 'b'], ordered=False, dtype='category', name='B')\n\nIn [169]: df5 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"bc\")})\n\nIn [170]: df5[\"B\"] = df5[\"B\"].astype(CategoricalDtype(list(\"bc\")))\n\nIn [171]: df5 = df5.set_index(\"B\")\n\nIn [172]: df5.index\nOut[172]: CategoricalIndex(['b', 'c'], categories=['b', 'c'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [173]: pd.concat([df4, df5])\nOut[173]: \n A\nB \nb  0\na  1\nb  0\nc  1 \n```", "```py\nIn [174]: idx = pd.RangeIndex(5)\n\nIn [175]: idx\nOut[175]: RangeIndex(start=0, stop=5, step=1) \n```", "```py\nIn [176]: ser = pd.Series([1, 2, 3])\n\nIn [177]: ser.index\nOut[177]: RangeIndex(start=0, stop=3, step=1)\n\nIn [178]: df = pd.DataFrame([[1, 2], [3, 4]])\n\nIn [179]: df.index\nOut[179]: RangeIndex(start=0, stop=2, step=1)\n\nIn [180]: df.columns\nOut[180]: RangeIndex(start=0, stop=2, step=1) \n```", "```py\nIn [181]: idx[[0, 2]]\nOut[181]: Index([0, 2], dtype='int64') \n```", "```py\nIn [182]: df = pd.DataFrame(\n .....:    {\"A\": [1, 2, 3, 4]}, index=pd.IntervalIndex.from_breaks([0, 1, 2, 3, 4])\n .....: )\n .....: \n\nIn [183]: df\nOut[183]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [184]: df.loc[2]\nOut[184]: \nA    2\nName: (1, 2], dtype: int64\n\nIn [185]: df.loc[[2, 3]]\nOut[185]: \n A\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [186]: df.loc[2.5]\nOut[186]: \nA    3\nName: (2, 3], dtype: int64\n\nIn [187]: df.loc[[2.5, 3.5]]\nOut[187]: \n A\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [188]: df.loc[pd.Interval(1, 2)]\nOut[188]: \nA    2\nName: (1, 2], dtype: int64 \n```", "```py\nIn [189]: df.loc[pd.Interval(0.5, 2.5)]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[189], line 1\n----> 1 df.loc[pd.Interval(0.5, 2.5)]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1431, in _LocIndexer._getitem_axis(self, key, axis)\n  1429 # fall thru to straight lookup\n  1430 self._validate_key(key, axis)\n-> 1431 return self._get_label(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1381, in _LocIndexer._get_label(self, label, axis)\n  1379 def _get_label(self, label, axis: AxisInt):\n  1380     # GH#5567 this will fail if the label is not present in the axis.\n-> 1381     return self.obj.xs(label, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4301, in NDFrame.xs(self, key, axis, level, drop_level)\n  4299             new_index = index[loc]\n  4300 else:\n-> 4301     loc = index.get_loc(key)\n  4303     if isinstance(loc, np.ndarray):\n  4304         if loc.dtype == np.bool_:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/interval.py:678, in IntervalIndex.get_loc(self, key)\n  676 matches = mask.sum()\n  677 if matches == 0:\n--> 678     raise KeyError(key)\n  679 if matches == 1:\n  680     return mask.argmax()\n\nKeyError: Interval(0.5, 2.5, closed='right') \n```", "```py\nIn [190]: idxr = df.index.overlaps(pd.Interval(0.5, 2.5))\n\nIn [191]: idxr\nOut[191]: array([ True,  True,  True, False])\n\nIn [192]: df[idxr]\nOut[192]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [193]: c = pd.cut(range(4), bins=2)\n\nIn [194]: c\nOut[194]: \n[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]]\n\nIn [195]: c.categories\nOut[195]: IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], dtype='interval[float64, right]') \n```", "```py\nIn [196]: pd.cut([0, 3, 5, 1], bins=c.categories)\nOut[196]: \n[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]] \n```", "```py\nIn [197]: pd.interval_range(start=0, end=5)\nOut[197]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype='interval[int64, right]')\n\nIn [198]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4)\nOut[198]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-02 00:00:00],\n (2017-01-02 00:00:00, 2017-01-03 00:00:00],\n (2017-01-03 00:00:00, 2017-01-04 00:00:00],\n (2017-01-04 00:00:00, 2017-01-05 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [199]: pd.interval_range(end=pd.Timedelta(\"3 days\"), periods=3)\nOut[199]: \nIntervalIndex([(0 days 00:00:00, 1 days 00:00:00],\n (1 days 00:00:00, 2 days 00:00:00],\n (2 days 00:00:00, 3 days 00:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [200]: pd.interval_range(start=0, periods=5, freq=1.5)\nOut[200]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]], dtype='interval[float64, right]')\n\nIn [201]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4, freq=\"W\")\nOut[201]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-08 00:00:00],\n (2017-01-08 00:00:00, 2017-01-15 00:00:00],\n (2017-01-15 00:00:00, 2017-01-22 00:00:00],\n (2017-01-22 00:00:00, 2017-01-29 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [202]: pd.interval_range(start=pd.Timedelta(\"0 days\"), periods=3, freq=\"9h\")\nOut[202]: \nIntervalIndex([(0 days 00:00:00, 0 days 09:00:00],\n (0 days 09:00:00, 0 days 18:00:00],\n (0 days 18:00:00, 1 days 03:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [203]: pd.interval_range(start=0, end=4, closed=\"both\")\nOut[203]: IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]], dtype='interval[int64, both]')\n\nIn [204]: pd.interval_range(start=0, end=4, closed=\"neither\")\nOut[204]: IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)], dtype='interval[int64, neither]') \n```", "```py\nIn [205]: pd.interval_range(start=0, end=6, periods=4)\nOut[205]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], dtype='interval[float64, right]')\n\nIn [206]: pd.interval_range(pd.Timestamp(\"2018-01-01\"), pd.Timestamp(\"2018-02-28\"), periods=3)\nOut[206]: \nIntervalIndex([(2018-01-01 00:00:00, 2018-01-20 08:00:00],\n (2018-01-20 08:00:00, 2018-02-08 16:00:00],\n (2018-02-08 16:00:00, 2018-02-28 00:00:00]],\n dtype='interval[datetime64[ns], right]') \n```", "```py\nIn [145]: from pandas.api.types import CategoricalDtype\n\nIn [146]: df = pd.DataFrame({\"A\": np.arange(6), \"B\": list(\"aabbca\")})\n\nIn [147]: df[\"B\"] = df[\"B\"].astype(CategoricalDtype(list(\"cab\")))\n\nIn [148]: df\nOut[148]: \n A  B\n0  0  a\n1  1  a\n2  2  b\n3  3  b\n4  4  c\n5  5  a\n\nIn [149]: df.dtypes\nOut[149]: \nA       int64\nB    category\ndtype: object\n\nIn [150]: df[\"B\"].cat.categories\nOut[150]: Index(['c', 'a', 'b'], dtype='object') \n```", "```py\nIn [151]: df2 = df.set_index(\"B\")\n\nIn [152]: df2.index\nOut[152]: CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [153]: df2.loc[\"a\"]\nOut[153]: \n A\nB \na  0\na  1\na  5 \n```", "```py\nIn [154]: df2.loc[\"a\"].index\nOut[154]: CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [155]: df2.sort_index()\nOut[155]: \n A\nB \nc  4\na  0\na  1\na  5\nb  2\nb  3 \n```", "```py\nIn [156]: df2.groupby(level=0, observed=True).sum()\nOut[156]: \n A\nB \nc  4\na  6\nb  5\n\nIn [157]: df2.groupby(level=0, observed=True).sum().index\nOut[157]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [158]: df3 = pd.DataFrame(\n .....:    {\"A\": np.arange(3), \"B\": pd.Series(list(\"abc\")).astype(\"category\")}\n .....: )\n .....: \n\nIn [159]: df3 = df3.set_index(\"B\")\n\nIn [160]: df3\nOut[160]: \n A\nB \na  0\nb  1\nc  2 \n```", "```py\nIn [161]: df3.reindex([\"a\", \"e\"])\nOut[161]: \n A\nB \na  0.0\ne  NaN\n\nIn [162]: df3.reindex([\"a\", \"e\"]).index\nOut[162]: Index(['a', 'e'], dtype='object', name='B')\n\nIn [163]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\")))\nOut[163]: \n A\nB \na  0.0\ne  NaN\n\nIn [164]: df3.reindex(pd.Categorical([\"a\", \"e\"], categories=list(\"abe\"))).index\nOut[164]: CategoricalIndex(['a', 'e'], categories=['a', 'b', 'e'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [165]: df4 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"ba\")})\n\nIn [166]: df4[\"B\"] = df4[\"B\"].astype(CategoricalDtype(list(\"ab\")))\n\nIn [167]: df4 = df4.set_index(\"B\")\n\nIn [168]: df4.index\nOut[168]: CategoricalIndex(['b', 'a'], categories=['a', 'b'], ordered=False, dtype='category', name='B')\n\nIn [169]: df5 = pd.DataFrame({\"A\": np.arange(2), \"B\": list(\"bc\")})\n\nIn [170]: df5[\"B\"] = df5[\"B\"].astype(CategoricalDtype(list(\"bc\")))\n\nIn [171]: df5 = df5.set_index(\"B\")\n\nIn [172]: df5.index\nOut[172]: CategoricalIndex(['b', 'c'], categories=['b', 'c'], ordered=False, dtype='category', name='B') \n```", "```py\nIn [173]: pd.concat([df4, df5])\nOut[173]: \n A\nB \nb  0\na  1\nb  0\nc  1 \n```", "```py\nIn [174]: idx = pd.RangeIndex(5)\n\nIn [175]: idx\nOut[175]: RangeIndex(start=0, stop=5, step=1) \n```", "```py\nIn [176]: ser = pd.Series([1, 2, 3])\n\nIn [177]: ser.index\nOut[177]: RangeIndex(start=0, stop=3, step=1)\n\nIn [178]: df = pd.DataFrame([[1, 2], [3, 4]])\n\nIn [179]: df.index\nOut[179]: RangeIndex(start=0, stop=2, step=1)\n\nIn [180]: df.columns\nOut[180]: RangeIndex(start=0, stop=2, step=1) \n```", "```py\nIn [181]: idx[[0, 2]]\nOut[181]: Index([0, 2], dtype='int64') \n```", "```py\nIn [182]: df = pd.DataFrame(\n .....:    {\"A\": [1, 2, 3, 4]}, index=pd.IntervalIndex.from_breaks([0, 1, 2, 3, 4])\n .....: )\n .....: \n\nIn [183]: df\nOut[183]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [184]: df.loc[2]\nOut[184]: \nA    2\nName: (1, 2], dtype: int64\n\nIn [185]: df.loc[[2, 3]]\nOut[185]: \n A\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [186]: df.loc[2.5]\nOut[186]: \nA    3\nName: (2, 3], dtype: int64\n\nIn [187]: df.loc[[2.5, 3.5]]\nOut[187]: \n A\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [188]: df.loc[pd.Interval(1, 2)]\nOut[188]: \nA    2\nName: (1, 2], dtype: int64 \n```", "```py\nIn [189]: df.loc[pd.Interval(0.5, 2.5)]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[189], line 1\n----> 1 df.loc[pd.Interval(0.5, 2.5)]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1431, in _LocIndexer._getitem_axis(self, key, axis)\n  1429 # fall thru to straight lookup\n  1430 self._validate_key(key, axis)\n-> 1431 return self._get_label(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1381, in _LocIndexer._get_label(self, label, axis)\n  1379 def _get_label(self, label, axis: AxisInt):\n  1380     # GH#5567 this will fail if the label is not present in the axis.\n-> 1381     return self.obj.xs(label, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4301, in NDFrame.xs(self, key, axis, level, drop_level)\n  4299             new_index = index[loc]\n  4300 else:\n-> 4301     loc = index.get_loc(key)\n  4303     if isinstance(loc, np.ndarray):\n  4304         if loc.dtype == np.bool_:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/interval.py:678, in IntervalIndex.get_loc(self, key)\n  676 matches = mask.sum()\n  677 if matches == 0:\n--> 678     raise KeyError(key)\n  679 if matches == 1:\n  680     return mask.argmax()\n\nKeyError: Interval(0.5, 2.5, closed='right') \n```", "```py\nIn [190]: idxr = df.index.overlaps(pd.Interval(0.5, 2.5))\n\nIn [191]: idxr\nOut[191]: array([ True,  True,  True, False])\n\nIn [192]: df[idxr]\nOut[192]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [193]: c = pd.cut(range(4), bins=2)\n\nIn [194]: c\nOut[194]: \n[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]]\n\nIn [195]: c.categories\nOut[195]: IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], dtype='interval[float64, right]') \n```", "```py\nIn [196]: pd.cut([0, 3, 5, 1], bins=c.categories)\nOut[196]: \n[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]] \n```", "```py\nIn [197]: pd.interval_range(start=0, end=5)\nOut[197]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype='interval[int64, right]')\n\nIn [198]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4)\nOut[198]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-02 00:00:00],\n (2017-01-02 00:00:00, 2017-01-03 00:00:00],\n (2017-01-03 00:00:00, 2017-01-04 00:00:00],\n (2017-01-04 00:00:00, 2017-01-05 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [199]: pd.interval_range(end=pd.Timedelta(\"3 days\"), periods=3)\nOut[199]: \nIntervalIndex([(0 days 00:00:00, 1 days 00:00:00],\n (1 days 00:00:00, 2 days 00:00:00],\n (2 days 00:00:00, 3 days 00:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [200]: pd.interval_range(start=0, periods=5, freq=1.5)\nOut[200]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]], dtype='interval[float64, right]')\n\nIn [201]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4, freq=\"W\")\nOut[201]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-08 00:00:00],\n (2017-01-08 00:00:00, 2017-01-15 00:00:00],\n (2017-01-15 00:00:00, 2017-01-22 00:00:00],\n (2017-01-22 00:00:00, 2017-01-29 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [202]: pd.interval_range(start=pd.Timedelta(\"0 days\"), periods=3, freq=\"9h\")\nOut[202]: \nIntervalIndex([(0 days 00:00:00, 0 days 09:00:00],\n (0 days 09:00:00, 0 days 18:00:00],\n (0 days 18:00:00, 1 days 03:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [203]: pd.interval_range(start=0, end=4, closed=\"both\")\nOut[203]: IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]], dtype='interval[int64, both]')\n\nIn [204]: pd.interval_range(start=0, end=4, closed=\"neither\")\nOut[204]: IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)], dtype='interval[int64, neither]') \n```", "```py\nIn [205]: pd.interval_range(start=0, end=6, periods=4)\nOut[205]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], dtype='interval[float64, right]')\n\nIn [206]: pd.interval_range(pd.Timestamp(\"2018-01-01\"), pd.Timestamp(\"2018-02-28\"), periods=3)\nOut[206]: \nIntervalIndex([(2018-01-01 00:00:00, 2018-01-20 08:00:00],\n (2018-01-20 08:00:00, 2018-02-08 16:00:00],\n (2018-02-08 16:00:00, 2018-02-28 00:00:00]],\n dtype='interval[datetime64[ns], right]') \n```", "```py\nIn [182]: df = pd.DataFrame(\n .....:    {\"A\": [1, 2, 3, 4]}, index=pd.IntervalIndex.from_breaks([0, 1, 2, 3, 4])\n .....: )\n .....: \n\nIn [183]: df\nOut[183]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [184]: df.loc[2]\nOut[184]: \nA    2\nName: (1, 2], dtype: int64\n\nIn [185]: df.loc[[2, 3]]\nOut[185]: \n A\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [186]: df.loc[2.5]\nOut[186]: \nA    3\nName: (2, 3], dtype: int64\n\nIn [187]: df.loc[[2.5, 3.5]]\nOut[187]: \n A\n(2, 3]  3\n(3, 4]  4 \n```", "```py\nIn [188]: df.loc[pd.Interval(1, 2)]\nOut[188]: \nA    2\nName: (1, 2], dtype: int64 \n```", "```py\nIn [189]: df.loc[pd.Interval(0.5, 2.5)]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[189], line 1\n----> 1 df.loc[pd.Interval(0.5, 2.5)]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)\n  1189 maybe_callable = com.apply_if_callable(key, self.obj)\n  1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)\n-> 1191 return self._getitem_axis(maybe_callable, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1431, in _LocIndexer._getitem_axis(self, key, axis)\n  1429 # fall thru to straight lookup\n  1430 self._validate_key(key, axis)\n-> 1431 return self._get_label(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1381, in _LocIndexer._get_label(self, label, axis)\n  1379 def _get_label(self, label, axis: AxisInt):\n  1380     # GH#5567 this will fail if the label is not present in the axis.\n-> 1381     return self.obj.xs(label, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/generic.py:4301, in NDFrame.xs(self, key, axis, level, drop_level)\n  4299             new_index = index[loc]\n  4300 else:\n-> 4301     loc = index.get_loc(key)\n  4303     if isinstance(loc, np.ndarray):\n  4304         if loc.dtype == np.bool_:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/interval.py:678, in IntervalIndex.get_loc(self, key)\n  676 matches = mask.sum()\n  677 if matches == 0:\n--> 678     raise KeyError(key)\n  679 if matches == 1:\n  680     return mask.argmax()\n\nKeyError: Interval(0.5, 2.5, closed='right') \n```", "```py\nIn [190]: idxr = df.index.overlaps(pd.Interval(0.5, 2.5))\n\nIn [191]: idxr\nOut[191]: array([ True,  True,  True, False])\n\nIn [192]: df[idxr]\nOut[192]: \n A\n(0, 1]  1\n(1, 2]  2\n(2, 3]  3 \n```", "```py\nIn [193]: c = pd.cut(range(4), bins=2)\n\nIn [194]: c\nOut[194]: \n[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]]\n\nIn [195]: c.categories\nOut[195]: IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], dtype='interval[float64, right]') \n```", "```py\nIn [196]: pd.cut([0, 3, 5, 1], bins=c.categories)\nOut[196]: \n[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]\nCategories (2, interval[float64, right]): [(-0.003, 1.5] < (1.5, 3.0]] \n```", "```py\nIn [197]: pd.interval_range(start=0, end=5)\nOut[197]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype='interval[int64, right]')\n\nIn [198]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4)\nOut[198]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-02 00:00:00],\n (2017-01-02 00:00:00, 2017-01-03 00:00:00],\n (2017-01-03 00:00:00, 2017-01-04 00:00:00],\n (2017-01-04 00:00:00, 2017-01-05 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [199]: pd.interval_range(end=pd.Timedelta(\"3 days\"), periods=3)\nOut[199]: \nIntervalIndex([(0 days 00:00:00, 1 days 00:00:00],\n (1 days 00:00:00, 2 days 00:00:00],\n (2 days 00:00:00, 3 days 00:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [200]: pd.interval_range(start=0, periods=5, freq=1.5)\nOut[200]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]], dtype='interval[float64, right]')\n\nIn [201]: pd.interval_range(start=pd.Timestamp(\"2017-01-01\"), periods=4, freq=\"W\")\nOut[201]: \nIntervalIndex([(2017-01-01 00:00:00, 2017-01-08 00:00:00],\n (2017-01-08 00:00:00, 2017-01-15 00:00:00],\n (2017-01-15 00:00:00, 2017-01-22 00:00:00],\n (2017-01-22 00:00:00, 2017-01-29 00:00:00]],\n dtype='interval[datetime64[ns], right]')\n\nIn [202]: pd.interval_range(start=pd.Timedelta(\"0 days\"), periods=3, freq=\"9h\")\nOut[202]: \nIntervalIndex([(0 days 00:00:00, 0 days 09:00:00],\n (0 days 09:00:00, 0 days 18:00:00],\n (0 days 18:00:00, 1 days 03:00:00]],\n dtype='interval[timedelta64[ns], right]') \n```", "```py\nIn [203]: pd.interval_range(start=0, end=4, closed=\"both\")\nOut[203]: IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]], dtype='interval[int64, both]')\n\nIn [204]: pd.interval_range(start=0, end=4, closed=\"neither\")\nOut[204]: IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)], dtype='interval[int64, neither]') \n```", "```py\nIn [205]: pd.interval_range(start=0, end=6, periods=4)\nOut[205]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], dtype='interval[float64, right]')\n\nIn [206]: pd.interval_range(pd.Timestamp(\"2018-01-01\"), pd.Timestamp(\"2018-02-28\"), periods=3)\nOut[206]: \nIntervalIndex([(2018-01-01 00:00:00, 2018-01-20 08:00:00],\n (2018-01-20 08:00:00, 2018-02-08 16:00:00],\n (2018-02-08 16:00:00, 2018-02-28 00:00:00]],\n dtype='interval[datetime64[ns], right]') \n```", "```py\nIn [207]: s = pd.Series(range(5))\n\nIn [208]: s[-1]\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)\n  412 try:\n--> 413     return self._range.index(new_key)\n  414 except ValueError as err:\n\nValueError: -1 is not in range\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[208], line 1\n----> 1 s[-1]\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)\n  1118     return self._values[key]\n  1120 elif key_is_scalar:\n-> 1121     return self._get_value(key)\n  1123 # Convert generator to list before going through hashable part\n  1124 # (We will iterate through the generator there to check for slices)\n  1125 if is_iterator(key):\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)\n  1234     return self._values[label]\n  1236 # Similar to Index.get_value, but we do not fall back to positional\n-> 1237 loc = self.index.get_loc(label)\n  1239 if is_integer(loc):\n  1240     return self._values[loc]\n\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)\n  413         return self._range.index(new_key)\n  414     except ValueError as err:\n--> 415         raise KeyError(key) from err\n  416 if isinstance(key, Hashable):\n  417     raise KeyError(key)\n\nKeyError: -1\n\nIn [209]: df = pd.DataFrame(np.random.randn(5, 4))\n\nIn [210]: df\nOut[210]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221\n\nIn [211]: df.loc[-2:]\nOut[211]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221 \n```", "```py\nIn [212]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=[\"data\"], data=list(range(5)))\n\nIn [213]: df.index.is_monotonic_increasing\nOut[213]: True\n\n# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:\nIn [214]: df.loc[0:4, :]\nOut[214]: \n data\n2     0\n3     1\n3     2\n4     3\n\n# slice is are outside the index, so empty DataFrame is returned\nIn [215]: df.loc[13:15, :]\nOut[215]: \nEmpty DataFrame\nColumns: [data]\nIndex: [] \n```", "```py\nIn [216]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5], columns=[\"data\"], data=list(range(6)))\n\nIn [217]: df.index.is_monotonic_increasing\nOut[217]: False\n\n# OK because 2 and 4 are in the index\nIn [218]: df.loc[2:4, :]\nOut[218]: \n data\n2     0\n3     1\n1     2\n4     3 \n```", "```py\n # 0 is not in the index\nIn [219]: df.loc[0:4, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n  3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n  3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:191, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:234, in pandas._libs.index.IndexEngine._get_loc_duplicates()\n\nFile index.pyx:242, in pandas._libs.index.IndexEngine._maybe_get_bool_indexer()\n\nFile index.pyx:134, in pandas._libs.index._unpack_bool_indexer()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[219], line 1\n----> 1 df.loc[0:4, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n  6877 start_slice = None\n  6878 if start is not None:\n-> 6879     start_slice = self.get_slice_bound(start, \"left\")\n  6880 if start_slice is None:\n  6881     start_slice = 0\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6804, in Index.get_slice_bound(self, label, side)\n  6801         return self._searchsorted_monotonic(label, side)\n  6802     except ValueError:\n  6803         # raise the original KeyError\n-> 6804         raise err\n  6806 if isinstance(slc, np.ndarray):\n  6807     # get_loc may return a boolean array, which\n  6808     # is OK as long as they are representable by a slice.\n  6809     assert is_bool_dtype(slc.dtype)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6798, in Index.get_slice_bound(self, label, side)\n  6796 # we need to look up the label\n  6797 try:\n-> 6798     slc = self.get_loc(label)\n  6799 except KeyError as err:\n  6800     try:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n  3807     if isinstance(casted_key, slice) or (\n  3808         isinstance(casted_key, abc.Iterable)\n  3809         and any(isinstance(x, slice) for x in casted_key)\n  3810     ):\n  3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n  3813 except TypeError:\n  3814     # If we have a listlike key, _check_indexing_error will raise\n  3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n  3816     #  the TypeError.\n  3817     self._check_indexing_error(key)\n\nKeyError: 0\n\n # 3 is not a unique label\nIn [220]: df.loc[2:3, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[220], line 1\n----> 1 df.loc[2:3, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6885, in Index.slice_locs(self, start, end, step)\n  6883 end_slice = None\n  6884 if end is not None:\n-> 6885     end_slice = self.get_slice_bound(end, \"right\")\n  6886 if end_slice is None:\n  6887     end_slice = len(self)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6812, in Index.get_slice_bound(self, label, side)\n  6810     slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n  6811     if isinstance(slc, np.ndarray):\n-> 6812         raise KeyError(\n  6813             f\"Cannot get {side} slice bound for non-unique \"\n  6814             f\"label: {repr(original_label)}\"\n  6815         )\n  6817 if isinstance(slc, slice):\n  6818     if side == \"left\":\n\nKeyError: 'Cannot get right slice bound for non-unique label: 3' \n```", "```py\nIn [221]: weakly_monotonic = pd.Index([\"a\", \"b\", \"c\", \"c\"])\n\nIn [222]: weakly_monotonic\nOut[222]: Index(['a', 'b', 'c', 'c'], dtype='object')\n\nIn [223]: weakly_monotonic.is_monotonic_increasing\nOut[223]: True\n\nIn [224]: weakly_monotonic.is_monotonic_increasing & weakly_monotonic.is_unique\nOut[224]: False \n```", "```py\nIn [225]: s = pd.Series(np.random.randn(6), index=list(\"abcdef\"))\n\nIn [226]: s\nOut[226]: \na   -0.101684\nb   -0.734907\nc   -0.130121\nd   -0.476046\ne    0.759104\nf    0.213379\ndtype: float64 \n```", "```py\nIn [227]: s[2:5]\nOut[227]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [228]: s.loc['c':'e' + 1]\n---------------------------------------------------------------------------\nTypeError  Traceback (most recent call last)\nCell In[228], line 1\n----> 1 s.loc['c':'e' + 1]\n\nTypeError: can only concatenate str (not \"int\") to str \n```", "```py\nIn [229]: s.loc[\"c\":\"e\"]\nOut[229]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [230]: series1 = pd.Series([1, 2, 3])\n\nIn [231]: series1.dtype\nOut[231]: dtype('int64')\n\nIn [232]: res = series1.reindex([0, 4])\n\nIn [233]: res.dtype\nOut[233]: dtype('float64')\n\nIn [234]: res\nOut[234]: \n0    1.0\n4    NaN\ndtype: float64 \n```", "```py\nIn [235]: series2 = pd.Series([True])\n\nIn [236]: series2.dtype\nOut[236]: dtype('bool')\n\nIn [237]: res = series2.reindex_like(series1)\n\nIn [238]: res.dtype\nOut[238]: dtype('O')\n\nIn [239]: res\nOut[239]: \n0    True\n1     NaN\n2     NaN\ndtype: object \n```", "```py\nIn [207]: s = pd.Series(range(5))\n\nIn [208]: s[-1]\n---------------------------------------------------------------------------\nValueError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)\n  412 try:\n--> 413     return self._range.index(new_key)\n  414 except ValueError as err:\n\nValueError: -1 is not in range\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[208], line 1\n----> 1 s[-1]\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)\n  1118     return self._values[key]\n  1120 elif key_is_scalar:\n-> 1121     return self._get_value(key)\n  1123 # Convert generator to list before going through hashable part\n  1124 # (We will iterate through the generator there to check for slices)\n  1125 if is_iterator(key):\n\nFile ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)\n  1234     return self._values[label]\n  1236 # Similar to Index.get_value, but we do not fall back to positional\n-> 1237 loc = self.index.get_loc(label)\n  1239 if is_integer(loc):\n  1240     return self._values[loc]\n\nFile ~/work/pandas/pandas/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)\n  413         return self._range.index(new_key)\n  414     except ValueError as err:\n--> 415         raise KeyError(key) from err\n  416 if isinstance(key, Hashable):\n  417     raise KeyError(key)\n\nKeyError: -1\n\nIn [209]: df = pd.DataFrame(np.random.randn(5, 4))\n\nIn [210]: df\nOut[210]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221\n\nIn [211]: df.loc[-2:]\nOut[211]: \n 0         1         2         3\n0 -0.435772 -1.188928 -0.808286 -0.284634\n1 -1.815703  1.347213 -0.243487  0.514704\n2  1.162969 -0.287725 -0.179734  0.993962\n3 -0.212673  0.909872 -0.733333 -0.349893\n4  0.456434 -0.306735  0.553396  0.166221 \n```", "```py\nIn [212]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=[\"data\"], data=list(range(5)))\n\nIn [213]: df.index.is_monotonic_increasing\nOut[213]: True\n\n# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:\nIn [214]: df.loc[0:4, :]\nOut[214]: \n data\n2     0\n3     1\n3     2\n4     3\n\n# slice is are outside the index, so empty DataFrame is returned\nIn [215]: df.loc[13:15, :]\nOut[215]: \nEmpty DataFrame\nColumns: [data]\nIndex: [] \n```", "```py\nIn [216]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5], columns=[\"data\"], data=list(range(6)))\n\nIn [217]: df.index.is_monotonic_increasing\nOut[217]: False\n\n# OK because 2 and 4 are in the index\nIn [218]: df.loc[2:4, :]\nOut[218]: \n data\n2     0\n3     1\n1     2\n4     3 \n```", "```py\n # 0 is not in the index\nIn [219]: df.loc[0:4, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n  3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n  3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:191, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:234, in pandas._libs.index.IndexEngine._get_loc_duplicates()\n\nFile index.pyx:242, in pandas._libs.index.IndexEngine._maybe_get_bool_indexer()\n\nFile index.pyx:134, in pandas._libs.index._unpack_bool_indexer()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError  Traceback (most recent call last)\nCell In[219], line 1\n----> 1 df.loc[0:4, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)\n  6877 start_slice = None\n  6878 if start is not None:\n-> 6879     start_slice = self.get_slice_bound(start, \"left\")\n  6880 if start_slice is None:\n  6881     start_slice = 0\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6804, in Index.get_slice_bound(self, label, side)\n  6801         return self._searchsorted_monotonic(label, side)\n  6802     except ValueError:\n  6803         # raise the original KeyError\n-> 6804         raise err\n  6806 if isinstance(slc, np.ndarray):\n  6807     # get_loc may return a boolean array, which\n  6808     # is OK as long as they are representable by a slice.\n  6809     assert is_bool_dtype(slc.dtype)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6798, in Index.get_slice_bound(self, label, side)\n  6796 # we need to look up the label\n  6797 try:\n-> 6798     slc = self.get_loc(label)\n  6799 except KeyError as err:\n  6800     try:\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n  3807     if isinstance(casted_key, slice) or (\n  3808         isinstance(casted_key, abc.Iterable)\n  3809         and any(isinstance(x, slice) for x in casted_key)\n  3810     ):\n  3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n  3813 except TypeError:\n  3814     # If we have a listlike key, _check_indexing_error will raise\n  3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n  3816     #  the TypeError.\n  3817     self._check_indexing_error(key)\n\nKeyError: 0\n\n # 3 is not a unique label\nIn [220]: df.loc[2:3, :]\n---------------------------------------------------------------------------\nKeyError  Traceback (most recent call last)\nCell In[220], line 1\n----> 1 df.loc[2:3, :]\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n  1182     if self._is_scalar_access(key):\n  1183         return self.obj._get_value(*key, takeable=self._takeable)\n-> 1184     return self._getitem_tuple(key)\n  1185 else:\n  1186     # we by definition only have the 0th axis\n  1187     axis = self.axis or 0\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)\n  1374 if self._multi_take_opportunity(tup):\n  1375     return self._multi_take(tup)\n-> 1377 return self._getitem_tuple_same_dim(tup)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)\n  1017 if com.is_null_slice(key):\n  1018     continue\n-> 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n  1021 # We should never have retval.ndim < self.ndim, as that should\n  1022 #  be handled by the _getitem_lowerdim call above.\n  1023 assert retval.ndim == self.ndim\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)\n  1409 if isinstance(key, slice):\n  1410     self._validate_key(key, axis)\n-> 1411     return self._get_slice_axis(key, axis=axis)\n  1412 elif com.is_bool_indexer(key):\n  1413     return self._getbool_axis(key, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)\n  1440     return obj.copy(deep=False)\n  1442 labels = obj._get_axis(axis)\n-> 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)\n  1445 if isinstance(indexer, slice):\n  1446     return self.obj._slice(indexer, axis=axis)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)\n  6618 def slice_indexer(\n  6619     self,\n  6620     start: Hashable | None = None,\n  6621     end: Hashable | None = None,\n  6622     step: int | None = None,\n  6623 ) -> slice:\n  6624  \"\"\"\n  6625 Compute the slice indexer for input labels and step.\n  6626  \n (...)\n  6660 slice(1, 3, None)\n  6661 \"\"\"\n-> 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)\n  6664     # return a slice\n  6665     if not is_scalar(start_slice):\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6885, in Index.slice_locs(self, start, end, step)\n  6883 end_slice = None\n  6884 if end is not None:\n-> 6885     end_slice = self.get_slice_bound(end, \"right\")\n  6886 if end_slice is None:\n  6887     end_slice = len(self)\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:6812, in Index.get_slice_bound(self, label, side)\n  6810     slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n  6811     if isinstance(slc, np.ndarray):\n-> 6812         raise KeyError(\n  6813             f\"Cannot get {side} slice bound for non-unique \"\n  6814             f\"label: {repr(original_label)}\"\n  6815         )\n  6817 if isinstance(slc, slice):\n  6818     if side == \"left\":\n\nKeyError: 'Cannot get right slice bound for non-unique label: 3' \n```", "```py\nIn [221]: weakly_monotonic = pd.Index([\"a\", \"b\", \"c\", \"c\"])\n\nIn [222]: weakly_monotonic\nOut[222]: Index(['a', 'b', 'c', 'c'], dtype='object')\n\nIn [223]: weakly_monotonic.is_monotonic_increasing\nOut[223]: True\n\nIn [224]: weakly_monotonic.is_monotonic_increasing & weakly_monotonic.is_unique\nOut[224]: False \n```", "```py\nIn [225]: s = pd.Series(np.random.randn(6), index=list(\"abcdef\"))\n\nIn [226]: s\nOut[226]: \na   -0.101684\nb   -0.734907\nc   -0.130121\nd   -0.476046\ne    0.759104\nf    0.213379\ndtype: float64 \n```", "```py\nIn [227]: s[2:5]\nOut[227]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [228]: s.loc['c':'e' + 1]\n---------------------------------------------------------------------------\nTypeError  Traceback (most recent call last)\nCell In[228], line 1\n----> 1 s.loc['c':'e' + 1]\n\nTypeError: can only concatenate str (not \"int\") to str \n```", "```py\nIn [229]: s.loc[\"c\":\"e\"]\nOut[229]: \nc   -0.130121\nd   -0.476046\ne    0.759104\ndtype: float64 \n```", "```py\nIn [230]: series1 = pd.Series([1, 2, 3])\n\nIn [231]: series1.dtype\nOut[231]: dtype('int64')\n\nIn [232]: res = series1.reindex([0, 4])\n\nIn [233]: res.dtype\nOut[233]: dtype('float64')\n\nIn [234]: res\nOut[234]: \n0    1.0\n4    NaN\ndtype: float64 \n```", "```py\nIn [235]: series2 = pd.Series([True])\n\nIn [236]: series2.dtype\nOut[236]: dtype('bool')\n\nIn [237]: res = series2.reindex_like(series1)\n\nIn [238]: res.dtype\nOut[238]: dtype('O')\n\nIn [239]: res\nOut[239]: \n0    True\n1     NaN\n2     NaN\ndtype: object \n```"]