- en: scipy.integrate.solve_ivp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solve an initial value problem for a system of ODEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function numerically integrates a system of ordinary differential equations
    given an initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here t is a 1-D independent variable (time), y(t) is an N-D vector-valued function
    (state), and an N-D vector-valued function f(t, y) determines the differential
    equations. The goal is to find y(t) approximately satisfying the differential
    equations, given an initial value y(t0)=y0.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the solvers support integration in the complex domain, but note that
    for stiff ODE solvers, the right-hand side must be complex-differentiable (satisfy
    Cauchy-Riemann equations [[11]](#r179348322575-11)). To solve a problem in the
    complex domain, pass y0 with a complex data type. Another option always available
    is to rewrite your problem for real and imaginary parts separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-hand side of the system: the time derivative of the state `y` at time
    `t`. The calling signature is `fun(t, y)`, where `t` is a scalar and `y` is an
    ndarray with `len(y) = len(y0)`. Additional arguments need to be passed if `args`
    is used (see documentation of `args` argument). `fun` must return an array of
    the same shape as `y`. See *vectorized* for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '**t_span**2-member sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Interval of integration (t0, tf). The solver starts with t=t0 and integrates
    until it reaches t=tf. Both t0 and tf must be floats or values interpretable by
    the float conversion function.
  prefs: []
  type: TYPE_NORMAL
- en: '**y0**array_like, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial state. For problems in the complex domain, pass *y0* with a complex
    data type (even if the initial value is purely real).
  prefs: []
  type: TYPE_NORMAL
- en: '**method**string or [`OdeSolver`](scipy.integrate.OdeSolver.html#scipy.integrate.OdeSolver
    "scipy.integrate.OdeSolver"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration method to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘RK45’ (default): Explicit Runge-Kutta method of order 5(4) [[1]](#r179348322575-1).
    The error is controlled assuming accuracy of the fourth-order method, but steps
    are taken using the fifth-order accurate formula (local extrapolation is done).
    A quartic interpolation polynomial is used for the dense output [[2]](#r179348322575-2).
    Can be applied in the complex domain.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘RK23’: Explicit Runge-Kutta method of order 3(2) [[3]](#r179348322575-3).
    The error is controlled assuming accuracy of the second-order method, but steps
    are taken using the third-order accurate formula (local extrapolation is done).
    A cubic Hermite polynomial is used for the dense output. Can be applied in the
    complex domain.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘DOP853’: Explicit Runge-Kutta method of order 8 [[13]](#r179348322575-13).
    Python implementation of the “DOP853” algorithm originally written in Fortran
    [[14]](#r179348322575-14). A 7-th order interpolation polynomial accurate to 7-th
    order is used for the dense output. Can be applied in the complex domain.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘Radau’: Implicit Runge-Kutta method of the Radau IIA family of order 5 [[4]](#r179348322575-4).
    The error is controlled with a third-order accurate embedded formula. A cubic
    polynomial which satisfies the collocation conditions is used for the dense output.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘BDF’: Implicit multi-step variable-order (1 to 5) method based on a backward
    differentiation formula for the derivative approximation [[5]](#r179348322575-5).
    The implementation follows the one described in [[6]](#r179348322575-6). A quasi-constant
    step scheme is used and accuracy is enhanced using the NDF modification. Can be
    applied in the complex domain.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘LSODA’: Adams/BDF method with automatic stiffness detection and switching
    [[7]](#r179348322575-7), [[8]](#r179348322575-8). This is a wrapper of the Fortran
    solver from ODEPACK.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit Runge-Kutta methods (‘RK23’, ‘RK45’, ‘DOP853’) should be used for non-stiff
    problems and implicit methods (‘Radau’, ‘BDF’) for stiff problems [[9]](#r179348322575-9).
    Among Runge-Kutta methods, ‘DOP853’ is recommended for solving with high precision
    (low values of *rtol* and *atol*).
  prefs: []
  type: TYPE_NORMAL
- en: If not sure, first try to run ‘RK45’. If it makes unusually many iterations,
    diverges, or fails, your problem is likely to be stiff and you should use ‘Radau’
    or ‘BDF’. ‘LSODA’ can also be a good universal choice, but it might be somewhat
    less convenient to work with as it wraps old Fortran code.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass an arbitrary class derived from [`OdeSolver`](scipy.integrate.OdeSolver.html#scipy.integrate.OdeSolver
    "scipy.integrate.OdeSolver") which implements the solver.
  prefs: []
  type: TYPE_NORMAL
- en: '**t_eval**array_like or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Times at which to store the computed solution, must be sorted and lie within
    *t_span*. If None (default), use points selected by the solver.
  prefs: []
  type: TYPE_NORMAL
- en: '**dense_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to compute a continuous solution. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: '**events**callable, or list of callables, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events to track. If None (default), no events will be tracked. Each event occurs
    at the zeros of a continuous function of time and state. Each function must have
    the signature `event(t, y)` where additional argument have to be passed if `args`
    is used (see documentation of `args` argument). Each function must return a float.
    The solver will find an accurate value of *t* at which `event(t, y(t)) = 0` using
    a root-finding algorithm. By default, all zeros will be found. The solver looks
    for a sign change over each step, so if multiple zero crossings occur within one
    step, events may be missed. Additionally each *event* function might have the
    following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'terminal: bool, optional'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether to terminate integration if this event occurs. Implicitly False if not
    assigned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'direction: float, optional'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Direction of a zero crossing. If *direction* is positive, *event* will only
    trigger when going from negative to positive, and vice versa if *direction* is
    negative. If 0, then either direction will trigger event. Implicitly 0 if not
    assigned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can assign attributes like `event.terminal = True` to any function in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**vectorized**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether *fun* can be called in a vectorized fashion. Default is False.
  prefs: []
  type: TYPE_NORMAL
- en: If `vectorized` is False, *fun* will always be called with `y` of shape `(n,)`,
    where `n = len(y0)`.
  prefs: []
  type: TYPE_NORMAL
- en: If `vectorized` is True, *fun* may be called with `y` of shape `(n, k)`, where
    `k` is an integer. In this case, *fun* must behave such that `fun(t, y)[:, i]
    == fun(t, y[:, i])` (i.e. each column of the returned array is the time derivative
    of the state corresponding with a column of `y`).
  prefs: []
  type: TYPE_NORMAL
- en: Setting `vectorized=True` allows for faster finite difference approximation
    of the Jacobian by methods ‘Radau’ and ‘BDF’, but will result in slower execution
    for other methods and for ‘Radau’ and ‘BDF’ in some circumstances (e.g. small
    `len(y0)`).
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Additional arguments to pass to the user-defined functions. If given, the additional
    arguments are passed to all user-defined functions. So if, for example, *fun*
    has the signature `fun(t, y, a, b, c)`, then *jac* (if given) and any event functions
    must have the same signature, and *args* must be a tuple of length 3.
  prefs: []
  type: TYPE_NORMAL
- en: '****options**'
  prefs: []
  type: TYPE_NORMAL
- en: Options passed to a chosen solver. All options available for already implemented
    solvers are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: '**first_step**float or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Initial step size. Default is *None* which means that the algorithm should choose.
  prefs: []
  type: TYPE_NORMAL
- en: '**max_step**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum allowed step size. Default is np.inf, i.e., the step size is not bounded
    and determined solely by the solver.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol, atol**float or array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative and absolute tolerances. The solver keeps the local error estimates
    less than `atol + rtol * abs(y)`. Here *rtol* controls a relative accuracy (number
    of correct digits), while *atol* controls absolute accuracy (number of correct
    decimal places). To achieve the desired *rtol*, set *atol* to be smaller than
    the smallest value that can be expected from `rtol * abs(y)` so that *rtol* dominates
    the allowable error. If *atol* is larger than `rtol * abs(y)` the number of correct
    digits is not guaranteed. Conversely, to achieve the desired *atol* set *rtol*
    such that `rtol * abs(y)` is always smaller than *atol*. If components of y have
    different scales, it might be beneficial to set different *atol* values for different
    components by passing array_like with shape (n,) for *atol*. Default values are
    1e-3 for *rtol* and 1e-6 for *atol*.
  prefs: []
  type: TYPE_NORMAL
- en: '**jac**array_like, sparse_matrix, callable or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jacobian matrix of the right-hand side of the system with respect to y, required
    by the ‘Radau’, ‘BDF’ and ‘LSODA’ method. The Jacobian matrix has shape (n, n)
    and its element (i, j) is equal to `d f_i / d y_j`. There are three ways to define
    the Jacobian:'
  prefs: []
  type: TYPE_NORMAL
- en: If array_like or sparse_matrix, the Jacobian is assumed to be constant. Not
    supported by ‘LSODA’.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If callable, the Jacobian is assumed to depend on both t and y; it will be called
    as `jac(t, y)`, as necessary. Additional arguments have to be passed if `args`
    is used (see documentation of `args` argument). For ‘Radau’ and ‘BDF’ methods,
    the return value might be a sparse matrix.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If None (default), the Jacobian will be approximated by finite differences.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: It is generally recommended to provide the Jacobian rather than relying on a
    finite-difference approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '**jac_sparsity**array_like, sparse matrix or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a sparsity structure of the Jacobian matrix for a finite- difference
    approximation. Its shape must be (n, n). This argument is ignored if *jac* is
    not *None*. If the Jacobian has only few non-zero elements in *each* row, providing
    the sparsity structure will greatly speed up the computations [[10]](#r179348322575-10).
    A zero entry means that a corresponding element in the Jacobian is always zero.
    If None (default), the Jacobian is assumed to be dense. Not supported by ‘LSODA’,
    see *lband* and *uband* instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**lband, uband**int or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters defining the bandwidth of the Jacobian for the ‘LSODA’ method, i.e.,
    `jac[i, j] != 0 only for i - lband <= j <= i + uband`. Default is None. Setting
    these requires your jac routine to return the Jacobian in the packed format: the
    returned array must have `n` columns and `uband + lband + 1` rows in which Jacobian
    diagonals are written. Specifically `jac_packed[uband + i - j , j] = jac[i, j]`.
    The same format is used in [`scipy.linalg.solve_banded`](scipy.linalg.solve_banded.html#scipy.linalg.solve_banded
    "scipy.linalg.solve_banded") (check for an illustration). These parameters can
    be also used with `jac=None` to reduce the number of Jacobian elements estimated
    by finite differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '**min_step**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum allowed step size for ‘LSODA’ method. By default *min_step* is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bunch object with the following fields defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**ndarray, shape (n_points,)'
  prefs: []
  type: TYPE_NORMAL
- en: Time points.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**ndarray, shape (n, n_points)'
  prefs: []
  type: TYPE_NORMAL
- en: Values of the solution at *t*.
  prefs: []
  type: TYPE_NORMAL
- en: '**sol**[`OdeSolution`](scipy.integrate.OdeSolution.html#scipy.integrate.OdeSolution
    "scipy.integrate.OdeSolution") or None'
  prefs: []
  type: TYPE_NORMAL
- en: Found solution as [`OdeSolution`](scipy.integrate.OdeSolution.html#scipy.integrate.OdeSolution
    "scipy.integrate.OdeSolution") instance; None if *dense_output* was set to False.
  prefs: []
  type: TYPE_NORMAL
- en: '**t_events**list of ndarray or None'
  prefs: []
  type: TYPE_NORMAL
- en: Contains for each event type a list of arrays at which an event of that type
    event was detected. None if *events* was None.
  prefs: []
  type: TYPE_NORMAL
- en: '**y_events**list of ndarray or None'
  prefs: []
  type: TYPE_NORMAL
- en: For each value of *t_events*, the corresponding value of the solution. None
    if *events* was None.
  prefs: []
  type: TYPE_NORMAL
- en: '**nfev**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of evaluations of the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '**njev**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of evaluations of the Jacobian.
  prefs: []
  type: TYPE_NORMAL
- en: '**nlu**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of LU decompositions.
  prefs: []
  type: TYPE_NORMAL
- en: '**status**int'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason for algorithm termination:'
  prefs: []
  type: TYPE_NORMAL
- en: '-1: Integration step failed.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0: The solver successfully reached the end of *tspan*.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1: A termination event occurred.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**message**string'
  prefs: []
  type: TYPE_NORMAL
- en: Human-readable description of the termination reason.
  prefs: []
  type: TYPE_NORMAL
- en: '**success**bool'
  prefs: []
  type: TYPE_NORMAL
- en: True if the solver reached the interval end or a termination event occurred
    (`status >= 0`).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: J. R. Dormand, P. J. Prince, “A family of embedded Runge-Kutta formulae”, Journal
    of Computational and Applied Mathematics, Vol. 6, No. 1, pp. 19-26, 1980.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: L. W. Shampine, “Some Practical Runge-Kutta Formulas”, Mathematics of Computation,,
    Vol. 46, No. 173, pp. 135-150, 1986.
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: P. Bogacki, L.F. Shampine, “A 3(2) Pair of Runge-Kutta Formulas”, Appl. Math.
    Lett. Vol. 2, No. 4\. pp. 321-325, 1989.
  prefs: []
  type: TYPE_NORMAL
- en: '[[4](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'E. Hairer, G. Wanner, “Solving Ordinary Differential Equations II: Stiff and
    Differential-Algebraic Problems”, Sec. IV.8.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[5](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Backward Differentiation Formula](https://en.wikipedia.org/wiki/Backward_differentiation_formula)
    on Wikipedia.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[6](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: L. F. Shampine, M. W. Reichelt, “THE MATLAB ODE SUITE”, SIAM J. SCI. COMPUTE.,
    Vol. 18, No. 1, pp. 1-22, January 1997.
  prefs: []
  type: TYPE_NORMAL
- en: '[[7](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: A. C. Hindmarsh, “ODEPACK, A Systematized Collection of ODE Solvers,” IMACS
    Transactions on Scientific Computation, Vol 1., pp. 55-64, 1983.
  prefs: []
  type: TYPE_NORMAL
- en: '[[8](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: L. Petzold, “Automatic selection of methods for solving stiff and nonstiff systems
    of ordinary differential equations”, SIAM Journal on Scientific and Statistical
    Computing, Vol. 4, No. 1, pp. 136-148, 1983.
  prefs: []
  type: TYPE_NORMAL
- en: '[[9](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Stiff equation](https://en.wikipedia.org/wiki/Stiff_equation) on Wikipedia.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[10](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: A. Curtis, M. J. D. Powell, and J. Reid, “On the estimation of sparse Jacobian
    matrices”, Journal of the Institute of Mathematics and its Applications, 13, pp.
    117-120, 1974.
  prefs: []
  type: TYPE_NORMAL
- en: '[[11](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cauchy-Riemann equations](https://en.wikipedia.org/wiki/Cauchy-Riemann_equations)
    on Wikipedia.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[12](#id28)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lotka-Volterra equations](https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations)
    on Wikipedia.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[13](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'E. Hairer, S. P. Norsett G. Wanner, “Solving Ordinary Differential Equations
    I: Nonstiff Problems”, Sec. II.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[14](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[Page with original Fortran code of DOP853](http://www.unige.ch/~hairer/software.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Basic exponential decay showing automatically chosen time points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Specifying points where the solution is desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Cannon fired upward with terminal event upon impact. The `terminal` and `direction`
    fields of an event are applied by monkey patching a function. Here `y[0]` is position
    and `y[1]` is velocity. The projectile starts at position 0 with velocity +10\.
    Note that the integration never reaches t=100 because the event is terminal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use *dense_output* and *events* to find position, which is 100, at the apex
    of the cannonball’s trajectory. Apex is not defined as terminal, so both apex
    and hit_ground are found. There is no information at t=20, so the sol attribute
    is used to evaluate the solution. The sol attribute is returned by setting `dense_output=True`.
    Alternatively, the *y_events* attribute can be used to access the solution at
    the time of the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As an example of a system with additional parameters, we’ll implement the Lotka-Volterra
    equations [[12]](#r179348322575-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the *args* argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compute a dense solution and plot it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-integrate-solve_ivp-1_00_00.png](../Images/887662515b745f1931e450d75657d189.png)'
  prefs: []
  type: TYPE_IMG
- en: A couple examples of using solve_ivp to solve the differential equation `y'
    = Ay` with complex matrix `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Solving an IVP with `A` from above and `y` as 3x1 vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Solving an IVP with `A` from above with `y` as 3x3 matrix :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
