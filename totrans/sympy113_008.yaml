- en: Basic Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/tutorials/intro-tutorial/basic_operations.html](https://docs.sympy.org/latest/tutorials/intro-tutorial/basic_operations.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here we discuss some of the most basic operations needed for expression manipulation
    in SymPy. Some more advanced operations will be discussed later in the [advanced
    expression manipulation](manipulation.html#tutorial-manipulation) section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common things you might want to do with a mathematical expression
    is substitution. Substitution replaces all instances of something in an expression
    with something else. It is done using the `subs` method. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Substitution is usually done for one of two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating an expression at a point. For example, if our expression is `cos(x)
    + 1` and we want to evaluate it at the point `x = 0`, so that we get `cos(0) +
    1`, which is 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replacing a subexpression with another subexpression. There are two reasons
    we might want to do this. The first is if we are trying to build an expression
    that has some symmetry, such as \(x^{x^{x^x}}\). To build this, we might start
    with `x**y`, and replace `y` with `x**y`. We would then get `x**(x**y)`. If we
    replaced `y` in this new expression with `x**x`, we would get `x**(x**(x**x))`,
    the desired expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The second is if we want to perform a very controlled simplification, or perhaps
    a simplification that SymPy is otherwise unable to do. For example, say we have
    \(\sin(2x) + \cos(2x)\), and we want to replace \(\sin(2x)\) with \(2\sin(x)\cos(x)\).
    As we will learn later, the function `expand_trig` does this. However, this function
    will also expand \(\cos(2x)\), which we may not want. While there are ways to
    perform such precise simplification, and we will learn some of them in the [advanced
    expression manipulation](manipulation.html#tutorial-manipulation) section, an
    easy way is to just replace \(\sin(2x)\) with \(2\sin(x)\cos(x)\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are two important things to note about `subs`. First, it returns a new
    expression. SymPy objects are immutable. That means that `subs` does not modify
    it in-place. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that performing `expr.subs(x, 0)` leaves `expr` unchanged. In fact,
    since SymPy expressions are immutable, no function will change them in-place.
    All functions will return new expressions.
  prefs: []
  type: TYPE_NORMAL
- en: To perform multiple substitutions at once, pass a list of `(old, new)` pairs
    to `subs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is often useful to combine this with a list comprehension to do a large set
    of similar replacements all at once. For example, say we had \(x^4 - 4x^3 + 4x^2
    - 2x + 3\) and we wanted to replace all instances of \(x\) that have an even power
    with \(y\), to get \(y^4 - 4x^3 + 4y^2 - 2x + 3\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Converting Strings to SymPy Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sympify` function (that’s `sympify`, not to be confused with `simplify`)
    can be used to convert strings into SymPy expressions.
  prefs: []
  type: TYPE_NORMAL
- en: For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '`sympify` uses `eval`. Don’t use it on unsanitized input.'
  prefs: []
  type: TYPE_NORMAL
- en: '`evalf`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To evaluate a numerical expression into a floating point number, use `evalf`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: SymPy can evaluate floating point expressions to arbitrary precision. By default,
    15 digits of precision are used, but you can pass any number as the argument to
    `evalf`. Let’s compute the first 100 digits of \(\pi\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To numerically evaluate an expression with a Symbol at a point, we might use
    `subs` followed by `evalf`, but it is more efficient and numerically stable to
    pass the substitution to `evalf` using the `subs` flag, which takes a dictionary
    of `Symbol: point` pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes there are roundoff errors smaller than the desired precision that
    remain after an expression is evaluated. Such numbers can be removed at the user’s
    discretion by setting the `chop` flag to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`lambdify`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`subs` and `evalf` are good if you want to do simple evaluation, but if you
    intend to evaluate an expression at many points, there are more efficient ways.
    For example, if you wanted to evaluate an expression at a thousand points, using
    SymPy would be far slower than it needs to be, especially if you only care about
    machine precision. Instead, you should use libraries like [NumPy](https://numpy.org/)
    and [SciPy](https://scipy.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to convert a SymPy expression to an expression that can be numerically
    evaluated is to use the `lambdify` function. `lambdify` acts like a `lambda` function,
    except it converts the SymPy names to the names of the given numerical library,
    usually NumPy. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '`lambdify` uses `eval`. Don’t use it on unsanitized input.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use other libraries than NumPy. For example, to use the standard library
    math module, use `"math"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To use lambdify with numerical libraries that it does not know about, pass a
    dictionary of `sympy_name:numerical_function` pairs. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
