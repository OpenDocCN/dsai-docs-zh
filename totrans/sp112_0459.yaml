- en: scipy.optimize.toms748
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.toms748.html#scipy.optimize.toms748](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.toms748.html#scipy.optimize.toms748)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root using TOMS Algorithm 748 method.
  prefs: []
  type: TYPE_NORMAL
- en: Implements the Algorithm 748 method of Alefeld, Potro and Shi to find a root
    of the function *f* on the interval *[a , b]*, where *f(a)* and *f(b)* must have
    opposite signs.
  prefs: []
  type: TYPE_NORMAL
- en: It uses a mixture of inverse cubic interpolation and “Newton-quadratic” steps.
    [APS1995].
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f**function'
  prefs: []
  type: TYPE_NORMAL
- en: Python function returning a scalar. The function \(f\) must be continuous, and
    \(f(a)\) and \(f(b)\) have opposite signs.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**scalar,'
  prefs: []
  type: TYPE_NORMAL
- en: lower boundary of the search interval
  prefs: []
  type: TYPE_NORMAL
- en: '**b**scalar,'
  prefs: []
  type: TYPE_NORMAL
- en: upper boundary of the search interval
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: containing extra arguments for the function *f*. *f* is called by `f(x, *args)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**k**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The number of Newton quadratic steps to perform each iteration. `k>=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**xtol**scalar, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root. The parameter must be positive.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol**scalar, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The computed root `x0` will satisfy `np.allclose(x, x0, atol=xtol, rtol=rtol)`,
    where `x` is the exact root.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If convergence is not achieved in *maxiter* iterations, an error is raised.
    Must be >= 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *full_output* is False, the root is returned. If *full_output* is True, the
    return value is `(x, r)`, where *x* is the root, and *r* is a [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") object.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, raise RuntimeError if the algorithm didn’t converge. Otherwise, the
    convergence status is recorded in the [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") return object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**root**float'
  prefs: []
  type: TYPE_NORMAL
- en: Approximate root of *f*
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") (present if `full_output = True`)'
  prefs: []
  type: TYPE_NORMAL
- en: Object containing information about the convergence. In particular, `r.converged`
    is True if the routine converged.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`brentq`](scipy.optimize.brentq.html#scipy.optimize.brentq "scipy.optimize.brentq"),
    [`brenth`](scipy.optimize.brenth.html#scipy.optimize.brenth "scipy.optimize.brenth"),
    [`ridder`](scipy.optimize.ridder.html#scipy.optimize.ridder "scipy.optimize.ridder"),
    [`bisect`](scipy.optimize.bisect.html#scipy.optimize.bisect "scipy.optimize.bisect"),
    [`newton`](scipy.optimize.newton.html#scipy.optimize.newton "scipy.optimize.newton")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`fsolve`](scipy.optimize.fsolve.html#scipy.optimize.fsolve "scipy.optimize.fsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: find roots in N dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '*f* must be continuous. Algorithm 748 with `k=2` is asymptotically the most
    efficient algorithm known for finding roots of a four times continuously differentiable
    function. In contrast with Brent’s algorithm, which may only decrease the length
    of the enclosing bracket on the last step, Algorithm 748 decreases it each iteration
    with the same asymptotic efficiency as it finds the root.'
  prefs: []
  type: TYPE_NORMAL
- en: For easy statement of efficiency indices, assume that *f* has 4 continuouous
    deriviatives. For `k=1`, the convergence order is at least 2.7, and with about
    asymptotically 2 function evaluations per iteration, the efficiency index is approximately
    1.65. For `k=2`, the order is about 4.6 with asymptotically 3 function evaluations
    per iteration, and the efficiency index 1.66. For higher values of *k*, the efficiency
    index approaches the kth root of `(3k-2)`, hence `k=1` or `k=2` are usually appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[APS1995]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alefeld, G. E. and Potra, F. A. and Shi, Yixun, *Algorithm 748: Enclosing Zeros
    of Continuous Functions*, ACM Trans. Math. Softw. Volume 221(1995) doi = {10.1145/210089.210111}'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
