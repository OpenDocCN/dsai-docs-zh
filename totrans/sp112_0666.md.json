["```py\nscipy.signal.stft(x, fs=1.0, window='hann', nperseg=256, noverlap=None, nfft=None, detrend=False, return_onesided=True, boundary='zeros', padded=True, axis=-1, scaling='spectrum')\n```", "```py\n>>> import numpy as np\n>>> from scipy import signal\n>>> import matplotlib.pyplot as plt\n>>> rng = np.random.default_rng() \n```", "```py\n>>> fs = 10e3\n>>> N = 1e5\n>>> amp = 2 * np.sqrt(2)\n>>> noise_power = 0.01 * fs / 2\n>>> time = np.arange(N) / float(fs)\n>>> mod = 500*np.cos(2*np.pi*0.25*time)\n>>> carrier = amp * np.sin(2*np.pi*3e3*time + mod)\n>>> noise = rng.normal(scale=np.sqrt(noise_power),\n...                    size=time.shape)\n>>> noise *= np.exp(-time/5)\n>>> x = carrier + noise \n```", "```py\n>>> f, t, Zxx = signal.stft(x, fs, nperseg=1000)\n>>> plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')\n>>> plt.title('STFT Magnitude')\n>>> plt.ylabel('Frequency [Hz]')\n>>> plt.xlabel('Time [sec]')\n>>> plt.show() \n```", "```py\n>>> E_x = sum(x**2) / fs  # Energy of x\n>>> # Calculate a two-sided STFT with PSD scaling:\n>>> f, t, Zxx = signal.stft(x, fs, nperseg=1000, return_onesided=False,\n...                         scaling='psd')\n>>> # Integrate numerically over abs(Zxx)**2:\n>>> df, dt = f[1] - f[0], t[1] - t[0]\n>>> E_Zxx = sum(np.sum(Zxx.real**2 + Zxx.imag**2, axis=0) * df) * dt\n>>> # The energy is the same, but the numerical errors are quite large:\n>>> np.isclose(E_x, E_Zxx, rtol=1e-2)\nTrue \n```"]