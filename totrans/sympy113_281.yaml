- en: Examples from Wester’s Article
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/polys/wester.html](https://docs.sympy.org/latest/modules/polys/wester.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial we present examples from Wester’s article concerning comparison
    and critique of mathematical abilities of several computer algebra systems (see
    [[Wester1999]](#wester1999)). All the examples are related to polynomial and algebraic
    computations and SymPy specific remarks were added to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All examples in this tutorial are computable, so one can just copy and paste
    them into a Python shell and do something useful with them. All computations were
    done using the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Simple univariate polynomial factorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To obtain a factorization of a polynomial use [`factor()`](reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") function. By default [`factor()`](reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") returns the result in unevaluated form, so the
    content of the input polynomial is left unexpanded, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same effect in a more systematic way use [`primitive()`](reference.html#sympy.polys.polytools.primitive
    "sympy.polys.polytools.primitive") function, which returns the content and the
    primitive part of the input polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The content and the primitive part can be computed only over a ring. To simplify
    coefficients of a polynomial over a field use [`monic()`](reference.html#sympy.polys.polytools.monic
    "sympy.polys.polytools.monic").
  prefs: []
  type: TYPE_NORMAL
- en: Univariate GCD, resultant and factorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider univariate polynomials `f`, `g` and `h` over integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compute the greatest common divisor (GCD) of two polynomials using [`gcd()`](reference.html#sympy.polys.polytools.gcd
    "sympy.polys.polytools.gcd") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that `f` and `g` have no common factors. However, `f*h` and `g*h` have
    an obvious factor `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be verified using the resultant of univariate polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Factorization of large univariate polynomials (of degree 120 in this case)
    over integers is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Multivariate GCD and factorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What can be done in univariate case, can be also done for multivariate polynomials.
    Consider the following polynomials `f`, `g` and `h` in \(\mathbb{Z}[x,y,z]\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously, we can verify that `f` and `g` have no common factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `f*h` and `g*h` have an obvious factor `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Multivariate factorization of large polynomials is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Support for symbols in exponents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Polynomial manipulation functions provided by [`sympy.polys`](reference.html#module-sympy.polys
    "sympy.polys") are mostly used with integer exponents. However, it’s perfectly
    valid to compute with symbolic exponents, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Testing if polynomials have common zeros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test if two polynomials have a root in common we can use [`resultant()`](reference.html#sympy.polys.polytools.resultant
    "sympy.polys.polytools.resultant") function. The theory says that the resultant
    of two polynomials vanishes if there is a common zero of those polynomials. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize this fact by factoring the polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In both cases we obtained the factor \(x + 1\) which tells us that the common
    root is \(x = -1\).
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing simple rational functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove common factors from the numerator and the denominator of a rational
    function the elegant way, use [`cancel()`](reference.html#sympy.polys.polytools.cancel
    "sympy.polys.polytools.cancel") function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Expanding expressions and factoring back
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One can work easily we expressions in both expanded and factored forms. Consider
    a polynomial `f` in expanded form. We differentiate it and factor the result back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved in factored form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Factoring in terms of cyclotomic polynomials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SymPy can very efficiently decompose polynomials of the form \(x^n \pm 1\)
    in terms of cyclotomic polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The original Wester`s example was \(x^{100} - 1\), but was truncated for readability
    purpose. Note that this is not a big struggle for [`factor()`](reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") to decompose polynomials of degree 1000 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: Univariate factoring over Gaussian numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a univariate polynomial `f` with integer coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to obtain a factorization of `f` over Gaussian numbers. To do this
    we use [`factor()`](reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")
    as previously, but this time we set `gaussian` keyword to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As the result we got a splitting factorization of `f` with monic factors (this
    is a general rule when computing in a field with SymPy). The `gaussian` keyword
    is useful for improving code readability, however the same result can be computed
    using more general syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Computing with automatic field extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider two univariate polynomials `f` and `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to reduce degrees of the numerator and the denominator of a rational
    function `f/g`. To do this we employ [`cancel()`](reference.html#sympy.polys.polytools.cancel
    "sympy.polys.polytools.cancel") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately nothing interesting happened. This is because by default SymPy
    treats \(\sqrt{2}\) as a generator, obtaining a bivariate polynomial for the numerator.
    To make [`cancel()`](reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel")
    recognize algebraic properties of \(\sqrt{2}\), one needs to use `extension` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `extension=True` tells [`cancel()`](reference.html#sympy.polys.polytools.cancel
    "sympy.polys.polytools.cancel") to find minimal algebraic number domain for the
    coefficients of `f/g`. The automatically inferred domain is \(\mathbb{Q}(\sqrt{2})\).
    If one doesn’t want to rely on automatic inference, the same result can be obtained
    by setting the `extension` keyword with an explicit algebraic number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Univariate factoring over various domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a univariate polynomial `f` with integer coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With [`sympy.polys`](reference.html#module-sympy.polys "sympy.polys") we can
    obtain factorizations of `f` over different domains, which includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rationals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'finite fields:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'algebraic numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Factoring polynomials into linear factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently SymPy can factor polynomials into irreducibles over various domains,
    which can result in a splitting factorization (into linear factors). However,
    there is currently no systematic way to infer a splitting field (algebraic number
    field) automatically. In future the following syntax will be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note this is different from `extension=True`, because the later only tells how
    expression parsing should be done, not what should be the domain of computation.
    One can simulate the `split` keyword for several classes of polynomials using
    [`solve()`](../solvers/solvers.html#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced factoring over finite fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a univariate polynomial `f` with integer coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can factor `f` over a large finite field \(F_{65537}\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'and expand the resulting factorization back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'obtaining polynomial `f`. This was done using symmetric polynomial representation
    over finite fields The same thing can be done using non-symmetric representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As with symmetric representation we can expand the factorization to get the
    input polynomial back. This time, however, we need to truncate coefficients of
    the expanded polynomial modulo 65537:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Working with expressions as polynomials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a multivariate polynomial `f` in \(\mathbb{Z}[x,y,z]\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to compute factorization of `f`. To do this we use `factor` as usually,
    however we note that the polynomial in consideration is already in expanded form,
    so we can tell the factorization routine to skip expanding `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The default in [`sympy.polys`](reference.html#module-sympy.polys "sympy.polys")
    is to expand all expressions given as arguments to polynomial manipulation functions
    and [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    class. If we know that expanding is unnecessary, then by setting `expand=False`
    we can save quite a lot of time for complicated inputs. This can be really important
    when computing with expressions like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Computing reduced Gröbner bases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To compute a reduced Gröbner basis for a set of polynomials use the [`groebner()`](reference.html#sympy.polys.polytools.groebner
    "sympy.polys.polytools.groebner") function. The function accepts various monomial
    orderings, e.g.: `lex`, `grlex` and `grevlex`, or a user defined one, via `order`
    keyword. The `lex` ordering is the most interesting because it has elimination
    property, which means that if the system of polynomial equations to [`groebner()`](reference.html#sympy.polys.polytools.groebner
    "sympy.polys.polytools.groebner") is zero-dimensional (has finite number of solutions)
    the last element of the basis is a univariate polynomial. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is an ordinary Python list, so we can easily apply a function to
    all its elements, for example we can factor those elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From the above we can easily find all solutions of the system of polynomial
    equations. Or we can use [`solve()`](../solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") to achieve this in a more systematic way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Multivariate factoring over algebraic numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computing with multivariate polynomials over various domains is as simple as
    in univariate case. For example consider the following factorization over \(\mathbb{Q}(\sqrt{-3})\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Currently multivariate polynomials over finite fields aren’t supported.
  prefs: []
  type: TYPE_NORMAL
- en: Partial fraction decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider a univariate rational function `f` with integer coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To decompose `f` into partial fractions use [`apart()`](reference.html#sympy.polys.partfrac.apart
    "sympy.polys.partfrac.apart") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To return from partial fractions to the rational function use a composition
    of [`together()`](reference.html#sympy.polys.rationaltools.together "sympy.polys.rationaltools.together")
    and [`cancel()`](reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Literature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[[Wester1999](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Michael J. Wester, A Critique of the Mathematical Abilities of CA Systems, 1999,
    [https://www.math.unm.edu/~wester/cas/book/Wester.pdf](https://www.math.unm.edu/~wester/cas/book/Wester.pdf)
  prefs: []
  type: TYPE_NORMAL
