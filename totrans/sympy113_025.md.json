["```py\n> >>> # Imports\n> \n> >>> from sympy import symbols, I, limit, pprint, solve, oo\n> \n> >>> from sympy.physics.control import TransferFunction \n> ```", "```py\n> >>> s, k = symbols('s k')\n> \n> >>> gain = k                        # Let unknwon gain be k\n> \n> >>> a = [-3]                        # Zero at -3 in S plane\n> \n> >>> b = [-1, -2-I, -2+I]            # Poles at -1, (-2, j) and (-2, -j) in S plane\n> \n> >>> tf = TransferFunction.from_zpk(a, b, gain, s)\n> \n> >>> pprint(tf)\n> \n>  k*(s + 3)\n> \n> -------------------------------\n> \n> (s + 1)*(s + 2 - I)*(s + 2 + I)\n> \n> >>> gain = tf.dc_gain()\n> \n> >>> print(gain)\n> \n> 3*k*(2 - I)*(2 + I)/25\n> \n> >>> K = solve(gain - 20, k)[0]               # Solve for k\n> \n> >>> tf = tf.subs({k: K})                     # Reconstruct the TransferFunction using .subs()\n> \n> >>> pprint(tf.expand())\n> \n>  100*s\n> \n>  ----- + 100\n> \n>  3\n> \n> -------------------\n> \n>  3      2\n> \n> s  + 5*s  + 9*s + 5 \n> ```", "```py\n> >>> tf.is_stable()  # Expect True, since poles lie in the left half of S plane\n> \n> True \n> ```", "```py\n> >>> from sympy import inverse_laplace_transform\n> \n> >>> t = symbols('t', positive = True)\n> \n> >>> # Convert from S to T domain for impulse response\n> \n> >>> tf = tf.to_expr()\n> \n> >>> Impulse_Response = inverse_laplace_transform(tf, s, t)\n> \n> >>> pprint(Impulse_Response)\n> \n>  -t        -2*t\n> \n>  100*e     100*e    *cos(t)\n> \n>  ------- - ----------------\n> \n>  3             3 \n> ```", "```py\n> >>> # Apply the Initial Value Theorem on Equation of S domain\n> \n> >>> # limit(y(t), t, 0) = limit(s*Y(S), s, oo)\n> \n> >>> limit(s*tf, s, oo)\n> \n> 0 \n> ```", "```py\n>>> # Imports\n>>> from sympy import Function, laplace_transform, laplace_initial_conds, laplace_correspondence, diff, Symbol, solve\n>>> from sympy.abc import s, t\n>>> from sympy.physics.control import TransferFunction\n>>> y = Function('y')\n>>> Y = Function('Y')\n>>> u = Function('u')\n>>> U = Function('U')\n>>> k = Symbol('k') # Spring Constant\n>>> c = Symbol('c') # Damper\n>>> m = Symbol('m') # Mass of block \n```", "```py\n> >>> f = m*diff(y(t), t, t) + c*diff(y(t), t) + k*y(t) - u(t)\n> \n> >>> F = laplace_transform(f, t, s, noconds=True)\n> \n> >>> F = laplace_correspondence(F, {u: U, y: Y})\n> \n> >>> F = laplace_initial_conds(F, t, {y: [0, 0]})\n> \n> >>> t = (solve(F, Y(s))[0])/U(s) # To construct Transfer Function from Y(s) and U(s)\n> \n> >>> tf = TransferFunction.from_rational_expression(t, s)\n> \n> >>> pprint(tf)\n> \n>  1\n> \n> --------------\n> \n>  2\n> \n> c*s + k + m*s \n> ```", "```py\n> >>> # Imports\n> \n> >>> from sympy import Matrix, laplace_transform, inverse_laplace_transform, exp, cos, sqrt, sin, pprint\n> \n> >>> from sympy.abc import s, t\n> \n> >>> from sympy.physics.control import * \n> ```", "```py\n> >>> g =  Matrix([[exp(-t)*(1 - t), exp(-2*t)], [5*exp((-2*t))-exp((-t)), (cos((sqrt(3)*t)/2) - 3*sqrt(3)*sin((sqrt(3)*t)/2))*exp(-t/2)]])\n> \n> >>> G = g.applyfunc(lambda a: laplace_transform(a, t, s)[0])\n> \n> >>> pprint(G)\n> \n> [  1        1                       1                 ]\n> \n> [----- - --------                 -----               ]\n> \n> [s + 1          2                 s + 2               ]\n> \n> [        (s + 1)                                      ]\n> \n> [                                                     ]\n> \n> [   5       1         s + 1/2               9         ]\n> \n> [ ----- - -----    -------------- - ------------------]\n> \n> [ s + 2   s + 1             2   3     /         2   3\\]\n> \n> [                  (s + 1/2)  + -   2*|(s + 1/2)  + -|]\n> \n> [                               4     \\             4/] \n> ```", "```py\n> >>> G = TransferFunctionMatrix.from_Matrix(G, s)\n> \n> >>> type(G)\n> \n> <class 'sympy.physics.control.lti.TransferFunctionMatrix'>\n> \n> >>> type(G[0])\n> \n> <class 'sympy.physics.control.lti.TransferFunction'>\n> \n> >>> print(f'Inputs = {G.num_inputs}, Outputs = {G.num_outputs}')\n> \n> Inputs = 2, Outputs = 2 \n> ```", "```py\n> >>> G.elem_poles()\n> \n> [[[-1, -1, -1], [-2]], [[-2, -1], [-1/2 - sqrt(3)*I/2, -1/2 - sqrt(3)*I/2, -1/2 + sqrt(3)*I/2, -1/2 + sqrt(3)*I/2]]]\n> \n> >>> G.elem_zeros()\n> \n> [[[-1, 0], []], [[-3/4], [4, -1/2 - sqrt(3)*I/2, -1/2 + sqrt(3)*I/2]]]\n> \n> >>> pole_zero_plot(G[0, 0]) \n> ```", "```py\n> >>> tf1 = G[0, 0]\n> \n> >>> pprint(tf1)\n> \n>  2\n> \n> -s + (s + 1)  - 1\n> \n> -----------------\n> \n>  3\n> \n>  (s + 1)\n> \n> >>> step_response_plot(tf1) \n> ```", "```py\n> >>> tf2 = G[0, 1]\n> \n> >>> bode_magnitude_plot(tf2) \n> ```", "```py\n> >>> bode_phase_plot(tf2) \n> ```", "```py\n> >>> # Imports\n> \n> >>> from sympy import Matrix, pprint\n> \n> >>> from sympy.abc import s, t\n> \n> >>> from sympy.physics.control import * \n> ```", "```py\n> >>> P_mat = Matrix([[1/s, 2/(2+s)], [0, 3]])\n> \n> >>> C_mat = Matrix([[1, 1], [2, 2]])\n> \n> >>> P = TransferFunctionMatrix.from_Matrix(P_mat, var=s)\n> \n> >>> C = TransferFunctionMatrix.from_Matrix(C_mat, var=s)\n> \n> >>> # Series equivalent, considering (Input)→[P]→[C]→(Output). Note that order of matrix multiplication is opposite to the order in which the elements are arranged.\n> \n> >>> pprint(C*P)\n> \n> [1  1]    [1    2  ]\n> \n> [-  -]    [-  -----]\n> \n> [1  1]    [s  s + 2]\n> \n> [    ]   *[        ]\n> \n> [2  2]    [0    3  ]\n> \n> [-  -]    [-    -  ]\n> \n> [1  1]{t} [1    1  ]{t}\n> \n> >>> # Series equivalent, considering (Input)→[C]→[P]→(Output).\n> \n> >>> pprint(P*C)\n> \n> [1    2  ]    [1  1]\n> \n> [-  -----]    [-  -]\n> \n> [s  s + 2]    [1  1]\n> \n> [        ]   *[    ]\n> \n> [0    3  ]    [2  2]\n> \n> [-    -  ]    [-  -]\n> \n> [1    1  ]{t} [1  1]{t}\n> \n> >>> pprint((C*P).doit())\n> \n> [1  3*s + 8 ]\n> \n> [-  ------- ]\n> \n> [s   s + 2  ]\n> \n> [           ]\n> \n> [2  6*s + 16]\n> \n> [-  --------]\n> \n> [s   s + 2  ]{t}\n> \n> >>> pprint((P*C).doit())\n> \n> [ 5*s + 2    5*s + 2 ]\n> \n> [---------  ---------]\n> \n> [s*(s + 2)  s*(s + 2)]\n> \n> [                    ]\n> \n> [    6          6    ]\n> \n> [    -          -    ]\n> \n> [    1          1    ]{t} \n> ```", "```py\n> >>> tfm_feedback = MIMOFeedback(P, C, sign=-1)\n> \n> >>> pprint(tfm_feedback.doit())  # ((I + P*C)**-1)*P\n> \n> [   7*s + 14          -s - 6     ]\n> \n> [---------------  ---------------]\n> \n> [   2                2           ]\n> \n> [7*s  + 19*s + 2  7*s  + 19*s + 2]\n> \n> [                                ]\n> \n> [                    2           ]\n> \n> [   -6*s - 12     3*s  + 9*s + 6 ]\n> \n> [---------------  ---------------]\n> \n> [   2                2           ]\n> \n> [7*s  + 19*s + 2  7*s  + 19*s + 2]{t} \n> ```", "```py\n> >>> from sympy.abc import s\n> \n> >>> from sympy.physics.control import *\n> \n> >>> G1 = TransferFunction(1, 10 + s, s)\n> \n> >>> G2 = TransferFunction(1, 1 + s, s)\n> \n> >>> G3 = TransferFunction(1 + s**2, 4 + 4*s + s**2, s)\n> \n> >>> G4 = TransferFunction(1 + s, 6 + s, s)\n> \n> >>> H1 = TransferFunction(1 + s, 2 + s, s)\n> \n> >>> H2 = TransferFunction(2*(6 + s), 1 + s, s)\n> \n> >>> H3 = TransferFunction(1, 1, s)\n> \n> >>> sys1 = Series(G3, G4)\n> \n> >>> sys2 = Feedback(sys1, H1, 1).doit()\n> \n> >>> sys3 = Series(G2, sys2)\n> \n> >>> sys4 = Feedback(sys3, H2).doit()\n> \n> >>> sys5 = Series(G1, sys4)\n> \n> >>> sys6 = Feedback(sys5, H3)\n> \n> >>> sys6  # Final unevaluated Feedback object\n> \n> Feedback(Series(TransferFunction(1, s + 10, s), TransferFunction((s + 1)**3*(s + 2)*(s + 6)**2*(s**2 + 1)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4)**2, (s + 1)*(s + 6)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*((s + 1)**2*(s + 6)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4) + (s + 1)*(s + 2)*(s + 6)*(2*s + 12)*(s**2 + 1)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4), s)), TransferFunction(1, 1, s), -1)\n> \n> >>> sys6.doit()  # Reducing to TransferFunction form without simplification\n> \n> TransferFunction((s + 1)**4*(s + 2)*(s + 6)**3*(s + 10)*(s**2 + 1)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))**2*((s + 1)**2*(s + 6)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4) + (s + 1)*(s + 2)*(s + 6)*(2*s + 12)*(s**2 + 1)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4)**3, (s + 1)*(s + 6)*(s + 10)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*((s + 1)**2*(s + 6)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4) + (s + 1)*(s + 2)*(s + 6)*(2*s + 12)*(s**2 + 1)*(s**2 + 4*s + 4))*((s + 1)**3*(s + 2)*(s + 6)**2*(s**2 + 1)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4)**2 + (s + 1)*(s + 6)*(s + 10)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*((s + 1)**2*(s + 6)*(-(s + 1)**2*(s**2 + 1) + (s + 2)*(s + 6)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4) + (s + 1)*(s + 2)*(s + 6)*(2*s + 12)*(s**2 + 1)*(s**2 + 4*s + 4))*(s**2 + 4*s + 4))*(s**2 + 4*s + 4), s)\n> \n> >>> sys6 = sys6.doit(cancel=True, expand=True)  # Simplified TransferFunction form\n> \n> >>> sys6\n> \n> TransferFunction(s**4 + 3*s**3 + 3*s**2 + 3*s + 2, 12*s**5 + 193*s**4 + 873*s**3 + 1644*s**2 + 1484*s + 712, s)\n> \n> >>> pole_zero_plot(sys6) \n> ```"]