- en: Linear Algebra (scipy.linalg)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/linalg.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When SciPy is built using the optimized ATLAS LAPACK and BLAS libraries, it
    has very fast linear algebra capabilities. If you dig deep enough, all of the
    raw LAPACK and BLAS libraries are available for your use for even more speed.
    In this section, some easier-to-use interfaces to these routines are described.
  prefs: []
  type: TYPE_NORMAL
- en: All of these linear algebra routines expect an object that can be converted
    into a 2-D array. The output of these routines is also a 2-D array.
  prefs: []
  type: TYPE_NORMAL
- en: scipy.linalg vs numpy.linalg
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`scipy.linalg`](../reference/linalg.html#module-scipy.linalg "scipy.linalg")
    contains all the functions in [numpy.linalg](https://www.numpy.org/devdocs/reference/routines.linalg.html).
    plus some other more advanced ones not contained in `numpy.linalg`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using `scipy.linalg` over `numpy.linalg` is that it is
    always compiled with BLAS/LAPACK support, while for NumPy this is optional. Therefore,
    the SciPy version might be faster depending on how NumPy was installed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, unless you don’t want to add `scipy` as a dependency to your `numpy`
    program, use `scipy.linalg` instead of `numpy.linalg`.
  prefs: []
  type: TYPE_NORMAL
- en: numpy.matrix vs 2-D numpy.ndarray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classes that represent matrices, and basic operations, such as matrix multiplications
    and transpose are a part of `numpy`. For convenience, we summarize the differences
    between [`numpy.matrix`](https://numpy.org/devdocs/reference/generated/numpy.matrix.html#numpy.matrix
    "(in NumPy v2.0.dev0)") and [`numpy.ndarray`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0.dev0)") here.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.matrix` is matrix class that has a more convenient interface than `numpy.ndarray`
    for matrix operations. This class supports, for example, MATLAB-like creation
    syntax via the semicolon, has matrix multiplication as default for the `*` operator,
    and contains `I` and `T` members that serve as shortcuts for inverse and transpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite its convenience, the use of the `numpy.matrix` class is discouraged,
    since it adds nothing that cannot be accomplished with 2-D `numpy.ndarray` objects,
    and may lead to a confusion of which class is being used. For example, the above
    code can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`scipy.linalg` operations can be applied equally to `numpy.matrix` or to 2D
    `numpy.ndarray` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding the inverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The inverse of a matrix \(\mathbf{A}\) is the matrix \(\mathbf{B}\), such that
    \(\mathbf{AB}=\mathbf{I}\), where \(\mathbf{I}\) is the identity matrix consisting
    of ones down the main diagonal. Usually, \(\mathbf{B}\) is denoted \(\mathbf{B}=\mathbf{A}^{-1}\)
    . In SciPy, the matrix inverse of the NumPy array, A, is obtained using [`linalg.inv`](../reference/generated/scipy.linalg.inv.html#scipy.linalg.inv
    "scipy.linalg.inv") `(A)`, or using `A.I` if `A` is a Matrix. For example, let
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{A} = \left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\
    2 & 3 & 8\end{array}\right],\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{A^{-1}} = \frac{1}{25} \left[\begin{array}{ccc} -37 &
    9 & 22 \\ 14 & 2 & -9 \\ 4 & -3 & 1 \end{array}\right] = % \left[\begin{array}{ccc}
    -1.48 & 0.36 & 0.88 \\ 0.56 & 0.08 & -0.36 \\ 0.16 & -0.12 & 0.04 \end{array}\right].\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates this computation in SciPy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Solving a linear system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Solving linear systems of equations is straightforward using the scipy command
    [`linalg.solve`](../reference/generated/scipy.linalg.solve.html#scipy.linalg.solve
    "scipy.linalg.solve"). This command expects an input matrix and a right-hand side
    vector. The solution vector is then computed. An option for entering a symmetric
    matrix is offered, which can speed up the processing when applicable. As an example,
    suppose it is desired to solve the following simultaneous equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} x + 3y + 5z & = & 10 \\ 2x + 5y + z & = & 8 \\ 2x + 3y + 8z
    & = & 3 \end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: 'We could find the solution vector using a matrix inverse:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\left[\begin{array}{c} x\\ y\\ z\end{array}\right]=\left[\begin{array}{ccc}
    1 & 3 & 5\\ 2 & 5 & 1\\ 2 & 3 & 8\end{array}\right]^{-1}\left[\begin{array}{c}
    10\\ 8\\ 3\end{array}\right]=\frac{1}{25}\left[\begin{array}{c} -232\\ 129\\ 19\end{array}\right]=\left[\begin{array}{c}
    -9.28\\ 5.16\\ 0.76\end{array}\right].\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is better to use the linalg.solve command, which can be faster
    and more numerically stable. In this case, it, however, gives the same answer
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finding the determinant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The determinant of a square matrix \(\mathbf{A}\) is often denoted \(\left|\mathbf{A}\right|\)
    and is a quantity often used in linear algebra. Suppose \(a_{ij}\) are the elements
    of the matrix \(\mathbf{A}\) and let \(M_{ij}=\left|\mathbf{A}_{ij}\right|\) be
    the determinant of the matrix left by removing the \(i^{\textrm{th}}\) row and
    \(j^{\textrm{th}}\) column from \(\mathbf{A}\) . Then, for any row \(i,\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\left|\mathbf{A}\right|=\sum_{j}\left(-1\right)^{i+j}a_{ij}M_{ij}.\]
  prefs: []
  type: TYPE_NORMAL
- en: This is a recursive way to define the determinant, where the base case is defined
    by accepting that the determinant of a \(1\times1\) matrix is the only matrix
    element. In SciPy the determinant can be calculated with [`linalg.det`](../reference/generated/scipy.linalg.det.html#scipy.linalg.det
    "scipy.linalg.det"). For example, the determinant of
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{A=}\left[\begin{array}{ccc} 1 & 3 & 5\\ 2 & 5 & 1\\ 2
    & 3 & 8\end{array}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \left|\mathbf{A}\right| & = & 1\left|\begin{array}{cc} 5 &
    1\\ 3 & 8\end{array}\right|-3\left|\begin{array}{cc} 2 & 1\\ 2 & 8\end{array}\right|+5\left|\begin{array}{cc}
    2 & 5\\ 2 & 3\end{array}\right|\\ & = & 1\left(5\cdot8-3\cdot1\right)-3\left(2\cdot8-2\cdot1\right)+5\left(2\cdot3-2\cdot5\right)=-25.\end{eqnarray*}.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SciPy, this is computed as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Computing norms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matrix and vector norms can also be computed with SciPy. A wide range of norm
    definitions are available using different parameters to the order argument of
    [`linalg.norm`](../reference/generated/scipy.linalg.norm.html#scipy.linalg.norm
    "scipy.linalg.norm"). This function takes a rank-1 (vectors) or a rank-2 (matrices)
    array and an optional order argument (default is 2). Based on these inputs, a
    vector or matrix norm of the requested order is computed.
  prefs: []
  type: TYPE_NORMAL
- en: For vector *x*, the order parameter can be any real number including `inf` or
    `-inf`. The computed norm is
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\left\Vert \mathbf{x}\right\Vert =\left\{ \begin{array}{cc} \max\left|x_{i}\right|
    & \textrm{ord}=\textrm{inf}\\ \min\left|x_{i}\right| & \textrm{ord}=-\textrm{inf}\\
    \left(\sum_{i}\left|x_{i}\right|^{\textrm{ord}}\right)^{1/\textrm{ord}} & \left|\textrm{ord}\right|<\infty.\end{array}\right.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: For matrix \(\mathbf{A}\), the only valid values for norm are \(\pm2,\pm1,\)
    \(\pm\) inf, and ‘fro’ (or ‘f’) Thus,
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\left\Vert \mathbf{A}\right\Vert =\left\{ \begin{array}{cc} \max_{i}\sum_{j}\left|a_{ij}\right|
    & \textrm{ord}=\textrm{inf}\\ \min_{i}\sum_{j}\left|a_{ij}\right| & \textrm{ord}=-\textrm{inf}\\
    \max_{j}\sum_{i}\left|a_{ij}\right| & \textrm{ord}=1\\ \min_{j}\sum_{i}\left|a_{ij}\right|
    & \textrm{ord}=-1\\ \max\sigma_{i} & \textrm{ord}=2\\ \min\sigma_{i} & \textrm{ord}=-2\\
    \sqrt{\textrm{trace}\left(\mathbf{A}^{H}\mathbf{A}\right)} & \textrm{ord}=\textrm{'fro'}\end{array}\right.\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\sigma_{i}\) are the singular values of \(\mathbf{A}\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Solving linear least-squares problems and pseudo-inverses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linear least-squares problems occur in many branches of applied mathematics.
    In this problem, a set of linear scaling coefficients is sought that allows a
    model to fit the data. In particular, it is assumed that data \(y_{i}\) is related
    to data \(\mathbf{x}_{i}\) through a set of coefficients \(c_{j}\) and model functions
    \(f_{j}\left(\mathbf{x}_{i}\right)\) via the model
  prefs: []
  type: TYPE_NORMAL
- en: \[y_{i}=\sum_{j}c_{j}f_{j}\left(\mathbf{x}_{i}\right)+\epsilon_{i},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\epsilon_{i}\) represents uncertainty in the data. The strategy of least
    squares is to pick the coefficients \(c_{j}\) to minimize
  prefs: []
  type: TYPE_NORMAL
- en: \[J\left(\mathbf{c}\right)=\sum_{i}\left|y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right|^{2}.\]
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, a global minimum will occur when
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial J}{\partial c_{n}^{*}}=0=\sum_{i}\left(y_{i}-\sum_{j}c_{j}f_{j}\left(x_{i}\right)\right)\left(-f_{n}^{*}\left(x_{i}\right)\right)\]
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \sum_{j}c_{j}\sum_{i}f_{j}\left(x_{i}\right)f_{n}^{*}\left(x_{i}\right)
    & = & \sum_{i}y_{i}f_{n}^{*}\left(x_{i}\right)\\ \mathbf{A}^{H}\mathbf{Ac} & =
    & \mathbf{A}^{H}\mathbf{y}\end{eqnarray*},
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: \[\left\{ \mathbf{A}\right\} _{ij}=f_{j}\left(x_{i}\right).\]
  prefs: []
  type: TYPE_NORMAL
- en: When \(\mathbf{A^{H}A}\) is invertible, then
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{c}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H}\mathbf{y}=\mathbf{A}^{\dagger}\mathbf{y},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\mathbf{A}^{\dagger}\) is called the pseudo-inverse of \(\mathbf{A}.\)
    Notice that using this definition of \(\mathbf{A}\) the model can be written
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{y}=\mathbf{Ac}+\boldsymbol{\epsilon}.\]
  prefs: []
  type: TYPE_NORMAL
- en: The command [`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq") will solve the linear least-squares problem for \(\mathbf{c}\)
    given \(\mathbf{A}\) and \(\mathbf{y}\) . In addition, [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv") will find \(\mathbf{A}^{\dagger}\) given \(\mathbf{A}.\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example and figure demonstrate the use of [`linalg.lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "scipy.linalg.lstsq") and [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv") for solving a data-fitting problem. The data shown below
    were generated using the model:'
  prefs: []
  type: TYPE_NORMAL
- en: \[y_{i}=c_{1}e^{-x_{i}}+c_{2}x_{i},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(x_{i}=0.1i\) for \(i=1\ldots10\) , \(c_{1}=5\), and \(c_{2}=4.\) Noise
    is added to \(y_{i}\) and the coefficients \(c_{1}\) and \(c_{2}\) are estimated
    using linear least squares.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/ca5015be6607724281e9ca72e23c1053.png)'
  prefs: []
  type: TYPE_IMG
- en: Generalized inverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The generalized inverse is calculated using the command [`linalg.pinv`](../reference/generated/scipy.linalg.pinv.html#scipy.linalg.pinv
    "scipy.linalg.pinv"). Let \(\mathbf{A}\) be an \(M\times N\) matrix, then if \(M>N\),
    the generalized inverse is
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}^{\dagger}=\left(\mathbf{A}^{H}\mathbf{A}\right)^{-1}\mathbf{A}^{H},\]
  prefs: []
  type: TYPE_NORMAL
- en: while if \(M<N\) matrix, the generalized inverse is
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}^{\#}=\mathbf{A}^{H}\left(\mathbf{A}\mathbf{A}^{H}\right)^{-1}.\]
  prefs: []
  type: TYPE_NORMAL
- en: In the case that \(M=N\), then
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}^{\dagger}=\mathbf{A}^{\#}=\mathbf{A}^{-1},\]
  prefs: []
  type: TYPE_NORMAL
- en: as long as \(\mathbf{A}\) is invertible.
  prefs: []
  type: TYPE_NORMAL
- en: Decompositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many applications, it is useful to decompose a matrix using other representations.
    There are several decompositions supported by SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvalues and eigenvectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The eigenvalue-eigenvector problem is one of the most commonly employed linear
    algebra operations. In one popular form, the eigenvalue-eigenvector problem is
    to find for some square matrix \(\mathbf{A}\) scalars \(\lambda\) and corresponding
    vectors \(\mathbf{v}\), such that
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{Av}=\lambda\mathbf{v}.\]
  prefs: []
  type: TYPE_NORMAL
- en: For an \(N\times N\) matrix, there are \(N\) (not necessarily distinct) eigenvalues
    — roots of the (characteristic) polynomial
  prefs: []
  type: TYPE_NORMAL
- en: \[\left|\mathbf{A}-\lambda\mathbf{I}\right|=0.\]
  prefs: []
  type: TYPE_NORMAL
- en: The eigenvectors, \(\mathbf{v}\), are also sometimes called right eigenvectors
    to distinguish them from another set of left eigenvectors that satisfy
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{v}_{L}^{H}\mathbf{A}=\lambda\mathbf{v}_{L}^{H}\]
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}^{H}\mathbf{v}_{L}=\lambda^{*}\mathbf{v}_{L}.\]
  prefs: []
  type: TYPE_NORMAL
- en: With its default optional arguments, the command [`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") returns \(\lambda\) and \(\mathbf{v}.\) However, it can also
    return \(\mathbf{v}_{L}\) and just \(\lambda\) by itself ( [`linalg.eigvals`](../reference/generated/scipy.linalg.eigvals.html#scipy.linalg.eigvals
    "scipy.linalg.eigvals") returns just \(\lambda\) as well).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, [`linalg.eig`](../reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "scipy.linalg.eig") can also solve the more general eigenvalue problem
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \mathbf{Av} & = & \lambda\mathbf{Bv}\\ \mathbf{A}^{H}\mathbf{v}_{L}
    & = & \lambda^{*}\mathbf{B}^{H}\mathbf{v}_{L}\end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: for square matrices \(\mathbf{A}\) and \(\mathbf{B}.\) The standard eigenvalue
    problem is an example of the general eigenvalue problem for \(\mathbf{B}=\mathbf{I}.\)
    When a generalized eigenvalue problem can be solved, it provides a decomposition
    of \(\mathbf{A}\) as
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}=\mathbf{BV}\boldsymbol{\Lambda}\mathbf{V}^{-1},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\mathbf{V}\) is the collection of eigenvectors into columns and \(\boldsymbol{\Lambda}\)
    is a diagonal matrix of eigenvalues.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, eigenvectors are only defined up to a constant scale factor.
    In SciPy, the scaling factor for the eigenvectors is chosen so that \(\left\Vert
    \mathbf{v}\right\Vert ^{2}=\sum_{i}v_{i}^{2}=1.\)
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider finding the eigenvalues and eigenvectors of the matrix
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{A}=\left[\begin{array}{ccc} 1 & 5 & 2\\ 2 & 4 & 1\\ 3
    & 6 & 2\end{array}\right].\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: The characteristic polynomial is
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \left|\mathbf{A}-\lambda\mathbf{I}\right| & = & \left(1-\lambda\right)\left[\left(4-\lambda\right)\left(2-\lambda\right)-6\right]-\\
    & & 5\left[2\left(2-\lambda\right)-3\right]+2\left[12-3\left(4-\lambda\right)\right]\\
    & = & -\lambda^{3}+7\lambda^{2}+8\lambda-3.\end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: 'The roots of this polynomial are the eigenvalues of \(\mathbf{A}\):'
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \lambda_{1} & = & 7.9579\\ \lambda_{2} & = & -1.2577\\ \lambda_{3}
    & = & 0.2997.\end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: The eigenvectors corresponding to each eigenvalue can be found using the original
    equation. The eigenvectors associated with these eigenvalues can then be found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Singular value decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Singular value decomposition (SVD) can be thought of as an extension of the
    eigenvalue problem to matrices that are not square. Let \(\mathbf{A}\) be an \(M\times
    N\) matrix with \(M\) and \(N\) arbitrary. The matrices \(\mathbf{A}^{H}\mathbf{A}\)
    and \(\mathbf{A}\mathbf{A}^{H}\) are square hermitian matrices [[1]](#id3) of
    size \(N\times N\) and \(M\times M\), respectively. It is known that the eigenvalues
    of square hermitian matrices are real and non-negative. In addition, there are
    at most \(\min\left(M,N\right)\) identical non-zero eigenvalues of \(\mathbf{A}^{H}\mathbf{A}\)
    and \(\mathbf{A}\mathbf{A}^{H}.\) Define these positive eigenvalues as \(\sigma_{i}^{2}.\)
    The square-root of these are called singular values of \(\mathbf{A}.\) The eigenvectors
    of \(\mathbf{A}^{H}\mathbf{A}\) are collected by columns into an \(N\times N\)
    unitary [[2]](#id4) matrix \(\mathbf{V}\), while the eigenvectors of \(\mathbf{A}\mathbf{A}^{H}\)
    are collected by columns in the unitary matrix \(\mathbf{U}\), the singular values
    are collected in an \(M\times N\) zero matrix \(\mathbf{\boldsymbol{\Sigma}}\)
    with main diagonal entries set to the singular values. Then
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A=U}\boldsymbol{\Sigma}\mathbf{V}^{H}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'is the singular value decomposition of \(\mathbf{A}.\) Every matrix has a singular
    value decomposition. Sometimes, the singular values are called the spectrum of
    \(\mathbf{A}.\) The command [`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd") will return \(\mathbf{U}\) , \(\mathbf{V}^{H}\), and \(\sigma_{i}\)
    as an array of the singular values. To obtain the matrix \(\boldsymbol{\Sigma}\),
    use [`linalg.diagsvd`](../reference/generated/scipy.linalg.diagsvd.html#scipy.linalg.diagsvd
    "scipy.linalg.diagsvd"). The following example illustrates the use of [`linalg.svd`](../reference/generated/scipy.linalg.svd.html#scipy.linalg.svd
    "scipy.linalg.svd"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: LU decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LU decomposition finds a representation for the \(M\times N\) matrix \(\mathbf{A}\)
    as
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}=\mathbf{P}\,\mathbf{L}\,\mathbf{U},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\mathbf{P}\) is an \(M\times M\) permutation matrix (a permutation of
    the rows of the identity matrix), \(\mathbf{L}\) is in \(M\times K\) lower triangular
    or trapezoidal matrix ( \(K=\min\left(M,N\right)\)) with unit-diagonal, and \(\mathbf{U}\)
    is an upper triangular or trapezoidal matrix. The SciPy command for this decomposition
    is [`linalg.lu`](../reference/generated/scipy.linalg.lu.html#scipy.linalg.lu "scipy.linalg.lu").
  prefs: []
  type: TYPE_NORMAL
- en: Such a decomposition is often useful for solving many simultaneous equations
    where the left-hand side does not change but the right-hand side does. For example,
    suppose we are going to solve
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}\mathbf{x}_{i}=\mathbf{b}_{i}\]
  prefs: []
  type: TYPE_NORMAL
- en: for many different \(\mathbf{b}_{i}\). The LU decomposition allows this to be
    written as
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{PLUx}_{i}=\mathbf{b}_{i}.\]
  prefs: []
  type: TYPE_NORMAL
- en: Because \(\mathbf{L}\) is lower-triangular, the equation can be solved for \(\mathbf{U}\mathbf{x}_{i}\)
    and, finally, \(\mathbf{x}_{i}\) very rapidly using forward- and back-substitution.
    An initial time spent factoring \(\mathbf{A}\) allows for very rapid solution
    of similar systems of equations in the future. If the intent for performing LU
    decomposition is for solving linear systems, then the command [`linalg.lu_factor`](../reference/generated/scipy.linalg.lu_factor.html#scipy.linalg.lu_factor
    "scipy.linalg.lu_factor") should be used followed by repeated applications of
    the command [`linalg.lu_solve`](../reference/generated/scipy.linalg.lu_solve.html#scipy.linalg.lu_solve
    "scipy.linalg.lu_solve") to solve the system for each new right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Cholesky decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cholesky decomposition is a special case of LU decomposition applicable to Hermitian
    positive definite matrices. When \(\mathbf{A}=\mathbf{A}^{H}\) and \(\mathbf{x}^{H}\mathbf{Ax}\geq0\)
    for all \(\mathbf{x}\), then decompositions of \(\mathbf{A}\) can be found so
    that
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \mathbf{A} & = & \mathbf{U}^{H}\mathbf{U}\\ \mathbf{A} & =
    & \mathbf{L}\mathbf{L}^{H}\end{eqnarray*},
  prefs: []
  type: TYPE_NORMAL
- en: where \(\mathbf{L}\) is lower triangular and \(\mathbf{U}\) is upper triangular.
    Notice that \(\mathbf{L}=\mathbf{U}^{H}.\) The command [`linalg.cholesky`](../reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky
    "scipy.linalg.cholesky") computes the Cholesky factorization. For using the Cholesky
    factorization to solve systems of equations, there are also [`linalg.cho_factor`](../reference/generated/scipy.linalg.cho_factor.html#scipy.linalg.cho_factor
    "scipy.linalg.cho_factor") and [`linalg.cho_solve`](../reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve
    "scipy.linalg.cho_solve") routines that work similarly to their LU decomposition
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: QR decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The QR decomposition (sometimes called a polar decomposition) works for any
    \(M\times N\) array and finds an \(M\times M\) unitary matrix \(\mathbf{Q}\) and
    an \(M\times N\) upper-trapezoidal matrix \(\mathbf{R}\), such that
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A=QR}.\]
  prefs: []
  type: TYPE_NORMAL
- en: Notice that if the SVD of \(\mathbf{A}\) is known, then the QR decomposition
    can be found.
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}=\mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^{H}=\mathbf{QR}\]
  prefs: []
  type: TYPE_NORMAL
- en: implies that \(\mathbf{Q}=\mathbf{U}\) and \(\mathbf{R}=\boldsymbol{\Sigma}\mathbf{V}^{H}.\)
    Note, however, that in SciPy independent algorithms are used to find QR and SVD
    decompositions. The command for QR decomposition is [`linalg.qr`](../reference/generated/scipy.linalg.qr.html#scipy.linalg.qr
    "scipy.linalg.qr").
  prefs: []
  type: TYPE_NORMAL
- en: Schur decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a square \(N\times N\) matrix, \(\mathbf{A}\), the Schur decomposition finds
    (not necessarily unique) matrices \(\mathbf{T}\) and \(\mathbf{Z}\), such that
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}=\mathbf{ZT}\mathbf{Z}^{H},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\mathbf{Z}\) is a unitary matrix and \(\mathbf{T}\) is either upper
    triangular or quasi upper triangular, depending on whether or not a real Schur
    form or complex Schur form is requested. For a real Schur form both \(\mathbf{T}\)
    and \(\mathbf{Z}\) are real-valued when \(\mathbf{A}\) is real-valued. When \(\mathbf{A}\)
    is a real-valued matrix, the real Schur form is only quasi upper triangular because
    \(2\times2\) blocks extrude from the main diagonal corresponding to any complex-valued
    eigenvalues. The command [`linalg.schur`](../reference/generated/scipy.linalg.schur.html#scipy.linalg.schur
    "scipy.linalg.schur") finds the Schur decomposition, while the command [`linalg.rsf2csf`](../reference/generated/scipy.linalg.rsf2csf.html#scipy.linalg.rsf2csf
    "scipy.linalg.rsf2csf") converts \(\mathbf{T}\) and \(\mathbf{Z}\) from a real
    Schur form to a complex Schur form. The Schur form is especially useful in calculating
    functions of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the Schur decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Interpolative decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") contains routines for computing the interpolative
    decomposition (ID) of a matrix. For a matrix \(A \in \mathbb{C}^{m \times n}\)
    of rank \(k \leq \min \{ m, n \}\) this is a factorization'
  prefs: []
  type: TYPE_NORMAL
- en: \[A \Pi = \begin{bmatrix} A \Pi_{1} & A \Pi_{2} \end{bmatrix} = A \Pi_{1} \begin{bmatrix}
    I & T \end{bmatrix},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\Pi = [\Pi_{1}, \Pi_{2}]\) is a permutation matrix with \(\Pi_{1} \in
    \{ 0, 1 \}^{n \times k}\), i.e., \(A \Pi_{2} = A \Pi_{1} T\). This can equivalently
    be written as \(A = BP\), where \(B = A \Pi_{1}\) and \(P = [I, T] \Pi^{\mathsf{T}}\)
    are the *skeleton* and *interpolation matrices*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.interpolative`](../reference/linalg.interpolative.html#module-scipy.linalg.interpolative
    "scipy.linalg.interpolative") — for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the function \(f\left(x\right)\) with Taylor series expansion
  prefs: []
  type: TYPE_NORMAL
- en: \[f\left(x\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}x^{k}.\]
  prefs: []
  type: TYPE_NORMAL
- en: A matrix function can be defined using this Taylor series for the square matrix
    \(\mathbf{A}\) as
  prefs: []
  type: TYPE_NORMAL
- en: \[f\left(\mathbf{A}\right)=\sum_{k=0}^{\infty}\frac{f^{\left(k\right)}\left(0\right)}{k!}\mathbf{A}^{k}.\]
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While this serves as a useful representation of a matrix function, it is rarely
    the best way to calculate a matrix function. In particular, if the matrix is not
    diagonalizable, results may be inaccurate.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential and logarithm functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The matrix exponential is one of the more common matrix functions. The preferred
    method for implementing the matrix exponential is to use scaling and a Padé approximation
    for \(e^{x}\). This algorithm is implemented as [`linalg.expm`](../reference/generated/scipy.linalg.expm.html#scipy.linalg.expm
    "scipy.linalg.expm").
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse of the matrix exponential is the matrix logarithm defined as the
    inverse of the matrix exponential:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\mathbf{A}\equiv\exp\left(\log\left(\mathbf{A}\right)\right).\]
  prefs: []
  type: TYPE_NORMAL
- en: The matrix logarithm can be obtained with [`linalg.logm`](../reference/generated/scipy.linalg.logm.html#scipy.linalg.logm
    "scipy.linalg.logm").
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The trigonometric functions, \(\sin\), \(\cos\), and \(\tan\), are implemented
    for matrices in [`linalg.sinm`](../reference/generated/scipy.linalg.sinm.html#scipy.linalg.sinm
    "scipy.linalg.sinm"), [`linalg.cosm`](../reference/generated/scipy.linalg.cosm.html#scipy.linalg.cosm
    "scipy.linalg.cosm"), and [`linalg.tanm`](../reference/generated/scipy.linalg.tanm.html#scipy.linalg.tanm
    "scipy.linalg.tanm"), respectively. The matrix sine and cosine can be defined
    using Euler’s identity as
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \sin\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}-e^{-j\mathbf{A}}}{2j}\\
    \cos\left(\mathbf{A}\right) & = & \frac{e^{j\mathbf{A}}+e^{-j\mathbf{A}}}{2}.\end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: The tangent is
  prefs: []
  type: TYPE_NORMAL
- en: \[\tan\left(x\right)=\frac{\sin\left(x\right)}{\cos\left(x\right)}=\left[\cos\left(x\right)\right]^{-1}\sin\left(x\right)\]
  prefs: []
  type: TYPE_NORMAL
- en: and so the matrix tangent is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\left[\cos\left(\mathbf{A}\right)\right]^{-1}\sin\left(\mathbf{A}\right).\]
  prefs: []
  type: TYPE_NORMAL
- en: Hyperbolic trigonometric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The hyperbolic trigonometric functions, \(\sinh\), \(\cosh\), and \(\tanh\),
    can also be defined for matrices using the familiar definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: \begin{eqnarray*} \sinh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}-e^{-\mathbf{A}}}{2}\\
    \cosh\left(\mathbf{A}\right) & = & \frac{e^{\mathbf{A}}+e^{-\mathbf{A}}}{2}\\
    \tanh\left(\mathbf{A}\right) & = & \left[\cosh\left(\mathbf{A}\right)\right]^{-1}\sinh\left(\mathbf{A}\right).\end{eqnarray*}
  prefs: []
  type: TYPE_NORMAL
- en: These matrix functions can be found using [`linalg.sinhm`](../reference/generated/scipy.linalg.sinhm.html#scipy.linalg.sinhm
    "scipy.linalg.sinhm"), [`linalg.coshm`](../reference/generated/scipy.linalg.coshm.html#scipy.linalg.coshm
    "scipy.linalg.coshm"), and [`linalg.tanhm`](../reference/generated/scipy.linalg.tanhm.html#scipy.linalg.tanhm
    "scipy.linalg.tanhm").
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, any arbitrary function that takes one complex number and returns a
    complex number can be called as a matrix function using the command [`linalg.funm`](../reference/generated/scipy.linalg.funm.html#scipy.linalg.funm
    "scipy.linalg.funm"). This command takes the matrix and an arbitrary Python function.
    It then implements an algorithm from Golub and Van Loan’s book “Matrix Computations”
    to compute the function applied to the matrix using a Schur decomposition. Note
    that *the function needs to accept complex numbers* as input in order to work
    with this algorithm. For example, the following code computes the zeroth-order
    Bessel function applied to a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note how, by virtue of how matrix analytic functions are defined, the Bessel
    function has acted on the matrix eigenvalues.
  prefs: []
  type: TYPE_NORMAL
- en: Special matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SciPy and NumPy provide several functions for creating special matrices that
    are frequently used in engineering and science.
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| block diagonal | [`scipy.linalg.block_diag`](../reference/generated/scipy.linalg.block_diag.html#scipy.linalg.block_diag
    "scipy.linalg.block_diag") | Create a block diagonal matrix from the provided
    arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| circulant | [`scipy.linalg.circulant`](../reference/generated/scipy.linalg.circulant.html#scipy.linalg.circulant
    "scipy.linalg.circulant") | Create a circulant matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| companion | [`scipy.linalg.companion`](../reference/generated/scipy.linalg.companion.html#scipy.linalg.companion
    "scipy.linalg.companion") | Create a companion matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| convolution | [`scipy.linalg.convolution_matrix`](../reference/generated/scipy.linalg.convolution_matrix.html#scipy.linalg.convolution_matrix
    "scipy.linalg.convolution_matrix") | Create a convolution matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Discrete Fourier | [`scipy.linalg.dft`](../reference/generated/scipy.linalg.dft.html#scipy.linalg.dft
    "scipy.linalg.dft") | Create a discrete Fourier transform matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Fiedler | [`scipy.linalg.fiedler`](../reference/generated/scipy.linalg.fiedler.html#scipy.linalg.fiedler
    "scipy.linalg.fiedler") | Create a symmetric Fiedler matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Fiedler Companion | [`scipy.linalg.fiedler_companion`](../reference/generated/scipy.linalg.fiedler_companion.html#scipy.linalg.fiedler_companion
    "scipy.linalg.fiedler_companion") | Create a Fiedler companion matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Hadamard | [`scipy.linalg.hadamard`](../reference/generated/scipy.linalg.hadamard.html#scipy.linalg.hadamard
    "scipy.linalg.hadamard") | Create an Hadamard matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Hankel | [`scipy.linalg.hankel`](../reference/generated/scipy.linalg.hankel.html#scipy.linalg.hankel
    "scipy.linalg.hankel") | Create a Hankel matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Helmert | [`scipy.linalg.helmert`](../reference/generated/scipy.linalg.helmert.html#scipy.linalg.helmert
    "scipy.linalg.helmert") | Create a Helmert matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Hilbert | [`scipy.linalg.hilbert`](../reference/generated/scipy.linalg.hilbert.html#scipy.linalg.hilbert
    "scipy.linalg.hilbert") | Create a Hilbert matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Inverse Hilbert | [`scipy.linalg.invhilbert`](../reference/generated/scipy.linalg.invhilbert.html#scipy.linalg.invhilbert
    "scipy.linalg.invhilbert") | Create the inverse of a Hilbert matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Leslie | [`scipy.linalg.leslie`](../reference/generated/scipy.linalg.leslie.html#scipy.linalg.leslie
    "scipy.linalg.leslie") | Create a Leslie matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Pascal | [`scipy.linalg.pascal`](../reference/generated/scipy.linalg.pascal.html#scipy.linalg.pascal
    "scipy.linalg.pascal") | Create a Pascal matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Inverse Pascal | [`scipy.linalg.invpascal`](../reference/generated/scipy.linalg.invpascal.html#scipy.linalg.invpascal
    "scipy.linalg.invpascal") | Create the inverse of a Pascal matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Toeplitz | [`scipy.linalg.toeplitz`](../reference/generated/scipy.linalg.toeplitz.html#scipy.linalg.toeplitz
    "scipy.linalg.toeplitz") | Create a Toeplitz matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| Van der Monde | [`numpy.vander`](https://numpy.org/devdocs/reference/generated/numpy.vander.html#numpy.vander
    "(in NumPy v2.0.dev0)") | Create a Van der Monde matrix. |'
  prefs: []
  type: TYPE_TB
- en: For examples of the use of these functions, see their respective docstrings.
  prefs: []
  type: TYPE_NORMAL
