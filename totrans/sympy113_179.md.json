["```py\n>>> from sympy import *\n>>> from sympy.physics.mechanics import *\n>>> print('Calculation of Linearized Bicycle \\\"A\\\" Matrix, '\n...       'with States: Roll, Steer, Roll Rate, Steer Rate')\nCalculation of Linearized Bicycle \"A\" Matrix, with States: Roll, Steer, Roll Rate, Steer Rate \n```", "```py\n>>> mechanics_printing(pretty_print=False) \n```", "```py\n>>> q1, q2, q3, q4, q5 = dynamicsymbols('q1 q2 q3 q4 q5')\n>>> q1d, q2d, q4d, q5d = dynamicsymbols('q1 q2 q4 q5', 1)\n>>> u1, u2, u3, u4, u5, u6 = dynamicsymbols('u1 u2 u3 u4 u5 u6')\n>>> u1d, u2d, u3d, u4d, u5d, u6d = dynamicsymbols('u1 u2 u3 u4 u5 u6', 1) \n```", "```py\n>>> WFrad, WRrad, htangle, forkoffset = symbols('WFrad WRrad htangle forkoffset')\n>>> forklength, framelength, forkcg1 = symbols('forklength framelength forkcg1')\n>>> forkcg3, framecg1, framecg3, Iwr11 = symbols('forkcg3 framecg1 framecg3 Iwr11')\n>>> Iwr22, Iwf11, Iwf22, Iframe11 = symbols('Iwr22 Iwf11 Iwf22 Iframe11')\n>>> Iframe22, Iframe33, Iframe31, Ifork11 = \\\n...     symbols('Iframe22 Iframe33 Iframe31 Ifork11')\n>>> Ifork22, Ifork33, Ifork31, g = symbols('Ifork22 Ifork33 Ifork31 g')\n>>> mframe, mfork, mwf, mwr = symbols('mframe mfork mwf mwr') \n```", "```py\n>>> N = ReferenceFrame('N')\n>>> Y = N.orientnew('Y', 'Axis', [q1, N.z])\n>>> R = Y.orientnew('R', 'Axis', [q2, Y.x])\n>>> Frame = R.orientnew('Frame', 'Axis', [q4 + htangle, R.y])\n>>> WR = ReferenceFrame('WR')\n>>> TempFrame = Frame.orientnew('TempFrame', 'Axis', [-htangle, Frame.y])\n>>> Fork = Frame.orientnew('Fork', 'Axis', [q5, Frame.x])\n>>> TempFork = Fork.orientnew('TempFork', 'Axis', [-htangle, Fork.y])\n>>> WF = ReferenceFrame('WF') \n```", "```py\n>>> WR_cont = Point('WR_cont')\n>>> WR_mc = WR_cont.locatenew('WR_mc', WRrad * R.z)\n>>> Steer = WR_mc.locatenew('Steer', framelength * Frame.z)\n>>> Frame_mc = WR_mc.locatenew('Frame_mc', -framecg1 * Frame.x + framecg3 * Frame.z)\n>>> Fork_mc = Steer.locatenew('Fork_mc', -forkcg1 * Fork.x + forkcg3 * Fork.z)\n>>> WF_mc = Steer.locatenew('WF_mc', forklength * Fork.x + forkoffset * Fork.z)\n>>> WF_cont = WF_mc.locatenew('WF_cont', WFrad*(dot(Fork.y, Y.z)*Fork.y - \\\n...                                             Y.z).normalize()) \n```", "```py\n>>> Y.set_ang_vel(N, u1 * Y.z)\n>>> R.set_ang_vel(Y, u2 * R.x)\n>>> WR.set_ang_vel(Frame, u3 * Frame.y)\n>>> Frame.set_ang_vel(R, u4 * Frame.y)\n>>> Fork.set_ang_vel(Frame, u5 * Fork.x)\n>>> WF.set_ang_vel(Fork, u6 * Fork.y) \n```", "```py\n>>> WR_cont.set_vel(N, 0)\n>>> WR_mc.v2pt_theory(WR_cont, N, WR)\nWRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y\n>>> Steer.v2pt_theory(WR_mc, N, Frame)\nWRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y + framelength*(u1*sin(q2) + u4)*Frame.x - framelength*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4))*Frame.y\n>>> Frame_mc.v2pt_theory(WR_mc, N, Frame)\nWRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y + framecg3*(u1*sin(q2) + u4)*Frame.x + (-framecg1*(u1*cos(htangle + q4)*cos(q2) + u2*sin(htangle + q4)) - framecg3*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4)))*Frame.y + framecg1*(u1*sin(q2) + u4)*Frame.z\n>>> Fork_mc.v2pt_theory(Steer, N, Fork)\nWRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y + framelength*(u1*sin(q2) + u4)*Frame.x - framelength*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4))*Frame.y + forkcg3*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5))*Fork.x + (-forkcg1*((-sin(q2)*sin(q5) + cos(htangle + q4)*cos(q2)*cos(q5))*u1 + u2*sin(htangle + q4)*cos(q5) - u4*sin(q5)) - forkcg3*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4) + u5))*Fork.y + forkcg1*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5))*Fork.z\n>>> WF_mc.v2pt_theory(Steer, N, Fork)\nWRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y + framelength*(u1*sin(q2) + u4)*Frame.x - framelength*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4))*Frame.y + forkoffset*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5))*Fork.x + (forklength*((-sin(q2)*sin(q5) + cos(htangle + q4)*cos(q2)*cos(q5))*u1 + u2*sin(htangle + q4)*cos(q5) - u4*sin(q5)) - forkoffset*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4) + u5))*Fork.y - forklength*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5))*Fork.z\n>>> WF_cont.v2pt_theory(WF_mc, N, WF)\n- WFrad*((-sin(q2)*sin(q5)*cos(htangle + q4) + cos(q2)*cos(q5))*u6 + u4*cos(q2) + u5*sin(htangle + q4)*sin(q2))/sqrt((-sin(q2)*cos(q5) - sin(q5)*cos(htangle + q4)*cos(q2))*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2)) + 1)*Y.x + WFrad*(u2 + u5*cos(htangle + q4) + u6*sin(htangle + q4)*sin(q5))/sqrt((-sin(q2)*cos(q5) - sin(q5)*cos(htangle + q4)*cos(q2))*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2)) + 1)*Y.y + WRrad*(u1*sin(q2) + u3 + u4)*R.x - WRrad*u2*R.y + framelength*(u1*sin(q2) + u4)*Frame.x - framelength*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4))*Frame.y + (-WFrad*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*((-sin(q2)*sin(q5) + cos(htangle + q4)*cos(q2)*cos(q5))*u1 + u2*sin(htangle + q4)*cos(q5) - u4*sin(q5))/sqrt((-sin(q2)*cos(q5) - sin(q5)*cos(htangle + q4)*cos(q2))*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2)) + 1) + forkoffset*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5)))*Fork.x + (forklength*((-sin(q2)*sin(q5) + cos(htangle + q4)*cos(q2)*cos(q5))*u1 + u2*sin(htangle + q4)*cos(q5) - u4*sin(q5)) - forkoffset*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4) + u5))*Fork.y + (WFrad*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*(-u1*sin(htangle + q4)*cos(q2) + u2*cos(htangle + q4) + u5)/sqrt((-sin(q2)*cos(q5) - sin(q5)*cos(htangle + q4)*cos(q2))*(sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2)) + 1) - forklength*((sin(q2)*cos(q5) + sin(q5)*cos(htangle + q4)*cos(q2))*u1 + u2*sin(htangle + q4)*sin(q5) + u4*cos(q5)))*Fork.z \n```", "```py\n>>> Frame_I = (inertia(TempFrame, Iframe11, Iframe22, Iframe33, 0, 0,\n...                                                   Iframe31), Frame_mc)\n>>> Fork_I = (inertia(TempFork, Ifork11, Ifork22, Ifork33, 0, 0, Ifork31), Fork_mc)\n>>> WR_I = (inertia(Frame, Iwr11, Iwr22, Iwr11), WR_mc)\n>>> WF_I = (inertia(Fork, Iwf11, Iwf22, Iwf11), WF_mc) \n```", "```py\n>>> BodyFrame = RigidBody('BodyFrame', Frame_mc, Frame, mframe, Frame_I)\n>>> BodyFork = RigidBody('BodyFork', Fork_mc, Fork, mfork, Fork_I)\n>>> BodyWR = RigidBody('BodyWR', WR_mc, WR, mwr, WR_I)\n>>> BodyWF = RigidBody('BodyWF', WF_mc, WF, mwf, WF_I)\n\n>>> print('Before Forming the List of Nonholonomic Constraints.')\nBefore Forming the List of Nonholonomic Constraints. \n```", "```py\n>>> kd = [q1d - u1, q2d - u2, q4d - u4, q5d - u5] \n```", "```py\n>>> conlist_speed = [dot(WF_cont.vel(N), Y.x),\n...                  dot(WF_cont.vel(N), Y.y),\n...                  dot(WF_cont.vel(N), Y.z)] \n```", "```py\n>>> conlist_coord = [dot(WF_cont.pos_from(WR_cont), Y.z)] \n```", "```py\n>>> FL = [(Frame_mc, -mframe * g * Y.z), (Fork_mc, -mfork * g * Y.z),\n...       (WF_mc, -mwf * g * Y.z), (WR_mc, -mwr * g * Y.z)]\n>>> BL = [BodyFrame, BodyFork, BodyWR, BodyWF] \n```", "```py\n>>> KM = KanesMethod(N, q_ind=[q1, q2, q5],\n...           q_dependent=[q4], configuration_constraints=conlist_coord,\n...           u_ind=[u2, u3, u5],\n...           u_dependent=[u1, u4, u6], velocity_constraints=conlist_speed,\n...           kd_eqs=kd)\n>>> print('Before Forming Generalized Active and Inertia Forces, Fr and Fr*')\nBefore Forming Generalized Active and Inertia Forces, Fr and Fr*\n>>> (fr, frstar) = KM.kanes_equations(BL, FL)\n>>> print('Base Equations of Motion Computed')\nBase Equations of Motion Computed \n```", "```py\n>>> PaperRadRear  =  0.3\n>>> PaperRadFront =  0.35\n>>> HTA           =  evalf.N(pi/2-pi/10)\n>>> TrailPaper    =  0.08\n>>> rake          =  evalf.N(-(TrailPaper*sin(HTA)-(PaperRadFront*cos(HTA))))\n>>> PaperWb       =  1.02\n>>> PaperFrameCgX =  0.3\n>>> PaperFrameCgZ =  0.9\n>>> PaperForkCgX  =  0.9\n>>> PaperForkCgZ  =  0.7\n>>> FrameLength   =  evalf.N(PaperWb*sin(HTA) - (rake - \\\n...                         (PaperRadFront - PaperRadRear)*cos(HTA)))\n>>> FrameCGNorm   =  evalf.N((PaperFrameCgZ - PaperRadRear - \\\n...                          (PaperFrameCgX/sin(HTA))*cos(HTA))*sin(HTA))\n>>> FrameCGPar    =  evalf.N((PaperFrameCgX / sin(HTA) + \\\n...                          (PaperFrameCgZ - PaperRadRear - \\\n...                           PaperFrameCgX / sin(HTA) * cos(HTA)) * cos(HTA)))\n>>> tempa         =  evalf.N((PaperForkCgZ - PaperRadFront))\n>>> tempb         =  evalf.N((PaperWb-PaperForkCgX))\n>>> tempc         =  evalf.N(sqrt(tempa**2 + tempb**2))\n>>> PaperForkL    =  evalf.N((PaperWb*cos(HTA) - \\\n...                          (PaperRadFront - PaperRadRear)*sin(HTA)))\n>>> ForkCGNorm    =  evalf.N(rake + (tempc * sin(pi/2 - \\\n...                          HTA - acos(tempa/tempc))))\n>>> ForkCGPar     =  evalf.N(tempc * cos((pi/2 - HTA) - \\\n...                          acos(tempa/tempc)) - PaperForkL) \n```", "```py\n>>> v = Symbol('v')\n>>> val_dict = {\n...       WFrad: PaperRadFront,\n...       WRrad: PaperRadRear,\n...       htangle: HTA,\n...       forkoffset: rake,\n...       forklength: PaperForkL,\n...       framelength: FrameLength,\n...       forkcg1: ForkCGPar,\n...       forkcg3: ForkCGNorm,\n...       framecg1: FrameCGNorm,\n...       framecg3: FrameCGPar,\n...       Iwr11: 0.0603,\n...       Iwr22: 0.12,\n...       Iwf11: 0.1405,\n...       Iwf22: 0.28,\n...       Ifork11: 0.05892,\n...       Ifork22: 0.06,\n...       Ifork33: 0.00708,\n...       Ifork31: 0.00756,\n...       Iframe11: 9.2,\n...       Iframe22: 11,\n...       Iframe33: 2.8,\n...       Iframe31: -2.4,\n...       mfork: 4,\n...       mframe: 85,\n...       mwf: 3,\n...       mwr: 2,\n...       g: 9.81,\n...       q1: 0,\n...       q2: 0,\n...       q4: 0,\n...       q5: 0,\n...       u1: 0,\n...       u2: 0,\n...       u3: v/PaperRadRear,\n...       u4: 0,\n...       u5: 0,\n...       u6: v/PaperRadFront}\n>>> kdd = KM.kindiffdict()\n>>> print('Before Linearization of the \\\"Forcing\\\" Term')\nBefore Linearization of the \"Forcing\" Term \n```", "```py\n>>> # forcing_lin = KM.linearize()[0].subs(sub_dict) \n```", "```py\n>>> MM_full = (KM._k_kqdot).row_join(zeros(4, 6)).col_join(\n...           (zeros(6, 4)).row_join(KM.mass_matrix))\n>>> print('Before Substitution of Numerical Values')\nBefore Substitution of Numerical Values \n```", "```py\n>>> # MM_full = MM_full.subs(val_dict)\n>>> # forcing_lin = forcing_lin.subs(val_dict)\n>>> # print('Before .evalf() call')\n\n>>> # MM_full = MM_full.evalf()\n>>> # forcing_lin = forcing_lin.evalf() \n```", "```py\n>>> # Amat = MM_full.inv() * forcing_lin\n>>> # A = Amat.extract([1,2,4,6],[1,2,3,5])\n>>> # print(A)\n>>> # print('v = 1')\n>>> # print(A.subs(v, 1).eigenvals())\n>>> # print('v = 2')\n>>> # print(A.subs(v, 2).eigenvals())\n>>> # print('v = 3')\n>>> # print(A.subs(v, 3).eigenvals())\n>>> # print('v = 4')\n>>> # print(A.subs(v, 4).eigenvals())\n>>> # print('v = 5')\n>>> # print(A.subs(v, 5).eigenvals()) \n```"]