- en: Using the Convenience Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/routines.polynomials.classes.html](https://numpy.org/doc/1.26/reference/routines.polynomials.classes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The convenience classes provided by the polynomial package are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Provides |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Polynomial | Power series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Chebyshev | Chebyshev series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Legendre | Legendre series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Laguerre | Laguerre series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Hermite | Hermite series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| HermiteE | HermiteE series |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: The series in this context are finite sums of the corresponding polynomial basis
    functions multiplied by coefficients. For instance, a power series looks like
  prefs: []
  type: TYPE_NORMAL
- en: \[p(x) = 1 + 2x + 3x^2\]
  prefs: []
  type: TYPE_NORMAL
- en: and has coefficients \([1, 2, 3]\). The Chebyshev series with the same coefficients
    looks like
  prefs: []
  type: TYPE_NORMAL
- en: \[p(x) = 1 T_0(x) + 2 T_1(x) + 3 T_2(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: and more generally
  prefs: []
  type: TYPE_NORMAL
- en: \[p(x) = \sum_{i=0}^n c_i T_i(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: where in this case the \(T_n\) are the Chebyshev functions of degree \(n\),
    but could just as easily be the basis functions of any of the other classes. The
    convention for all the classes is that the coefficient \(c[i]\) goes with the
    basis function of degree i.
  prefs: []
  type: TYPE_NORMAL
- en: All of the classes are immutable and have the same methods, and especially they
    implement the Python numeric operators +, -, *, //, %, divmod, **, ==, and !=.
    The last two can be a bit problematic due to floating point roundoff errors. We
    now give a quick demonstration of the various operations using NumPy version 1.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need a polynomial class and a polynomial instance to play with. The
    classes can be imported directly from the polynomial package or from the module
    of the relevant type. Here we import from the package and use the conventional
    Polynomial class because of its familiarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are three parts to the long version of the printout. The first
    is the coefficients, the second is the domain, and the third is the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing a polynomial yields the polynomial expression in a more familiar format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the string representation of polynomials uses Unicode characters
    by default (except on Windows) to express powers and subscripts. An ASCII-based
    representation is also available (default on Windows). The polynomial string format
    can be toggled at the package-level with the [`set_default_printstyle`](generated/numpy.polynomial.set_default_printstyle.html#numpy.polynomial.set_default_printstyle
    "numpy.polynomial.set_default_printstyle") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'or controlled for individual polynomial instances with string formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will deal with the domain and window when we get to fitting, for the moment
    we ignore them and run through the basic algebraic and arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition and Subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Powers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Division:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Floor division, ‘//’, is the division operator for the polynomial classes,
    polynomials are treated like integers in this regard. For Python versions < 3.x
    the ‘/’ operator maps to ‘//’, as it does for Python, for later versions the ‘/’
    will only work for division by scalars. At some point it will be deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Divmod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitute a polynomial for x and expand the result. Here we substitute p in
    itself leading to a new polynomial of degree 4 after expansion. If the polynomials
    are regarded as functions this is composition of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It isn’t always convenient to explicitly use Polynomial instances, so tuples,
    lists, arrays, and scalars are automatically cast in the arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials that differ in domain, window, or class can’t be mixed in arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But different types can be used for substitution. In fact, this is how conversion
    of Polynomial classes among themselves is done for type, domain, and window casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Which gives the polynomial *p* in Chebyshev form. This works because \(T_1(x)
    = x\) and substituting \(x\) for \(x\) doesn’t change the original polynomial.
    However, all the multiplications and divisions will be done using Chebyshev series,
    hence the type of the result.
  prefs: []
  type: TYPE_NORMAL
- en: It is intended that all polynomial instances are immutable, therefore augmented
    operations (`+=`, `-=`, etc.) and any other functionality that would violate the
    immutablity of a polynomial instance are intentionally unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polynomial instances can be integrated and differentiated.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example integrates *p* once, the second example integrates it twice.
    By default, the lower bound of the integration and the integration constant are
    0, but both can be specified.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first case the lower bound of the integration is set to -1 and the integration
    constant is 0\. In the second the constant of integration is set to 1 as well.
    Differentiation is simpler since the only option is the number of times the polynomial
    is differentiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Other Polynomial Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructing polynomials by specifying coefficients is just one way of obtaining
    a polynomial instance, they may also be created by specifying their roots, by
    conversion from other polynomial types, and by least squares fits. Fitting is
    discussed in its own section, the other methods are demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The convert method can also convert domain and window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In numpy versions >= 1.7.0 the *basis* and *cast* class methods are also available.
    The cast method works like the convert method while the basis method returns the
    basis polynomial of given degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Conversions between types can be useful, but it is *not* recommended for routine
    use. The loss of numerical precision in passing from a Chebyshev series of degree
    50 to a Polynomial series of the same degree can make the results of numerical
    evaluation essentially random.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fitting is the reason that the *domain* and *window* attributes are part of
    the convenience classes. To illustrate the problem, the values of the Chebyshev
    polynomials up to degree 5 are plotted below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-1.png](../Images/6d79e2b61bbb83e904b2ea95224b4f80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the range -1 <= *x* <= 1 they are nice, equiripple functions lying between
    +/- 1. The same plots over the range -2 <= *x* <= 2 look very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-2.png](../Images/46b6715bf8fdd2cd16c983468b821029.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, the “good” parts have shrunk to insignificance. In using Chebyshev
    polynomials for fitting we want to use the region where *x* is between -1 and
    1 and that is what the *window* specifies. However, it is unlikely that the data
    to be fit has all its data points in that interval, so we use *domain* to specify
    the interval where the data points lie. When the fit is done, the domain is first
    mapped to the window by a linear transformation and the usual least squares fit
    is done using the mapped data points. The window and domain of the fit are part
    of the returned series and are automatically used when computing values, derivatives,
    and such. If they aren’t specified in the call the fitting routine will use the
    default window and the smallest domain that holds all the data points. This is
    illustrated below for a fit to a noisy sine curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-3.png](../Images/5a26f7aa7b35192835363053385515d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need a polynomial class and a polynomial instance to play with. The
    classes can be imported directly from the polynomial package or from the module
    of the relevant type. Here we import from the package and use the conventional
    Polynomial class because of its familiarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are three parts to the long version of the printout. The first
    is the coefficients, the second is the domain, and the third is the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing a polynomial yields the polynomial expression in a more familiar format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the string representation of polynomials uses Unicode characters
    by default (except on Windows) to express powers and subscripts. An ASCII-based
    representation is also available (default on Windows). The polynomial string format
    can be toggled at the package-level with the [`set_default_printstyle`](generated/numpy.polynomial.set_default_printstyle.html#numpy.polynomial.set_default_printstyle
    "numpy.polynomial.set_default_printstyle") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'or controlled for individual polynomial instances with string formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will deal with the domain and window when we get to fitting, for the moment
    we ignore them and run through the basic algebraic and arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition and Subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Powers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Division:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Floor division, ‘//’, is the division operator for the polynomial classes,
    polynomials are treated like integers in this regard. For Python versions < 3.x
    the ‘/’ operator maps to ‘//’, as it does for Python, for later versions the ‘/’
    will only work for division by scalars. At some point it will be deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Divmod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Substitute a polynomial for x and expand the result. Here we substitute p in
    itself leading to a new polynomial of degree 4 after expansion. If the polynomials
    are regarded as functions this is composition of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Roots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It isn’t always convenient to explicitly use Polynomial instances, so tuples,
    lists, arrays, and scalars are automatically cast in the arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Polynomials that differ in domain, window, or class can’t be mixed in arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'But different types can be used for substitution. In fact, this is how conversion
    of Polynomial classes among themselves is done for type, domain, and window casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Which gives the polynomial *p* in Chebyshev form. This works because \(T_1(x)
    = x\) and substituting \(x\) for \(x\) doesn’t change the original polynomial.
    However, all the multiplications and divisions will be done using Chebyshev series,
    hence the type of the result.
  prefs: []
  type: TYPE_NORMAL
- en: It is intended that all polynomial instances are immutable, therefore augmented
    operations (`+=`, `-=`, etc.) and any other functionality that would violate the
    immutablity of a polynomial instance are intentionally unimplemented.
  prefs: []
  type: TYPE_NORMAL
- en: Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polynomial instances can be integrated and differentiated.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example integrates *p* once, the second example integrates it twice.
    By default, the lower bound of the integration and the integration constant are
    0, but both can be specified.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first case the lower bound of the integration is set to -1 and the integration
    constant is 0\. In the second the constant of integration is set to 1 as well.
    Differentiation is simpler since the only option is the number of times the polynomial
    is differentiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Other Polynomial Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constructing polynomials by specifying coefficients is just one way of obtaining
    a polynomial instance, they may also be created by specifying their roots, by
    conversion from other polynomial types, and by least squares fits. Fitting is
    discussed in its own section, the other methods are demonstrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The convert method can also convert domain and window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In numpy versions >= 1.7.0 the *basis* and *cast* class methods are also available.
    The cast method works like the convert method while the basis method returns the
    basis polynomial of given degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Conversions between types can be useful, but it is *not* recommended for routine
    use. The loss of numerical precision in passing from a Chebyshev series of degree
    50 to a Polynomial series of the same degree can make the results of numerical
    evaluation essentially random.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fitting is the reason that the *domain* and *window* attributes are part of
    the convenience classes. To illustrate the problem, the values of the Chebyshev
    polynomials up to degree 5 are plotted below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-1.png](../Images/6d79e2b61bbb83e904b2ea95224b4f80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the range -1 <= *x* <= 1 they are nice, equiripple functions lying between
    +/- 1. The same plots over the range -2 <= *x* <= 2 look very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-2.png](../Images/46b6715bf8fdd2cd16c983468b821029.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, the “good” parts have shrunk to insignificance. In using Chebyshev
    polynomials for fitting we want to use the region where *x* is between -1 and
    1 and that is what the *window* specifies. However, it is unlikely that the data
    to be fit has all its data points in that interval, so we use *domain* to specify
    the interval where the data points lie. When the fit is done, the domain is first
    mapped to the window by a linear transformation and the usual least squares fit
    is done using the mapped data points. The window and domain of the fit are part
    of the returned series and are automatically used when computing values, derivatives,
    and such. If they aren’t specified in the call the fitting routine will use the
    default window and the smallest domain that holds all the data points. This is
    illustrated below for a fit to a noisy sine curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/routines-polynomials-classes-3.png](../Images/5a26f7aa7b35192835363053385515d0.png)'
  prefs: []
  type: TYPE_IMG
