- en: scipy.signal.filtfilt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.filtfilt.html#scipy.signal.filtfilt](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.filtfilt.html#scipy.signal.filtfilt)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Apply a digital filter forward and backward to a signal.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies a linear digital filter twice, once forward and once backwards.
    The combined filter has zero phase and a filter order twice that of the original.
  prefs: []
  type: TYPE_NORMAL
- en: The function provides options for handling the edges of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: The function [`sosfiltfilt`](scipy.signal.sosfiltfilt.html#scipy.signal.sosfiltfilt
    "scipy.signal.sosfiltfilt") (and filter design using `output='sos'`) should be
    preferred over [`filtfilt`](#scipy.signal.filtfilt "scipy.signal.filtfilt") for
    most filtering tasks, as second-order sections have fewer numerical problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**b**(N,) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The numerator coefficient vector of the filter.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(N,) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The denominator coefficient vector of the filter. If `a[0]` is not 1, then both
    *a* and *b* are normalized by `a[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The array of data to be filtered.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The axis of *x* to which the filter is applied. Default is -1.
  prefs: []
  type: TYPE_NORMAL
- en: '**padtype**str or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Must be ‘odd’, ‘even’, ‘constant’, or None. This determines the type of extension
    to use for the padded signal to which the filter is applied. If *padtype* is None,
    no padding is used. The default is ‘odd’.
  prefs: []
  type: TYPE_NORMAL
- en: '**padlen**int or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The number of elements by which to extend *x* at both ends of *axis* before
    applying the filter. This value must be less than `x.shape[axis] - 1`. `padlen=0`
    implies no padding. The default value is `3 * max(len(a), len(b))`.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Determines the method for handling the edges of the signal, either “pad” or
    “gust”. When *method* is “pad”, the signal is padded; the type of padding is determined
    by *padtype* and *padlen*, and *irlen* is ignored. When *method* is “gust”, Gustafsson’s
    method is used, and *padtype* and *padlen* are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**irlen**int or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: When *method* is “gust”, *irlen* specifies the length of the impulse response
    of the filter. If *irlen* is None, no part of the impulse response is ignored.
    For a long signal, specifying *irlen* can significantly improve the performance
    of the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**y**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The filtered output with the same shape as *x*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sosfiltfilt`](scipy.signal.sosfiltfilt.html#scipy.signal.sosfiltfilt "scipy.signal.sosfiltfilt"),
    [`lfilter_zi`](scipy.signal.lfilter_zi.html#scipy.signal.lfilter_zi "scipy.signal.lfilter_zi"),
    [`lfilter`](scipy.signal.lfilter.html#scipy.signal.lfilter "scipy.signal.lfilter"),
    [`lfiltic`](scipy.signal.lfiltic.html#scipy.signal.lfiltic "scipy.signal.lfiltic"),
    [`savgol_filter`](scipy.signal.savgol_filter.html#scipy.signal.savgol_filter "scipy.signal.savgol_filter"),
    [`sosfilt`](scipy.signal.sosfilt.html#scipy.signal.sosfilt "scipy.signal.sosfilt")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'When *method* is “pad”, the function pads the data along the given axis in
    one of three ways: odd, even or constant. The odd and even extensions have the
    corresponding symmetry about the end point of the data. The constant extension
    extends the data with the values at the end points. On both the forward and backward
    passes, the initial condition of the filter is found by using [`lfilter_zi`](scipy.signal.lfilter_zi.html#scipy.signal.lfilter_zi
    "scipy.signal.lfilter_zi") and scaling it by the end point of the extended data.'
  prefs: []
  type: TYPE_NORMAL
- en: When *method* is “gust”, Gustafsson’s method [[1]](#r10879a509a76-1) is used.
    Initial conditions are chosen for the forward and backward passes so that the
    forward-backward filter gives the same result as the backward-forward filter.
  prefs: []
  type: TYPE_NORMAL
- en: The option to use Gustaffson’s method was added in scipy version 0.16.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: F. Gustaffson, “Determining the initial states in forward-backward filtering”,
    Transactions on Signal Processing, Vol. 46, pp. 988-992, 1996.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The examples will use several functions from [`scipy.signal`](../signal.html#module-scipy.signal
    "scipy.signal").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First we create a one second signal that is the sum of two pure sine waves,
    with frequencies 5 Hz and 250 Hz, sampled at 2000 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now create a lowpass Butterworth filter with a cutoff of 0.125 times the Nyquist
    frequency, or 125 Hz, and apply it to `x` with [`filtfilt`](#scipy.signal.filtfilt
    "scipy.signal.filtfilt"). The result should be approximately `xlow`, with no phase
    shift.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We get a fairly clean result for this artificial example because the odd extension
    is exact, and with the moderately long padding, the filter’s transients have dissipated
    by the time the actual data is reached. In general, transient effects at the edges
    are unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates the option `method="gust"`.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a filter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*sig* is a random input signal to be filtered.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Apply [`filtfilt`](#scipy.signal.filtfilt "scipy.signal.filtfilt") to *sig*,
    once using the Gustafsson method, and once using padding, and plot the results
    for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-filtfilt-1_00_00.png](../Images/7094dc8e2e627f6d89567358db9bada3.png)'
  prefs: []
  type: TYPE_IMG
- en: The *irlen* argument can be used to improve the performance of Gustafsson’s
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Estimate the impulse response length of the filter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Apply the filter to a longer signal, with and without the *irlen* argument.
    The difference between *y1* and *y2* is small. For long signals, using *irlen*
    gives a significant performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
