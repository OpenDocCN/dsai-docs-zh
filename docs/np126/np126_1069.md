# Python 类型和 C 结构

> 原文：[`numpy.org/doc/1.26/reference/c-api/types-and-structures.html`](https://numpy.org/doc/1.26/reference/c-api/types-and-structures.html)

几种新类型在 C 代码中定义。其中大多数可以从 Python 中访问，但由于使用受限，有些则没有暴露出来。每个新的 Python 类型都有一个关联的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)")*，其内部结构包括指向“方法表”的指针，定义了新对象在 Python 中的行为。在 C 代码中接收到 Python 对象时，始终会得到一个指向[`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)") 结构的指针。因为 [`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)") 结构非常通用，仅定义了 [`PyObject_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD "(in Python v3.11)")，因此本身并不是很有趣。但是，不同类型的对象在[`PyObject_HEAD`](https://docs.python.org/3/c-api/structures.html#c.PyObject_HEAD "(in Python v3.11)")之后包含更多细节（但你必须将其转换为正确的类型才能访问它们 - 或者使用访问器函数或宏）。

## 定义了新的 Python 类型

Python 类型在 C 语言中等效于 Python 中的类。通过构建新的 Python 类型，可以为 Python 提供一个新的对象。ndarray 对象就是在 C 中定义的一个新类型的例子。通过两个基本步骤在 C 中定义新类型：

1.  创建一个 C 结构（通常命名为 `Py{Name}Object`），它与 [`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)") 结构本身二进制兼容，但包含了特定对象需要的额外信息；

1.  使用指针指向实现所需行为的函数，将[`PyTypeObject`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "(in Python v3.11)")表（由[`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)") 结构的 ob_type 成员指向）填充。

不再使用定义 Python 类的特殊方法名，而是使用指向实现所需结果的函数的“函数表”。自从 Python 2.2 开始，PyTypeObject 本身变得动态，允许从其他 C 类型“子类型化” C 类型，并在 Python 中派生子类。子类型继承其父类的属性和方法。

有两种主要的新类型：ndarray（ `PyArray_Type` ）和 ufunc（ `PyUFunc_Type` ）。其他类型起着支持作用：`PyArrayIter_Type`、`PyArrayMultiIter_Type` 和 `PyArrayDescr_Type`。`PyArrayIter_Type` 是用于 ndarray 的平面迭代器的类型（获取 flat 属性时返回的对象）。`PyArrayMultiIter_Type` 是在调用 `broadcast` () 时返回的对象的类型。它处理对嵌套序列集合的迭代和广播。此外，`PyArrayDescr_Type` 是描述数据的数据类型描述符类型，其实例描述数据。最后，有 21 种新的标量数组类型，它们是与数组可用的每种基本数据类型对应的新的 Python 标量。另外还有 10 种其他类型是占位符，允许数组标量适应实际 Python 类型的层次结构。

### PyArray_Type 和 PyArrayObject

```py
PyArray_Type
```

ndarray 的 Python 类型是 `PyArray_Type`。在 C 中，每个 ndarray 都是指向 `PyArrayObject` 结构的指针。此结构的 `ob_type` 成员包含指向 `PyArray_Type` 类型对象的指针。

```py
type PyArrayObject
```

```py
type NPY_AO
```

`PyArrayObject` C 结构包含数组的所有必需信息。所有 ndarray（及其子类）的实例都将具有此结构。为了未来的兼容性，应该通常使用提供的宏来访问这些结构成员。如果需要更短的名称，那么可以使用已弃用的 `NPY_AO`，它被定义为等同于 `PyArrayObject`。直接访问结构字段已被弃用。请改用 `PyArray_*(arr)` 形式。截至 NumPy 1.20，此结构的大小不被视为 NumPy ABI 的一部分（请参见成员列表末尾的注释）。

```py
typedef  struct  PyArrayObject  {
  PyObject_HEAD
  char  *data;
  int  nd;
  npy_intp  *dimensions;
  npy_intp  *strides;
  PyObject  *base;
  PyArray_Descr  *descr;
  int  flags;
  PyObject  *weakreflist;
  /* version dependent private members */
}  PyArrayObject; 
```

```py
PyObject_HEAD
```

这是所有 Python 对象所需的。它至少包含一个引用计数成员（ `ob_refcnt` ）和一个指向类型对象的指针（ `ob_type` ）。（如果 Python 是使用特殊选项编译的，还可能存在其他元素，请参阅 Python 源树中的 Include/object.h 了解更多信息）。`ob_type` 成员指向 Python 类型对象。

```py
char *data
```

通过 `PyArray_DATA` 可访问，此数据成员是数组的第一个元素的指针。这个指针可以（通常应该）重新转换为数组的数据类型。

```py
int nd
```

一个整数，提供此数组的维数。当 nd 为 0 时，有时称为秩-0 数组。这种数组具有未定义的维度和步幅，无法访问。宏`PyArray_NDIM`定义在`ndarraytypes.h`指向这个数据成员。`NPY_MAXDIMS` 是任何数组的最大维数。

```py
*dimensions
```

一个整数数组，为每个维度提供该维度中的形状，只要 nd \(\geq\) 1。这个整数总是足够大，能够在平台上保存一个指针，所以维度大小仅受内存限制。`PyArray_DIMS` 是与这个数据成员相关联的宏。

```py
*strides
```

一个整数数组，为每个维度提供必须跳过的字节数，以到达该维度中的下一个元素。与宏`PyArray_STRIDES`相关联。

```py
*base
```

由`PyArray_BASE`指向，这个成员用于保存与这个数组相关的另一个 Python 对象的指针。有两个用例：

+   如果这个数组没有拥有自己的内存，那么 base 指向拥有它的 Python 对象（也许是另一个数组对象）。

+   如果这个数组设置了`NPY_ARRAY_WRITEBACKIFCOPY`标志，那么这个数组是一个“不良”数组的工作副本。

当调用`PyArray_ResolveWritebackIfCopy`时，base 指向的数组将使用这个数组的内容更新。

```py
*descr
```

指向数据类型描述符对象的指针（见下文）。数据类型描述符对象是新建的内置类型的实例，它允许对内存进行通用描述。对每个支持的数据类型都存在一个描述符结构。这个描述符结构包含有关类型的有用信息，以及一个指向实现特定功能的函数指针表的指针。顾名思义，它与宏`PyArray_DESCR`相关联。

```py
int flags
```

由宏`PyArray_FLAGS`指向，这个数据成员表示标志，指示数据指针指向的内存应如何解释。可能的标志是`NPY_ARRAY_C_CONTIGUOUS`，`NPY_ARRAY_F_CONTIGUOUS`，`NPY_ARRAY_OWNDATA`，`NPY_ARRAY_ALIGNED`，`NPY_ARRAY_WRITEABLE`，`NPY_ARRAY_WRITEBACKIFCOPY`。

```py
*weakreflist
```

这个成员允许数组对象具有弱引用（使用 weakref 模块）。

注意

其他成员被视为私有和与版本有关。如果结构的大小对您的代码很重要，必须特别小心。当这一点相关时的一种可能的用例是在 C 中进行子类化。如果您的代码依赖于 `sizeof(PyArrayObject)` 的大小是不变的，您在导入时必须添加以下检查：

```py
if  (sizeof(PyArrayObject)  <  PyArray_Type.tp_basicsize)  {
  PyErr_SetString(PyExc_ImportError,
  "Binary incompatibility with NumPy, must recompile/update X.");
  return  NULL;
} 
```

为了确保您的代码不必为特定的 NumPy 版本进行编译，您可以添加一个常数，留出 NumPy 变化的空间。可确保与将来任何 NumPy 版本兼容的解决方案需要使用运行时计算偏移和分配大小。

### PyArrayDescr_Type 和 PyArray_Descr

```py
PyArrayDescr_Type
```

`PyArrayDescr_Type` 是用于描述数组所包含的字节应如何解释的数据类型描述对象的内置类型。内置数据类型有 21 个静态定义的 `PyArray_Descr` 对象。虽然这些对象参与引用计数，但它们的引用计数永远不应该达到零。还有一个动态的用户自定义 `PyArray_Descr` 对象表也会被维护。一旦数据类型描述对象被“注册”，它就不应该被释放。函数 `PyArray_DescrFromType` (…) 可以用来从一个枚举类型编号（内置或用户自定义）中检索出一个 `PyArray_Descr` 对象。

```py
type PyArray_Descr
```

`PyArray_Descr` 结构位于 `PyArrayDescr_Type` 的核心。虽然这里描述了它，但它应被视为 NumPy 的内部部分，并通过 `PyArrayDescr_*` 或 `PyDataType*` 函数和宏进行操作。这个结构的大小会随着 NumPy 的版本变化而变化。为确保兼容性：

+   永远不要声明结构的非指针实例

+   永远不要执行指针算术运算

+   永远不要使用 `sizeof(PyArray_Descr)`

它具有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  PyTypeObject  *typeobj;
  char  kind;
  char  type;
  char  byteorder;
  char  flags;
  int  type_num;
  int  elsize;
  int  alignment;
  PyArray_ArrayDescr  *subarray;
  PyObject  *fields;
  PyObject  *names;
  PyArray_ArrFuncs  *f;
  PyObject  *metadata;
  NpyAuxData  *c_metadata;
  npy_hash_t  hash;
}  PyArray_Descr; 
```

```py
*typeobj
```

指向该数组元素对应的 Python 类型的类型对象的指针。对于内置类型，这将指向对应的 array scalar。对于用户定义类型，这应该指向用户定义的类型对象。这个类型对象可以继承自数组标量，也可以不继承。如果它不继承自数组标量，那么`flags` 成员中应该设置 `NPY_USE_GETITEM` 和 `NPY_USE_SETITEM` 标志。

```py
char kind
```

表示数组种类的字符代码（使用数组接口类型字符串表示）。‘b’ 表示布尔型，‘i’ 表示有符号整数，‘u’ 表示无符号整数，‘f’ 表示浮点型，‘c’ 表示复数浮点型，‘S’ 表示 8 位零终结字节，‘U’ 表示 32 位/字符 Unicode 字符串，‘V’ 表示任意类型。

```py
char type
```

指示数据类型的传统字符代码。

```py
char byteorder
```

表示字节顺序的字符：‘>’（大端），‘<’（小端），‘=’（本地），‘|’（不相关，忽略）。所有内置数据类型的字节顺序为‘=’。

```py
char flags
```

决定数据类型是否具有对象数组行为的数据类型位标志。此成员中的每个位都是一个标志，其命名为：

+   `NPY_ITEM_REFCOUNT`

+   `NPY_ITEM_HASOBJECT`

+   `NPY_LIST_PICKLE`

+   `NPY_ITEM_IS_POINTER`

+   `NPY_NEEDS_INIT`

+   `NPY_NEEDS_PYAPI`

+   `NPY_USE_GETITEM`

+   `NPY_USE_SETITEM`

+   `NPY_FROM_FIELDS`

+   `NPY_OBJECT_DTYPE_FLAGS`

```py
int type_num
```

唯一标识数据类型的数字。对于新的数据类型，当数据类型注册时会分配此数字。

```py
int elsize
```

对于始终大小相同的数据类型（例如 long），这表示数据类型的大小。对于灵活的数据类型，其中不同的数组可以具有不同的元素大小，这应为 0。

```py
int alignment
```

提供此数据类型的对齐信息的数字。具体来说，它显示编译器在从 2 个元素结构的开始（其第一个元素是一个 `char`）放置此类型的项目的距离：`offsetof(struct {char c; type v;}, v)`

```py
*subarray
```

如果此为非 `NULL`，则此数据类型描述符是另一个数据类型描述符的 C 风格连续数组。换句话说，此描述符描述的每个元素实际上是另一个基本描述符的数组。如果此为非 `NULL`，则字段成员应为 `NULL`（但是基本描述符的字段成员可以为非 `NULL`）。

```py
type PyArray_ArrayDescr
```

```py
typedef  struct  {
  PyArray_Descr  *base;
  PyObject  *shape;
}  PyArray_ArrayDescr; 
```

```py
*base
```

基本类型的数据类型描述符对象。

```py
*shape
```

子数组的形状（始终为 C 风格连续）作为 Python 元组。

```py
*fields
```

如果此为非空，则此数据类型描述符具有由 Python 字典描述的字段，其键是名称（如果给定也是标题），其值是描述字段的元组。请注意，数据类型描述符始终描述一组固定长度的字节。字段是总的、固定长度集合的命名子区域。字段由另一个数据类型描述符和字节偏移量组成的元组描述。可选地，元组可能包含通常为 Python 字符串的标题。这些元组根据名称（如果给定还有标题）放置在此字典中。

```py
*names
```

字段名称的有序元组。如果未定义字段，则为 NULL。

```py
*f
```

指向一个包含类型需要实现内部特性的函数的结构体的指针。这些函数不同于后面描述的通用函数（ufuncs）。它们的签名可以任意变化。

```py
*metadata
```

关于此数据类型的元数据。

```py
*c_metadata
```

这些特定于特定 dtype 的 C 实现的元数据。增加于 NumPy 1.7.0。

```py
type npy_hash_t
```

```py
*hash
```

目前未使用。保留以用于在缓存哈希值中将来使用。

```py
NPY_ITEM_REFCOUNT
```

表示此数据类型的项必须进行引用计数（使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(在 Python v3.11)") 和 [`Py_DECREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "(在 Python v3.11)")）。

```py
NPY_ITEM_HASOBJECT
```

等同于`NPY_ITEM_REFCOUNT`。

```py
NPY_LIST_PICKLE
```

表示必须将这种数据类型的数组在 pickling 之前转换为列表。

```py
NPY_ITEM_IS_POINTER
```

表示该项是指向其他数据类型的指针。

```py
NPY_NEEDS_INIT
```

表示必须在创建时初始化（设置为 0）此数据类型的内存。

```py
NPY_NEEDS_PYAPI
```

表示在访问时此数据类型需要 Python C-API（因此如果需要数组访问，请不要放弃 GIL）。

```py
NPY_USE_GETITEM
```

在数组访问时，使用`f->getitem`函数指针，而不是标准的转换为数组标量。如果没有定义与数据类型相匹配的数组标量，必须使用。

```py
NPY_USE_SETITEM
```

当从数组标量创建 0 维数组时，使用`f->setitem`而不是标准的从数组标量复制。如果你没有定义与数据类型相匹配的数组标量，必须使用。

```py
NPY_FROM_FIELDS
```

如果在数据类型的任何字段中设置了这些位，则从父数据类型继承这些位。目前（`NPY_NEEDS_INIT` | `NPY_LIST_PICKLE` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_PYAPI`）。

```py
NPY_OBJECT_DTYPE_FLAGS
```

为对象数据类型设置的位：（`NPY_LIST_PICKLE` | `NPY_USE_GETITEM` | `NPY_ITEM_IS_POINTER` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_INIT` | `NPY_NEEDS_PYAPI`）。

```py
int PyDataType_FLAGCHK( *dtype, int flags)
```

如果数据类型对象的所有给定标志都设置为真，则返回真。

```py
int PyDataType_REFCHK( *dtype)
```

等同于`PyDataType_FLAGCHK`（*dtype*，`NPY_ITEM_REFCOUNT`）。

```py
type PyArray_ArrFuncs
```

实现内部特性的函数。并非必须为给定类型定义所有这些函数指针。必须定义的成员包括`nonzero`、`copyswap`、`copyswapn`、`setitem`、`getitem`和`cast`。这默认假定为非 `NULL`，而`NULL`条目将导致程序崩溃。其他函数可以是 `NULL`，这只会导致该数据类型的功能减少。（此外，如果在注册用户定义的数据类型时`nonzero`函数为空，将使用默认函数填充`nonzero`函数）。

```py
typedef  struct  {
  PyArray_VectorUnaryFunc  *cast[NPY_NTYPES];
  PyArray_GetItemFunc  *getitem;
  PyArray_SetItemFunc  *setitem;
  PyArray_CopySwapNFunc  *copyswapn;
  PyArray_CopySwapFunc  *copyswap;
  PyArray_CompareFunc  *compare;
  PyArray_ArgFunc  *argmax;
  PyArray_DotFunc  *dotfunc;
  PyArray_ScanFunc  *scanfunc;
  PyArray_FromStrFunc  *fromstr;
  PyArray_NonzeroFunc  *nonzero;
  PyArray_FillFunc  *fill;
  PyArray_FillWithScalarFunc  *fillwithscalar;
  PyArray_SortFunc  *sort[NPY_NSORTS];
  PyArray_ArgSortFunc  *argsort[NPY_NSORTS];
  PyObject  *castdict;
  PyArray_ScalarKindFunc  *scalarkind;
  int  **cancastscalarkindto;
  int  *cancastto;
  PyArray_FastClipFunc  *fastclip;  /* deprecated */
  PyArray_FastPutmaskFunc  *fastputmask;  /* deprecated */
  PyArray_FastTakeFunc  *fasttake;  /* deprecated */
  PyArray_ArgFunc  *argmin;
}  PyArray_ArrFuncs; 
```

描述函数指针时使用了行为良好段的概念。行为良好的段是指与数据类型对齐且符合本机字节顺序的段。`nonzero`、`copyswap`、`copyswapn`、`getitem` 和 `setitem` 函数可以（必须）处理不规范的数组。其他函数则需要行为良好的内存段。

```py
void cast(void *from, void *to, n, void *fromarr, void *toarr)
```

一个函数指针数组，用于将当前类型转换为所有其他内置类型。每个函数都将由 *from* 指向的连续、对齐且未交换的缓冲区转换为由 *to* 指向的连续、对齐且未交换的缓冲区。要转换的项数由 *n* 给出，并且参数 *fromarr* 和 *toarr* 被解释为灵活数组的 PyArrayObjects 以获取 itemsize 信息。

```py
*getitem(void *data, void *arr)
```

一个函数指针，用于从由 *data* 指向的数组对象 *arr* 的单个元素返回标准 Python 对象。此函数必须能够正确处理“不规范”的（未对齐和/或交换的）数组。

```py
int setitem( *item, void *data, void *arr)
```

一个函数指针，用于将 Python 对象 *item* 设置到由 *data* 指向的数组 *arr* 中的位置。此函数处理“不规范”的数组。如果成功，返回零，否则返回负一（并设置 Python 错误）。

```py
void copyswapn(void *dest, dstride, void *src, sstride, n, int swap, void *arr)
```

```py
void copyswap(void *dest, void *src, int swap, void *arr)
```

这些成员都是指向从 *src* 复制数据到 *dest* 并在需要时交换的函数的指针。仅当为灵活数组（`NPY_STRING`、`NPY_UNICODE` 和 `NPY_VOID` ）时才使用 arr 的值（从 `arr->descr->elsize` 获取）。第二个函数复制单个值，而第一个函数则使用提供的步幅循环 n 值。这些函数可以处理不规范的 *src* 数据。如果 *src* 为 NULL，则不执行复制。如果 *swap* 为 0，则不执行字节交换。假设 *dest* 和 *src* 不重叠。如果它们重叠，则首先使用 `memmove`（…）再使用值为 NULL 的 `src` 执行 `copyswap(n)`。

```py
int compare(const void *d1, const void *d2, void *arr)
```

一个函数指针，用于比较由 `d1` 和 `d2` 指向的数组 `arr` 的两个元素。此函数需要行为良好（对齐且未交换）的数组。如果 * `d1` > * `d2`，返回值为 1；如果 * `d1` == * `d2`，返回值为 0；如果 * `d1` < * `d2`，返回值为 -1。数组对象 `arr` 用于检索灵活数组的 itemsize 和字段信息。

```py
int argmax(void *data, n, *max_ind, void *arr)
```

一个函数指针，用于从由 *data* 指向的元素开始的 `n` 个元素中检索最大的索引。此函数要求内存段是连续且行为良好的。返回值始终为 0。最大元素的索引在 `max_ind` 中返回。

```py
void dotfunc(void *ip1, is1, void *ip2, is2, void *op, n, void *arr)
```

一个指向将两个`n`长度的序列相乘，相加，并将结果放置到由`op`指向的`arr`元素中的函数的指针。序列的开始分别由`ip1`和`ip2`指向。要获取每个序列中的下一个元素需要跳过`is1`和`is2` *字节*。此函数需要表现良好的（尽管不一定是连续的）内存。

```py
int scanfunc(FILE *fd, void *ip, void *arr)
```

一个指向从文件描述符`fd`中扫描（类似于 scanf）相应类型的元素到由`ip`指向的数组内存中的函数的指针。假定数组表现良好。最后一个参数`arr`是要扫描的数组。返回成功分配的接收参数的数量（如果在分配第一个接收参数之前匹配失败，则可能为零），或者如果在分配第一个接收参数之前发生输入故障，则为 EOF。调用此函数时应该不持有 Python GIL，并且必须为错误报告抓取它。

```py
int fromstr(char *str, void *ip, char **endptr, void *arr)
```

一个指向将`str`指向的字符串转换为相应类型的一个元素并将其放置到由`ip`指向的内存位置的函数的指针。转换完成后，`*endptr`指向字符串的其余部分。最后一个参数`arr`是 ip 指向的数组（需要用于变量大小数据类型）。成功返回 0，失败返回-1。需要一个表现良好的数组。调用此函数时应该不持有 Python GIL，并且必须为错误报告抓取它。

```py
nonzero(void *data, void *arr)
```

一个指向如果`data`指向的`arr`的项为非零则返回 TRUE 的函数的指针。此函数可以处理行为不当的数组。

```py
void fill(void *data, length, void *arr)
```

一个指向填充给定长度的连续数组数据的函数的指针。数组的前两个元素必须已经被填充。根据这两个值，将计算出一个增量，然后从第 3 个元素到最后的值将通过重复添加这个计算出的增量来计算。数据缓冲区必须表现良好。

```py
void fillwithscalar(void *buffer, length, void *value, void *arr)
```

一个指向使用单个标量`value`的地址填充给定`长度`的连续`buffer`的函数的指针。最后一个参数是所需用于变长数组的 itemsize 的数组。

```py
int sort(void *start, length, void *arr)
```

一个指向特定排序算法的函数指针数组。可以使用一个关键字（到目前为止定义了`NPY_QUICKSORT`、`NPY_HEAPSORT`和`NPY_MERGESORT`）。这些排序是在假定连续和对齐的数据上进行的。

```py
int argsort(void *start, *result, length, void *arr)
```

一个指向此数据类型的排序算法的函数指针数组。可用于排序的排序算法与 sort 相同。产生排序的索引被返回到`result`中（必须初始化为包含 0 到`length-1`的索引）。

```py
*castdict
```

可以是`NULL`或包含用户定义数据类型的低级转换函数的字典。每个函数都包装在一个[PyCapsule](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11)")*中，并以数据类型编号为键。

```py
scalarkind( *arr)
```

用于确定此类型的标量应如何解释的函数。参数是一个包含数据的 0 维数组（如果需要确定标量的种类，则需要该数据）。返回值必须是类型为`NPY_SCALARKIND`的值。

```py
int **cancastscalarkindto
```

可以是`NULL`或一个包含`NPY_NSCALARKINDS`指针的数组。这些指针每个都应该是`NULL`，或者是指向整数数组的指针（以`NPY_NOTYPE`终止），指示此数据类型的指定种类的标量可以安全地转换为的数据类型（通常意味着不会失去精度）。

```py
int *cancastto
```

可以是`NULL`或一个整数数组（以`NPY_NOTYPE`终止），指示此数据类型可以安全地转换为的数据类型（通常意味着不会失去精度）。

```py
void fastclip(void *in, n_in, void *min, void *max, void *out)
```

自版本 1.17 起弃用：使用此函数将在`np.clip`时产生弃用警告。不再使用此函数，数据类型必须使用`PyUFunc_RegisterLoopForDescr`将自定义循环附加到`np.core.umath.clip`、`np.minimum`和`np.maximum`。

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

从`in`中读取`n_in`项，并在其指向的限制范围内写入到`out`，如果超出范围，则写入相应的限制值。内存段必须是连续的且行为良好，`min`和`max`中的一个可以是`NULL`，但不能同时为空。

```py
void fastputmask(void *in, void *mask, n_in, void *values, nv)
```

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

一个函数，它接受一个指向长度为`n_in`项的数组的指针`in`，一个指向长度为`n_in`的布尔值数组的指针`mask`，以及一个指向长度为`nv`项的数组的指针`vals`。将`vals`中的项复制到`in`中，其中`mask`中的值为非零，如果`nv < n_in`，则根据需要平铺`vals`。所有数组必须是连续的且行为良好。

```py
void fasttake(void *dest, void *src, *indarray, nindarray, n_outer, m_middle, nelem, clipmode)
```

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

一个函数，它接受一个指针`src`，指向一个 C 连续的、行为良好的段，解释为形状为`(n_outer, nindarray, nelem)`的三维数组，一个指向`m_middle`整数索引的 C 连续的、行为良好的段的指针`indarray`，以及一个指向 C 连续的、行为良好的段的指针`dest`，解释为形状为`(n_outer, m_middle, nelem)`的三维数组。`indarray` 中的索引用于沿第二维索引`src`，并将对应的`nelem`项的块复制到`dest`中。`clipmode`（可以取值`NPY_RAISE`、`NPY_WRAP` 或 `NPY_CLIP`）确定如何处理小于 0 或大于`nindarray`的索引。

```py
int argmin(void *data, n, *min_ind, void *arr)
```

一个函数指针，用于检索从`data`指向的元素开始的包含`n`个元素的`arr`中最小元素的索引。此函数要求内存段是连续的且行为良好。返回值始终为 0。最小元素的索引将返回到`min_ind`中。

`PyArray_Type` 类型对象实现了许多[`Python 对象`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "(在 Python v3.11)")的特性，包括[`tp_as_number`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_number "(在 Python v3.11)")、[`tp_as_sequence`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence "(在 Python v3.11)")、[`tp_as_mapping`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping "(在 Python v3.11)") 和[`tp_as_buffer`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer "(在 Python v3.11)") 接口。[`富比较`](https://docs.python.org/3/c-api/typeobj.html#c.richcmpfunc "(在 Python v3.11)") 也与新式属性查找一起使用，用于成员（[`tp_members`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_members "(在 Python v3.11)")）和属性（[`tp_getset`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset "(在 Python v3.11)")）的访问。`PyArray_Type` 也可以被子类型化。

提示

`tp_as_number` 方法使用一种通用方法调用已注册用于处理操作的任何函数。当导入`_multiarray_umath 模块`时，它将所有数组的数值操作设置为相应的 ufuncs。可以使用`PyUFunc_ReplaceLoopBySignature` 来更改此选择。`tp_str` 和 `tp_repr` 方法也可以使用`PyArray_SetStringFunction` 进行更改。

### PyUFunc_Type 和 PyUFuncObject

```py
PyUFunc_Type
```

ufunc 对象是通过创建`PyUFunc_Type`来实现的。 它是一种非常简单的类型，只实现了基本的 getAttribute 行为、打印行为，并且有 call 行为，这样这些对象就可以像函数一样。 ufunc 的基本思想是保存对支持操作的数据类型的快速 1 维（向量）循环的引用。 所有这些一维循环都具有相同的签名，并且是创建新 ufunc 的关键。 它们由通用循环代码适当调用以实现 N 维函数。 还为浮点和复数浮点数组定义了一些通用的一维循环，允许你使用单个标量函数（*例如*atanh）来定义 ufunc。

```py
type PyUFuncObject
```

ufunc 的核心是`PyUFuncObject`，其中包含调用执行实际工作的基础 C 代码循环所需的所有信息。 虽然这里描述了这一点以确保兼容性： *infotext* *default*可以在不同的 NumPy 版本中更改。 为了确保兼容性。

+   绝不声明结构的非指针实例

+   永远不要执行指针算术

+   永远不要使用`sizeof(PyUFuncObject)`

它具有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  int  nin;
  int  nout;
  int  nargs;
  int  identity;
  PyUFuncGenericFunction  *functions;
  void  **data;
  int  ntypes;
  int  reserved1;
  const  char  *name;
  char  *types;
  const  char  *doc;
  void  *ptr;
  PyObject  *obj;
  PyObject  *userloops;
  int  core_enabled;
  int  core_num_dim_ix;
  int  *core_num_dims;
  int  *core_dim_ixs;
  int  *core_offsets;
  char  *core_signature;
  PyUFunc_TypeResolutionFunc  *type_resolver;
  PyUFunc_LegacyInnerLoopSelectionFunc  *legacy_inner_loop_selector;
  void  *reserved2;
  npy_uint32  *op_flags;
  npy_uint32  *iter_flags;
  /* new in API version 0x0000000D */
  npy_intp  *core_dim_sizes;
  npy_uint32  *core_dim_flags;
  PyObject  *identity_value;
  /* Further private slots (size depends on the NumPy version) */
}  PyUFuncObject; 
```

```py
int nin
```

输入参数的数量。

```py
int nout
```

输出参数的数量。

```py
int nargs
```

参数的总数（* nin * + * nout *）。 这必须小于`NPY_MAXARGS`。

```py
int identity
```

`PyUFunc_One`，`PyUFunc_Zero`，`PyUFunc_MinusOne`，`PyUFunc_None`，`PyUFunc_ReorderableNone`或`PyUFunc_IdentityValue`中的任何一个，以指示此操作的标识。 仅用于对空数组进行类似缩小的调用。

```py
void functions(char **args, *dims, *steps, void *extradata)
```

一个函数指针数组 - 每种 ufunc 支持的数据类型一个。 这是被调用以实现基础功能*dims*[0]次的向量循环。 第一个参数*args*是一个* nargs *指针的数组，指向行为良好的内存。 首先是输入参数数据的指针，然后是输出参数数据的指针。 必须跳过多少字节才能到达序列中下一个元素由* steps *数组中的对应条目指定。 最后一个参数允许循环接收额外信息。 通常用于使单个通用向量循环用于多个函数。 在这种情况下，要调用的实际标量函数被传递为* extradata *。 这个函数指针数组的大小是 ntypes。

```py
void **data
```

要传递给 1-d 向量循环的额外数据，如果不需要额外数据则为`NULL`。这个 C 数组必须与函数数组的大小相同（*即* ntypes）。如果不需要额外数据，则使用`NULL`。几个用于 UFuncs 的 C API 调用只是利用这些额外数据运行 1-d 向量循环，以接收指向要调用的实际函数的指针。

```py
int ntypes
```

ufunc 支持的数据类型数。这个数字指定可用的不同 1-d 循环（内置数据类型）的数量。

```py
int reserved1
```

未使用。

```py
char *name
```

为 ufunc 的字符串名称。这是动态使用的，用于构建 ufunc 的 __doc__ 属性。

```py
char *types
```

一个 \(nargs \times ntypes\) 8 位类型编号数组，包含每个支持（内置）数据类型的函数的类型签名。对于每个 *ntypes* 函数，该数组中对应的一组类型编号显示了如何在 1-d 向量循环中解释 *args* 参数。这些类型编号不必是相同类型，支持混合类型的 ufunc。

```py
char *doc
```

用于 ufunc 的文档。不应包含函数签名，因为在检索 __doc__ 时动态生成。

```py
void *ptr
```

任何动态分配的内存。目前，这用于从 Python 函数创建动态 ufunc，用于存储类型、数据和名称成员的空间。

```py
*obj
```

对于从 Python 函数动态创建的 ufunc，该成员持有对底层 Python 函数的引用。

```py
*userloops
```

用户定义的 1-d 向量循环的字典（存储为 CObject 指针）用于用户定义的类型。用户可以为任何用户定义的类型注册循环。它通过类型编号检索。用户定义的类型编号总是大于`NPY_USERDEF`。

```py
int core_enabled
```

标量 ufunc 为 0；广义 ufunc 为 1

```py
int core_num_dim_ix
```

签名中具有不同核心维度名称的数量

```py
int *core_num_dims
```

每个参数的核心维度数

```py
int *core_dim_ixs
```

展平形式的维度索引；参数`k`的索引存储在`core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]`中

```py
int *core_offsets
```

每个参数在`core_dim_ixs`中第 1 个核心维度的位置，相当于 cumsum(`core_num_dims`)

```py
char *core_signature
```

核心签名字符串

```py
PyUFunc_TypeResolutionFunc *type_resolver
```

解析类型并填充输入和输出的 dtypes 的函数

```py
PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector
```

从版本 1.22 起弃用：此插槽存在一些回退支持，但最终将被移除。依赖于此的通用函数最终将需要移植。请参阅[NEP 41](https://numpy.org/neps/nep-0041-improved-dtype-support.html#nep41 "(in NumPy Enhancement Proposals)") 和 [NEP 43](https://numpy.org/neps/nep-0043-extensible-ufuncs.html#nep43 "(in NumPy Enhancement Proposals)")

```py
void *reserved2
```

用于可能的具有不同签名的未来循环选择器。

```py
op_flags
```

为每个 ufunc 操作数覆盖默认操作数标志。

```py
iter_flags
```

为 ufunc 覆盖默认 nditer 标志。

添加在 API 版本 0x0000000D 中

```py
*core_dim_sizes
```

对于每个不同的核心维度，如果 `UFUNC_CORE_DIM_SIZE_INFERRED` 为 `0`，则可能的 frozen 大小

```py
*core_dim_flags
```

对于每个不同的核心维度，一组标志（`UFUNC_CORE_DIM_CAN_IGNORE` 和 `UFUNC_CORE_DIM_SIZE_INFERRED`）

```py
*identity_value
```

缩减的标识，当 `PyUFuncObject.identity` 等于 `PyUFunc_IdentityValue` 时。

```py
UFUNC_CORE_DIM_CAN_IGNORE
```

如果维度名称以 `?` 结尾

```py
UFUNC_CORE_DIM_SIZE_INFERRED
```

如果维度大小将由操作数而不是从 frozen 签名确定

### PyArrayIter_Type 和 PyArrayIterObject

```py
PyArrayIter_Type
```

这是一个迭代器对象，使得可以轻松地循环遍历 N 维数组。它是从 ndarray 的 flat 属性返回的对象。它还在整个实现内部广泛使用，以循环遍历 N 维数组。实现了 tp_as_mapping 接口，以便可以索引迭代器对象（使用 1-d 索引），并且通过 tp_methods 表实现了一些方法。此对象实现了 next 方法，并且可以在 Python 中使用任何迭代器可以使用的地方。

```py
type PyArrayIterObject
```

与 `PyArrayIter_Type` 对象对应的 C 结构是 `PyArrayIterObject`。 `PyArrayIterObject` 用于跟踪指向 N 维数组的指针。它包含用于快速遍历数组的相关信息。指针可以通过三种基本方式进行调整：1）以 C 风格连续地前进到数组中的“下一个”位置，2）前进到数组中的任意 N 维坐标，和 3）前进到数组中的任意一维索引。`PyArrayIterObject` 结构的成员在这些计算中使用。迭代器对象保存关于数组的自己的维度和跨度信息。这可以根据需要进行“广播”，或者仅循环特定维度。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index;
  npy_intp  size;
  npy_intp  coordinates[NPY_MAXDIMS];
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
}  PyArrayIterObject; 
```

```py
int nd_m1
```

\(N-1\) 其中 \(N\) 是底层数组中的维数。

```py
index
```

数组中的当前 1-d 索引。

```py
size
```

底层数组的总大小。

```py
*coordinates
```

对数组的 \(N\) 维索引。

```py
*dims_m1
```

数组在每个维度上的大小减去 1。

```py
*strides
```

数组的跨度。在每个维度跳转到下一个元素所需的字节数。

```py
*backstrides
```

从维度的末尾跳回到其开头所需的字节数。请注意 `backstrides[k] == strides[k] * dims_m1[k]`，但这里存储为一种优化。

```py
*factors
```

此数组用于从 1-d 索引计算 N-d 索引。它包含维度的所需乘积。

```py
*ao
```

指向创建此迭代器代表的底层 ndarray 的指针。

```py
char *dataptr
```

此成员指向由索引指示的 ndarray 中的元素。

```py
contiguous
```

若底层数组是 `NPY_ARRAY_C_CONTIGUOUS`，则此标志为真。在可能的情况下，可用于简化计算。

如何在 C 级别上使用数组迭代器在后续章节中有更详细的解释。通常，您无需关心迭代器对象的内部结构，只需通过宏 `PyArray_ITER_NEXT` (it)、`PyArray_ITER_GOTO` (it, dest) 或 `PyArray_ITER_GOTO1D` (it, index) 与其进行交互。所有这些宏都需要参数 *it* 为 PyArrayIterObject*。

### PyArrayMultiIter_Type 和 PyArrayMultiIterObject

```py
PyArrayMultiIter_Type
```

该类型提供了一种封装广播概念的迭代器。它允许 \(N\) 个数组一起进行广播，使循环以 C 样式连续方式在广播的数组上进行。相应的 C 结构是 `PyArrayMultiIterObject`，其内存布局必须以传递给 `PyArray_Broadcast` (obj) 函数的任何对象 *obj* 开始。通过调整数组迭代器来执行广播，使得每个迭代器表示广播的形状和大小，但其步长被调整，以便在每次迭代中使用数组的正确元素。

```py
type PyArrayMultiIterObject
```

```py
typedef  struct  {
  PyObject_HEAD
  int  numiter;
  npy_intp  size;
  npy_intp  index;
  int  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject  *iters[NPY_MAXDIMS];
}  PyArrayMultiIterObject; 
```

```py
int numiter
```

需要广播到相同形状的数组的数量。

```py
size
```

总的广播大小。

```py
index
```

当前（1-d）索引进入广播结果。

```py
int nd
```

广播结果中的维数。

```py
*dimensions
```

广播结果的形状（仅使用 `nd` 槽）。

```py
**iters
```

一个迭代器对象数组，其中包含要一起广播的数组的迭代器。返回时，迭代器会进行调整以进行广播。

### PyArrayNeighborhoodIter_Type 和 PyArrayNeighborhoodIterObject

```py
PyArrayNeighborhoodIter_Type
```

这是一个迭代器对象，可轻松循环遍历 N 维邻域。

```py
type PyArrayNeighborhoodIterObject
```

与 `PyArrayNeighborhoodIter_Type` 对象对应的 C 结构是 `PyArrayNeighborhoodIterObject`。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index,  size;
  npy_intp  coordinates[NPY_MAXDIMS]
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
  npy_intp  bounds[NPY_MAXDIMS][2];
  npy_intp  limits[NPY_MAXDIMS][2];
  npy_intp  limits_sizes[NPY_MAXDIMS];
  npy_iter_get_dataptr_t  translate;
  npy_intp  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject*  _internal_iter;
  char*  constant;
  int  mode;
}  PyArrayNeighborhoodIterObject; 
```

### PyArrayFlags_Type 和 PyArrayFlagsObject

```py
PyArrayFlags_Type
```

当从 Python 中检索 flags 属性时，将构建此特殊内置对象的特殊类型。这种特殊类型通过将它们作为属性访问或通过将对象视为具有标志名称条目的字典来访问它们，使得更容易处理不同的标志。

```py
type PyArrayFlagsObject
```

```py
typedef  struct  PyArrayFlagsObject  {
  PyObject_HEAD
  PyObject  *arr;
  int  flags;
}  PyArrayFlagsObject; 
```

### ScalarArrayTypes

每种内置数据类型在 Python 中都有一个类型。这些大多是简单的包装器，用于对应 C 中的相应数据类型。这些类型的 C 名称为`Py{TYPE}ArrType_Type`，其中`{TYPE}`可以是

> **Bool**，**Byte**，**Short**，**Int**，**Long**，**LongLong**，**UByte**，**UShort**，**UInt**，**ULong**，**ULongLong**，**Half**，**Float**，**Double**，**LongDouble**，**CFloat**，**CDouble**，**CLongDouble**，**String**，**Unicode**，**Void**和**Object**。

这些类型名称是 C-API 的一部分，因此可以在扩展的 C 代码中创建。还有一个`PyIntpArrType_Type`和一个`PyUIntpArrType_Type`，它们是平台上可以容纳指针的整数类型之一的简单替代品。这些标量对象的结构对 C 代码不可见。函数`PyArray_ScalarAsCtype`（..）可以用于从数组标量中提取 C 类型值，函数`PyArray_Scalar`（…）可以用于从 C 值构造数组标量。

## 其他 C-结构

开发 NumPy 时发现有几个新的 C-结构很有用。这些 C 结构至少在一个 C-API 调用中使用，因此在这里记录。定义这些结构的主要原因是为了方便使用 Python ParseTuple C-API，将 Python 对象转换为有用的 C 对象。

### PyArray_Dims

```py
type PyArray_Dims
```

当形状和/或步幅信息被解释时，这个结构非常有用。结构如下：

```py
typedef  struct  {
  npy_intp  *ptr;
  int  len;
}  PyArray_Dims; 
```

这个结构体的成员是

```py
*ptr
```

一个指向(`npy_intp`)整数列表的指针，通常表示数组形状或数组步幅。

```py
int len
```

整数列表的长度。假定安全访问*ptr*[0]至*ptr*[len-1]。

### PyArray_Chunk

```py
type PyArray_Chunk
```

这与 Python 中的缓冲对象结构相当，直到 ptr 成员。在 32 位平台上（*即*如果`NPY_SIZEOF_INT` == `NPY_SIZEOF_INTP`），len 成员也与缓冲对象的等效成员匹配。它用于表示通用的单段内存块。

```py
typedef  struct  {
  PyObject_HEAD
  PyObject  *base;
  void  *ptr;
  npy_intp  len;
  int  flags;
}  PyArray_Chunk; 
```

成员是

```py
*base
```

此内存块来自的 Python 对象。需要这样才能正确地计算内存。

```py
void *ptr
```

单段内存块开始的指针。

```py
len
```

段的长度（以字节为单位）。

```py
int flags
```

用来解释内存的任何数据标志（*例如* `NPY_ARRAY_WRITEABLE`）。

### PyArrayInterface

另请参阅

数组接口协议

```py
type PyArrayInterface
```

`PyArrayInterface` 结构被定义为 NumPy 和其他扩展模块可以使用快速的数组接口协议。支持快速数组接口协议的对象的`__array_struct__`方法应该返回一个包含指向`PyArrayInterface`结构的相关细节的指针的[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(在 Python v3.11)")。创建新数组后，应该对属性执行`DECREF`，这将释放`PyArrayInterface`结构。记得对检索到的`__array_struct__`属性的对象进行`INCREF`，并将新的`PyArrayObject`的 base 成员指向这个相同的对象。以这种方式管理数组的内存将是正确的。

```py
typedef  struct  {
  int  two;
  int  nd;
  char  typekind;
  int  itemsize;
  int  flags;
  npy_intp  *shape;
  npy_intp  *strides;
  void  *data;
  PyObject  *descr;
}  PyArrayInterface; 
```

```py
int two
```

整数 2 作为一个健全性检查。

```py
int nd
```

数组中的维数。

```py
char typekind
```

根据类型字符串约定，指示存在何种类型数组的字符，‘t’ -> 位域，‘b’ -> 布尔值，‘i’ -> 有符号整数，‘u’ -> 无符号整数，‘f’ -> 浮点数，‘c’ -> 复数浮点数，‘O’ -> 对象，‘S’ -> （字节）字符串，‘U’ -> Unicode，‘V’ -> 空。

```py
int itemsize
```

数组中每个项需要的字节数。

```py
int flags
```

位`NPY_ARRAY_C_CONTIGUOUS` (1), `NPY_ARRAY_F_CONTIGUOUS` (2), `NPY_ARRAY_ALIGNED` (0x100), `NPY_ARRAY_NOTSWAPPED` (0x200)，或`NPY_ARRAY_WRITEABLE` (0x400)，指示有关数据的一些信息。`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_C_CONTIGUOUS`和`NPY_ARRAY_F_CONTIGUOUS`标志实际上可以从其他参数中确定。标志`NPY_ARR_HAS_DESCR` (0x800)也可以设置为指示给消耗版本 3 数组接口的对象，这个结构的 descr 成员是存在的（对消耗版本 2 数组接口的对象会被忽略）。

```py
*shape
```

包含每个维度中数组大小的数组。

```py
*strides
```

包含每个维度中移动到下一个元素所需的字节数的数组。

```py
void *data
```

数组的第一个元素的指针。

```py
*descr
```

更详细描述数据类型的 Python 对象（与`__array_interface__`中的*descr*键相同）。如果*typekind*和*itemsize*提供足够信息，则这可以是`NULL`。除非*flags*中打开了 `NPY_ARR_HAS_DESCR` 标志，否则也会忽略此字段。

### 内部使用的结构

内部，代码使用一些额外的 Python 对象主要用于内存管理。这些类型无法直接从 Python 访问，也不暴露给 C-API。它们在这里仅用于完整性和帮助理解代码。

```py
type PyUFunc_Loop1d
```

一个包含为每个用户定义的数据类型的每个已定义签名定义 1-d 循环的信息的 C-结构的简单链接列表。

```py
PyArrayMapIter_Type
```

高级索引由这种 Python 类型处理。它只是包装了包含高级数组索引所需变量的 C 结构的松散包装。

```py
type PyArrayMapIterObject
```

与`PyArrayMapIter_Type`相关联的 C 结构。如果您试图理解高级索引映射代码，这个结构很有用。它在`arrayobject.h`头文件中定义。这种类型不暴露给 Python，可以用 C 结构替换。作为 Python 类型，它利用了引用计数内存管理。

## 定义的新 Python 类型

Python 类型相当于 Python 中的类。通过构建一个新的 Python 类型，您可以为 Python 提供一个新对象。`ndarray`对象就是在 C 中定义的一个新类型的示例。定义新类型的基本步骤是：

1.  创建一个与[`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)")结构本身二进制兼容但包含特定对象所需的附加信息的 C 结构（通常命名为`Py{Name}Object`）;

1.  填充[`PyTypeObject`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "(in Python v3.11")表（由[`PyObject`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)")结构的 ob_type 成员指向的）：指向实现该类型所需行为的函数的指针。

而不是为 Python 类定义行为的特殊方法名称，有指向实现所需结果的功能表。自 Python 2.2 以来，`PyTypeObject`本身已经变得动态，允许在 C 中“从其他 C 类型”继承的 C 类型，“在 Python 中子类化”。子类型从其父类型继承属性和方法。

有两个主要的新类型：`ndarray`（ `PyArray_Type` ）和`ufunc`（ `PyUFunc_Type` ）。其他类型起辅助作用：`PyArrayIter_Type`，`PyArrayMultiIter_Type`和`PyArrayDescr_Type`。`PyArrayIter_Type`是`ndarray`的平坦迭代器类型（在获取 flat 属性时返回的对象）。`PyArrayMultiIter_Type`是调用`broadcast`()时返回的对象类型。它处理迭代和广播集合的嵌套序列。另外，`PyArrayDescr_Type`是数据类型描述符类型，其实例描述数据。最后，还有 21 种新的标量数组类型，这些是对应于数组的可用基本数据类型的新 Python 标量。另外还有 10 种其他类型，这些是占位符，允许数组标量适应实际 Python 类型的层次结构。

### `PyArray_Type`和`PyArrayObject`

```py
PyArray_Type
```

`ndarray`的 Python 类型是`PyArray_Type`。在 C 中，每个`ndarray`都是指向`PyArrayObject`结构体的指针。该结构体的`ob_type`成员包含一个指向`PyArray_Type`类型对象的指针。

```py
type PyArrayObject
```

```py
type NPY_AO
```

`PyArrayObject` C 结构体包含数组的所有必需信息。所有`ndarray`实例（及其子类）都将具有此结构。为了将来的兼容性，应使用提供的宏来访问这些结构成员。如果需要更短的名称，可以使用`NPY_AO`（已弃用），其定义等同于`PyArrayObject`。已弃用直接访问结构字段。请改为使用`PyArray_*(arr)`形式。从 NumPy 1.20 开始，这个结构的大小不被视为 NumPy ABI 的一部分（请参见成员列表末尾的说明）。

```py
typedef  struct  PyArrayObject  {
  PyObject_HEAD
  char  *data;
  int  nd;
  npy_intp  *dimensions;
  npy_intp  *strides;
  PyObject  *base;
  PyArray_Descr  *descr;
  int  flags;
  PyObject  *weakreflist;
  /* version dependent private members */
}  PyArrayObject; 
```

```py
PyObject_HEAD
```

这对所有 Python 对象都是必需的。它由（至少）一个引用计数成员（`ob_refcnt`）和一个指向类型对象（`ob_type`）的指针组成。（如果 Python 是使用特殊选项编译的，可能还有其他元素，请参见 Python 源代码树中的 Include/object.h 了解更多信息）。ob_type 成员指向 Python 类型对象。

```py
char *data
```

可通过`PyArray_DATA`访问，此数据成员是数组的第一个元素的指针。这个指针可以（通常应该）重塑为数组的数据类型。

```py
int nd
```

一个整数，提供此数组的维度数量。当 nd 为 0 时，该数组有时被称为 0 阶数组。这样的数组具有未定义的维度和跨度，无法访问。宏 `PyArray_NDIM` 在 `ndarraytypes.h` 中定义，指向这个数据成员。`NPY_MAXDIMS` 是任何数组的最大维度数量。

```py
*dimensions
```

一个整数数组，为每个维度提供每个维度的形状，只要 nd \(\geq\) 1。整数总是足够大以容纳平台上的指针，因此维度大小仅受内存限制。`PyArray_DIMS` 是与这个数据成员相关联的宏。

```py
*strides
```

一个整数数组，为每个维度提供跳过的字节数，以便在该维度中到达下一个元素。与宏 `PyArray_STRIDES` 相关联。

```py
*base
```

由 `PyArray_BASE` 指向，这个成员用于保存与该数组相关的另一个 Python 对象的指针。有两种用例：

+   如果这个数组不拥有自己的内存，那么 base 指向拥有它的 Python 对象（也许是另一个数组对象）。

+   如果这个数组设置了 `NPY_ARRAY_WRITEBACKIFCOPY` 标志，那么这个数组是一个“行为异常”的数组的工作副本。

当调用 `PyArray_ResolveWritebackIfCopy` 时，将使用该数组的内容更新由 base 指向的数组。

```py
*descr
```

一个指向数据类型描述对象的指针（参见下文）。数据类型描述对象是一个新的内置类型的实例，它允许对内存进行通用描述。每种支持的数据类型都有一个描述结构体。这个描述结构体包含有关该类型的有用信息，以及指向实现特定功能的函数指针表的指针。顾名思义，它与宏 `PyArray_DESCR` 相关联。

```py
int flags
```

由宏 `PyArray_FLAGS` 指向，这个数据成员表示数据指向的内存应该如何解释的标志。可能的标志有 `NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_OWNDATA`、`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_WRITEABLE`、`NPY_ARRAY_WRITEBACKIFCOPY`。

```py
*weakreflist
```

这个成员允许数组对象具有弱引用（使用 weakref 模块）。

注意

进一步的成员被视为私有和版本相关。如果结构的大小对您的代码很重要，必须特别小心。当这是相关的可能使用案例是在 C 中进行子类化。如果您的代码依赖于`sizeof(PyArrayObject)`是恒定的，您必须在导入时添加以下检查：

```py
if  (sizeof(PyArrayObject)  <  PyArray_Type.tp_basicsize)  {
  PyErr_SetString(PyExc_ImportError,
  "Binary incompatibility with NumPy, must recompile/update X.");
  return  NULL;
} 
```

要确保您的代码不必针对特定的 NumPy 版本进行编译，可以添加一个常量，为 NumPy 中的变化留出空间。 确保兼容任何未来的 NumPy 版本的解决方案需要运行时计算偏移量和分配大小。

### PyArrayDescr_Type 和 PyArray_Descr

```py
PyArrayDescr_Type
```

`PyArrayDescr_Type` 是用于描述组成数组的字节该如何解释的数据类型描述符对象的内置类型。有 21 个静态定义的`PyArray_Descr`对象用于内置数据类型。尽管这些参与引用计数，但它们的引用计数永远不应该为零。还维护了一个动态的用户定义的`PyArray_Descr`对象表。一旦“注册”了数据类型描述符对象，就不应该将其释放。函数`PyArray_DescrFromType` (…)可以用于从枚举类型号（内置或用户定义的）中检索`PyArray_Descr`对象。

```py
type PyArray_Descr
```

`PyArray_Descr` 结构位于`PyArrayDescr_Type`的核心。虽然此处为完整起见进行了描述，但应将其视为 NumPy 的内部结构，并通过`PyArrayDescr_*`或`PyDataType*`函数和宏来操作。此结构的大小可能会随 NumPy 的不同版本而发生变化。为确保兼容性：

+   永远不要声明结构的非指针实例

+   永远不要执行指针算术运算

+   永远不要使用`sizeof(PyArray_Descr)`

它有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  PyTypeObject  *typeobj;
  char  kind;
  char  type;
  char  byteorder;
  char  flags;
  int  type_num;
  int  elsize;
  int  alignment;
  PyArray_ArrayDescr  *subarray;
  PyObject  *fields;
  PyObject  *names;
  PyArray_ArrFuncs  *f;
  PyObject  *metadata;
  NpyAuxData  *c_metadata;
  npy_hash_t  hash;
}  PyArray_Descr; 
```

```py
*typeobj
```

指向对应于此数组元素的 Python 类型的类型对象的指针。 对于内置类型，这指向对应的数组标量。 对于用户定义的类型，这应指向用户定义的类型对象。 这个类型对象可以继承自数组标量，也可以不继承。 如果它不继承自数组标量，那么`flags`成员中应该设置`NPY_USE_GETITEM`和`NPY_USE_SETITEM`标志。

```py
char kind
```

表示数组种类的字符代码（使用数组接口类型字符串表示法）。 'b'代表布尔值，'i'代表有符号整数，'u'代表无符号整数，'f'代表浮点数，'c'代表复数浮点数，'S'代表 8 位零终止字节，'U'代表 32 位/字符的 unicode 字符串，'V'代表任意长度。

```py
char type
```

传统的字符代码，表示数据类型。

```py
char byteorder
```

一个表示字节顺序的字符：‘>’（大端），‘<’（小端），‘=’（本机），‘|’（无关，忽略）。所有内置数据类型都具有字节顺序‘=’。

```py
char flags
```

一个确定数据类型是否展示类似对象数组的行为的数据类型位标志。这个成员中的每个位是一个标志，它们被命名为：

+   `NPY_ITEM_REFCOUNT`

+   `NPY_ITEM_HASOBJECT`

+   `NPY_LIST_PICKLE`

+   `NPY_ITEM_IS_POINTER`

+   `NPY_NEEDS_INIT`

+   `NPY_NEEDS_PYAPI`

+   `NPY_USE_GETITEM`

+   `NPY_USE_SETITEM`

+   `NPY_FROM_FIELDS`

+   `NPY_OBJECT_DTYPE_FLAGS`

```py
int type_num
```

一个唯一标识数据类型的数字。对于新数据类型，当数据类型被注册时，分配这个数字。

```py
int elsize
```

对于始终相同大小的数据类型（例如 long），这个成员保存数据类型的大小。对于灵活的数据类型，不同的数组可能具有不同的元素大小，这个值应该为 0。

```py
int alignment
```

提供这个数据类型的对齐信息的数字。具体来说，它显示编译器在一个 2 元结构的开始处（其第一个元素是一个`char`）放置该类型的项的距离：`offsetof(struct {char c; type v;}, v)`

```py
*subarray
```

如果这是非`NULL`，那么这个数据类型描述符是另一个数据类型描述符的 C 风格连续数组。换句话说，这个描述符描述的每个元素实际上是另一个基本描述符的数组。这对于作为另一个数据类型描述符中字段的数据类型描述符最有用。如果这个非`NULL`，则 fields 成员应该为`NULL`（但是 base 描述符的 fields 成员可以为非`NULL`）。

```py
type PyArray_ArrayDescr
```

```py
typedef  struct  {
  PyArray_Descr  *base;
  PyObject  *shape;
}  PyArray_ArrayDescr; 
```

```py
*base
```

基本类型的数据类型描述符对象。

```py
*shape
```

子数组的形状（始终是 C 风格连续）作为 Python 元组。

```py
*fields
```

如果这不是 NULL，则这个数据类型描述符具有由 Python 字典描述的字段，其键是名称（如果给定也是标题），其值是描述字段的元组。请记住，数据类型描述符总是描述一组固定长度的字节。字段是该总体固定长度集合的命名子区域。字段由另一个数据类型描述符和一个字节偏移的元组描述。可选地，元组可以包含通常是 Python 字符串的标题。这些元组被放在此字典中，以名称（如果给定也是标题）为键。

```py
*names
```

字段名称的有序元组。如果未定义字段，则为 NULL。

```py
*f
```

指向包含类型需要实现内部功能的函数的结构的指针。这些函数与后面描述的通用函数（ufuncs）不同。它们的签名可以任意变化。

```py
*metadata
```

关于这个数据类型的元数据。

```py
*c_metadata
```

特定于特定 dtype 的 C 实现的元数据。添加到 NumPy 1.7.0 中。

```py
type npy_hash_t
```

```py
*hash
```

当前未使用。保留用于将来缓存哈希值。

```py
NPY_ITEM_REFCOUNT
```

表示这种数据类型的项必须进行引用计数（使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(in Python v3.11)")和[`Py_DECREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "(in Python v3.11)")）。

```py
NPY_ITEM_HASOBJECT
```

与`NPY_ITEM_REFCOUNT`相同。

```py
NPY_LIST_PICKLE
```

表示必须在将数组转储为列表之前将这种数据类型的数组转换为列表。

```py
NPY_ITEM_IS_POINTER
```

表示该项是指向其他数据类型的指针

```py
NPY_NEEDS_INIT
```

表示必须初始化此数据类型的内存（设置为 0）。

```py
NPY_NEEDS_PYAPI
```

表明此数据类型在访问时需要 Python C-API（因此，在需要数组访问时不要放弃 GIL）。

```py
NPY_USE_GETITEM
```

在数组访问时，使用`f->getitem`函数指针而不是标准的转换为数组标量。如果不定义与数据类型一起使用的数组标量，必须使用。

```py
NPY_USE_SETITEM
```

从数组标量创建一个 0-d 数组时，请使用`f->setitem`而不是标准的从数组标量复制。如果不定义与数据类型一起使用的数组标量，必须使用。

```py
NPY_FROM_FIELDS
```

如果数据类型的任何字段中设置了这些位，则从父数据类型继承的位。目前（`NPY_NEEDS_INIT` | `NPY_LIST_PICKLE` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_PYAPI`）。

```py
NPY_OBJECT_DTYPE_FLAGS
```

对象数据类型的设置位：（`NPY_LIST_PICKLE` | `NPY_USE_GETITEM` | `NPY_ITEM_IS_POINTER` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_INIT` | `NPY_NEEDS_PYAPI`）。

```py
int PyDataType_FLAGCHK( *dtype, int flags)
```

如果对于数据类型对象设置了所有给定的标志，则返回 true。

```py
int PyDataType_REFCHK( *dtype)
```

等效于`PyDataType_FLAGCHK`（*dtype*，`NPY_ITEM_REFCOUNT`）。

```py
type PyArray_ArrFuncs
```

实现内部功能的函数。并非所有这些函数指针必须对给定类型进行定义。所需成员是`nonzero`、`copyswap`、`copyswapn`、`setitem`、`getitem`和`cast`。假定这些都是非`NULL`的，而`NULL`条目将导致程序崩溃。其他函数可能是`NULL`，这意味着该数据类型的功能将减少。 （同时，如果在注册用户定义的数据类型时`NULL`，则`nonzero`函数将填充为默认函数）。

```py
typedef  struct  {
  PyArray_VectorUnaryFunc  *cast[NPY_NTYPES];
  PyArray_GetItemFunc  *getitem;
  PyArray_SetItemFunc  *setitem;
  PyArray_CopySwapNFunc  *copyswapn;
  PyArray_CopySwapFunc  *copyswap;
  PyArray_CompareFunc  *compare;
  PyArray_ArgFunc  *argmax;
  PyArray_DotFunc  *dotfunc;
  PyArray_ScanFunc  *scanfunc;
  PyArray_FromStrFunc  *fromstr;
  PyArray_NonzeroFunc  *nonzero;
  PyArray_FillFunc  *fill;
  PyArray_FillWithScalarFunc  *fillwithscalar;
  PyArray_SortFunc  *sort[NPY_NSORTS];
  PyArray_ArgSortFunc  *argsort[NPY_NSORTS];
  PyObject  *castdict;
  PyArray_ScalarKindFunc  *scalarkind;
  int  **cancastscalarkindto;
  int  *cancastto;
  PyArray_FastClipFunc  *fastclip;  /* deprecated */
  PyArray_FastPutmaskFunc  *fastputmask;  /* deprecated */
  PyArray_FastTakeFunc  *fasttake;  /* deprecated */
  PyArray_ArgFunc  *argmin;
}  PyArray_ArrFuncs; 
```

"表现正常"的概念用于描述函数指针。一个表现正常的段是指对齐且符合数据类型本机字节顺序的段。`nonzero`、`copyswap`、`copyswapn`、`getitem`和`setitem`函数可以（而且必须）处理不正常的数组。其他函数要求内存段表现正常。

```py
void cast(void *from, void *to, n, void *fromarr, void *toarr)
```

一串函数指针，用于将当前类型向所有其他内置类型转换。每个函数将一个由*from*指向的连续、对齐、未交换的缓冲区转换为一个由*to*指向的连续、对齐和未交换的缓冲区。要转换的项数由*n*给出，参数*fromarr*和*toarr*被解释为灵活数组的 PyArrayObjects 以获取 itemsize 信息。

```py
*getitem(void *data, void *arr)
```

一个指向从由*data*指向的数组对象*arr*的单个元素返回标准 Python 对象的函数的指针。这个函数必须能够正确处理“不正常”（不对齐和/或交换）的数组。

```py
int setitem( *item, void *data, void *arr)
```

一个指向将 Python 对象*item*设置到由*data*指向的数组*arr*中的函数的指针。这个函数处理“不正常的”数组。如果成功，返回值为零，否则返回一个负数（并设置一个 Python 错误）。

```py
void copyswapn(void *dest, dstride, void *src, sstride, n, int swap, void *arr)
```

```py
void copyswap(void *dest, void *src, int swap, void *arr)
```

这些成员都是指向从*src*复制数据到*dest*并在需要时进行*swap*的函数的指针。arr 的值仅用于灵活（`NPY_STRING`，`NPY_UNICODE`和`NPY_VOID`）数组（并且从`arr->descr->elsize`中获取）。第二个函数复制单个值，而第一个函数使用提供的步幅循环 n 次。这些函数可以处理不正常的*src*数据。如果*src*为 NULL，则不执行复制。如果*swap*为 0，则不进行字节交换。假定*dest*和*src*不重叠。如果它们重叠，则首先使用`memmove`（…），然后使用带有空值`src`的`copyswap(n)`。

```py
int compare(const void *d1, const void *d2, void *arr)
```

一个指向比较数组`arr`中由`d1`和`d2`指向的两个元素的函数的指针。这个函数要求数组表现正常（对齐并且没有交换）。如果* `d1` > * `d2`，返回值为 1；如果* `d1` == * `d2`，返回值为 0；如果* `d1` < * `d2`，返回值为-1。数组对象`arr`用于获取灵活数组的 itemsize 和字段信息。

```py
int argmax(void *data, n, *max_ind, void *arr)
```

一个指向从由`data`指向的元素开始的`arr`中`n`个元素中最大值的索引的函数的指针。这个函数要求内存段是连续的并且表现正常。返回值总是 0。最大元素的索引存储在`max_ind`中。

```py
void dotfunc(void *ip1, is1, void *ip2, is2, void *op, n, void *arr)
```

指向一个函数的指针，用于将两个长度为`n`的序列相乘，并将它们相加，然后将结果放在`arr`的`op`指向的元素中。两个序列的起始位置分别由`ip1`和`ip2`指向。要达到每个序列的下一个元素，需要分别跳过`is1`和`is2` *字节*。此函数需要被认为是行为良好的（尽管不一定连续）内存。

```py
int scanfunc(FILE *fd, void *ip, void *arr)
```

指向一个函数的指针，用于从文件描述符`fd`中以（scanf 风格）扫描相应类型的元素到`ip`指向的数组内存中。假定该数组是被认为是行为良好的。最后一个参数`arr`是要扫描到的数组。返回成功分配的接收参数的数量（如果在分配第一个接收参数之前发生匹配失败，这个数量可能为零），或者在分配第一个接收参数之前发生输入失败时返回 EOF。在报告错误时应该在不持有 Python GIL 的情况下调用此函数，并且会为错误报告而调用 GIL。

```py
int fromstr(char *str, void *ip, char **endptr, void *arr)
```

指向一个函数的指针，用于将由`str`指向的字符串转换为相应类型的一个元素，并将其放入`ip`指向的内存位置。转换完成后，`*endptr`指向字符串的其余部分。最后一个参数`arr`是 ip 指向的数组（对于可变大小数据类型是必需的）。成功返回 0，失败返回-1。需要一个被认为是行为良好的数组。在报告错误时应该在不持有 Python GIL 的情况下调用此函数，并且会为错误报告而调用 GIL。

```py
nonzero(void *data, void *arr)
```

指向一个函数的指针，如果`data`指向的`arr`项是非零则返回 TRUE。此函数可以处理行为不良的数组。

```py
void fill(void *data, length, void *arr)
```

指向一个函数的指针，用于用数据填充给定长度的连续数组。数组的前两个元素必须已经填充了值。从这两个值中，将计算出一个增量，并且从第 3 个到最后一个元素将会反复地加上这个计算出的增量。数据缓冲区必须是行为良好的。

```py
void fillwithscalar(void *buffer, length, void *value, void *arr)
```

指向一个函数的指针，用于使用给定的单一标量值向长度为给定`length`的连续`buffer`填充数据。最后一个参数是所需的用于变长数组获取 itemsize 的数组。

```py
int sort(void *start, length, void *arr)
```

一个指向特定排序算法的函数指针数组。使用键（到目前为止已经定义了`NPY_QUICKSORT`，`NPY_HEAPSORT`，和`NPY_MERGESORT`）可以获取特定的排序算法。这些排序是就地进行的，假定数据是连续的和对齐的。

```py
int argsort(void *start, *result, length, void *arr)
```

一个指向用于此数据类型的排序算法的函数指针数组。与 sort 相同的排序算法可用。产生排序的索引将会返回在`result`中（必须初始化为包含 0 到`length-1`的索引）。

```py
*castdict
```

要么为`NULL`，要么是包含用户定义数据类型的低级转换函数的字典。每个函数都被包装在一个[PyCapsule](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(在 Python v3.11)")*中，并由数据类型编号键入。

```py
scalarkind( *arr)
```

用于确定应如何解释此类型标量的函数。参数为`NULL`或包含数据的 0 维数组（如果需要确定标量类型）。返回值必须是`NPY_SCALARKIND`类型。

```py
int **cancastscalarkindto
```

要么为`NULL`，要么为`NPY_SCALARKINDS`指针数组。这些指针应该是`NULL`，或者指向整数数组（以`NPY_NOTYPE`结尾），表示此数据类型的标量可以安全转换为指定类型的数据类型（通常表示不会失去精度）。

```py
int *cancastto
```

要么为`NULL`，要么为整数数组（以`NPY_NOTYPE`结尾），表示此数据类型可以安全转换为的数据类型（通常表示不会失去精度）。

```py
void fastclip(void *in, n_in, void *min, void *max, void *out)
```

自版本 1.17 起弃用：使用此函数将在`np.clip`时产生弃用警告。该数据类型必须使用`PyUFunc_RegisterLoopForDescr`来将自定义循环附加到`np.core.umath.clip`，`np.minimum`和`np.maximum`。

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

一个函数，从`in`中读取`n_in`个项目，并将读取的值写入`out`，如果在`min`和`max`指向的限制范围内，则在外部使用对应的限制。内存段必须是连续的且规范化的，并且`min`或`max`可能为`NULL`，但不能同时为`NULL`。

```py
void fastputmask(void *in, void *mask, n_in, void *values, nv)
```

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

一个函数，接受指向`n_in`个项目数组的指针`in`，指向`n_in`个布尔值的数组的指针`mask`，以及指向`nv`个项目的数组的指针`vals`。无需失去精度地将`vals`中的项复制到`in`中，只需在`mask`中的值非零时，根据需要平铺`vals`，如果`nv < n_in`。所有数组都必须是连续的且规范化的。

```py
void fasttake(void *dest, void *src, *indarray, nindarray, n_outer, m_middle, nelem, clipmode)
```

自版本 1.19 起弃用：设置此函数已被弃用，应始终为`NULL`，如果设置，将被忽略。

一个函数，它接受一个指向 C 连续、行为良好的段`src`，解释为形状为`(n_outer, nindarray, nelem)`的三维数组的指针，一个指向`m_middle`整数索引的连续的、行为良好的段`indarray`的指针，以及一个指向 C 连续、行为良好的段的指针`dest`，解释为形状为`(n_outer, m_middle, nelem)`的三维数组。`indarray`中的索引用于沿着第二维对`src`进行索引，并将相应的`nelem`项的块复制到`dest`中。`clipmode`（可以取值`NPY_RAISE`、`NPY_WRAP`或`NPY_CLIP`
```

一个指针，指向一个函数，用于检索`data`指向的开始于`arr`的`n`个元素中最小元素的索引。此函数要求内存段是连续的且行为良好。返回值始终为 0。最小元素的索引存储在`min_ind`中。

`PyArray_Type` 类型对象实现了许多[`Python 对象`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "(in Python v3.11)")的特性，包括[`tp_as_number`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_number "(in Python v3.11)")、[`tp_as_sequence`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence "(in Python v3.11)")、[`tp_as_mapping`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping "(in Python v3.11)")和[`tp_as_buffer`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer "(in Python v3.11)")接口。还使用了[`rich comparison`](https://docs.python.org/3/c-api/typeobj.html#c.richcmpfunc "(in Python v3.11)")，以及新式属性查找用于成员([`tp_members`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_members "(in Python v3.11)"))和属性([`tp_getset`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset "(in Python v3.11)"))。`PyArray_Type` 也可以被子类型化。

提示

`tp_as_number`方法使用一种通用方法来调用已注册用于处理操作的任何函数。导入`_multiarray_umath`模块时，它将为所有数组设置相应的 ufunc 数值操作。这个选择可以使用`PyUFunc_ReplaceLoopBySignature`进行更改。还可以使用`PyArray_SetStringFunction`更改`tp_str`和`tp_repr`方法。

### PyUFunc_Type 和 PyUFuncObject

```py
PyUFunc_Type
```

ufunc 对象是通过创建`PyUFunc_Type`来实现的。它是一个非常简单的类型，仅实现了基本的 getattribute 行为、打印行为，并具有调用行为，使这些对象可以像函数一样工作。ufunc 背后的基本思想是存储每种支持操作的数据类型的快速一维（向量）循环的引用. 所有这些一维循环都有相同的标识并且是创建新 ufunc 的关键。它们由通用循环代码在适当时调用以实现 N 维功能。还为浮点和复数浮点数组定义了一些通用的 1-d 循环，使您可以使用单个标量函数(*例如*atanh)来定义一个 ufunc。

```py
type PyUFuncObject
```

ufunc 的核心是`PyUFuncObject`，它包含调用执行实际工作的底层 C 代码循环所需的所有信息。虽然这里对其进行了描述以便完整，但应该将其视为 NumPy 的内部部分，并通过`PyUFunc_*`函数进行操作。该结构的大小可能会随着 NumPy 版本的更改而改变。为确保兼容性：

+   永远不要声明结构的非指针实例

+   永远不要执行指针算术

+   永远不要使用`sizeof(PyUFuncObject)`

它具有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  int  nin;
  int  nout;
  int  nargs;
  int  identity;
  PyUFuncGenericFunction  *functions;
  void  **data;
  int  ntypes;
  int  reserved1;
  const  char  *name;
  char  *types;
  const  char  *doc;
  void  *ptr;
  PyObject  *obj;
  PyObject  *userloops;
  int  core_enabled;
  int  core_num_dim_ix;
  int  *core_num_dims;
  int  *core_dim_ixs;
  int  *core_offsets;
  char  *core_signature;
  PyUFunc_TypeResolutionFunc  *type_resolver;
  PyUFunc_LegacyInnerLoopSelectionFunc  *legacy_inner_loop_selector;
  void  *reserved2;
  npy_uint32  *op_flags;
  npy_uint32  *iter_flags;
  /* new in API version 0x0000000D */
  npy_intp  *core_dim_sizes;
  npy_uint32  *core_dim_flags;
  PyObject  *identity_value;
  /* Further private slots (size depends on the NumPy version) */
}  PyUFuncObject; 
```

```py
int nin
```

输入参数的数量。

```py
int nout
```

输出参数的数量。

```py
int nargs
```

参数的总数(*nin* + *nout*)。这个必须小于`NPY_MAXARGS`。

```py
int identity
```

使用`PyUFunc_One`、`PyUFunc_Zero`、`PyUFunc_MinusOne`、`PyUFunc_None`、`PyUFunc_ReorderableNone`或`PyUFunc_IdentityValue`来指示此操作的标识。它仅在对空数组进行类似缩减的调用时使用。

```py
void functions(char **args, *dims, *steps, void *extradata)
```

一个函数指针数组，每一种数据类型都有一个。这个向量循环用于实现底层函数*dims*[0]次。第一个参数*args*是一个具有*nargs*指针的数组，指向行为良好的内存。首先是指向输入参数数据的指针，然后是指向输出参数数据的指针。必须跳过多少字节才能到达序列中的下一个元素由*steps*数组中的相应条目指定。最后一个参数允许循环接收额外的信息。这通常是为了使单个通用向量循环用于多个函数。在这种情况下，要调用的实际标量函数以*extradata*的形式传递。此函数指针数组的大小为 ntypes。

```py
void **data
```

传递给 1 维向量循环的额外数据，如果不需要额外数据，则为`NULL`。这个 C 数组的大小必须与函数数组相同（即 ntypes）。如果不需要 extra_data，则使用`NULL`。一些用于 UFuncs 的 C-API 调用只是 1 维向量循环，利用这些额外数据来接收要调用的实际函数的指针。

```py
int ntypes
```

Ufunc 支持的数据类型数。此数字指定有多少不同的 1 维循环（内置数据类型）可用。

```py
int reserved1
```

未使用。

```py
char *name
```

Ufunc 的字符串名称。这个动态用于构建 ufunc 的 __doc__ 属性。

```py
char *types
```

一个\(nargs \times ntypes\)的 8 位 type_numbers 数组，其中包含每个支持的（内置）数据类型的函数的类型签名。对于*ntypes*个函数中的每一个，该数组中相应的一组类型编号显示了如何在 1 维向量循环中解释*args*参数。这些类型编号不必是相同的类型，支持混合类型的 ufunc。

```py
char *doc
```

UFunc 的文档。不应包含函数签名，因为这在检索 __doc__ 时动态生成。

```py
void *ptr
```

任何动态分配的内存。目前，这用于从 python 函数创建的动态 ufunc 中存储类型、数据和名称成员的空间。

```py
*obj
```

对于从 python 函数动态创建的 ufunc，此成员保存对底层 Python 函数的引用。

```py
*userloops
```

用户定义的 1 维向量循环的字典（存储为 CObject ptrs），用于用户定义的类型。用户可以为任何用户定义的类型注册循环。它通过类型编号检索。用户定义的类型编号始终大于`NPY_USERDEF`。

```py
int core_enabled
```

标量 ufunc 的为 0；广义 ufunc 的为 1。

```py
int core_num_dim_ix
```

签名中的不同核心维度名称数

```py
int *core_num_dims
```

每个参数的核心维度数

```py
int *core_dim_ixs
```

展平形式的维度索引；参数`k`的索引存储在`core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]`

```py
int *core_offsets
```

每个参数在`core_dim_ixs`中的第一个核心维度的位置，相当于 cumsum(`core_num_dims`)

```py
char *core_signature
```

核心签名字符串

```py
PyUFunc_TypeResolutionFunc *type_resolver
```

解析类型并填充一个数组以获取输入和输出的 dtype 的函数

```py
PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector
```

自版本 1.22 起弃用：该插槽的一些回退支持存在，但最终将被移除。依赖于此的通用函数最终将必须进行移植。参见[NEP 41](https://numpy.org/neps/nep-0041-improved-dtype-support.html#nep41 "(in NumPy Enhancement Proposals)")和[NEP 43](https://numpy.org/neps/nep-0043-extensible-ufuncs.html#nep43 "(in NumPy Enhancement Proposals)")

```py
void *reserved2
```

对于可能的具有不同签名的未来循环选择器。

```py
op_flags
```

覆盖每个 ufunc 操作数的默认操作数标志。

```py
iter_flags
```

覆盖 ufunc 的默认 nditer 标志。

在 API 版本 0x0000000D 中添加

```py
*core_dim_sizes
```

对于每个不同的核心维度，如果`UFUNC_CORE_DIM_SIZE_INFERRED`为`0`，则可能为冻结大小

```py
*core_dim_flags
```

对于每个不同的核心维度，一组标志（`UFUNC_CORE_DIM_CAN_IGNORE` 和 `UFUNC_CORE_DIM_SIZE_INFERRED`)

```py
*identity_value
```

缩减的身份，当`PyUFuncObject.identity`等于`PyUFunc_IdentityValue`时。

```py
UFUNC_CORE_DIM_CAN_IGNORE
```

如果维度名称以`?`结尾

```py
UFUNC_CORE_DIM_SIZE_INFERRED
```

如果维度大小将根据操作数确定而不是来自冻结签名

### PyArrayIter_Type 和 PyArrayIterObject

```py
PyArrayIter_Type
```

这是一个迭代器对象，可以轻松地循环遍历 N 维数组。它是从 ndarray 的 flat 属性返回的对象。它还广泛地用于实现内部，以便循环遍历 N 维数组。实现了 tp_as_mapping 接口，以便可以索引迭代器对象（使用 1-d 索引），并且通过 tp_methods 表实现了一些方法。这个对象实现了 next 方法，并且可以在 Python 中的任何地方使用迭代器。

```py
type PyArrayIterObject
```

与`PyArrayIter_Type`对象对应的 C 结构是`PyArrayIterObject`。 `PyArrayIterObject`用于跟踪 N 维数组中的指针。它包含用于快速遍历数组的相关信息。指针可以通过三种基本方式进行调整：1）以 C 样式的连续方式前进到数组中的“下一个”位置，2）前进到数组中的任意 N 维坐标，3）前进到数组中的任意一维索引。`PyArrayIterObject`结构的成员用于进行这些计算。迭代器对象保留有关数组的自己的维度和跨度信息。这可根据需要进行调整，以进行“广播”，或仅在特定维度上循环。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index;
  npy_intp  size;
  npy_intp  coordinates[NPY_MAXDIMS];
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
}  PyArrayIterObject; 
```

```py
int nd_m1
```

\(N-1\)，其中\(N\)是底层数组中的维数。

```py
index
```

到数组的当前一维索引。

```py
size
```

底层数组的总大小。

```py
*coordinates
```

到数组的\(N\) -维索引。

```py
*dims_m1
```

每个维度中数组大小减 1。

```py
*strides
```

数组的跨度。在每个维度中跳到下一个元素需要多少字节。

```py
*backstrides
```

从维度末尾跳回到开头需要多少字节。注意`backstrides[k] == strides[k] * dims_m1[k]`，但它被存储在这里作为一种优化。

```py
*factors
```

该数组用于从一维索引计算 N 维索引。它包含所需的维度的乘积。

```py
*ao
```

指向此迭代器被创建以代表的基础 ndarray 的指针。

```py
char *dataptr
```

此成员指向由索引指示的 ndarray 中的一个元素。

```py
contiguous
```

如果底层数组是`NPY_ARRAY_C_CONTIGUOUS`，则此标志为 true。它用于在可能的情况下简化计算。

如何在 C 级别上使用数组迭代器在后续章节中有更详细的解释。通常情况下，您不需要关心迭代器对象的内部结构，只需通过宏`PyArray_ITER_NEXT` (it)、`PyArray_ITER_GOTO` (it, dest)或者`PyArray_ITER_GOTO1D` (it, index)来与之交互即可，所有这些宏要求参数*it*是 PyArrayIterObject*。

### PyArrayMultiIter_Type 和 PyArrayMultiIterObject

```py
PyArrayMultiIter_Type
```

这种类型提供了一种封装广播概念的迭代器。它允许将\(N\)个数组一起广播，使得循环按照广播数组的 C 风格连续方式进行。相应的 C 结构是`PyArrayMultiIterObject`，其内存布局必须从任何传递给`PyArray_Broadcast` (obj)函数的对象*obj*开始。通过调整数组迭代器执行广播，使得每个迭代器表示广播的形状和大小，但其步幅调整为每次迭代中使用数组的正确元素。

```py
type PyArrayMultiIterObject
```

```py
typedef  struct  {
  PyObject_HEAD
  int  numiter;
  npy_intp  size;
  npy_intp  index;
  int  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject  *iters[NPY_MAXDIMS];
}  PyArrayMultiIterObject; 
```

```py
int numiter
```

需要广播到相同形状的数组的数量。

```py
size
```

广播的总大小。

```py
index
```

广播结果的当前（1-D）索引。

```py
int nd
```

广播结果中的维数。

```py
*dimensions
```

广播结果的形状（仅使用`nd`个插槽）。

```py
**iters
```

一个迭代器对象数组，其中包含要合并广播的数组的迭代器。返回时，这些迭代器已调整为进行广播。

### PyArrayNeighborhoodIter_Type 和 PyArrayNeighborhoodIterObject

```py
PyArrayNeighborhoodIter_Type
```

这是一个迭代器对象，它可以轻松地在 N 维邻域上循环。

```py
type PyArrayNeighborhoodIterObject
```

与`PyArrayNeighborhoodIter_Type`对象对应的 C 结构是`PyArrayNeighborhoodIterObject`。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index,  size;
  npy_intp  coordinates[NPY_MAXDIMS]
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
  npy_intp  bounds[NPY_MAXDIMS][2];
  npy_intp  limits[NPY_MAXDIMS][2];
  npy_intp  limits_sizes[NPY_MAXDIMS];
  npy_iter_get_dataptr_t  translate;
  npy_intp  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject*  _internal_iter;
  char*  constant;
  int  mode;
}  PyArrayNeighborhoodIterObject; 
```

### PyArrayFlags_Type 和 PyArrayFlagsObject

```py
PyArrayFlags_Type
```

当从 Python 检索 flags 属性时，会构造一个特殊的内置对象的此类型。这种特殊的类型使得通过访问它们作为属性或者假定对象是一个以标志名称为条目的字典而访问它们来更容易地处理不同的标志。

```py
type PyArrayFlagsObject
```

```py
typedef  struct  PyArrayFlagsObject  {
  PyObject_HEAD
  PyObject  *arr;
  int  flags;
}  PyArrayFlagsObject; 
```

### 标量数组类型

数组中可能出现的不同内置数据类型都有对应的 Python 类型。其中大多数类型只是对应的 C 语言数据类型的简单封装。这些类型在 C 语言中的名称为 `Py{TYPE}ArrType_Type`，其中 `{TYPE}` 可以是

> **Bool**、**Byte**、**Short**、**Int**、**Long**、**LongLong**、**UByte**、**UShort**、**UInt**、**ULong**、**ULongLong**、**Half**、**Float**、**Double**、**LongDouble**、**CFloat**、**CDouble**、**CLongDouble**、**String**、**Unicode**、**Void** 和 **Object**。

这些类型名称属于 C-API 的一部分，因此可以在扩展 C 代码中创建。还有一个 `PyIntpArrType_Type` 和 `PyUIntpArrType_Type`，它们是平台上可以保存指针的整数类型的简单替代品。这些标量对象的结构对 C 代码不可见。函数 `PyArray_ScalarAsCtype` (..) 可以用于从数组标量中提取 C 类型值，而函数 `PyArray_Scalar` (…) 可以用于从 C 值构造一个数组标量。

### -   `PyArray_Type` 和 `PyArrayObject`

```py
PyArray_Type
```

ndarray 的 Python 类型是`PyArray_Type`。在 C 中，每个 ndarray 都是一个指向 `PyArrayObject` 结构的指针。这个结构的 ob_type 成员包含一个指向 `PyArray_Type` 类型对象的指针。

```py
type PyArrayObject
```

```py
type NPY_AO
```

`PyArrayObject` C 结构包含数组的所有必要信息。所有 ndarray（及其子类）的实例都具有这一结构。为了未来的兼容性，应该使用提供的宏来访问这些结构成员。如果需要更短的名称，那么可以使用 `NPY_AO`（已弃用），它被定义为等同于 `PyArrayObject`。直接访问结构字段已被弃用。请改用 `PyArray_*(arr)` 形式。从 NumPy 1.20 开始，此结构的大小不被认为是 NumPy ABI 的一部分（请参见成员列表末尾的注释）。

```py
typedef  struct  PyArrayObject  {
  PyObject_HEAD
  char  *data;
  int  nd;
  npy_intp  *dimensions;
  npy_intp  *strides;
  PyObject  *base;
  PyArray_Descr  *descr;
  int  flags;
  PyObject  *weakreflist;
  /* version dependent private members */
}  PyArrayObject; 
```

```py
PyObject_HEAD
```

这适用于所有 Python 对象。它至少包含一个引用计数成员（ `ob_refcnt` ）和一个类型对象指针（ `ob_type` ）。（如果使用特殊选项编译 Python，可能还有其他成员，请参见 Python 源代码树中的 Include/object.h 获取更多信息。）ob_type 成员指向一个 Python 类型对象。

```py
char *data
```

通过 `PyArray_DATA` 可以访问到这个数据成员，它是数组的第一个元素的指针。这个指针可以（通常应该）被重新解释为数组的数据类型。

```py
int nd
```

为此数组提供维数的整数。当 nd 为 0 时，有时称该数组为秩为 0 的数组。这样的数组具有未定义的维度和步幅，并且无法访问。宏 `PyArray_NDIM` 在 `ndarraytypes.h` 中定义，指向此数据成员。`NPY_MAXDIMS` 是任何数组的最大维数。

```py
*dimensions
```

一个提供每个维度的形状的整数数组，只要 nd \(\geq\) 1\. 该整数始终足够大，以容纳平台上的指针，因此维度大小仅受内存限制。`PyArray_DIMS` 是与此数据成员关联的宏。

```py
*strides
```

为每个维度提供一个整数数组，指定必须跳过多少字节才能到达该维度中的下一个元素。与宏`PyArray_STRIDES` 相关。

```py
*base
```

由`PyArray_BASE` 指向，此成员用于保存指向与此数组相关的另一个 Python 对象的指针。有两种用法：

+   如果该数组不拥有自己的内存，则 base 指向拥有它的 Python 对象（也许是另一个数组对象）。

+   如果此数组设置了`NPY_ARRAY_WRITEBACKIFCOPY` 标志，则此数组是“行为不端”数组的工作副本。

当调用 `PyArray_ResolveWritebackIfCopy` 时，base 指向的数组将使用此数组的内容进行更新。

```py
*descr
```

指向数据类型描述符对象的指针（见下文）。数据类型描述符对象是一种新的内置类型的实例，允许对内存进行通用描述。对于支持的每种数据类型都有一个描述符结构。此描述符结构包含有关类型的有用信息以及实现特定功能的函数指针表的指针。正如名称所示，它与宏`PyArray_DESCR` 相关联。

```py
int flags
```

由宏`PyArray_FLAGS` 指向的，这个数据成员表示标志，指示由 data 指向的内存应如何解释。可能的标志有`NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_OWNDATA`、`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_WRITEABLE`、`NPY_ARRAY_WRITEBACKIFCOPY`。

```py
*weakreflist
```

此成员允许数组对象具有弱引用（使用 weakref 模块）。

注意

进一步的成员被视为私有和版本相关的。如果结构的大小对您的代码很重要，则必须特别小心。当这一点是相关的时候可能的用例是在 C 中进行子类化。如果您的代码依赖于`sizeof(PyArrayObject)`是常量，您必须在导入时添加以下检查：

```py
if  (sizeof(PyArrayObject)  <  PyArray_Type.tp_basicsize)  {
  PyErr_SetString(PyExc_ImportError,
  "Binary incompatibility with NumPy, must recompile/update X.");
  return  NULL;
} 
```

为了确保您的代码不必为特定的 NumPy 版本编译，您可以添加一个常量，为 NumPy 的更改留出空间。一个确保与任何未来 NumPy 版本兼容的解决方案需要使用运行时计算偏移和分配大小。

### PyArrayDescr_Type 和 PyArray_Descr

```py
PyArrayDescr_Type
```

`PyArrayDescr_Type`是用于描述如何解释组成数组的字节的数据类型描述符对象的内置类型。有 21 个静态定义的`PyArray_Descr`对象用于内置数据类型。虽然它们参与引用计数，但它们的引用计数永远不应该达到零。还有一个动态的用户定义的`PyArray_Descr`对象表也在维护中。一旦数据类型描述符对象被“注册”，就不应该被释放。函数`PyArray_DescrFromType`（…）可以用于从枚举类型编号（内置或用户定义的）检索`PyArray_Descr`对象。

```py
type PyArray_Descr
```

`PyArray_Descr`结构位于`PyArrayDescr_Type`的核心。虽然这里对其进行了描述以保持完整性，但应该将其视为 NumPy 的内部结构，并通过`PyArrayDescr_*`或`PyDataType*`函数和宏来操作。此结构的大小可能会随 NumPy 版本的变化而变化。为了确保兼容性：

+   永远不要声明结构的非指针实例

+   永远不要进行指针算术运算

+   永远不要使用 `sizeof(PyArray_Descr)`

它具有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  PyTypeObject  *typeobj;
  char  kind;
  char  type;
  char  byteorder;
  char  flags;
  int  type_num;
  int  elsize;
  int  alignment;
  PyArray_ArrayDescr  *subarray;
  PyObject  *fields;
  PyObject  *names;
  PyArray_ArrFuncs  *f;
  PyObject  *metadata;
  NpyAuxData  *c_metadata;
  npy_hash_t  hash;
}  PyArray_Descr; 
```

```py
*typeobj
```

指向与此数组元素对应的 Python 类型的类型对象的指针。对于内置类型，这指向相应的数组标量。对于用户定义的类型，这应该指向用户定义的类型对象。这个类型对象可以继承自数组标量，也可以不继承。如果它不继承自数组标量，则`flags`成员中应设置`NPY_USE_GETITEM`和`NPY_USE_SETITEM`标志。

```py
char kind
```

表示数组种类的字符代码（使用数组接口类型字符串表示法）。‘b’表示布尔，‘i’表示有符号整数，‘u’表示无符号整数，‘f’表示浮点数，‘c’表示复数浮点数，‘S’表示 8 位以零结尾的字节，‘U’表示 32 位/字符的 Unicode 字符串，‘V’表示任意。

```py
char type
```

表示数据类型的传统字符代码。

```py
char byteorder
```

表示字节顺序的字符：‘>’（大端）、‘<’（小端）、‘=’（本地）、‘|’（不相关，忽略）。所有内置数据类型的字节顺序都是‘=’。

```py
char flags
```

一个数据类型位标志，确定数据类型是否表现出对象数组的行为。该成员中的每个位都是一个标志，命名为：

+   `NPY_ITEM_REFCOUNT`

+   `NPY_ITEM_HASOBJECT`

+   `NPY_LIST_PICKLE`

+   `NPY_ITEM_IS_POINTER`

+   `NPY_NEEDS_INIT`

+   `NPY_NEEDS_PYAPI`

+   `NPY_USE_GETITEM`

+   `NPY_USE_SETITEM`

+   `NPY_FROM_FIELDS`

+   `NPY_OBJECT_DTYPE_FLAGS`

```py
int type_num
```

一个唯一标识数据类型的数字。对于新数据类型，当数据类型被注册时，会分配这个数字。

```py
int elsize
```

对于始终大小相同的数据类型（例如 long），这保存数据类型的大小。对于灵活的数据类型，其中不同的数组可以具有不同的元素大小，这应为 0。

```py
int alignment
```

为此数据类型提供对齐信息的数字。具体来说，它显示了编译器将该类型的项目放置在起始为 `char` 的 2 元结构中的距离：`offsetof(struct {char c; type v;}, v)`

```py
*subarray
```

如果这是非 `NULL`，那么这个数据类型描述符是另一个数据类型描述符的 C 风格连续数组。换句话说，这个描述符描述的每个元素实际上都是另一个基本描述符的数组。这在作为另一个数据类型描述符中的字段的数据类型描述符时最有用。如果这是非 `NULL`，则 fields 成员应为 `NULL`（但基本描述符的 fields 成员可以是非 `NULL`）。

```py
type PyArray_ArrayDescr
```

```py
typedef  struct  {
  PyArray_Descr  *base;
  PyObject  *shape;
}  PyArray_ArrayDescr; 
```

```py
*base
```

基础类型的数据类型描述符对象。

```py
*shape
```

作为 Python 元组的子数组的形状（始终是 C 风格连续的）。

```py
*fields
```

如果这是非 NULL，则此数据类型描述符具有由 Python 字典描述的字段，其键是名称（如果给定也是标题），其值是描述字段的元组。回想一下，数据类型描述符总是描述一组固定长度的字节。字段是该总体、固定长度的集合的命名子区域。字段由另一个数据类型描述符和字节偏移量组成的元组描述。可选地，元组可以包含一个标题，通常是 Python 字符串。这些元组被放置在此字典中，键为名称（如果给定也是标题）。

```py
*names
```

一个有序的字段名称元组。如果未定义字段，则为 NULL。

```py
*f
```

指向包含类型需要实现内部功能的函数的结构体指针。这些函数与后面描述的通用函数（ufuncs）不是同一种东西。它们的签名可以任意变化。

```py
*metadata
```

关于此数据类型的元数据。

```py
*c_metadata
```

特定于特定数据类型的 C 实现的元数据。添加于 NumPy 1.7.0。

```py
type npy_hash_t
```

```py
*hash
```

目前未使用。保留以缓存散列值的未来使用。

```py
NPY_ITEM_REFCOUNT
```

表明此数据类型的项目必须进行引用计数（使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(in Python v3.11)")和[`Py_DECREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF "(in Python v3.11)")）。

```py
NPY_ITEM_HASOBJECT
```

与`NPY_ITEM_REFCOUNT`相同。

```py
NPY_LIST_PICKLE
```

表示此数据类型的数��必须在 pickling 之前转换为列表。

```py
NPY_ITEM_IS_POINTER
```

表示项目是指向其他数据类型的指针。

```py
NPY_NEEDS_INIT
```

表示此数据类型的内存在创建时必须初始化（设置为 0）。

```py
NPY_NEEDS_PYAPI
```

表明此数据类型在访问时需要 Python C-API（因此如果需要数组访问，则不要放弃 GIL）。

```py
NPY_USE_GETITEM
```

在数组访问中，使用`f->getitem`函数指针，而不是标准的转换为数组标量。如果没有定义与数据类型相配套的数组标量，则必须使用。

```py
NPY_USE_SETITEM
```

从数组标量创建 0 维数组时，请使用`f->setitem`，而不是标准的从数组标量复制。如果没有定义与数据类型相匹配的数组标量，则必须使用。

```py
NPY_FROM_FIELDS
```

如果这些位在数据类型的任何字段中设置，那么这些位就会继承自父数据类型。当前（`NPY_NEEDS_INIT` | `NPY_LIST_PICKLE` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_PYAPI`）。

```py
NPY_OBJECT_DTYPE_FLAGS
```

为对象数据类型设置的位：（`NPY_LIST_PICKLE` | `NPY_USE_GETITEM` | `NPY_ITEM_IS_POINTER` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_INIT` | `NPY_NEEDS_PYAPI`）。

```py
int PyDataType_FLAGCHK( *dtype, int flags)
```

如果数据类型对象上设置了给定标志，则返回 true。

```py
int PyDataType_REFCHK( *dtype)
```

等同于`PyDataType_FLAGCHK`（*dtype*, `NPY_ITEM_REFCOUNT`）。

```py
type PyArray_ArrFuncs
```

实现内部功能的函数。并非所有这些函数指针都必须为给定类型定义。所需成员包括`nonzero`、`copyswap`、`copyswapn`、`setitem`、`getitem`和`cast`。假定这些为非`NULL`，而`NULL`条目将导致程序崩溃。其他功能可能为`NULL`，这只会减少该数据类型的功能。（另外，如果在注册用户定义的数据类型时`NULL`，则`nonzero`函数将用默认函数填充）。

```py
typedef  struct  {
  PyArray_VectorUnaryFunc  *cast[NPY_NTYPES];
  PyArray_GetItemFunc  *getitem;
  PyArray_SetItemFunc  *setitem;
  PyArray_CopySwapNFunc  *copyswapn;
  PyArray_CopySwapFunc  *copyswap;
  PyArray_CompareFunc  *compare;
  PyArray_ArgFunc  *argmax;
  PyArray_DotFunc  *dotfunc;
  PyArray_ScanFunc  *scanfunc;
  PyArray_FromStrFunc  *fromstr;
  PyArray_NonzeroFunc  *nonzero;
  PyArray_FillFunc  *fill;
  PyArray_FillWithScalarFunc  *fillwithscalar;
  PyArray_SortFunc  *sort[NPY_NSORTS];
  PyArray_ArgSortFunc  *argsort[NPY_NSORTS];
  PyObject  *castdict;
  PyArray_ScalarKindFunc  *scalarkind;
  int  **cancastscalarkindto;
  int  *cancastto;
  PyArray_FastClipFunc  *fastclip;  /* deprecated */
  PyArray_FastPutmaskFunc  *fastputmask;  /* deprecated */
  PyArray_FastTakeFunc  *fasttake;  /* deprecated */
  PyArray_ArgFunc  *argmin;
}  PyArray_ArrFuncs; 
```

在描述函数指针时使用了行为良好的段的概念。 行为良好的段是指与数据类型的本机机器字节顺序对齐的段。 `nonzero`、`copyswap`、`copyswapn`、`getitem` 和 `setitem` 函数可以（并且必须）处理不规范的数组。 其他函数需要行为良好的内存段。

```py
void cast(void *from, void *to, n, void *fromarr, void *toarr)
```

用于将当前类型转换为所有其他内置类型的函数指针数组。 每个函数将由 *from* 指向的连续、对齐且未交换的缓冲区转换为由 *to* 指向的连续、对齐且未交换的缓冲区。 要转换的项目数由 *n* 给出，并且参数 *fromarr* 和 *toarr* 被解释为灵活数组的 PyArrayObjects 以获取 itemsize 信息。

```py
*getitem(void *data, void *arr)
```

指向从由 *data* 指向的数组对象 *arr* 的单个元素返回标准 Python 对象的函数的指针。 该函数必须能够正确处理“不规范”（未对齐和/或已交换）的数组。

```py
int setitem( *item, void *data, void *arr)
```

指向将 Python 对象 *item* 设置到数组 *arr* 中由 *data* 指向位置的函数的指针。 该函数处理“不规范”的数组。 如果成功，则返回零，否则返回负一（并设置 Python 错误）。

```py
void copyswapn(void *dest, dstride, void *src, sstride, n, int swap, void *arr)
```

```py
void copyswap(void *dest, void *src, int swap, void *arr)
```

这些成员都是指向从 *src* 复制数据到 *dest* 并在需要时交换的函数的指针。 arr 的值仅用于灵活（`NPY_STRING`、`NPY_UNICODE` 和 `NPY_VOID`）数组（并从 `arr->descr->elsize` 获取）。 第二个函数复制单个值，而第一个函数则使用提供的步幅循环 n 个值。 这些函数可以处理不规范的 *src* 数据。 如果 *src* 为 NULL，则不执行复制。 如果 *swap* 为 0，则不进行字节交换。 假定 *dest* 和 *src* 不重叠。 如果它们重叠，则首先使用 `memmove`（…）后跟 NULL 值的 `src` 进行 `copyswap(n)`。

```py
int compare(const void *d1, const void *d2, void *arr)
```

指向比较数组 `arr` 中由 `d1` 和 `d2` 指向的两个元素的函数的指针。 此函数需要行为良好的（对齐且未交换）数组。 如果 * `d1` > * `d2`，则返回值为 1，如果 * `d1` == * `d2`，则返回值为 0，如果 * `d1` < * `d2`，则返回值为 -1。 用于灵活数组的数组对象 `arr` 用于检索 itemsize 和字段信息。

```py
int argmax(void *data, n, *max_ind, void *arr)
```

指向从由 *data* 指向的数组中从指向的元素开始的 `n` 个元素中检索最大索引的函数的指针。 此函数要求内存段是连续且行为良好的。 返回值始终为 0。 最大元素的索引在 `max_ind` 中返回。

```py
void dotfunc(void *ip1, is1, void *ip2, is2, void *op, n, void *arr)
```

指向函数的指针，将两个`n`长度序列相乘，相加，并将结果放置在`arr`的`op`指向的元素中。两个序列的起始点由`ip1`和`ip2`指向。要进入每个序列的下一个元素，分别需要跳过`is1`和`is2` *字节*。此函数需要良好行为的内存（尽管不一定是连续的）。

```py
int scanfunc(FILE *fd, void *ip, void *arr)
```

指向函数的指针，从文件描述符`fd`中扫描（类似于 scanf）相应类型的一个元素到由`ip`指向的数组内存中。假定数组良好行为。最后一个参数`arr`是要扫描到的数组。返回成功分配的接收参数的数量（如果在分配第一个接收参数之前发生匹配失败，则可能为零），或者如果在分配第一个接收参数之前发生输入失败则返回 EOF。此函数应在不持有 Python GIL 的情况下调用，并且在报告错误时必须抓取它。

```py
int fromstr(char *str, void *ip, char **endptr, void *arr)
```

指向函数的指针，将由`str`指向的字符串转换为相应类型的一个元素，并将其放置在由`ip`指向的内存位置。转换完成后，`*endptr`指向字符串的剩余部分。最后一个参数`arr`是`ip`指向的数组（对于可变大小数据类型需要）。成功返回 0，失败返回-1。需要一个良好行为的数组。此函数应在不持有 Python GIL 的情况下调用，并且在报告错误时必须抓取它。

```py
nonzero(void *data, void *arr)
```

指向函数的指针，如果`data`指向的`arr`的项非零，则返回 TRUE。该函数可处理不良行为的数组。

```py
void fill(void *data, length, void *arr)
```

指向函数的指针，用于将给定长度的连续数组填充到数据中。数组的前两个元素必须已经填充。从这两个值中，将计算一个增量，然后通过重复添加此计算出的增量来计算从第 3 个项目到末尾的值。数据缓冲区必须良好行为。

```py
void fillwithscalar(void *buffer, length, void *value, void *arr)
```

指向函数的指针，用给定的`value`填充给定`length`的连续`buffer`。最后一个参数是需要获取变长数组的项大小。

```py
int sort(void *start, length, void *arr)
```

一组函数指针的数组，指向特定的排序算法。使用键（到目前为止已定义`NPY_QUICKSORT`、`NPY_HEAPSORT`和`NPY_MERGESORT`）获得特定的排序算法。这些排序是就地完成的，假设数据是连续且对齐的。

```py
int argsort(void *start, *result, length, void *arr)
```

一组函数指针的数组，用于这种数据类型的排序算法。与 sort 相同的排序算法可用。产生排序的索引将返回到`result`（必须初始化为 0 到`length-1`的索引）。

```py
*castdict
```

可以为`NULL`，也可以是包含用户定义数据类型的低级转换函数的字典。每个函数都包装在[PyCapsule](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11)")*中，并以数据类型编号为键。

```py
scalarkind( *arr)
```

一个确定此类型标量应该如何解释的函数。该参数为`NULL`或包含数据的零维数组（如果需要确定标量的类型）。返回值必须为类型`NPY_SCALARKIND`。

```py
int **cancastscalarkindto
```

可以为`NULL`，也可以是`NPY_NSCALARKINDS`指针数组。这些指针可以是`NULL`，也可以是指向整数数组的指针（以`NPY_NOTYPE`结尾），指示此指定类型的标量可以安全转换的数据类型（通常意味着不会失去精度）。

```py
int *cancastto
```

可以为`NULL`，也可以是一个整数数组（以`NPY_NOTYPE`结尾），指示此数据类型可以安全转换的数据类型（通常意味着不会失去精度）。

```py
void fastclip(void *in, n_in, void *min, void *max, void *out)
```

自 1.17 版本起已弃用：当`np.clip`时，使用此函数会引发弃用警告。而不是使用此函数，数据类型必须使用`PyUFunc_RegisterLoopForDescr`将自定义循环附加到`np.core.umath.clip`、`np.minimum`和`np.maximum`。

自 1.19 版本起已弃用：设置此函数已被弃用，应该始终为`NULL`，如果设置了，将被忽略。

一个从`in`中读取`n_in`个项目，并在`min`和`max`指向的限制内写入`out`的值的函数，如果读取的值在`min`和`max`指向的限制内，或者在外部，则相应的限制。内存段必须是连续的且表现良好，`min`或`max`可以为`NULL`，但不能同时为`NULL`。

```py
void fastputmask(void *in, void *mask, n_in, void *values, nv)
```

自 1.19 版本起已弃用：设置此函数已被弃用，应该始终为`NULL`，如果设置了，将被忽略。

一个使用指针`in`指向一个包含`n_in`个项目的数组，指针`mask`指向一个包含`n_in`个布尔值的数组，以及指针`vals`指向一个包含`nv`个项目的数组的函数。将`vals`中的项目复制到`in`中，无论`mask`中的值是否为非零，在`nv < n_in`的情况下需要按需平铺`vals`。所有数组必须是连续的且表现良好。

```py
void fasttake(void *dest, void *src, *indarray, nindarray, n_outer, m_middle, nelem, clipmode)
```

自 1.19 版本起已弃用：设置此函数已被弃用，应该始终为`NULL`，如果设置了，将被忽略。

一个函数，它接受指向 C 连续、行为良好段的指针`src`，解释为形状为`(n_outer, nindarray, nelem)`的 3 维数组，指向`indarray`指针到`m_middle`整数索引的连续、行为良好段，以及指向 C 连续、行为良好段的指针`dest`，解释为形状为`(n_outer, m_middle, nelem)`的 3 维数组。`indarray`中的索引用于沿第二维索引`src`，并将`nelem`项的相应块复制到`dest`。`clipmode`（可以取值`NPY_RAISE`、`NPY_WRAP`或`NPY_CLIP`）确定小于 0 或大于`nindarray`的索引将如何处理。

```py
int argmin(void *data, n, *min_ind, void *arr)
```

指针指向一个函数，该函数检索数组`arr`中从指向`data`的元素开始的`n`个元素中最小的索引。此函数要求内存段是连续且行为良好。返回值始终为 0。最小元素的索引在`min_ind`中返回。

`PyArray_Type`类型对象实现了许多[`Python 对象`](https://docs.python.org/3/c-api/type.html#c.PyTypeObject "(在 Python v3.11)")的特性，包括[`tp_as_number`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_number "(在 Python v3.11)")、[`tp_as_sequence`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence "(在 Python v3.11)")、[`tp_as_mapping`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping "(在 Python v3.11)")和[`tp_as_buffer`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer "(在 Python v3.11)")接口。还使用了[`rich comparison`](https://docs.python.org/3/c-api/typeobj.html#c.richcmpfunc "(在 Python v3.11)")以及成员([`tp_members`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_members "(在 Python v3.11)"))和属性([`tp_getset`](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset "(在 Python v3.11)"))的新式属性查找。`PyArray_Type`也可以被子类化。

提示

`tp_as_number` 方法使用通用方法调用已注册用于处理操作的函数。当导入`_multiarray_umath`模块时，它将所有数组的数字操作设置为相应的 ufunc。可以使用`PyUFunc_ReplaceLoopBySignature`更改此选择，也可以使用`PyArray_SetStringFunction`改变`tp_str`和`tp_repr`方法。

### PyUFunc_Type 和 PyUFuncObject

```py
PyUFunc_Type
```

ufunc 对象是通过创建`PyUFunc_Type`来实现的。这是一种非常简单的类型，仅实现了基本的 getattribute 行为、打印行为，并具有调用行为，允许这些对象像函数一样运行。ufunc 的基本思想是持有对支持该操作的每种数据类型的快速 1 维（向量）循环的引用。这些一维循环都具有相同的签名，并且是创建新 ufunc 的关键。它们由通用循环代码在适当的时候调用，以实现 N 维函数。还为浮点和复数浮点数组定义了一些通用的 1-d 循环，允许您使用单个标量函数定义 ufunc（*例如*atanh）。

```py
type PyUFuncObject
```

ufunc 的核心是`PyUFuncObject`，它包含调用执行实际工作的基础 C 代码循环所需的所有信息。虽然这里描述了完整的内容，但它应被视为 NumPy 的内部内容，并通过`PyUFunc_*`函数来操作。该结构的大小可能会因 NumPy 的不同版本而发生变化。为了确保兼容性：

+   永远不要声明结构的非指针实例

+   永远不要执行指针算术

+   永远不要使用`sizeof(PyUFuncObject)`

它具有以下结构：

```py
typedef  struct  {
  PyObject_HEAD
  int  nin;
  int  nout;
  int  nargs;
  int  identity;
  PyUFuncGenericFunction  *functions;
  void  **data;
  int  ntypes;
  int  reserved1;
  const  char  *name;
  char  *types;
  const  char  *doc;
  void  *ptr;
  PyObject  *obj;
  PyObject  *userloops;
  int  core_enabled;
  int  core_num_dim_ix;
  int  *core_num_dims;
  int  *core_dim_ixs;
  int  *core_offsets;
  char  *core_signature;
  PyUFunc_TypeResolutionFunc  *type_resolver;
  PyUFunc_LegacyInnerLoopSelectionFunc  *legacy_inner_loop_selector;
  void  *reserved2;
  npy_uint32  *op_flags;
  npy_uint32  *iter_flags;
  /* new in API version 0x0000000D */
  npy_intp  *core_dim_sizes;
  npy_uint32  *core_dim_flags;
  PyObject  *identity_value;
  /* Further private slots (size depends on the NumPy version) */
}  PyUFuncObject; 
```

```py
int nin
```

输入参数的数量。

```py
int nout
```

输出参数的数量。

```py
int nargs
```

参数的总数（*nin* + *nout*）。这必须小于`NPY_MAXARGS`。

```py
int identity
```

要么`PyUFunc_One`、`PyUFunc_Zero`、`PyUFunc_MinusOne`、`PyUFunc_None`、`PyUFunc_ReorderableNone`或`PyUFunc_IdentityValue`用于指示该操作的身份。它仅在对空数组进行类似于 reduce 的调用时使用。

```py
void functions(char **args, *dims, *steps, void *extradata)
```

一个函数指针数组—每种 ufunc 支持的数据类型都有一个。这是被调用以实现底层函数的向量循环，*dims* [0]次。第一个参数*args*是一个包含*nargs*指针的行为内存数组。首先是输入参数的数据指针，然后是输出参数的数据指针。必须跳过多少字节才能到达序列中的下一个元素是由*steps*数组中的相应条目指定的。最后一个参数允许循环接收额外的信息。这通常用于一个通用的向量循环可以用于多个函数的情况。在这种情况下，要调用的实际标量函数作为*extradata*传递进来。该函数指针数组的大小为 ntypes。

```py
void **data
```

要传递给 1-d 向量循环的额外数据，如果不需要额外数据则为 `NULL`。这个 C 数组必须与函数数组的大小相同（*即* ntypes）。如果不需要额外数据，则使用 `NULL`。对于 UFuncs 的几个 C-API 调用只是使用这些额外数据的 1-d 向量循环，以接收指向要调用的实际函数的指针。

```py
int ntypes
```

ufunc 支持的数据类型数量。这个数字指定了内置数据类型的多少不同的 1-d 循环可用。

```py
int reserved1
```

未使用。

```py
char *name
```

ufunc 的字符串名称。这在动态构建 ufuncs 的 `__doc__` 属性时使用。

```py
char *types
```

一个 \(nargs \times ntypes\) 的 8 位 type_numbers 数组，其中包含函数对于每个支持的（内置）数据类型的类型签名。对于每个 *ntypes* 函数，该数组中相应的类型编号集显示了 1-d 向量循环中 *args* 参数应该如何解释。这些类型编号不必是相同的类型，支持混合类型的 ufuncs。

```py
char *doc
```

ufunc 的文档。不应该包含函数签名，因为在检索 `__doc__` 时会动态生成。

```py
void *ptr
```

任何动态分配的内存。目前，这用于从 Python 函数创建动态 ufuncs，用于存储类型、数据和名称成员的空间。

```py
*obj
```

对于从 Python 函数动态创建的 ufuncs，这个成员保存对底层 Python 函数的引用。

```py
*userloops
```

用户定义的 1-d 向量循环的字典（存储为 CObject ptrs）用于用户定义的类型。用户可以为任何用户定义的类型注册一个循环。它通过类型编号检索。用户定义的类型编号始终大于`NPY_USERDEF`。

```py
int core_enabled
```

标量 ufunc 为 0；广义 ufunc 为 1

```py
int core_num_dim_ix
```

签名中核心维度名称的不同个数

```py
int *core_num_dims
```

每个参数的核心维度的数量

```py
int *core_dim_ixs
```

以扁平化的形式存储的维度索引；第 `k` 个参数的索引存储在 `core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]`

```py
int *core_offsets
```

每个参数中第一个核心维度的位置在 `core_dim_ixs` 中，等同于累加和(`core_num_dims`)

```py
char *core_signature
```

核心签名字符串

```py
PyUFunc_TypeResolutionFunc *type_resolver
```

解析类型并填充输入和输出的 dtypes 的函数

```py
PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector
```

从版本 1.22 起弃用：这个插槽存在某些后备支持，但最终将被移除。依赖于此的通用函数最终将必须迁移。参见[NEP 41](https://numpy.org/neps/nep-0041-improved-dtype-support.html#nep41 "(in NumPy Enhancement Proposals)") 和 [NEP 43](https://numpy.org/neps/nep-0043-extensible-ufuncs.html#nep43 "(in NumPy Enhancement Proposals)")

```py
void *reserved2
```

用于可能的将来使用具有不同签名的循环选择器。

```py
op_flags
```

重写每个 ufunc 操作数的默认操作数标志。

```py
iter_flags
```

重写 ufunc 的默认 nditer 标志。

在 API 版本 0x0000000D 中添加

```py
*core_dim_sizes
```

对于每个不同的核心尺寸，如果`UFUNC_CORE_DIM_SIZE_INFERRED` 等于 `0`，则是 p</span>签名的可能大小

```py
*core_dim_flags
```

每个不同的核心维度，一组标志（`UFUNC_CORE_DIM_CAN_IGNORE` 和 `UFUNC_CORE_DIM_SIZE_INFERRED`）

```py
*identity_value
```

缩减的身份，当`PyUFuncObject.identity` 等于`PyUFunc_IdentityValue`时。

```py
UFUNC_CORE_DIM_CAN_IGNORE
```

如果维度名称以 `?` 结尾

```py
UFUNC_CORE_DIM_SIZE_INFERRED
```

若维度大小将由操作数确定，并非来自 frozen 签名

### PyArrayIter_Type 和 PyArrayIterObject

```py
PyArrayIter_Type
```

这是一个迭代器对象，它可以轻松地循环访问 N 维数组。 这是从 ndarray 的 flat 属性返回的对象。 它还广泛用于整体实现内部，用于循环访问 N 维数组。<span class="fn"></span> interface 已实现，使得可以对迭代器对象进行索引（使用 1-d 索引），并且一些方法通过`tp_methods`表进行了实现。 此对象实现了`next`方法，并且可以在 Python 中使用任何可以使用迭代器的地方。

```py
type PyArrayIterObject
```

与`PyArrayIter_Type`对象对应的 C-结构是`PyArrayIterObject`. `PyArrayIterObject` 用于跟踪指向 N 维数组的指针。 它包含相关信息，用于快速遍历数组。 指针可以通过三种基本方法进行调整：1) 以 C 风格连续的方式前进到数组中的“下一个”位置，2) 前进到数组中的任意 N 维坐标，和 3) 前进到数组中的任意一维索引。 这些计算中使用了`PyArrayIterObject`结构的成员。 迭代器对象保留其数组的维度和步幅信息。这可以根据需要进行“广播”，或者仅循环特定维度。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index;
  npy_intp  size;
  npy_intp  coordinates[NPY_MAXDIMS];
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
}  PyArrayIterObject; 
```

```py
int nd_m1
```

\(N-1\) 其中 \(N\) 是底层数组中的维数。

```py
index
```

当前数组的 1-d 索引。

```py
size
```

底层数组的总大小。

```py
*coordinates
```

一个 \(N\) -维数组的索引。

```py
*dims_m1
```

每个维度中数组的大小减 1。

```py
*strides
```

数组的步幅。在每个维度中，跳到下一个元素需要多少字节。

```py
*backstrides
```

从维度末尾跳回到其开头需要多少字节。注意 `backstrides[k] == strides[k] * dims_m1[k]`，但它存储在这里是一种优化。

```py
*factors
```

此数组用于计算从 1-d 索引到 N-d 索引的所需乘积。 

```py
*ao
```

创建此迭代器表示的基础 ndarray 的指针。

```py
char *dataptr
```

此成员指向由索引指示的 ndarray 中的元素。

```py
contiguous
```

如果底层数组为`NPY_ARRAY_C_CONTIGUOUS`，则此标志为真。它用于尽可能简化计算。

如何在 C 级别上使用数组迭代器在后续部分中有更详细的解释。通常情况下，您无需关注迭代器对象的内部结构，而只需通过宏 `PyArray_ITER_NEXT` (it)、`PyArray_ITER_GOTO` (it, dest) 或 `PyArray_ITER_GOTO1D` (it, index) 与之交互即可。所有这些宏都要求参数 *it* 是一个 PyArrayIterObject*。

### [PyArrayMultiIter_Type](https://wiki.example.org/PyArrayMultiIter_Type) 和 [PyArrayMultiIterObject](https://wiki.example.org/PyArrayMultiIterObject)

```py
PyArrayMultiIter_Type
```

这种类型提供了一种封装了广播概念的迭代器。它允许将 \(N\) 个数组一起广播，以便循环按照 C 风格的连续方式在广播的数组上进行。相应的 C 结构是 `PyArrayMultiIterObject`，其内存布局必须从传递给 `PyArray_Broadcast` (obj) 函数的任何对象 *obj* 开始。通过调整数组迭代器来执行广播，使得每个迭代器表示广播的形状和大小，但其步幅被调整，以便在每次迭代中使用数组中的正确元素。

```py
type PyArrayMultiIterObject
```

```py
typedef  struct  {
  PyObject_HEAD
  int  numiter;
  npy_intp  size;
  npy_intp  index;
  int  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject  *iters[NPY_MAXDIMS];
}  PyArrayMultiIterObject; 
```

```py
int numiter
```

需要广播到相同形状的数组数量。

```py
size
```

广播的总大小。

```py
index
```

广播结果中当前的（1-d）索引。

```py
int nd
```

广播结果中的维数数量。

```py
*dimensions
```

广播结果的形状（仅使用 `nd` 个槽）。

```py
**iters
```

一个包含为一起广播的数组调整过迭代器的迭代器对象数组。返回时，这些迭代器已调整好以进行广播。

### [PyArrayNeighborhoodIter_Type](https://wiki.example.org/PyArrayNeighborhoodIter_Type) 和 [PyArrayNeighborhoodIterObject](https://wiki.example.org/PyArrayNeighborhoodIterObject)

```py
PyArrayNeighborhoodIter_Type
```

这是一个迭代器对象，使得在 N 维邻域上循环变得��易。

```py
type PyArrayNeighborhoodIterObject
```

与对象 `PyArrayNeighborhoodIter_Type` 对应的 C 结构是 `PyArrayNeighborhoodIterObject`。

```py
typedef  struct  {
  PyObject_HEAD
  int  nd_m1;
  npy_intp  index,  size;
  npy_intp  coordinates[NPY_MAXDIMS]
  npy_intp  dims_m1[NPY_MAXDIMS];
  npy_intp  strides[NPY_MAXDIMS];
  npy_intp  backstrides[NPY_MAXDIMS];
  npy_intp  factors[NPY_MAXDIMS];
  PyArrayObject  *ao;
  char  *dataptr;
  npy_bool  contiguous;
  npy_intp  bounds[NPY_MAXDIMS][2];
  npy_intp  limits[NPY_MAXDIMS][2];
  npy_intp  limits_sizes[NPY_MAXDIMS];
  npy_iter_get_dataptr_t  translate;
  npy_intp  nd;
  npy_intp  dimensions[NPY_MAXDIMS];
  PyArrayIterObject*  _internal_iter;
  char*  constant;
  int  mode;
}  PyArrayNeighborhoodIterObject; 
```

### [PyArrayFlags_Type](https://wiki.example.org/PyArrayFlags_Type) 和 [PyArrayFlagsObject](https://wiki.example.org/PyArrayFlagsObject)

```py
PyArrayFlags_Type
```

当从 Python 检索 flags 属性时，将构造这种特殊的内置对象。这种特殊类型通过将其作为属性访问这些不同的标志，或者通过将其作为字典访问，其中标志名称作为条目，使得更容易处理不同的标志。

```py
type PyArrayFlagsObject
```

```py
typedef  struct  PyArrayFlagsObject  {
  PyObject_HEAD
  PyObject  *arr;
  int  flags;
}  PyArrayFlagsObject; 
```

### ScalarArrayTypes

对于数组中可能存在的不同内置数据类型，每个都有一个 Python 类型。其中大部分只是对应的 C 中数据类型的简单包装。这些类型的 C 名称为`Py{TYPE}ArrType_Type`，其中`{TYPE}`可以是

> **Bool**，**Byte**，**Short**，**Int**，**Long**，**LongLong**，**UByte**，**UShort**，**UInt**，**ULong**，**ULongLong**，**Half**，**Float**，**Double**，**LongDouble**，**CFloat**，**CDouble**，**CLongDouble**，**String**，**Unicode**，**Void**，和**Object**。

这些类型名称是 C-API 的一部分，因此可以在扩展 C 代码中创建它们。还有一个`PyIntpArrType_Type`和一个`PyUIntpArrType_Type`，它们可以简单地替代可以在平台上保存指针的整数类型之一。这些标量对象的结构不暴露给 C 代码。函数`PyArray_ScalarAsCtype`（..）可用于从数组标量中提取 C 类型值，而函数`PyArray_Scalar`（...）可用于从 C 值构造数组标量。

## 其他 C 结构

发现在 NumPy 开发中几个新的 C 结构非常有用。这些 C 结构至少在一个 C-API 调用中被使用，因此在此进行了文档化。定义这些结构的主要原因是为了简化使用 Python ParseTuple C-API，将 Python 对象转换为有用的 C 对象。

### PyArray_Dims

```py
type PyArray_Dims
```

当需要解释形状和/或步幅信息时，此结构非常有用。该结构是：

```py
typedef  struct  {
  npy_intp  *ptr;
  int  len;
}  PyArray_Dims; 
```

该结构的成员有

```py
*ptr
```

指向（`npy_intp`）整数列表的指针，通常表示数组形状或数组步幅。

```py
int len
```

整数列表的长度。假定可以安全地访问*ptr*[0]至*ptr*[len-1]。

### PyArray_Chunk

```py
type PyArray_Chunk
```

这相当于 Python 中缓冲区对象结构，直到 ptr 成员。在 32 位平台上（即如果`NPY_SIZEOF_INT` == `NPY_SIZEOF_INTP`），len 成员也与缓冲区对象的等效成员匹配。用于表示通用单段内存块。

```py
typedef  struct  {
  PyObject_HEAD
  PyObject  *base;
  void  *ptr;
  npy_intp  len;
  int  flags;
}  PyArray_Chunk; 
```

其成员有

```py
*base
```

此内存块来自的 Python 对象。需要这样做以正确计算内存。

```py
void *ptr
```

指向内存单段块的起始位置的指针。

```py
len
```

段的长度（以字节为单位）。

```py
int flags
```

任何应该用于解释内存的数据标志（例如`NPY_ARRAY_WRITEABLE`）。

### PyArrayInterface

另请参阅

数组接口协议

```py
type PyArrayInterface
```

`PyArrayInterface` 结构定义了 NumPy 和其他扩展模块可以使用的快速数组接口协议。支持快速数组接口协议的对象的 `__array_struct__` 方法应返回一个包含指向 `PyArrayInterface` 结构的指针的 [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11)")，其中包含数组的相关详细信息。创建新数组后，应`DECREF`该属性，这将释放 `PyArrayInterface` 结构的内存。记得`INCREF`获取 `__array_struct__` 属性的对象，并将新 `PyArrayObject` 的 base 成员指向同一对象。通过这种方式，数组的内存将正确管理。

```py
typedef  struct  {
  int  two;
  int  nd;
  char  typekind;
  int  itemsize;
  int  flags;
  npy_intp  *shape;
  npy_intp  *strides;
  void  *data;
  PyObject  *descr;
}  PyArrayInterface; 
```

```py
int two
```

作为健全性检查的整数 2。

```py
int nd
```

数组中的维度数。

```py
char typekind
```

根据类型字符串约定指示存在什么类型的数组的字符，将 ‘t’ -> 位域，‘b’ -> 布尔值，‘i’ -> 有符号整数，‘u’ -> 无符号整数，‘f’ -> 浮点，‘c’ -> 复数浮点，‘O’ -> 对象，‘S’ -> （字节）字符串，‘U’ -> Unicode，‘V’ -> void。

```py
int itemsize
```

数组中每个项所需的字节数。

```py
int flags
```

任何一个位 `NPY_ARRAY_C_CONTIGUOUS` (1)，`NPY_ARRAY_F_CONTIGUOUS` (2)，`NPY_ARRAY_ALIGNED` (0x100)，`NPY_ARRAY_NOTSWAPPED` (0x200)，或 `NPY_ARRAY_WRITEABLE` (0x400)，以指示有关数据的一些信息。实际上，可以从其他参数确定标志 `NPY_ARRAY_ALIGNED`，`NPY_ARRAY_C_CONTIGUOUS` 和 `NPY_ARRAY_F_CONTIGUOUS`。标志 `NPY_ARR_HAS_DESCR` (0x800) 也可以设置，以向消费版本 3 数组接口的对象指示结构的 descr 成员存在（版本 2 的数组接口将忽略它）。

```py
*shape
```

包含数组每个维度的大小的数组。

```py
*strides
```

包含在每个维度中跳过下一个元素所需的字节数的数组。

```py
void *data
```

指向数组第一个元素的指针。

```py
*descr
```

描述数据类型详细信息的 Python 对象（与`__array_interface__`中的*descr*键相同）。如果*typekind*和*itemsize*提供足够的信息，这个字段可以为`NULL`。除非在*flags*中打开了`NPY_ARR_HAS_DESCR`标志，否则此字段也会被忽略。

### 内部使用的结构

内部，该代码使用了一些额外的 Python 对象，主要用于内存管理。这些类型无法直接从 Python 访问，并且不会暴露给 C-API。它们在此处仅用于完整性和帮助理解代码。

```py
type PyUFunc_Loop1d
```

简单的 C 结构链表，包含了为用户定义的数据类型的每个定义的签名定义 1-d 循环所需的信息。

```py
PyArrayMapIter_Type
```

使用此 Python 类型处理高级索引。它只是一个松散的包装器，包装了包含高级数组索引所需变量的 C 结构。

```py
type PyArrayMapIterObject
```

与`PyArrayMapIter_Type`相关联的 C 结构。如果你正在尝试理解高级索引映射代码，这个结构很有用。它在`arrayobject.h`头文件中定义。此类型未暴露给 Python，可以用 C 结构替换。作为 Python 类型，它利用引用计数内存管理。

### PyArray_Dims

```py
type PyArray_Dims
```

当形状和/或步长信息需要被解释时，这个结构非常有用。结构是:

```py
typedef  struct  {
  npy_intp  *ptr;
  int  len;
}  PyArray_Dims; 
```

这个结构的成员是

```py
*ptr
```

指向一个(`npy_intp`)整数列表的指针，通常表示数组的形状或数组的步长。

```py
int len
```

整数列表的长度。假定可以安全访问*ptr*[0]到*ptr*[len-1]。

### PyArray_Chunk

```py
type PyArray_Chunk
```

这与 Python 中的缓冲对象结构相当，直到 ptr 成员。在 32 位平台上（*即* if `NPY_SIZEOF_INT` == `NPY_SIZEOF_INTP`），len 成员也与缓冲对象的等效成员匹配。它用于表示通用单段内存块。

```py
typedef  struct  {
  PyObject_HEAD
  PyObject  *base;
  void  *ptr;
  npy_intp  len;
  int  flags;
}  PyArray_Chunk; 
```

这些成员是

```py
*base
```

分配这块内存的 Python 对象。需要这样以便能够正确计算内存使用。

```py
void *ptr
```

指向单个内存块的起始指针。

```py
len
```

段的字节长度。

```py
int flags
```

用于解释内存的任何数据标志（*例如* `NPY_ARRAY_WRITEABLE`）。

### PyArrayInterface

另请参见

数组接口协议

```py
type PyArrayInterface
```

`PyArrayInterface`结构被定义为 NumPy 和其他扩展模块可以使用快速数组接口协议。支持快速数组接口协议的对象的`__array_struct__`方法应返回包含指向具有数组的相关细节的`PyArrayInterface`结构的指针的[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11")。创建新数组后，应`DECREF`该属性，这将释放`PyArrayInterface`结构。记得`INCREF`这个对象（其`__array_struct__`属性已被检索）并将新`PyArrayObject`的 base 成员指向同一对象。这样数组的内存将得到正确管理。

```py
typedef  struct  {
  int  two;
  int  nd;
  char  typekind;
  int  itemsize;
  int  flags;
  npy_intp  *shape;
  npy_intp  *strides;
  void  *data;
  PyObject  *descr;
}  PyArrayInterface; 
```

```py
int two
```

整数`2`作为健全性检查。

```py
int nd
```

数组中的维度数。

```py
char typekind
```

根据类型字符串约定指示出现的数组类型的字符，‘t’ -> 位字段，‘b’ -> 布尔，‘i’ -> 有符号整数，‘u’ -> 无符号整数，‘f’ -> 浮点数，‘c’ -> 复数浮点数，‘O’ -> 对象，‘S’ -> （字节）字符串，‘U’ -> Unicode，‘V’ -> 空。

```py
int itemsize
```

数组中每个项所需的字节数。

```py
int flags
```

位之一`NPY_ARRAY_C_CONTIGUOUS`（1）、`NPY_ARRAY_F_CONTIGUOUS`（2）、`NPY_ARRAY_ALIGNED`（0x100）、`NPY_ARRAY_NOTSWAPPED`（0x200）或`NPY_ARRAY_WRITEABLE`（0x400）用于指示数据的某些内容。`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_C_CONTIGUOUS`和`NPY_ARRAY_F_CONTIGUOUS`标志实际上可以从其他参数中确定。标志`NPY_ARR_HAS_DESCR`（0x800）也可以设置为指示消耗版本 3 数组接口的对象，结构的 descr 成员存在（对于消耗版本 2 的数组接口的对象将被忽略）。

```py
*shape
```

包含每个维度中数组大小的数组。

```py
*strides
```

包含跳转到每个维度中下一个元素所需字节数的数组。

```py
void *data
```

指向数组第一个元素的指针。

```py
*descr
```

描述数据类型的 Python 对象更详细（与`__array_interface__`中的*descr*键相同）。如果*typekind*和*itemsize*提供足够信息，则此字段可以是`NULL`。除非*flags*中打开了`NPY_ARR_HAS_DESCR`标志，否则此字段也会被忽略。

### 内部使用的结构

在内部，代码主要用于内存管理的一些额外的 Python 对象。这些类型不能直接从 Python 访问，也未暴露给 C-API。它们仅在此列出，以完整和帮助理解代码。

```py
type PyUFunc_Loop1d
```

包含定义用户定义数据类型的每个签名的 1-d 循环所需信息的 C 结构的简单链接列表。

```py
PyArrayMapIter_Type
```

高级索引使用这种 Python 类型处理。它只是围绕包含高级数组索引所需变量的 C 结构的松散包装。

```py
type PyArrayMapIterObject
```

与`PyArrayMapIter_Type`相关联的 C 结构。如果您试图理解高级索引映射代码，这个结构非常有用。它在`arrayobject.h`头文件中定义。这种类型并未暴露给 Python，可以用 C 结构替代。作为 Python 类型，它利用引用计数的内存管理。
