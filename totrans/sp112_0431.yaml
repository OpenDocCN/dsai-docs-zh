- en: Optimization and root finding (scipy.optimize)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/optimize.html](https://docs.scipy.org/doc/scipy-1.12.0/reference/optimize.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SciPy `optimize` provides functions for minimizing (or maximizing) objective
    functions, possibly subject to constraints. It includes solvers for nonlinear
    problems (with support for both local and global optimization algorithms), linear
    programming, constrained and nonlinear least-squares, root finding, and curve
    fitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common functions and objects, shared across different solvers, are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`show_options`](generated/scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options")([solver, method, disp]) | Show documentation for
    additional options of optimization solvers. |'
  prefs: []
  type: TYPE_TB
- en: '| [`OptimizeResult`](generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") | Represents the optimization result. |'
  prefs: []
  type: TYPE_TB
- en: '| [`OptimizeWarning`](generated/scipy.optimize.OptimizeWarning.html#scipy.optimize.OptimizeWarning
    "scipy.optimize.OptimizeWarning") |  |'
  prefs: []
  type: TYPE_TB
- en: Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalar functions optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`minimize_scalar`](generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")(fun[, bracket, bounds, ...]) | Local minimization
    of scalar function of one variable. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`minimize_scalar`](generated/scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar") function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[minimize_scalar(method=’brent’)](optimize.minimize_scalar-brent.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize_scalar(method=’bounded’)](optimize.minimize_scalar-bounded.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize_scalar(method=’golden’)](optimize.minimize_scalar-golden.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local (multivariate) optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")(fun, x0[, args, method, jac, hess, ...]) | Minimization
    of scalar function of one or more variables. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[minimize(method=’Nelder-Mead’)](optimize.minimize-neldermead.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’Powell’)](optimize.minimize-powell.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’CG’)](optimize.minimize-cg.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’BFGS’)](optimize.minimize-bfgs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’Newton-CG’)](optimize.minimize-newtoncg.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’L-BFGS-B’)](optimize.minimize-lbfgsb.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’TNC’)](optimize.minimize-tnc.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’COBYLA’)](optimize.minimize-cobyla.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’SLSQP’)](optimize.minimize-slsqp.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’trust-constr’)](optimize.minimize-trustconstr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’dogleg’)](optimize.minimize-dogleg.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’trust-ncg’)](optimize.minimize-trustncg.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’trust-krylov’)](optimize.minimize-trustkrylov.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[minimize(method=’trust-exact’)](optimize.minimize-trustexact.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constraints are passed to [`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function as a single object or as a list of objects
    from the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`NonlinearConstraint`](generated/scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint")(fun, lb, ub[, jac, ...]) | Nonlinear constraint
    on the variables. |'
  prefs: []
  type: TYPE_TB
- en: '| [`LinearConstraint`](generated/scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")(A[, lb, ub, keep_feasible]) | Linear constraint
    on the variables. |'
  prefs: []
  type: TYPE_TB
- en: 'Simple bound constraints are handled separately and there is a special class
    for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`Bounds`](generated/scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")([lb, ub, keep_feasible])
    | Bounds constraint on the variables. |'
  prefs: []
  type: TYPE_TB
- en: 'Quasi-Newton strategies implementing [`HessianUpdateStrategy`](generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") interface can be used to approximate the
    Hessian in [`minimize`](generated/scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") function (available only for the ‘trust-constr’ method).
    Available quasi-Newton methods implementing this interface are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`BFGS`](generated/scipy.optimize.BFGS.html#scipy.optimize.BFGS "scipy.optimize.BFGS")([exception_strategy, min_curvature, ...])
    | Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy. |'
  prefs: []
  type: TYPE_TB
- en: '| [`SR1`](generated/scipy.optimize.SR1.html#scipy.optimize.SR1 "scipy.optimize.SR1")([min_denominator, init_scale])
    | Symmetric-rank-1 Hessian update strategy. |'
  prefs: []
  type: TYPE_TB
- en: '### Global optimization'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`basinhopping`](generated/scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping")(func, x0[, niter, T, stepsize, ...]) | Find the
    global minimum of a function using the basin-hopping algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`brute`](generated/scipy.optimize.brute.html#scipy.optimize.brute "scipy.optimize.brute")(func, ranges[, args, Ns, full_output, ...])
    | Minimize a function over a given range by brute force. |'
  prefs: []
  type: TYPE_TB
- en: '| [`differential_evolution`](generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution
    "scipy.optimize.differential_evolution")(func, bounds[, args, ...]) | Finds the
    global minimum of a multivariate function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`shgo`](generated/scipy.optimize.shgo.html#scipy.optimize.shgo "scipy.optimize.shgo")(func, bounds[, args, constraints, n, ...])
    | Finds the global minimum of a function using SHG optimization. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dual_annealing`](generated/scipy.optimize.dual_annealing.html#scipy.optimize.dual_annealing
    "scipy.optimize.dual_annealing")(func, bounds[, args, ...]) | Find the global
    minimum of a function using Dual Annealing. |'
  prefs: []
  type: TYPE_TB
- en: '| [`direct`](generated/scipy.optimize.direct.html#scipy.optimize.direct "scipy.optimize.direct")(func, bounds, *[, args, eps, maxfun, ...])
    | Finds the global minimum of a function using the DIRECT algorithm. |'
  prefs: []
  type: TYPE_TB
- en: Least-squares and curve fitting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nonlinear least-squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`least_squares`](generated/scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")(fun, x0[, jac, bounds, ...]) | Solve a nonlinear
    least-squares problem with bounds on the variables. |'
  prefs: []
  type: TYPE_TB
- en: Linear least-squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`nnls`](generated/scipy.optimize.nnls.html#scipy.optimize.nnls "scipy.optimize.nnls")(A, b[, maxiter, atol])
    | Solve `argmin_x &#124;&#124; Ax - b &#124;&#124;_2` for `x>=0`. |'
  prefs: []
  type: TYPE_TB
- en: '| [`lsq_linear`](generated/scipy.optimize.lsq_linear.html#scipy.optimize.lsq_linear
    "scipy.optimize.lsq_linear")(A, b[, bounds, method, tol, ...]) | Solve a linear
    least-squares problem with bounds on the variables. |'
  prefs: []
  type: TYPE_TB
- en: '| [`isotonic_regression`](generated/scipy.optimize.isotonic_regression.html#scipy.optimize.isotonic_regression
    "scipy.optimize.isotonic_regression")(y, *[, weights, increasing]) | Nonparametric
    isotonic regression. |'
  prefs: []
  type: TYPE_TB
- en: Curve fitting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`curve_fit`](generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit
    "scipy.optimize.curve_fit")(f, xdata, ydata[, p0, sigma, ...]) | Use non-linear
    least squares to fit a function, f, to data. |'
  prefs: []
  type: TYPE_TB
- en: Root finding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalar functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`root_scalar`](generated/scipy.optimize.root_scalar.html#scipy.optimize.root_scalar
    "scipy.optimize.root_scalar")(f[, args, method, bracket, ...]) | Find a root of
    a scalar function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`brentq`](generated/scipy.optimize.brentq.html#scipy.optimize.brentq "scipy.optimize.brentq")(f, a, b[, args, xtol, rtol, maxiter, ...])
    | Find a root of a function in a bracketing interval using Brent''s method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`brenth`](generated/scipy.optimize.brenth.html#scipy.optimize.brenth "scipy.optimize.brenth")(f, a, b[, args, xtol, rtol, maxiter, ...])
    | Find a root of a function in a bracketing interval using Brent''s method with
    hyperbolic extrapolation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ridder`](generated/scipy.optimize.ridder.html#scipy.optimize.ridder "scipy.optimize.ridder")(f, a, b[, args, xtol, rtol, maxiter, ...])
    | Find a root of a function in an interval using Ridder''s method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`bisect`](generated/scipy.optimize.bisect.html#scipy.optimize.bisect "scipy.optimize.bisect")(f, a, b[, args, xtol, rtol, maxiter, ...])
    | Find root of a function within an interval using bisection. |'
  prefs: []
  type: TYPE_TB
- en: '| [`newton`](generated/scipy.optimize.newton.html#scipy.optimize.newton "scipy.optimize.newton")(func, x0[, fprime, args, tol, ...])
    | Find a root of a real or complex function using the Newton-Raphson (or secant
    or Halley''s) method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`toms748`](generated/scipy.optimize.toms748.html#scipy.optimize.toms748
    "scipy.optimize.toms748")(f, a, b[, args, k, xtol, rtol, ...]) | Find a root using
    TOMS Algorithm 748 method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`RootResults`](generated/scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults")(root, iterations, ...) | Represents the root finding
    result. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`root_scalar`](generated/scipy.optimize.root_scalar.html#scipy.optimize.root_scalar
    "scipy.optimize.root_scalar") function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[root_scalar(method=’brentq’)](optimize.root_scalar-brentq.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’brenth’)](optimize.root_scalar-brenth.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’bisect’)](optimize.root_scalar-bisect.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’ridder’)](optimize.root_scalar-ridder.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’newton’)](optimize.root_scalar-newton.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’toms748’)](optimize.root_scalar-toms748.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’secant’)](optimize.root_scalar-secant.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root_scalar(method=’halley’)](optimize.root_scalar-halley.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table below lists situations and appropriate methods, along with *asymptotic*
    convergence rates per iteration (and per function evaluation) for successful convergence
    to a simple root(*). Bisection is the slowest of them all, adding one bit of accuracy
    for each function evaluation, but is guaranteed to converge. The other bracketing
    methods all (eventually) increase the number of accurate bits by about 50% for
    every function evaluation. The derivative-based methods, all built on [`newton`](generated/scipy.optimize.newton.html#scipy.optimize.newton
    "scipy.optimize.newton"), can converge quite quickly if the initial value is close
    to the root. They can also be applied to functions defined on (a subset of) the
    complex plane.
  prefs: []
  type: TYPE_NORMAL
- en: '| Domain of f | Bracket? | Derivatives? | Solvers | Convergence |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *fprime* | *fprime2* | Guaranteed? | Rate(s)(*) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *R* | Yes | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: bisection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: brentq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: brenth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ridder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: toms748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 1 “Linear”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '>=1, <= 1.62'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '>=1, <= 1.62'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.0 (1.41)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.7 (1.65)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| *R* or *C* | No | No | No | secant | No | 1.62 (1.62) |'
  prefs: []
  type: TYPE_TB
- en: '| *R* or *C* | No | Yes | No | newton | No | 2.00 (1.41) |'
  prefs: []
  type: TYPE_TB
- en: '| *R* or *C* | No | Yes | Yes | halley | No | 3.00 (1.44) |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.optimize.cython_optimize`](optimize.cython_optimize.html#module-scipy.optimize.cython_optimize
    "scipy.optimize.cython_optimize") – Typed Cython versions of root finding functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixed point finding:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fixed_point`](generated/scipy.optimize.fixed_point.html#scipy.optimize.fixed_point
    "scipy.optimize.fixed_point")(func, x0[, args, xtol, maxiter, ...]) | Find a fixed
    point of the function. |'
  prefs: []
  type: TYPE_TB
- en: Multidimensional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`root`](generated/scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root")(fun, x0[, args, method, jac, tol, ...])
    | Find a root of a vector function. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`root`](generated/scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root")
    function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[root(method=’hybr’)](optimize.root-hybr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’lm’)](optimize.root-lm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’broyden1’)](optimize.root-broyden1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’broyden2’)](optimize.root-broyden2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’anderson’)](optimize.root-anderson.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’linearmixing’)](optimize.root-linearmixing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’diagbroyden’)](optimize.root-diagbroyden.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’excitingmixing’)](optimize.root-excitingmixing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’krylov’)](optimize.root-krylov.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[root(method=’df-sane’)](optimize.root-dfsane.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linear programming / MILP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`milp`](generated/scipy.optimize.milp.html#scipy.optimize.milp "scipy.optimize.milp")(c, *[, integrality, bounds, ...])
    | Mixed-integer linear programming |'
  prefs: []
  type: TYPE_TB
- en: '| [`linprog`](generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog")(c[, A_ub, b_ub, A_eq, b_eq, bounds, ...]) | Linear programming:
    minimize a linear objective function subject to linear equality and inequality
    constraints. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`linprog`](generated/scipy.optimize.linprog.html#scipy.optimize.linprog
    "scipy.optimize.linprog") function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[linprog(method=’simplex’)](optimize.linprog-simplex.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linprog(method=’interior-point’)](optimize.linprog-interior-point.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linprog(method=’revised simplex’)](optimize.linprog-revised_simplex.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linprog(method=’highs-ipm’)](optimize.linprog-highs-ipm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linprog(method=’highs-ds’)](optimize.linprog-highs-ds.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[linprog(method=’highs’)](optimize.linprog-highs.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The simplex, interior-point, and revised simplex methods support callback functions,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`linprog_verbose_callback`](generated/scipy.optimize.linprog_verbose_callback.html#scipy.optimize.linprog_verbose_callback
    "scipy.optimize.linprog_verbose_callback")(res) | A sample callback function demonstrating
    the linprog callback interface. |'
  prefs: []
  type: TYPE_TB
- en: Assignment problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`linear_sum_assignment`](generated/scipy.optimize.linear_sum_assignment.html#scipy.optimize.linear_sum_assignment
    "scipy.optimize.linear_sum_assignment") | Solve the linear sum assignment problem.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`quadratic_assignment`](generated/scipy.optimize.quadratic_assignment.html#scipy.optimize.quadratic_assignment
    "scipy.optimize.quadratic_assignment")(A, B[, method, options]) | Approximates
    solution to the quadratic assignment problem and the graph matching problem. |'
  prefs: []
  type: TYPE_TB
- en: 'The [`quadratic_assignment`](generated/scipy.optimize.quadratic_assignment.html#scipy.optimize.quadratic_assignment
    "scipy.optimize.quadratic_assignment") function supports the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[quadratic_assignment(method=’faq’)](optimize.qap-faq.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[quadratic_assignment(method=’2opt’)](optimize.qap-2opt.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finite-difference approximation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`approx_fprime`](generated/scipy.optimize.approx_fprime.html#scipy.optimize.approx_fprime
    "scipy.optimize.approx_fprime")(xk, f[, epsilon]) | Finite difference approximation
    of the derivatives of a scalar or vector-valued function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`check_grad`](generated/scipy.optimize.check_grad.html#scipy.optimize.check_grad
    "scipy.optimize.check_grad")(func, grad, x0, *args[, epsilon, ...]) | Check the
    correctness of a gradient function by comparing it against a (forward) finite-difference
    approximation of the gradient. |'
  prefs: []
  type: TYPE_TB
- en: Line search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`bracket`](generated/scipy.optimize.bracket.html#scipy.optimize.bracket
    "scipy.optimize.bracket")(func[, xa, xb, args, grow_limit, ...]) | Bracket the
    minimum of a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`line_search`](generated/scipy.optimize.line_search.html#scipy.optimize.line_search
    "scipy.optimize.line_search")(f, myfprime, xk, pk[, gfk, ...]) | Find alpha that
    satisfies strong Wolfe conditions. |'
  prefs: []
  type: TYPE_TB
- en: Hessian approximation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`LbfgsInvHessProduct`](generated/scipy.optimize.LbfgsInvHessProduct.html#scipy.optimize.LbfgsInvHessProduct
    "scipy.optimize.LbfgsInvHessProduct")(*args, **kwargs) | Linear operator for the
    L-BFGS approximate inverse Hessian. |'
  prefs: []
  type: TYPE_TB
- en: '| [`HessianUpdateStrategy`](generated/scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy")() | Interface for implementing Hessian
    update strategies. |'
  prefs: []
  type: TYPE_TB
- en: Benchmark problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`rosen`](generated/scipy.optimize.rosen.html#scipy.optimize.rosen "scipy.optimize.rosen")(x)
    | The Rosenbrock function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rosen_der`](generated/scipy.optimize.rosen_der.html#scipy.optimize.rosen_der
    "scipy.optimize.rosen_der")(x) | The derivative (i.e. gradient) of the Rosenbrock
    function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rosen_hess`](generated/scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess
    "scipy.optimize.rosen_hess")(x) | The Hessian matrix of the Rosenbrock function.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`rosen_hess_prod`](generated/scipy.optimize.rosen_hess_prod.html#scipy.optimize.rosen_hess_prod
    "scipy.optimize.rosen_hess_prod")(x, p) | Product of the Hessian matrix of the
    Rosenbrock function with a vector. |'
  prefs: []
  type: TYPE_TB
- en: Legacy functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions below are not recommended for use in new scripts; all of these
    methods are accessible via a newer, more consistent interfaces, provided by the
    interfaces above.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'General-purpose multivariate methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fmin`](generated/scipy.optimize.fmin.html#scipy.optimize.fmin "scipy.optimize.fmin")(func, x0[, args, xtol, ftol, maxiter, ...])
    | Minimize a function using the downhill simplex algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_powell`](generated/scipy.optimize.fmin_powell.html#scipy.optimize.fmin_powell
    "scipy.optimize.fmin_powell")(func, x0[, args, xtol, ftol, ...]) | Minimize a
    function using modified Powell''s method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_cg`](generated/scipy.optimize.fmin_cg.html#scipy.optimize.fmin_cg
    "scipy.optimize.fmin_cg")(f, x0[, fprime, args, gtol, norm, ...]) | Minimize a
    function using a nonlinear conjugate gradient algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_bfgs`](generated/scipy.optimize.fmin_bfgs.html#scipy.optimize.fmin_bfgs
    "scipy.optimize.fmin_bfgs")(f, x0[, fprime, args, gtol, norm, ...]) | Minimize
    a function using the BFGS algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_ncg`](generated/scipy.optimize.fmin_ncg.html#scipy.optimize.fmin_ncg
    "scipy.optimize.fmin_ncg")(f, x0, fprime[, fhess_p, fhess, ...]) | Unconstrained
    minimization of a function using the Newton-CG method. |'
  prefs: []
  type: TYPE_TB
- en: 'Constrained multivariate methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fmin_l_bfgs_b`](generated/scipy.optimize.fmin_l_bfgs_b.html#scipy.optimize.fmin_l_bfgs_b
    "scipy.optimize.fmin_l_bfgs_b")(func, x0[, fprime, args, ...]) | Minimize a function
    func using the L-BFGS-B algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_tnc`](generated/scipy.optimize.fmin_tnc.html#scipy.optimize.fmin_tnc
    "scipy.optimize.fmin_tnc")(func, x0[, fprime, args, ...]) | Minimize a function
    with variables subject to bounds, using gradient information in a truncated Newton
    algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_cobyla`](generated/scipy.optimize.fmin_cobyla.html#scipy.optimize.fmin_cobyla
    "scipy.optimize.fmin_cobyla")(func, x0, cons[, args, ...]) | Minimize a function
    using the Constrained Optimization By Linear Approximation (COBYLA) method. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fmin_slsqp`](generated/scipy.optimize.fmin_slsqp.html#scipy.optimize.fmin_slsqp
    "scipy.optimize.fmin_slsqp")(func, x0[, eqcons, f_eqcons, ...]) | Minimize a function
    using Sequential Least Squares Programming |'
  prefs: []
  type: TYPE_TB
- en: 'Univariate (scalar) minimization methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fminbound`](generated/scipy.optimize.fminbound.html#scipy.optimize.fminbound
    "scipy.optimize.fminbound")(func, x1, x2[, args, xtol, ...]) | Bounded minimization
    for scalar functions. |'
  prefs: []
  type: TYPE_TB
- en: '| [`brent`](generated/scipy.optimize.brent.html#scipy.optimize.brent "scipy.optimize.brent")(func[, args, brack, tol, full_output, ...])
    | Given a function of one variable and a possible bracket, return a local minimizer
    of the function isolated to a fractional precision of tol. |'
  prefs: []
  type: TYPE_TB
- en: '| [`golden`](generated/scipy.optimize.golden.html#scipy.optimize.golden "scipy.optimize.golden")(func[, args, brack, tol, ...])
    | Return the minimizer of a function of one variable using the golden section
    method. |'
  prefs: []
  type: TYPE_TB
- en: Least-squares
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| [`leastsq`](generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq
    "scipy.optimize.leastsq")(func, x0[, args, Dfun, full_output, ...]) | Minimize
    the sum of squares of a set of equations. |'
  prefs: []
  type: TYPE_TB
- en: Root finding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'General nonlinear solvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`fsolve`](generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve "scipy.optimize.fsolve")(func, x0[, args, fprime, ...])
    | Find the roots of a function. |'
  prefs: []
  type: TYPE_TB
- en: '| [`broyden1`](generated/scipy.optimize.broyden1.html#scipy.optimize.broyden1
    "scipy.optimize.broyden1")(F, xin[, iter, alpha, ...]) | Find a root of a function,
    using Broyden''s first Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`broyden2`](generated/scipy.optimize.broyden2.html#scipy.optimize.broyden2
    "scipy.optimize.broyden2")(F, xin[, iter, alpha, ...]) | Find a root of a function,
    using Broyden''s second Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
- en: 'Large-scale nonlinear solvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`newton_krylov`](generated/scipy.optimize.newton_krylov.html#scipy.optimize.newton_krylov
    "scipy.optimize.newton_krylov")(F, xin[, iter, rdiff, method, ...]) | Find a root
    of a function, using Krylov approximation for inverse Jacobian. |'
  prefs: []
  type: TYPE_TB
- en: '| [`anderson`](generated/scipy.optimize.anderson.html#scipy.optimize.anderson
    "scipy.optimize.anderson")(F, xin[, iter, alpha, w0, M, ...]) | Find a root of
    a function, using (extended) Anderson mixing. |'
  prefs: []
  type: TYPE_TB
- en: '| [`BroydenFirst`](generated/scipy.optimize.BroydenFirst.html#scipy.optimize.BroydenFirst
    "scipy.optimize.BroydenFirst")([alpha, reduction_method, max_rank]) | Find a root
    of a function, using Broyden''s first Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`InverseJacobian`](generated/scipy.optimize.InverseJacobian.html#scipy.optimize.InverseJacobian
    "scipy.optimize.InverseJacobian")(jacobian) |'
  prefs: []
  type: TYPE_TB
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`KrylovJacobian`](generated/scipy.optimize.KrylovJacobian.html#scipy.optimize.KrylovJacobian
    "scipy.optimize.KrylovJacobian")([rdiff, method, ...]) | Find a root of a function,
    using Krylov approximation for inverse Jacobian. |'
  prefs: []
  type: TYPE_TB
- en: 'Simple iteration solvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| [`excitingmixing`](generated/scipy.optimize.excitingmixing.html#scipy.optimize.excitingmixing
    "scipy.optimize.excitingmixing")(F, xin[, iter, alpha, ...]) | Find a root of
    a function, using a tuned diagonal Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`linearmixing`](generated/scipy.optimize.linearmixing.html#scipy.optimize.linearmixing
    "scipy.optimize.linearmixing")(F, xin[, iter, alpha, verbose, ...]) | Find a root
    of a function, using a scalar Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
- en: '| [`diagbroyden`](generated/scipy.optimize.diagbroyden.html#scipy.optimize.diagbroyden
    "scipy.optimize.diagbroyden")(F, xin[, iter, alpha, verbose, ...]) | Find a root
    of a function, using diagonal Broyden Jacobian approximation. |'
  prefs: []
  type: TYPE_TB
