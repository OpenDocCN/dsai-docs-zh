- en: scipy.linalg.ordqz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.ordqz.html#scipy.linalg.ordqz](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.ordqz.html#scipy.linalg.ordqz)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: QZ decomposition for a pair of matrices with reordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: 2-D array to decompose
  prefs: []
  type: TYPE_NORMAL
- en: '**B**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: 2-D array to decompose
  prefs: []
  type: TYPE_NORMAL
- en: '**sort**{callable, ‘lhp’, ‘rhp’, ‘iuc’, ‘ouc’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifies whether the upper eigenvalues should be sorted. A callable may be
    passed that, given an ordered pair `(alpha, beta)` representing the eigenvalue
    `x = (alpha/beta)`, returns a boolean denoting whether the eigenvalue should be
    sorted to the top-left (True). For the real matrix pairs `beta` is real while
    `alpha` can be complex, and for complex matrix pairs both `alpha` and `beta` can
    be complex. The callable must be able to accept a NumPy array. Alternatively,
    string parameters may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘lhp’ Left-hand plane (x.real < 0.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rhp’ Right-hand plane (x.real > 0.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘iuc’ Inside the unit circle (x*x.conjugate() < 1.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘ouc’ Outside the unit circle (x*x.conjugate() > 1.0)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: With the predefined sorting functions, an infinite eigenvalue (i.e., `alpha
    != 0` and `beta = 0`) is considered to lie in neither the left-hand nor the right-hand
    plane, but it is considered to lie outside the unit circle. For the eigenvalue
    `(alpha, beta) = (0, 0)`, the predefined sorting functions all return *False*.
  prefs: []
  type: TYPE_NORMAL
- en: '**output**str {‘real’,’complex’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the real or complex QZ decomposition for real matrices. Default is
    ‘real’.
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_a**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the contents of A are overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_b**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the contents of B are overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: '**check_finite**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If true checks the elements of *A* and *B* are finite numbers. If false does
    no checking and passes matrix through to underlying algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AA**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized Schur form of A.
  prefs: []
  type: TYPE_NORMAL
- en: '**BB**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized Schur form of B.
  prefs: []
  type: TYPE_NORMAL
- en: '**alpha**(N,) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: alpha = alphar + alphai * 1j. See notes.
  prefs: []
  type: TYPE_NORMAL
- en: '**beta**(N,) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: See notes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The left Schur vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**(N, N) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The right Schur vectors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`qz`](scipy.linalg.qz.html#scipy.linalg.qz "scipy.linalg.qz")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: On exit, `(ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N`, will be the generalized
    eigenvalues. `ALPHAR(j) + ALPHAI(j)*i` and `BETA(j),j=1,...,N` are the diagonals
    of the complex Schur form (S,T) that would result if the 2-by-2 diagonal blocks
    of the real generalized Schur form of (A,B) were further reduced to triangular
    form using complex unitary transformations. If ALPHAI(j) is zero, then the jth
    eigenvalue is real; if positive, then the `j`th and `(j+1)`st eigenvalues are
    a complex conjugate pair, with `ALPHAI(j+1)` negative.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.17.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we have sorted for left half plane eigenvalues, negatives come first
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
