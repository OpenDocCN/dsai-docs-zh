# 多项式操作模块参考

> 原文：[`docs.sympy.org/latest/modules/polys/reference.html`](https://docs.sympy.org/latest/modules/polys/reference.html)

多项式操作算法和代数对象。

请查看多项式操作以获取 polys 模块文档的索引和模块的基本功能以获取简介性说明。

## 基本多项式操作函数

```py
sympy.polys.polytools.poly(expr, *gens, **args)
```

将表达式有效地转换为多项式。

示例

```py
>>> from sympy import poly
>>> from sympy.abc import x 
```

```py
>>> poly(x*(x**2 + x - 1)**2)
Poly(x**5 + 2*x**4 - x**3 - 2*x**2 + x, x, domain='ZZ') 
```

```py
sympy.polys.polytools.poly_from_expr(expr, *gens, **args)
```

从表达式构造一个多项式。

```py
sympy.polys.polytools.parallel_poly_from_expr(exprs, *gens, **args)
```

从表达式构造多项式。

```py
sympy.polys.polytools.degree(f, gen=0)
```

返回 `f` 在给定变量中的次数。

0 的次数为负无穷大。

示例

```py
>>> from sympy import degree
>>> from sympy.abc import x, y 
```

```py
>>> degree(x**2 + y*x + 1, gen=x)
2
>>> degree(x**2 + y*x + 1, gen=y)
1
>>> degree(0, x)
-oo 
```

另请参阅

`sympy.polys.polytools.Poly.total_degree`，`degree_list`

```py
sympy.polys.polytools.degree_list(f, *gens, **args)
```

返回 `f` 在所有变量中的次数列表。

示例

```py
>>> from sympy import degree_list
>>> from sympy.abc import x, y 
```

```py
>>> degree_list(x**2 + y*x + 1)
(2, 1) 
```

```py
sympy.polys.polytools.LC(f, *gens, **args)
```

返回多项式 `f` 的首项系数。

示例

```py
>>> from sympy import LC
>>> from sympy.abc import x, y 
```

```py
>>> LC(4*x**2 + 2*x*y**2 + x*y + 3*y)
4 
```

```py
sympy.polys.polytools.LM(f, *gens, **args)
```

返回 `f` 的首项单项式。

示例

```py
>>> from sympy import LM
>>> from sympy.abc import x, y 
```

```py
>>> LM(4*x**2 + 2*x*y**2 + x*y + 3*y)
x**2 
```

```py
sympy.polys.polytools.LT(f, *gens, **args)
```

返回 `f` 的首项。

示例

```py
>>> from sympy import LT
>>> from sympy.abc import x, y 
```

```py
>>> LT(4*x**2 + 2*x*y**2 + x*y + 3*y)
4*x**2 
```

```py
sympy.polys.polytools.pdiv(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的伪除法。

示例

```py
>>> from sympy import pdiv
>>> from sympy.abc import x 
```

```py
>>> pdiv(x**2 + 1, 2*x - 4)
(2*x + 4, 20) 
```

```py
sympy.polys.polytools.prem(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的伪余数。

示例

```py
>>> from sympy import prem
>>> from sympy.abc import x 
```

```py
>>> prem(x**2 + 1, 2*x - 4)
20 
```

```py
sympy.polys.polytools.pquo(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的精确伪商。

示例

```py
>>> from sympy import pquo
>>> from sympy.abc import x 
```

```py
>>> pquo(x**2 + 1, 2*x - 4)
2*x + 4
>>> pquo(x**2 - 1, 2*x - 1)
2*x + 1 
```

```py
sympy.polys.polytools.pexquo(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的精确伪商。

示例

```py
>>> from sympy import pexquo
>>> from sympy.abc import x 
```

```py
>>> pexquo(x**2 - 1, 2*x - 2)
2*x + 2 
```

```py
>>> pexquo(x**2 + 1, 2*x - 4)
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1 
```

```py
sympy.polys.polytools.div(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的除法。

示例

```py
>>> from sympy import div, ZZ, QQ
>>> from sympy.abc import x 
```

```py
>>> div(x**2 + 1, 2*x - 4, domain=ZZ)
(0, x**2 + 1)
>>> div(x**2 + 1, 2*x - 4, domain=QQ)
(x/2 + 1, 5) 
```

```py
sympy.polys.polytools.rem(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的余数。

示例

```py
>>> from sympy import rem, ZZ, QQ
>>> from sympy.abc import x 
```

```py
>>> rem(x**2 + 1, 2*x - 4, domain=ZZ)
x**2 + 1
>>> rem(x**2 + 1, 2*x - 4, domain=QQ)
5 
```

```py
sympy.polys.polytools.quo(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的商。

示例

```py
>>> from sympy import quo
>>> from sympy.abc import x 
```

```py
>>> quo(x**2 + 1, 2*x - 4)
x/2 + 1
>>> quo(x**2 - 1, x - 1)
x + 1 
```

```py
sympy.polys.polytools.exquo(f, g, *gens, **args)
```

计算多项式 `f` 和 `g` 的精确商。

示例

```py
>>> from sympy import exquo
>>> from sympy.abc import x 
```

```py
>>> exquo(x**2 - 1, x - 1)
x + 1 
```

```py
>>> exquo(x**2 + 1, 2*x - 4)
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1 
```

```py
sympy.polys.polytools.half_gcdex(f, g, *gens, **args)
```

`f` 和 `g` 的半扩展欧几里德算法。

返回 `(s, h)`，使得 `h = gcd(f, g)` 和 `s*f = h (mod g)`。

示例

```py
>>> from sympy import half_gcdex
>>> from sympy.abc import x 
```

```py
>>> half_gcdex(x**4 - 2*x**3 - 6*x**2 + 12*x + 15, x**3 + x**2 - 4*x - 4)
(3/5 - x/5, x + 1) 
```

```py
sympy.polys.polytools.gcdex(f, g, *gens, **args)
```

`f` 和 `g` 的扩展欧几里德算法。

返回 `(s, t, h)`，使得 `h = gcd(f, g)` 和 `s*f + t*g = h`。

示例

```py
>>> from sympy import gcdex
>>> from sympy.abc import x 
```

```py
>>> gcdex(x**4 - 2*x**3 - 6*x**2 + 12*x + 15, x**3 + x**2 - 4*x - 4)
(3/5 - x/5, x**2/5 - 6*x/5 + 2, x + 1) 
```

```py
sympy.polys.polytools.invert(f, g, *gens, **args)
```

在可能时对 `f` 模 `g` 取倒数。

示例

```py
>>> from sympy import invert, S, mod_inverse
>>> from sympy.abc import x 
```

```py
>>> invert(x**2 - 1, 2*x - 1)
-4/3 
```

```py
>>> invert(x**2 - 1, x - 1)
Traceback (most recent call last):
...
NotInvertible: zero divisor 
```

要更高效地求有理数的倒数，请使用`sympy.core.intfunc.mod_inverse`函数：

```py
>>> mod_inverse(3, 5)
2
>>> (S(2)/5).invert(S(7)/3)
5/2 
```

另请参阅

`sympy.core.intfunc.mod_inverse`

```py
sympy.polys.polytools.subresultants(f, g, *gens, **args)
```

计算 `f` 和 `g` 的子结果 PRS。

示例

```py
>>> from sympy import subresultants
>>> from sympy.abc import x 
```

```py
>>> subresultants(x**2 + 1, x**2 - 1)
[x**2 + 1, x**2 - 1, -2] 
```

```py
sympy.polys.polytools.resultant(f, g, *gens, includePRS=False, **args)
```

计算 `f` 和 `g` 的结果多项式。

示例

```py
>>> from sympy import resultant
>>> from sympy.abc import x 
```

```py
>>> resultant(x**2 + 1, x**2 - 1)
4 
```

```py
sympy.polys.polytools.discriminant(f, *gens, **args)
```

计算 `f` 的判别式。

示例

```py
>>> from sympy import discriminant
>>> from sympy.abc import x 
```

```py
>>> discriminant(x**2 + 2*x + 3)
-8 
```

```py
sympy.polys.polytools.terms_gcd(f, *gens, **args)
```

移除 `f` 中项的最大公因式。

如果 `deep` 标志为 True，则 `f` 的参数将应用 `terms_gcd` 到它们。

如果从 `f` 中分离出一个分数，并且 `f` 是一个加法表达式，则会返回一个未求值的乘法表达式，以避免自动化简时重新分配它。当 `clear` 标志设置为 False 时，可以防止这种分离，前提是所有系数都不是分数。

示例

```py
>>> from sympy import terms_gcd, cos
>>> from sympy.abc import x, y
>>> terms_gcd(x**6*y**2 + x**3*y, x, y)
x**3*y*(x**3*y + 1) 
```

polys 程序的默认操作是展开给定的表达式。`terms_gcd` 遵循此行为：

```py
>>> terms_gcd((3+3*x)*(x+x*y))
3*x*(x*y + x + y + 1) 
```

如果不需要这样做，则可以将提示 `expand` 设置为 False。在这种情况下，该表达式将被视为由一个或多个项组成：

```py
>>> terms_gcd((3+3*x)*(x+x*y), expand=False)
(3*x + 3)*(x*y + x) 
```

为了遍历 `Mul` 的因子或其他函数的参数，可以使用 `deep` 提示：

```py
>>> terms_gcd((3 + 3*x)*(x + x*y), expand=False, deep=True)
3*x*(x + 1)*(y + 1)
>>> terms_gcd(cos(x + x*y), deep=True)
cos(x*(y + 1)) 
```

有理数默认被分解出来：

```py
>>> terms_gcd(x + y/2)
(2*x + y)/2 
```

只有 `y` 项的系数是分数；如果不想在这种情况下因式分解 `1/2`，可以将标志 `clear` 设为 `False`：

```py
>>> terms_gcd(x + y/2, clear=False)
x + y/2
>>> terms_gcd(x*y/2 + y**2, clear=False)
y*(x/2 + y) 
```

如果所有系数都是分数，则忽略 `clear` 标志：

```py
>>> terms_gcd(x/3 + y/2, clear=False)
(2*x + 3*y)/6 
```

另请参阅

`sympy.core.exprtools.gcd_terms`, `sympy.core.exprtools.factor_terms`

```py
sympy.polys.polytools.cofactors(f, g, *gens, **args)
```

计算 `f` 和 `g` 的最大公约数及其余因子。

返回多项式 `(h, cff, cfg)`，使得 `h = gcd(f, g)`，`cff = quo(f, h)` 和 `cfg = quo(g, h)` 是所谓的 `f` 和 `g` 的余因子。

示例

```py
>>> from sympy import cofactors
>>> from sympy.abc import x 
```

```py
>>> cofactors(x**2 - 1, x**2 - 3*x + 2)
(x - 1, x + 1, x - 2) 
```

```py
sympy.polys.polytools.gcd(f, g=None, *gens, **args)
```

计算 `f` 和 `g` 的最大公约数。

示例

```py
>>> from sympy import gcd
>>> from sympy.abc import x 
```

```py
>>> gcd(x**2 - 1, x**2 - 3*x + 2)
x - 1 
```

```py
sympy.polys.polytools.gcd_list(seq, *gens, **args)
```

计算多项式列表的最大公约数。

示例

```py
>>> from sympy import gcd_list
>>> from sympy.abc import x 
```

```py
>>> gcd_list([x**3 - 1, x**2 - 1, x**2 - 3*x + 2])
x - 1 
```

```py
sympy.polys.polytools.lcm(f, g=None, *gens, **args)
```

计算 `f` 和 `g` 的最小公倍数。

示例

```py
>>> from sympy import lcm
>>> from sympy.abc import x 
```

```py
>>> lcm(x**2 - 1, x**2 - 3*x + 2)
x**3 - 2*x**2 - x + 2 
```

```py
sympy.polys.polytools.lcm_list(seq, *gens, **args)
```

计算多项式列表的最小公倍数。

示例

```py
>>> from sympy import lcm_list
>>> from sympy.abc import x 
```

```py
>>> lcm_list([x**3 - 1, x**2 - 1, x**2 - 3*x + 2])
x**5 - x**4 - 2*x**3 - x**2 + x + 2 
```

```py
sympy.polys.polytools.trunc(f, p, *gens, **args)
```

将 `f` 对常数 `p` 取模。

示例

```py
>>> from sympy import trunc
>>> from sympy.abc import x 
```

```py
>>> trunc(2*x**3 + 3*x**2 + 5*x + 7, 3)
-x**3 - x + 1 
```

```py
sympy.polys.polytools.monic(f, *gens, **args)
```

将 `f` 的所有系数除以 `LC(f)`。

示例

```py
>>> from sympy import monic
>>> from sympy.abc import x 
```

```py
>>> monic(3*x**2 + 4*x + 2)
x**2 + 4*x/3 + 2/3 
```

```py
sympy.polys.polytools.content(f, *gens, **args)
```

计算 `f` 的系数的最大公约数。

示例

```py
>>> from sympy import content
>>> from sympy.abc import x 
```

```py
>>> content(6*x**2 + 8*x + 12)
2 
```

```py
sympy.polys.polytools.primitive(f, *gens, **args)
```

计算 `f` 的内容和原始形式。

示例

```py
>>> from sympy.polys.polytools import primitive
>>> from sympy.abc import x 
```

```py
>>> primitive(6*x**2 + 8*x + 12)
(2, 3*x**2 + 4*x + 6) 
```

```py
>>> eq = (2 + 2*x)*x + 2 
```

默认执行展开：

```py
>>> primitive(eq)
(2, x**2 + x + 1) 
```

将 `expand` 设置为 `False` 可关闭此功能。请注意，提取将不会递归进行；使用 `as_content_primitive` 方法进行递归、非破坏性有理数提取。

```py
>>> primitive(eq, expand=False)
(1, x*(2*x + 2) + 2) 
```

```py
>>> eq.as_content_primitive()
(2, x*(x + 1) + 1) 
```

```py
sympy.polys.polytools.compose(f, g, *gens, **args)
```

计算函数组合 `f(g)`。

示例

```py
>>> from sympy import compose
>>> from sympy.abc import x 
```

```py
>>> compose(x**2 + x, x - 1)
x**2 - x 
```

```py
sympy.polys.polytools.decompose(f, *gens, **args)
```

计算 `f` 的函数分解。

示例

```py
>>> from sympy import decompose
>>> from sympy.abc import x 
```

```py
>>> decompose(x**4 + 2*x**3 - x - 1)
[x**2 - x - 1, x**2 + x] 
```

```py
sympy.polys.polytools.sturm(f, *gens, **args)
```

计算 `f` 的斯图姆序列。

示例

```py
>>> from sympy import sturm
>>> from sympy.abc import x 
```

```py
>>> sturm(x**3 - 2*x**2 + x - 3)
[x**3 - 2*x**2 + x - 3, 3*x**2 - 4*x + 1, 2*x/9 + 25/9, -2079/4] 
```

```py
sympy.polys.polytools.gff_list(f, *gens, **args)
```

计算 `f` 的最大阶乘因式列表。

注意，`ff()` 和 `rf()` 的输入应为 `Poly` 实例，以使用这里的定义。

示例

```py
>>> from sympy import gff_list, ff, Poly
>>> from sympy.abc import x 
```

```py
>>> f = Poly(x**5 + 2*x**4 - x**3 - 2*x**2, x) 
```

```py
>>> gff_list(f)
[(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)] 
```

```py
>>> (ff(Poly(x), 1)*ff(Poly(x + 2), 4)) == f
True 
```

```py
>>> f = Poly(x**12 + 6*x**11 - 11*x**10 - 56*x**9 + 220*x**8 + 208*x**7 -         1401*x**6 + 1090*x**5 + 2715*x**4 - 6720*x**3 - 1092*x**2 + 5040*x, x) 
```

```py
>>> gff_list(f)
[(Poly(x**3 + 7, x, domain='ZZ'), 2), (Poly(x**2 + 5*x, x, domain='ZZ'), 3)] 
```

```py
>>> ff(Poly(x**3 + 7, x), 2)*ff(Poly(x**2 + 5*x, x), 3) == f
True 
```

```py
sympy.polys.polytools.gff(f, *gens, **args)
```

计算 `f` 的最大阶乘因式分解。

```py
sympy.polys.polytools.sqf_norm(f, *gens, **args)
```

计算 `f` 的平方自由规范。

返回 `s`，`f`，`r`，使得 `g(x) = f(x-sa)` 和 `r(x) = Norm(g(x))` 是 `K` 上的平方自由多项式，其中 `a` 是基域的代数扩展。

示例

```py
>>> from sympy import sqf_norm, sqrt
>>> from sympy.abc import x 
```

```py
>>> sqf_norm(x**2 + 1, extension=[sqrt(3)])
([1], x**2 - 2*sqrt(3)*x + 4, x**4 - 4*x**2 + 16) 
```

```py
sympy.polys.polytools.sqf_part(f, *gens, **args)
```

计算 `f` 的平方自由部分。

示例

```py
>>> from sympy import sqf_part
>>> from sympy.abc import x 
```

```py
>>> sqf_part(x**3 - 3*x - 2)
x**2 - x - 2 
```

```py
sympy.polys.polytools.sqf_list(f, *gens, **args)
```

计算 `f` 的平方自由因式列表。

示例

```py
>>> from sympy import sqf_list
>>> from sympy.abc import x 
```

```py
>>> sqf_list(2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16)
(2, [(x + 1, 2), (x + 2, 3)]) 
```

```py
sympy.polys.polytools.sqf(f, *gens, **args)
```

计算 `f` 的平方自由因式分解。

示例

```py
>>> from sympy import sqf
>>> from sympy.abc import x 
```

```py
>>> sqf(2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16)
2*(x + 1)**2*(x + 2)**3 
```

```py
sympy.polys.polytools.factor_list(f, *gens, **args)
```

计算 `f` 的不可约因式列表。

示例

```py
>>> from sympy import factor_list
>>> from sympy.abc import x, y 
```

```py
>>> factor_list(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)
(2, [(x + y, 1), (x**2 + 1, 2)]) 
```

```py
sympy.polys.polytools.factor(f, *gens, deep=False, **args)
```

计算表达式 `f` 的因式分解为不可约因式。（要将整数因式分解为质数，请使用 `factorint`。）

有两种实现模式：符号模式和形式模式。如果 `f` 不是 `Poly` 的实例，并且未指定生成器，则使用前者模式。否则，使用形式模式。

在符号模式下，`factor()` 将遍历表达式树并分解其组件，不进行先前的展开，除非遇到 `Add` 的实例（在这种情况下使用形式分解）。这样 `factor()` 可以处理大或符号指数。

默认情况下，因子分解是在有理数上计算的。要在其他域上进行因子分解，例如代数或有限域，请使用适当的选项：`extension`、`modulus` 或 `domain`。

示例

```py
>>> from sympy import factor, sqrt, exp
>>> from sympy.abc import x, y 
```

```py
>>> factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)
2*(x + y)*(x**2 + 1)**2 
```

```py
>>> factor(x**2 + 1)
x**2 + 1
>>> factor(x**2 + 1, modulus=2)
(x + 1)**2
>>> factor(x**2 + 1, gaussian=True)
(x - I)*(x + I) 
```

```py
>>> factor(x**2 - 2, extension=sqrt(2))
(x - sqrt(2))*(x + sqrt(2)) 
```

```py
>>> factor((x**2 - 1)/(x**2 + 4*x + 4))
(x - 1)*(x + 1)/(x + 2)**2
>>> factor((x**2 + 4*x + 4)**10000000*(x**2 + 1))
(x + 2)**20000000*(x**2 + 1) 
```

默认情况下，因子处理整个表达式：

```py
>>> eq = 2**(x**2 + 2*x + 1)
>>> factor(eq)
2**(x**2 + 2*x + 1) 
```

如果 `deep` 标志为 True 则将分解子表达式：

```py
>>> factor(eq, deep=True)
2**((x + 1)**2) 
```

如果 `fraction` 标志为 False，则不会合并有理表达式。默认为 True。

```py
>>> factor(5*x + 3*exp(2 - 7*x), deep=True)
(5*x*exp(7*x) + 3*exp(2))*exp(-7*x)
>>> factor(5*x + 3*exp(2 - 7*x), deep=True, fraction=False)
5*x + 3*exp(2)*exp(-7*x) 
```

另请参阅

`sympy.ntheory.factor_.factorint`

```py
sympy.polys.polytools.intervals(F, all=False, eps=None, inf=None, sup=None, strict=False, fast=False, sqf=False)
```

计算 `f` 的根的隔离区间。

示例

```py
>>> from sympy import intervals
>>> from sympy.abc import x 
```

```py
>>> intervals(x**2 - 3)
[((-2, -1), 1), ((1, 2), 1)]
>>> intervals(x**2 - 3, eps=1e-2)
[((-26/15, -19/11), 1), ((19/11, 26/15), 1)] 
```

```py
sympy.polys.polytools.refine_root(f, s, t, eps=None, steps=None, fast=False, check_sqf=False)
```

将根的隔离区间精确化到给定的精度。

示例

```py
>>> from sympy import refine_root
>>> from sympy.abc import x 
```

```py
>>> refine_root(x**2 - 3, 1, 2, eps=1e-2)
(19/11, 26/15) 
```

```py
sympy.polys.polytools.count_roots(f, inf=None, sup=None)
```

返回在 `[inf, sup]` 区间内 `f` 的根数。

如果 `inf` 或 `sup` 中的一个是复数，则将返回在以 `inf` 和 `sup` 为角的复数矩形中的根数。

示例

```py
>>> from sympy import count_roots, I
>>> from sympy.abc import x 
```

```py
>>> count_roots(x**4 - 4, -3, 3)
2
>>> count_roots(x**4 - 4, 0, 1 + 3*I)
1 
```

```py
sympy.polys.polytools.all_roots(f, multiple=True, radicals=True)
```

返回 `f` 的实数和复数根及其重数。

参数：

**f**：`Expr` 或 `Poly`

> 一元有理（或 `Float`）系数的多项式。

**multiple**：`bool`（默认为 `True`）。

> 是否返回根的 `list` 或根/重数对的列表。

**radicals**：`bool`（默认为 `True`）

> 对于一些无理根，使用简单的根式公式而不是 `ComplexRootOf`。

返回：

`Expr` 的列表（通常是 `ComplexRootOf`）表示

返回的根根据其重数重复显示每个根

作为 `f` 的根。根总是以实根唯一的顺序排列

在复数根之前。实根按增加顺序排列。

复数根按递增的实部和递增的顺序排列

虚部。

如果传递 `multiple=False` 则会返回根/重数对的列表

替代返回。

如果传递 `radicals=False` 则所有根将表示为

要么是有理数，要么是 `ComplexRootOf`。

解释

准确找到具有任意次有理系数的一元多项式的所有实数和复数根。根据 `rootof()` 给出的形式表示根。这等同于使用 `rootof()` 找到每个索引根。

示例

```py
>>> from sympy import all_roots
>>> from sympy.abc import x, y 
```

```py
>>> print(all_roots(x**3 + 1))
[-1, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2] 
```

在某些情况下使用简单的根式公式，但避免使用三次和四次公式。相反，大多数非有理根将表示为 `ComplexRootOf`：

```py
>>> print(all_roots(x**3 + x + 1))
[CRootOf(x**3 + x + 1, 0), CRootOf(x**3 + x + 1, 1), CRootOf(x**3 + x + 1, 2)] 
```

任何次数的有理系数多项式的所有根都可以用 `ComplexRootOf` 表示。 使用 `ComplexRootOf` 可以绕过关于五次及更高次多项式根式公式可用性的限制 _[1]：

```py
>>> p = x**5 - x - 1
>>> for r in all_roots(p): print(r)
CRootOf(x**5 - x - 1, 0)
CRootOf(x**5 - x - 1, 1)
CRootOf(x**5 - x - 1, 2)
CRootOf(x**5 - x - 1, 3)
CRootOf(x**5 - x - 1, 4)
>>> [r.evalf(3) for r in all_roots(p)]
[1.17, -0.765 - 0.352*I, -0.765 + 0.352*I, 0.181 - 1.08*I, 0.181 + 1.08*I] 
```

目前无法处理无理代数或超越系数 `all_roots()`（或一般上更广义的 `rootof()`）：

```py
>>> from sympy import sqrt, expand
>>> p = expand((x - sqrt(2))*(x - sqrt(3)))
>>> print(p)
x**2 - sqrt(3)*x - sqrt(2)*x + sqrt(6)
>>> all_roots(p)
Traceback (most recent call last):
...
NotImplementedError: sorted roots not supported over EX 
```

对于代数或超越系数，`ground_roots()` 可能能够通过因式分解找到一些根：

```py
>>> from sympy import ground_roots
>>> ground_roots(p, x, extension=True)
{sqrt(2): 1, sqrt(3): 1} 
```

如果系数是数值的，则可以使用`nroots()`来找到所有根的近似值：

```py
>>> from sympy import nroots
>>> nroots(p, 5)
[1.4142, 1.732] 
```

如果系数是符号的，则应使用`sympy.polys.polyroots.roots()`或`ground_roots()`：

```py
>>> from sympy import roots, ground_roots
>>> p = x**2 - 3*x*y + 2*y**2
>>> roots(p, x)
{y: 1, 2*y: 1}
>>> ground_roots(p, x)
{y: 1, 2*y: 1} 
```

另见

`Poly.all_roots`

`all_roots()` 使用的底层 `Poly` 方法。

`rootof`

计算单个一元多项式的编号根。

`real_roots`

使用 `rootof()` 计算所有实根。

`ground_roots`

通过因式分解计算地域域中的一些根。

`nroots`

使用近似数值技术计算所有根。

`sympy.polys.polyroots.roots`

使用根式公式计算根的符号表达式。

参考资料

[R808]

[`en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem`](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)

```py
sympy.polys.polytools.real_roots(f, multiple=True, radicals=True)
```

返回 `f` 的实根及其重数。

参数：

**f**：`Expr` 或 `Poly`

> 一元有理（或`Float`）系数的多项式。

**多重**：`bool`（默认`True`）。

> 是否返回根的列表或根/重数对列表。

**根式**：`bool`（默认`True`）

> 对于一些无理根，使用简单的根式公式而不是`ComplexRootOf`。

返回：

一个`Expr`列表（通常为`ComplexRootOf`）表示

返回实根。 根据增加顺序排列的根和

根据它们作为`f`的根的重数重复。

如果传递了`multiple=False`，则将返回根/重数对列表

返回。

如果传递了`radicals=False`，则所有根将表示为

要么有理数，要么`ComplexRootOf`。

解释

找到具有任意次数有理系数的一元多项式的所有实根。 根据`rootof()`给出的形式表示根。 这相当于使用`rootof()`或`all_roots()`并仅过滤出实根。 但是，如果只需要实根，则`real_roots()`比`all_roots()`更有效，因为它仅计算实根，并避免昂贵的复数根隔离程序。

示例

```py
>>> from sympy import real_roots
>>> from sympy.abc import x, y 
```

```py
>>> real_roots(2*x**3 - 7*x**2 + 4*x + 4)
[-1/2, 2, 2]
>>> real_roots(2*x**3 - 7*x**2 + 4*x + 4, multiple=False)
[(-1/2, 1), (2, 2)] 
```

任何次数的具有有理系数的多项式的实根可以使用`ComplexRootOf`表示：

```py
>>> p = x**9 + 2*x + 2
>>> print(real_roots(p))
[CRootOf(x**9 + 2*x + 2, 0)]
>>> [r.evalf(3) for r in real_roots(p)]
[-0.865] 
```

所有有理根将作为有理数返回。 一些简单因子的根将使用根式或其他公式表示（除非传递了`radicals=False`）。 所有其他根将表示为`ComplexRootOf`。

```py
>>> p = (x + 7)*(x**2 - 2)*(x**3 + x + 1)
>>> print(real_roots(p))
[-7, -sqrt(2), CRootOf(x**3 + x + 1, 0), sqrt(2)]
>>> print(real_roots(p, radicals=False))
[-7, CRootOf(x**2 - 2, 0), CRootOf(x**3 + x + 1, 0), CRootOf(x**2 - 2, 1)] 
```

返回的所有根表达式将数值评估为没有虚部的实数。 这与由`roots()`使用的三次或四次公式生成的表达式形成对比，这些表达式受到由 casus irreducibilis 引起的影响[[R809]](#r809)：

```py
>>> from sympy import roots
>>> p = 2*x**3 - 9*x**2 - 6*x + 3
>>> [r.evalf(5) for r in roots(p, multiple=True)]
[5.0365 - 0.e-11*I, 0.33984 + 0.e-13*I, -0.87636 + 0.e-10*I]
>>> [r.evalf(5) for r in real_roots(p, x)]
[-0.87636, 0.33984, 5.0365]
>>> [r.is_real for r in roots(p, multiple=True)]
[None, None, None]
>>> [r.is_real for r in real_roots(p)]
[True, True, True] 
```

使用`real_roots()`等同于使用`all_roots()`（或`rootof()`）并仅过滤出实根：

```py
>>> from sympy import all_roots
>>> r = [r for r in all_roots(p) if r.is_real]
>>> real_roots(p) == r
True 
```

如果只想要实根，则使用 `real_roots()` 比使用 `all_roots()` 更快。使用 `real_roots()` 避免了复杂根的隔离，后者在处理高阶多项式时通常比实根隔离要慢得多，因为高阶多项式通常有比实根多得多的复杂根。

无法处理无理代数或超越系数的 `real_roots()`（或更一般地 `rootof()`）：

```py
>>> from sympy import sqrt, expand
>>> p = expand((x - sqrt(2))*(x - sqrt(3)))
>>> print(p)
x**2 - sqrt(3)*x - sqrt(2)*x + sqrt(6)
>>> real_roots(p)
Traceback (most recent call last):
...
NotImplementedError: sorted roots not supported over EX 
```

对于代数或超越系数的情况，`ground_roots()` 可能通过因式分解找到一些根：

```py
>>> from sympy import ground_roots
>>> ground_roots(p, x, extension=True)
{sqrt(2): 1, sqrt(3): 1} 
```

如果系数是数字的话，可以使用 `nroots()` 大致找出所有根：

```py
>>> from sympy import nroots
>>> nroots(p, 5)
[1.4142, 1.732] 
```

如果系数是符号的话，则应使用 `sympy.polys.polyroots.roots()` 或 `ground_roots()`。

```py
>>> from sympy import roots, ground_roots
>>> p = x**2 - 3*x*y + 2*y**2
>>> roots(p, x)
{y: 1, 2*y: 1}
>>> ground_roots(p, x)
{y: 1, 2*y: 1} 
```

另见

`Poly.real_roots`

`real_roots()` 使用的底层 `Poly` 方法。

`rootof`

计算单个多项式的编号根。

`all_roots`

使用 `rootof()` 计算所有实根和非实根。

`ground_roots`

通过因式分解在基域中计算一些根。

`nroots`

使用近似数值技术计算所有根。

`sympy.polys.polyroots.roots`

使用根式公式计算 `f` 的根。

参考

[R809] (1,2)

[`en.wikipedia.org/wiki/Casus_irreducibilis`](https://en.wikipedia.org/wiki/Casus_irreducibilis)

```py
sympy.polys.polytools.nroots(f, n=15, maxsteps=50, cleanup=True)
```

使用数值近似方法计算 `f` 的根。

示例

```py
>>> from sympy import nroots
>>> from sympy.abc import x 
```

```py
>>> nroots(x**2 - 3, n=15)
[-1.73205080756888, 1.73205080756888]
>>> nroots(x**2 - 3, n=30)
[-1.73205080756887729352744634151, 1.73205080756887729352744634151] 
```

```py
sympy.polys.polytools.ground_roots(f, *gens, **args)
```

通过因式分解在基域中计算 `f` 的根。

示例

```py
>>> from sympy import ground_roots
>>> from sympy.abc import x 
```

```py
>>> ground_roots(x**6 - 4*x**4 + 4*x**3 - x**2)
{0: 2, 1: 2} 
```

```py
sympy.polys.polytools.nth_power_roots_poly(f, n, *gens, **args)
```

构造一个多项式，其根的 n 次方是 `f` 的根。

示例

```py
>>> from sympy import nth_power_roots_poly, factor, roots
>>> from sympy.abc import x 
```

```py
>>> f = x**4 - x**2 + 1
>>> g = factor(nth_power_roots_poly(f, 2)) 
```

```py
>>> g
(x**2 - x + 1)**2 
```

```py
>>> R_f = [ (r**2).expand() for r in roots(f) ]
>>> R_g = roots(g).keys() 
```

```py
>>> set(R_f) == set(R_g)
True 
```

```py
sympy.polys.polytools.cancel(f, *gens, _signsimp=True, **args)
```

取消有理函数 `f` 中的公因子。

示例

```py
>>> from sympy import cancel, sqrt, Symbol, together
>>> from sympy.abc import x
>>> A = Symbol('A', commutative=False) 
```

```py
>>> cancel((2*x**2 - 2)/(x**2 - 2*x + 1))
(2*x + 2)/(x - 1)
>>> cancel((sqrt(3) + sqrt(15)*A)/(sqrt(2) + sqrt(10)*A))
sqrt(6)/2 
```

注意: 由于有理数的自动分布，由整数除以和会显示为和。要恢复有理数形式，请在结果上使用\(\text{together}\)：

```py
>>> cancel(x/2 + 1)
x/2 + 1
>>> together(_)
(x + 2)/2 
```

```py
sympy.polys.polytools.reduced(f, G, *gens, **args)
```

将多项式`f`减少为一组多项式`G`的模。

给定多项式`f`和一组多项式`G = (g_1, ..., g_n)`，计算一组商`q = (q_1, ..., q_n)`和余数`r`，使得`f = q_1*g_1 + ... + q_n*g_n + r`，其中`r`消失或者`r`是相对于`G`完全归约的多项式。

示例

```py
>>> from sympy import reduced
>>> from sympy.abc import x, y 
```

```py
>>> reduced(2*x**4 + y**2 - x**2 + y**3, [x**3 - x, y**3 - y])
([2*x, 1], x**2 + y**2 + y) 
```

```py
sympy.polys.polytools.groebner(F, *gens, **args)
```

计算一组多项式的简化格罗布纳基。

使用`order`参数设置用于计算基础的单项式顺序。允许的顺序有`lex`、`grlex`和`grevlex`。如果未指定顺序，则默认为`lex`。

有关格罗布纳基的更多信息，请参见参考文献和`solve_poly_system()`的文档字符串。

示例

示例来自[1]。

```py
>>> from sympy import groebner
>>> from sympy.abc import x, y 
```

```py
>>> F = [x*y - 2*y, 2*y**2 - x**2] 
```

```py
>>> groebner(F, x, y, order='lex')
GroebnerBasis([x**2 - 2*y**2, x*y - 2*y, y**3 - 2*y], x, y,
 domain='ZZ', order='lex')
>>> groebner(F, x, y, order='grlex')
GroebnerBasis([y**3 - 2*y, x**2 - 2*y**2, x*y - 2*y], x, y,
 domain='ZZ', order='grlex')
>>> groebner(F, x, y, order='grevlex')
GroebnerBasis([y**3 - 2*y, x**2 - 2*y**2, x*y - 2*y], x, y,
 domain='ZZ', order='grevlex') 
```

默认情况下，使用改进后的布赫伯格算法的实现。可选择使用 F5B 算法的实现。可以使用`method`标志或`sympy.polys.polyconfig.setup()`函数来设置算法。

```py
>>> F = [x**2 - x - 1, (2*x - 1) * y - (x**10 - (1 - x)**10)] 
```

```py
>>> groebner(F, x, y, method='buchberger')
GroebnerBasis([x**2 - x - 1, y - 55], x, y, domain='ZZ', order='lex')
>>> groebner(F, x, y, method='f5b')
GroebnerBasis([x**2 - x - 1, y - 55], x, y, domain='ZZ', order='lex') 
```

参考文献

1.  [[Buchberger01]](literature.html#buchberger01)

1.  [[Cox97]](literature.html#cox97)

```py
sympy.polys.polytools.is_zero_dimensional(F, *gens, **args)
```

检查由格罗布纳基生成的理想是否是零维的。

该算法检查不可被`F`的任何元素的主导单项式整除的单项式集是否有界。

参考文献

David A. Cox, John B. Little, Donal O’Shea. 理想、变量与算法, 第三版, 第 230 页

```py
class sympy.polys.polytools.Poly(rep, *gens, **args)
```

用于表示和操作多项式表达式的通用类。

查看多项式操作以获取通用文档。

Poly 是 Basic 的子类而不是 Expr，但实例可以使用`as_expr()`方法转换为 Expr。

自版本 1.6 起已弃用: 在二元操作中，将 Poly 与非 Poly 对象结合使用已弃用。请先明确将两个对象都转换为 Poly 或 Expr。参见在二元操作中混合 Poly 和非多项式表达式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

创建一个单变量多项式：

```py
>>> Poly(x*(x**2 + x - 1)**2)
Poly(x**5 + 2*x**4 - x**3 - 2*x**2 + x, x, domain='ZZ') 
```

创建一个带有特定定义域的单变量多项式：

```py
>>> from sympy import sqrt
>>> Poly(x**2 + 2*x + sqrt(3), domain='R')
Poly(1.0*x**2 + 2.0*x + 1.73205080756888, x, domain='RR') 
```

创建一个多变量多项式：

```py
>>> Poly(y*x**2 + x*y + 1)
Poly(x**2*y + x*y + 1, x, y, domain='ZZ') 
```

创建一个单变量多项式，其中`y`是一个常数：

```py
>>> Poly(y*x**2 + x*y + 1,x)
Poly(y*x**2 + y*x + 1, x, domain='ZZ[y]') 
```

您可以将上述多项式作为`y`的函数进行评估：

```py
>>> Poly(y*x**2 + x*y + 1,x).eval(2)
6*y + 1 
```

另请参见

`sympy.core.expr.Expr`

```py
EC(order=None)
```

返回`f`的最后一个非零系数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x**2 + 3*x, x).EC()
3 
```

```py
EM(order=None)
```

返回`f`的最后一个非零单项式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).EM()
x**0*y**1 
```

```py
ET(order=None)
```

返回`f`的最后一个非零项。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).ET()
(x**0*y**1, 3) 
```

```py
LC(order=None)
```

返回`f`的主导系数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(4*x**3 + 2*x**2 + 3*x, x).LC()
4 
```

```py
LM(order=None)
```

返回`f`的主导单项式。

主导单项式表示表达式 `f` 中主生成器的最高幂次的单项式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).LM()
x**2*y**0 
```

```py
LT(order=None)
```

返回 `f` 的主导项。

主导项表示表达式 `f` 中主生成器的最高幂次的项及其系数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(4*x**2 + 2*x*y**2 + x*y + 3*y, x, y).LT()
(x**2*y**0, 4) 
```

```py
TC()
```

返回 `f` 的尾部系数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x**2 + 3*x, x).TC()
0 
```

```py
abs()
```

使 `f` 中的所有系数为正。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).abs()
Poly(x**2 + 1, x, domain='ZZ') 
```

```py
add(g)
```

添加两个多项式 `f` 和 `g`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).add(Poly(x - 2, x))
Poly(x**2 + x - 1, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x) + Poly(x - 2, x)
Poly(x**2 + x - 1, x, domain='ZZ') 
```

```py
add_ground(coeff)
```

向 `f` 添加基础域的元素。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x + 1).add_ground(2)
Poly(x + 3, x, domain='ZZ') 
```

```py
all_coeffs()
```

返回单变量多项式 `f` 的所有系数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x - 1, x).all_coeffs()
[1, 0, 2, -1] 
```

```py
all_monoms()
```

返回单变量多项式 `f` 的所有单项式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x - 1, x).all_monoms()
[(3,), (2,), (1,), (0,)] 
```

另见

`all_terms`

```py
all_roots(multiple=True, radicals=True)
```

返回具有重数的实数和复数根的列表。

更多说明见 `all_roots()`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**3 - 7*x**2 + 4*x + 4).all_roots()
[-1/2, 2, 2]
>>> Poly(x**3 + x + 1).all_roots()
[CRootOf(x**3 + x + 1, 0),
 CRootOf(x**3 + x + 1, 1),
 CRootOf(x**3 + x + 1, 2)] 
```

```py
all_terms()
```

返回单变量多项式 `f` 的所有项。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x - 1, x).all_terms()
[((3,), 1), ((2,), 0), ((1,), 2), ((0,), -1)] 
```

```py
as_dict(native=False, zero=False)
```

切换到 `dict` 表示。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 2*x*y**2 - y, x, y).as_dict()
{(0, 1): -1, (1, 2): 2, (2, 0): 1} 
```

```py
as_expr(*gens)
```

将 Poly 实例转换为 Expr 实例。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = Poly(x**2 + 2*x*y**2 - y, x, y) 
```

```py
>>> f.as_expr()
x**2 + 2*x*y**2 - y
>>> f.as_expr({x: 5})
10*y**2 - y + 25
>>> f.as_expr(5, 6)
379 
```

```py
as_list(native=False)
```

切换到 `list` 表示。

```py
as_poly(*gens, **args)
```

将 `self` 转换为多项式或返回 `None`。

```py
>>> from sympy import sin
>>> from sympy.abc import x, y 
```

```py
>>> print((x**2 + x*y).as_poly())
Poly(x**2 + x*y, x, y, domain='ZZ') 
```

```py
>>> print((x**2 + x*y).as_poly(x, y))
Poly(x**2 + x*y, x, y, domain='ZZ') 
```

```py
>>> print((x**2 + sin(y)).as_poly(x, y))
None 
```

```py
cancel(g, include=False)
```

取消有理函数 `f/g` 中的公共因子。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x))
(1, Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ')) 
```

```py
>>> Poly(2*x**2 - 2, x).cancel(Poly(x**2 - 2*x + 1, x), include=True)
(Poly(2*x + 2, x, domain='ZZ'), Poly(x - 1, x, domain='ZZ')) 
```

```py
clear_denoms(convert=False)
```

清除分母，但保留基础域。

示例

```py
>>> from sympy import Poly, S, QQ
>>> from sympy.abc import x 
```

```py
>>> f = Poly(x/2 + S(1)/3, x, domain=QQ) 
```

```py
>>> f.clear_denoms()
(6, Poly(3*x + 2, x, domain='QQ'))
>>> f.clear_denoms(convert=True)
(6, Poly(3*x + 2, x, domain='ZZ')) 
```

```py
coeff_monomial(monom)
```

如果存在，则返回 `f` 中 `monom` 的系数，否则返回 `None`。

示例

```py
>>> from sympy import Poly, exp
>>> from sympy.abc import x, y 
```

```py
>>> p = Poly(24*x*y*exp(8) + 23*x, x, y) 
```

```py
>>> p.coeff_monomial(x)
23
>>> p.coeff_monomial(y)
0
>>> p.coeff_monomial(x*y)
24*exp(8) 
```

注意 `Expr.coeff()` 的行为不同，如果可能的话会收集项；但是必须将 Poly 转换为 Expr 才能使用该方法：

```py
>>> p.as_expr().coeff(x)
24*y*exp(8) + 23
>>> p.as_expr().coeff(y)
24*x*exp(8)
>>> p.as_expr().coeff(x*y)
24*exp(8) 
```

另见

`nth`

使用单项式生成器的指数进行更高效的查询

```py
coeffs(order=None)
```

返回 `f` 中所有非零系数的字典顺序。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 + 2*x + 3, x).coeffs()
[1, 2, 3] 
```

另见

`all_coeffs`, `coeff_monomial`, `nth`

```py
cofactors(g)
```

返回 `f` 和 `g` 的最大公因式及其余项。

返回多项式 `f` 的最大公因式 `(h, cff, cfg)`，使得 `h = gcd(f, g)`，并且 `cff = quo(f, h)` 和 `cfg = quo(g, h)` 是称为 `f` 和 `g` 的余式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).cofactors(Poly(x**2 - 3*x + 2, x))
(Poly(x - 1, x, domain='ZZ'),
 Poly(x + 1, x, domain='ZZ'),
 Poly(x - 2, x, domain='ZZ')) 
```

```py
compose(g)
```

计算 `f` 和 `g` 的函数复合。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + x, x).compose(Poly(x - 1, x))
Poly(x**2 - x, x, domain='ZZ') 
```

```py
content()
```

返回多项式系数的最大公因式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(6*x**2 + 8*x + 12, x).content()
2 
```

```py
count_roots(inf=None, sup=None)
```

返回 `f` 在 `[inf, sup]` 区间内的根数。

示例

```py
>>> from sympy import Poly, I
>>> from sympy.abc import x 
```

```py
>>> Poly(x**4 - 4, x).count_roots(-3, 3)
2
>>> Poly(x**4 - 4, x).count_roots(0, 1 + 3*I)
1 
```

```py
decompose()
```

计算 `f` 的函数分解。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**4 + 2*x**3 - x - 1, x, domain='ZZ').decompose()
[Poly(x**2 - x - 1, x, domain='ZZ'), Poly(x**2 + x, x, domain='ZZ')] 
```

```py
deflate()
```

通过将 `x_i**m` 映射到 `y_i` 来减少 `f` 的次数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**6*y**2 + x**3 + 1, x, y).deflate()
((3, 2), Poly(x**2*y + x + 1, x, y, domain='ZZ')) 
```

```py
degree(gen=0)
```

返回 `f` 在 `x_j` 中的次数。

0 的次数为负无穷大。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + y*x + 1, x, y).degree()
2
>>> Poly(x**2 + y*x + y, x, y).degree(y)
1
>>> Poly(0, x).degree()
-oo 
```

```py
degree_list()
```

返回 `f` 的次数列表。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + y*x + 1, x, y).degree_list()
(2, 1) 
```

```py
diff(*specs, **kwargs)
```

计算 `f` 的偏导数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 2*x + 1, x).diff()
Poly(2*x + 2, x, domain='ZZ') 
```

```py
>>> Poly(x*y**2 + x, x, y).diff((0, 0), (1, 1))
Poly(2*x*y, x, y, domain='ZZ') 
```

```py
discriminant()
```

计算 `f` 的判别式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 2*x + 3, x).discriminant()
-8 
```

```py
dispersion(g=None)
```

计算多项式的*离散度*。

对于两个多项式 \(f(x)\) 和 \(g(x)\)，其中 \(\deg f > 0\) 和 \(\deg g > 0\)，离散度 \(\operatorname{dis}(f, g)\) 定义为：

\[\begin{split}\operatorname{dis}(f, g) & := \max\{ J(f,g) \cup \{0\} \} \\ & = \max\{ \{a \in \mathbb{N} | \gcd(f(x), g(x+a)) \neq 1\} \cup \{0\} \}\end{split}\]

对于单个多项式 \(\operatorname{dis}(f) := \operatorname{dis}(f, f)\)。

示例

```py
>>> from sympy import poly
>>> from sympy.polys.dispersion import dispersion, dispersionset
>>> from sympy.abc import x 
```

简单多项式的离散集和离散：

```py
>>> fp = poly((x - 3)*(x + 3), x)
>>> sorted(dispersionset(fp))
[0, 6]
>>> dispersion(fp)
6 
```

注意，离散的定义不对称：

```py
>>> fp = poly(x**4 - 3*x**2 + 1, x)
>>> gp = fp.shift(-3)
>>> sorted(dispersionset(fp, gp))
[2, 3, 4]
>>> dispersion(fp, gp)
4
>>> sorted(dispersionset(gp, fp))
[]
>>> dispersion(gp, fp)
-oo 
```

计算离散也适用于域扩展：

```py
>>> from sympy import sqrt
>>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')
>>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')
>>> sorted(dispersionset(fp, gp))
[2]
>>> sorted(dispersionset(gp, fp))
[1, 4] 
```

我们甚至可以为具有符号系数的多项式执行计算：

```py
>>> from sympy.abc import a
>>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)
>>> sorted(dispersionset(fp))
[0, 1] 
```

参见

`dispersionset`

参考文献

1.  [[ManWright94]](literature.html#manwright94)

1.  [[Koepf98]](literature.html#koepf98)

1.  [[Abramov71]](literature.html#abramov71)

1.  [[Man93]](literature.html#man93)

```py
dispersionset(g=None)
```

计算两个多项式的 *离散集*。

对于两个多项式 \(f(x)\) 和 \(g(x)\)，其中 \(\deg f > 0\) 和 \(\deg g > 0\)，定义了离散集合 \(\operatorname{J}(f, g)\) 如下：

\[\begin{split}\operatorname{J}(f, g) & := \{a \in \mathbb{N}_0 | \gcd(f(x), g(x+a)) \neq 1\} \\ & = \{a \in \mathbb{N}_0 | \deg \gcd(f(x), g(x+a)) \geq 1\}\end{split}\]

对于单个多项式，定义为 \(\operatorname{J}(f) := \operatorname{J}(f, f)\)。

示例

```py
>>> from sympy import poly
>>> from sympy.polys.dispersion import dispersion, dispersionset
>>> from sympy.abc import x 
```

简单多项式的离散集和离散：

```py
>>> fp = poly((x - 3)*(x + 3), x)
>>> sorted(dispersionset(fp))
[0, 6]
>>> dispersion(fp)
6 
```

注意，离散的定义不对称：

```py
>>> fp = poly(x**4 - 3*x**2 + 1, x)
>>> gp = fp.shift(-3)
>>> sorted(dispersionset(fp, gp))
[2, 3, 4]
>>> dispersion(fp, gp)
4
>>> sorted(dispersionset(gp, fp))
[]
>>> dispersion(gp, fp)
-oo 
```

计算离散也适用于域扩展：

```py
>>> from sympy import sqrt
>>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')
>>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')
>>> sorted(dispersionset(fp, gp))
[2]
>>> sorted(dispersionset(gp, fp))
[1, 4] 
```

我们甚至可以为具有符号系数的多项式执行计算：

```py
>>> from sympy.abc import a
>>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)
>>> sorted(dispersionset(fp))
[0, 1] 
```

参见

`dispersion`

参考文献

1.  [[ManWright94]](literature.html#manwright94)

1.  [[Koepf98]](literature.html#koepf98)

1.  [[Abramov71]](literature.html#abramov71)

1.  [[Man93]](literature.html#man93)

```py
div(g, auto=True)
```

通过 `g` 对 `f` 进行多项式除法的余数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).div(Poly(2*x - 4, x))
(Poly(1/2*x + 1, x, domain='QQ'), Poly(5, x, domain='QQ')) 
```

```py
>>> Poly(x**2 + 1, x).div(Poly(2*x - 4, x), auto=False)
(Poly(0, x, domain='ZZ'), Poly(x**2 + 1, x, domain='ZZ')) 
```

```py
property domain
```

获取 `Poly` 的地面域。

返回：

`Domain`:

> `Poly` 的地面域。

示例

```py
>>> from sympy import Poly, Symbol
>>> x = Symbol('x')
>>> p = Poly(x**2 + x)
>>> p
Poly(x**2 + x, x, domain='ZZ')
>>> p.domain
ZZ 
```

```py
eject(*gens)
```

将选定的生成器弹出到地面域。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = Poly(x**2*y + x*y**3 + x*y + 1, x, y) 
```

```py
>>> f.eject(x)
Poly(x*y**3 + (x**2 + x)*y + 1, y, domain='ZZ[x]')
>>> f.eject(y)
Poly(y*x**2 + (y**3 + y)*x + 1, x, domain='ZZ[y]') 
```

```py
eval(x, a=None, auto=True)
```

在给定变量中的 `a` 处评估 `f`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y, z 
```

```py
>>> Poly(x**2 + 2*x + 3, x).eval(2)
11 
```

```py
>>> Poly(2*x*y + 3*x + y + 2, x, y).eval(x, 2)
Poly(5*y + 8, y, domain='ZZ') 
```

```py
>>> f = Poly(2*x*y + 3*x + y + 2*z, x, y, z) 
```

```py
>>> f.eval({x: 2})
Poly(5*y + 2*z + 6, y, z, domain='ZZ')
>>> f.eval({x: 2, y: 5})
Poly(2*z + 31, z, domain='ZZ')
>>> f.eval({x: 2, y: 5, z: 7})
45 
```

```py
>>> f.eval((2, 5))
Poly(2*z + 31, z, domain='ZZ')
>>> f(2, 5)
Poly(2*z + 31, z, domain='ZZ') 
```

```py
exclude()
```

从 `f` 中移除不必要的生成器。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import a, b, c, d, x 
```

```py
>>> Poly(a + x, a, b, c, d, x).exclude()
Poly(a + x, a, x, domain='ZZ') 
```

```py
exquo(g, auto=True)
```

计算 `f` 与 `g` 的多项式精确商。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).exquo(Poly(x - 1, x))
Poly(x + 1, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x).exquo(Poly(2*x - 4, x))
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1 
```

```py
exquo_ground(coeff)
```

精确地通过地面域中的一个元素 `f` 的商。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x + 4).exquo_ground(2)
Poly(x + 2, x, domain='ZZ') 
```

```py
>>> Poly(2*x + 3).exquo_ground(2)
Traceback (most recent call last):
...
ExactQuotientFailed: 2 does not divide 3 in ZZ 
```

```py
factor_list()
```

返回 `f` 的不可约因子列表。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = 2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y 
```

```py
>>> Poly(f).factor_list()
(2, [(Poly(x + y, x, y, domain='ZZ'), 1),
 (Poly(x**2 + 1, x, y, domain='ZZ'), 2)]) 
```

```py
factor_list_include()
```

返回 `f` 的不可约因子列表。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = 2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y 
```

```py
>>> Poly(f).factor_list_include()
[(Poly(2*x + 2*y, x, y, domain='ZZ'), 1),
 (Poly(x**2 + 1, x, y, domain='ZZ'), 2)] 
```

```py
property free_symbols
```

多项式表达式的自由符号。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y, z 
```

```py
>>> Poly(x**2 + 1).free_symbols
{x}
>>> Poly(x**2 + y).free_symbols
{x, y}
>>> Poly(x**2 + y, x).free_symbols
{x, y}
>>> Poly(x**2 + y, x, z).free_symbols
{x, y} 
```

```py
property free_symbols_in_domain
```

`self` 域的自由符号。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 1).free_symbols_in_domain
set()
>>> Poly(x**2 + y).free_symbols_in_domain
set()
>>> Poly(x**2 + y, x).free_symbols_in_domain
{y} 
```

```py
classmethod from_dict(rep, *gens, **args)
```

从一个 `dict` 构造一个多项式。

```py
classmethod from_expr(rep, *gens, **args)
```

从表达式构造一个多项式。

```py
classmethod from_list(rep, *gens, **args)
```

从一个 `list` 构造一个多项式。

```py
classmethod from_poly(rep, *gens, **args)
```

从一个多项式构造一个多项式。

```py
galois_group(by_name=False, max_tries=30, randomize=False)
```

计算此多项式的 Galois 群。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x
>>> f = Poly(x**4 - 2)
>>> G, _ = f.galois_group(by_name=True)
>>> print(G)
S4TransitiveSubgroups.D4 
```

参见

`sympy.polys.numberfields.galoisgroups.galois_group`

```py
gcd(g)
```

返回 `f` 和 `g` 的多项式最大公因式。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).gcd(Poly(x**2 - 3*x + 2, x))
Poly(x - 1, x, domain='ZZ') 
```

```py
gcdex(g, auto=True)
```

扩展欧几里得算法应用于 `f` 和 `g`。

返回 `(s, t, h)`，使得 `h = gcd(f, g)` 和 `s*f + t*g = h`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = x**4 - 2*x**3 - 6*x**2 + 12*x + 15
>>> g = x**3 + x**2 - 4*x - 4 
```

```py
>>> Poly(f).gcdex(Poly(g))
(Poly(-1/5*x + 3/5, x, domain='QQ'),
 Poly(1/5*x**2 - 6/5*x + 2, x, domain='QQ'),
 Poly(x + 1, x, domain='QQ')) 
```

```py
property gen
```

返回主要生成元。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).gen
x 
```

```py
get_domain()
```

获取 `f` 的底域。

```py
get_modulus()
```

获取 `f` 的模。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, modulus=2).get_modulus()
2 
```

```py
gff_list()
```

计算 `f` 的最大阶乘分解。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = x**5 + 2*x**4 - x**3 - 2*x**2 
```

```py
>>> Poly(f).gff_list()
[(Poly(x, x, domain='ZZ'), 1), (Poly(x + 2, x, domain='ZZ'), 4)] 
```

```py
ground_roots()
```

通过在底域中进行因式分解计算 `f` 的根。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**6 - 4*x**4 + 4*x**3 - x**2).ground_roots()
{0: 2, 1: 2} 
```

```py
half_gcdex(g, auto=True)
```

`f` 和 `g` 的半扩展欧几里得算法。

返回 `(s, h)`，使得 `h = gcd(f, g)` 和 `s*f = h (mod g)`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = x**4 - 2*x**3 - 6*x**2 + 12*x + 15
>>> g = x**3 + x**2 - 4*x - 4 
```

```py
>>> Poly(f).half_gcdex(Poly(g))
(Poly(-1/5*x + 3/5, x, domain='QQ'), Poly(x + 1, x, domain='QQ')) 
```

```py
has_only_gens(*gens)
```

如果 `Poly(f, *gens)` 保留底域，则返回 `True`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y, z 
```

```py
>>> Poly(x*y + 1, x, y, z).has_only_gens(x, y)
True
>>> Poly(x*y + z, x, y, z).has_only_gens(x, y)
False 
```

```py
homogeneous_order()
```

返回 `f` 的齐次阶数。

齐次多项式是所有非零系数的单项式具有相同总次数的多项式。这个次数就是 `f` 的齐次阶数。如果你只想检查一个多项式是否是齐次的，则使用 `Poly.is_homogeneous()`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = Poly(x**5 + 2*x**3*y**2 + 9*x*y**4)
>>> f.homogeneous_order()
5 
```

```py
homogenize(s)
```

返回 `f` 的齐次多项式。

齐次多项式是所有非零系数的单项式具有相同总次数的多项式。如果你只想检查一个多项式是否是齐次的，则使用 `Poly.is_homogeneous()`。如果你不仅想检查一个多项式是否是齐次的，还想计算其齐次阶数，请使用 `Poly.homogeneous_order()`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y, z 
```

```py
>>> f = Poly(x**5 + 2*x**2*y**2 + 9*x*y**3)
>>> f.homogenize(z)
Poly(x**5 + 2*x**2*y**2*z + 9*x*y**3*z, x, y, z, domain='ZZ') 
```

```py
inject(front=False)
```

将底域生成元注入到 `f` 中。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = Poly(x**2*y + x*y**3 + x*y + 1, x) 
```

```py
>>> f.inject()
Poly(x**2*y + x*y**3 + x*y + 1, x, y, domain='ZZ')
>>> f.inject(front=True)
Poly(y**3*x + y*x**2 + y*x + 1, y, x, domain='ZZ') 
```

```py
integrate(*specs, **args)
```

计算 `f` 的不定积分。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 2*x + 1, x).integrate()
Poly(1/3*x**3 + x**2 + x, x, domain='QQ') 
```

```py
>>> Poly(x*y**2 + x, x, y).integrate((0, 1), (1, 0))
Poly(1/2*x**2*y**2 + 1/2*x**2, x, y, domain='QQ') 
```

```py
intervals(all=False, eps=None, inf=None, sup=None, fast=False, sqf=False)
```

计算 `f` 的根的隔离区间。

对于实根，使用文森特-阿克里塔斯-斯特泽邦斯基（VAS）连分数法。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 3, x).intervals()
[((-2, -1), 1), ((1, 2), 1)]
>>> Poly(x**2 - 3, x).intervals(eps=1e-2)
[((-26/15, -19/11), 1), ((19/11, 26/15), 1)] 
```

参考文献

```py
invert(g, auto=True)
```

在可能时对 `f` 模 `g` 反演。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).invert(Poly(2*x - 1, x))
Poly(-4/3, x, domain='QQ') 
```

```py
>>> Poly(x**2 - 1, x).invert(Poly(x - 1, x))
Traceback (most recent call last):
...
NotInvertible: zero divisor 
```

```py
property is_cyclotomic
```

返回 `True` 如果 `f` 是一个周期多项式。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = x**16 + x**14 - x**10 + x**8 - x**6 + x**2 + 1 
```

```py
>>> Poly(f).is_cyclotomic
False 
```

```py
>>> g = x**16 + x**14 - x**10 - x**8 - x**6 + x**2 + 1 
```

```py
>>> Poly(g).is_cyclotomic
True 
```

```py
property is_ground
```

返回 `True` 如果 `f` 是底域的元素。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x, x).is_ground
False
>>> Poly(2, x).is_ground
True
>>> Poly(y, x).is_ground
True 
```

```py
property is_homogeneous
```

返回 `True` 如果 `f` 是一个齐次多项式。

齐次多项式是所有非零系数的单项式具有相同总次数的多项式。如果你不仅想检查一个多项式是否是齐次的，还想计算其齐次阶数，请使用 `Poly.homogeneous_order()`。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + x*y, x, y).is_homogeneous
True
>>> Poly(x**3 + x*y, x, y).is_homogeneous
False 
```

```py
property is_irreducible
```

返回 `True` 如果 `f` 在其域上没有因子。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + x + 1, x, modulus=2).is_irreducible
True
>>> Poly(x**2 + 1, x, modulus=2).is_irreducible
False 
```

```py
property is_linear
```

返回 `True` 如果 `f` 在所有变量中是线性的。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x + y + 2, x, y).is_linear
True
>>> Poly(x*y + 2, x, y).is_linear
False 
```

```py
property is_monic
```

返回 `True` 如果 `f` 的首项系数为一。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x + 2, x).is_monic
True
>>> Poly(2*x + 2, x).is_monic
False 
```

```py
property is_monomial
```

返回 `True` 如果 `f` 是零或仅有一个项。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(3*x**2, x).is_monomial
True
>>> Poly(3*x**2 + 1, x).is_monomial
False 
```

```py
property is_multivariate
```

返回 `True` 如果 `f` 是一个多变量多项式。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + x + 1, x).is_multivariate
False
>>> Poly(x*y**2 + x*y + 1, x, y).is_multivariate
True
>>> Poly(x*y**2 + x*y + 1, x).is_multivariate
False
>>> Poly(x**2 + x + 1, x, y).is_multivariate
True 
```

```py
property is_one
```

返回 `True` 如果 `f` 是一个单位多项式。

例子

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(0, x).is_one
False
>>> Poly(1, x).is_one
True 
```

```py
property is_primitive
```

如果 `f` 的系数的最大公约数是一，则返回 `True`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**2 + 6*x + 12, x).is_primitive
False
>>> Poly(x**2 + 3*x + 6, x).is_primitive
True 
```

```py
property is_quadratic
```

如果 `f` 在所有变量上都是二次的，则返回 `True`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x*y + 2, x, y).is_quadratic
True
>>> Poly(x*y**2 + 2, x, y).is_quadratic
False 
```

```py
property is_sqf
```

如果 `f` 是一个无平方因子的多项式，则返回 `True`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 2*x + 1, x).is_sqf
False
>>> Poly(x**2 - 1, x).is_sqf
True 
```

```py
property is_univariate
```

如果 `f` 是一元多项式，则返回 `True`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + x + 1, x).is_univariate
True
>>> Poly(x*y**2 + x*y + 1, x, y).is_univariate
False
>>> Poly(x*y**2 + x*y + 1, x).is_univariate
True
>>> Poly(x**2 + x + 1, x, y).is_univariate
False 
```

```py
property is_zero
```

如果 `f` 是零多项式，则返回 `True`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(0, x).is_zero
True
>>> Poly(1, x).is_zero
False 
```

```py
l1_norm()
```

返回 `f` 的 l1 范数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(-x**2 + 2*x - 3, x).l1_norm()
6 
```

```py
lcm(g)
```

返回 `f` 和 `g` 的多项式最小公倍数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).lcm(Poly(x**2 - 3*x + 2, x))
Poly(x**3 - 2*x**2 - x + 2, x, domain='ZZ') 
```

```py
length()
```

返回 `f` 中非零项的数量。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 2*x - 1).length()
3 
```

```py
lift()
```

将代数系数转换为有理数。

示例

```py
>>> from sympy import Poly, I
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + I*x + 1, x, extension=I).lift()
Poly(x**4 + 3*x**2 + 1, x, domain='QQ') 
```

```py
ltrim(gen)
```

从 `f` 中删除左边指定的 `gen` 生成器的虚拟生成器。当 `gen` 是整数时，它指的是 `f` 的生成器元组中位于该位置的生成器。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y, z 
```

```py
>>> Poly(y**2 + y*z**2, x, y, z).ltrim(y)
Poly(y**2 + y*z**2, y, z, domain='ZZ')
>>> Poly(z, x, y, z).ltrim(-1)
Poly(z, z, domain='ZZ') 
```

```py
make_monic_over_integers_by_scaling_roots()
```

将任意一元多项式在 QQ 或 ZZ 上转换为 ZZ 上的首一多项式，必要时通过缩放根来进行。

返回：

对偶 `(g, c)`

> `g` 是多项式。
> 
> c 是根必须缩放的整数

解释

无论 *f* 是否是不可约的，都可以执行此操作；当 *f* 是不可约的时，可以理解为确定一个生成与 *f* 的根相同的域的代数整数。

示例

```py
>>> from sympy import Poly, S
>>> from sympy.abc import x
>>> f = Poly(x**2/2 + S(1)/4 * x + S(1)/8, x, domain='QQ')
>>> f.make_monic_over_integers_by_scaling_roots()
(Poly(x**2 + 2*x + 4, x, domain='ZZ'), 4) 
```

```py
match(*args, **kwargs)
```

匹配 Poly 中的表达式。参见 Basic.match()

```py
max_norm()
```

返回 `f` 的最大范数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(-x**2 + 2*x - 3, x).max_norm()
3 
```

```py
monic(auto=True)
```

将所有系数除以 `LC(f)`。

示例

```py
>>> from sympy import Poly, ZZ
>>> from sympy.abc import x 
```

```py
>>> Poly(3*x**2 + 6*x + 9, x, domain=ZZ).monic()
Poly(x**2 + 2*x + 3, x, domain='QQ') 
```

```py
>>> Poly(3*x**2 + 4*x + 2, x, domain=ZZ).monic()
Poly(x**2 + 4/3*x + 2/3, x, domain='QQ') 
```

```py
monoms(order=None)
```

返回 `f` 的所有非零单项式按词典序。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 2*x*y**2 + x*y + 3*y, x, y).monoms()
[(2, 0), (1, 2), (1, 1), (0, 1)] 
```

另见

`all_monoms`：

```py
mul(g)
```

将两个多项式 `f` 和 `g` 相乘。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).mul(Poly(x - 2, x))
Poly(x**3 - 2*x**2 + x - 2, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x)*Poly(x - 2, x)
Poly(x**3 - 2*x**2 + x - 2, x, domain='ZZ') 
```

```py
mul_ground(coeff)
```

将 `f` 乘以地面域的元素。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x + 1).mul_ground(2)
Poly(2*x + 2, x, domain='ZZ') 
```

```py
neg()
```

将 `f` 的所有系数取反。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).neg()
Poly(-x**2 + 1, x, domain='ZZ') 
```

```py
>>> -Poly(x**2 - 1, x)
Poly(-x**2 + 1, x, domain='ZZ') 
```

```py
classmethod new(rep, *gens)
```

从原始表示构造 `Poly` 实例。

```py
norm()
```

计算定义在数域 `K` 上的多项式 `f` 共轭的乘积 `Norm(f)`。

示例

```py
>>> from sympy import Poly, sqrt
>>> from sympy.abc import x 
```

```py
>>> a, b = sqrt(2), sqrt(3) 
```

二次扩展上的多项式。两个共轭根 x - a 和 x + a。

```py
>>> f = Poly(x - a, x, extension=a)
>>> f.norm()
Poly(x**2 - 2, x, domain='QQ') 
```

四次扩展上的多项式。四个共轭根 x - a, x - a, x + a 和 x + a。

```py
>>> f = Poly(x - a, x, extension=(a, b))
>>> f.norm()
Poly(x**4 - 4*x**2 + 4, x, domain='QQ') 
```

```py
nroots(n=15, maxsteps=50, cleanup=True)
```

计算 `f` 的根的数值近似。

参数：

**n … 计算的数字位数**

**maxsteps … 最大迭代次数**

**如果在 `maxsteps` 中无法达到精度 `n`，它将引发异常**

**exception. 需要使用更高的 maxsteps 重新运行。**

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 3).nroots(n=15)
[-1.73205080756888, 1.73205080756888]
>>> Poly(x**2 - 3).nroots(n=30)
[-1.73205080756887729352744634151, 1.73205080756887729352744634151] 
```

```py
nth(*N)
```

返回 `f` 的第 `n` 个系数，其中 `N` 是感兴趣项中生成器的指数。

示例

```py
>>> from sympy import Poly, sqrt
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**3 + 2*x**2 + 3*x, x).nth(2)
2
>>> Poly(x**3 + 2*x*y**2 + y**2, x, y).nth(1, 2)
2
>>> Poly(4*sqrt(x)*y)
Poly(4*y*(sqrt(x)), y, sqrt(x), domain='ZZ')
>>> _.nth(1, 1)
4 
```

另见

`coeff_monomial`：

```py
nth_power_roots_poly(n)
```

用 `f` 的根的 n 次幂构造一个多项式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = Poly(x**4 - x**2 + 1) 
```

```py
>>> f.nth_power_roots_poly(2)
Poly(x**4 - 2*x**3 + 3*x**2 - 2*x + 1, x, domain='ZZ')
>>> f.nth_power_roots_poly(3)
Poly(x**4 + 2*x**2 + 1, x, domain='ZZ')
>>> f.nth_power_roots_poly(4)
Poly(x**4 + 2*x**3 + 3*x**2 + 2*x + 1, x, domain='ZZ')
>>> f.nth_power_roots_poly(12)
Poly(x**4 - 4*x**3 + 6*x**2 - 4*x + 1, x, domain='ZZ') 
```

```py
property one
```

返回具有 `self` 属性的一个多项式。

```py
pdiv(g)
```

`f` 除以 `g` 的多项式伪除法。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).pdiv(Poly(2*x - 4, x))
(Poly(2*x + 4, x, domain='ZZ'), Poly(20, x, domain='ZZ')) 
```

```py
per(rep, gens=None, remove=None)
```

用给定的表示创建一个 Poly。

示例

```py
>>> from sympy import Poly, ZZ
>>> from sympy.abc import x, y 
```

```py
>>> from sympy.polys.polyclasses import DMP 
```

```py
>>> a = Poly(x**2 + 1) 
```

```py
>>> a.per(DMP([ZZ(1), ZZ(1)], ZZ), gens=[y])
Poly(y + 1, y, domain='ZZ') 
```

```py
pexquo(g)
```

`f` 除以 `g` 的多项式精确伪商。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 1, x).pexquo(Poly(2*x - 2, x))
Poly(2*x + 2, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x).pexquo(Poly(2*x - 4, x))
Traceback (most recent call last):
...
ExactQuotientFailed: 2*x - 4 does not divide x**2 + 1 
```

```py
pow(n)
```

将 `f` 提升到非负幂 `n`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x - 2, x).pow(3)
Poly(x**3 - 6*x**2 + 12*x - 8, x, domain='ZZ') 
```

```py
>>> Poly(x - 2, x)**3
Poly(x**3 - 6*x**2 + 12*x - 8, x, domain='ZZ') 
```

```py
pquo(g)
```

`f` 除以 `g` 的多项式伪商。

请参见函数 prem(f, g) 中的注意事项。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).pquo(Poly(2*x - 4, x))
Poly(2*x + 4, x, domain='ZZ') 
```

```py
>>> Poly(x**2 - 1, x).pquo(Poly(2*x - 2, x))
Poly(2*x + 2, x, domain='ZZ') 
```

```py
prem(g)
```

多项式伪余数 `f` 除以 `g`。

注意：函数 prem(f, g, x) 可以安全地用于计算。

在 Z[x] _only_ 中的子结果多项式余数序列 (PRS)。

若要在 Z[x] 中安全地计算欧几里德和斯图米尔 PRS，请使用模块 sympy.polys.subresultants_qq_zz 中找到的相应函数之一。带有后缀 _pg 的模块函数使用 rem(f, g, x) 在 Z[x] 中计算 PRS，而带有后缀 _amv 的函数使用 rem_z(f, g, x) 在 Z[x] 中计算 PRS。

函数 rem_z(f, g, x) 不同于 prem(f, g, x)，因为它在计算 Z[x]中的余式多项式时，将被除数预乘以除数的绝对值的次数，即 degree(f, x) - degree(g, x) + 1。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).prem(Poly(2*x - 4, x))
Poly(20, x, domain='ZZ') 
```

```py
primitive()
```

返回 `f` 的内容和原始形式。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**2 + 8*x + 12, x).primitive()
(2, Poly(x**2 + 4*x + 6, x, domain='ZZ')) 
```

```py
quo(g, auto=True)
```

计算 `f` 除以 `g` 的多项式商。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).quo(Poly(2*x - 4, x))
Poly(1/2*x + 1, x, domain='QQ') 
```

```py
>>> Poly(x**2 - 1, x).quo(Poly(x - 1, x))
Poly(x + 1, x, domain='ZZ') 
```

```py
quo_ground(coeff)
```

`f` 除以基本定义域元素的商。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x + 4).quo_ground(2)
Poly(x + 2, x, domain='ZZ') 
```

```py
>>> Poly(2*x + 3).quo_ground(2)
Poly(x + 1, x, domain='ZZ') 
```

```py
rat_clear_denoms(g)
```

清除有理函数 `f/g` 中的分母。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> f = Poly(x**2/y + 1, x)
>>> g = Poly(x**3 + y, x) 
```

```py
>>> p, q = f.rat_clear_denoms(g) 
```

```py
>>> p
Poly(x**2 + y, x, domain='ZZ[y]')
>>> q
Poly(y*x**3 + y**2, x, domain='ZZ[y]') 
```

```py
real_roots(multiple=True, radicals=True)
```

返回带有重数的实根列表。

参见 `real_roots()` 以获取更多解释。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**3 - 7*x**2 + 4*x + 4).real_roots()
[-1/2, 2, 2]
>>> Poly(x**3 + x + 1).real_roots()
[CRootOf(x**3 + x + 1, 0)] 
```

```py
refine_root(s, t, eps=None, steps=None, fast=False, check_sqf=False)
```

优化根的隔离区间至指定精度。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 3, x).refine_root(1, 2, eps=1e-2)
(19/11, 26/15) 
```

```py
rem(g, auto=True)
```

计算 `f` 除以 `g` 的多项式余数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).rem(Poly(2*x - 4, x))
Poly(5, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x).rem(Poly(2*x - 4, x), auto=False)
Poly(x**2 + 1, x, domain='ZZ') 
```

```py
reorder(*gens, **args)
```

高效应用新的生成器顺序。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + x*y**2, x, y).reorder(y, x)
Poly(y**2*x + x**2, y, x, domain='ZZ') 
```

```py
replace(x, y=None, **_ignore)
```

在生成器列表中用 `y` 替换 `x`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 1, x).replace(x, y)
Poly(y**2 + 1, y, domain='ZZ') 
```

```py
resultant(g, includePRS=False)
```

计算 `f` 和 `g` 的结果通过 PRS。

如果 includePRS=True，则在结果中包含子结果 PRS。因为 PRS 用于计算结果，所以这比单独调用 `subresultants()` 更有效。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = Poly(x**2 + 1, x) 
```

```py
>>> f.resultant(Poly(x**2 - 1, x))
4
>>> f.resultant(Poly(x**2 - 1, x), includePRS=True)
(4, [Poly(x**2 + 1, x, domain='ZZ'), Poly(x**2 - 1, x, domain='ZZ'),
 Poly(-2, x, domain='ZZ')]) 
```

```py
retract(field=None)
```

重新计算多项式的基本定义域。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = Poly(x**2 + 1, x, domain='QQ[y]')
>>> f
Poly(x**2 + 1, x, domain='QQ[y]') 
```

```py
>>> f.retract()
Poly(x**2 + 1, x, domain='ZZ')
>>> f.retract(field=True)
Poly(x**2 + 1, x, domain='QQ') 
```

```py
revert(n)
```

计算 `f**(-1)` mod `x**n`.

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(1, x).revert(2)
Poly(1, x, domain='ZZ') 
```

```py
>>> Poly(1 + x, x).revert(1)
Poly(1, x, domain='ZZ') 
```

```py
>>> Poly(x**2 - 2, x).revert(2)
Traceback (most recent call last):
...
NotReversible: only units are reversible in a ring 
```

```py
>>> Poly(1/x, x).revert(1)
Traceback (most recent call last):
...
PolynomialError: 1/x contains an element of the generators set 
```

```py
root(index, radicals=True)
```

获取多项式的索引根。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = Poly(2*x**3 - 7*x**2 + 4*x + 4) 
```

```py
>>> f.root(0)
-1/2
>>> f.root(1)
2
>>> f.root(2)
2
>>> f.root(3)
Traceback (most recent call last):
...
IndexError: root index out of [-3, 2] range, got 3 
```

```py
>>> Poly(x**5 + x + 1).root(0)
CRootOf(x**3 - x**2 + 1, 0) 
```

```py
same_root(a, b)
```

决定该多项式的两个根是否相等。

抛出:

**域错误**

> 如果多项式的定义域不是 ZZ, QQ, RR, 或 CC。

**多变量多项式错误**

> 如果多项式不是单变量的。

**多项式错误**

> 如果多项式的次数 < 2。

示例

```py
>>> from sympy import Poly, cyclotomic_poly, exp, I, pi
>>> f = Poly(cyclotomic_poly(5))
>>> r0 = exp(2*I*pi/5)
>>> indices = [i for i, r in enumerate(f.all_roots()) if f.same_root(r, r0)]
>>> print(indices)
[3] 
```

```py
set_domain(domain)
```

设置 `f` 的基本定义域。

```py
set_modulus(modulus)
```

设置 `f` 的模数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(5*x**2 + 2*x - 1, x).set_modulus(2)
Poly(x**2 + 1, x, modulus=2) 
```

```py
shift(a)
```

高效计算泰勒移位 `f(x + a)`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 2*x + 1, x).shift(2)
Poly(x**2 + 2*x + 1, x, domain='ZZ') 
```

另见

`shift_list`

多变量多项式的类似方法。

```py
shift_list(a)
```

高效计算泰勒移位 `f(X + A)`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x*y, [x,y]).shift_list([1, 2]) == Poly((x+1)*(y+2), [x,y])
True 
```

另见

`shift`

单变量多项式的类似方法。

```py
slice(x, m, n=None)
```

取 `f` 的连续子序列。

```py
sqf_list(all=False)
```

返回 `f` 的无平方因子列表。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f = 2*x**5 + 16*x**4 + 50*x**3 + 76*x**2 + 56*x + 16 
```

```py
>>> Poly(f).sqf_list()
(2, [(Poly(x + 1, x, domain='ZZ'), 2),
 (Poly(x + 2, x, domain='ZZ'), 3)]) 
```

```py
>>> Poly(f).sqf_list(all=True)
(2, [(Poly(1, x, domain='ZZ'), 1),
 (Poly(x + 1, x, domain='ZZ'), 2),
 (Poly(x + 2, x, domain='ZZ'), 3)]) 
```

```py
sqf_list_include(all=False)
```

返回 `f` 的无平方因子列表。

示例

```py
>>> from sympy import Poly, expand
>>> from sympy.abc import x 
```

```py
>>> f = expand(2*(x + 1)**3*x**4)
>>> f
2*x**7 + 6*x**6 + 6*x**5 + 2*x**4 
```

```py
>>> Poly(f).sqf_list_include()
[(Poly(2, x, domain='ZZ'), 1),
 (Poly(x + 1, x, domain='ZZ'), 3),
 (Poly(x, x, domain='ZZ'), 4)] 
```

```py
>>> Poly(f).sqf_list_include(all=True)
[(Poly(2, x, domain='ZZ'), 1),
 (Poly(1, x, domain='ZZ'), 2),
 (Poly(x + 1, x, domain='ZZ'), 3),
 (Poly(x, x, domain='ZZ'), 4)] 
```

```py
sqf_norm()
```

计算 `f` 的无平方法则。

返回 `s`、`f`、`r`，使得 `g(x) = f(x-sa)` 和 `r(x) = Norm(g(x))` 是在 `K` 上的一个无平方多项式，其中 `a` 是地域域的代数扩展。

示例

```py
>>> from sympy import Poly, sqrt
>>> from sympy.abc import x 
```

```py
>>> s, f, r = Poly(x**2 + 1, x, extension=[sqrt(3)]).sqf_norm() 
```

```py
>>> s
[1]
>>> f
Poly(x**2 - 2*sqrt(3)*x + 4, x, domain='QQ<sqrt(3)>')
>>> r
Poly(x**4 - 4*x**2 + 16, x, domain='QQ') 
```

```py
sqf_part()
```

计算 `f` 的无平方部分。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 - 3*x - 2, x).sqf_part()
Poly(x**2 - x - 2, x, domain='ZZ') 
```

```py
sqr()
```

对多项式 `f` 进行平方。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x - 2, x).sqr()
Poly(x**2 - 4*x + 4, x, domain='ZZ') 
```

```py
>>> Poly(x - 2, x)**2
Poly(x**2 - 4*x + 4, x, domain='ZZ') 
```

```py
sturm(auto=True)
```

计算 `f` 的斯图姆序列。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**3 - 2*x**2 + x - 3, x).sturm()
[Poly(x**3 - 2*x**2 + x - 3, x, domain='QQ'),
 Poly(3*x**2 - 4*x + 1, x, domain='QQ'),
 Poly(2/9*x + 25/9, x, domain='QQ'),
 Poly(-2079/4, x, domain='QQ')] 
```

```py
sub(g)
```

减去两个多项式 `f` 和 `g`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).sub(Poly(x - 2, x))
Poly(x**2 - x + 3, x, domain='ZZ') 
```

```py
>>> Poly(x**2 + 1, x) - Poly(x - 2, x)
Poly(x**2 - x + 3, x, domain='ZZ') 
```

```py
sub_ground(coeff)
```

从地域域的元素中减去 `f`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x + 1).sub_ground(2)
Poly(x - 1, x, domain='ZZ') 
```

```py
subresultants(g)
```

计算 `f` 和 `g` 的子结果 PRS。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x).subresultants(Poly(x**2 - 1, x))
[Poly(x**2 + 1, x, domain='ZZ'),
 Poly(x**2 - 1, x, domain='ZZ'),
 Poly(-2, x, domain='ZZ')] 
```

```py
terms(order=None)
```

按词典顺序返回 `f` 的所有非零项。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + 2*x*y**2 + x*y + 3*y, x, y).terms()
[((2, 0), 1), ((1, 2), 2), ((1, 1), 1), ((0, 1), 3)] 
```

另见

`all_terms`

```py
terms_gcd()
```

从多项式 `f` 中移除项的最大公因子。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**6*y**2 + x**3*y, x, y).terms_gcd()
((3, 1), Poly(x**3*y + 1, x, y, domain='ZZ')) 
```

```py
termwise(func, *gens, **args)
```

对 `f` 的所有项应用函数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> def func(k, coeff):
...     k = k[0]
...     return coeff//10**(2-k) 
```

```py
>>> Poly(x**2 + 20*x + 400).termwise(func)
Poly(x**2 + 2*x + 4, x, domain='ZZ') 
```

```py
to_exact()
```

使地域域变得精确。

示例

```py
>>> from sympy import Poly, RR
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1.0, x, domain=RR).to_exact()
Poly(x**2 + 1, x, domain='QQ') 
```

```py
to_field()
```

使地域域成为一个域。

示例

```py
>>> from sympy import Poly, ZZ
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, x, domain=ZZ).to_field()
Poly(x**2 + 1, x, domain='QQ') 
```

```py
to_ring()
```

使地域域成为一个环。

示例

```py
>>> from sympy import Poly, QQ
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 + 1, domain=QQ).to_ring()
Poly(x**2 + 1, x, domain='ZZ') 
```

```py
total_degree()
```

返回 `f` 的总次数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x, y 
```

```py
>>> Poly(x**2 + y*x + 1, x, y).total_degree()
2
>>> Poly(x + y**5, x, y).total_degree()
5 
```

```py
transform(p, q)
```

高效地评估函数变换 `q**n * f(p/q)`。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(x**2 - 2*x + 1, x).transform(Poly(x + 1, x), Poly(x - 1, x))
Poly(4, x, domain='ZZ') 
```

```py
trunc(p)
```

将 `f` 模化为常数 `p` 的余数。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> Poly(2*x**3 + 3*x**2 + 5*x + 7, x).trunc(3)
Poly(-x**3 - x + 1, x, domain='ZZ') 
```

```py
unify(g)
```

使 `f` 和 `g` 属于相同的地域域。

示例

```py
>>> from sympy import Poly
>>> from sympy.abc import x 
```

```py
>>> f, g = Poly(x/2 + 1), Poly(2*x + 1) 
```

```py
>>> f
Poly(1/2*x + 1, x, domain='QQ')
>>> g
Poly(2*x + 1, x, domain='ZZ') 
```

```py
>>> F, G = f.unify(g) 
```

```py
>>> F
Poly(1/2*x + 1, x, domain='QQ')
>>> G
Poly(2*x + 1, x, domain='QQ') 
```

```py
property unit
```

返回与 `self` 属性相同的单位多项式。

```py
property zero
```

返回与 `self` 属性相同的零多项式。

```py
class sympy.polys.polytools.PurePoly(rep, *gens, **args)
```

用于表示纯多项式的类。

```py
property free_symbols
```

多项式的自由符号。

示例

```py
>>> from sympy import PurePoly
>>> from sympy.abc import x, y 
```

```py
>>> PurePoly(x**2 + 1).free_symbols
set()
>>> PurePoly(x**2 + y).free_symbols
set()
>>> PurePoly(x**2 + y, x).free_symbols
{y} 
```

```py
class sympy.polys.polytools.GroebnerBasis(F, *gens, **args)
```

表示简化的 Groebner 基础。

```py
contains(poly)
```

检查 `poly` 是否属于由 `self` 生成的理想。

示例

```py
>>> from sympy import groebner
>>> from sympy.abc import x, y 
```

```py
>>> f = 2*x**3 + y**3 + 3*y
>>> G = groebner([x**2 + y**2 - 1, x*y - 2]) 
```

```py
>>> G.contains(f)
True
>>> G.contains(f + 1)
False 
```

```py
fglm(order)
```

将一个 Groebner 基础从一种排序转换到另一种排序。

FGLM 算法将零维理想的简化 Groebner 基从一种排序转换到另一种排序。 当直接计算与特定排序相关的 Groebner 基不可行时，通常使用此方法。

示例

```py
>>> from sympy.abc import x, y
>>> from sympy import groebner 
```

```py
>>> F = [x**2 - 3*y - x + 1, y**2 - 2*x + y - 1]
>>> G = groebner(F, x, y, order='grlex') 
```

```py
>>> list(G.fglm('lex'))
[2*x - y**2 - y + 1, y**4 + 2*y**3 - 3*y**2 - 16*y + 7]
>>> list(groebner(F, x, y, order='lex'))
[2*x - y**2 - y + 1, y**4 + 2*y**3 - 3*y**2 - 16*y + 7] 
```

参考

[R810]

J.C. Faugere, P. Gianni, D. Lazard, T. Mora (1994). Efficient Computation of Zero-dimensional Groebner Bases by Change of Ordering

```py
property is_zero_dimensional
```

检查由 Groebner 基生成的理想是否是零维的。

算法检查 `F` 的任何元素的领导单项式不可整除的单项式集是否是有界的。

参考

David A. Cox, John B. Little, Donal O’Shea. Ideals, Varieties and Algorithms, 第 3 版, p. 230

```py
reduce(expr, auto=True)
```

将多项式模化为 Groebner 基的余数。

给定多项式 `f` 和一组多项式 `G = (g_1, ..., g_n)`，计算商集 `q = (q_1, ..., q_n)` 和余项 `r`，使得 `f = q_1*f_1 + ... + q_n*f_n + r`，其中 `r` 为零或者相对于 `G` 完全约简的多项式。

示例

```py
>>> from sympy import groebner, expand
>>> from sympy.abc import x, y 
```

```py
>>> f = 2*x**4 - x**2 + y**3 + y**2
>>> G = groebner([x**3 - x, y**3 - y]) 
```

```py
>>> G.reduce(f)
([2*x, 1], x**2 + y**2 + y)
>>> Q, r = _ 
```

```py
>>> expand(sum(q*g for q, g in zip(Q, G)) + r)
2*x**4 - x**2 + y**3 + y**2
>>> _ == f
True 
```

## 额外的多项式操作函数

```py
sympy.polys.polyfuncs.symmetrize(F, *gens, **args)
```

将一个多项式重写为基本对称多项式的形式。

对称多项式是一个多元多项式，在任何变量置换下保持不变，即如果 \(f = f(x_1, x_2, \dots, x_n)\)，那么 \(f = f(x_{i_1}, x_{i_2}, \dots, x_{i_n})\)，其中 \((i_1, i_2, \dots, i_n)\) 是 \((1, 2, \dots, n)\) 的一个排列（即 \(S_n\) 群的一个元素）。

返回对称多项式元组 `(f1, f2, ..., fn)`，使得 `f = f1 + f2 + ... + fn`。

示例

```py
>>> from sympy.polys.polyfuncs import symmetrize
>>> from sympy.abc import x, y 
```

```py
>>> symmetrize(x**2 + y**2)
(-2*x*y + (x + y)**2, 0) 
```

```py
>>> symmetrize(x**2 + y**2, formal=True)
(s1**2 - 2*s2, 0, [(s1, x + y), (s2, x*y)]) 
```

```py
>>> symmetrize(x**2 - y**2)
(-2*x*y + (x + y)**2, -2*y**2) 
```

```py
>>> symmetrize(x**2 - y**2, formal=True)
(s1**2 - 2*s2, -2*y**2, [(s1, x + y), (s2, x*y)]) 
```

```py
sympy.polys.polyfuncs.horner(f, *gens, **args)
```

将一个多项式重写为 Horner 形式。

在其他应用中，使用 Horner 方案([1])来在点处求多项式的值是最优的。

示例

```py
>>> from sympy.polys.polyfuncs import horner
>>> from sympy.abc import x, y, a, b, c, d, e 
```

```py
>>> horner(9*x**4 + 8*x**3 + 7*x**2 + 6*x + 5)
x*(x*(x*(9*x + 8) + 7) + 6) + 5 
```

```py
>>> horner(a*x**4 + b*x**3 + c*x**2 + d*x + e)
e + x*(d + x*(c + x*(a*x + b))) 
```

```py
>>> f = 4*x**2*y**2 + 2*x**2*y + 2*x*y**2 + x*y 
```

```py
>>> horner(f, wrt=x)
x*(x*y*(4*y + 2) + y*(2*y + 1)) 
```

```py
>>> horner(f, wrt=y)
y*(x*y*(4*x + 2) + x*(2*x + 1)) 
```

参考

[1] - [`en.wikipedia.org/wiki/Horner_scheme`](https://en.wikipedia.org/wiki/Horner_scheme)

```py
sympy.polys.polyfuncs.interpolate(data, x)
```

为数据点在点 x 处插值多项式。

示例

```py
>>> from sympy.polys.polyfuncs import interpolate
>>> from sympy.abc import a, b, x 
```

列表被解释为与从 1 开始的范围配对：

```py
>>> interpolate([1, 4, 9, 16], x)
x**2 
```

通过提供坐标列表来明确表示：

```py
>>> interpolate([(1, 1), (2, 4), (3, 9)], x)
x**2 
```

(x, y)坐标也可以作为字典的键和值给出（且点不需要等间距）：

```py
>>> interpolate([(-1, 2), (1, 2), (2, 5)], x)
x**2 + 1
>>> interpolate({-1: 2, 1: 2, 2: 5}, x)
x**2 + 1 
```

如果插值仅会被使用一次，那么可以传递感兴趣的值而不是传递符号：

```py
>>> interpolate([1, 4, 9], 5)
25 
```

符号坐标也受支持：

```py
>>> [(i,interpolate((a, b), i)) for i in range(1, 4)]
[(1, a), (2, b), (3, -a + 2*b)] 
```

```py
sympy.polys.polyfuncs.viete(f, roots=None, *gens, **args)
```

为`f`生成 Vieta 公式。

示例

```py
>>> from sympy.polys.polyfuncs import viete
>>> from sympy import symbols 
```

```py
>>> x, a, b, c, r1, r2 = symbols('x,a:c,r1:3') 
```

```py
>>> viete(a*x**2 + b*x + c, [r1, r2], x)
[(r1 + r2, -b/a), (r1*r2, c/a)] 
```

## 域构造器

```py
sympy.polys.constructor.construct_domain(obj, **args)
```

构建表达式列表的最小域。

参数：

**obj: 列表或字典**

> 用于构建域的表达式。

****args: 关键字参数**

> 影响域选择的选项。

返回：

(K, elements): 域及其域元素列表

> 能表示表达式的域 K，以及表示同一表达式为 K 元素的列表或字典。

解释

给定一组正常的 SymPy 表达式（类型为`Expr`），`construct_domain`将找到能表示这些表达式的最小`Domain`。表达式将被转换为域的元素，并返回域和域元素。

示例

给定`Integer`列表`construct_domain`将返回域 ZZ，以及作为 ZZ 元素的整数列表。

```py
>>> from sympy import construct_domain, S
>>> expressions = [S(2), S(3), S(4)]
>>> K, elements = construct_domain(expressions)
>>> K
ZZ
>>> elements
[2, 3, 4]
>>> type(elements[0])  
<class 'int'>
>>> type(expressions[0])
<class 'sympy.core.numbers.Integer'> 
```

如果存在`Rational`，则返回 QQ。

```py
>>> construct_domain([S(1)/2, S(3)/4])
(QQ, [1/2, 3/4]) 
```

如果存在符号，则返回一个多项式环[K[x]](domainsref.html#k-x)。

```py
>>> from sympy import symbols
>>> x, y = symbols('x, y')
>>> construct_domain([2*x + 1, S(3)/4])
(QQ[x], [2*x + 1, 3/4])
>>> construct_domain([2*x + 1, y])
(ZZ[x,y], [2*x + 1, y]) 
```

如果任何符号具有负指数，则将返回一个有理函数域 K(x)。

```py
>>> construct_domain([y/x, x/(1 - y)])
(ZZ(x,y), [y/x, -x/(y - 1)]) 
```

无理数代数会默认返回 EX 域。关键字参数`extension=True`会导致构造代数数域 QQ<a>。

```py
>>> from sympy import sqrt
>>> construct_domain([sqrt(2)])
(EX, [EX(sqrt(2))])
>>> construct_domain([sqrt(2)], extension=True)  
(QQ<sqrt(2)>, [ANP([1, 0], [1, 0, -2], QQ)]) 
```

另请参阅

`Domain`，`Expr`

## 单项式编码为元组

```py
class sympy.polys.monomials.Monomial(monom, gens=None)
```

表示单项式的类，即幂的乘积。

```py
as_expr(*gens)
```

将单项式实例转换为 SymPy 表达式。

```py
gcd(other)
```

单项式的最大公因子。

```py
lcm(other)
```

单项式的最小公倍数。

```py
sympy.polys.monomials.itermonomials(variables, max_degrees, min_degrees=None)
```

`max_degrees` 和 `min_degrees` 都是整数或列表。除非另有说明，否则 `min_degrees` 要么是 `0` 要么是 `[0, ..., 0]`。

返回所有单项式 `monom` 的生成器，使得 `min_degree <= total_degree(monom) <= max_degree`，或对于所有 `i`，`min_degrees[i] <= degree_list(monom)[i] <= max_degrees[i]`。

情况 I. `max_degrees` 和 `min_degrees` 都是整数

给定变量集合 \(V\) 和最小次数 \(N\) 以及最大次数 \(M\)，生成次数小于等于 \(N\) 且大于等于 \(M\) 的单项式集合。在可交换变量的情况下，单项式的总数巨大，并由以下公式给出，如果 \(M = 0\)：

> \[\frac{(\#V + N)!}{\#V! N!}\]

例如，如果我们想生成一个总次数为 \(N = 50\)，\(M = 0\) 的密集多项式，这是最坏的情况，在 5 个变量中，假设指数和所有系数都是 32 位长，并存储在一个数组中，我们将需要接近 80 GiB 的内存！幸运的是，我们将遇到的大多数多项式都是稀疏的。

考虑在可交换变量 \(x\) 和 \(y\) 中以及非交换变量 \(a\) 和 \(b\) 中的单项式：

```py
>>> from sympy import symbols
>>> from sympy.polys.monomials import itermonomials
>>> from sympy.polys.orderings import monomial_key
>>> from sympy.abc import x, y

>>> sorted(itermonomials([x, y], 2), key=monomial_key('grlex', [y, x]))
[1, x, y, x**2, x*y, y**2]

>>> sorted(itermonomials([x, y], 3), key=monomial_key('grlex', [y, x]))
[1, x, y, x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3]

>>> a, b = symbols('a, b', commutative=False)
>>> set(itermonomials([a, b, x], 2))
{1, a, a**2, b, b**2, x, x**2, a*b, b*a, x*a, x*b}

>>> sorted(itermonomials([x, y], 2, 1), key=monomial_key('grlex', [y, x]))
[x, y, x**2, x*y, y**2] 
```

情况 II. `max_degrees` 和 `min_degrees` 都是列表

如果 `max_degrees = [d_1, ..., d_n]` 和 `min_degrees = [e_1, ..., e_n]`，生成的单项式数量为：

\[(d_1 - e_1 + 1) (d_2 - e_2 + 1) \cdots (d_n - e_n + 1)\]

让我们生成所有变量为 \(x\) 和 \(y\) 的单项式 `monom`，使得 `[1, 2][i] <= degree_list(monom)[i] <= [2, 4][i]`，其中 `i = 0, 1`

```py
>>> from sympy import symbols
>>> from sympy.polys.monomials import itermonomials
>>> from sympy.polys.orderings import monomial_key
>>> from sympy.abc import x, y

>>> sorted(itermonomials([x, y], [2, 4], [1, 2]), reverse=True, key=monomial_key('lex', [x, y]))
[x**2*y**4, x**2*y**3, x**2*y**2, x*y**4, x*y**3, x*y**2] 
```

```py
sympy.polys.monomials.monomial_count(V, N)
```

计算单项式的数量。

单项式的数量由以下公式给出：

\[\frac{(\#V + N)!}{\#V! N!}\]

其中 \(N\) 是总次数，\(V\) 是变量集合。

例子

```py
>>> from sympy.polys.monomials import itermonomials, monomial_count
>>> from sympy.polys.orderings import monomial_key
>>> from sympy.abc import x, y 
```

```py
>>> monomial_count(2, 2)
6 
```

```py
>>> M = list(itermonomials([x, y], 2)) 
```

```py
>>> sorted(M, key=monomial_key('grlex', [y, x]))
[1, x, y, x**2, x*y, y**2]
>>> len(M)
6 
```

## 单项式的排列顺序

```py
class sympy.polys.orderings.MonomialOrder
```

单项式排序的基类。

```py
class sympy.polys.orderings.LexOrder
```

单项式的词典序。

```py
class sympy.polys.orderings.GradedLexOrder
```

单项式的分级字典序。

```py
class sympy.polys.orderings.ReversedGradedLexOrder
```

单项式的逆分级字典序。

## 多项式根的形式推导

```py
sympy.polys.rootoftools.rootof(f, x, index=None, radicals=True, expand=True)
```

一元多项式的索引根。

返回一个 `ComplexRootOf` 对象或涉及根式的显式表达式。

参数:

**f** : 表达式

> 一元多项式。

**x** : 符号，可选

> 生成 `f` 的生成器。

**index** : int 或 Integer

**radicals** : bool

> 如果可能，返回一个根式表达式。

**expand** : bool

> 展开 `f`。

```py
class sympy.polys.rootoftools.RootOf(f, x, index=None, radicals=True, expand=True)
```

表示一元多项式的根。

不同类型多项式根的基类。目前仅支持复数根。

```py
class sympy.polys.rootoftools.ComplexRootOf(f, x, index=None, radicals=False, expand=True)
```

表示多项式的索引复数根。

将一元多项式的根分离成不相交的实数或复数区间，并按固定顺序进行索引：

+   实根先来，按增加顺序排序；

+   复数根接下来，并按照增加的实部和次要地按增加的虚部排序。

目前只允许有理系数。可以导入为 `CRootOf`。为了避免混淆，生成器必须是一个符号。

例子

```py
>>> from sympy import CRootOf, rootof
>>> from sympy.abc import x 
```

CRootOf 是引用多项式特定根的一种方式。如果有有理根，则将返回它：

```py
>>> CRootOf.clear_cache()  # for doctest reproducibility
>>> CRootOf(x**2 - 4, 0)
-2 
```

是否返回涉及根式的根取决于`radicals`标志是否为真（在`rootof`中设为 True）：

```py
>>> CRootOf(x**2 - 3, 0)
CRootOf(x**2 - 3, 0)
>>> CRootOf(x**2 - 3, 0, radicals=True)
-sqrt(3)
>>> rootof(x**2 - 3, 0)
-sqrt(3) 
```

以下不能用根式表达：

```py
>>> r = rootof(4*x**5 + 16*x**3 + 12*x**2 + 7, 0); r
CRootOf(4*x**5 + 16*x**3 + 12*x**2 + 7, 0) 
```

可见根边界，它们被评估方法用于获取根的数值近似。

```py
>>> interval = r._get_interval(); interval
(-1, 0)
>>> r.evalf(2)
-0.98 
```

`evalf`方法会细化根的边界宽度，直到保证这些边界内的任何小数近似都满足所需的精度。然后，它会存储细化后的区间，因此在请求的精度范围内，后续请求不必重新计算根的边界，会非常快速地返回。

在上述评估之前，区间是

```py
>>> interval
(-1, 0) 
```

在评估之后，现在是

```py
>>> r._get_interval() 
(-165/169, -206/211) 
```

要重置给定多项式的所有区间，可以从多项式的任何 CRootOf 实例调用`_reset()`方法：

```py
>>> r._reset()
>>> r._get_interval()
(-1, 0) 
```

`eval_approx()`方法也会按所需精度找到根，但除非在根边界内搜索失败以收敛，否则不会修改区间。使用弦割法找到根。（`evalf`方法使用二分法，并始终更新区间。）

```py
>>> r.eval_approx(2)
-0.98 
```

需要稍微更新区间以找到该根：

```py
>>> r._get_interval()
(-1, -1/2) 
```

`evalf_rational`会计算根的有理近似，以达到所需的准确度或精度。

```py
>>> r.eval_rational(n=2)
-69629/71318 
```

```py
>>> t = CRootOf(x**3 + 10*x + 1, 1)
>>> t.eval_rational(1e-1)
15/256 - 805*I/256
>>> t.eval_rational(1e-1, 1e-4)
3275/65536 - 414645*I/131072
>>> t.eval_rational(1e-4, 1e-4)
6545/131072 - 414645*I/131072
>>> t.eval_rational(n=2)
104755/2097152 - 6634255*I/2097152 
```

注意

虽然可以从非符号生成器 RootOf 实例构造 PurePoly，但不允许使用非符号来避免对所表示的根的混淆。

```py
>>> from sympy import exp, PurePoly
>>> PurePoly(x) == PurePoly(exp(x))
True
>>> CRootOf(x - 1, 0)
1
>>> CRootOf(exp(x) - 1, 0)  # would correspond to x == 0
Traceback (most recent call last):
...
sympy.polys.polyerrors.PolynomialError: generator must be a Symbol 
```

参见

`eval_approx`，`eval_rational`

```py
classmethod _all_roots(poly, use_cache=True)
```

获取复合多项式的实根和复根。

```py
classmethod _complexes_index(complexes, index)
```

将初始复根索引映射到根所属因子中的索引。

```py
classmethod _complexes_sorted(complexes)
```

使复数隔离区间不相交并排序根。

```py
classmethod _count_roots(roots)
```

计算具有重数的实根或复根的数量。

```py
_ensure_complexes_init()
```

确保我们的多项式在复数缓存中有条目。

```py
_ensure_reals_init()
```

确保我们的多项式在实数缓存中有条目。

```py
_eval_evalf(prec, **kwargs)
```

对给定精度评估此复根。

```py
_eval_is_imaginary()
```

如果根是虚数则返回`True`。

```py
_eval_is_real()
```

如果根是实数则返回`True`。

```py
classmethod _get_complexes(factors, use_cache=True)
```

为一组因子计算复数根隔离区间。

```py
classmethod _get_complexes_sqf(currentfactor, use_cache=True)
```

获取一个无平方因子的复数根隔离区间。

```py
_get_interval()
```

从缓存中检索隔离区间的内部函数。

```py
classmethod _get_reals(factors, use_cache=True)
```

为一组因子计算实根隔离区间。

```py
classmethod _get_reals_sqf(currentfactor, use_cache=True)
```

获取一个无平方因子的实根隔离区间。

```py
classmethod _get_roots(method, poly, radicals)
```

返回指定类型的后处理根。

```py
classmethod _indexed_root(poly, index, lazy=False)
```

按索引获取复合多项式的一个根。

```py
classmethod _new(poly, index)
```

从原始数据构造新的`CRootOf`对象。

```py
classmethod _postprocess_root(root, radicals)
```

如果根是微不足道的或者是`CRootOf`对象，则返回根。

```py
classmethod _preprocess_roots(poly)
```

采取英雄般的措施使`poly`与`CRootOf`兼容。

```py
classmethod _real_roots(poly)
```

获取复合多项式的实根。

```py
classmethod _reals_index(reals, index)
```

将初始实根索引映射到根所属因子的索引。

```py
classmethod _reals_sorted(reals)
```

使实数隔离区间不重叠并排序根。

```py
classmethod _refine_complexes(complexes)
```

返回复数，使非共轭根的包围矩形不相交。此外，确保 ay 和 by 都不为 0，以确保非实根在 y 边界上与实根有所不同。

```py
_reset()
```

重置所有区间

```py
classmethod _roots_trivial(poly, radicals)
```

在线性、二次和二项情况下计算根。

```py
_set_interval(interval)
```

更新缓存中隔离区间的内部函数。

```py
classmethod all_roots(poly, radicals=True)
```

获取多项式的实根和复根。

```py
classmethod clear_cache()
```

重置实数和复数的缓存。

用于近似根实例的区间根据需要进行更新。当请求查看区间时，显示最新的值。\(clear_cache\)将所有`CRootOf`实例重置为其原始状态。

另见

`_reset`

```py
eval_approx(n, return_mpmath=False)
```

对给定精度评估此复根。

此方法使用割线法，根边界用于生成初始猜测并检查返回的根是否有效。如果方法在根边界外收敛，边界将变小并更新。

```py
eval_rational(dx=None, dy=None, n=15)
```

返回`self`的有理数近似，其实部和虚部近似值分别在`dx`和`dy`内。或者，可以指定`n`位精度。

通过二分法细化区间，并确保收敛。当细化完成时更新根的边界，因此在相同或更低的精度下重新计算不需要重复细化，应该会快得多。

下面的示例首先获得 4 阶 Legendre 多项式所有根的 1e-8 精度的有理数近似。由于所有根都小于 1，这将确保近似的十进制表示（包括四舍五入）正确到 6 位小数：

```py
>>> from sympy import legendre_poly, Symbol
>>> x = Symbol("x")
>>> p = legendre_poly(4, x, polys=True)
>>> r = p.real_roots()[-1]
>>> r.eval_rational(10**-8).n(6)
0.861136 
```

不必进行两步计算，然而：可以直接计算十进制表示：

```py
>>> r.evalf(17)
0.86113631159405258 
```

```py
classmethod real_roots(poly, radicals=True)
```

获取多项式的实根。

```py
class sympy.polys.rootoftools.RootSum(expr, func=None, x=None, auto=True, quadratic=False)
```

表示一元多项式所有根的和。

```py
classmethod new(poly, func, auto=True)
```

构造新的`RootSum`实例。

## 符号根查找算法

```py
sympy.polys.polyroots.roots(f, *gens, auto=True, cubics=True, trig=False, quartics=True, quintics=False, multiple=False, filter=None, predicate=None, strict=False, **flags)
```

计算一元多项式的符号根。

给定具有符号系数的一元多项式 f（或多项式系数的列表），返回包含其根及其重数的字典。

只有可以用根式表达的根将被返回。要获得完整的根集，请改用 RootOf 类或数值方法。默认情况下，算法中使用三次和四次公式。要禁用它们以避免不可读的输出，请设置`cubics=False`或`quartics=False`。如果三次根是实数但表达为复数形式（casus irreducibilis [1]），则可以将`trig`标志设置为 True，以便将解以余弦和反余弦函数的形式返回。

要从特定域获取根，使用`filter`标志并设置以下其中之一的说明符：Z，Q，R，I，C。默认情况下返回所有根（相当于设置`filter='C'`）。

默认情况下，返回一个字典，给出多根的紧凑结果。但是，要获取包含所有这些根的列表，请将`multiple`标志设置为 True；该列表将在结果中相同的根旁边出现。（对于给定的 Poly，all_roots 方法将以排序的数值顺序给出根。）

如果`strict`标志为 True，则如果找到的根已知不完整（因为某些根无法用根式表达），将引发`UnsolvableFactorError`。

示例

```py
>>> from sympy import Poly, roots, degree
>>> from sympy.abc import x, y 
```

```py
>>> roots(x**2 - 1, x)
{-1: 1, 1: 1} 
```

```py
>>> p = Poly(x**2-1, x)
>>> roots(p)
{-1: 1, 1: 1} 
```

```py
>>> p = Poly(x**2-y, x, y) 
```

```py
>>> roots(Poly(p, x))
{-sqrt(y): 1, sqrt(y): 1} 
```

```py
>>> roots(x**2 - y, x)
{-sqrt(y): 1, sqrt(y): 1} 
```

```py
>>> roots([1, 0, -1])
{-1: 1, 1: 1} 
```

`roots`只会返回可以用根式表达的根。如果给定的多项式有部分或全部根不能用根式表达，则`roots`的结果将分别是不完整或空的。

结果不完整的示例：

```py
>>> roots((x-1)*(x**5-x+1), x)
{1: 1} 
```

在这种情况下，多项式有一个无法解决的五次因子，其根无法用根式表达。由于总是能找到所有有理根，因此返回了一个有理根（因为因子\((x-1)\)），该根由`roots`返回。

结果为空的示例：

```py
>>> roots(x**7-3*x**2+1, x)
{} 
```

在这里，多项式没有可以用根式表达的根，因此`roots`返回一个空字典。

函数`roots`的结果仅当每个根的重数之和等于多项式的次数时才是完整的。如果`strict=True`，则如果结果不完整，将引发`UnsolvableFactorError`。

结果可以通过以下方式检查完整性：

```py
>>> f = x**3-2*x**2+1
>>> sum(roots(f, x).values()) == degree(f, x)
True
>>> f = (x-1)*(x**5-x+1)
>>> sum(roots(f, x).values()) == degree(f, x)
False 
```

参考

[R811]

[`en.wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions`](https://en.wikipedia.org/wiki/Cubic_equation#Trigonometric_and_hyperbolic_solutions)

## 特殊多项式

```py
sympy.polys.specialpolys.swinnerton_dyer_poly(n, x=None, polys=False)
```

生成\(x\)的第\(n\)个 Swinnerton-Dyer 多项式。

参数：

**n**：整数

> \(n\)决定多项式的阶数

**x**：可选

**polys**：布尔型，可选

> `polys=True`返回一个表达式，否则（默认）返回一个表达式。

```py
sympy.polys.specialpolys.interpolating_poly(n, x, X='x', Y='y')
```

构造拉格朗日插值多项式以适应`n`个数据点。如果为`X`和`Y`给出了一系列值，则将使用前`n`个值。

```py
sympy.polys.specialpolys.cyclotomic_poly(n, x=None, polys=False)
```

生成\(x\)的阶为\(n\)的旋轮多项式。

参数：

**n**：整数

> \(n\)决定多项式的阶数

**x**：可选

**polys**：布尔型，可选

> `polys=True`返回一个表达式，否则（默认）返回一个表达式。

```py
sympy.polys.specialpolys.symmetric_poly(n, *gens, polys=False)
```

生成阶为\(n\)的对称多项式。

参数：

**polys: bool, optional (default: False)**

> 当`polys=True`时返回一个多项式对象，否则（默认）返回一个表达式。

```py
sympy.polys.specialpolys.random_poly(x, n, inf, sup, domain=ZZ, polys=False)
```

生成一个系数在`[inf, sup]`内的阶数为`n`的多项式。

参数：

**x**

> \(x\)是多项式的独立项

**n**：整数

> \(n\)决定多项式的阶数

**inf**

> 系数所在范围的下限

**sup**

> 系数所在范围的上限

**domain**：可选

> 决定系数应属于哪个环。默认设置为整数。

**polys**：布尔型，可选

> `polys=True`返回一个表达式，否则（默认）返回一个表达式。

## 正交多项式

```py
sympy.polys.orthopolys.chebyshevt_poly(n, x=None, polys=False)
```

生成第一类 Chebyshev 多项式\(T_n(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.chebyshevu_poly(n, x=None, polys=False)
```

生成第二类 Chebyshev 多项式\(U_n(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.gegenbauer_poly(n, a, x=None, polys=False)
```

生成 Gegenbauer 多项式\(C_n^{(a)}(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**a**

> 决定系数列表的最小定义域。

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.hermite_poly(n, x=None, polys=False)
```

生成 Hermite 多项式\(H_n(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.hermite_prob_poly(n, x=None, polys=False)
```

生成概率论的 Hermite 多项式\(He_n(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.jacobi_poly(n, a, b, x=None, polys=False)
```

生成 Jacobi 多项式\(P_n^{(a,b)}(x)\)。

参数：

**n**：整数

> 多项式的次数。

**a**

> 系数列表的最小定义域的下限。

**b**

> 系数列表的最小定义域的上限。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.legendre_poly(n, x=None, polys=False)
```

生成 Legendre 多项式\(P_n(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.laguerre_poly(n, x=None, alpha=0, polys=False)
```

生成 Laguerre 多项式\(L_n^{(\alpha)}(x)\)。

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**alpha**：可选

> 决定系数列表的最小定义域。

**polys**：布尔型，可选

> 如果为真，返回一个多项式，否则（默认）返回一个表达式。

```py
sympy.polys.orthopolys.spherical_bessel_fn(n, x=None, polys=False)
```

球形贝塞尔函数的系数。

仅在 jn()函数中需要这些。

系数由以下计算：

fn(0, z) = 1/z fn(1, z) = 1/z**2 fn(n-1, z) + fn(n+1, z) == (2*n+1)/z * fn(n, z)

参数：

**n**：整数

> 多项式的次数。

**x**：可选

**polys**：布尔型，可选

> 如果为真，则返回一个 Poly，否则（默认）返回一个表达式。

示例

```py
>>> from sympy.polys.orthopolys import spherical_bessel_fn as fn
>>> from sympy import Symbol
>>> z = Symbol("z")
>>> fn(1, z)
z**(-2)
>>> fn(2, z)
-1/z + 3/z**3
>>> fn(3, z)
-6/z**2 + 15/z**4
>>> fn(4, z)
1/z - 45/z**3 + 105/z**5 
```

## Appell 序列

```py
sympy.polys.appellseqs.bernoulli_poly(n, x=None, polys=False)
```

生成伯努利多项式 \(\operatorname{B}_n(x)\)。

\(\operatorname{B}_n(x)\)是满足以下唯一性质的多项式：

\[\int_{x}^{x+1} \operatorname{B}_n(t) \,dt = x^n.\]

基于此，我们对非负整数\(s\)和整数\(a\)和\(b\)有：

\[\sum_{k=a}^{b} k^s = \frac{\operatorname{B}_{s+1}(b+1) - \operatorname{B}_{s+1}(a)}{s+1}\]

这与 Jakob Bernoulli 引入伯努利数的最初动机有关，这些多项式在\(x = 1\)处的值。

参数：

**n** : 整数

> 多项式的次数。

**x** : 可选

**polys** : 布尔值，可选

> 如果为真，则返回一个 Poly，否则（默认）返回一个表达式。

示例

```py
>>> from sympy import summation
>>> from sympy.abc import x
>>> from sympy.polys import bernoulli_poly
>>> bernoulli_poly(5, x)
x**5 - 5*x**4/2 + 5*x**3/3 - x/6 
```

```py
>>> def psum(p, a, b):
...     return (bernoulli_poly(p+1,b+1) - bernoulli_poly(p+1,a)) / (p+1)
>>> psum(4, -6, 27)
3144337
>>> summation(x**4, (x, -6, 27))
3144337 
```

```py
>>> psum(1, 1, x).factor()
x*(x + 1)/2
>>> psum(2, 1, x).factor()
x*(x + 1)*(2*x + 1)/6
>>> psum(3, 1, x).factor()
x**2*(x + 1)**2/4 
```

参见

`sympy.functions.combinatorial.numbers.bernoulli`

参考文献

[R812]

[`en.wikipedia.org/wiki/Bernoulli_polynomials`](https://en.wikipedia.org/wiki/Bernoulli_polynomials)

```py
sympy.polys.appellseqs.bernoulli_c_poly(n, x=None, polys=False)
```

生成中心伯努利多项式 \(\operatorname{B}_n^c(x)\)。

这些是普通伯努利多项式的缩放和平移版本，以便\(\operatorname{B}_n^c(x)\)分别为偶函数或奇函数，对应于偶数或奇数的\(n\)：

\[\operatorname{B}_n^c(x) = 2^n \operatorname{B}_n \left(\frac{x+1}{2}\right)\]

参数：

**n** : 整数

> 多项式的次数。

**x** : 可选

**polys** : 布尔值，可选

> 如果为真，则返回一个 Poly，否则（默认）返回一个表达式。

```py
sympy.polys.appellseqs.genocchi_poly(n, x=None, polys=False)
```

生成 Genocchi 多项式 \(\operatorname{G}_n(x)\)。

\(\operatorname{G}_n(x)\)是普通和中心伯努利多项式之差的两倍，因此次数为\(n-1\)：

\[\operatorname{G}_n(x) = 2 (\operatorname{B}_n(x) - \operatorname{B}_n^c(x))\]

定义中的因子 2 赋予\(\operatorname{G}_n(x)\)整数系数。

参数：

**n** : 整数

> 多项式的次数加一。

**x** : 可选

**polys** : 布尔值，可选

> 如果为真，则返回一个 Poly，否则（默认）返回一个表达式。

参见

`sympy.functions.combinatorial.numbers.genocchi`

```py
sympy.polys.appellseqs.euler_poly(n, x=None, polys=False)
```

生成 Euler 多项式 \(\operatorname{E}_n(x)\)。

这些是 Genocchi 多项式的缩放和重新索引版本：

\[\operatorname{E}_n(x) = -\frac{\operatorname{G}_{n+1}(x)}{n+1}\]

参数：

**n** : 整数

> 多项式的次数。

**x** : 可选

**polys** : 布尔值，可选

> 如果为真，则返回一个 Poly，否则（默认）返回一个表达式。

参见

`sympy.functions.combinatorial.numbers.euler`

```py
sympy.polys.appellseqs.andre_poly(n, x=None, polys=False)
```

生成 Andre 多项式 \(\mathcal{A}_n(x)\)。

这是 Appell 序列，其中常数系数形成欧拉数序列`euler(n)`。因此它们具有整数系数，并且与\( n \)的奇偶性匹配。

Luschny 称之为*瑞士军刀多项式*，因为它们在 0 和 1 处的值可以简单地转化为伯努利数和欧拉数。在这里它们被称为 Andre 多项式，因为对于\( n \ge 0 \)，\( |\mathcal{A}_n(n\bmod 2)| \)生成了 Luschny 所称的*Andre 数*，在 OEIS 中是 A000111。

参数：

**n** : int

> 多项式的次数。

**x** : optional

**polys** : bool, optional

> 如果为 True，则返回 Poly，否则（默认）返回一个表达式。

示例

```py
>>> from sympy import bernoulli, euler, genocchi
>>> from sympy.abc import x
>>> from sympy.polys import andre_poly
>>> andre_poly(9, x)
x**9 - 36*x**7 + 630*x**5 - 5124*x**3 + 12465*x 
```

```py
>>> [andre_poly(n, 0) for n in range(11)]
[1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]
>>> [euler(n) for n in range(11)]
[1, 0, -1, 0, 5, 0, -61, 0, 1385, 0, -50521]
>>> [andre_poly(n-1, 1) * n / (4**n - 2**n) for n in range(1, 11)]
[1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]
>>> [bernoulli(n) for n in range(1, 11)]
[1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]
>>> [-andre_poly(n-1, -1) * n / (-2)**(n-1) for n in range(1, 11)]
[-1, -1, 0, 1, 0, -3, 0, 17, 0, -155]
>>> [genocchi(n) for n in range(1, 11)]
[-1, -1, 0, 1, 0, -3, 0, 17, 0, -155] 
```

```py
>>> [abs(andre_poly(n, n%2)) for n in range(11)]
[1, 1, 1, 2, 5, 16, 61, 272, 1385, 7936, 50521] 
```

另见

`sympy.functions.combinatorial.numbers.andre`

参考

[R813]

Peter Luschny，“伯努利函数简介”，[`arxiv.org/abs/2009.06743`](https://arxiv.org/abs/2009.06743)

## 操作有理函数

```py
sympy.polys.rationaltools.together(expr, deep=False, fraction=True)
```

使用符号方法去除并组合有理表达式。

此函数接受表达式或表达式容器，并通过去除嵌套和组合有理子表达式将其放在一起。不会采取英雄般的措施来最小化生成的分子和分母的次数。要获取完全简化的表达式，请使用`cancel()`。然而，`together()`可以尽可能地保留输入表达式的结构（不会执行扩展）。

可以组合多种对象，包括列表、元组、集合、关系对象、积分等。还可以通过将`deep`标志设置为`True`来转换函数应用的内部。

根据定义，`together()`是`apart()`的补充，因此`apart(together(expr))`应该返回未改变的表达式。然而，请注意，`together()`仅使用符号方法，因此可能需要使用`cancel()`进行代数化简并最小化分子和分母的次数。

示例

```py
>>> from sympy import together, exp
>>> from sympy.abc import x, y, z 
```

```py
>>> together(1/x + 1/y)
(x + y)/(x*y)
>>> together(1/x + 1/y + 1/z)
(x*y + x*z + y*z)/(x*y*z) 
```

```py
>>> together(1/(x*y) + 1/y**2)
(x + y)/(x*y**2) 
```

```py
>>> together(1/(1 + 1/x) + 1/(1 + 1/y))
(x*(y + 1) + y*(x + 1))/((x + 1)*(y + 1)) 
```

```py
>>> together(exp(1/x + 1/y))
exp(1/y + 1/x)
>>> together(exp(1/x + 1/y), deep=True)
exp((x + y)/(x*y)) 
```

```py
>>> together(1/exp(x) + 1/(x*exp(x)))
(x + 1)*exp(-x)/x 
```

```py
>>> together(1/exp(2*x) + 1/(x*exp(3*x)))
(x*exp(x) + 1)*exp(-3*x)/x 
```

## 部分分解

```py
sympy.polys.partfrac.apart(f, x=None, full=False, **options)
```

计算有理函数的部分分解。

给定有理函数`f`，计算`f`的部分分解。有两种算法可用：一种基于未知系数方法，另一种是 Bronstein 的完全部分分解算法。

使用未知系数法（通过 `full=False` 选择）使用多项式因式分解（因此接受与因子相同的选项）用于分母。默认情况下它在有理数上工作，因此不支持具有非有理根（例如无理数，复根）的分母的分解（参见因子的选项）。

通过使用 `full=True` 可选择 Bronstein 算法，并允许分解具有非有理根的分母。可以通过 `doit()` 获得一个易于理解的结果（见下面的示例）。

示例

```py
>>> from sympy.polys.partfrac import apart
>>> from sympy.abc import x, y 
```

默认情况下，使用待定系数法：

```py
>>> apart(y/(x + 2)/(x + 1), x)
-y/(x + 2) + y/(x + 1) 
```

当分母的根不是有理数时，待定系数法不会给出结果：

```py
>>> apart(y/(x**2 + x + 1), x)
y/(x**2 + x + 1) 
```

通过设置 `full=True` 可选择 Bronstein 的算法：

```py
>>> apart(y/(x**2 + x + 1), x, full=True)
RootSum(_w**2 + _w + 1, Lambda(_a, (-2*_a*y/3 - y/3)/(-_a + x))) 
```

调用 `doit()` 会产生一个易于理解的结果：

```py
>>> apart(y/(x**2 + x + 1), x, full=True).doit()
(-y/3 - 2*y*(-1/2 - sqrt(3)*I/2)/3)/(x + 1/2 + sqrt(3)*I/2) + (-y/3 -
 2*y*(-1/2 + sqrt(3)*I/2)/3)/(x + 1/2 - sqrt(3)*I/2) 
```

参见

`apart_list`, `assemble_partfrac_list`

```py
sympy.polys.partfrac.apart_list(f, x=None, dummies=None, **options)
```

计算有理函数的部分分解，并以结构化形式返回结果。

给定有理函数 `f`，计算 `f` 的部分分解。此方法仅支持 Bronstein 的完全部分分解算法。返回值结构化且非常适合进一步的算法处理，而不是易于理解的人类阅读。函数返回一个包含三个元素的元组：

+   第一项是通用系数，不涉及用于分解的变量 \(x\)。（它是基础域 \(K\) 的元素。）

+   第二项是分解的多项式部分。这可以是零多项式。（它是 \(K[x]\) 的元素。）

+   第三部分本身是一个四元组列表。每个四元组按照以下顺序具有以下元素：

    +   多个相关分式项的线性分母中出现的根 \(w_i\) 的多项式 \(D\)（不一定是不可约的）。（该项也可以是显式根的列表。然而，目前 `apart_list` 从未以这种方式返回结果，但相关的 `assemble_partfrac_list` 函数接受此格式作为输入。）

    +   分数的分子，写成关于根 \(w\) 的函数

    +   分数的线性分母 *不包括其幂指数*，写成根 \(w\) 的函数。

    +   分母必须提升的幂。

可以始终通过使用函数 `assemble_partfrac_list` 重建简单表达式。

示例

第一个例子：

```py
>>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list
>>> from sympy.abc import x, t 
```

```py
>>> f = (2*x**3 - 2*x) / (x**2 - 2*x + 1)
>>> pfd = apart_list(f)
>>> pfd
(1,
Poly(2*x + 4, x, domain='ZZ'),
[(Poly(_w - 1, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
2*x + 4 + 4/(x - 1) 
```

第二个例子：

```py
>>> f = (-2*x - 2*x**2) / (3*x**2 - 6*x)
>>> pfd = apart_list(f)
>>> pfd
(-1,
Poly(2/3, x, domain='QQ'),
[(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 2), Lambda(_a, -_a + x), 1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
-2/3 - 2/(x - 2) 
```

另一个例子，展示符号参数：

```py
>>> pfd = apart_list(t/(x**2 + x + t), x)
>>> pfd
(1,
Poly(0, x, domain='ZZ[t]'),
[(Poly(_w**2 + _w + t, _w, domain='ZZ[t]'),
Lambda(_a, -2*_a*t/(4*t - 1) - t/(4*t - 1)),
Lambda(_a, -_a + x),
1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
RootSum(_w**2 + _w + t, Lambda(_a, (-2*_a*t/(4*t - 1) - t/(4*t - 1))/(-_a + x))) 
```

此示例摘自 Bronstein 的原始论文：

```py
>>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)
>>> pfd = apart_list(f)
>>> pfd
(1,
Poly(0, x, domain='ZZ'),
[(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),
(Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),
(Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
-4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2) 
```

参见

`apart`, `assemble_partfrac_list`

参考文献

[R814]

[[Bronstein93]](literature.html#bronstein93)

```py
sympy.polys.partfrac.assemble_partfrac_list(partial_list)
```

通过函数 `apart_list` 获得的结构化结果重新组装完整的部分分数分解。

示例

此示例取自 Bronstein 的原始论文：

```py
>>> from sympy.polys.partfrac import apart_list, assemble_partfrac_list
>>> from sympy.abc import x 
```

```py
>>> f = 36 / (x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2)
>>> pfd = apart_list(f)
>>> pfd
(1,
Poly(0, x, domain='ZZ'),
[(Poly(_w - 2, _w, domain='ZZ'), Lambda(_a, 4), Lambda(_a, -_a + x), 1),
(Poly(_w**2 - 1, _w, domain='ZZ'), Lambda(_a, -3*_a - 6), Lambda(_a, -_a + x), 2),
(Poly(_w + 1, _w, domain='ZZ'), Lambda(_a, -4), Lambda(_a, -_a + x), 1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
-4/(x + 1) - 3/(x + 1)**2 - 9/(x - 1)**2 + 4/(x - 2) 
```

如果我们恰好知道一些根，则可以轻松地在结构内提供它们：

```py
>>> pfd = apart_list(2/(x**2-2))
>>> pfd
(1,
Poly(0, x, domain='ZZ'),
[(Poly(_w**2 - 2, _w, domain='ZZ'),
Lambda(_a, _a/2),
Lambda(_a, -_a + x),
1)]) 
```

```py
>>> pfda = assemble_partfrac_list(pfd)
>>> pfda
RootSum(_w**2 - 2, Lambda(_a, _a/(-_a + x)))/2 
```

```py
>>> pfda.doit()
-sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2))) 
```

```py
>>> from sympy import Dummy, Poly, Lambda, sqrt
>>> a = Dummy("a")
>>> pfd = (1, Poly(0, x, domain='ZZ'), [([sqrt(2),-sqrt(2)], Lambda(a, a/2), Lambda(a, -a + x), 1)]) 
```

```py
>>> assemble_partfrac_list(pfd)
-sqrt(2)/(2*(x + sqrt(2))) + sqrt(2)/(2*(x - sqrt(2))) 
```

参见

`apart`, `apart_list`

## 多项式的分散

```py
sympy.polys.dispersion.dispersionset(p, q=None, *gens, **args)
```

计算两个多项式的*分散集*。

对于两个多项式 \(f(x)\) 和 \(g(x)\)，其中 \(\deg f > 0\) 和 \(\deg g > 0\)，分散集 \(\operatorname{J}(f, g)\) 定义如下：

\[\begin{split}\operatorname{J}(f, g) & := \{a \in \mathbb{N}_0 | \gcd(f(x), g(x+a)) \neq 1\} \\ & = \{a \in \mathbb{N}_0 | \deg \gcd(f(x), g(x+a)) \geq 1\}\end{split}\]

对于单个多项式，定义为 \(\operatorname{J}(f) := \operatorname{J}(f, f)\)。

示例

```py
>>> from sympy import poly
>>> from sympy.polys.dispersion import dispersion, dispersionset
>>> from sympy.abc import x 
```

简单多项式的分散集和分散度：

```py
>>> fp = poly((x - 3)*(x + 3), x)
>>> sorted(dispersionset(fp))
[0, 6]
>>> dispersion(fp)
6 
```

请注意分散的定义不对称：

```py
>>> fp = poly(x**4 - 3*x**2 + 1, x)
>>> gp = fp.shift(-3)
>>> sorted(dispersionset(fp, gp))
[2, 3, 4]
>>> dispersion(fp, gp)
4
>>> sorted(dispersionset(gp, fp))
[]
>>> dispersion(gp, fp)
-oo 
```

分散计算也适用于域扩展：

```py
>>> from sympy import sqrt
>>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')
>>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')
>>> sorted(dispersionset(fp, gp))
[2]
>>> sorted(dispersionset(gp, fp))
[1, 4] 
```

我们甚至可以为具有符号系数的多项式执行计算：

```py
>>> from sympy.abc import a
>>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)
>>> sorted(dispersionset(fp))
[0, 1] 
```

参见

`dispersion`

参考文献

[R815]

[[ManWright94]](literature.html#manwright94)

[R816]

[[Koepf98]](literature.html#koepf98)

[R817]

[[Abramov71]](literature.html#abramov71)

[R818]

[[Man93]](literature.html#man93)

```py
sympy.polys.dispersion.dispersion(p, q=None, *gens, **args)
```

计算多项式的*分散*。

对于两个多项式 \(f(x)\) 和 \(g(x)\)，其中 \(\deg f > 0\) 和 \(\deg g > 0\)，分散 \(\operatorname{dis}(f, g)\) 定义如下：

\[\begin{split}\operatorname{dis}(f, g) & := \max\{ J(f,g) \cup \{0\} \} \\ & = \max\{ \{a \in \mathbb{N} | \gcd(f(x), g(x+a)) \neq 1\} \cup \{0\} \}\end{split}\]

对于单个多项式 \(\operatorname{dis}(f) := \operatorname{dis}(f, f)\)，请注意我们定义 \(\max\{\} := -\infty\)。

示例

```py
>>> from sympy import poly
>>> from sympy.polys.dispersion import dispersion, dispersionset
>>> from sympy.abc import x 
```

简单多项式的分散集和分散度：

```py
>>> fp = poly((x - 3)*(x + 3), x)
>>> sorted(dispersionset(fp))
[0, 6]
>>> dispersion(fp)
6 
```

请注意分散的定义不对称：

```py
>>> fp = poly(x**4 - 3*x**2 + 1, x)
>>> gp = fp.shift(-3)
>>> sorted(dispersionset(fp, gp))
[2, 3, 4]
>>> dispersion(fp, gp)
4
>>> sorted(dispersionset(gp, fp))
[]
>>> dispersion(gp, fp)
-oo 
```

空集的最大值定义为 \(-\infty\)，如本例所示。

分散计算也适用于域扩展：

```py
>>> from sympy import sqrt
>>> fp = poly(x**2 + sqrt(5)*x - 1, x, domain='QQ<sqrt(5)>')
>>> gp = poly(x**2 + (2 + sqrt(5))*x + sqrt(5), x, domain='QQ<sqrt(5)>')
>>> sorted(dispersionset(fp, gp))
[2]
>>> sorted(dispersionset(gp, fp))
[1, 4] 
```

我们甚至可以为具有符号系数的多项式执行计算：

```py
>>> from sympy.abc import a
>>> fp = poly(4*x**4 + (4*a + 8)*x**3 + (a**2 + 6*a + 4)*x**2 + (a**2 + 2*a)*x, x)
>>> sorted(dispersionset(fp))
[0, 1] 
```

参见

`dispersionset`

参考文献

[R819]

[[ManWright94]](literature.html#manwright94)

[R820]

[[Koepf98]](literature.html#koepf98)

[R821]

[[Abramov71]](literature.html#abramov71)

[R822]

[[Man93]](literature.html#man93)
