- en: Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑
- en: Original text：[https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/logic.html](https://docs.sympy.org/latest/modules/logic.html)
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 介绍'
- en: The logic module for SymPy allows to form and manipulate logic expressions using
    symbolic and Boolean values.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 的逻辑模块允许使用符号和布尔值形成和操作逻辑表达式。
- en: Forming logical expressions
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形成逻辑表达式
- en: 'You can build Boolean expressions with the standard python operators `&` ([`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And")), `|` ([`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")),
    `~` ([`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not")):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的 Python 操作符`&`（[`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")）、`|`（[`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or")）、`~`（[`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not")）构建布尔表达式：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also form implications with `>>` and `<<`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`>>`和`<<`形成含义：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Like most types in SymPy, Boolean expressions inherit from [`Basic`](core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 像 SymPy 中的大多数类型一样，布尔表达式继承自 [`Basic`](core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The logic module also includes the following functions to derive boolean expressions
    from their truth tables:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 的逻辑模块还包括以下功能，可从其真值表中推导布尔表达式：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SOPform function uses simplified_pairs and a redundant group- eliminating
    algorithm to convert the list of all input combos that generate ‘1’ (the minterms)
    into the smallest sum-of-products form.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`SOPform`使用简化对和冗余组消除算法将产生‘1’的所有输入组合列表（即最小项）转换为最小的“求和乘积”形式。
- en: The variables must be given as the first argument.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须作为第一个参数给出。
- en: Return a logical [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or") function
    (i.e., the “sum of products” or “SOP” form) that gives the desired outcome. If
    there are inputs that can be ignored, pass them as a list, too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 返回逻辑 [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or") 函数（即“求和乘积”或“SOP”形式），以达到所需的结果。如果有可以忽略的输入，请也将它们作为列表传递。
- en: The result will be one of the (perhaps many) functions that satisfy the conditions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是满足条件的函数之一（也许有多个）。
- en: Examples
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The terms can also be represented as integers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 术语也可以表示为整数：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'They can also be specified using dicts, which does not have to be fully specified:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还可以使用字典来指定，不必完全指定：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or a combination:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或其组合：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`POSform`](#sympy.logic.boolalg.POSform "sympy.logic.boolalg.POSform")'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[`POSform`](#sympy.logic.boolalg.POSform "sympy.logic.boolalg.POSform")'
- en: References
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R600](#id1)]'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R600](#id1)]'
- en: '[https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm](https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/奎因-麦克拉斯基算法](https://zh.wikipedia.org/wiki/奎因-麦克拉斯基算法)'
- en: '[[R601](#id2)]'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R601](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/无关紧要的术语](https://zh.wikipedia.org/wiki/无关紧要的术语)'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The POSform function uses simplified_pairs and a redundant-group eliminating
    algorithm to convert the list of all input combinations that generate ‘1’ (the
    minterms) into the smallest product-of-sums form.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`POSform`使用简化对和冗余组消除算法将产生‘1’的所有输入组合列表（即最小项）转换为最小的“乘积求和”形式。
- en: The variables must be given as the first argument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须作为第一个参数给出。
- en: Return a logical [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")
    function (i.e., the “product of sums” or “POS” form) that gives the desired outcome.
    If there are inputs that can be ignored, pass them as a list, too.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 返回逻辑 [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And") 函数（即“乘积求和”或“POS”形式），以达到所需的结果。如果有可以忽略的输入，请也将它们作为列表传递。
- en: The result will be one of the (perhaps many) functions that satisfy the conditions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是满足条件的函数之一（也许有多个）。
- en: Examples
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The terms can also be represented as integers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 术语也可以表示为整数：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'They can also be specified using dicts, which does not have to be fully specified:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还可以使用字典来指定，不必完全指定：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or a combination:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或其组合：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`SOPform`](#sympy.logic.boolalg.SOPform "sympy.logic.boolalg.SOPform")'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SOPform`](#sympy.logic.boolalg.SOPform "sympy.logic.boolalg.SOPform")'
- en: References
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R602](#id3)]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R602](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm](https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/奎因-麦克拉斯基算法](https://zh.wikipedia.org/wiki/奎因-麦克拉斯基算法)'
- en: '[[R603](#id4)]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R603](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/无关紧要的术语](https://zh.wikipedia.org/wiki/无关紧要的术语)'
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ANFform function converts the list of truth values to Algebraic Normal Form
    (ANF).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ANFform 函数将真值列表转换为代数正常形式（ANF）。
- en: The variables must be given as the first argument.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须作为第一个参数给出。
- en: Return True, False, logical [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")
    function (i.e., the “Zhegalkin monomial”) or logical [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor") function (i.e., the “Zhegalkin polynomial”). When True
    and False are represented by 1 and 0, respectively, then [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And") is multiplication and [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor") is addition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`True`、`False`、逻辑[`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")函数（即“Zhegalkin单项式”）或逻辑[`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor")函数（即“Zhegalkin多项式”）。当True和False分别由1和0表示时，[`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And")为乘法，[`Xor`](#sympy.logic.boolalg.Xor "sympy.logic.boolalg.Xor")为加法。
- en: Formally a “Zhegalkin monomial” is the product (logical And) of a finite set
    of distinct variables, including the empty set whose product is denoted 1 (True).
    A “Zhegalkin polynomial” is the sum (logical Xor) of a set of Zhegalkin monomials,
    with the empty set denoted by 0 (False).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，“Zhegalkin单项式”是一组不同变量（包括空集）的乘积（逻辑And），其乘积表示为1（True）。“Zhegalkin多项式”是Zhegalkin单项式集合的和（逻辑Xor），其中空集表示为0（False）。
- en: 'Parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**variables** : list of variables'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**：变量列表'
- en: '**truthvalues** : list of 1’s and 0’s (result column of truth table)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**真值**：1 和 0 的列表（真值表的结果列）'
- en: Examples
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: References
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R604](#id5)]'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R604](#id5)]'
- en: '[https://en.wikipedia.org/wiki/Zhegalkin_polynomial](https://en.wikipedia.org/wiki/Zhegalkin_polynomial)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/Zhegalkin_polynomial](https://en.wikipedia.org/wiki/Zhegalkin_polynomial)'
- en: Boolean functions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔函数
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A Boolean object is an object for which logic operations make sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔对象是一种逻辑操作有意义的对象。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Rewrites Boolean expression in terms of real sets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 用实集的术语重写布尔表达式。
- en: Examples
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Returns `True` if the given formulas have the same truth table. For two formulas
    to be equal they must have the same literals.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的公式具有相同的真值表，则返回`True`。要使两个公式相等，它们必须具有相同的文字。
- en: Examples
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: SymPy version of `True`, a singleton that can be accessed via `S.true`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy版本的`True`，可以通过`S.true`访问的单例。
- en: This is the SymPy version of `True`, for use in the logic module. The primary
    advantage of using `true` instead of `True` is that shorthand Boolean operations
    like `~` and `>>` will work as expected on this class, whereas with True they
    act bitwise on 1\. Functions in the logic module will return this class when they
    evaluate to true.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逻辑模块中使用的SymPy版本的`True`。使用`true`而不是`True`的主要优势在于，像`~`和`>>`这样的简写布尔操作在这个类上将按预期工作，而在`True`上则按位操作1。在逻辑模块中，当函数求值为true时，它们将返回这个类。
- en: Notes
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is liable to be some confusion as to when `True` should be used and when
    `S.true` should be used in various contexts throughout SymPy. An important thing
    to remember is that `sympify(True)` returns `S.true`. This means that for the
    most part, you can just use `True` and it will automatically be converted to `S.true`
    when necessary, similar to how you can generally use 1 instead of `S.One`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy的各种上下文中，关于何时使用`True`和何时使用`S.true`可能会有些混淆。重要的是要记住，`sympify(True)`返回`S.true`。这意味着在大多数情况下，您可以直接使用`True`，必要时它会自动转换为`S.true`，类似于您通常可以使用1代替`S.One`。
- en: 'The rule of thumb is:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则是：
- en: “If the boolean in question can be replaced by an arbitrary symbolic `Boolean`,
    like `Or(x, y)` or `x > 1`, use `S.true`. Otherwise, use `True`”
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “如果所讨论的布尔值可以被任意符号的`Boolean`替换，如`Or(x, y)`或`x > 1`，则使用`S.true`。否则，使用`True`”
- en: In other words, use `S.true` only on those contexts where the boolean is being
    used as a symbolic representation of truth. For example, if the object ends up
    in the `.args` of any expression, then it must necessarily be `S.true` instead
    of `True`, as elements of `.args` must be `Basic`. On the other hand, `==` is
    not a symbolic operation in SymPy, since it always returns `True` or `False`,
    and does so in terms of structural equality rather than mathematical, so it should
    return `True`. The assumptions system should use `True` and `False`. Aside from
    not satisfying the above rule of thumb, the assumptions system uses a three-valued
    logic (`True`, `False`, `None`), whereas `S.true` and `S.false` represent a two-valued
    logic. When in doubt, use `True`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，仅在布尔用作真实符号表示的情况下使用`S.true`。例如，如果对象最终位于任何表达式的`.args`中，则必须是`S.true`而不是`True`，因为`.args`的元素必须是`Basic`。另一方面，`==`在SymPy中不是一个符号操作，因为它总是以结构相等性返回`True`或`False`，而不是数学上的相等性，因此应该返回`True`。假设系统应使用`True`和`False`。除了不满足上述经验法则外，假设系统使用三值逻辑（`True`，`False`，`None`），而`S.true`和`S.false`表示二值逻辑。当有疑问时，使用`True`。
- en: “`S.true == True is True`.”
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “`S.true == True is True`.”
- en: 'While “`S.true is True`” is `False`, “`S.true == True`” is `True`, so if there
    is any doubt over whether a function or expression will return `S.true` or `True`,
    just use `==` instead of `is` to do the comparison, and it will work in either
    case. Finally, for boolean flags, it’s better to just use `if x` instead of `if
    x is True`. To quote PEP 8:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“`S.true is True`”是`False`，但“`S.true == True`”是`True`，因此，如果对于函数或表达式是否会返回`S.true`或`True`存在任何疑问，只需使用`==`而不是`is`来进行比较，它将在任何情况下都起作用。最后，对于布尔标志，最好只是使用`if
    x`而不是`if x is True`。引用PEP 8：
- en: Do not compare boolean values to `True` or `False` using `==`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`==`将布尔值与`True`或`False`进行比较。
- en: 'Yes: `if greeting:`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是的：`if greeting:`
- en: 'No: `if greeting == True:`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不：`if greeting == True:`
- en: 'Worse: `if greeting is True:`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更糟糕的是：`if greeting is True:`
- en: Examples
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Python operators give a boolean result for true but a bitwise result for True
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python运算符对true给出布尔结果，但对True给出位结果
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.logic.boolalg.BooleanFalse`](#sympy.logic.boolalg.BooleanFalse "sympy.logic.boolalg.BooleanFalse")'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.logic.boolalg.BooleanFalse`](#sympy.logic.boolalg.BooleanFalse "sympy.logic.boolalg.BooleanFalse")'
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Rewrite logic operators and relationals in terms of real sets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重写逻辑运算符和关系运算符以真实集合的术语表示。
- en: Examples
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: SymPy version of `False`, a singleton that can be accessed via `S.false`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy版本的`False`，可以通过`S.false`访问的单例。
- en: This is the SymPy version of `False`, for use in the logic module. The primary
    advantage of using `false` instead of `False` is that shorthand Boolean operations
    like `~` and `>>` will work as expected on this class, whereas with `False` they
    act bitwise on 0\. Functions in the logic module will return this class when they
    evaluate to false.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SymPy版本的`False`，用于逻辑模块中。使用`false`而不是`False`的主要优势在于，像`~`和`>>`这样的简便布尔运算符会按预期在这个类上起作用，而对于`False`，它们会按位操作0。在逻辑模块中，当它们评估为false时，函数将返回此类。
- en: Notes
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: See the notes section in [`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue
    "sympy.logic.boolalg.BooleanTrue")
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue "sympy.logic.boolalg.BooleanTrue")的注释部分查看笔记
- en: Examples
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Python operators give a boolean result for false but a bitwise result for False
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python运算符对false给出布尔结果，但对False给出位结果
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue "sympy.logic.boolalg.BooleanTrue")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.logic.boolalg.BooleanTrue`](#sympy.logic.boolalg.BooleanTrue "sympy.logic.boolalg.BooleanTrue")'
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Rewrite logic operators and relationals in terms of real sets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重写逻辑运算符和关系运算符以真实集合的术语表示。
- en: Examples
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Logical AND function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与功能。
- en: It evaluates its arguments in order, returning false immediately when an argument
    is false and true if they are all true.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个参数为false时，按顺序评估其参数，如果它们都为true，则立即返回false。
- en: Examples
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: The `&` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise and. Hence, `And(a,
    b)` and `a & b` will produce different results if `a` and `b` are integers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与操作符`&`作为便利性提供，但请注意其在这里的使用与Python中的正常用法不同，即它是位与。因此，`And(a, b)`和`a & b`将在`a`和`b`为整数时产生不同的结果。
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Logical OR function
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或函数
- en: It evaluates its arguments in order, returning true immediately when an argument
    is true, and false if they are all false.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序评估其参数，如果一个参数为真，则立即返回true，如果它们都为false，则返回false。
- en: Examples
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 举例
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notes
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: The `|` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise or. Hence, `Or(a, b)`
    and `a | b` will return different things if `a` and `b` are integers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 操作符是为了方便起见提供的，但请注意，它在这里的使用与 Python 中的正常用法不同，Python 中它表示按位或。因此，如果 `a` 和
    `b` 是整数，`Or(a, b)` 和 `a | b` 将返回不同的结果。'
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Logical Not function (negation)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 Not 函数（否定）
- en: Returns `true` if the statement is `false` or `False`. Returns `false` if the
    statement is `true` or `True`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句为 `false` 或 `False`，则返回 `true`；如果语句为 `true` 或 `True`，则返回 `false`。
- en: Examples
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notes
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `~` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise not. In particular,
    `~a` and `Not(a)` will be different if `a` is an integer. Furthermore, since bools
    in Python subclass from `int`, `~True` is the same as `~1` which is `-2`, which
    has a boolean value of True. To avoid this issue, use the SymPy boolean types
    `true` and `false`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~` 操作符是为了方便起见提供的，但请注意，它在这里的使用与 Python 中的正常用法不同，Python 中它表示按位取反。特别地，`~a` 和
    `Not(a)` 如果 `a` 是整数将不同。此外，由于 Python 中的布尔值是从 `int` 继承而来，`~True` 将与 `~1` 相同，即 `-2`，其布尔值为
    True。为避免此问题，请使用 SymPy 的布尔类型 `true` 和 `false`。'
- en: As of Python 3.12, the bitwise not operator `~` used on a Python `bool` is deprecated
    and will emit a warning.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 3.12 中，对 Python 的布尔类型使用位取反操作符 `~` 已经不推荐使用，并将会发出警告。
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Logical XOR (exclusive OR) function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 XOR（异或）函数。
- en: Returns True if an odd number of the arguments are True and the rest are False.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果奇数个参数为 True 而其余为 False，则返回 True。
- en: Returns False if an even number of the arguments are True and the rest are False.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果偶数个参数为 True 而其余为 False，则返回 False。
- en: Examples
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notes
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `^` operator is provided as a convenience, but note that its use here is
    different from its normal use in Python, which is bitwise xor. In particular,
    `a ^ b` and `Xor(a, b)` will be different if `a` and `b` are integers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`^` 操作符是为了方便起见提供的，但请注意，它在这里的使用与 Python 中的正常用法不同，Python 中它表示按位异或。特别地，`a ^ b`
    和 `Xor(a, b)` 如果 `a` 和 `b` 是整数将不同。'
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Logical NAND function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 NAND 函数。
- en: It evaluates its arguments in order, giving True immediately if any of them
    are False, and False if they are all True.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它按顺序评估其参数，如果任何参数为 False，则立即返回 True；如果它们全部为 True，则返回 False。
- en: Returns True if any of the arguments are False Returns False if all arguments
    are True
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何参数为 False，则返回 True；如果所有参数为 True，则返回 False。
- en: Examples
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Logical NOR function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 NOR 函数。
- en: It evaluates its arguments in order, giving False immediately if any of them
    are True, and True if they are all False.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它按顺序评估其参数，如果任何参数为 True，则立即返回 False；如果它们全部为 False，则返回 True。
- en: Returns False if any argument is True Returns True if all arguments are False
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何参数为 True，则返回 False；如果所有参数为 False，则返回 True。
- en: Examples
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Logical XNOR function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 XNOR 函数。
- en: Returns False if an odd number of the arguments are True and the rest are False.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果奇数个参数为 True 而其余为 False，则返回 False。
- en: Returns True if an even number of the arguments are True and the rest are False.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果偶数个参数为 True 而其余为 False，则返回 True。
- en: Examples
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Logical implication.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑蕴含。
- en: A implies B is equivalent to if A then B. Mathematically, it is written as \(A
    \Rightarrow B\) and is equivalent to \(\neg A \vee B\) or `~A | B`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: A 蕴含 B 相当于如果 A 则 B。在数学上，它写作 \(A \Rightarrow B\)，相当于 \(\neg A \vee B\) 或 `~A
    | B`。
- en: Accepts two Boolean arguments; A and B. Returns False if A is True and B is
    False Returns True otherwise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接受两个布尔参数；A 和 B。如果 A 为 True 而 B 为 False，则返回 False；否则返回 True。
- en: Examples
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE52]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notes
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `>>` and `<<` operators are provided as a convenience, but note that their
    use here is different from their normal use in Python, which is bit shifts. Hence,
    `Implies(a, b)` and `a >> b` will return different things if `a` and `b` are integers.
    In particular, since Python considers `True` and `False` to be integers, `True
    >> True` will be the same as `1 >> 1`, i.e., 0, which has a truth value of False.
    To avoid this issue, use the SymPy objects `true` and `false`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>` 和 `<<` 操作符是为了方便起见提供的，但请注意，它们在这里的使用与 Python 中的正常用法不同，Python 中它们表示位移。因此，如果
    `a` 和 `b` 是整数，`Implies(a, b)` 和 `a >> b` 将返回不同的结果。特别地，因为 Python 认为 `True` 和 `False`
    是整数，`True >> True` 将与 `1 >> 1` 相同，即 0，其布尔值为 False。为避免此问题，请使用 SymPy 对象 `true` 和
    `false`。'
- en: '[PRE54]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Equivalence relation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 等价关系。
- en: '`Equivalent(A, B)` is True iff A and B are both True or both False.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Equivalent(A, B)` 当且仅当 A 和 B 都为 True 或都为 False 时为 True。'
- en: Returns True if all of the arguments are logically equivalent. Returns False
    otherwise.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有参数在逻辑上等价，则返回 True；否则返回 False。
- en: For two arguments, this is equivalent to [`Xnor`](#sympy.logic.boolalg.Xnor
    "sympy.logic.boolalg.Xnor").
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个参数，这相当于[`Xnor`](#sympy.logic.boolalg.Xnor "sympy.logic.boolalg.Xnor")。
- en: Examples
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If-then-else clause.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: If-then-else 子句。
- en: '`ITE(A, B, C)` evaluates and returns the result of B if A is true else it returns
    the result of C. All args must be Booleans.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITE(A, B, C)` 评估并返回B的结果，如果A为真则返回C的结果。所有参数必须是布尔值。'
- en: From a logic gate perspective, ITE corresponds to a 2-to-1 multiplexer, where
    A is the select signal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑门的角度来看，ITE对应于一个2到1的多路复用器，其中A是选择信号。
- en: Examples
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE58]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Trying to use non-Boolean args will generate a TypeError:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用非布尔参数将生成一个TypeError：
- en: '[PRE59]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: True if only one or no argument is true.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个或没有参数为真时为真。
- en: '`Exclusive(A, B, C)` is equivalent to `~(A & B) & ~(A & C) & ~(B & C)`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exclusive(A, B, C)` 等效于 `~(A & B) & ~(A & C) & ~(B & C)`。'
- en: For two arguments, this is equivalent to [`Xor`](#sympy.logic.boolalg.Xor "sympy.logic.boolalg.Xor").
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个参数，这相当于[`Xor`](#sympy.logic.boolalg.Xor "sympy.logic.boolalg.Xor")。
- en: Examples
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following functions can be used to handle Algebraic, Conjunctive, Disjunctive,
    and Negated Normal forms:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以用来处理代数、合取、析取和否定标准形式：
- en: '[PRE62]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Converts expr to Algebraic Normal Form (ANF).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将`expr`转换为代数标准形式（ANF）。
- en: ANF is a canonical normal form, which means that two equivalent formulas will
    convert to the same ANF.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ANF是一个规范的标准形式，这意味着两个等价的公式将转换为相同的ANF。
- en: A logical expression is in ANF if it has the form
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式处于ANF中，如果它具有以下形式
- en: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
- en: 'i.e. it can be:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即可以是：
- en: purely true,
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯粹的真，
- en: purely false,
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯粹的假，
- en: conjunction of variables,
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的合取，
- en: exclusive disjunction.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥的异或。
- en: The exclusive disjunction can only contain true, variables or conjunction of
    variables. No negations are permitted.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥的异或只能包含真、变量或变量的合取。不允许有否定。
- en: If `deep` is `False`, arguments of the boolean expression are considered variables,
    i.e. only the top-level expression is converted to ANF.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`deep`是`False`，布尔表达式的参数被视为变量，即只有顶层表达式转换为ANF。
- en: Examples
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Convert a propositional logical sentence `expr` to conjunctive normal form:
    `((A | ~B | ...) & (B | C | ...) & ...)`. If `simplify` is `True`, `expr` is evaluated
    to its simplest CNF form using the Quine-McCluskey algorithm; this may take a
    long time. If there are more than 8 variables the `force` flag must be set to
    `True` to simplify (default is `False`).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将命题逻辑句子`expr`转换为合取范式：`((A | ~B | ...) & (B | C | ...) & ...)`。如果`simplify`为`True`，则使用Quine-McCluskey算法将`expr`评估为其最简单的CNF形式；这可能需要很长时间。如果有超过8个变量，则必须将`force`标志设置为`True`以进行简化（默认为`False`）。
- en: Examples
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Convert a propositional logical sentence `expr` to disjunctive normal form:
    `((A & ~B & ...) | (B & C & ...) | ...)`. If `simplify` is `True`, `expr` is evaluated
    to its simplest DNF form using the Quine-McCluskey algorithm; this may take a
    long time. If there are more than 8 variables, the `force` flag must be set to
    `True` to simplify (default is `False`).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将命题逻辑句子`expr`转换为析取范式：`((A & ~B & ...) | (B & C & ...) | ...)`。如果`simplify`为`True`，则使用Quine-McCluskey算法将`expr`评估为其最简单的DNF形式；这可能需要很长时间。如果有超过8个变量，则必须将`force`标志设置为`True`以进行简化（默认为`False`）。
- en: Examples
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE67]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Converts `expr` to Negation Normal Form (NNF).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将`expr`转换为否定标准形式（NNF）。
- en: A logical expression is in NNF if it contains only [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"), and [`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not") is applied only to literals. If `simplify` is `True`,
    the result contains no redundant clauses.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式处于NNF中，如果它仅包含[`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")、[`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or")和[`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not")，并且[`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not")仅应用于文字。如果`simplify`为`True`，结果不包含多余的子句。
- en: Examples
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Checks if `expr` is in Algebraic Normal Form (ANF).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`expr`是否在代数标准形式（ANF）中。
- en: A logical expression is in ANF if it has the form
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式处于ANF中，如果它具有以下形式
- en: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: \[1 \oplus a \oplus b \oplus ab \oplus abc\]
- en: i.e. it is purely true, purely false, conjunction of variables or exclusive
    disjunction. The exclusive disjunction can only contain true, variables or conjunction
    of variables. No negations are permitted.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即它是纯粹的真、纯粹的假、变量的合取或互斥的异或。互斥的异或只能包含真、变量或变量的合取。不允许有否定。
- en: Examples
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE71]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Test whether or not an expression is in conjunctive normal form.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 测试表达式是否处于合取范式中。
- en: Examples
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Test whether or not an expression is in disjunctive normal form.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测试表达式是否为析取范式（DNF）。
- en: Examples
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE75]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Checks if `expr` is in Negation Normal Form (NNF).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`expr`是否处于否定范式（NNF）。
- en: A logical expression is in NNF if it contains only [`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"), and [`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not") is applied only to literals. If `simplified` is `True`,
    checks if result contains no redundant clauses.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式在NNF中，如果只包含[`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")、[`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or")和[`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not")，并且[`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not")仅应用于文字。如果`simplified`为`True`，则检查结果是否不包含冗余子句。
- en: Examples
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE77]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Return the total number of inputs for the logic gates realizing the Boolean
    expression.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 返回实现布尔表达式的逻辑门的总输入数。
- en: 'Returns:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: int
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 整数
- en: Number of gate inputs
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 门输入数
- en: Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Not all Boolean functions count as gate here, only those that are considered
    to be standard gates. These are: [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And"),
    [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or"), [`Xor`](#sympy.logic.boolalg.Xor
    "sympy.logic.boolalg.Xor"), [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not"),
    and [`ITE`](#sympy.logic.boolalg.ITE "sympy.logic.boolalg.ITE") (multiplexer).
    [`Nand`](#sympy.logic.boolalg.Nand "sympy.logic.boolalg.Nand"), [`Nor`](#sympy.logic.boolalg.Nor
    "sympy.logic.boolalg.Nor"), and [`Xnor`](#sympy.logic.boolalg.Xnor "sympy.logic.boolalg.Xnor")
    will be evaluated to `Not(And())` etc.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此处只有标准门才算作布尔函数，包括：[`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And")、[`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or")、[`Xor`](#sympy.logic.boolalg.Xor "sympy.logic.boolalg.Xor")、[`Not`](#sympy.logic.boolalg.Not
    "sympy.logic.boolalg.Not")和[`ITE`](#sympy.logic.boolalg.ITE "sympy.logic.boolalg.ITE")（多路复用器）。[`Nand`](#sympy.logic.boolalg.Nand
    "sympy.logic.boolalg.Nand")、[`Nor`](#sympy.logic.boolalg.Nor "sympy.logic.boolalg.Nor")和[`Xnor`](#sympy.logic.boolalg.Xnor
    "sympy.logic.boolalg.Xnor")将被计算为`Not(And())`等。
- en: Examples
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE79]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that `Nand` is automatically evaluated to `Not(And())` so
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Nand`自动计算为`Not(And())`，因此
- en: '[PRE80]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Although this can be avoided by using `evaluate=False`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以通过使用`evaluate=False`来避免此问题
- en: '[PRE81]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Also note that a comparison will count as a Boolean variable:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，比较将计为布尔变量：
- en: '[PRE82]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As will a symbol: >>> gateinputcount(x) 0'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如符号：>>> gateinputcount(x) 0
- en: Simplification and equivalence-testing
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化和等价测试
- en: '[PRE83]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This function simplifies a boolean function to its simplified version in SOP
    or POS form. The return type is an [`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")
    or [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And") object in SymPy.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将布尔函数简化为其标准形式中的简化版本（SOP或POS）。返回类型是SymPy中的[`Or`](#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")或[`And`](#sympy.logic.boolalg.And
    "sympy.logic.boolalg.And")对象。
- en: 'Parameters:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : Boolean'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：布尔值'
- en: '**form** : string (`''cnf''` or `''dnf''`) or `None` (default).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**form**：字符串（`''cnf''`或`''dnf''`）或`None`（默认）。'
- en: If `'cnf'` or `'dnf'`, the simplest expression in the corresponding normal form
    is returned; if `None`, the answer is returned according to the form with fewest
    args (in CNF by default).
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是`'cnf'`或`'dnf'`，则返回相应正规形式中的最简表达式；如果是`None`，则根据参数最少的形式返回答案（默认为CNF）。
- en: '**deep** : bool (default `True`)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**deep**：布尔值（默认`True`）'
- en: Indicates whether to recursively simplify any non-boolean functions contained
    within the input.
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示是否递归简化输入中包含的任何非布尔函数。
- en: '**force** : bool (default `False`)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**force**：布尔值（默认`False`）'
- en: As the simplifications require exponential time in the number of variables,
    there is by default a limit on expressions with 8 variables. When the expression
    has more than 8 variables only symbolical simplification (controlled by `deep`)
    is made. By setting `force` to `True`, this limit is removed. Be aware that this
    can lead to very long simplification times.
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于简化在变量数量的指数时间内，对具有8个以上变量的表达式默认有一个限制。当表达式超过8个变量时，只进行符号化简化（由`deep`控制）。通过将`force`设置为`True`，可以移除此限制。请注意，这可能导致非常长的简化时间。
- en: '**dontcare** : Boolean'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**dontcare**：布尔值'
- en: Optimize expression under the assumption that inputs where this expression is
    true are don’t care. This is useful in e.g. Piecewise conditions, where later
    conditions do not need to consider inputs that are converted by previous conditions.
    For example, if a previous condition is `And(A, B)`, the simplification of expr
    can be made with don’t cares for `And(A, B)`.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在假设这个表达式为真的输入是不重要的情况下优化表达式。例如，在分段条件中很有用，后续条件不需要考虑前面条件转换的输入。例如，如果前面的条件是`And(A,
    B)`，则可以使用对`And(A, B)`的不重要性简化表达式。
- en: Examples
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE84]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: References
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R605](#id6)]'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R605](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Don%27t-care_term](https://en.wikipedia.org/wiki/Don%27t-care_term)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[不重要术语](https://en.wikipedia.org/wiki/Don%27t-care_term)'
- en: SymPy’s [`simplify()`](simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") function can also be used to simplify logic
    expressions to their simplest forms.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的[`simplify()`](simplify/simplify.html#sympy.simplify.simplify.simplify)函数也可用于将逻辑表达式简化为其最简形式。
- en: '[PRE85]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Return the simplified version of *bool1*, and the mapping of variables that
    makes the two expressions *bool1* and *bool2* represent the same logical behaviour
    for some correspondence between the variables of each. If more than one mappings
    of this sort exist, one of them is returned.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*bool1*的简化版本，以及使两个表达式*bool1*和*bool2*在变量之间的某种对应关系下表示相同逻辑行为的变量映射。如果存在多个这样的映射，则返回其中一个。
- en: 'For example, `And(x, y)` is logically equivalent to `And(a, b)` for the mapping
    `{x: a, y: b}` or `{x: b, y: a}`. If no such mapping exists, return `False`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，对于映射`{x: a, y: b}`或`{x: b, y: a}`，`And(x, y)`在逻辑上等价于`And(a, b)`。如果不存在这样的映射，则返回`False`。'
- en: Examples
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE86]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The results are not necessarily unique, but they are canonical. Here, `(w,
    z)` could be `(a, d)` or `(d, a)`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不一定是唯一的，但它们是规范的。这里，`(w, z)`可以是`(a, d)`或`(d, a)`：
- en: '[PRE87]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Manipulating expressions
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵表达式
- en: 'The following functions can be used to manipulate Boolean expressions:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来操作布尔表达式的以下函数：
- en: '[PRE88]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Given a sentence `expr` consisting of conjunctions and disjunctions of literals,
    return an equivalent sentence in CNF.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由文字的合取和析取组成的句子`expr`，返回一个等价的CNF形式的句子。
- en: Examples
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE89]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Given a sentence `expr` consisting of conjunctions and disjunctions of literals,
    return an equivalent sentence in DNF.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由文字的合取和析取组成的句子`expr`，返回一个等价的DNF形式的句子。
- en: Note that the output is NOT simplified.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出未简化。
- en: Examples
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE91]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Given a sentence `expr` consisting of conjunction and exclusive disjunctions
    of literals, return an equivalent exclusive disjunction.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个由文字的合取和排他析取组成的句子`expr`，返回一个等价的排他析取。
- en: Note that the output is NOT simplified.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出未简化。
- en: Examples
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE93]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Change [`Implies`](#sympy.logic.boolalg.Implies "sympy.logic.boolalg.Implies")
    and [`Equivalent`](#sympy.logic.boolalg.Equivalent "sympy.logic.boolalg.Equivalent")
    into [`And`](#sympy.logic.boolalg.And "sympy.logic.boolalg.And"), [`Or`](#sympy.logic.boolalg.Or
    "sympy.logic.boolalg.Or"), and [`Not`](#sympy.logic.boolalg.Not "sympy.logic.boolalg.Not").
    That is, return an expression that is equivalent to `expr`, but has only `&`,
    `|`, and `~` as logical operators.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将[`Implies`](#sympy.logic.boolalg.Implies)和[`Equivalent`](#sympy.logic.boolalg.Equivalent)改为[`And`](#sympy.logic.boolalg.And)，[`Or`](#sympy.logic.boolalg.Or)和[`Not`](#sympy.logic.boolalg.Not)。也就是说，返回一个与`expr`等价的表达式，但只使用`&`、`|`和`~`作为逻辑运算符。
- en: Examples
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE95]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Truth tables and related functions
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真值表及相关函数
- en: It is possible to create a truth table for a Boolean function with
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建布尔函数的真值表。
- en: '[PRE96]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Return a generator of all possible configurations of the input variables, and
    the result of the boolean expression for those values.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 返回输入变量的所有可能配置的生成器，以及这些值的布尔表达式的结果。
- en: 'Parameters:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : Boolean expression'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：布尔表达式'
- en: '**variables** : list of variables'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**variables**：变量列表'
- en: '**input** : bool (default `True`)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**input**：布尔值（默认为`True`）'
- en: Indicates whether to return the input combinations.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示是否返回输入组合。
- en: Examples
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE97]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If `input` is `False`, `truth_table` returns only a list of truth values. In
    this case, the corresponding input values of variables can be deduced from the
    index of a given output.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`input`为`False`，`truth_table`仅返回一个真值列表。在这种情况下，可以从给定输出的索引推导出变量的相应输入值。
- en: '[PRE99]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'For mapping between integer representations of truth table positions, lists
    of zeros and ones and symbols, the following functions can be used:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在真值表位置的整数表示、零和一的列表以及符号之间进行映射，可以使用以下函数：
- en: '[PRE101]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Return a list of length `bits` corresponding to the binary value of `n` with
    small bits to the right (last). If bits is omitted, the length will be the number
    required to represent `n`. If the bits are desired in reversed order, use the
    `[::-1]` slice of the returned list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 返回长度为`bits`的列表，该列表对应于表示`n`的二进制值，小位数在右边（最后）。如果省略bits，则长度将是表示`n`所需的位数。如果希望以反向顺序显示位数，请使用返回列表的`[::-1]`切片。
- en: If a sequence of all bits-length lists starting from `[0, 0,..., 0]` through
    `[1, 1, ..., 1]` are desired, pass a non-integer for bits, e.g. `'all'`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望得到从`[0, 0,..., 0]`到`[1, 1, ..., 1]`的所有位长度列表的序列，则传递非整数作为位数，例如 `'all'`。
- en: If the bit *string* is desired pass `str=True`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要比特串，则传递`str=True`。
- en: Examples
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE102]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If all lists corresponding to 0 to 2**n - 1, pass a non-integer for bits:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望所有与0到$2^n - 1$对应的列表，请传递非整数作为位数：
- en: '[PRE103]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If a bit string is desired of a given length, use str=True:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要给定长度的比特串，请使用str=True：
- en: '[PRE104]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Return an integer corresponding to the base-2 digits given by *term*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与*项*给定的基于二进制的2进制数相对应的整数。
- en: 'Parameters:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**term** : a string or list of ones and zeros'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**项**：字符串或1和0列表'
- en: Examples
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE106]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Return the k-th maxterm.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第k个最大项。
- en: Each maxterm is assigned an index based on the opposite conventional binary
    encoding used for minterms. The maxterm convention assigns the value 0 to the
    direct form and 1 to the complemented form.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 每个最大项根据用于最小项的传统相反的二进制编码而分配一个索引。最大项的约定将直接形式分配值0，补码形式分配值1。
- en: 'Parameters:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**k** : int or list of 1’s and 0’s (complementation pattern)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：整数或1和0列表（补码模式）'
- en: '**variables** : list of variables'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**：变量列表'
- en: Examples
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE108]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: References
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R606](#id7)]'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R606](#id7)]'
- en: '[https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms](https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/正规范式#最大项的索引](https://zh.wikipedia.org/wiki/正规范式#最大项的索引)'
- en: '[PRE109]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Return the k-th minterm.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第k个最小项。
- en: Minterms are numbered by a binary encoding of the complementation pattern of
    the variables. This convention assigns the value 1 to the direct form and 0 to
    the complemented form.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最小项按变量的补码模式的二进制编码编号。此约定将直接形式分配值1，补码形式分配值0。
- en: 'Parameters:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**k** : int or list of 1’s and 0’s (complementation pattern)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：整数或1和0列表（补码模式）'
- en: '**variables** : list of variables'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**：变量列表'
- en: Examples
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE110]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: References
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R607](#id8)]'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R607](#id8)]'
- en: '[https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms](https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/正规范式#最小项的索引](https://zh.wikipedia.org/wiki/正规范式#最小项的索引)'
- en: '[PRE111]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Return the k-th monomial.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第k个单项式。
- en: Monomials are numbered by a binary encoding of the presence and absences of
    the variables. This convention assigns the value 1 to the presence of variable
    and 0 to the absence of variable.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 单项式按变量的存在和不存在的二进制编码编号。此约定将变量的存在分配值1，变量的不存在分配值0。
- en: Each boolean function can be uniquely represented by a Zhegalkin Polynomial
    (Algebraic Normal Form). The Zhegalkin Polynomial of the boolean function with
    \(n\) variables can contain up to \(2^n\) monomials. We can enumerate all the
    monomials. Each monomial is fully specified by the presence or absence of each
    variable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布尔函数都可以通过Zhegalkin多项式（代数正常形式）唯一表示。具有$n$个变量的布尔函数的Zhegalkin多项式可以包含多达$2^n$个单项式。我们可以枚举所有的单项式。每个单项式由每个变量的存在或不存在来完全指定。
- en: For example, boolean function with four variables `(a, b, c, d)` can contain
    up to \(2^4 = 16\) monomials. The 13-th monomial is the product `a & b & d`, because
    13 in binary is 1, 1, 0, 1.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，具有四个变量`(a, b, c, d)`的布尔函数可以包含多达$2^4 = 16$个单项式。第13个单项式是乘积`a & b & d`，因为13在二进制中是1,
    1, 0, 1。
- en: 'Parameters:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**k** : int or list of 1’s and 0’s'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：整数或1和0列表'
- en: '**variables** : list of variables'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**：变量列表'
- en: Examples
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE112]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Convert a list of truth values of some boolean expression to the list of coefficients
    of the polynomial mod 2 (exclusive disjunction) representing the boolean expression
    in ANF (i.e., the “Zhegalkin polynomial”).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将某个布尔表达式的真值列表转换为在ANF中表示该布尔表达式的多项式模2的系数列表（排他或）（即“Zhegalkin多项式”）。
- en: There are \(2^n\) possible Zhegalkin monomials in \(n\) variables, since each
    monomial is fully specified by the presence or absence of each variable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在\(n\)个变量中，Zhegalkin单项式有\(2^n\)个可能，因为每个单项式通过每个变量的有无来完全指定。
- en: We can enumerate all the monomials. For example, boolean function with four
    variables `(a, b, c, d)` can contain up to \(2^4 = 16\) monomials. The 13-th monomial
    is the product `a & b & d`, because 13 in binary is 1, 1, 0, 1.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以枚举所有的单项式。例如，具有四个变量`(a, b, c, d)`的布尔函数可以包含最多\(2^4 = 16\)个单项式。第13个单项式是乘积`a
    & b & d`，因为13在二进制中是1, 1, 0, 1。
- en: A given monomial’s presence or absence in a polynomial corresponds to that monomial’s
    coefficient being 1 or 0 respectively.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定单项式在多项式中的出现与该单项式的系数分别为1或0相对应。
- en: Examples
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE114]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Takes clauses in CNF format and puts them into an integer representation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将CNF格式的子句转换为整数表示。
- en: Examples
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE116]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '## Inference'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '## 推断'
- en: This module implements some inference routines in propositional logic.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块实现了命题逻辑中的一些推断例程。
- en: The function satisfiable will test that a given Boolean expression is satisfiable,
    that is, you can assign values to the variables to make the sentence `True`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`satisfiable`将测试给定的布尔表达式是否可满足，即你可以为变量分配值使得句子为`True`。
- en: For example, the expression `x & ~x` is not satisfiable, since there are no
    values for `x` that make this sentence `True`. On the other hand, `(x | y) & (x
    | ~y) & (~x | y)` is satisfiable with both `x` and `y` being `True`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`x & ~x`是不可满足的，因为没有任何值可以使得这个句子为`True`。另一方面，`(x | y) & (x | ~y) & (~x |
    y)`是可满足的，其中`x`和`y`都为`True`。
- en: '[PRE117]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: As you see, when a sentence is satisfiable, it returns a model that makes that
    sentence `True`. If it is not satisfiable it will return `False`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当一个句子是可满足的时候，它会返回一个使得这个句子为`True`的模型。如果它不可满足，则会返回`False`。
- en: '[PRE118]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Check satisfiability of a propositional sentence. Returns a model when it succeeds.
    Returns {true: true} for trivially true expressions.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '检查命题句子的可满足性。当成功时返回一个模型。对于显然为真的表达式，返回`{true: true}`。'
- en: On setting all_models to True, if given expr is satisfiable then returns a generator
    of models. However, if expr is unsatisfiable then returns a generator containing
    the single element False.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`all_models`设置为True时，如果给定的表达式是可满足的，则返回一个模型的生成器。然而，如果表达式是不可满足的，则返回一个包含单一元素`False`的生成器。
- en: Examples
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE119]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
