- en: scipy.optimize.lsq_linear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.lsq_linear.html#scipy.optimize.lsq_linear](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.lsq_linear.html#scipy.optimize.lsq_linear)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solve a linear least-squares problem with bounds on the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a m-by-n design matrix A and a target vector b with m elements, [`lsq_linear`](#scipy.optimize.lsq_linear
    "scipy.optimize.lsq_linear") solves the following optimization problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This optimization problem is convex, hence a found minimum (if iterations have
    converged) is guaranteed to be global.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A**array_like, sparse matrix of LinearOperator, shape (m, n)'
  prefs: []
  type: TYPE_NORMAL
- en: Design matrix. Can be [`scipy.sparse.linalg.LinearOperator`](scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator").
  prefs: []
  type: TYPE_NORMAL
- en: '**b**array_like, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: Target vector.
  prefs: []
  type: TYPE_NORMAL
- en: '**bounds**2-tuple of array_like or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lower and upper bounds on parameters. Defaults to no bounds. There are two
    ways to specify the bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2-tuple of array_like: Each element of the tuple must be either an array with
    the length equal to the number of parameters, or a scalar (in which case the bound
    is taken to be the same for all parameters). Use `np.inf` with an appropriate
    sign to disable bounds on all or some parameters.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**method**‘trf’ or ‘bvls’, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to perform minimization.
  prefs: []
  type: TYPE_NORMAL
- en: '‘trf’ : Trust Region Reflective algorithm adapted for a linear least-squares
    problem. This is an interior-point-like method and the required number of iterations
    is weakly correlated with the number of variables.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘bvls’ : Bounded-variable least-squares algorithm. This is an active set method,
    which requires the number of iterations comparable to the number of variables.
    Can’t be used when *A* is sparse or LinearOperator.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is ‘trf’.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tolerance parameter. The algorithm terminates if a relative change of the cost
    function is less than *tol* on the last iteration. Additionally, the first-order
    optimality measure is considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method=''trf''` terminates if the uniform norm of the gradient, scaled to
    account for the presence of the bounds, is less than *tol*.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`method=''bvls''` terminates if Karush-Kuhn-Tucker conditions are satisfied
    within *tol* tolerance.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lsq_solver**{None, ‘exact’, ‘lsmr’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method of solving unbounded least-squares problems throughout iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘exact’ : Use dense QR or SVD decomposition approach. Can’t be used when *A*
    is sparse or LinearOperator.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘lsmr’ : Use [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr") iterative procedure which requires only matrix-vector
    product evaluations. Can’t be used with `method=''bvls''`.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If None (default), the solver is chosen based on type of *A*.
  prefs: []
  type: TYPE_NORMAL
- en: '**lsmr_tol**None, float or ‘auto’, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Tolerance parameters ‘atol’ and ‘btol’ for [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr") If None (default), it is set to `1e-2 * tol`. If ‘auto’,
    the tolerance will be adjusted based on the optimality of the current iterate,
    which can speed up the optimization process, but is not always reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '**max_iter**None or int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations before termination. If None (default), it is set
    to 100 for `method='trf'` or to the number of variables for `method='bvls'` (not
    counting iterations for ‘bvls’ initialization).
  prefs: []
  type: TYPE_NORMAL
- en: '**verbose**{0, 1, 2}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level of algorithm’s verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '0 : work silently (default).'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : display a termination report.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2 : display progress during iterations.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**lsmr_maxiter**None or int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations for the lsmr least squares solver, if it is used
    (by setting `lsq_solver='lsmr'`). If None (default), it uses lsmr’s default of
    `min(m, n)` where `m` and `n` are the number of rows and columns of *A*, respectively.
    Has no effect if `lsq_solver='exact'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OptimizeResult with the following fields defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: Solution found.
  prefs: []
  type: TYPE_NORMAL
- en: '**cost**float'
  prefs: []
  type: TYPE_NORMAL
- en: Value of the cost function at the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**ndarray, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: Vector of residuals at the solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**optimality**float'
  prefs: []
  type: TYPE_NORMAL
- en: First-order optimality measure. The exact meaning depends on *method*, refer
    to the description of *tol* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**active_mask**ndarray of int, shape (n,)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each component shows whether a corresponding constraint is active (that is,
    whether a variable is at the bound):'
  prefs: []
  type: TYPE_NORMAL
- en: '0 : a constraint is not active.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '-1 : a lower bound is active.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : an upper bound is active.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Might be somewhat arbitrary for the *trf* method as it generates a sequence
    of strictly feasible iterates and active_mask is determined within a tolerance
    threshold.
  prefs: []
  type: TYPE_NORMAL
- en: '**unbounded_sol**tuple'
  prefs: []
  type: TYPE_NORMAL
- en: Unbounded least squares solution tuple returned by the least squares solver
    (set with *lsq_solver* option). If *lsq_solver* is not set or is set to `'exact'`,
    the tuple contains an ndarray of shape (n,) with the unbounded solution, an ndarray
    with the sum of squared residuals, an int with the rank of *A*, and an ndarray
    with the singular values of *A* (see NumPy’s `linalg.lstsq` for more information).
    If *lsq_solver* is set to `'lsmr'`, the tuple contains an ndarray of shape (n,)
    with the unbounded solution, an int with the exit code, an int with the number
    of iterations, and five floats with various norms and the condition number of
    *A* (see SciPy’s `sparse.linalg.lsmr` for more information). This output can be
    useful for determining the convergence of the least squares solver, particularly
    the iterative `'lsmr'` solver. The unbounded least squares problem is to minimize
    `0.5 * ||A x - b||**2`.
  prefs: []
  type: TYPE_NORMAL
- en: '**nit**int'
  prefs: []
  type: TYPE_NORMAL
- en: Number of iterations. Zero if the unconstrained solution is optimal.
  prefs: []
  type: TYPE_NORMAL
- en: '**status**int'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reason for algorithm termination:'
  prefs: []
  type: TYPE_NORMAL
- en: '-1 : the algorithm was not able to make progress on the last iteration.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '0 : the maximum number of iterations is exceeded.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '1 : the first-order optimality measure is less than *tol*.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '2 : the relative change of the cost function is less than *tol*.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '3 : the unconstrained solution is optimal.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**message**str'
  prefs: []
  type: TYPE_NORMAL
- en: Verbal description of the termination reason.
  prefs: []
  type: TYPE_NORMAL
- en: '**success**bool'
  prefs: []
  type: TYPE_NORMAL
- en: True if one of the convergence criteria is satisfied (*status* > 0).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`nnls`](scipy.optimize.nnls.html#scipy.optimize.nnls "scipy.optimize.nnls")'
  prefs: []
  type: TYPE_NORMAL
- en: Linear least squares with non-negativity constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[`least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares")'
  prefs: []
  type: TYPE_NORMAL
- en: Nonlinear least squares with bounds on the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm first computes the unconstrained least-squares solution by [`numpy.linalg.lstsq`](https://numpy.org/devdocs/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq
    "(in NumPy v2.0.dev0)") or [`scipy.sparse.linalg.lsmr`](scipy.sparse.linalg.lsmr.html#scipy.sparse.linalg.lsmr
    "scipy.sparse.linalg.lsmr") depending on *lsq_solver*. This solution is returned
    as optimal if it lies within the bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Method ‘trf’ runs the adaptation of the algorithm described in [[STIR]](#r74f8b7a68993-stir)
    for a linear least-squares problem. The iterations are essentially the same as
    in the nonlinear least-squares algorithm, but as the quadratic function model
    is always accurate, we don’t need to track or modify the radius of a trust region.
    The line search (backtracking) is used as a safety net when a selected step does
    not decrease the cost function. Read more detailed description of the algorithm
    in [`scipy.optimize.least_squares`](scipy.optimize.least_squares.html#scipy.optimize.least_squares
    "scipy.optimize.least_squares").
  prefs: []
  type: TYPE_NORMAL
- en: Method ‘bvls’ runs a Python implementation of the algorithm described in [[BVLS]](#r74f8b7a68993-bvls).
    The algorithm maintains active and free sets of variables, on each iteration chooses
    a new variable to move from the active set to the free set and then solves the
    unconstrained least-squares problem on free variables. This algorithm is guaranteed
    to give an accurate solution eventually, but may require up to n iterations for
    a problem with n variables. Additionally, an ad-hoc initialization procedure is
    implemented, that determines which variables to set free or active initially.
    It takes some number of iterations before actual BVLS starts, but can significantly
    reduce the number of further iterations.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[STIR](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: M. A. Branch, T. F. Coleman, and Y. Li, “A Subspace, Interior, and Conjugate
    Gradient Method for Large-Scale Bound-Constrained Minimization Problems,” SIAM
    Journal on Scientific Computing, Vol. 21, Number 1, pp 1-23, 1999.
  prefs: []
  type: TYPE_NORMAL
- en: '[[BVLS](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'P. B. Start and R. L. Parker, “Bounded-Variable Least-Squares: an Algorithm
    and Applications”, Computational Statistics, 10, 129-141, 1995.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a problem with a large sparse matrix and bounds on the variables
    is solved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
