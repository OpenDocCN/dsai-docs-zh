- en: scipy.fftpack.ifft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.fftpack.ifft.html#scipy.fftpack.ifft](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.fftpack.ifft.html#scipy.fftpack.ifft)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return discrete inverse Fourier transform of real or complex sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The returned complex array contains `y(0), y(1),..., y(n-1)`, where
  prefs: []
  type: TYPE_NORMAL
- en: '`y(j) = (x * exp(2*pi*sqrt(-1)*j*np.arange(n)/n)).mean()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Transformed data to invert.
  prefs: []
  type: TYPE_NORMAL
- en: '**n**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Length of the inverse Fourier transform. If `n < x.shape[axis]`, *x* is truncated.
    If `n > x.shape[axis]`, *x* is zero-padded. The default results in `n = x.shape[axis]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Axis along which the ifft’s are computed; the default is over the last axis
    (i.e., `axis=-1`).
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_x**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the contents of *x* can be destroyed; the default is False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ifft**ndarray of floats'
  prefs: []
  type: TYPE_NORMAL
- en: The inverse discrete Fourier transform.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fft`](scipy.fftpack.fft.html#scipy.fftpack.fft "scipy.fftpack.fft")'
  prefs: []
  type: TYPE_NORMAL
- en: Forward FFT
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Both single and double precision routines are implemented. Half precision inputs
    will be converted to single precision. Non-floating-point inputs will be converted
    to double precision. Long-double precision inputs are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: This function is most efficient when *n* is a power of two, and least efficient
    when *n* is prime.
  prefs: []
  type: TYPE_NORMAL
- en: If the data type of *x* is real, a “real IFFT” algorithm is automatically used,
    which roughly halves the computation time.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
