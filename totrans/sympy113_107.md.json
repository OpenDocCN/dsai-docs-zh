["```py\n>>> from sympy import *\n>>> x, y = symbols('x,y')\n>>> y | (x & y)\ny | (x & y)\n>>> x | y\nx | y\n>>> ~x\n~x \n```", "```py\n>>> x >> y\nImplies(x, y)\n>>> x << y\nImplies(y, x) \n```", "```py\n>>> (y & x).subs({x: True, y: True})\nTrue\n>>> (x | y).atoms()\n{x, y} \n```", "```py\nsympy.logic.boolalg.SOPform(variables, minterms, dontcares=None)\n```", "```py\n>>> from sympy.logic import SOPform\n>>> from sympy import symbols\n>>> w, x, y, z = symbols('w x y z')\n>>> minterms = [[0, 0, 0, 1], [0, 0, 1, 1],\n...             [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 1]]\n>>> dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]\n>>> SOPform([w, x, y, z], minterms, dontcares)\n(y & z) | (~w & ~x) \n```", "```py\n>>> minterms = [1, 3, 7, 11, 15]\n>>> dontcares = [0, 2, 5]\n>>> SOPform([w, x, y, z], minterms, dontcares)\n(y & z) | (~w & ~x) \n```", "```py\n>>> minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]\n>>> SOPform([w, x, y, z], minterms)\n(x & ~w) | (y & z & ~x) \n```", "```py\n>>> minterms = [4, 7, 11, [1, 1, 1, 1]]\n>>> dontcares = [{w : 0, x : 0, y: 0}, 5]\n>>> SOPform([w, x, y, z], minterms, dontcares)\n(w & y & z) | (~w & ~y) | (x & z & ~w) \n```", "```py\nsympy.logic.boolalg.POSform(variables, minterms, dontcares=None)\n```", "```py\n>>> from sympy.logic import POSform\n>>> from sympy import symbols\n>>> w, x, y, z = symbols('w x y z')\n>>> minterms = [[0, 0, 0, 1], [0, 0, 1, 1], [0, 1, 1, 1],\n...             [1, 0, 1, 1], [1, 1, 1, 1]]\n>>> dontcares = [[0, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 1]]\n>>> POSform([w, x, y, z], minterms, dontcares)\nz & (y | ~w) \n```", "```py\n>>> minterms = [1, 3, 7, 11, 15]\n>>> dontcares = [0, 2, 5]\n>>> POSform([w, x, y, z], minterms, dontcares)\nz & (y | ~w) \n```", "```py\n>>> minterms = [{w: 0, x: 1}, {y: 1, z: 1, x: 0}]\n>>> POSform([w, x, y, z], minterms)\n(x | y) & (x | z) & (~w | ~x) \n```", "```py\n>>> minterms = [4, 7, 11, [1, 1, 1, 1]]\n>>> dontcares = [{w : 0, x : 0, y: 0}, 5]\n>>> POSform([w, x, y, z], minterms, dontcares)\n(w | x) & (y | ~w) & (z | ~y) \n```", "```py\nsympy.logic.boolalg.ANFform(variables, truthvalues)\n```", "```py\n>>> from sympy.logic.boolalg import ANFform\n>>> from sympy.abc import x, y\n>>> ANFform([x], [1, 0])\nx ^ True\n>>> ANFform([x, y], [0, 1, 1, 1])\nx ^ y ^ (x & y) \n```", "```py\nclass sympy.logic.boolalg.Boolean(*args)\n```", "```py\nas_set()\n```", "```py\n>>> from sympy import Symbol, Eq, Or, And\n>>> x = Symbol('x', real=True)\n>>> Eq(x, 0).as_set()\n{0}\n>>> (x > 0).as_set()\nInterval.open(0, oo)\n>>> And(-2 < x, x < 2).as_set()\nInterval.open(-2, 2)\n>>> Or(x < -2, 2 < x).as_set()\nUnion(Interval.open(-oo, -2), Interval.open(2, oo)) \n```", "```py\nequals(other)\n```", "```py\n>>> from sympy.abc import A, B, C\n>>> from sympy import And, Or, Not\n>>> (A >> B).equals(~B >> ~A)\nTrue\n>>> Not(And(A, B, C)).equals(And(Not(A), Not(B), Not(C)))\nFalse\n>>> Not(And(A, Not(A))).equals(Or(B, Not(B)))\nFalse \n```", "```py\nclass sympy.logic.boolalg.BooleanTrue\n```", "```py\n>>> from sympy import sympify, true, false, Or\n>>> sympify(True)\nTrue\n>>> _ is True, _ is true\n(False, True) \n```", "```py\n>>> Or(true, false)\nTrue\n>>> _ is true\nTrue \n```", "```py\n>>> ~true, ~True  \n(False, -2)\n>>> true >> true, True >> True\n(True, 0) \n```", "```py\nas_set()\n```", "```py\n>>> from sympy import true\n>>> true.as_set()\nUniversalSet \n```", "```py\nclass sympy.logic.boolalg.BooleanFalse\n```", "```py\n>>> from sympy import sympify, true, false, Or\n>>> sympify(False)\nFalse\n>>> _ is False, _ is false\n(False, True) \n```", "```py\n>>> Or(true, false)\nTrue\n>>> _ is true\nTrue \n```", "```py\n>>> ~false, ~False  \n(True, -1)\n>>> false >> false, False >> False\n(True, 0) \n```", "```py\nas_set()\n```", "```py\n>>> from sympy import false\n>>> false.as_set()\nEmptySet \n```", "```py\nclass sympy.logic.boolalg.And(*args)\n```", "```py\n>>> from sympy.abc import x, y\n>>> from sympy import And\n>>> x & y\nx & y \n```", "```py\n>>> And(x, y).subs(x, 1)\ny \n```", "```py\nclass sympy.logic.boolalg.Or(*args)\n```", "```py\n>>> from sympy.abc import x, y\n>>> from sympy import Or\n>>> x | y\nx | y \n```", "```py\n>>> Or(x, y).subs(x, 0)\ny \n```", "```py\nclass sympy.logic.boolalg.Not(arg)\n```", "```py\n>>> from sympy import Not, And, Or\n>>> from sympy.abc import x, A, B\n>>> Not(True)\nFalse\n>>> Not(False)\nTrue\n>>> Not(And(True, False))\nTrue\n>>> Not(Or(True, False))\nFalse\n>>> Not(And(And(True, x), Or(x, False)))\n~x\n>>> ~x\n~x\n>>> Not(And(Or(A, B), Or(~A, ~B)))\n~((A | B) & (~A | ~B)) \n```", "```py\n>>> from sympy import true\n>>> ~True  \n-2\n>>> ~true\nFalse \n```", "```py\nclass sympy.logic.boolalg.Xor(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Xor\n>>> from sympy import symbols\n>>> x, y = symbols('x y')\n>>> Xor(True, False)\nTrue\n>>> Xor(True, True)\nFalse\n>>> Xor(True, False, True, True, False)\nTrue\n>>> Xor(True, False, True, False)\nFalse\n>>> x ^ y\nx ^ y \n```", "```py\n>>> Xor(x, y).subs(y, 0)\nx \n```", "```py\nclass sympy.logic.boolalg.Nand(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Nand\n>>> from sympy import symbols\n>>> x, y = symbols('x y')\n>>> Nand(False, True)\nTrue\n>>> Nand(True, True)\nFalse\n>>> Nand(x, y)\n~(x & y) \n```", "```py\nclass sympy.logic.boolalg.Nor(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Nor\n>>> from sympy import symbols\n>>> x, y = symbols('x y') \n```", "```py\n>>> Nor(True, False)\nFalse\n>>> Nor(True, True)\nFalse\n>>> Nor(False, True)\nFalse\n>>> Nor(False, False)\nTrue\n>>> Nor(x, y)\n~(x | y) \n```", "```py\nclass sympy.logic.boolalg.Xnor(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Xnor\n>>> from sympy import symbols\n>>> x, y = symbols('x y')\n>>> Xnor(True, False)\nFalse\n>>> Xnor(True, True)\nTrue\n>>> Xnor(True, False, True, True, False)\nFalse\n>>> Xnor(True, False, True, False)\nTrue \n```", "```py\nclass sympy.logic.boolalg.Implies(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Implies\n>>> from sympy import symbols\n>>> x, y = symbols('x y') \n```", "```py\n>>> Implies(True, False)\nFalse\n>>> Implies(False, False)\nTrue\n>>> Implies(True, True)\nTrue\n>>> Implies(False, True)\nTrue\n>>> x >> y\nImplies(x, y)\n>>> y << x\nImplies(x, y) \n```", "```py\n>>> from sympy import true, false\n>>> True >> False\n1\n>>> true >> false\nFalse \n```", "```py\nclass sympy.logic.boolalg.Equivalent(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Equivalent, And\n>>> from sympy.abc import x\n>>> Equivalent(False, False, False)\nTrue\n>>> Equivalent(True, False, False)\nFalse\n>>> Equivalent(x, And(x, True))\nTrue \n```", "```py\nclass sympy.logic.boolalg.ITE(*args)\n```", "```py\n>>> from sympy.logic.boolalg import ITE, And, Xor, Or\n>>> from sympy.abc import x, y, z\n>>> ITE(True, False, True)\nFalse\n>>> ITE(Or(True, False), And(True, True), Xor(True, True))\nTrue\n>>> ITE(x, y, z)\nITE(x, y, z)\n>>> ITE(True, x, y)\nx\n>>> ITE(False, x, y)\ny\n>>> ITE(x, y, y)\ny \n```", "```py\n>>> ITE(True, [], ())\nTraceback (most recent call last):\n...\nTypeError: expecting bool, Boolean or ITE, not `[]` \n```", "```py\nclass sympy.logic.boolalg.Exclusive(*args)\n```", "```py\n>>> from sympy.logic.boolalg import Exclusive\n>>> Exclusive(False, False, False)\nTrue\n>>> Exclusive(False, True, False)\nTrue\n>>> Exclusive(False, True, True)\nFalse \n```", "```py\nsympy.logic.boolalg.to_anf(expr, deep=True)\n```", "```py\n>>> from sympy.logic.boolalg import And, Or, Not, Implies, Equivalent\n>>> from sympy.logic.boolalg import to_anf\n>>> from sympy.abc import A, B, C\n>>> to_anf(Not(A))\nA ^ True\n>>> to_anf(And(Or(A, B), Not(C)))\nA ^ B ^ (A & B) ^ (A & C) ^ (B & C) ^ (A & B & C)\n>>> to_anf(Implies(Not(A), Equivalent(B, C)), deep=False)\nTrue ^ ~A ^ (~A & (Equivalent(B, C))) \n```", "```py\nsympy.logic.boolalg.to_cnf(expr, simplify=False, force=False)\n```", "```py\n>>> from sympy.logic.boolalg import to_cnf\n>>> from sympy.abc import A, B, D\n>>> to_cnf(~(A | B) | D)\n(D | ~A) & (D | ~B)\n>>> to_cnf((A | B) & (A | ~A), True)\nA | B \n```", "```py\nsympy.logic.boolalg.to_dnf(expr, simplify=False, force=False)\n```", "```py\n>>> from sympy.logic.boolalg import to_dnf\n>>> from sympy.abc import A, B, C\n>>> to_dnf(B & (A | C))\n(A & B) | (B & C)\n>>> to_dnf((A & B) | (A & ~B) | (B & C) | (~B & C), True)\nA | C \n```", "```py\nsympy.logic.boolalg.to_nnf(expr, simplify=True)\n```", "```py\n>>> from sympy.abc import A, B, C, D\n>>> from sympy.logic.boolalg import Not, Equivalent, to_nnf\n>>> to_nnf(Not((~A & ~B) | (C & D)))\n(A | B) & (~C | ~D)\n>>> to_nnf(Equivalent(A >> B, B >> A))\n(A | ~B | (A & ~B)) & (B | ~A | (B & ~A)) \n```", "```py\nsympy.logic.boolalg.is_anf(expr)\n```", "```py\n>>> from sympy.logic.boolalg import And, Not, Xor, true, is_anf\n>>> from sympy.abc import A, B, C\n>>> is_anf(true)\nTrue\n>>> is_anf(A)\nTrue\n>>> is_anf(And(A, B, C))\nTrue\n>>> is_anf(Xor(A, Not(B)))\nFalse \n```", "```py\nsympy.logic.boolalg.is_cnf(expr)\n```", "```py\n>>> from sympy.logic.boolalg import is_cnf\n>>> from sympy.abc import A, B, C\n>>> is_cnf(A | B | C)\nTrue\n>>> is_cnf(A & B & C)\nTrue\n>>> is_cnf((A & B) | C)\nFalse \n```", "```py\nsympy.logic.boolalg.is_dnf(expr)\n```", "```py\n>>> from sympy.logic.boolalg import is_dnf\n>>> from sympy.abc import A, B, C\n>>> is_dnf(A | B | C)\nTrue\n>>> is_dnf(A & B & C)\nTrue\n>>> is_dnf((A & B) | C)\nTrue\n>>> is_dnf(A & (B | C))\nFalse \n```", "```py\nsympy.logic.boolalg.is_nnf(expr, simplified=True)\n```", "```py\n>>> from sympy.abc import A, B, C\n>>> from sympy.logic.boolalg import Not, is_nnf\n>>> is_nnf(A & B | ~C)\nTrue\n>>> is_nnf((A | ~A) & (B | C))\nFalse\n>>> is_nnf((A | ~A) & (B | C), False)\nTrue\n>>> is_nnf(Not(A & B) | C)\nFalse\n>>> is_nnf((A >> B) & (B >> A))\nFalse \n```", "```py\nsympy.logic.boolalg.gateinputcount(expr)\n```", "```py\n>>> from sympy.logic import And, Or, Nand, Not, gateinputcount\n>>> from sympy.abc import x, y, z\n>>> expr = And(x, y)\n>>> gateinputcount(expr)\n2\n>>> gateinputcount(Or(expr, z))\n4 \n```", "```py\n>>> gateinputcount(Nand(x, y, z))\n4\n>>> gateinputcount(Not(And(x, y, z)))\n4 \n```", "```py\n>>> gateinputcount(Nand(x, y, z, evaluate=False))\n3 \n```", "```py\n>>> gateinputcount(And(x > z, y >= 2))\n2 \n```", "```py\nsympy.logic.boolalg.simplify_logic(expr, form=None, deep=True, force=False, dontcare=None)\n```", "```py\n>>> from sympy.logic import simplify_logic\n>>> from sympy.abc import x, y, z\n>>> b = (~x & ~y & ~z) | ( ~x & ~y & z)\n>>> simplify_logic(b)\n~x & ~y\n>>> simplify_logic(x | y, dontcare=y)\nx \n```", "```py\nsympy.logic.boolalg.bool_map(bool1, bool2)\n```", "```py\n>>> from sympy import SOPform, bool_map, Or, And, Not, Xor\n>>> from sympy.abc import w, x, y, z, a, b, c, d\n>>> function1 = SOPform([x, z, y],[[1, 0, 1], [0, 0, 1]])\n>>> function2 = SOPform([a, b, c],[[1, 0, 1], [1, 0, 0]])\n>>> bool_map(function1, function2)\n(y & ~z, {y: a, z: b}) \n```", "```py\n>>> eq =  Or(And(Not(y), w), And(Not(y), z), And(x, y))\n>>> eq2 = Or(And(Not(c), a), And(Not(c), d), And(b, c))\n>>> bool_map(eq, eq2)\n((x & y) | (w & ~y) | (z & ~y), {w: a, x: b, y: c, z: d})\n>>> eq = And(Xor(a, b), c, And(c,d))\n>>> bool_map(eq, eq.subs(c, x))\n(c & d & (a | b) & (~a | ~b), {a: a, b: b, c: d, d: x}) \n```", "```py\nsympy.logic.boolalg.distribute_and_over_or(expr)\n```", "```py\n>>> from sympy.logic.boolalg import distribute_and_over_or, And, Or, Not\n>>> from sympy.abc import A, B, C\n>>> distribute_and_over_or(Or(A, And(Not(B), Not(C))))\n(A | ~B) & (A | ~C) \n```", "```py\nsympy.logic.boolalg.distribute_or_over_and(expr)\n```", "```py\n>>> from sympy.logic.boolalg import distribute_or_over_and, And, Or, Not\n>>> from sympy.abc import A, B, C\n>>> distribute_or_over_and(And(Or(Not(A), B), C))\n(B & C) | (C & ~A) \n```", "```py\nsympy.logic.boolalg.distribute_xor_over_and(expr)\n```", "```py\n>>> from sympy.logic.boolalg import distribute_xor_over_and, And, Xor, Not\n>>> from sympy.abc import A, B, C\n>>> distribute_xor_over_and(And(Xor(Not(A), B), C))\n(B & C) ^ (C & ~A) \n```", "```py\nsympy.logic.boolalg.eliminate_implications(expr)\n```", "```py\n>>> from sympy.logic.boolalg import Implies, Equivalent,          eliminate_implications\n>>> from sympy.abc import A, B, C\n>>> eliminate_implications(Implies(A, B))\nB | ~A\n>>> eliminate_implications(Equivalent(A, B))\n(A | ~B) & (B | ~A)\n>>> eliminate_implications(Equivalent(A, B, C))\n(A | ~C) & (B | ~A) & (C | ~B) \n```", "```py\nsympy.logic.boolalg.truth_table(expr, variables, input=True)\n```", "```py\n>>> from sympy.logic.boolalg import truth_table\n>>> from sympy.abc import x,y\n>>> table = truth_table(x >> y, [x, y])\n>>> for t in table:\n...     print('{0} -> {1}'.format(*t))\n[0, 0] -> True\n[0, 1] -> True\n[1, 0] -> False\n[1, 1] -> True \n```", "```py\n>>> table = truth_table(x | y, [x, y])\n>>> list(table)\n[([0, 0], False), ([0, 1], True), ([1, 0], True), ([1, 1], True)] \n```", "```py\n>>> from sympy.utilities.iterables import ibin\n>>> vars = [y, x]\n>>> values = truth_table(x >> y, vars, input=False)\n>>> values = list(values)\n>>> values\n[True, False, True, True] \n```", "```py\n>>> for i, value in enumerate(values):\n...     print('{0} -> {1}'.format(list(zip(\n...     vars, ibin(i, len(vars)))), value))\n[(y, 0), (x, 0)] -> True\n[(y, 0), (x, 1)] -> False\n[(y, 1), (x, 0)] -> True\n[(y, 1), (x, 1)] -> True \n```", "```py\nsympy.logic.boolalg.integer_to_term(n, bits=None, str=False)\n```", "```py\n>>> from sympy.utilities.iterables import ibin\n>>> ibin(2)\n[1, 0]\n>>> ibin(2, 4)\n[0, 0, 1, 0] \n```", "```py\n>>> bits = 2\n>>> for i in ibin(2, 'all'):\n...     print(i)\n(0, 0)\n(0, 1)\n(1, 0)\n(1, 1) \n```", "```py\n>>> n = 123\n>>> bits = 10\n>>> ibin(n, bits, str=True)\n'0001111011'\n>>> ibin(n, bits, str=True)[::-1]  # small bits left\n'1101111000'\n>>> list(ibin(3, 'all', str=True))\n['000', '001', '010', '011', '100', '101', '110', '111'] \n```", "```py\nsympy.logic.boolalg.term_to_integer(term)\n```", "```py\n>>> from sympy.logic.boolalg import term_to_integer\n>>> term_to_integer([1, 0, 0])\n4\n>>> term_to_integer('100')\n4 \n```", "```py\nsympy.logic.boolalg.bool_maxterm(k, variables)\n```", "```py\n>>> from sympy.logic.boolalg import bool_maxterm\n>>> from sympy.abc import x, y, z\n>>> bool_maxterm([1, 0, 1], [x, y, z])\ny | ~x | ~z\n>>> bool_maxterm(6, [x, y, z])\nz | ~x | ~y \n```", "```py\nsympy.logic.boolalg.bool_minterm(k, variables)\n```", "```py\n>>> from sympy.logic.boolalg import bool_minterm\n>>> from sympy.abc import x, y, z\n>>> bool_minterm([1, 0, 1], [x, y, z])\nx & z & ~y\n>>> bool_minterm(6, [x, y, z])\nx & y & ~z \n```", "```py\nsympy.logic.boolalg.bool_monomial(k, variables)\n```", "```py\n>>> from sympy.logic.boolalg import bool_monomial\n>>> from sympy.abc import x, y, z\n>>> bool_monomial([1, 0, 1], [x, y, z])\nx & z\n>>> bool_monomial(6, [x, y, z])\nx & y \n```", "```py\nsympy.logic.boolalg.anf_coeffs(truthvalues)\n```", "```py\n>>> from sympy.logic.boolalg import anf_coeffs, bool_monomial, Xor\n>>> from sympy.abc import a, b, c\n>>> truthvalues = [0, 1, 1, 0, 0, 1, 0, 1]\n>>> coeffs = anf_coeffs(truthvalues)\n>>> coeffs\n[0, 1, 1, 0, 0, 0, 1, 0]\n>>> polynomial = Xor(*[\n...     bool_monomial(k, [a, b, c])\n...     for k, coeff in enumerate(coeffs) if coeff == 1\n... ])\n>>> polynomial\nb ^ c ^ (a & b) \n```", "```py\nsympy.logic.boolalg.to_int_repr(clauses, symbols)\n```", "```py\n>>> from sympy.logic.boolalg import to_int_repr\n>>> from sympy.abc import x, y\n>>> to_int_repr([x | y, y], [x, y]) == [{1, 2}, {2}]\nTrue \n```", "```py\n>>> from sympy.logic.inference import satisfiable\n>>> from sympy import Symbol\n>>> x = Symbol('x')\n>>> y = Symbol('y')\n>>> satisfiable(x & ~x)\nFalse\n>>> satisfiable((x | y) & (x | ~y) & (~x | y))\n{x: True, y: True} \n```", "```py\nsympy.logic.inference.satisfiable(expr, algorithm=None, all_models=False, minimal=False, use_lra_theory=False)\n```", "```py\n>>> from sympy.abc import A, B\n>>> from sympy.logic.inference import satisfiable\n>>> satisfiable(A & ~B)\n{A: True, B: False}\n>>> satisfiable(A & ~A)\nFalse\n>>> satisfiable(True)\n{True: True}\n>>> next(satisfiable(A & ~A, all_models=True))\nFalse\n>>> models = satisfiable((A >> B) & B, all_models=True)\n>>> next(models)\n{A: False, B: True}\n>>> next(models)\n{A: True, B: True}\n>>> def use_models(models):\n...     for model in models:\n...         if model:\n...             # Do something with the model.\n...             print(model)\n...         else:\n...             # Given expr is unsatisfiable.\n...             print(\"UNSAT\")\n>>> use_models(satisfiable(A >> ~A, all_models=True))\n{A: False}\n>>> use_models(satisfiable(A ^ A, all_models=True))\nUNSAT \n```"]