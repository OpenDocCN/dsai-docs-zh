- en: Linearization (Docstrings)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/physics/mechanics/api/linearize.html](https://docs.sympy.org/latest/modules/physics/mechanics/api/linearize.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This object holds the general model form for a dynamic system. This model is
    used for computing the linearized form of the system, while properly dealing with
    constraints leading to dependent coordinates and speeds. The notation and method
    is described in [[R739]](#r739).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R739] ([1](#id1),[2](#id2))'
  prefs: []
  type: TYPE_NORMAL
- en: 'D. L. Peterson, G. Gede, and M. Hubbard, “Symbolic linearization of equations
    of motion of constrained multibody systems,” Multibody Syst Dyn, vol. 33, no.
    2, pp. 143-161, Feb. 2015, doi: 10.1007/s11044-014-9436-5.'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| f_0, f_1, f_2, f_3, f_4, f_c, f_v, f_a | (Matrix) Matrices holding the general
    system form. |'
  prefs: []
  type: TYPE_TB
- en: '| q, u, r | (Matrix) Matrices holding the generalized coordinates, speeds,
    and input vectors. |'
  prefs: []
  type: TYPE_TB
- en: '| q_i, u_i | (Matrix) Matrices of the independent generalized coordinates and
    speeds. |'
  prefs: []
  type: TYPE_TB
- en: '| q_d, u_d | (Matrix) Matrices of the dependent generalized coordinates and
    speeds. |'
  prefs: []
  type: TYPE_TB
- en: '| perm_mat | (Matrix) Permutation matrix such that [q_ind, u_ind]^T = perm_mat*[q,
    u]^T |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f_0, f_1, f_2, f_3, f_4, f_c, f_v, f_a** : array_like'
  prefs: []
  type: TYPE_NORMAL
- en: System of equations holding the general system form. Supply empty array or Matrix
    if the parameter does not exist.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**q** : array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The generalized coordinates.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**u** : array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The generalized speeds
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**q_i, u_i** : array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The independent generalized coordinates and speeds.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**q_d, u_d** : array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The dependent generalized coordinates and speeds.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**r** : array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The input variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**lams** : array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The lagrange multipliers
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**linear_solver** : str, callable'
  prefs: []
  type: TYPE_NORMAL
- en: Method used to solve the several symbolic linear systems of the form `A*x=b`
    in the linearization process. If a string is supplied, it should be a valid method
    that can be used with the [`sympy.matrices.matrixbase.MatrixBase.solve()`](../../../matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.solve
    "sympy.matrices.matrixbase.MatrixBase.solve"). If a callable is supplied, it should
    have the format `x = f(A, b)`, where it solves the equations and returns the solution.
    The default is `'LU'` which corresponds to SymPy’s `A.LUsolve(b)`. `LUsolve()`
    is fast to compute but will often result in divide-by-zero and thus `nan` results.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Linearize the system about the operating point. Note that q_op, u_op, qd_op,
    ud_op must satisfy the equations of motion. These may be either symbolic or numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op_point** : dict or iterable of dicts, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary or iterable of dictionaries containing the operating point conditions
    for all or a subset of the generalized coordinates, generalized speeds, and time
    derivatives of the generalized speeds. These will be substituted into the linearized
    system before the linearization is complete. Leave set to `None` if you want the
    operating point to be an arbitrary set of symbols. Note that any reduction in
    symbols (whether substituted for numbers or expressions with a common parameter)
    will result in faster runtime.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A_and_B** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If A_and_B=False (default), (M, A, B) is returned and of A_and_B=True, (A, B)
    is returned. See below.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Determines if returned values are simplified before return. For large expressions
    this may be time consuming. Default is False.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M, A, B** : Matrices, `A_and_B=False`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices from the implicit form:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`[M]*[q'', u'']^T = [A]*[q_ind, u_ind]^T + [B]*r`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A, B** : Matrices, `A_and_B=True`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices from the explicit form:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`[q_ind'', u_ind'']^T = [A]*[q_ind, u_ind]^T + [B]*r`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Note that the process of solving with A_and_B=True is computationally intensive
    if there are many symbolic parameters. For this reason, it may be more desirable
    to use the default A_and_B=False, returning M, A, and B. More values may then
    be substituted in to these matrices later on. The state space form can then be
    found as A = P.T*M.LUsolve(A), B = P.T*M.LUsolve(B), where P = Linearizer.perm_mat.
  prefs: []
  type: TYPE_NORMAL
