# `numpy.partition`

> 译文：[`numpy.org/doc/1.26/reference/generated/numpy.partition.html`](https://numpy.org/doc/1.26/reference/generated/numpy.partition.html)

```py
numpy.partition(a, kth, axis=-1, kind='introselect', order=None)
```

返回数组的分区副本。

创建数组的副本，其元素重新排列，使得第 k 个位置的元素的值在排序数组中的位置。在分区数组中，所有在第 k 个元素之前的元素都小于或等于该元素，而在第 k 个元素之后的所有元素都大于或等于该元素。两个分区中元素的顺序是未定义的。

自版本 1.8.0 起新增。

参数：

**a**类似数组

要排序的数组。

**kth**int 或 int 序列

要按元素索引进行分区的元素。元素的第 k 个值将在其最终排序位置上，所有较小的元素将在其前面移动，所有相等或更大的元素将在其后面。分区中所有元素的顺序是未定义的。如果提供了一个 k-th 序列，它将一次将所有由它们的 k-th 索引的元素分区到它们的排序位置。

自版本 1.22.0 起弃用：将布尔值作为索引传递已弃用。

**轴**整数或 None，可选

要排序的轴。如果为 None，则在排序之前将数组展平。默认值为 -1，沿着最后一个轴排序。

**种类**{‘introselect’}，可选

选择算法。默认为 ‘introselect’。

**顺序**字符串或字符串列表，可选

当 *a* 是一个定义了字段的数组时，此参数指定首先比较哪些字段，其次是哪些字段等。可以将单个字段指定为字符串。不需要指定所有字段，但未指定的字段仍将按照它们在 dtype 中出现的顺序来解决冲突。

返回：

**分区数组**ndarray

与 *a* 相同类型和形状的数组。

另请参阅

`ndarray.partition`

在原地对数组进行排序的方法。

`argpartition`

间接分区。

`sort`

完全排序

笔记

各种选择算法的特点在于它们的平均速度、最坏情况性能、工作空间大小以及它们是否稳定。稳定排序会保持具有相同键的项目相对顺序不变。可用的算法具有以下特性：

| 种类 | 速度 | 最坏情况 | 工作空间 | 稳定性 |
| --- | --- | --- | --- | --- |
| ‘introselect’ | 1 | O(n) | 0 | 否 |

所有分区算法在沿着除最后一个轴以外的任何轴进行分区时都会对数据进行临时复制。因此，沿着最后一个轴进行分区比沿着其他任何轴进行分区更快，使用的空间也更少。

复数的排序顺序是按字典顺序排列的。如果实部和虚部都不是 nan，则顺序由实部确定，除非它们相等，在这种情况下，顺序由虚部确定。

示例

```py
>>> a = np.array([7, 1, 7, 7, 1, 5, 7, 2, 3, 2, 6, 2, 3, 0])
>>> p = np.partition(a, 4)
>>> p
array([0, 1, 2, 1, 2, 5, 2, 3, 3, 6, 7, 7, 7, 7]) 
```

`p[4]`为 2；`p[:4]`中的所有元素都小于或等于`p[4]`，`p[5:]`中的所有元素都大于或等于`p[4]`。划分如下：

```py
[0, 1, 2, 1], [2], [5, 2, 3, 3, 6, 7, 7, 7, 7] 
```

下一个示例展示了传递给*kth*的多个值的使用。

```py
>>> p2 = np.partition(a, (4, 8))
>>> p2
array([0, 1, 2, 1, 2, 3, 3, 2, 5, 6, 7, 7, 7, 7]) 
```

`p2[4]`为 2，`p2[8]`为 5。`p2[:4]`中的所有元素都小于或等于`p2[4]`，`p2[5:8]`中的所有元素都大于或等于`p2[4]`且小于或等于`p2[8]`，`p2[9:]`中的所有元素都大于或等于`p2[8]`。划分如下：

```py
[0, 1, 2, 1], [2], [3, 3, 2], [5], [6, 7, 7, 7, 7] 
```
