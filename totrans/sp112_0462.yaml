- en: scipy.optimize.root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.root.html#scipy.optimize.root](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.root.html#scipy.optimize.root)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of a vector function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun**callable'
  prefs: []
  type: TYPE_NORMAL
- en: A vector function to find a root of.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments passed to the objective function and its Jacobian.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Type of solver. Should be one of
  prefs: []
  type: TYPE_NORMAL
- en: ‘hybr’ [(see here)](../optimize.root-hybr.html#optimize-root-hybr)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘lm’ [(see here)](../optimize.root-lm.html#optimize-root-lm)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘broyden1’ [(see here)](../optimize.root-broyden1.html#optimize-root-broyden1)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘broyden2’ [(see here)](../optimize.root-broyden2.html#optimize-root-broyden2)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘anderson’ [(see here)](../optimize.root-anderson.html#optimize-root-anderson)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘linearmixing’ [(see here)](../optimize.root-linearmixing.html#optimize-root-linearmixing)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘diagbroyden’ [(see here)](../optimize.root-diagbroyden.html#optimize-root-diagbroyden)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘excitingmixing’ [(see here)](../optimize.root-excitingmixing.html#optimize-root-excitingmixing)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘krylov’ [(see here)](../optimize.root-krylov.html#optimize-root-krylov)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘df-sane’ [(see here)](../optimize.root-dfsane.html#optimize-root-dfsane)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jac**bool or callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *jac* is a Boolean and is True, *fun* is assumed to return the value of Jacobian
    along with the objective function. If False, the Jacobian will be estimated numerically.
    *jac* can also be a callable returning the Jacobian of *fun*. In this case, it
    must accept the same arguments as *fun*.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Tolerance for termination. For detailed control, use solver-specific options.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Optional callback function. It is called on every iteration as `callback(x,
    f)` where *x* is the current solution and *f* the corresponding residual. For
    all methods but ‘hybr’ and ‘lm’.
  prefs: []
  type: TYPE_NORMAL
- en: '**options**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of solver options. E.g., *xtol* or *maxiter*, see [`show_options()`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options") for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sol**OptimizeResult'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution represented as a `OptimizeResult` object. Important attributes
    are: `x` the solution array, `success` a Boolean flag indicating if the algorithm
    exited successfully and `message` which describes the cause of the termination.
    See [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") for a description of other attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options")'
  prefs: []
  type: TYPE_NORMAL
- en: Additional options accepted by the solvers
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the available solvers that can be selected by the ‘method’
    parameter. The default method is *hybr*.
  prefs: []
  type: TYPE_NORMAL
- en: Method *hybr* uses a modification of the Powell hybrid method as implemented
    in MINPACK [[1]](#r9d4d7396324b-1).
  prefs: []
  type: TYPE_NORMAL
- en: Method *lm* solves the system of nonlinear equations in a least squares sense
    using a modification of the Levenberg-Marquardt algorithm as implemented in MINPACK
    [[1]](#r9d4d7396324b-1).
  prefs: []
  type: TYPE_NORMAL
- en: Method *df-sane* is a derivative-free spectral method. [[3]](#r9d4d7396324b-3)
  prefs: []
  type: TYPE_NORMAL
- en: Methods *broyden1*, *broyden2*, *anderson*, *linearmixing*, *diagbroyden*, *excitingmixing*,
    *krylov* are inexact Newton methods, with backtracking or full line searches [[2]](#r9d4d7396324b-2).
    Each method corresponds to a particular Jacobian approximations.
  prefs: []
  type: TYPE_NORMAL
- en: Method *broyden1* uses Broyden’s first Jacobian approximation, it is known as
    Broyden’s good method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *broyden2* uses Broyden’s second Jacobian approximation, it is known
    as Broyden’s bad method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *anderson* uses (extended) Anderson mixing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *Krylov* uses Krylov approximation for inverse Jacobian. It is suitable
    for large-scale problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *diagbroyden* uses diagonal Broyden Jacobian approximation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *linearmixing* uses a scalar Jacobian approximation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method *excitingmixing* uses a tuned diagonal Jacobian approximation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms implemented for methods *diagbroyden*, *linearmixing* and *excitingmixing*
    may be useful for specific problems, but whether they will work may depend strongly
    on the problem.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id1),[2](#id2))'
  prefs: []
  type: TYPE_NORMAL
- en: More, Jorge J., Burton S. Garbow, and Kenneth E. Hillstrom. 1980\. User Guide
    for MINPACK-1.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: C. T. Kelley. 1995\. Iterative Methods for Linear and Nonlinear Equations. Society
    for Industrial and Applied Mathematics. <[https://archive.siam.org/books/kelley/fr16/](https://archive.siam.org/books/kelley/fr16/)>
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: La Cruz, J.M. Martinez, M. Raydan. Math. Comp. 75, 1429 (2006).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The following functions define a system of nonlinear equations and its jacobian.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A solution can be obtained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Large problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we needed to solve the following integrodifferential equation
    on the square \([0,1]\times[0,1]\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[\nabla^2 P = 10 \left(\int_0^1\int_0^1\cosh(P)\,dx\,dy\right)^2\]
  prefs: []
  type: TYPE_NORMAL
- en: with \(P(x,1) = 1\) and \(P=0\) elsewhere on the boundary of the square.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution can be found using the `method=''krylov''` solver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-optimize-root-1.png](../Images/2198d97bf9416a5d154f363d837e6153.png)'
  prefs: []
  type: TYPE_IMG
