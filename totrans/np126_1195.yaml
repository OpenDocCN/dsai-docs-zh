- en: NumPy 1.3.0 Release Notes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/release/1.3.0-notes.html](https://numpy.org/doc/1.26/release/1.3.0-notes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This minor includes numerous bug fixes, official python 2.6 support, and several
    new features such as generalized ufuncs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python 2.6 support
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 2.6 is now supported on all previously supported platforms, including
    windows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0361/](https://www.python.org/dev/peps/pep-0361/)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Generalized ufuncs
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a general need for looping over not only functions on scalars but also
    over functions on vectors (or arrays), as explained on [http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions](http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions).
    We propose to realize this concept by generalizing the universal functions (ufuncs),
    and provide a C implementation that adds ~500 lines to the numpy code base. In
    current (specialized) ufuncs, the elementary function is limited to element-by-element
    operations, whereas the generalized version supports “sub-array” by “sub-array”
    operations. The Perl vector library PDL provides a similar functionality and its
    terms are re-used in the following.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Each generalized ufunc has information associated with it that states what the
    “core” dimensionality of the inputs is, as well as the corresponding dimensionality
    of the outputs (the element-wise ufuncs have zero core dimensions). The list of
    the core dimensions for all arguments is called the “signature” of a ufunc. For
    example, the ufunc numpy.add has signature “(),()->()” defining two scalar inputs
    and one scalar output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Another example is (see the GeneralLoopingFunctions page) the function inner1d(a,b)
    with a signature of “(i),(i)->()”. This applies the inner product along the last
    axis of each input, but keeps the remaining indices intact. For example, where
    a is of shape (3,5,N) and b is of shape (5,N), this will return an output of shape
    (3,5). The underlying elementary function is called 3*5 times. In the signature,
    we specify one core dimension “(i)” for each input and zero core dimensions “()”
    for the output, since it takes two 1-d arrays and returns a scalar. By using the
    same name “i”, we specify that the two corresponding dimensions should be of the
    same size (or one of them is of size 1 and will be broadcasted).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The dimensions beyond the core dimensions are called “loop” dimensions. In the
    above example, this corresponds to (3,5).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual numpy “broadcasting” rules apply, where the signature determines
    how the dimensions of each input/output object are split into core and loop dimensions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: While an input array has a smaller dimensionality than the corresponding number
    of core dimensions, 1’s are pre-pended to its shape. The core dimensions are removed
    from all inputs and the remaining dimensions are broadcasted; defining the loop
    dimensions. The output is given by the loop dimensions plus the output core dimensions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Experimental Windows 64 bits support
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numpy can now be built on windows 64 bits (amd64 only, not IA64), with both
    MS compilers and mingw-w64 compilers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'This is *highly experimental*: DO NOT USE FOR PRODUCTION USE. See INSTALL.txt,
    Windows 64 bits section for more information on limitations and how to build it
    by yourself.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: New features
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Formatting issues
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Float formatting is now handled by numpy instead of the C runtime: this enables
    locale independent formatting, more robust fromstring and related methods. Special
    values (inf and nan) are also more consistent across platforms (nan vs IND/NaN,
    etc…), and more consistent with recent python formatting work (in 2.6 and later).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Nan handling in max/min
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum/minimum ufuncs now reliably propagate nans. If one of the arguments
    is a nan, then nan is returned. This affects np.min/np.max, amin/amax and the
    array methods max/min. New ufuncs fmax and fmin have been added to deal with non-propagating
    nans.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Nan handling in sign
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ufunc sign now returns nan for the sign of anan.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: New ufuncs
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: fmax - same as maximum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fmin - same as minimum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: deg2rad - converts degrees to radians, same as the radians ufunc.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rad2deg - converts radians to degrees, same as the degrees ufunc.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: log2 - base 2 logarithm.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: exp2 - base 2 exponential.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: trunc - truncate floats to nearest integer towards zero.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: logaddexp - add numbers stored as logarithms and return the logarithm of the
    result.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: logaddexp2 - add numbers stored as base 2 logarithms and return the base 2 logarithm
    of the result.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Masked arrays
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several new features and bug fixes, including:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: structured arrays should now be fully supported by MaskedArray (r6463, r6324,
    r6305, r6300, r6294…)
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Minor bug fixes (r6356, r6352, r6335, r6299, r6298)
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Improved support for __iter__ (r6326)
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: made baseclass, sharedmask and hardmask accessible to the user (but read-only)
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: doc update
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: gfortran support on windows
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gfortran can now be used as a fortran compiler for numpy on windows, even when
    the C compiler is Visual Studio (VS 2005 and above; VS 2003 will NOT work). Gfortran
    + Visual studio does not work on windows 64 bits (but gcc + gfortran does). It
    is unclear whether it will be possible to use gfortran and visual studio at all
    on x64.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Arch option for windows binary
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Automatic arch detection can now be bypassed from the command line for the
    superpack installed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: numpy-1.3.0-superpack-win32.exe /arch=nosse
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: will install a numpy which works on any x86, even if the running computer supports
    SSE set.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated features
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Histogram
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The semantics of histogram has been modified to fix long-standing issues with
    outliers handling. The main changes concern
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: the definition of the bin edges, now including the rightmost edge, and
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the handling of upper outliers, now ignored rather than tallied in the rightmost
    bin.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对上限离群值的处理方式已更改，现在在最右边的箱中被忽略而不是被计数。
- en: The previous behavior is still accessible using *new=False*, but this is deprecated,
    and will be removed entirely in 1.4.0.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的行为仍可通过*new=False*访问，但已被弃用，并将在1.4.0中完全移除。
- en: Documentation changes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档更改
- en: A lot of documentation has been added. Both user guide and references can be
    built from sphinx.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了大量文档。用户指南和参考资料可以从sphinx中构建。
- en: New C API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的C API
- en: Multiarray API
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Multiarray API
- en: 'The following functions have been added to the multiarray C API:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数已添加到multiarray C API中：
- en: 'PyArray_GetEndianness: to get runtime endianness'
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyArray_GetEndianness:获取运行时的字节顺序
- en: Ufunc API
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ufunc API
- en: 'The following functions have been added to the ufunc API:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数已添加到ufunc API中：
- en: 'PyUFunc_FromFuncAndDataAndSignature: to declare a more general ufunc (generalized
    ufunc).'
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyUFunc_FromFuncAndDataAndSignature：声明一个更常规的ufunc（广义ufunc）。
- en: New defines
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新定义
- en: 'New public C defines are available for ARCH specific code through numpy/npy_cpu.h:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过numpy/npy_cpu.h现在提供了用于特定代码的ARCH的新公共C定义：
- en: 'NPY_CPU_X86: x86 arch (32 bits)'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_X86: x86架构（32位）'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_AMD64: amd64 arch (x86_64, NOT Itanium)'
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_AMD64: amd64架构（x86_64，非Itanium）'
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC: 32 bits ppc'
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_CPU_PPC：32位ppc
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC64: 64 bits ppc'
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_PPC64: 64位ppc'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC: 32 bits sparc'
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_SPARC: 32位sparc'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC64: 64 bits sparc'
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_SPARC64: 64位sparc'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_S390: S390'
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_CPU_S390：S390
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_IA64: ia64'
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_CPU_IA64: ia64'
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PARISC: PARISC'
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_CPU_PARISC：PARISC
- en: 'New macros for CPU endianness has been added as well (see internal changes
    below for details):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也添加了CPU字节顺序的新宏（有关详细信息，请参见下文的内部更改）：
- en: 'NPY_BYTE_ORDER: integer'
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_BYTE_ORDER：整数
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: NPY_LITTLE_ENDIAN/NPY_BIG_ENDIAN defines
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_LITTLE_ENDIAN/NPY_BIG_ENDIAN定义
- en: Those provide portable alternatives to glibc endian.h macros for platforms without
    it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为那些没有的平台提供可移植的glibc endian.h宏。
- en: Portable NAN, INFINITY, etc…
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可移植的NAN、INFINITY等...
- en: 'npy_math.h now makes available several portable macro to get NAN, INFINITY:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: npy_math.h现在提供了几个可移植的宏，用于获取NAN、INFINITY：
- en: 'NPY_NAN: equivalent to NAN, which is a GNU extension'
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_NAN: 等同于GNU扩展的NAN'
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_INFINITY: equivalent to C99 INFINITY'
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NPY_INFINITY: 等同于C99 INFINITY'
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_PZERO, NPY_NZERO: positive and negative zero respectively'
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPY_PZERO, NPY_NZERO:正零和负零
- en: Corresponding single and extended precision macros are available as well. All
    references to NAN, or home-grown computation of NAN on the fly have been removed
    for consistency.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的单精度和扩展精度宏也可用。为了一致性，所有对NAN的引用或现场计算NAN的处理方式都已移除。
- en: Internal changes
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部更改
- en: numpy.core math configuration revamp
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numpy.core数学配置重组
- en: This should make the porting to new platforms easier, and more robust. In particular,
    the configuration stage does not need to execute any code on the target platform,
    which is a first step toward cross-compilation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以更容易、更强大地移植到新平台。特别是配置阶段不需要在目标平台上执行任何代码，这是迈向交叉编译的第一步。
- en: '[https://www.numpy.org/neps/nep-0003-math_config_clean.html](https://www.numpy.org/neps/nep-0003-math_config_clean.html)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.numpy.org/neps/nep-0003-math_config_clean.html](https://www.numpy.org/neps/nep-0003-math_config_clean.html)'
- en: umath refactor
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: umath重构
- en: A lot of code cleanup for umath/ufunc code (charris).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对umath/ufunc代码进行了大量清理（charris）。
- en: Improvements to build warnings
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进了构建警告
- en: Numpy can now build with -W -Wall without warnings
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy现在可以在不警告的情况下使用-W-Wall构建
- en: '[https://www.numpy.org/neps/nep-0002-warnfix.html](https://www.numpy.org/neps/nep-0002-warnfix.html)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.numpy.org/neps/nep-0002-warnfix.html](https://www.numpy.org/neps/nep-0002-warnfix.html)'
- en: Separate core math library
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单独的核心数学库
- en: The core math functions (sin, cos, etc… for basic C types) have been put into
    a separate library; it acts as a compatibility layer, to support most C99 maths
    functions (real only for now). The library includes platform-specific fixes for
    various maths functions, such as using those versions should be more robust than
    using your platform functions directly. The API for existing functions is exactly
    the same as the C99 math functions API; the only difference is the npy prefix
    (npy_cos vs cos).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数学函数（sin、cos等...）已放入单独的库中；它作为兼容性层，支持大多数C99数学函数（目前仅为实数）。该库包括各种数学函数的特定于平台的修复，使用这些版本比直接使用你的平台函数更稳健。现有函数的API与C99数学函数的API完全相同；唯一的区别是npyprefix（npy_cos与cos相比）。
- en: The core library will be made available to any extension in 1.4.0.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 核心库将在1.4.0中提供给任何扩展。
- en: CPU arch detection
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU架构检测
- en: npy_cpu.h defines numpy specific CPU defines, such as NPY_CPU_X86, etc… Those
    are portable across OS and toolchains, and set up when the header is parsed, so
    that they can be safely used even in the case of cross-compilation (the values
    is not set when numpy is built), or for multi-arch binaries (e.g. fat binaries
    on Max OS X).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: npy_cpu.h 定义了numpy特定的CPU定义，如NPY_CPU_X86等… 这些在OS和工具链之间是可移植的，并在头文件解析时设置，以便它们可以安全地在跨编译（值在构建numpy时未设置）或多架构二进制文件（如在Max
    OS X上的fat二进制文件）中使用。
- en: npy_endian.h defines numpy specific endianness defines, modeled on the glibc
    endian.h. NPY_BYTE_ORDER is equivalent to BYTE_ORDER, and one of NPY_LITTLE_ENDIAN
    or NPY_BIG_ENDIAN is defined. As for CPU archs, those are set when the header
    is parsed by the compiler, and as such can be used for cross-compilation and multi-arch
    binaries.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: npy_endian.h 定义了numpy特定的字节顺序定义，模仿了glibc的endian.h。NPY_BYTE_ORDER等同于BYTE_ORDER，并且定义了NPY_LITTLE_ENDIAN或NPY_BIG_ENDIAN之一。至于CPU架构，这些是在头文件被编译器解析时设置的，并且因此可以用于跨编译和多架构二进制文件。
- en: Highlights
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亮点
- en: Python 2.6 support
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 2.6 支持
- en: Python 2.6 is now supported on all previously supported platforms, including
    windows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.6 现在在所有先前支持的平台上得到支持，包括windows。
- en: '[https://www.python.org/dev/peps/pep-0361/](https://www.python.org/dev/peps/pep-0361/)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0361/](https://www.python.org/dev/peps/pep-0361/)'
- en: Generalized ufuncs
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛化的ufuncs
- en: There is a general need for looping over not only functions on scalars but also
    over functions on vectors (or arrays), as explained on [http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions](http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions).
    We propose to realize this concept by generalizing the universal functions (ufuncs),
    and provide a C implementation that adds ~500 lines to the numpy code base. In
    current (specialized) ufuncs, the elementary function is limited to element-by-element
    operations, whereas the generalized version supports “sub-array” by “sub-array”
    operations. The Perl vector library PDL provides a similar functionality and its
    terms are re-used in the following.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅需要循环遍历标量函数，还需要循环遍历向量（或数组）函数，如[http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions](http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions)中所解释的。我们建议通过泛化通用函数（ufuncs）来实现这一概念，并提供一个C实现，为numpy代码库增加了大约500行。在当前（专用）ufuncs中，基本函数受限于逐元素操作，而泛化版本支持“子数组”之间的操作。Perl向量库PDL提供了类似功能，并且它的术语在下文中被重复使用。
- en: Each generalized ufunc has information associated with it that states what the
    “core” dimensionality of the inputs is, as well as the corresponding dimensionality
    of the outputs (the element-wise ufuncs have zero core dimensions). The list of
    the core dimensions for all arguments is called the “signature” of a ufunc. For
    example, the ufunc numpy.add has signature “(),()->()” defining two scalar inputs
    and one scalar output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个泛化的ufunc都有与之相关的信息，说明输入的“核心”维度是什么，以及对应的输出的维度（逐元素ufuncs具有零个核心维度）。所有参数的核心维度列表被称为ufunc的“签名”。例如，ufunc
    numpy.add 具有签名“（），（）->（）”，定义了两个标量输入和一个标量输出。
- en: Another example is (see the GeneralLoopingFunctions page) the function inner1d(a,b)
    with a signature of “(i),(i)->()”. This applies the inner product along the last
    axis of each input, but keeps the remaining indices intact. For example, where
    a is of shape (3,5,N) and b is of shape (5,N), this will return an output of shape
    (3,5). The underlying elementary function is called 3*5 times. In the signature,
    we specify one core dimension “(i)” for each input and zero core dimensions “()”
    for the output, since it takes two 1-d arrays and returns a scalar. By using the
    same name “i”, we specify that the two corresponding dimensions should be of the
    same size (or one of them is of size 1 and will be broadcasted).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是（参见GeneralLoopingFunctions页面）具有“（i），（i）->（）”签名的函数inner1d(a,b)。这将沿着每个输入的最后一个轴应用内积，但保持其余索引不变。例如，如果a的形状为（3,5,N），b的形状为（5,N），则返回形状为（3,5）的输出。底层基本函数被调用了3*5次。在签名中，我们为每个输入指定一个核心维度“（i）”，为输出指定零个核心维度“（）”，因为它接受两个1维数组并返回一个标量。通过使用相同的名称“i”，我们指定两个对应的维度应该具有相同的大小（或其中一个大小为1，并且将被广播）。
- en: The dimensions beyond the core dimensions are called “loop” dimensions. In the
    above example, this corresponds to (3,5).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 超出核心维度的维度被称为“循环”维度。在上面的示例中，这对应于（3,5）。
- en: 'The usual numpy “broadcasting” rules apply, where the signature determines
    how the dimensions of each input/output object are split into core and loop dimensions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: While an input array has a smaller dimensionality than the corresponding number
    of core dimensions, 1’s are pre-pended to its shape. The core dimensions are removed
    from all inputs and the remaining dimensions are broadcasted; defining the loop
    dimensions. The output is given by the loop dimensions plus the output core dimensions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Experimental Windows 64 bits support
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numpy can now be built on windows 64 bits (amd64 only, not IA64), with both
    MS compilers and mingw-w64 compilers:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'This is *highly experimental*: DO NOT USE FOR PRODUCTION USE. See INSTALL.txt,
    Windows 64 bits section for more information on limitations and how to build it
    by yourself.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.6 support
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python 2.6 is now supported on all previously supported platforms, including
    windows.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0361/](https://www.python.org/dev/peps/pep-0361/)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Generalized ufuncs
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a general need for looping over not only functions on scalars but also
    over functions on vectors (or arrays), as explained on [http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions](http://scipy.org/scipy/numpy/wiki/GeneralLoopingFunctions).
    We propose to realize this concept by generalizing the universal functions (ufuncs),
    and provide a C implementation that adds ~500 lines to the numpy code base. In
    current (specialized) ufuncs, the elementary function is limited to element-by-element
    operations, whereas the generalized version supports “sub-array” by “sub-array”
    operations. The Perl vector library PDL provides a similar functionality and its
    terms are re-used in the following.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Each generalized ufunc has information associated with it that states what the
    “core” dimensionality of the inputs is, as well as the corresponding dimensionality
    of the outputs (the element-wise ufuncs have zero core dimensions). The list of
    the core dimensions for all arguments is called the “signature” of a ufunc. For
    example, the ufunc numpy.add has signature “(),()->()” defining two scalar inputs
    and one scalar output.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Another example is (see the GeneralLoopingFunctions page) the function inner1d(a,b)
    with a signature of “(i),(i)->()”. This applies the inner product along the last
    axis of each input, but keeps the remaining indices intact. For example, where
    a is of shape (3,5,N) and b is of shape (5,N), this will return an output of shape
    (3,5). The underlying elementary function is called 3*5 times. In the signature,
    we specify one core dimension “(i)” for each input and zero core dimensions “()”
    for the output, since it takes two 1-d arrays and returns a scalar. By using the
    same name “i”, we specify that the two corresponding dimensions should be of the
    same size (or one of them is of size 1 and will be broadcasted).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The dimensions beyond the core dimensions are called “loop” dimensions. In the
    above example, this corresponds to (3,5).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual numpy “broadcasting” rules apply, where the signature determines
    how the dimensions of each input/output object are split into core and loop dimensions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的 numpy “broadcasting” 规则适用，其中签名确定每个输入/输出对象的维度如何分割为核心维度和循环维度：
- en: While an input array has a smaller dimensionality than the corresponding number
    of core dimensions, 1’s are pre-pended to its shape. The core dimensions are removed
    from all inputs and the remaining dimensions are broadcasted; defining the loop
    dimensions. The output is given by the loop dimensions plus the output core dimensions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '当输入数组的维度小于对应的核心维度数量时，在其形状前面加上 1。从所有输入中移除核心维度，剩下的维度进行广播；定义循环维度。输出由循环维度加上输出核心维度给出。 '
- en: Experimental Windows 64 bits support
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验性的windows 64位支持
- en: 'Numpy can now be built on windows 64 bits (amd64 only, not IA64), with both
    MS compilers and mingw-w64 compilers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在 windows 64 位（仅限 amd64，不是 IA64）上构建 Numpy，使用 MS 编译器和 mingw-w64 编译器：
- en: 'This is *highly experimental*: DO NOT USE FOR PRODUCTION USE. See INSTALL.txt,
    Windows 64 bits section for more information on limitations and how to build it
    by yourself.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*高度实验性的*：不要用于生产用途。有关限制和如何自行构建的更多信息，请参阅 INSTALL.txt，Windows 64位部分。
- en: New features
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能
- en: Formatting issues
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式问题
- en: 'Float formatting is now handled by numpy instead of the C runtime: this enables
    locale independent formatting, more robust fromstring and related methods. Special
    values (inf and nan) are also more consistent across platforms (nan vs IND/NaN,
    etc…), and more consistent with recent python formatting work (in 2.6 and later).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点格式现在由 numpy 处理，而不是由 C 运行时处理：这使得格式化与语言环境无关，fromstring 等方法更加稳健。特殊值（inf 和 nan）在不同平台上也更一致（nan
    vs IND/NaN 等），与最近的 python 格式化工作（2.6及更高版本）更一致。
- en: Nan handling in max/min
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: max/min 中的 NaN 处理
- en: The maximum/minimum ufuncs now reliably propagate nans. If one of the arguments
    is a nan, then nan is returned. This affects np.min/np.max, amin/amax and the
    array methods max/min. New ufuncs fmax and fmin have been added to deal with non-propagating
    nans.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最大值/最小值ufuncs现在可靠地传播 nans。如果其中一个参数是 nan，则返回 nan。这影响 np.min/np.max，amin/amax
    和数组方法 max/min。已添加新的 fmax 和 fmin ufuncs 以处理不传播 nans。
- en: Nan handling in sign
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sign 中的 NaN 处理
- en: The ufunc sign now returns nan for the sign of anan.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ufunc sign 现在返回 nan 作为 anan 的符号。
- en: New ufuncs
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新ufuncs
- en: fmax - same as maximum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fmax - 对于整数类型和非nan浮点数，与最大值相同。如果一个参数是 nan，则返回非 nan 参数；如果两个参数都是 nan，则返回 nan。
- en: fmin - same as minimum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fmin - 对于整数类型和非 nan 浮点数，与最小值相同。如果一个参数是 nan，则返回非 nan 参数；如果两个参数都是 nan，则返回 nan。
- en: deg2rad - converts degrees to radians, same as the radians ufunc.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: deg2rad - 将度数转换为弧度，与 radians ufunc 相同。
- en: rad2deg - converts radians to degrees, same as the degrees ufunc.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: rad2deg - 将弧度转换为度数，与 degrees ufunc 相同。
- en: log2 - base 2 logarithm.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: log2 - 基数2的对数。
- en: exp2 - base 2 exponential.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: exp2 - 基数2的指数。
- en: trunc - truncate floats to nearest integer towards zero.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: trunc - 将浮点数截断为最接近零的整数。
- en: logaddexp - add numbers stored as logarithms and return the logarithm of the
    result.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: logaddexp - 将作为对数存储的数字相加，并返回结果的对数。
- en: logaddexp2 - add numbers stored as base 2 logarithms and return the base 2 logarithm
    of the result.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: logaddexp2 - 将存储为基数2的对数的数字相加，并返回结果的基数2对数。
- en: Masked arrays
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Masked arrays
- en: 'Several new features and bug fixes, including:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 包括若干新功能和 bug 修复：
- en: structured arrays should now be fully supported by MaskedArray (r6463, r6324,
    r6305, r6300, r6294…)
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化数组现在应该被 MaskedArray 完全支持 (r6463, r6324, r6305, r6300, r6294…)
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Minor bug fixes (r6356, r6352, r6335, r6299, r6298)
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小 bug 修复 (r6356, r6352, r6335, r6299, r6298)
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Improved support for __iter__ (r6326)
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 __iter__ 进行了改进 (r6326)
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: made baseclass, sharedmask and hardmask accessible to the user (but read-only)
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 baseclass、sharedmask 和 hardmask 对用户可访问（但只读）
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: doc update
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档更新
- en: gfortran support on windows
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: windows 上的 gfortran 支持
- en: Gfortran can now be used as a fortran compiler for numpy on windows, even when
    the C compiler is Visual Studio (VS 2005 and above; VS 2003 will NOT work). Gfortran
    + Visual studio does not work on windows 64 bits (but gcc + gfortran does). It
    is unclear whether it will be possible to use gfortran and visual studio at all
    on x64.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Gfortran 现在可以在 windows 上用作 numpy 的 Fortran 编译器，即使 C 编译器是 Visual Studio（VS 2005
    及更高版本；VS 2003 不工作）。Gfortran + Visual Studio 不能在 64 位 windows 上工作（但 gcc + gfortran
    可以）。目前尚不清楚是否可能在 x64 上使用 gfortran 和 Visual Studio。
- en: Arch option for windows binary
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Automatic arch detection can now be bypassed from the command line for the
    superpack installed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: numpy-1.3.0-superpack-win32.exe /arch=nosse
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: will install a numpy which works on any x86, even if the running computer supports
    SSE set.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Formatting issues
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Float formatting is now handled by numpy instead of the C runtime: this enables
    locale independent formatting, more robust fromstring and related methods. Special
    values (inf and nan) are also more consistent across platforms (nan vs IND/NaN,
    etc…), and more consistent with recent python formatting work (in 2.6 and later).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Nan handling in max/min
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum/minimum ufuncs now reliably propagate nans. If one of the arguments
    is a nan, then nan is returned. This affects np.min/np.max, amin/amax and the
    array methods max/min. New ufuncs fmax and fmin have been added to deal with non-propagating
    nans.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Nan handling in sign
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ufunc sign now returns nan for the sign of anan.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: New ufuncs
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: fmax - same as maximum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fmin - same as minimum for integer types and non-nan floats. Returns the non-nan
    argument if one argument is nan and returns nan if both arguments are nan.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: deg2rad - converts degrees to radians, same as the radians ufunc.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rad2deg - converts radians to degrees, same as the degrees ufunc.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: log2 - base 2 logarithm.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: exp2 - base 2 exponential.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: trunc - truncate floats to nearest integer towards zero.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: logaddexp - add numbers stored as logarithms and return the logarithm of the
    result.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: logaddexp2 - add numbers stored as base 2 logarithms and return the base 2 logarithm
    of the result.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Masked arrays
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several new features and bug fixes, including:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: structured arrays should now be fully supported by MaskedArray (r6463, r6324,
    r6305, r6300, r6294…)
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Minor bug fixes (r6356, r6352, r6335, r6299, r6298)
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Improved support for __iter__ (r6326)
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: made baseclass, sharedmask and hardmask accessible to the user (but read-only)
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: doc update
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: gfortran support on windows
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gfortran can now be used as a fortran compiler for numpy on windows, even when
    the C compiler is Visual Studio (VS 2005 and above; VS 2003 will NOT work). Gfortran
    + Visual studio does not work on windows 64 bits (but gcc + gfortran does). It
    is unclear whether it will be possible to use gfortran and visual studio at all
    on x64.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Arch option for windows binary
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Automatic arch detection can now be bypassed from the command line for the
    superpack installed:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: numpy-1.3.0-superpack-win32.exe /arch=nosse
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: will install a numpy which works on any x86, even if the running computer supports
    SSE set.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated features
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Histogram
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The semantics of histogram has been modified to fix long-standing issues with
    outliers handling. The main changes concern
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: the definition of the bin edges, now including the rightmost edge, and
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the handling of upper outliers, now ignored rather than tallied in the rightmost
    bin.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous behavior is still accessible using *new=False*, but this is deprecated,
    and will be removed entirely in 1.4.0.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Histogram
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The semantics of histogram has been modified to fix long-standing issues with
    outliers handling. The main changes concern
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: the definition of the bin edges, now including the rightmost edge, and
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the handling of upper outliers, now ignored rather than tallied in the rightmost
    bin.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The previous behavior is still accessible using *new=False*, but this is deprecated,
    and will be removed entirely in 1.4.0.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Documentation changes
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of documentation has been added. Both user guide and references can be
    built from sphinx.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: New C API
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiarray API
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions have been added to the multiarray C API:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'PyArray_GetEndianness: to get runtime endianness'
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Ufunc API
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions have been added to the ufunc API:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'PyUFunc_FromFuncAndDataAndSignature: to declare a more general ufunc (generalized
    ufunc).'
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: New defines
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New public C defines are available for ARCH specific code through numpy/npy_cpu.h:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_CPU_X86: x86 arch (32 bits)'
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_AMD64: amd64 arch (x86_64, NOT Itanium)'
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC: 32 bits ppc'
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC64: 64 bits ppc'
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC: 32 bits sparc'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC64: 64 bits sparc'
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_S390: S390'
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_IA64: ia64'
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PARISC: PARISC'
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New macros for CPU endianness has been added as well (see internal changes
    below for details):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_BYTE_ORDER: integer'
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: NPY_LITTLE_ENDIAN/NPY_BIG_ENDIAN defines
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Those provide portable alternatives to glibc endian.h macros for platforms without
    it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Portable NAN, INFINITY, etc…
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'npy_math.h now makes available several portable macro to get NAN, INFINITY:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_NAN: equivalent to NAN, which is a GNU extension'
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_INFINITY: equivalent to C99 INFINITY'
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_PZERO, NPY_NZERO: positive and negative zero respectively'
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Corresponding single and extended precision macros are available as well. All
    references to NAN, or home-grown computation of NAN on the fly have been removed
    for consistency.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Multiarray API
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions have been added to the multiarray C API:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'PyArray_GetEndianness: to get runtime endianness'
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Ufunc API
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following functions have been added to the ufunc API:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'PyUFunc_FromFuncAndDataAndSignature: to declare a more general ufunc (generalized
    ufunc).'
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: New defines
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'New public C defines are available for ARCH specific code through numpy/npy_cpu.h:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_CPU_X86: x86 arch (32 bits)'
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_AMD64: amd64 arch (x86_64, NOT Itanium)'
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC: 32 bits ppc'
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PPC64: 64 bits ppc'
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC: 32 bits sparc'
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_SPARC64: 64 bits sparc'
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_S390: S390'
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_IA64: ia64'
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_CPU_PARISC: PARISC'
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New macros for CPU endianness has been added as well (see internal changes
    below for details):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_BYTE_ORDER: integer'
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: NPY_LITTLE_ENDIAN/NPY_BIG_ENDIAN defines
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Those provide portable alternatives to glibc endian.h macros for platforms without
    it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Portable NAN, INFINITY, etc…
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'npy_math.h now makes available several portable macro to get NAN, INFINITY:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'NPY_NAN: equivalent to NAN, which is a GNU extension'
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_INFINITY: equivalent to C99 INFINITY'
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'NPY_PZERO, NPY_NZERO: positive and negative zero respectively'
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Corresponding single and extended precision macros are available as well. All
    references to NAN, or home-grown computation of NAN on the fly have been removed
    for consistency.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Internal changes
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: numpy.core math configuration revamp
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This should make the porting to new platforms easier, and more robust. In particular,
    the configuration stage does not need to execute any code on the target platform,
    which is a first step toward cross-compilation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.numpy.org/neps/nep-0003-math_config_clean.html](https://www.numpy.org/neps/nep-0003-math_config_clean.html)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: umath refactor
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of code cleanup for umath/ufunc code (charris).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to build warnings
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numpy can now build with -W -Wall without warnings
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.numpy.org/neps/nep-0002-warnfix.html](https://www.numpy.org/neps/nep-0002-warnfix.html)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Separate core math library
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core math functions (sin, cos, etc… for basic C types) have been put into
    a separate library; it acts as a compatibility layer, to support most C99 maths
    functions (real only for now). The library includes platform-specific fixes for
    various maths functions, such as using those versions should be more robust than
    using your platform functions directly. The API for existing functions is exactly
    the same as the C99 math functions API; the only difference is the npy prefix
    (npy_cos vs cos).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The core library will be made available to any extension in 1.4.0.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: CPU arch detection
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: npy_cpu.h defines numpy specific CPU defines, such as NPY_CPU_X86, etc… Those
    are portable across OS and toolchains, and set up when the header is parsed, so
    that they can be safely used even in the case of cross-compilation (the values
    is not set when numpy is built), or for multi-arch binaries (e.g. fat binaries
    on Max OS X).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: npy_endian.h defines numpy specific endianness defines, modeled on the glibc
    endian.h. NPY_BYTE_ORDER is equivalent to BYTE_ORDER, and one of NPY_LITTLE_ENDIAN
    or NPY_BIG_ENDIAN is defined. As for CPU archs, those are set when the header
    is parsed by the compiler, and as such can be used for cross-compilation and multi-arch
    binaries.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: numpy.core math configuration revamp
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This should make the porting to new platforms easier, and more robust. In particular,
    the configuration stage does not need to execute any code on the target platform,
    which is a first step toward cross-compilation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.numpy.org/neps/nep-0003-math_config_clean.html](https://www.numpy.org/neps/nep-0003-math_config_clean.html)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: umath refactor
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A lot of code cleanup for umath/ufunc code (charris).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to build warnings
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Numpy can now build with -W -Wall without warnings
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.numpy.org/neps/nep-0002-warnfix.html](https://www.numpy.org/neps/nep-0002-warnfix.html)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Separate core math library
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The core math functions (sin, cos, etc… for basic C types) have been put into
    a separate library; it acts as a compatibility layer, to support most C99 maths
    functions (real only for now). The library includes platform-specific fixes for
    various maths functions, such as using those versions should be more robust than
    using your platform functions directly. The API for existing functions is exactly
    the same as the C99 math functions API; the only difference is the npy prefix
    (npy_cos vs cos).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The core library will be made available to any extension in 1.4.0.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: CPU arch detection
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: npy_cpu.h defines numpy specific CPU defines, such as NPY_CPU_X86, etc… Those
    are portable across OS and toolchains, and set up when the header is parsed, so
    that they can be safely used even in the case of cross-compilation (the values
    is not set when numpy is built), or for multi-arch binaries (e.g. fat binaries
    on Max OS X).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: npy_endian.h defines numpy specific endianness defines, modeled on the glibc
    endian.h. NPY_BYTE_ORDER is equivalent to BYTE_ORDER, and one of NPY_LITTLE_ENDIAN
    or NPY_BIG_ENDIAN is defined. As for CPU archs, those are set when the header
    is parsed by the compiler, and as such can be used for cross-compilation and multi-arch
    binaries.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
