- en: numpy.ma.polyfit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.ma.polyfit.html](https://numpy.org/doc/1.26/reference/generated/numpy.ma.polyfit.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Least squares polynomial fit.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This forms part of the old polynomial API. Since version 1.4, the new polynomial
    API defined in [`numpy.polynomial`](../routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") is preferred. A summary of the differences can be found in
    the [transition guide](../routines.polynomials.html).
  prefs: []
  type: TYPE_NORMAL
- en: Fit a polynomial `p(x) = p[0] * x**deg + ... + p[deg]` of degree *deg* to points
    *(x, y)*. Returns a vector of coefficients *p* that minimises the squared error
    in the order *deg*, *deg-1*, … *0*.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Polynomial.fit`](numpy.polynomial.polynomial.Polynomial.fit.html#numpy.polynomial.polynomial.Polynomial.fit
    "numpy.polynomial.polynomial.Polynomial.fit") class method is recommended for
    new code as it is more stable numerically. See the documentation of the method
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**array_like, shape (M,)'
  prefs: []
  type: TYPE_NORMAL
- en: x-coordinates of the M sample points `(x[i], y[i])`.
  prefs: []
  type: TYPE_NORMAL
- en: '**y**array_like, shape (M,) or (M, K)'
  prefs: []
  type: TYPE_NORMAL
- en: y-coordinates of the sample points. Several data sets of sample points sharing
    the same x-coordinates can be fitted at once by passing in a 2D-array that contains
    one dataset per column.
  prefs: []
  type: TYPE_NORMAL
- en: '**deg**int'
  prefs: []
  type: TYPE_NORMAL
- en: Degree of the fitting polynomial
  prefs: []
  type: TYPE_NORMAL
- en: '**rcond**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Relative condition number of the fit. Singular values smaller than this relative
    to the largest singular value will be ignored. The default value is len(x)*eps,
    where eps is the relative precision of the float type, about 2e-16 in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**full**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Switch determining nature of return value. When it is False (the default) just
    the coefficients are returned, when True diagnostic information from the singular
    value decomposition is also returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**w**array_like, shape (M,), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Weights. If not None, the weight `w[i]` applies to the unsquared residual `y[i]
    - y_hat[i]` at `x[i]`. Ideally the weights are chosen so that the errors of the
    products `w[i]*y[i]` all have the same variance. When using inverse-variance weighting,
    use `w[i] = 1/sigma(y[i])`. The default value is None.
  prefs: []
  type: TYPE_NORMAL
- en: '**cov**bool or str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If given and not *False*, return not just the estimate but also its covariance
    matrix. By default, the covariance are scaled by chi2/dof, where dof = M - (deg
    + 1), i.e., the weights are presumed to be unreliable except in a relative sense
    and everything is scaled such that the reduced chi2 is unity. This scaling is
    omitted if `cov='unscaled'`, as is relevant for the case that the weights are
    w = 1/sigma, with sigma known to be a reliable estimate of the uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p**ndarray, shape (deg + 1,) or (deg + 1, K)'
  prefs: []
  type: TYPE_NORMAL
- en: Polynomial coefficients, highest power first. If *y* was 2-D, the coefficients
    for *k*-th data set are in `p[:,k]`.
  prefs: []
  type: TYPE_NORMAL
- en: residuals, rank, singular_values, rcond
  prefs: []
  type: TYPE_NORMAL
- en: These values are only returned if `full == True`
  prefs: []
  type: TYPE_NORMAL
- en: residuals – sum of squared residuals of the least squares fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rank – the effective rank of the scaled Vandermonde
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: coefficient matrix
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: singular_values – singular values of the scaled Vandermonde
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: coefficient matrix
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rcond – value of *rcond*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details, see [`numpy.linalg.lstsq`](numpy.linalg.lstsq.html#numpy.linalg.lstsq
    "numpy.linalg.lstsq").
  prefs: []
  type: TYPE_NORMAL
- en: '**V**ndarray, shape (M,M) or (M,M,K)'
  prefs: []
  type: TYPE_NORMAL
- en: Present only if `full == False` and `cov == True`. The covariance matrix of
    the polynomial coefficient estimates. The diagonal of this matrix are the variance
    estimates for each coefficient. If y is a 2-D array, then the covariance matrix
    for the *k*-th data set are in `V[:,:,k]`
  prefs: []
  type: TYPE_NORMAL
- en: 'Warns:'
  prefs: []
  type: TYPE_NORMAL
- en: RankWarning
  prefs: []
  type: TYPE_NORMAL
- en: The rank of the coefficient matrix in the least-squares fit is deficient. The
    warning is only raised if `full == False`.
  prefs: []
  type: TYPE_NORMAL
- en: The warnings can be turned off by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`polyval`](numpy.polyval.html#numpy.polyval "numpy.polyval")'
  prefs: []
  type: TYPE_NORMAL
- en: Compute polynomial values.
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.lstsq`](numpy.linalg.lstsq.html#numpy.linalg.lstsq "numpy.linalg.lstsq")'
  prefs: []
  type: TYPE_NORMAL
- en: Computes a least-squares fit.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.interpolate.UnivariateSpline`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html#scipy.interpolate.UnivariateSpline
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Computes spline fits.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Any masked values in x is propagated in y, and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: The solution minimizes the squared error
  prefs: []
  type: TYPE_NORMAL
- en: \[E = \sum_{j=0}^k |p(x_j) - y_j|^2\]
  prefs: []
  type: TYPE_NORMAL
- en: 'in the equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The coefficient matrix of the coefficients *p* is a Vandermonde matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[`polyfit`](numpy.polyfit.html#numpy.polyfit "numpy.polyfit") issues a [`RankWarning`](numpy.RankWarning.html#numpy.RankWarning
    "numpy.RankWarning") when the least-squares fit is badly conditioned. This implies
    that the best fit is not well-defined due to numerical error. The results may
    be improved by lowering the polynomial degree or by replacing *x* by *x* - *x*.mean().
    The *rcond* parameter can also be set to a value smaller than its default, but
    the resulting fit may be spurious: including contributions from the small singular
    values can add numerical noise to the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that fitting polynomial coefficients is inherently badly conditioned when
    the degree of the polynomial is large or the interval of sample points is badly
    centered. The quality of the fit should always be checked in these cases. When
    polynomial fits are not satisfactory, splines may be a good alternative.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia, “Curve fitting”, [https://en.wikipedia.org/wiki/Curve_fitting](https://en.wikipedia.org/wiki/Curve_fitting)
  prefs: []
  type: TYPE_NORMAL
- en: '[2]'
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia, “Polynomial interpolation”, [https://en.wikipedia.org/wiki/Polynomial_interpolation](https://en.wikipedia.org/wiki/Polynomial_interpolation)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is convenient to use [`poly1d`](numpy.poly1d.html#numpy.poly1d "numpy.poly1d")
    objects for dealing with polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'High-order polynomials may oscillate wildly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/numpy-ma-polyfit-1.png](../Images/484d2a0375b105e2080f4887db2b4503.png)'
  prefs: []
  type: TYPE_IMG
