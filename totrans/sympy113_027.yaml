- en: Solving Guidance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/solving-guidance.html](https://docs.sympy.org/latest/guides/solving/solving-guidance.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These guidelines apply to many types of solving.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equations With no Closed-Form Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The vast majority of arbitrary nonlinear equations have no closed-form solution.
    The classes of equations that are solvable are basically:'
  prefs: []
  type: TYPE_NORMAL
- en: Linear equations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polynomials, except where limited by the [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)
    (learn more about solving polynomials using a [`GroebnerBasis`](../../modules/polys/reference.html#sympy.polys.polytools.GroebnerBasis
    "sympy.polys.polytools.GroebnerBasis"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equations that can be solved by inverting some transcendental functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Problems that can be transformed into the cases above (e.g., by turning trigonometric
    functions into polynomials)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few other special cases that can be solved with something like the [`Lambert
    W function`](../../modules/functions/elementary.html#sympy.functions.elementary.exponential.LambertW
    "sympy.functions.elementary.exponential.LambertW")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Equations that you can [`decompose()`](../../modules/polys/reference.html#sympy.polys.polytools.decompose
    "sympy.polys.polytools.decompose") via any of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SymPy may reflect that your equation has no solutions that can be expressed
    algebraically (symbolically), or that SymPy lacks an algorithm to find a closed-form
    solution that does exist, by returning an error such as `NotImplementedError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: so you may have to solve your equation numerically instead, for example using
    [`nsolve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve "sympy.solvers.solvers.nsolve")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you receive non-closed-form solutions such as [`CRootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") (which represents an indexed complex
    root of a polynomial), you can evaluate them numerically using [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When You Might Prefer a Numeric Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if your problem has a closed-form solution, you might prefer a numeric
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Solving functions such as [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset") will not try to find a numeric solution, only
    a mathematically-exact symbolic solution. So if you want a numeric solution, consider
    [`nsolve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve "sympy.solvers.solvers.nsolve").
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, even though a closed-form solution is available, it may
    be too cumbersome to be desirable. In that case, you can use [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf") instead if a numerical solution is acceptable. For example,
    the following solution set contains more than 40 terms total when expressed exactly
    (scroll horizontally in the code block below if you want to view them all), compared
    to eight when expressed numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In other situations, even if the exact solution has few terms, you may want
    a numeric solution so you know its approximate numerical value. For example, it
    may be difficult to estimate that \(\sqrt{2} e^{\pi}/2\) is approximately \(16\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use Exact Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to preserve the exact mathematical values of symbols such as transcendental
    numbers and [square roots](../../tutorials/intro-tutorial/intro.html#symbolic-computation),
    define them so that SymPy can interpret them symbolically, for example use SymPy’s
    [`Pi`](../../modules/core.html#sympy.core.numbers.Pi "sympy.core.numbers.Pi"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the standard Python math version of \(\pi\), Python will pass that
    inexact value to SymPy, leading to an inexact, numerical solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To use exact values for numbers such as \(6.2\) or \(1/2\), refer to [Python
    numbers vs. SymPy Numbers](../../explanation/gotchas.html#python-vs-sympy-numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases, using an inexact value will prevent SymPy from finding a
    result. For example, this exact equation can be solved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: but if you use the inexact equation `eq = x**1.4142135623730951 - 2`, SymPy
    will not return a result despite attempting for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Include the Variable to be Solved for in the Function Call
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We recommend you include the variable to be solved for as the second argument
    for solving functions including [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset"). While this is optional for univariate equations,
    it is a good practice because it ensures SymPy will solve for the desired symbol.
    For example, you might be interested in a solution for \(x\), but SymPy solves
    for \(y\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the variable to solve for ensures that SymPy solves for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '## Ensure Consistent Formatting From [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") produces a variety of output as explained in [Solve
    Output by Type](../../explanation/solve_output.html#solve-output). Using `dict=True`
    will give a consistent output format which is especially important when extracting
    information about the solution programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the solutions, you can iterate through the list of dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]  ## Options That Can Speed up [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")'
  prefs: []
  type: TYPE_NORMAL
- en: Include Solutions Making Any Denominator Zero
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") checks whether any solutions make any denominator
    zero, and automatically excludes them. If you want to include those solutions,
    and speed up [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") (at the risk of obtaining invalid solutions), set
    `check=False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Do Not Simplify Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") simplifies many results before returning them and
    (if `check` is not False) uses the general [`simplify()`](../../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") function on the solutions and the expression
    obtained when they are substituted into the function which should be zero. If
    you do not want the solutions simplified, and want to speed up [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"), use `simplify=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Parse a String Representing the Equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are creating the expression yourself, we advise [against using string
    parsing to create expressions](https://github.com/sympy/sympy/wiki/Idioms-and-Antipatterns#user-content-strings-as-input).
    But if you are programmatically reading in a string, this approach is convenient.
  prefs: []
  type: TYPE_NORMAL
- en: You can parse a string representing the equation into a form that SymPy can
    understand (for example, [`Eq`](../../modules/core.html#sympy.core.relational.Eq
    "sympy.core.relational.Eq") form), then solve the parsed expression. Parsing an
    equation from a string requires you to use [`transformations`](../../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr") for SymPy to
  prefs: []
  type: TYPE_NORMAL
- en: interpret equals signs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: create symbols from your variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use more mathematical (rather than standard Python) notation, for example the
    exponent operator can be parsed from `^` rather than having to use Python’s `**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you already have the equation in [`Eq`](../../modules/core.html#sympy.core.relational.Eq
    "sympy.core.relational.Eq") (equation) form, you can parse that string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: SymPy can also parse [LaTeX](https://www.latex-project.org/) into expressions
    using [`parse_latex()`](../../modules/parsing.html#sympy.parsing.latex.parse_latex
    "sympy.parsing.latex.parse_latex").
  prefs: []
  type: TYPE_NORMAL
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find a bug with these commands, please post the problem on the [SymPy
    mailing list](https://groups.google.com/g/sympy).
  prefs: []
  type: TYPE_NORMAL
