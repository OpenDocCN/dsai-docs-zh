# `numpy.corrcoef`

> 原文：[`numpy.org/doc/1.26/reference/generated/numpy.corrcoef.html`](https://numpy.org/doc/1.26/reference/generated/numpy.corrcoef.html)

```py
numpy.corrcoef(x, y=None, rowvar=True, bias=<no value>, ddof=<no value>, *, dtype=None)
```

返回 Pearson 积矩相关系数。

请参考`cov`文档获取更多细节。相关系数矩阵 *R* 与协方差矩阵 *C* 之间的关系为

\[R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} C_{jj} } }\]

*R* 的值介于 -1 到 1 之间，包括端点。

参数:

**x**array_like

包含多个变量和观测值的 1-D 或 2-D 数组。*x* 的每一行代表一个变量，每一列代表所有这些变量的单个观测值。也请参阅下方的 *rowvar*。

**y**array_like, 可选

一个包含额外变量和观测值的集合。*y* 的形状与 *x* 相同。

**rowvar**布尔值，可选

如果 *rowvar* 为 True（默认情况），则每行代表一个变量，列中包含观测值。否则，关系被转置：每列代表一个变量，而行包含观测值。

**bias**_NoValue, 可选

无效果，请勿使用。

自版本 1.10.0 弃用。

**ddof**_NoValue, 可选

无效果，请勿使用。

自版本 1.10.0 弃用。

**dtype**数据类型，可选

结果的数据类型。默认情况下，返回的数据类型至少具有`numpy.float64` 精度。

1.20 版本中推出。

返回:

**R**ndarray

变量的相关系数矩阵。

另请参见

`cov`

协方差矩阵

备注

由于浮点舍入的结果，最终数组可能不会是 Hermite 矩阵，对角线元素可能不会是 1，元素可能不满足不等式 abs(a) <= 1。为了改善这种情况，实部和虚部被剪切到区间[-1, 1]，但在复杂情况下帮助不大。

此函数接受但忽略参数 *bias* 和 *ddof*。这是为了向后兼容以前版本的函数。这些参数对函数的返回值没有影响，在这个版本和以前的 numpy 版本中可以安全地忽略。

示例

在此示例中，我们生成两个随机数组，`xarr` 和 `yarr`，并计算行-wise 和列-wise 的 Pearson 相关系数 `R`。由于默认情况下 `rowvar` 为真，我们首先找到 `xarr` 的变量之间的行-wise Pearson 相关系数。

```py
>>> import numpy as np
>>> rng = np.random.default_rng(seed=42)
>>> xarr = rng.random((3, 3))
>>> xarr
array([[0.77395605, 0.43887844, 0.85859792],
 [0.69736803, 0.09417735, 0.97562235],
 [0.7611397 , 0.78606431, 0.12811363]])
>>> R1 = np.corrcoef(xarr)
>>> R1
array([[ 1\.        ,  0.99256089, -0.68080986],
 [ 0.99256089,  1\.        , -0.76492172],
 [-0.68080986, -0.76492172,  1\.        ]]) 
```

如果我们增加另一组变量和观测值 `yarr`，我们可以计算 `xarr` 和 `yarr` 变量之间的按行 Pearson 相关系数。

```py
>>> yarr = rng.random((3, 3))
>>> yarr
array([[0.45038594, 0.37079802, 0.92676499],
 [0.64386512, 0.82276161, 0.4434142 ],
 [0.22723872, 0.55458479, 0.06381726]])
>>> R2 = np.corrcoef(xarr, yarr)
>>> R2
array([[ 1\.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,
 -0.99004057],
 [ 0.99256089,  1\.        , -0.76492172,  0.82502011, -0.97074098,
 -0.99981569],
 [-0.68080986, -0.76492172,  1\.        , -0.99507202,  0.89721355,
 0.77714685],
 [ 0.75008178,  0.82502011, -0.99507202,  1\.        , -0.93657855,
 -0.83571711],
 [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1\.        ,
 0.97517215],
 [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,
 1\.        ]]) 
```

最后，如果我们使用选项 `rowvar=False`，那么现在列会被视为变量，我们将在 `xarr` 和 `yarr` 中变量之间计算列-wise Pearson 相关系数。

```py
>>> R3 = np.corrcoef(xarr, yarr, rowvar=False)
>>> R3
array([[ 1\.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,
 0.22423734],
 [ 0.77598074,  1\.        , -0.92346708, -0.99923895, -0.58826587,
 -0.44069024],
 [-0.47458546, -0.92346708,  1\.        ,  0.93773029,  0.23297648,
 0.75137473],
 [-0.75078643, -0.99923895,  0.93773029,  1\.        ,  0.55627469,
 0.47536961],
 [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1\.        ,
 -0.46666491],
 [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,
 1\.        ]]) 
```
