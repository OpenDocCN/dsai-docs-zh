- en: scipy.integrate.nquad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Integration over multiple variables.
  prefs: []
  type: TYPE_NORMAL
- en: Wraps [`quad`](scipy.integrate.quad.html#scipy.integrate.quad "scipy.integrate.quad")
    to enable integration over multiple variables. Various options allow improved
    integration of discontinuous functions, as well as the use of weighted integration,
    and generally finer control of the integration process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**{callable, scipy.LowLevelCallable}'
  prefs: []
  type: TYPE_NORMAL
- en: The function to be integrated. Has arguments of `x0, ... xn`, `t0, ... tm`,
    where integration is carried out over `x0, ... xn`, which must be floats. Where
    `t0, ... tm` are extra arguments passed in args. Function signature should be
    `func(x0, x1, ..., xn, t0, t1, ..., tm)`. Integration is carried out in order.
    That is, integration over `x0` is the innermost integral, and `xn` is the outermost.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user desires improved integration performance, then *f* may be a [`scipy.LowLevelCallable`](scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") with one of the signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `n` is the number of variables and args. The `xx` array contains the coordinates
    and extra arguments. `user_data` is the data contained in the [`scipy.LowLevelCallable`](scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable").
  prefs: []
  type: TYPE_NORMAL
- en: '**ranges**iterable object'
  prefs: []
  type: TYPE_NORMAL
- en: Each element of ranges may be either a sequence of 2 numbers, or else a callable
    that returns such a sequence. `ranges[0]` corresponds to integration over x0,
    and so on. If an element of ranges is a callable, then it will be called with
    all of the integration arguments available, as well as any parametric arguments.
    e.g., if `func = f(x0, x1, x2, t0, t1)`, then `ranges[0]` may be defined as either
    `(a, b)` or else as `(a, b) = range0(x1, x2, t0, t1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**iterable object, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Additional arguments `t0, ... tn`, required by `func`, `ranges`, and `opts`.
  prefs: []
  type: TYPE_NORMAL
- en: '**opts**iterable object or dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Options to be passed to [`quad`](scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"). May be empty, a dict, or a sequence of dicts or functions
    that return a dict. If empty, the default options from scipy.integrate.quad are
    used. If a dict, the same options are used for all levels of integraion. If a
    sequence, then each element of the sequence corresponds to a particular integration.
    e.g., `opts[0]` corresponds to integration over `x0`, and so on. If a callable,
    the signature must be the same as for `ranges`. The available options together
    with their default values are:'
  prefs: []
  type: TYPE_NORMAL
- en: epsabs = 1.49e-08
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: epsrel = 1.49e-08
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: limit = 50
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: points = None
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: weight = None
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: wvar = None
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: wopts = None
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on these options, see [`quad`](scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad").
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Partial implementation of `full_output` from scipy.integrate.quad. The number
    of integrand function evaluations `neval` can be obtained by setting `full_output=True`
    when calling nquad.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**result**float'
  prefs: []
  type: TYPE_NORMAL
- en: The result of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: '**abserr**float'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum of the estimates of the absolute error in the various integration
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '**out_dict**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A dict containing additional information on the integration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`quad`](scipy.integrate.quad.html#scipy.integrate.quad "scipy.integrate.quad")'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D numerical integration
  prefs: []
  type: TYPE_NORMAL
- en: '[`dblquad`](scipy.integrate.dblquad.html#scipy.integrate.dblquad "scipy.integrate.dblquad"),
    [`tplquad`](scipy.integrate.tplquad.html#scipy.integrate.tplquad "scipy.integrate.tplquad")'
  prefs: []
  type: TYPE_NORMAL
- en: double and triple integrals
  prefs: []
  type: TYPE_NORMAL
- en: '[`fixed_quad`](scipy.integrate.fixed_quad.html#scipy.integrate.fixed_quad "scipy.integrate.fixed_quad")'
  prefs: []
  type: TYPE_NORMAL
- en: fixed-order Gaussian quadrature
  prefs: []
  type: TYPE_NORMAL
- en: '[`quadrature`](scipy.integrate.quadrature.html#scipy.integrate.quadrature "scipy.integrate.quadrature")'
  prefs: []
  type: TYPE_NORMAL
- en: adaptive Gaussian quadrature
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: For valid results, the integral must converge; behavior for divergent integrals
    is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Details of QUADPACK level routines**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`nquad`](#scipy.integrate.nquad "scipy.integrate.nquad") calls routines from
    the FORTRAN library QUADPACK. This section provides details on the conditions
    for each routine to be called and a short description of each routine. The routine
    called depends on *weight*, *points* and the integration limits *a* and *b*.'
  prefs: []
  type: TYPE_NORMAL
- en: '| QUADPACK routine | *weight* | *points* | infinite bounds |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| qagse | None | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| qagie | None | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| qagpe | None | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| qawoe | ‘sin’, ‘cos’ | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| qawfe | ‘sin’, ‘cos’ | No | either *a* or *b* |'
  prefs: []
  type: TYPE_TB
- en: '| qawse | ‘alg*’ | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| qawce | ‘cauchy’ | No | No |'
  prefs: []
  type: TYPE_TB
- en: The following provides a short description from [[1]](#rf4c41c8133f1-1) for
    each routine.
  prefs: []
  type: TYPE_NORMAL
- en: qagse
  prefs: []
  type: TYPE_NORMAL
- en: is an integrator based on globally adaptive interval subdivision in connection
    with extrapolation, which will eliminate the effects of integrand singularities
    of several types.
  prefs: []
  type: TYPE_NORMAL
- en: qagie
  prefs: []
  type: TYPE_NORMAL
- en: handles integration over infinite intervals. The infinite range is mapped onto
    a finite interval and subsequently the same strategy as in `QAGS` is applied.
  prefs: []
  type: TYPE_NORMAL
- en: qagpe
  prefs: []
  type: TYPE_NORMAL
- en: serves the same purposes as QAGS, but also allows the user to provide explicit
    information about the location and type of trouble-spots i.e. the abscissae of
    internal singularities, discontinuities and other difficulties of the integrand
    function.
  prefs: []
  type: TYPE_NORMAL
- en: qawoe
  prefs: []
  type: TYPE_NORMAL
- en: is an integrator for the evaluation of \(\int^b_a \cos(\omega x)f(x)dx\) or
    \(\int^b_a \sin(\omega x)f(x)dx\) over a finite interval [a,b], where \(\omega\)
    and \(f\) are specified by the user. The rule evaluation component is based on
    the modified Clenshaw-Curtis technique
  prefs: []
  type: TYPE_NORMAL
- en: An adaptive subdivision scheme is used in connection with an extrapolation procedure,
    which is a modification of that in `QAGS` and allows the algorithm to deal with
    singularities in \(f(x)\).
  prefs: []
  type: TYPE_NORMAL
- en: qawfe
  prefs: []
  type: TYPE_NORMAL
- en: calculates the Fourier transform \(\int^\infty_a \cos(\omega x)f(x)dx\) or \(\int^\infty_a
    \sin(\omega x)f(x)dx\) for user-provided \(\omega\) and \(f\). The procedure of
    `QAWO` is applied on successive finite intervals, and convergence acceleration
    by means of the \(\varepsilon\)-algorithm is applied to the series of integral
    approximations.
  prefs: []
  type: TYPE_NORMAL
- en: qawse
  prefs: []
  type: TYPE_NORMAL
- en: 'approximate \(\int^b_a w(x)f(x)dx\), with \(a < b\) where \(w(x) = (x-a)^{\alpha}(b-x)^{\beta}v(x)\)
    with \(\alpha,\beta > -1\), where \(v(x)\) may be one of the following functions:
    \(1\), \(\log(x-a)\), \(\log(b-x)\), \(\log(x-a)\log(b-x)\).'
  prefs: []
  type: TYPE_NORMAL
- en: The user specifies \(\alpha\), \(\beta\) and the type of the function \(v\).
    A globally adaptive subdivision strategy is applied, with modified Clenshaw-Curtis
    integration on those subintervals which contain *a* or *b*.
  prefs: []
  type: TYPE_NORMAL
- en: qawce
  prefs: []
  type: TYPE_NORMAL
- en: compute \(\int^b_a f(x) / (x-c)dx\) where the integral must be interpreted as
    a Cauchy principal value integral, for user specified \(c\) and \(f\). The strategy
    is globally adaptive. Modified Clenshaw-Curtis integration is used on those intervals
    containing the point \(x = c\).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Piessens, Robert; de Doncker-Kapenga, Elise; Überhuber, Christoph W.; Kahaner,
    David (1983). QUADPACK: A subroutine package for automatic integration. Springer-Verlag.
    ISBN 978-3-540-12553-2.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Calculate
  prefs: []
  type: TYPE_NORMAL
- en: \[\int^{1}_{-0.15} \int^{0.8}_{0.13} \int^{1}_{-1} \int^{1}_{0} f(x_0, x_1,
    x_2, x_3) \,dx_0 \,dx_1 \,dx_2 \,dx_3 ,\]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}f(x_0, x_1, x_2, x_3) = \begin{cases} x_0^2+x_1 x_2-x_3^3+ \sin{x_0}+1
    & (x_0-0.2 x_3-0.5-0.25 x_1 > 0) \\ x_0^2+x_1 x_2-x_3^3+ \sin{x_0}+0 & (x_0-0.2
    x_3-0.5-0.25 x_1 \leq 0) \end{cases} .\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calculate
  prefs: []
  type: TYPE_NORMAL
- en: \[\int^{t_0+t_1+1}_{t_0+t_1-1} \int^{x_2+t_0^2 t_1^3+1}_{x_2+t_0^2 t_1^3-1}
    \int^{t_0 x_1+t_1 x_2+1}_{t_0 x_1+t_1 x_2-1} f(x_0,x_1, x_2,t_0,t_1) \,dx_0 \,dx_1
    \,dx_2,\]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}f(x_0, x_1, x_2, t_0, t_1) = \begin{cases} x_0 x_2^2 + \sin{x_1}+2
    & (x_0+t_1 x_1-t_0 > 0) \\ x_0 x_2^2 +\sin{x_1}+1 & (x_0+t_1 x_1-t_0 \leq 0) \end{cases}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: and \((t_0, t_1) = (0, 1)\) .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
