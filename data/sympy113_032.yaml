- en: Find the Roots of a Polynomial Algebraically or Numerically
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代数或数值上找到多项式的根
- en: Original text：[https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html](https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html](https://docs.sympy.org/latest/guides/solving/find-roots-polynomial.html)
- en: Use SymPy to find the roots of a univariate polynomial algebraically. For example,
    finding the roots of \(ax^2 + bx + c\) for \(x\) yields \(x = \frac{-b\pm\sqrt{b^2
    - 4ac}}{2a}\).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SymPy 代数上找到一元多项式的根。例如，对于 \(ax^2 + bx + c\) 找到 \(x\) 的根为 \(x = \frac{-b\pm\sqrt{b^2
    - 4ac}}{2a}\)。
- en: Alternatives to Consider
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑的替代方案
- en: If you need a numeric (rather than algebraic) solution, you can use either
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要数值（而不是代数）解，可以使用以下任一种方法
- en: NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)")
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NumPy 的 [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(在 NumPy v1.26)") '
- en: SciPy’s [`root()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "(in SciPy v1.13.1)")
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SciPy 的 [`root()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html#scipy.optimize.root
    "(在 SciPy v1.13.1)") '
- en: If you need to solve systems of polynomial equations algebraically, use [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果你需要代数上解多项式方程组，请使用 [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") '
- en: Example of Finding the Roots of a Polynomial Algebraically
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数上找到多项式根的例子
- en: 'Here is an example of finding the roots of a polynomial algebraically:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代数上找到多项式根的例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example reproduces the [quadratic formula](https://en.wikipedia.org/wiki/Quadratic_formula).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例重现了[二次公式](https://en.wikipedia.org/wiki/Quadratic_formula)。
- en: Functions to Find the Roots of a Polynomial
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到多项式根的函数
- en: 'There are several functions that you can use to find the roots of a polynomial:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个函数可以用来找到多项式的根：
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") is a general solving function which can find roots,
    though is less efficient than [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") and is the only function in this list
    that does not convey the multiplicity of roots; [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") also works on [non-polynomial equations](solve-equation-algebraically.html)
    and [systems of non-polynomial equations](solve-system-of-equations-algebraically.html)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 是一个通用的解函数，可以找到根，但效率低于 [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") ，并且是此列表中唯一不传达根的重数的函数；[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 也适用于[非多项式方程](solve-equation-algebraically.html)和[非多项式方程组](solve-system-of-equations-algebraically.html)'
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") computes the symbolic roots of a univariate polynomial;
    will fail for most high-degree polynomials (five or greater)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") 计算一元多项式的符号根；对于大多数高次多项式（五次或更高次）将失败。'
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") computes numerical approximations of the roots
    of any polynomial whose coefficients can be numerically evaluated, whether the
    coefficients are rational or irrational'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 计算可以数值评估系数的任何多项式的数值近似根，无论系数是有理数还是无理数。'
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can represent all the roots exactly of a polynomial
    of arbitrarily large degree, as long as the coefficients are rational numbers.
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can avoid both ill-conditioning and returning
    spurious complex parts because it uses a more exact, but much slower, numerical
    algorithm based on isolating intervals. The following two functions use [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") so they have the same properties:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 可以精确表示任意大次数多项式的所有根，只要系数是有理数。[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 可以避免病态条件和返回虚假的复数部分，因为它使用基于隔离区间的更精确但更慢的数值算法。以下两个函数使用
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")，因此它们具有相同的属性：'
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") can find all the real roots exactly of a polynomial
    of arbitrarily large degree; because it finds only the real roots, it can be more
    efficient than functions that find all roots.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 可以精确找到任意大次数多项式的所有实根；因为它只找到实根，所以它可能比找到所有根的函数更有效。'
- en: '[`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") can find all the roots exactly of a polynomial
    of arbitrarily large degree'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") 可以精确找到任意大次数多项式的所有根。'
- en: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") factors a polynomial into irreducibles and can
    reveal that roots lie in the coefficient ring'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") 将多项式因式分解为不可约多项式，并且可以显示根位于系数环中'
- en: Each will be used on this page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个都将在本页上使用。
- en: Guidance
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指导
- en: Refer to [Include the Variable to be Solved for in the Function Call](solving-guidance.html#include-the-variable-to-be-solved-for-in-the-function-call)
    and [Use Exact Values](solving-guidance.html#use-exact-values).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 参考 [在函数调用中包含要解决的变量](solving-guidance.html#include-the-variable-to-be-solved-for-in-the-function-call)
    和 [使用精确值](solving-guidance.html#use-exact-values)。
- en: Find the Roots of a Polynomial
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到多项式的根
- en: You can find the roots of a polynomial algebraically in several ways. The one
    to use depends on whether you
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式代数地找到多项式的根。使用哪一种取决于你是否
- en: want an algebraic or numeric answer
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要代数或数值答案
- en: want the multiplicity of each root (how many times each root is a solution).
    In the `expression` below representing \((x+2)^2(x-3)\), the root -2 has a multiplicity
    of two because \(x+2\) is squared, whereas 3 has a multiplicity of one because
    \(x-3\) has no exponent. Similarly, for the `symbolic` expression, the root \(-a\)
    has a multiplicity of two and the root \(b\) has a multiplicity of one.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要每个根的重数（每个根是解的次数）。在表示为 \((x+2)^2(x-3)\) 的 `expression` 下，根 -2 的重数为二，因为 \(x+2\)
    被平方，而根 3 的重数为一，因为 \(x-3\) 没有指数。类似地，在 `symbolic` 表达式中，根 \(-a\) 的重数为二，根 \(b\) 的重数为一。
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Algebraic Solution Without Root Multiplicities
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数解决方案不考虑根重数。
- en: 'You can use SymPy’s standard [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") function, though it will not return the multiplicity
    of roots:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用SymPy的标准 [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 函数，尽管它不会返回根的重数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will first try using [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots"); if that doesn’t work, it will try using [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots"). For cubics (third-degree polynomials)
    and quartics (fourth-degree polynomials), that means that [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will use radical formulae from roots rather than
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") even if RootOf is possible. The cubic and quartic
    formulae often give very complex expressions that are not useful in practice.
    As a result, you may want to set the [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") parameter `cubics` or `quartics` to `False` to
    return [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") results:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")首先尝试使用[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots")；如果这不起作用，它将尝试使用[`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots")。对于三次（三次多项式）和四次（四次多项式），这意味着[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")将使用来自根的根式公式，而不是[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")即使RootOf是可能的。三次和四次公式通常给出在实际中无用的非常复杂的表达式。因此，您可能希望将[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")参数`cubics`或`quartics`设置为`False`以返回[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")结果：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Writing the first root from [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") in standard mathematical notation emphasizes how
    complex it is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准数学符号中写出[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")的第一个根强调了它的复杂性：
- en: \[- \frac{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}
    + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}{2} - \frac{\sqrt{- 2 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}} - \frac{2}{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}}} + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}
    - \frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}}{2}\]
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: \[- \frac{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}
    + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}{2} - \frac{\sqrt{- 2 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}} - \frac{2}{\sqrt{\frac{2}{3 \sqrt[3]{\frac{1}{16}
    + \frac{\sqrt{687} i}{144}}} + 2 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}
    - \frac{2}{3 \sqrt[3]{\frac{1}{16} + \frac{\sqrt{687} i}{144}}}}}{2}\]
- en: Further, there is no general radical formula for quintics (fifth degree) or
    higher polynomials, so their [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") representations may be the best option.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于五次（五次多项式）或更高次多项式，没有一般的根式公式，因此它们的[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")表示可能是最佳选项。
- en: Refer to [Solve an Equation Algebraically](solve-equation-algebraically.html)
    for more about using [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[代数解方程](solve-equation-algebraically.html)以了解更多关于使用[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")的信息。
- en: Algebraic Solution With Root Multiplicities
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数解与根的重数
- en: '`roots`'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`roots`'
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") can give explicit expressions for the roots of
    polynomials that have symbolic coefficients (that is, if there are symbols in
    the coefficients) if [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") does not reveal them. However, it may fail for
    some polynomials. Here are examples of [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots"):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots")可以为具有符号系数的多项式的根给出显式表达式（即如果系数中有符号）。如果[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor")没有揭示它们，则可能会失败。以下是[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots")的示例：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It returns results as a dictionary, where the key is the root (for example,
    -2) and the value is the multiplicity of that root (for example, 2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它以字典形式返回结果，其中键是根（例如，-2），值是该根的重数（例如，2）。
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") function uses a combination of techniques (factorization,
    decomposition, radical formulae) to find expressions in radicals if possible for
    the roots. When it can find some radical expressions for the roots, it returns
    them along with their multiplicity. This function will fail for most high-degree
    polynomials (five or greater) because they do not have radical solutions, and
    there is no guarantee that they have closed-form solutions at all, as explained
    by the [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") 函数使用多种技术（因式分解、分解、根式公式）寻找根的表达式，如果可能的话返回根的根式表达式。当它能找到一些根的根式表达式时，它会返回它们及其重数。对于大多数高次多项式（五次或更高次），此函数将失败，因为它们没有根式解，并且不能保证它们根本上有闭合形式的解，这与[阿贝尔-鲁菲尼定理](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)的解释相符。'
- en: Factor the Equation
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 因式分解方程
- en: 'A different approach is to factor a polynomial using [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor"), which does not give the roots directly but can
    give you simpler expressions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor")来因式分解多项式，它不直接给出根，但可以给出更简单的表达式：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") can also factorize a polynomial in a given [polynomial
    ring](../../modules/polys/basics.html#polys-ring) which can reveal roots lie in
    the coefficient ring. For example, if the polynomial has rational coefficients,
    then [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") will reveal any rational roots. If the coefficients
    are polynomials involving, for example, symbol \(a\) with rational coefficients
    then any roots that are polynomial functions of \(a\) with rational coefficients
    will be revealed. In this example, [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") reveals that \(x = a^2\) and \(x = -a^3 - a\)
    are roots:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") 也可以因式分解给定[多项式环](../../modules/polys/basics.html#polys-ring)，这可以揭示根位于系数环中的信息。例如，如果多项式具有有理系数，则
    [`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")
    将显示任何有理根。如果系数是涉及符号 \(a\) 的多项式，例如具有有理系数的多项式函数，则将显示与 \(a\) 有关的多项式函数的任何根。在此示例中，[`factor()`](../../modules/polys/reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") 显示 \(x = a^2\) 和 \(x = -a^3 - a\) 是根：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Exact Numeric Solution With Root Multiplicities
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精确数值解与根重数
- en: '`real_roots`'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`real_roots`'
- en: If the roots to your polynomial are real, using [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") ensures that only real (not complex or imaginary)
    roots will be returned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多项式的根是实数，使用[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 确保只返回实数根（不包括复数或虚数）。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") calls [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf"), so for equations whose roots are all real,
    you can get the same results by iterating over the number of roots of your equation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 调用 [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")，因此对于所有根为实数的方程，通过迭代方程的根数，可以得到相同的结果：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Approximate Numeric Solution With Root Multiplicities
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近似数值解与根重数
- en: '`nroots`'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`nroots`'
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") gives an approximate numerical approximation to
    the roots of a polynomial. This example demonstrates that it can include numerical
    noise, for example a (negligible) imaginary component in what should be a real
    root:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 给出多项式根的近似数值解。此示例表明它可能包含数值噪声，例如本应是实根的部分（可忽略的）虚部分：'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want numeric approximations of the real roots, but you want to know
    exactly which roots are real, then the best method is [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") with [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实根的数值近似，但又想确切知道哪些根是实数，那么最好的方法是使用 [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 结合 [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf")：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") is analogous to NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)") function. Usually the difference between these two is that
    [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots "sympy.polys.polytools.nroots")
    is more accurate but slower.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 类似于 NumPy 的 [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(在 NumPy v1.26 中)") 函数。通常这两者的区别在于 [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 更精确但速度较慢。'
- en: 'A major advantage of [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") is that it can compute numerical approximations
    of the roots of any polynomial whose coefficients can be numerically evaluated
    with [`evalf()`](../../modules/core.html#module-sympy.core.evalf "sympy.core.evalf")
    (that is, they do not have free symbols). Contrarily, symbolic solutions may not
    be possible for higher-order (fifth or greater) polynomials as explained by the
    [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).
    Even if closed-form solutions are available, they may have so many terms that
    they are not useful in practice. You may therefore want to use [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") to find approximate numeric solutions even if
    closed-form symbolic solutions are available. For example, the closed-form roots
    of a fourth-order (quartic) polynomial may be rather complicated:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 的一个主要优势是它可以计算任何多项式的数值近似根，只要其系数可以通过 [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf") 进行数值评估（即它们没有自由符号）。相反，符号解可能对于高阶（五阶或更高阶）多项式不可能，正如 [阿贝尔-鲁菲尼定理](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)
    所解释的那样。即使存在闭合形式解，它们可能有太多项以至于在实际中不太有用。因此，即使存在闭合形式的符号解，你可能还是会选择使用 [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 来找到近似的数值解。例如，四阶（四次）多项式的闭合形式根可能会相当复杂：'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'so you may prefer an approximate numerical solution:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能更喜欢一个近似数值解：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") can fail sometimes for polynomials that are numerically
    ill conditioned, for example [Wilkinson’s polynomial](https://en.wikipedia.org/wiki/Wilkinson%27s_polynomial).
    Using [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") and [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf") as described in [Numerically Evaluate CRootOf Roots](#numerically-evaluate-crootof-roots)
    can avoid both ill-conditioning and returning spurious complex parts because it
    uses a more exact, but much slower, numerical algorithm based on isolating intervals.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 有时对于数值条件不佳的多项式可能会失败，例如 [威尔金森多项式](https://en.wikipedia.org/wiki/Wilkinson%27s_polynomial)。使用
    [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 和 [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf")，如 [数值评估CRootOf的根](#numerically-evaluate-crootof-roots) 中描述的，可以避免由于使用更精确但速度较慢的数值算法（基于孤立区间）而导致的病态和返回虚假复数部分。'
- en: Complex Roots
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数根
- en: 'For complex roots, similar functions can be used, for example [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复数根，可以使用类似的函数，例如 [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the constants are symbolic, you may need to specify their domain for SymPy
    to recognize that the solutions are not real. For example, specifying that \(a\)
    is positive leads to imaginary roots:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常数是符号性的，你可能需要指定它们的域以便于 SymPy 认识到解不是实数。例如，指定 \(a\) 为正会导致虚数根：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") will also find imaginary or complex roots:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") 也可以找到虚根或复根：'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") will also return complex roots:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 也会返回复杂根：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") will return only the real roots.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 将仅返回实根。'
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An advantage of [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") is that it can be more efficient than generating
    all the roots: [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") can be slow for complex roots.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 的优点在于，它可能比生成所有根更有效：[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 对于复杂根可能会比较慢。'
- en: 'If you make the expression into a polynomial class [`Poly`](../../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly"), you can use its [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") method to find the roots:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将表达式转换为多项式类 [`Poly`](../../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")，则可以使用其 [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") 方法查找根：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Use the Solution Result
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用解决方案结果
- en: The way to extract solutions from the result depends on the form of the result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中提取解的方式取决于结果的形式。
- en: List (`all_roots`, `real_roots`, `nroots`)
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表（`all_roots`, `real_roots`, `nroots`）
- en: 'You can use standard Python list traversal techniques such as looping. Here,
    we substitute each root into the expression to verify that the result is \(0\):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的 Python 列表遍历技术进行遍历。在这里，我们将每个根代入表达式中以验证结果为 \(0\)：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: List of dictionaries (`solve`)
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典列表（`solve`）
- en: Refer to [Use the Solution Result](solve-equation-algebraically.html#use-the-solution-result).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 [使用解决方案结果](solve-equation-algebraically.html#use-the-solution-result)。
- en: Dictionary (`roots`)
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典（`roots`）
- en: 'You can use standard Python list traversal techniques such as looping through
    the keys and values in a dictionary. Here we print the value and multiplicity
    of each root:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的 Python 列表遍历技术，比如遍历字典中的键和值。这里我们打印每个根的值和重复次数：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Expression (`factor`)
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式（`factor`）
- en: 'You can manipulate an algebraic expression using various SymPy techniques,
    for example substituting in a symbolic or numeric value for \(x\):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用各种 SymPy 技术来操作代数表达式，例如用符号或数值替换 \(x\)：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tradeoffs
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折衷方案
- en: Mathematical Exactness, Completeness of List of Roots, and Speed
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学精确性、根列表的完整性和速度
- en: 'Consider the high-order polynomial \(x^5 - x + 1 = 0\). [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") returns numerical approximations to all five roots:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑高阶多项式 \(x^5 - x + 1 = 0\)。[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots") 返回所有五个根的数值近似：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") can sometimes return only a subset of the roots
    or nothing if it can’t express any roots in radicals. In this case, it returns
    no roots (an empty set):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") 有时可能只返回部分根，或者如果无法用根式表示任何根，则返回空集合：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But if you set the flag `strict=True`, [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") will inform you that all roots cannot be returned:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您设置标志 `strict=True`，[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") 将告知您无法返回所有根：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Get All Roots, Perhaps Implicitly
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取所有根，也许是隐含的
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will return all five roots as `CRootOf` ([`ComplexRootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")) class members:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 将作为 `CRootOf`（[`ComplexRootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf")）类成员返回所有五个根'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where the second argument in each `CRootOf` is the index of the root.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `CRootOf` 中的第二个参数是根的索引。
- en: Numerically Evaluate `CRootOf` Roots
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数值评估 `CRootOf` 根
- en: 'You can then numerically evaluate those `CRootOf` roots using `n` from [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 [`evalf()`](../../modules/core.html#module-sympy.core.evalf "sympy.core.evalf")
    对那些 `CRootOf` 根进行数值评估：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are only interested in the sole real root, it is faster to use [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") because it will not attempt to find the complex
    roots:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对唯一的实根感兴趣，使用 [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 更快，因为它不会尝试找到复数根：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Representing Roots
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示根
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf"), [`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots"), and [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") can find all the roots exactly of a polynomial
    of arbitrarily large degree despite the [Abel-Ruffini theorem](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem).
    Those functions allow the roots to be categorized precisely and manipulated symbolically.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf")、[`real_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.real_roots
    "sympy.polys.polytools.real_roots") 和 [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") 可以精确地找到多项式的所有根，尽管存在 [Abel-Ruffini 定理](https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem)。这些函数允许精确地分类和符号操作根。'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that the roots have been found exactly, their properties can be determined
    free of numerical noise. For example, we can tell whether roots are real or not.
    If we request the [`conjugate()`](../../modules/core.html#sympy.core.expr.Expr.conjugate
    "sympy.core.expr.Expr.conjugate") (same real part and imaginary part with opposite
    sign) of a root, for example `r1`, and that is exactly equal to another root `r2`,
    that root `r2` will be returned:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经精确找到了根，可以确定它们的属性而不受数值噪声的影响。例如，我们可以判断根是实数还是虚数。例如，如果我们请求根 `r1` 的 [`conjugate()`](../../modules/core.html#sympy.core.expr.Expr.conjugate
    "sympy.core.expr.Expr.conjugate")（实部相同，虚部相反），并且这恰好等于另一个根 `r2`，则根 `r2` 将被返回：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") will also give the complex roots where possible
    but it is less efficient than using [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") directly.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 在可能的情况下也会给出复数根，但比直接使用 [`all_roots()`](../../modules/polys/reference.html#sympy.polys.polytools.Poly.all_roots
    "sympy.polys.polytools.Poly.all_roots") 效率低。'
- en: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") exactly represents the root in a way that can
    be manipulated symbolically, and computed to arbitrary precision. The [`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") representation makes it possible to precisely:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 以可以符号操作和任意精度计算的方式精确表示根。[`RootOf()`](../../modules/polys/reference.html#sympy.polys.rootoftools.RootOf
    "sympy.polys.rootoftools.RootOf") 的表示使得能够精确地：'
- en: Compute all roots of a polynomial with exact rational coefficients.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算具有精确有理系数的多项式的所有根。
- en: Decide exactly the multiplicity of every root.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定每个根的多重性。
- en: Determine exactly whether roots are real or not.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确确定根是否为实数。
- en: Order the real and complex roots precisely.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确地排序实根和复根。
- en: Know which roots are complex conjugate pairs of each other.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道哪些根是复共轭对。
- en: Determine precisely which roots are rational vs irrational.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确切确定哪些根是有理数，哪些是无理数。
- en: Represent every possible algebraic number exactly.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确地表示每个可能的代数数。
- en: The other numerical methods such NumPy’s [`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(in NumPy v1.26)"), [`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots"), and [`nsolve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve
    "sympy.solvers.solvers.nsolve") cannot do any of these things robustly, if at
    all. Similarly, when numerically evaluated using [`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf"), the radical expressions returned by [`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") or [`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots") cannot do these things robustly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数值方法如 NumPy 的[`roots()`](https://numpy.org/doc/stable/reference/generated/numpy.roots.html#numpy.roots
    "(在 NumPy v1.26 中)")，[`nroots()`](../../modules/polys/reference.html#sympy.polys.polytools.nroots
    "sympy.polys.polytools.nroots")和[`nsolve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve
    "sympy.solvers.solvers.nsolve")在所有情况下都无法稳健地执行这些操作。同样地，当使用[`evalf()`](../../modules/core.html#module-sympy.core.evalf
    "sympy.core.evalf")进行数值评估时，由[`solve()`](../../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")或[`roots()`](../../modules/polys/reference.html#sympy.polys.polyroots.roots
    "sympy.polys.polyroots.roots")返回的根式表达式也无法稳健地执行这些操作。
- en: Not All Equations Can Be Solved
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并非所有方程都能求解
- en: Equations With No Closed-Form Solution
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有闭合形式解的方程
- en: As mentioned above, higher-order polynomials (fifth or greater) are unlikely
    to have closed-form solutions, so you may have to represent them using, for example,
    [`RootOf` as described above](#representing-roots), or use a numerical method
    such as [`nroots` as described above](#nroots).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，高阶多项式（五次或更高次）不太可能有闭合形式的解，因此你可能需要用例如[`RootOf` 如上所述](#representing-roots)，或使用数值方法如[`nroots`
    如上所述](#nroots)来表示它们。
- en: Report a Bug
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告错误
- en: If you encounter a bug with these commands, please post the problem on the [SymPy
    mailing list](https://groups.google.com/g/sympy). Until the issue is resolved,
    you can use another of the [Functions to Find the Roots of a Polynomial](#functions-to-find-the-roots-of-a-polynomial)
    or try one of the [Alternatives to Consider](#alternatives-to-consider).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用这些命令时遇到错误，请在[SymPy 邮件列表](https://groups.google.com/g/sympy)上发布问题。在问题得到解决之前，您可以使用另一个[寻找多项式根的函数](#functions-to-find-the-roots-of-a-polynomial)或尝试[考虑的替代方案之一](#alternatives-to-consider)。
