- en: Multidimensional image processing (scipy.ndimage)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Image processing and analysis are generally seen as operations on 2-D arrays
    of values. There are, however, a number of fields where images of higher dimensionality
    must be analyzed. Good examples of these are medical imaging and biological imaging.
    [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy "(in NumPy
    v2.0.dev0)") is suited very well for this type of applications due to its inherent
    multidimensional nature. The [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") packages provides a number of general image processing and analysis
    functions that are designed to operate with arrays of arbitrary dimensionality.
    The packages currently includes: functions for linear and non-linear filtering,
    binary morphology, B-spline interpolation, and object measurements.  ## Properties
    shared by all functions'
  prefs: []
  type: TYPE_NORMAL
- en: All functions share some common properties. Notably, all functions allow the
    specification of an output array with the *output* argument. With this argument,
    you can specify an array that will be changed in-place with the result with the
    operation. In this case, the result is not returned. Usually, using the *output*
    argument is more efficient, since an existing array is used to store the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of arrays returned is dependent on the type of operation, but it is,
    in most cases, equal to the type of the input. If, however, the *output* argument
    is used, the type of the result is equal to the type of the specified output argument.
    If no output argument is given, it is still possible to specify what the result
    of the output should be. This is done by simply assigning the desired [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(in NumPy v2.0.dev0)") type object to the output argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]  ## Filter functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions described in this section all perform some type of spatial filtering
    of the input array: the elements in the output are some function of the values
    in the neighborhood of the corresponding input element. We refer to this neighborhood
    of elements as the filter kernel, which is often rectangular in shape but may
    also have an arbitrary footprint. Many of the functions described below allow
    you to define the footprint of the kernel by passing a mask through the *footprint*
    parameter. For example, a cross-shaped kernel can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, the origin of the kernel is at the center calculated by dividing the
    dimensions of the kernel shape by two. For instance, the origin of a 1-D kernel
    of length three is at the second element. Take, for example, the correlation of
    a 1-D array with a filter of length 3 consisting of ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is convenient to choose a different origin for the kernel. For
    this reason, most functions support the *origin* parameter, which gives the origin
    of the filter relative to its center. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect is a shift of the result towards the left. This feature will not
    be needed very often, but it may be useful, especially for filters that have an
    even size. A good example is the calculation of backward and forward differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also have calculated the forward difference as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, using the origin parameter instead of a larger kernel is more efficient.
    For multidimensional kernels, *origin* can be a number, in which case the origin
    is assumed to be equal along all axes, or a sequence giving the origin along each
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the output elements are a function of elements in the neighborhood of
    the input elements, the borders of the array need to be dealt with appropriately
    by providing the values outside the borders. This is done by assuming that the
    arrays are extended beyond their boundaries according to certain boundary conditions.
    In the functions described below, the boundary conditions can be selected using
    the *mode* parameter, which must be a string with the name of the boundary condition.
    The following boundary conditions are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **mode** | **description** | **example** |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “nearest” | use the value at the boundary | [1 2 3]->[1 1 2 3 3] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “wrap” | periodically replicate the array | [1 2 3]->[3 1 2 3 1] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “reflect” | reflect the array at the boundary | [1 2 3]->[1 1 2 3 3] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “mirror” | mirror the array at the boundary | [1 2 3]->[2 1 2 3 2] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “constant” | use a constant value, default is 0.0 | [1 2 3]->[0 1 2 3 0]
    |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'The following synonyms are also supported for consistency with the interpolation
    routines:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **mode** | **description** |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “grid-constant” | equivalent to “constant”* |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “grid-mirror” | equivalent to “reflect” |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| “grid-wrap” | equivalent to “wrap” |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '* “grid-constant” and “constant” are equivalent for filtering operations, but
    have different behavior in interpolation functions. For API consistency, the filtering
    functions accept either name.'
  prefs: []
  type: TYPE_NORMAL
- en: The “constant” mode is special since it needs an additional parameter to specify
    the constant value that should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note that modes mirror and reflect differ only in whether the sample at the
    boundary is repeated upon reflection. For mode mirror, the point of symmetry is
    exactly at the final sample, so that value is not repeated. This mode is also
    known as whole-sample symmetric since the point of symmetry falls on the final
    sample. Similarly, reflect is often referred to as half-sample symmetric as the
    point of symmetry is half a sample beyond the array boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to implement such boundary conditions would be to copy the data
    to a larger array and extend the data at the borders according to the boundary
    conditions. For large arrays and large filter kernels, this would be very memory
    consuming, and the functions described below, therefore, use a different approach
    that does not require allocating large temporary buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Correlation and convolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`correlate1d`](../reference/generated/scipy.ndimage.correlate1d.html#scipy.ndimage.correlate1d
    "scipy.ndimage.correlate1d") function calculates a 1-D correlation along the given
    axis. The lines of the array along the given axis are correlated with the given
    *weights*. The *weights* parameter must be a 1-D sequence of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function [`correlate`](../reference/generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate
    "scipy.ndimage.correlate") implements multidimensional correlation of the input
    array with a given kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`convolve1d`](../reference/generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d
    "scipy.ndimage.convolve1d") function calculates a 1-D convolution along the given
    axis. The lines of the array along the given axis are convoluted with the given
    *weights*. The *weights* parameter must be a 1-D sequence of numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function [`convolve`](../reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve
    "scipy.ndimage.convolve") implements multidimensional convolution of the input
    array with a given kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A convolution is essentially a correlation after mirroring the kernel. As a
    result, the *origin* parameter behaves differently than in the case of a correlation:
    the results is shifted in the opposite direction.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### Smoothing filters'
  prefs: []
  type: TYPE_NORMAL
- en: The [`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d") function implements a 1-D Gaussian filter.
    The standard deviation of the Gaussian filter is passed through the parameter
    *sigma*. Setting *order* = 0 corresponds to convolution with a Gaussian kernel.
    An order of 1, 2, or 3 corresponds to convolution with the first, second, or third
    derivatives of a Gaussian. Higher-order derivatives are not implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") function implements a multidimensional Gaussian
    filter. The standard deviations of the Gaussian filter along each axis are passed
    through the parameter *sigma* as a sequence or numbers. If *sigma* is not a sequence
    but a single number, the standard deviation of the filter is equal along all directions.
    The order of the filter can be specified separately for each axis. An order of
    0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds
    to convolution with the first, second, or third derivatives of a Gaussian. Higher-order
    derivatives are not implemented. The *order* parameter must be a number, to specify
    the same order for all axes, or a sequence of numbers to specify a different order
    for each axis. The example below shows the filter applied on test data with different
    values of *sigma*. The *order* parameter is kept at 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![" "](../Images/1707e05f56813d14ba8e33db91ee768a.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The multidimensional filter is implemented as a sequence of 1-D Gaussian filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    for output types with a lower precision, the results may be imprecise because
    intermediate results may be stored with insufficient precision. This can be prevented
    by specifying a more precise output type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`uniform_filter1d`](../reference/generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d
    "scipy.ndimage.uniform_filter1d") function calculates a 1-D uniform filter of
    the given *size* along the given axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`uniform_filter`](../reference/generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter
    "scipy.ndimage.uniform_filter") implements a multidimensional uniform filter.
    The sizes of the uniform filter are given for each axis as a sequence of integers
    by the *size* parameter. If *size* is not a sequence, but a single number, the
    sizes along all axes are assumed to be equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The multidimensional filter is implemented as a sequence of 1-D uniform filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    for output types with a lower precision, the results may be imprecise because
    intermediate results may be stored with insufficient precision. This can be prevented
    by specifying a more precise output type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Filters based on order statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`minimum_filter1d`](../reference/generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d
    "scipy.ndimage.minimum_filter1d") function calculates a 1-D minimum filter of
    the given *size* along the given axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`maximum_filter1d`](../reference/generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d
    "scipy.ndimage.maximum_filter1d") function calculates a 1-D maximum filter of
    the given *size* along the given axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`minimum_filter`](../reference/generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter
    "scipy.ndimage.minimum_filter") function calculates a multidimensional minimum
    filter. Either the sizes of a rectangular kernel or the footprint of the kernel
    must be provided. The *size* parameter, if provided, must be a sequence of sizes
    or a single number, in which case the size of the filter is assumed to be equal
    along each axis. The *footprint*, if provided, must be an array that defines the
    shape of the kernel by its non-zero elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`maximum_filter`](../reference/generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter
    "scipy.ndimage.maximum_filter") function calculates a multidimensional maximum
    filter. Either the sizes of a rectangular kernel or the footprint of the kernel
    must be provided. The *size* parameter, if provided, must be a sequence of sizes
    or a single number, in which case the size of the filter is assumed to be equal
    along each axis. The *footprint*, if provided, must be an array that defines the
    shape of the kernel by its non-zero elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`rank_filter`](../reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter
    "scipy.ndimage.rank_filter") function calculates a multidimensional rank filter.
    The *rank* may be less than zero, i.e., *rank* = -1 indicates the largest element.
    Either the sizes of a rectangular kernel or the footprint of the kernel must be
    provided. The *size* parameter, if provided, must be a sequence of sizes or a
    single number, in which case the size of the filter is assumed to be equal along
    each axis. The *footprint*, if provided, must be an array that defines the shape
    of the kernel by its non-zero elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`percentile_filter`](../reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter
    "scipy.ndimage.percentile_filter") function calculates a multidimensional percentile
    filter. The *percentile* may be less than zero, i.e., *percentile* = -20 equals
    *percentile* = 80\. Either the sizes of a rectangular kernel or the footprint
    of the kernel must be provided. The *size* parameter, if provided, must be a sequence
    of sizes or a single number, in which case the size of the filter is assumed to
    be equal along each axis. The *footprint*, if provided, must be an array that
    defines the shape of the kernel by its non-zero elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`median_filter`](../reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter
    "scipy.ndimage.median_filter") function calculates a multidimensional median filter.
    Either the sizes of a rectangular kernel or the footprint of the kernel must be
    provided. The *size* parameter, if provided, must be a sequence of sizes or a
    single number, in which case the size of the filter is assumed to be equal along
    each axis. The *footprint* if provided, must be an array that defines the shape
    of the kernel by its non-zero elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Derivative filters can be constructed in several ways. The function [`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d"), described in [Smoothing filters](#ndimage-filter-functions-smoothing),
    can be used to calculate derivatives along a given axis using the *order* parameter.
    Other derivative filters are the Prewitt and Sobel filters:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt") function calculates a derivative along the given axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") function calculates a derivative along the given axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Laplace filter is calculated by the sum of the second derivatives along
    all axes. Thus, different Laplace filters can be constructed using different second-derivative
    functions. Therefore, we provide a general function that takes a function argument
    to calculate the second derivative along a given direction.
  prefs: []
  type: TYPE_NORMAL
- en: The function [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") calculates a Laplace filter using the function
    passed through `derivative2` to calculate second derivatives. The function `derivative2`
    should have the following signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should calculate the second derivative along the dimension *axis*. If *output*
    is not `None`, it should use that for the output and return `None`, otherwise
    it should return the result. *mode*, *cval* have the usual meaning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and a dictionary of named arguments that are passed to `derivative2`
    at each call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To demonstrate the use of the *extra_arguments* argument, we could do
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following two functions are implemented using [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") by providing appropriate functions for the second-derivative
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: The function [`laplace`](../reference/generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace
    "scipy.ndimage.laplace") calculates the Laplace using discrete differentiation
    for the second derivative (i.e., convolution with `[1, -2, 1]`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function [`gaussian_laplace`](../reference/generated/scipy.ndimage.gaussian_laplace.html#scipy.ndimage.gaussian_laplace
    "scipy.ndimage.gaussian_laplace") calculates the Laplace filter using [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") to calculate the second derivatives. The standard
    deviations of the Gaussian filter along each axis are passed through the parameter
    *sigma* as a sequence or numbers. If *sigma* is not a sequence but a single number,
    the standard deviation of the filter is equal along all directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gradient magnitude is defined as the square root of the sum of the squares
    of the gradients in all directions. Similar to the generic Laplace function, there
    is a [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude") function that calculates the gradient
    magnitude of an array.
  prefs: []
  type: TYPE_NORMAL
- en: The function [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude") calculates a gradient magnitude using
    the function passed through `derivative` to calculate first derivatives. The function
    `derivative` should have the following signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should calculate the derivative along the dimension *axis*. If *output* is
    not `None`, it should use that for the output and return `None`, otherwise it
    should return the result. *mode*, *cval* have the usual meaning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and a dictionary of named arguments that are passed to *derivative*
    at each call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, the [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") function fits the required signature
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the documentation of [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") for examples of using the *extra_arguments* and
    *extra_keywords* arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") and [`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt") functions fit the required signature and can, therefore,
    be used directly with [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude").
  prefs: []
  type: TYPE_NORMAL
- en: The function [`gaussian_gradient_magnitude`](../reference/generated/scipy.ndimage.gaussian_gradient_magnitude.html#scipy.ndimage.gaussian_gradient_magnitude
    "scipy.ndimage.gaussian_gradient_magnitude") calculates the gradient magnitude
    using [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") to calculate the first derivatives. The standard
    deviations of the Gaussian filter along each axis are passed through the parameter
    *sigma* as a sequence or numbers. If *sigma* is not a sequence but a single number,
    the standard deviation of the filter is equal along all directions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Generic filter functions'
  prefs: []
  type: TYPE_NORMAL
- en: To implement filter functions, generic functions can be used that accept a callable
    object that implements the filtering operation. The iteration over the input and
    output arrays is handled by these generic functions, along with such details as
    the implementation of the boundary conditions. Only a callable object implementing
    a callback function that does the actual filtering work must be provided. The
    callback function can also be written in C and passed using a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)") (see [Extending scipy.ndimage in C](#ndimage-ccallbacks)
    for more information).
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function implements a generic 1-D filter function,
    where the actual filtering operation must be supplied as a python function (or
    other callable object). The [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function iterates over the lines of an array
    and calls `function` at each line. The arguments that are passed to `function`
    are 1-D arrays of the `numpy.float64` type. The first contains the values of the
    current line. It is extended at the beginning and the end, according to the *filter_size*
    and *origin* arguments. The second array should be modified in-place to provide
    the output values of the line. For example, consider a correlation along one dimension:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same operation can be implemented using [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d"), as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the origin of the kernel was (by default) assumed to be in the middle
    of the filter of length 3\. Therefore, each input line had been extended by one
    value at the beginning and at the end, before the function was called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the parameters of our filter as an argument
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter") function implements a generic filter function,
    where the actual filtering operation must be supplied as a python function (or
    other callable object). The [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter") function iterates over the array and calls `function`
    at each element. The argument of `function` is a 1-D array of the `numpy.float64`
    type that contains the values around the current element that are within the footprint
    of the filter. The function should return a single value that can be converted
    to a double precision number. For example, consider a correlation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The same operation can be implemented using *generic_filter*, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a kernel footprint was specified that contains only two elements. Therefore,
    the filter function receives a buffer of length equal to two, which was multiplied
    with the proper weights and the result summed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When calling [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), either the sizes of a rectangular kernel or the
    footprint of the kernel must be provided. The *size* parameter, if provided, must
    be a sequence of sizes or a single number, in which case the size of the filter
    is assumed to be equal along each axis. The *footprint*, if provided, must be
    an array that defines the shape of the kernel by its non-zero elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the parameters of our filter as an argument
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These functions iterate over the lines or elements starting at the last axis,
    i.e., the last index changes the fastest. This order of iteration is guaranteed
    for the case that it is important to adapt the filter depending on spatial location.
    Here is an example of using a class that implements the filter and keeps track
    of the current coordinates while iterating. It performs the same filter operation
    as described above for [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), but additionally prints the current coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For the [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function, the same approach works, except that
    this function does not iterate over the axis that is being filtered. The example
    for [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") then becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Fourier domain filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions described in this section perform filtering operations in the
    Fourier domain. Thus, the input array of such a function should be compatible
    with an inverse Fourier transform function, such as the functions from the [`numpy.fft`](https://numpy.org/devdocs/reference/routines.fft.html#module-numpy.fft
    "(in NumPy v2.0.dev0)") module. We, therefore, have to deal with arrays that may
    be the result of a real or a complex Fourier transform. In the case of a real
    Fourier transform, only half of the of the symmetric complex transform is stored.
    Additionally, it needs to be known what the length of the axis was that was transformed
    by the real fft. The functions described here provide a parameter *n* that, in
    the case of a real transform, must be equal to the length of the real transform
    axis before transformation. If this parameter is less than zero, it is assumed
    that the input array was the result of a complex Fourier transform. The parameter
    *axis* can be used to indicate along which axis the real transform was executed.
  prefs: []
  type: TYPE_NORMAL
- en: The [`fourier_shift`](../reference/generated/scipy.ndimage.fourier_shift.html#scipy.ndimage.fourier_shift
    "scipy.ndimage.fourier_shift") function multiplies the input array with the multidimensional
    Fourier transform of a shift operation for the given shift. The *shift* parameter
    is a sequence of shifts for each dimension or a single value for all dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`fourier_gaussian`](../reference/generated/scipy.ndimage.fourier_gaussian.html#scipy.ndimage.fourier_gaussian
    "scipy.ndimage.fourier_gaussian") function multiplies the input array with the
    multidimensional Fourier transform of a Gaussian filter with given standard deviations
    *sigma*. The *sigma* parameter is a sequence of values for each dimension or a
    single value for all dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`fourier_uniform`](../reference/generated/scipy.ndimage.fourier_uniform.html#scipy.ndimage.fourier_uniform
    "scipy.ndimage.fourier_uniform") function multiplies the input array with the
    multidimensional Fourier transform of a uniform filter with given sizes *size*.
    The *size* parameter is a sequence of values for each dimension or a single value
    for all dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`fourier_ellipsoid`](../reference/generated/scipy.ndimage.fourier_ellipsoid.html#scipy.ndimage.fourier_ellipsoid
    "scipy.ndimage.fourier_ellipsoid") function multiplies the input array with the
    multidimensional Fourier transform of an elliptically-shaped filter with given
    sizes *size*. The *size* parameter is a sequence of values for each dimension
    or a single value for all dimensions. This function is only implemented for dimensions
    1, 2, and 3.  ## Interpolation functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section describes various interpolation functions that are based on B-spline
    theory. A good introduction to B-splines can be found in [[1]](#id8) with detailed
    algorithms for image interpolation given in [[5]](#id12).
  prefs: []
  type: TYPE_NORMAL
- en: Spline pre-filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Interpolation using splines of an order larger than 1 requires a pre-filtering
    step. The interpolation functions described in section [Interpolation functions](#ndimage-interpolation)
    apply pre-filtering by calling [`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter"), but they can be instructed not to do this by setting
    the *prefilter* keyword equal to False. This is useful if more than one interpolation
    operation is done on the same array. In this case, it is more efficient to do
    the pre-filtering only once and use a pre-filtered array as the input of the interpolation
    functions. The following two functions implement the pre-filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`spline_filter1d`](../reference/generated/scipy.ndimage.spline_filter1d.html#scipy.ndimage.spline_filter1d
    "scipy.ndimage.spline_filter1d") function calculates a 1-D spline filter along
    the given axis. An output array can optionally be provided. The order of the spline
    must be larger than 1 and less than 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter") function calculates a multidimensional spline filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The multidimensional filter is implemented as a sequence of 1-D spline filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    if an output with a limited precision is requested, the results may be imprecise
    because intermediate results may be stored with insufficient precision. This can
    be prevented by specifying a output type of high precision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### Interpolation boundary handling'
  prefs: []
  type: TYPE_NORMAL
- en: The interpolation functions all employ spline interpolation to effect some type
    of geometric transformation of the input array. This requires a mapping of the
    output coordinates to the input coordinates, and therefore, the possibility arises
    that input values outside the boundaries may be needed. This problem is solved
    in the same way as described in [Filter functions](#ndimage-filter-functions)
    for the multidimensional filter functions. Therefore, these functions all support
    a *mode* parameter that determines how the boundaries are handled, and a *cval*
    parameter that gives a constant value in case that the ‘constant’ mode is used.
    The behavior of all modes, including at non-integer locations is illustrated below.
    Note the boundaries are not handled the same for all modes; *reflect* (aka *grid-mirror*)
    and *grid-wrap* involve symmetry or repetition about a point that is half way
    between image samples (dashed vertical lines) while modes *mirror* and *wrap*
    treat the image as if it’s extent ends exactly at the first and last sample point
    rather than 0.5 samples past it.
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/107cdb725ccd95831a4ba5074b502a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: The coordinates of image samples fall on integer sampling locations in the range
    from 0 to `shape[i] - 1` along each axis, `i`. The figure below illustrates the
    interpolation of a point at location `(3.7, 3.3)` within an image of shape `(7,
    7)`. For an interpolation of order `n`, `n + 1` samples are involved along each
    axis. The filled circles illustrate the sampling locations involved in the interpolation
    of the value at the location of the red x.
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/b4cf03bdffeaf405ab1e3824e1e6cb0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Interpolation functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") function applies an arbitrary geometric transform
    to the input. The given *mapping* function is called at each point in the output
    to find the corresponding coordinates in the input. *mapping* must be a callable
    object that accepts a tuple of length equal to the output array rank and returns
    the corresponding input coordinates as a tuple of length equal to the input array
    rank. The output shape and output type can optionally be provided. If not given,
    they are equal to the input shape and type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the shifts in our example as arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The mapping function can also be written in C and passed using a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable"). See [Extending scipy.ndimage in C](#ndimage-ccallbacks)
    for more information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function [`map_coordinates`](../reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates
    "scipy.ndimage.map_coordinates") applies an arbitrary coordinate transformation
    using the given array of coordinates. The shape of the output is derived from
    that of the coordinate array by dropping the first axis. The parameter *coordinates*
    is used to find for each point in the output the corresponding coordinates in
    the input. The values of *coordinates* along the first axis are the coordinates
    in the input array at which the output value is found. (See also the numarray
    *coordinates* function.) Since the coordinates may be non- integer coordinates,
    the value of the input at these coordinates is determined by spline interpolation
    of the requested order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example that interpolates a 2D array at `(0.5, 0.5)` and `(1, 2)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The [`affine_transform`](../reference/generated/scipy.ndimage.affine_transform.html#scipy.ndimage.affine_transform
    "scipy.ndimage.affine_transform") function applies an affine transformation to
    the input array. The given transformation *matrix* and *offset* are used to find
    for each point in the output the corresponding coordinates in the input. The value
    of the input at the calculated coordinates is determined by spline interpolation
    of the requested order. The transformation *matrix* must be 2-D or can also be
    given as a 1-D sequence or array. In the latter case, it is assumed that the matrix
    is diagonal. A more efficient interpolation algorithm is then applied that exploits
    the separability of the problem. The output shape and output type can optionally
    be provided. If not given, they are equal to the input shape and type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`shift`](../reference/generated/scipy.ndimage.shift.html#scipy.ndimage.shift
    "scipy.ndimage.shift") function returns a shifted version of the input, using
    spline interpolation of the requested *order*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`zoom`](../reference/generated/scipy.ndimage.zoom.html#scipy.ndimage.zoom
    "scipy.ndimage.zoom") function returns a rescaled version of the input, using
    spline interpolation of the requested *order*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`rotate`](../reference/generated/scipy.ndimage.rotate.html#scipy.ndimage.rotate
    "scipy.ndimage.rotate") function returns the input array rotated in the plane
    defined by the two axes given by the parameter *axes*, using spline interpolation
    of the requested *order*. The angle must be given in degrees. If *reshape* is
    true, then the size of the output array is adapted to contain the rotated input.  ##
    Morphology'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Binary morphology'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") functions generates a binary structuring
    element for use in binary morphology operations. The *rank* of the structure must
    be provided. The size of the structure that is returned is equal to three in each
    direction. The value of each element is equal to one if the square of the Euclidean
    distance from the element to the center is less than or equal to *connectivity*.
    For instance, 2-D 4-connected and 8-connected structures are generated as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a visual presentation of [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") in 3D:'
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/ef3b334e00490f57e7f362b27434c7e1.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'Most binary morphology functions can be expressed in terms of the basic operations
    erosion and dilation, which can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/a74b3111309bd8011739df3806ce86e7.png)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: The [`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") function implements binary erosion of arrays of
    arbitrary rank with the given structuring element. The origin parameter controls
    the placement of the structuring element, as described in [Filter functions](#ndimage-filter-functions).
    If no structuring element is provided, an element with connectivity equal to one
    is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *border_value* parameter gives
    the value of the array outside boundaries. The erosion is repeated *iterations*
    times. If *iterations* is less than one, the erosion is repeated until the result
    does not change anymore. If a *mask* array is given, only those elements with
    a true value at the corresponding mask element are modified at each iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") function implements binary dilation of arrays
    of arbitrary rank with the given structuring element. The origin parameter controls
    the placement of the structuring element, as described in [Filter functions](#ndimage-filter-functions).
    If no structuring element is provided, an element with connectivity equal to one
    is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *border_value* parameter gives
    the value of the array outside boundaries. The dilation is repeated *iterations*
    times. If *iterations* is less than one, the dilation is repeated until the result
    does not change anymore. If a *mask* array is given, only those elements with
    a true value at the corresponding mask element are modified at each iteration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of using [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") to find all elements that touch the border, by
    repeatedly dilating an empty array from the border using the data array as the
    mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") and [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") functions both have an *iterations* parameter,
    which allows the erosion or dilation to be repeated a number of times. Repeating
    an erosion or a dilation with a given structure *n* times is equivalent to an
    erosion or a dilation with a structure that is *n-1* times dilated with itself.
    A function is provided that allows the calculation of a structure that is dilated
    a number of times with itself:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`iterate_structure`](../reference/generated/scipy.ndimage.iterate_structure.html#scipy.ndimage.iterate_structure
    "scipy.ndimage.iterate_structure") function returns a structure by dilation of
    the input structure *iteration* - 1 times with itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Other morphology operations can be defined in terms of erosion and dilation.
    The following functions provide a few of these operations for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`binary_opening`](../reference/generated/scipy.ndimage.binary_opening.html#scipy.ndimage.binary_opening
    "scipy.ndimage.binary_opening") function implements binary opening of arrays of
    arbitrary rank with the given structuring element. Binary opening is equivalent
    to a binary erosion followed by a binary dilation with the same structuring element.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *iterations* parameter gives the
    number of erosions that is performed followed by the same number of dilations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`binary_closing`](../reference/generated/scipy.ndimage.binary_closing.html#scipy.ndimage.binary_closing
    "scipy.ndimage.binary_closing") function implements binary closing of arrays of
    arbitrary rank with the given structuring element. Binary closing is equivalent
    to a binary dilation followed by a binary erosion with the same structuring element.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *iterations* parameter gives the
    number of dilations that is performed followed by the same number of erosions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`binary_fill_holes`](../reference/generated/scipy.ndimage.binary_fill_holes.html#scipy.ndimage.binary_fill_holes
    "scipy.ndimage.binary_fill_holes") function is used to close holes in objects
    in a binary image, where the structure defines the connectivity of the holes.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`binary_hit_or_miss`](../reference/generated/scipy.ndimage.binary_hit_or_miss.html#scipy.ndimage.binary_hit_or_miss
    "scipy.ndimage.binary_hit_or_miss") function implements a binary hit-or-miss transform
    of arrays of arbitrary rank with the given structuring elements. The hit-or-miss
    transform is calculated by erosion of the input with the first structure, erosion
    of the logical *not* of the input with the second structure, followed by the logical
    *and* of these two erosions. The origin parameters control the placement of the
    structuring elements, as described in [Filter functions](#ndimage-filter-functions).
    If *origin2* equals `None`, it is set equal to the *origin1* parameter. If the
    first structuring element is not provided, a structuring element with connectivity
    equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). If *structure2* is not provided, it
    is set equal to the logical *not* of *structure1*.  ### Grey-scale morphology'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grey-scale morphology operations are the equivalents of binary morphology operations
    that operate on arrays with arbitrary values. Below, we describe the grey-scale
    equivalents of erosion, dilation, opening and closing. These operations are implemented
    in a similar fashion as the filters described in [Filter functions](#ndimage-filter-functions),
    and we refer to this section for the description of filter kernels and footprints,
    and the handling of array borders. The grey-scale morphology operations optionally
    take a *structure* parameter that gives the values of the structuring element.
    If this parameter is not given, the structuring element is assumed to be flat
    with a value equal to zero. The shape of the structure can optionally be defined
    by the *footprint* parameter. If this parameter is not given, the structure is
    assumed to be rectangular, with sizes equal to the dimensions of the *structure*
    array, or by the *size* parameter if *structure* is not given. The *size* parameter
    is only used if both *structure* and *footprint* are not given, in which case
    the structuring element is assumed to be rectangular and flat with the dimensions
    given by *size*. The *size* parameter, if provided, must be a sequence of sizes
    or a single number in which case the size of the filter is assumed to be equal
    along each axis. The *footprint* parameter, if provided, must be an array that
    defines the shape of the kernel by its non-zero elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to binary erosion and dilation, there are operations for grey-scale
    erosion and dilation:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`grey_erosion`](../reference/generated/scipy.ndimage.grey_erosion.html#scipy.ndimage.grey_erosion
    "scipy.ndimage.grey_erosion") function calculates a multidimensional grey-scale
    erosion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`grey_dilation`](../reference/generated/scipy.ndimage.grey_dilation.html#scipy.ndimage.grey_dilation
    "scipy.ndimage.grey_dilation") function calculates a multidimensional grey-scale
    dilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grey-scale opening and closing operations can be defined similarly to their
    binary counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`grey_opening`](../reference/generated/scipy.ndimage.grey_opening.html#scipy.ndimage.grey_opening
    "scipy.ndimage.grey_opening") function implements grey-scale opening of arrays
    of arbitrary rank. Grey-scale opening is equivalent to a grey-scale erosion followed
    by a grey-scale dilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`grey_closing`](../reference/generated/scipy.ndimage.grey_closing.html#scipy.ndimage.grey_closing
    "scipy.ndimage.grey_closing") function implements grey-scale closing of arrays
    of arbitrary rank. Grey-scale opening is equivalent to a grey-scale dilation followed
    by a grey-scale erosion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`morphological_gradient`](../reference/generated/scipy.ndimage.morphological_gradient.html#scipy.ndimage.morphological_gradient
    "scipy.ndimage.morphological_gradient") function implements a grey-scale morphological
    gradient of arrays of arbitrary rank. The grey-scale morphological gradient is
    equal to the difference of a grey-scale dilation and a grey-scale erosion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`morphological_laplace`](../reference/generated/scipy.ndimage.morphological_laplace.html#scipy.ndimage.morphological_laplace
    "scipy.ndimage.morphological_laplace") function implements a grey-scale morphological
    laplace of arrays of arbitrary rank. The grey-scale morphological laplace is equal
    to the sum of a grey-scale dilation and a grey-scale erosion minus twice the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`white_tophat`](../reference/generated/scipy.ndimage.white_tophat.html#scipy.ndimage.white_tophat
    "scipy.ndimage.white_tophat") function implements a white top-hat filter of arrays
    of arbitrary rank. The white top-hat is equal to the difference of the input and
    a grey-scale opening.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`black_tophat`](../reference/generated/scipy.ndimage.black_tophat.html#scipy.ndimage.black_tophat
    "scipy.ndimage.black_tophat") function implements a black top-hat filter of arrays
    of arbitrary rank. The black top-hat is equal to the difference of a grey-scale
    closing and the input.  ## Distance transforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distance transforms are used to calculate the minimum distance from each element
    of an object to the background. The following functions implement distance transforms
    for three different distance metrics: Euclidean, city block, and chessboard distances.'
  prefs: []
  type: TYPE_NORMAL
- en: The function [`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt") uses a chamfer type algorithm to calculate
    the distance transform of the input, by replacing each object element (defined
    by values larger than zero) with the shortest distance to the background (all
    non-object elements). The structure determines the type of chamfering that is
    done. If the structure is equal to ‘cityblock’, a structure is generated using
    [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") with a squared distance equal to 1\.
    If the structure is equal to ‘chessboard’, a structure is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") with a squared distance equal to the
    rank of the array. These choices correspond to the common interpretations of the
    city block and the chessboard distance metrics in two dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances*, and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (both `numpy.int32`). The basics
    of the algorithm used to implement this function are described in [[2]](#id9).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function [`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt") calculates the exact Euclidean distance
    transform of the input, by replacing each object element (defined by values larger
    than zero) with the shortest Euclidean distance to the background (all non-object
    elements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances* and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, the sampling along each axis can be given by the *sampling* parameter,
    which should be a sequence of length equal to the input rank, or a single number
    in which the sampling is assumed to be equal along all axes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (`numpy.float64` and `numpy.int32`).The
    algorithm used to implement this function is described in [[3]](#id10).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function [`distance_transform_bf`](../reference/generated/scipy.ndimage.distance_transform_bf.html#scipy.ndimage.distance_transform_bf
    "scipy.ndimage.distance_transform_bf") uses a brute-force algorithm to calculate
    the distance transform of the input, by replacing each object element (defined
    by values larger than zero) with the shortest distance to the background (all
    non-object elements). The metric must be one of “euclidean”, “cityblock”, or “chessboard”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances* and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, the sampling along each axis can be given by the *sampling* parameter,
    which should be a sequence of length equal to the input rank, or a single number
    in which the sampling is assumed to be equal along all axes. This parameter is
    only used in the case of the Euclidean distance transform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (`numpy.float64` and `numpy.int32`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function uses a slow brute-force algorithm, the function [`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt") can be used to more efficiently calculate
    city block and chessboard distance transforms. The function [`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt") can be used to more efficiently calculate
    the exact Euclidean distance transform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Segmentation and labeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Segmentation is the process of separating objects of interest from the background.
    The most simple approach is, probably, intensity thresholding, which is easily
    done with [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(in NumPy v2.0.dev0)") functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a binary image, in which the individual objects still need to
    be identified and labeled. The function [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") generates an array where each object is assigned a unique
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") function generates an array where the objects in the input
    are labeled with an integer index. It returns a tuple consisting of the array
    of object labels and the number of objects found, unless the *output* parameter
    is given, in which case only the number of objects is returned. The connectivity
    of the objects is defined by a structuring element. For instance, in 2D using
    a 4-connected structuring element gives:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two objects are not connected because there is no way in which we can
    place the structuring element, such that it overlaps with both objects. However,
    an 8-connected structuring element results in only a single object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If no structuring element is provided, one is generated by calling [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") (see [Binary morphology](#ndimage-binary-morphology))
    using a connectivity of one (which in 2D is the 4-connected structure of the first
    example). The input can be of any type, any value not equal to zero is taken to
    be part of an object. This is useful if you need to ‘re-label’ an array of object
    indices, for instance, after removing unwanted objects. Just apply the label function
    again to the index array. For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The structuring element used by [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") is assumed to be symmetric.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is a large number of other approaches for segmentation, for instance,
    from an estimation of the borders of the objects that can be obtained by derivative
    filters. One such approach is watershed segmentation. The function [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") generates an array where each object is assigned
    a unique label, from an array that localizes the object borders, generated, for
    instance, by a gradient magnitude filter. It uses an array containing initial
    markers for the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") function applies a watershed from markers algorithm,
    using Image Foresting Transform, as described in [[4]](#id11).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The inputs of this function are the array to which the transform is applied,
    and an array of markers that designate the objects by a unique label, where any
    non-zero value is a marker. For instance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, two markers were used to designate an object (*marker* = 2) and the background
    (*marker* = 1). The order in which these are processed is arbitrary: moving the
    marker for the background to the lower-right corner of the array yields a different
    result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is that the object (*marker* = 2) is smaller because the second
    marker was processed earlier. This may not be the desired effect if the first
    marker was supposed to designate a background object. Therefore, [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") treats markers with a negative value explicitly
    as background markers and processes them after the normal markers. For instance,
    replacing the first marker by a negative marker gives a result similar to the
    first example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The connectivity of the objects is defined by a structuring element. If no
    structuring element is provided, one is generated by calling [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") (see [Binary morphology](#ndimage-binary-morphology))
    using a connectivity of one (which in 2D is a 4-connected structure.) For example,
    using an 8-connected structure with the last example yields a different object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The implementation of [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") limits the data types of the input to `numpy.uint8`
    and `numpy.uint16`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '## Object measurements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an array of labeled objects, the properties of the individual objects
    can be measured. The [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") function can be used to generate a list of slices
    that for each object, give the smallest sub-array that fully contains the object:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") function finds all objects in a labeled array and
    returns a list of slices that correspond to the smallest regions in the array
    that contains the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") returns slices for all objects, unless the *max_label*
    parameter is larger then zero, in which case only the first *max_label* objects
    are returned. If an index is missing in the *label* array, `None` is return instead
    of a slice. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The list of slices generated by [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") is useful to find the position and dimensions of
    the objects in the array, but can also be used to perform measurements on the
    individual objects. Say, we want to find the sum of the intensities of an object
    in image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can calculate the sum of the elements in the second object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, however, not particularly efficient and may also be more complicated
    for other types of measurements. Therefore, a few measurements functions are defined
    that accept the array of object labels and the index of the object to be measured.
    For instance, calculating the sum of the intensities can be done by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For large arrays and small objects, it is more efficient to call the measurement
    functions after slicing the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can do the measurements for a number of labels with a single
    function call, returning a list of results. For instance, to measure the sum of
    the values of the background and the second object in our example, we give a list
    of labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The measurement functions described below all support the *index* parameter
    to indicate which object(s) should be measured. The default value of *index* is
    `None`. This indicates that all elements where the label is larger than zero should
    be treated as a single object and measured. Thus, in this case the *labels* array
    is treated as a mask defined by the elements that are larger than zero. If *index*
    is a number or a sequence of numbers it gives the labels of the objects that are
    measured. If *index* is a sequence, a list of the results is returned. Functions
    that return more than one result return their result as a tuple if *index* is
    a single number, or as a tuple of lists if *index* is a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sum`](https://docs.python.org/3/library/functions.html#sum "(in Python
    v3.12)") function calculates the sum of the elements of the object with label(s)
    given by *index*, using the *labels* array for the object labels. If *index* is
    `None`, all elements with a non-zero label value are treated as a single object.
    If *label* is `None`, all elements of *input* are used in the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`mean`](../reference/generated/scipy.ndimage.mean.html#scipy.ndimage.mean
    "scipy.ndimage.mean") function calculates the mean of the elements of the object
    with label(s) given by *index*, using the *labels* array for the object labels.
    If *index* is `None`, all elements with a non-zero label value are treated as
    a single object. If *label* is `None`, all elements of *input* are used in the
    calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`variance`](../reference/generated/scipy.ndimage.variance.html#scipy.ndimage.variance
    "scipy.ndimage.variance") function calculates the variance of the elements of
    the object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`standard_deviation`](../reference/generated/scipy.ndimage.standard_deviation.html#scipy.ndimage.standard_deviation
    "scipy.ndimage.standard_deviation") function calculates the standard deviation
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`minimum`](../reference/generated/scipy.ndimage.minimum.html#scipy.ndimage.minimum
    "scipy.ndimage.minimum") function calculates the minimum of the elements of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`maximum`](../reference/generated/scipy.ndimage.maximum.html#scipy.ndimage.maximum
    "scipy.ndimage.maximum") function calculates the maximum of the elements of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`minimum_position`](../reference/generated/scipy.ndimage.minimum_position.html#scipy.ndimage.minimum_position
    "scipy.ndimage.minimum_position") function calculates the position of the minimum
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`maximum_position`](../reference/generated/scipy.ndimage.maximum_position.html#scipy.ndimage.maximum_position
    "scipy.ndimage.maximum_position") function calculates the position of the maximum
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`extrema`](../reference/generated/scipy.ndimage.extrema.html#scipy.ndimage.extrema
    "scipy.ndimage.extrema") function calculates the minimum, the maximum, and their
    positions, of the elements of the object with label(s) given by *index*, using
    the *labels* array for the object labels. If *index* is `None`, all elements with
    a non-zero label value are treated as a single object. If *label* is `None`, all
    elements of *input* are used in the calculation. The result is a tuple giving
    the minimum, the maximum, the position of the minimum, and the position of the
    maximum. The result is the same as a tuple formed by the results of the functions
    *minimum*, *maximum*, *minimum_position*, and *maximum_position* that are described
    above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`center_of_mass`](../reference/generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass
    "scipy.ndimage.center_of_mass") function calculates the center of mass of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The [`histogram`](../reference/generated/scipy.ndimage.histogram.html#scipy.ndimage.histogram
    "scipy.ndimage.histogram") function calculates a histogram of the object with
    label(s) given by *index*, using the *labels* array for the object labels. If
    *index* is `None`, all elements with a non-zero label value are treated as a single
    object. If *label* is `None`, all elements of *input* are used in the calculation.
    Histograms are defined by their minimum (*min*), maximum (*max*), and the number
    of bins (*bins*). They are returned as 1-D arrays of type `numpy.int32`.  ## Extending
    [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")
    in C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few functions in [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") take a callback argument. This can be either a python function
    or a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") containing a pointer to a C function. Using a C function
    will generally be more efficient, since it avoids the overhead of calling a python
    function on many elements of an array. To use a C function, you must write a C
    extension that contains the callback function and a Python function that returns
    a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") containing a pointer to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a function that supports callbacks is [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform"), which accepts a callback function that defines
    a mapping from all output coordinates to corresponding coordinates in the input
    array. Consider the following python example, which uses [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") to implement a shift function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement the callback function with the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'More information on writing Python extension modules can be found [here](https://docs.python.org/3/extending/index.html).
    If the C code is in the file `example.c`, then it can be compiled after adding
    it to `meson.build` (see examples inside `meson.build` files) and follow what’s
    there. After that is done, running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: produces the same result as the original python script.
  prefs: []
  type: TYPE_NORMAL
- en: In the C version, `_transform` is the callback function and the parameters `output_coordinates`
    and `input_coordinates` play the same role as they do in the python version, while
    `output_rank` and `input_rank` provide the equivalents of `len(output_coordinates)`
    and `len(input_coordinates)`. The variable `shift` is passed through `user_data`
    instead of `extra_arguments`. Finally, the C callback function returns an integer
    status, which is one upon success and zero otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `py_transform` wraps the callback function in a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)"). The main steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)"). The first argument is a pointer to the callback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is the function signature, which must match exactly the
    one expected by [`ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above, we used [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") to specify `user_data` that we generated with [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A different approach would be to supply the data in the capsule context, that
    can be set by *PyCapsule_SetContext* and omit specifying `user_data` in [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable"). However, in this approach we would need to deal with
    allocation/freeing of the data — freeing the data after the capsule has been destroyed
    can be done by specifying a non-NULL callback function in the third argument of
    *PyCapsule_New*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C callback functions for [`ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") all follow this scheme. The next section lists the [`ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") functions that accept a C callback function and gives the prototype
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions that support low-level callback arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d"), [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: Below, we show alternative ways to write the code, using [Numba](https://numba.pydata.org/),
    [Cython](https://cython.org/), [ctypes](https://docs.python.org/3/library/ctypes.html),
    or [cffi](https://cffi.readthedocs.io/) instead of writing wrapper code in C.
  prefs: []
  type: TYPE_NORMAL
- en: Numba
  prefs: []
  type: TYPE_NORMAL
- en: '[Numba](https://numba.pydata.org/) provides a way to write low-level functions
    easily in Python. We can write the above using Numba as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Cython
  prefs: []
  type: TYPE_NORMAL
- en: 'Functionally the same code as above can be written in Cython with somewhat
    less boilerplate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: cffi
  prefs: []
  type: TYPE_NORMAL
- en: 'With [cffi](https://cffi.readthedocs.io/), you can interface with a C function
    residing in a shared library (DLL). First, we need to write the shared library,
    which we do in C — this example is for Linux/OSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python code calling the library is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information in the [cffi](https://cffi.readthedocs.io/) documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ctypes
  prefs: []
  type: TYPE_NORMAL
- en: 'With *ctypes*, the C code and the compilation of the so/DLL is as for cffi
    above. The Python code is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information in the [ctypes](https://docs.python.org/3/library/ctypes.html)
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
