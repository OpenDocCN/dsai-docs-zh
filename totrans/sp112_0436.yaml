- en: scipy.optimize.minimize
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scipy.optimize.minimize
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize)
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Minimization of scalar function of one or more variables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化一个或多个变量的标量函数。
- en: 'Parameters:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**fun**callable'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**fun** 可调用对象'
- en: The objective function to be minimized.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要最小化的目标函数。
- en: '`fun(x, *args) -> float`'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`fun(x, *args) -> float`'
- en: where `x` is a 1-D array with shape (n,) and `args` is a tuple of the fixed
    parameters needed to completely specify the function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 是形状为 (n,) 的一维数组，`args` 是一个元组，包含完全指定函数所需的固定参数。
- en: '**x0**ndarray, shape (n,)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0** 数组，形状为 (n,)'
- en: Initial guess. Array of real elements of size (n,), where `n` is the number
    of independent variables.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 初始猜测。大小为 (n,) 的实数元素数组，其中 `n` 是独立变量的数量。
- en: '**args**tuple, optional'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**args** 元组，可选'
- en: Extra arguments passed to the objective function and its derivatives (*fun*,
    *jac* and *hess* functions).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给目标函数及其导数（*fun*、*jac* 和 *hess* 函数）的额外参数。
- en: '**method**str or callable, optional'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**method** 字符串或可调用对象，可选'
- en: Type of solver. Should be one of
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器的类型。应为以下之一：
- en: ‘Nelder-Mead’ [(see here)](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘Nelder-Mead’ [(详见此处)](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘Powell’ [(see here)](../optimize.minimize-powell.html#optimize-minimize-powell)
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘Powell’ [(详见此处)](../optimize.minimize-powell.html#optimize-minimize-powell)
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘CG’ [(see here)](../optimize.minimize-cg.html#optimize-minimize-cg)
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘CG’ [(详见此处)](../optimize.minimize-cg.html#optimize-minimize-cg)
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘BFGS’ [(see here)](../optimize.minimize-bfgs.html#optimize-minimize-bfgs)
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘BFGS’ [(详见此处)](../optimize.minimize-bfgs.html#optimize-minimize-bfgs)
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘Newton-CG’ [(see here)](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘Newton-CG’ [(详见此处)](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘L-BFGS-B’ [(see here)](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘L-BFGS-B’ [(详见此处)](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘TNC’ [(see here)](../optimize.minimize-tnc.html#optimize-minimize-tnc)
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘TNC’ [(详见此处)](../optimize.minimize-tnc.html#optimize-minimize-tnc)
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘COBYLA’ [(see here)](../optimize.minimize-cobyla.html#optimize-minimize-cobyla)
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘COBYLA’ [(详见此处)](../optimize.minimize-cobyla.html#optimize-minimize-cobyla)
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘SLSQP’ [(see here)](../optimize.minimize-slsqp.html#optimize-minimize-slsqp)
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘SLSQP’ [(详见此处)](../optimize.minimize-slsqp.html#optimize-minimize-slsqp)
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-constr’[(see here)](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘trust-constr’[(详见此处)](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘dogleg’ [(see here)](../optimize.minimize-dogleg.html#optimize-minimize-dogleg)
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘dogleg’ [(详见此处)](../optimize.minimize-dogleg.html#optimize-minimize-dogleg)
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-ncg’ [(see here)](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘trust-ncg’ [(详见此处)](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-exact’ [(see here)](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘trust-exact’ [(详见此处)](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘trust-krylov’ [(see here)](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘trust-krylov’ [(详见此处)](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: custom - a callable object, see below for description.
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: custom - 一个可调用对象，请参阅下文进行描述。
- en: If not given, chosen to be one of `BFGS`, `L-BFGS-B`, `SLSQP`, depending on
    whether or not the problem has constraints or bounds.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供，则根据问题是否有约束或边界选择 `BFGS`、`L-BFGS-B`、`SLSQP` 中的一种。
- en: '**jac**{callable, ‘2-point’, ‘3-point’, ‘cs’, bool}, optional'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**jac**{callable, ‘2-point’, ‘3-point’, ‘cs’, bool}, optional'
- en: 'Method for computing the gradient vector. Only for CG, BFGS, Newton-CG, L-BFGS-B,
    TNC, SLSQP, dogleg, trust-ncg, trust-krylov, trust-exact and trust-constr. If
    it is a callable, it should be a function that returns the gradient vector:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 计算梯度向量的方法。仅适用于 CG、BFGS、Newton-CG、L-BFGS-B、TNC、SLSQP、dogleg、trust-ncg、trust-krylov、trust-exact
    和 trust-constr。如果是可调用对象，则应为返回梯度向量的函数：
- en: '`jac(x, *args) -> array_like, shape (n,)`'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jac(x, *args) -> array_like, shape (n,)`'
- en: where `x` is an array with shape (n,) and `args` is a tuple with the fixed parameters.
    If *jac* is a Boolean and is True, *fun* is assumed to return a tuple `(f, g)`
    containing the objective function and the gradient. Methods ‘Newton-CG’, ‘trust-ncg’,
    ‘dogleg’, ‘trust-exact’, and ‘trust-krylov’ require that either a callable be
    supplied, or that *fun* return the objective and gradient. If None or False, the
    gradient will be estimated using 2-point finite difference estimation with an
    absolute step size. Alternatively, the keywords {‘2-point’, ‘3-point’, ‘cs’} can
    be used to select a finite difference scheme for numerical estimation of the gradient
    with a relative step size. These finite difference schemes obey any specified
    *bounds*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 是形状为 (n,) 的数组，`args` 是具有固定参数的元组。如果 *jac* 是布尔值且为 True，则假定 *fun* 返回包含目标函数和梯度的元组
    `(f, g)`。方法 ‘Newton-CG’、‘trust-ncg’、‘dogleg’、‘trust-exact’ 和 ‘trust-krylov’ 要求提供一个可调用对象，或者
    *fun* 返回目标函数和梯度。如果为 None 或 False，则使用绝对步长进行二点有限差分估计梯度。或者，关键字 {‘2-point’、‘3-point’、‘cs’}
    可用于选择用于数值梯度估计的有限差分方案，并使用相对步长。这些有限差分方案遵循任何指定的 *bounds*。
- en: '**hess**{callable, ‘2-point’, ‘3-point’, ‘cs’, HessianUpdateStrategy}, optional'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**hess**{可调用对象，‘2-point’，‘3-point’，‘cs’，HessianUpdateStrategy}，可选'
- en: 'Method for computing the Hessian matrix. Only for Newton-CG, dogleg, trust-ncg,
    trust-krylov, trust-exact and trust-constr. If it is callable, it should return
    the Hessian matrix:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 Hessian 矩阵的方法。仅适用于 Newton-CG、dogleg、trust-ncg、trust-krylov、trust-exact 和
    trust-constr。如果是可调用对象，则应返回 Hessian 矩阵：
- en: '`hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)`'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`hess(x, *args) -> {LinearOperator, spmatrix, array}, (n, n)`'
- en: 'where `x` is a (n,) ndarray and `args` is a tuple with the fixed parameters.
    The keywords {‘2-point’, ‘3-point’, ‘cs’} can also be used to select a finite
    difference scheme for numerical estimation of the hessian. Alternatively, objects
    implementing the [`HessianUpdateStrategy`](scipy.optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") interface can be used to approximate the
    Hessian. Available quasi-Newton methods implementing this interface are:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 是形状为 (n,) 的 ndarray，`args` 是具有固定参数的元组。关键字 {‘2-point’、‘3-point’、‘cs’}
    也可用于选择用于数值估计 Hessian 的有限差分方案。或者，实现 [`HessianUpdateStrategy`](https://docs.scipy.org/doc/scipy/reference/optimize.HessianUpdateStrategy.html#scipy.optimize.HessianUpdateStrategy
    "scipy.optimize.HessianUpdateStrategy") 接口的对象可用于近似 Hessian。实现此接口的可用拟牛顿方法包括：
- en: '[`BFGS`](scipy.optimize.BFGS.html#scipy.optimize.BFGS "scipy.optimize.BFGS");'
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`BFGS`](https://docs.scipy.org/doc/scipy/reference/optimize.BFGS.html#scipy.optimize.BFGS
    "scipy.optimize.BFGS");'
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`SR1`](scipy.optimize.SR1.html#scipy.optimize.SR1 "scipy.optimize.SR1").'
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`SR1`](https://docs.scipy.org/doc/scipy/reference/optimize.SR1.html#scipy.optimize.SR1
    "scipy.optimize.SR1")。'
- en: Not all of the options are available for each of the methods; for availability
    refer to the notes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每种方法都有所有选项；可参考注释中的可用性。
- en: '**hessp**callable, optional'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**hessp**可调用对象，可选'
- en: 'Hessian of objective function times an arbitrary vector p. Only for Newton-CG,
    trust-ncg, trust-krylov, trust-constr. Only one of *hessp* or *hess* needs to
    be given. If *hess* is provided, then *hessp* will be ignored. *hessp* must compute
    the Hessian times an arbitrary vector:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数的 Hessian 矩阵乘以任意向量 p。仅适用于 Newton-CG、trust-ncg、trust-krylov、trust-constr。*hessp*
    或 *hess* 之一需要提供。如果提供了 *hess*，则将忽略 *hessp*。*hessp* 必须计算 Hessian 乘以任意向量：
- en: '`hessp(x, p, *args) ->  ndarray shape (n,)`'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`hessp(x, p, *args) ->  ndarray 形状 (n,)`'
- en: where `x` is a (n,) ndarray, `p` is an arbitrary vector with dimension (n,)
    and `args` is a tuple with the fixed parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `x` 是形状为 (n,) 的 ndarray，`p` 是维度为 (n,) 的任意向量，`args` 是具有固定参数的元组。
- en: '**bounds**sequence or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds"), optional'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**bounds**序列或 [`Bounds`](https://docs.scipy.org/doc/scipy/reference/optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")，可选'
- en: 'Bounds on variables for Nelder-Mead, L-BFGS-B, TNC, SLSQP, Powell, trust-constr,
    and COBYLA methods. There are two ways to specify the bounds:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的界限用于 Nelder-Mead、L-BFGS-B、TNC、SLSQP、Powell、trust-constr 和 COBYLA 方法。有两种指定界限的方式：
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Bounds`](https://docs.scipy.org/doc/scipy/reference/optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds") 类的实例。'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Sequence of `(min, max)` pairs for each element in *x*. None is used to specify
    no bound.
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 *x* 中的每个元素，`(min, max)` 对用于指定界限。使用 None 表示无界限。
- en: '**constraints**{Constraint, dict} or List of {Constraint, dict}, optional'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**约束**{约束，字典} 或 约束列表 {约束，字典}，可选'
- en: Constraints definition. Only for COBYLA, SLSQP and trust-constr.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 约束定义。仅适用于 COBYLA、SLSQP 和 trust-constr。
- en: 'Constraints for ‘trust-constr’ are defined as a single object or a list of
    objects specifying constraints to the optimization problem. Available constraints
    are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ‘trust-constr’ 的约束被定义为一个单一对象或指定优化问题约束的对象列表。可用的约束类型包括：
- en: '[`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")'
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint")'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NonlinearConstraint`](scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint")'
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`NonlinearConstraint`](scipy.optimize.NonlinearConstraint.html#scipy.optimize.NonlinearConstraint
    "scipy.optimize.NonlinearConstraint")'
- en: 'Constraints for COBYLA, SLSQP are defined as a list of dictionaries. Each dictionary
    with fields:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 COBYLA、SLSQP，约束被定义为一个包含字段的字典列表：
- en: typestr
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: typestr
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Constraint type: ‘eq’ for equality, ‘ineq’ for inequality.'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 约束类型：‘eq’ 表示等式约束，‘ineq’ 表示不等式约束。
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: funcallable
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: funcallable
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function defining the constraint.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义约束的函数。
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: jaccallable, optional
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: jaccallable，可选
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Jacobian of *fun* (only for SLSQP).
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*fun* 的雅可比矩阵（仅适用于 SLSQP）。'
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: argssequence, optional
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: argssequence，可选
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Extra arguments to be passed to the function and Jacobian.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传递给函数和雅可比矩阵的额外参数。
- en: Equality constraint means that the constraint function result is to be zero
    whereas inequality means that it is to be non-negative. Note that COBYLA only
    supports inequality constraints.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 等式约束意味着约束函数的结果应为零，而不等式则意味着其应为非负。请注意，COBYLA 只支持不等式约束。
- en: '**tol**float, optional'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**tol**float，可选'
- en: Tolerance for termination. When *tol* is specified, the selected minimization
    algorithm sets some relevant solver-specific tolerance(s) equal to *tol*. For
    detailed control, use solver-specific options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 终止容差。当指定 *tol* 时，所选的最小化算法设置一些相关的特定解算器容差为 *tol*。要进行详细的控制，请使用特定于解算器的选项。
- en: '**options**dict, optional'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**options**dict，可选'
- en: 'A dictionary of solver options. All methods except *TNC* accept the following
    generic options:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解算器选项的字典。除了 *TNC* 方法外，所有方法都接受以下通用选项：
- en: maxiterint
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: maxiterint
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maximum number of iterations to perform. Depending on the method each iteration
    may use several function evaluations.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 执行的最大迭代次数。根据方法，每次迭代可能会使用多个函数评估。
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For *TNC* use *maxfun* instead of *maxiter*.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 *TNC* 方法，请使用 *maxfun* 而不是 *maxiter*。
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: dispbool
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dispbool
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set to True to print convergence messages.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置为 True 以打印收敛消息。
- en: For method-specific options, see [`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定方法的选项，请参见 [`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options")。
- en: '**callback**callable, optional'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**callback**callable，可选'
- en: A callable called after each iteration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代后调用的可调用函数。
- en: 'All methods except TNC, SLSQP, and COBYLA support a callable with the signature:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TNC、SLSQP 和 COBYLA 方法之外的所有方法都支持具有以下签名的可调用函数：
- en: '`callback(intermediate_result: OptimizeResult)`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`callback(intermediate_result: OptimizeResult)`'
- en: where `intermediate_result` is a keyword parameter containing an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") with attributes `x` and `fun`, the present values
    of the parameter vector and objective function. Note that the name of the parameter
    must be `intermediate_result` for the callback to be passed an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult"). These methods will also terminate if the callback
    raises `StopIteration`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `intermediate_result` 是一个关键字参数，包含一个 [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")，具有参数向量和目标函数当前值的属性。请注意，回调函数必须命名为 `intermediate_result`，以便传递一个
    [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")。如果回调函数引发 `StopIteration`，这些方法也将终止。
- en: 'All methods except trust-constr (also) support a signature like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 trust-constr 方法之外的所有方法都支持以下形式的签名：
- en: '`callback(xk)`'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`callback(xk)`'
- en: where `xk` is the current parameter vector.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `xk` 是当前的参数向量。
- en: Introspection is used to determine which of the signatures above to invoke.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内省来确定要调用上述哪种签名。
- en: 'Returns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**res**OptimizeResult'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**res**OptimizeResult'
- en: 'The optimization result represented as a `OptimizeResult` object. Important
    attributes are: `x` the solution array, `success` a Boolean flag indicating if
    the optimizer exited successfully and `message` which describes the cause of the
    termination. See [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") for a description of other attributes.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 优化结果表示为 `OptimizeResult` 对象。重要属性包括：`x` 解数组，`success` 表示优化器是否成功退出的布尔标志，`message`
    描述终止原因。请参阅 [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") 了解其他属性的描述。
- en: See also
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`minimize_scalar`](scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar")'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[`minimize_scalar`](scipy.optimize.minimize_scalar.html#scipy.optimize.minimize_scalar
    "scipy.optimize.minimize_scalar") 标量函数最小化接口。'
- en: Interface to minimization algorithms for scalar univariate functions
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标量单变量函数最小化算法接口
- en: '[`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[`show_options`](scipy.optimize.show_options.html#scipy.optimize.show_options
    "scipy.optimize.show_options") 函数显示选项。'
- en: Additional options accepted by the solvers
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 求解器接受的额外选项
- en: Notes
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: This section describes the available solvers that can be selected by the ‘method’
    parameter. The default method is *BFGS*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述可以通过 'method' 参数选择的可用求解器。默认方法为 *BFGS*。
- en: '**Unconstrained minimization**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**无约束最小化**'
- en: Method [CG](../optimize.minimize-cg.html#optimize-minimize-cg) uses a nonlinear
    conjugate gradient algorithm by Polak and Ribiere, a variant of the Fletcher-Reeves
    method described in [[5]](#rdd2e1855725e-5) pp.120-122\. Only the first derivatives
    are used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [CG](../optimize.minimize-cg.html#optimize-minimize-cg) 使用 Polak 和 Ribiere
    的非线性共轭梯度算法，是 Fletcher-Reeves 方法的变种，详见 [[5]](#rdd2e1855725e-5) pp.120-122\. 仅使用一阶导数。
- en: Method [BFGS](../optimize.minimize-bfgs.html#optimize-minimize-bfgs) uses the
    quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno (BFGS) [[5]](#rdd2e1855725e-5)
    pp. 136\. It uses the first derivatives only. BFGS has proven good performance
    even for non-smooth optimizations. This method also returns an approximation of
    the Hessian inverse, stored as *hess_inv* in the OptimizeResult object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [BFGS](../optimize.minimize-bfgs.html#optimize-minimize-bfgs) 使用 Broyden、Fletcher、Goldfarb
    和 Shanno（BFGS）拟牛顿法 [[5]](#rdd2e1855725e-5) pp. 136\. 仅使用一阶导数。即使在非平滑优化中，BFGS 也表现良好。此方法还返回存储在
    OptimizeResult 对象的 *hess_inv* 中的海森矩阵逆的近似值。
- en: Method [Newton-CG](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
    uses a Newton-CG algorithm [[5]](#rdd2e1855725e-5) pp. 168 (also known as the
    truncated Newton method). It uses a CG method to the compute the search direction.
    See also *TNC* method for a box-constrained minimization with a similar algorithm.
    Suitable for large-scale problems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [Newton-CG](../optimize.minimize-newtoncg.html#optimize-minimize-newtoncg)
    使用 Newton-CG 算法 [[5]](#rdd2e1855725e-5) pp. 168（也称为截断牛顿法）。它使用共轭梯度方法计算搜索方向。参见 *TNC*
    方法，该方法类似，但适用于有边界约束的最小化问题。适用于大规模问题。
- en: Method [dogleg](../optimize.minimize-dogleg.html#optimize-minimize-dogleg) uses
    the dog-leg trust-region algorithm [[5]](#rdd2e1855725e-5) for unconstrained minimization.
    This algorithm requires the gradient and Hessian; furthermore the Hessian is required
    to be positive definite.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [dogleg](../optimize.minimize-dogleg.html#optimize-minimize-dogleg) 使用狗腿信任域算法
    [[5]](#rdd2e1855725e-5) 进行无约束最小化。该算法需要梯度和海森矩阵；此外，海森矩阵要求正定。
- en: Method [trust-ncg](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
    uses the Newton conjugate gradient trust-region algorithm [[5]](#rdd2e1855725e-5)
    for unconstrained minimization. This algorithm requires the gradient and either
    the Hessian or a function that computes the product of the Hessian with a given
    vector. Suitable for large-scale problems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [trust-ncg](../optimize.minimize-trustncg.html#optimize-minimize-trustncg)
    使用牛顿共轭梯度信任域算法 [[5]](#rdd2e1855725e-5) 进行无约束最小化。该算法需要梯度和海森矩阵或计算给定向量与海森矩阵乘积的函数。适用于大规模问题。
- en: Method [trust-krylov](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)
    uses the Newton GLTR trust-region algorithm [[14]](#rdd2e1855725e-14), [[15]](#rdd2e1855725e-15)
    for unconstrained minimization. This algorithm requires the gradient and either
    the Hessian or a function that computes the product of the Hessian with a given
    vector. Suitable for large-scale problems. On indefinite problems it requires
    usually less iterations than the *trust-ncg* method and is recommended for medium
    and large-scale problems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[trust-krylov](../optimize.minimize-trustkrylov.html#optimize-minimize-trustkrylov)使用Newton
    GLTR信赖域算法[[14]](#rdd2e1855725e-14)，[[15]](#rdd2e1855725e-15)进行无约束最小化。此算法要求梯度和Hessian矩阵或计算给定向量与Hessian矩阵乘积的函数。适用于大规模问题。在不定问题上，通常比*trust-ncg*方法需要更少的迭代，推荐用于中等和大规模问题。
- en: Method [trust-exact](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)
    is a trust-region method for unconstrained minimization in which quadratic subproblems
    are solved almost exactly [[13]](#rdd2e1855725e-13). This algorithm requires the
    gradient and the Hessian (which is *not* required to be positive definite). It
    is, in many situations, the Newton method to converge in fewer iterations and
    the most recommended for small and medium-size problems.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[trust-exact](../optimize.minimize-trustexact.html#optimize-minimize-trustexact)是一种信赖域方法，用于无约束最小化，几乎完全解决二次子问题[[13]](#rdd2e1855725e-13)。此算法要求梯度和Hessian矩阵（*不*要求为正定）。在许多情况下，这种方法收敛迭代较少，是小型和中型问题中最推荐的方法。
- en: '**Bound-Constrained minimization**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**边界约束最小化**'
- en: Method [Nelder-Mead](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)
    uses the Simplex algorithm [[1]](#rdd2e1855725e-1), [[2]](#rdd2e1855725e-2). This
    algorithm is robust in many applications. However, if numerical computation of
    derivative can be trusted, other algorithms using the first and/or second derivatives
    information might be preferred for their better performance in general.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[Nelder-Mead](../optimize.minimize-neldermead.html#optimize-minimize-neldermead)使用Simplex算法[[1]](#rdd2e1855725e-1)，[[2]](#rdd2e1855725e-2)。此算法在许多应用中表现稳健。但是，如果可以信任数值导数的计算，其他利用一阶和/或二阶导数信息的算法可能更适合于其在一般情况下的更好性能。
- en: Method [L-BFGS-B](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)
    uses the L-BFGS-B algorithm [[6]](#rdd2e1855725e-6), [[7]](#rdd2e1855725e-7) for
    bound constrained minimization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[L-BFGS-B](../optimize.minimize-lbfgsb.html#optimize-minimize-lbfgsb)使用L-BFGS-B算法[[6]](#rdd2e1855725e-6)，[[7]](#rdd2e1855725e-7)进行边界约束最小化。
- en: Method [Powell](../optimize.minimize-powell.html#optimize-minimize-powell) is
    a modification of Powell’s method [[3]](#rdd2e1855725e-3), [[4]](#rdd2e1855725e-4)
    which is a conjugate direction method. It performs sequential one-dimensional
    minimizations along each vector of the directions set (*direc* field in *options*
    and *info*), which is updated at each iteration of the main minimization loop.
    The function need not be differentiable, and no derivatives are taken. If bounds
    are not provided, then an unbounded line search will be used. If bounds are provided
    and the initial guess is within the bounds, then every function evaluation throughout
    the minimization procedure will be within the bounds. If bounds are provided,
    the initial guess is outside the bounds, and *direc* is full rank (default has
    full rank), then some function evaluations during the first iteration may be outside
    the bounds, but every function evaluation after the first iteration will be within
    the bounds. If *direc* is not full rank, then some parameters may not be optimized
    and the solution is not guaranteed to be within the bounds.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[Powell](../optimize.minimize-powell.html#optimize-minimize-powell)是Powell方法的改进[[3]](#rdd2e1855725e-3)，[[4]](#rdd2e1855725e-4)，它是一种共轭方向方法。它沿着每个方向集合的每个向量（*options*和*info*中的*direc*字段）顺序进行一维最小化，每次主最小化循环迭代时更新。函数不需要可微，也不计算导数。如果未提供边界，则将使用无界线搜索。如果提供了边界，并且初始猜测在边界内，则最小化过程中的每个函数评估都将在边界内。如果提供了边界，初始猜测超出边界，并且*direc*具有完整秩（默认具有完整秩），则第一次迭代期间的某些函数评估可能超出边界，但第一次迭代后的每个函数评估都将在边界内。如果*direc*秩不完整，则某些参数可能不会被优化，并且不能保证解在边界内。
- en: Method [TNC](../optimize.minimize-tnc.html#optimize-minimize-tnc) uses a truncated
    Newton algorithm [[5]](#rdd2e1855725e-5), [[8]](#rdd2e1855725e-8) to minimize
    a function with variables subject to bounds. This algorithm uses gradient information;
    it is also called Newton Conjugate-Gradient. It differs from the *Newton-CG* method
    described above as it wraps a C implementation and allows each variable to be
    given upper and lower bounds.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [TNC](../optimize.minimize-tnc.html#optimize-minimize-tnc) 使用截断牛顿算法[[5]](#rdd2e1855725e-5),
    [[8]](#rdd2e1855725e-8)来最小化带有变量界限的函数。此算法利用梯度信息；它也称为牛顿共轭梯度法。它与上述*Newton-CG*方法不同，因为它封装了C实现，并允许每个变量都有上限和下限。
- en: '**Constrained Minimization**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**约束最小化**'
- en: Method [COBYLA](../optimize.minimize-cobyla.html#optimize-minimize-cobyla) uses
    the Constrained Optimization BY Linear Approximation (COBYLA) method [[9]](#rdd2e1855725e-9),
    [[10]](#rdd2e1855725e-10), [[11]](#rdd2e1855725e-11). The algorithm is based on
    linear approximations to the objective function and each constraint. The method
    wraps a FORTRAN implementation of the algorithm. The constraints functions ‘fun’
    may return either a single number or an array or list of numbers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [COBYLA](../optimize.minimize-cobyla.html#optimize-minimize-cobyla) 使用约束优化BY线性近似（COBYLA）方法[[9]](#rdd2e1855725e-9),
    [[10]](#rdd2e1855725e-10), [[11]](#rdd2e1855725e-11)。该算法基于目标函数和每个约束的线性近似。该方法封装了该算法的FORTRAN实现。约束函数‘fun’可以返回单个数字或数字数组或列表。
- en: Method [SLSQP](../optimize.minimize-slsqp.html#optimize-minimize-slsqp) uses
    Sequential Least SQuares Programming to minimize a function of several variables
    with any combination of bounds, equality and inequality constraints. The method
    wraps the SLSQP Optimization subroutine originally implemented by Dieter Kraft
    [[12]](#rdd2e1855725e-12). Note that the wrapper handles infinite values in bounds
    by converting them into large floating values.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [SLSQP](../optimize.minimize-slsqp.html#optimize-minimize-slsqp) 使用顺序最小二乘编程来最小化多变量函数，可以有各种边界、等式和不等式约束的组合。该方法封装了最初由Dieter
    Kraft实现的SLSQP优化子程序[[12]](#rdd2e1855725e-12)。请注意，包装器通过将边界中的无限值转换为大浮点值来处理边界中的无限值。
- en: Method [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    is a trust-region algorithm for constrained optimization. It switches between
    two implementations depending on the problem definition. It is the most versatile
    constrained minimization algorithm implemented in SciPy and the most appropriate
    for large-scale problems. For equality constrained problems it is an implementation
    of Byrd-Omojokun Trust-Region SQP method described in [[17]](#rdd2e1855725e-17)
    and in [[5]](#rdd2e1855725e-5), p. 549\. When inequality constraints are imposed
    as well, it switches to the trust-region interior point method described in [[16]](#rdd2e1855725e-16).
    This interior point algorithm, in turn, solves inequality constraints by introducing
    slack variables and solving a sequence of equality-constrained barrier problems
    for progressively smaller values of the barrier parameter. The previously described
    equality constrained SQP method is used to solve the subproblems with increasing
    levels of accuracy as the iterate gets closer to a solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    是一种用于约束优化的信赖域算法。它根据问题定义切换两种实现方式。这是SciPy中最通用的约束最小化算法，特别适用于大规模问题。对于等式约束问题，它是Byrd-Omojokun信赖域SQP方法的实现，详见[[17]](#rdd2e1855725e-17)和[[5]](#rdd2e1855725e-5)，第549页。当还有不等式约束时，它切换到信赖域内点法，详见[[16]](#rdd2e1855725e-16)。这种内点算法通过引入松弛变量并解决一系列逐渐减小的约束问题，以逐步减小的障碍参数。先前描述的等式约束SQP方法用于解决越来越精确的子问题，因为迭代逐渐接近解决方案。
- en: '**Finite-Difference Options**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限差分期权**'
- en: 'For Method [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    the gradient and the Hessian may be approximated using three finite-difference
    schemes: {‘2-point’, ‘3-point’, ‘cs’}. The scheme ‘cs’ is, potentially, the most
    accurate but it requires the function to correctly handle complex inputs and to
    be differentiable in the complex plane. The scheme ‘3-point’ is more accurate
    than ‘2-point’ but requires twice as many operations. If the gradient is estimated
    via finite-differences the Hessian must be estimated using one of the quasi-Newton
    strategies.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法 [trust-constr](../optimize.minimize-trustconstr.html#optimize-minimize-trustconstr)
    ，可以使用三种有限差分方案来近似梯度和海森矩阵：{‘2-point’, ‘3-point’, ‘cs’}。方案 ‘cs’ 可能是最精确的，但它要求函数能够正确处理复杂输入并在复平面上可微分。方案
    ‘3-point’ 比 ‘2-point’ 更精确，但需要两倍的操作。如果通过有限差分法估计梯度，则必须使用一种拟牛顿策略来估计海森矩阵。
- en: '**Method specific options for the** *hess* **keyword**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于** *hess* **关键字的方法特定选项**'
- en: '| method/Hess | None | callable | ‘2-point/’3-point’/’cs’ | HUS |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| method/Hess | None | callable | ‘2-point/’3-point’/’cs’ | HUS |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Newton-CG | x | (n, n) LO | x | x |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| Newton-CG | x | (n, n) LO | x | x |'
- en: '| dogleg |  | (n, n) |  |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| dogleg |  | (n, n) |  |  |'
- en: '| trust-ncg |  | (n, n) | x | x |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| trust-ncg |  | (n, n) | x | x |'
- en: '| trust-krylov |  | (n, n) | x | x |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| trust-krylov |  | (n, n) | x | x |'
- en: '| trust-exact |  | (n, n) |  |  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| trust-exact |  | (n, n) |  |  |'
- en: '| trust-constr | x | (n, n) LO sp | x | x |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| trust-constr | x | (n, n) LO sp | x | x |'
- en: where LO=LinearOperator, sp=Sparse matrix, HUS=HessianUpdateStrategy
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 LO=LinearOperator，sp=Sparse matrix，HUS=HessianUpdateStrategy
- en: '**Custom minimizers**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义最小化器**'
- en: It may be useful to pass a custom minimization method, for example when using
    a frontend to this method such as [`scipy.optimize.basinhopping`](scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping") or a different library. You can simply pass a callable
    as the `method` parameter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可能在使用此方法的前端（例如[`scipy.optimize.basinhopping`](scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping")）或其他库时，传递自定义的最小化方法可能很有用。您可以简单地将可调用对象作为`method`参数传递。
- en: The callable is called as `method(fun, x0, args, **kwargs, **options)` where
    `kwargs` corresponds to any other parameters passed to [`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize") (such as *callback*, *hess*, etc.), except the *options*
    dict, which has its contents also passed as *method* parameters pair by pair.
    Also, if *jac* has been passed as a bool type, *jac* and *fun* are mangled so
    that *fun* returns just the function values and *jac* is converted to a function
    returning the Jacobian. The method shall return an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象被调用为 `method(fun, x0, args, **kwargs, **options)`，其中 `kwargs` 对应于传递给[`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize")的任何其他参数（如 *callback*, *hess* 等），除了 *options* 字典，其内容也会逐对传递为
    *method* 参数。此外，如果 *jac* 被传递为布尔类型，则 *jac* 和 *fun* 将被篡改，使 *fun* 仅返回函数值，而 *jac* 被转换为返回雅可比矩阵的函数。该方法应返回一个[`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")对象。
- en: The provided *method* callable must be able to accept (and possibly ignore)
    arbitrary parameters; the set of parameters accepted by [`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize") may expand in future versions and then these parameters
    will be passed to the method. You can find an example in the scipy.optimize tutorial.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 *method* 可调用对象必须能够接受（并可能忽略）任意参数；由于[`minimize`](#scipy.optimize.minimize
    "scipy.optimize.minimize")接受的参数集可能会在未来版本中扩展，这些参数将被传递给该方法。您可以在scipy.optimize教程中找到一个示例。
- en: References
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[1](#id9)]'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1](#id9)]'
- en: 'Nelder, J A, and R Mead. 1965\. A Simplex Method for Function Minimization.
    The Computer Journal 7: 308-13.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'Nelder, J A 和 R Mead. 1965\. 函数最小化的单纯形法。《计算机期刊》 7: 308-13.'
- en: '[[2](#id10)]'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2](#id10)]'
- en: 'Wright M H. 1996\. Direct search methods: Once scorned, now respectable, in
    Numerical Analysis 1995: Proceedings of the 1995 Dundee Biennial Conference in
    Numerical Analysis (Eds. D F Griffiths and G A Watson). Addison Wesley Longman,
    Harlow, UK. 191-208.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Wright M H. 1996\. 直接搜索方法：曾经被蔑视，现在倍受尊重，收录于《数值分析1995：1995年邓迪双年会数值分析会议论文集》（主编
    D F Griffiths 和 G A Watson）。Addison Wesley Longman, Harlow, UK. 191-208.
- en: '[[3](#id13)]'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[[3](#id13)]'
- en: 'Powell, M J D. 1964\. An efficient method for finding the minimum of a function
    of several variables without calculating derivatives. The Computer Journal 7:
    155-162.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'Powell, M J D. 1964\. 一种在不计算导数的情况下找到多变量函数最小值的高效方法。《计算机期刊》 7: 155-162.'
- en: '[[4](#id14)]'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[[4](#id14)]'
- en: Press W, S A Teukolsky, W T Vetterling and B P Flannery. Numerical Recipes (any
    edition), Cambridge University Press.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Press W, S A Teukolsky, W T Vetterling和B P Flannery. Numerical Recipes（任何版本），剑桥大学出版社。
- en: '[5] ([1](#id1),[2](#id2),[3](#id3),[4](#id4),[5](#id5),[6](#id15),[7](#id22),[8](#id41))'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[5] ([1](#id1),[2](#id2),[3](#id3),[4](#id4),[5](#id5),[6](#id15),[7](#id22),[8](#id41))'
- en: Nocedal, J, and S J Wright. 2006\. Numerical Optimization. Springer New York.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Nocedal, J和S J Wright. 2006.数值优化。Springer New York。
- en: '[[6](#id11)]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6](#id11)]'
- en: 'Byrd, R H and P Lu and J. Nocedal. 1995\. A Limited Memory Algorithm for Bound
    Constrained Optimization. SIAM Journal on Scientific and Statistical Computing
    16 (5): 1190-1208.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Byrd, R H和P Lu和J. Nocedal. 1995.用于有界约束优化的有限内存算法。SIAM Journal on Scientific and
    Statistical Computing 16（5）：1190-1208。
- en: '[[7](#id12)]'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7](#id12)]'
- en: 'Zhu, C and R H Byrd and J Nocedal. 1997\. L-BFGS-B: Algorithm 778: L-BFGS-B,
    FORTRAN routines for large scale bound constrained optimization. ACM Transactions
    on Mathematical Software 23 (4): 550-560.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Zhu, C和R H Byrd和J Nocedal. 1997. L-BFGS-B：算法778：L-BFGS-B，FORTRAN大规模有界约束优化的例程。ACM
    Transactions on Mathematical Software 23（4）：550-560。
- en: '[[8](#id16)]'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[[8](#id16)]'
- en: 'Nash, S G. Newton-Type Minimization Via the Lanczos Method. 1984\. SIAM Journal
    of Numerical Analysis 21: 770-778.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Nash, S G. 通过Lanczos方法的牛顿型最小化。1984. SIAM Journal of Numerical Analysis 21：770-778。
- en: '[[9](#id17)]'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[[9](#id17)]'
- en: Powell, M J D. A direct search optimization method that models the objective
    and constraint functions by linear interpolation. 1994\. Advances in Optimization
    and Numerical Analysis, eds. S. Gomez and J-P Hennart, Kluwer Academic (Dordrecht),
    51-67.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Powell, M J D. 一种直接搜索优化方法，通过线性插值模拟目标和约束函数。1994.优化和数值分析进展，主编S. Gomez和J-P Hennart，Kluwer
    Academic（Dordrecht），51-67。
- en: '[[10](#id18)]'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[[10](#id18)]'
- en: 'Powell M J D. Direct search algorithms for optimization calculations. 1998\.
    Acta Numerica 7: 287-336.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Powell M J D. 用于优化计算的直接搜索算法。1998. Acta Numerica 7：287-336。
- en: '[[11](#id19)]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[[11](#id19)]'
- en: Powell M J D. A view of algorithms for optimization without derivatives. 2007.Cambridge
    University Technical Report DAMTP 2007/NA03
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Powell M J D. 无导数优化算法概览。2007.剑桥大学技术报告DAMTP 2007/NA03
- en: '[[12](#id20)]'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[[12](#id20)]'
- en: Kraft, D. A software package for sequential quadratic programming. 1988\. Tech.
    Rep. DFVLR-FB 88-28, DLR German Aerospace Center – Institute for Flight Mechanics,
    Koln, Germany.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Kraft, D. 用于顺序二次规划的软件包。1988. Tech. Rep. DFVLR-FB 88-28，DLR German Aerospace
    Center – Institute for Flight Mechanics，Koln，Germany。
- en: '[[13](#id8)]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[[13](#id8)]'
- en: Conn, A. R., Gould, N. I., and Toint, P. L. Trust region methods. 2000\. Siam.
    pp. 169-200.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Conn, A. R., Gould, N. I.,和Toint, P. L. 信任区域方法。2000. Siam. pp. 169-200.
- en: '[[14](#id6)]'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[[14](#id6)]'
- en: 'F. Lenders, C. Kirches, A. Potschka: “trlib: A vector-free implementation of
    the GLTR method for iterative solution of the trust region problem”, [arXiv:1611.04718](https://arxiv.org/abs/1611.04718)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'F. Lenders, C. Kirches, A. Potschka: “trlib：用于迭代解决信任区域问题的无向量实现”，[arXiv:1611.04718](https://arxiv.org/abs/1611.04718)'
- en: '[[15](#id7)]'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[[15](#id7)]'
- en: 'N. Gould, S. Lucidi, M. Roma, P. Toint: “Solving the Trust-Region Subproblem
    using the Lanczos Method”, SIAM J. Optim., 9(2), 504–525, (1999).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'N. Gould, S. Lucidi, M. Roma, P. Toint: “使用Lanczos方法解决信任区域子问题”，SIAM J. Optim.,
    9(2), 504–525, (1999).'
- en: '[[16](#id23)]'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[[16](#id23)]'
- en: 'Byrd, Richard H., Mary E. Hribar, and Jorge Nocedal. 1999. An interior point
    algorithm for large-scale nonlinear programming. SIAM Journal on Optimization
    9.4: 877-900.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Byrd, Richard H., Mary E. Hribar和Jorge Nocedal. 1999.大规模非线性规划的内点算法。SIAM Journal
    on Optimization 9.4：877-900。
- en: '[[17](#id21)]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[[17](#id21)]'
- en: 'Lalee, Marucha, Jorge Nocedal, and Todd Plantega. 1998\. On the implementation
    of an algorithm for large-scale equality constrained optimization. SIAM Journal
    on Optimization 8.3: 682-706.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Lalee, Marucha，Jorge Nocedal和Todd Plantega. 1998.关于大规模等式约束优化算法的实现。SIAM Journal
    on Optimization 8.3：682-706。
- en: Examples
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: Let us consider the problem of minimizing the Rosenbrock function. This function
    (and its respective derivatives) is implemented in [`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen
    "scipy.optimize.rosen") (resp. [`rosen_der`](scipy.optimize.rosen_der.html#scipy.optimize.rosen_der
    "scipy.optimize.rosen_der"), [`rosen_hess`](scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess
    "scipy.optimize.rosen_hess")) in the [`scipy.optimize`](../optimize.html#module-scipy.optimize
    "scipy.optimize").
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑最小化Rosenbrock函数的问题。该函数（及其相应的导数）在[`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen
    "scipy.optimize.rosen")（分别在[`rosen_der`](scipy.optimize.rosen_der.html#scipy.optimize.rosen_der
    "scipy.optimize.rosen_der")，[`rosen_hess`](scipy.optimize.rosen_hess.html#scipy.optimize.rosen_hess
    "scipy.optimize.rosen_hess")中实现）中。[`scipy.optimize`](../optimize.html#module-scipy.optimize
    "scipy.optimize")。
- en: '[PRE1]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A simple application of the *Nelder-Mead* method is:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nelder-Mead*方法的一个简单应用是：'
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now using the *BFGS* algorithm, using the first derivative and a few options:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用*BFGS*算法，使用第一阶导数和一些选项：
- en: '[PRE3]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, consider a minimization problem with several constraints (namely Example
    16.4 from [[5]](#rdd2e1855725e-5)). The objective function is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑一个带有多个约束条件的最小化问题（即来自[[5]](#rdd2e1855725e-5)的示例16.4）。目标函数是：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are three constraints defined as:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个定义为约束条件：
- en: '[PRE5]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And variables must be positive, hence the following bounds:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须为正数，因此以下是界限：
- en: '[PRE6]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The optimization problem is solved using the SLSQP method as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题使用SLSQP方法求解如下：
- en: '[PRE7]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It should converge to the theoretical solution (1.4 ,1.7).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该收敛到理论解（1.4, 1.7）。
