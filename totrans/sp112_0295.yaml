- en: scipy.linalg.cossin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.cossin.html#scipy.linalg.cossin](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.cossin.html#scipy.linalg.cossin)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'X is an `(m, m)` orthogonal/unitary matrix, partitioned as the following where
    upper left block has the shape of `(p, q)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`U1`, `U2`, `V1`, `V2` are square orthogonal/unitary matrices of dimensions
    `(p,p)`, `(m-p,m-p)`, `(q,q)`, and `(m-q,m-q)` respectively, and `C` and `S` are
    `(r, r)` nonnegative diagonal matrices satisfying `C^2 + S^2 = I` where `r = min(p,
    m-p, q, m-q)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the rank of the identity matrices are `min(p, q) - r`, `min(p, m -
    q) - r`, `min(m - p, q) - r`, and `min(m - p, m - q) - r` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: X can be supplied either by itself and block specifications p, q or its subblocks
    in an iterable from which the shapes would be derived. See the examples below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X**array_like, iterable'
  prefs: []
  type: TYPE_NORMAL
- en: complex unitary or real orthogonal matrix to be decomposed, or iterable of subblocks
    `X11`, `X12`, `X21`, `X22`, when `p`, `q` are omitted.
  prefs: []
  type: TYPE_NORMAL
- en: '**p**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of rows of the upper left block `X11`, used only when X is given as an
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '**q**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of columns of the upper left block `X11`, used only when X is given as
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: '**separate**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: if `True`, the low level components are returned instead of the matrix factors,
    i.e. `(u1,u2)`, `theta`, `(v1h,v2h)` instead of `u`, `cs`, `vh`.
  prefs: []
  type: TYPE_NORMAL
- en: '**swap_sign**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: if `True`, the `-S`, `-I` block will be the bottom left, otherwise (by default)
    they will be in the upper right block.
  prefs: []
  type: TYPE_NORMAL
- en: '**compute_u**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: if `False`, `u` won’t be computed and an empty array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**compute_vh**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: if `False`, `vh` won’t be computed and an empty array is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**u**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: When `compute_u=True`, contains the block diagonal orthogonal/unitary matrix
    consisting of the blocks `U1` (`p` x `p`) and `U2` (`m-p` x `m-p`) orthogonal/unitary
    matrices. If `separate=True`, this contains the tuple of `(U1, U2)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**cs**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The cosine-sine factor with the structure described above.
  prefs: []
  type: TYPE_NORMAL
- en: If `separate=True`, this contains the `theta` array containing the angles in
    radians.
  prefs: []
  type: TYPE_NORMAL
- en: '**vh**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: When [PRE2] (`q` x `q`) and `V2H` (`m-q` x `m-q`) orthogonal/unitary matrices.
    If `separate=True`, this contains the tuple of `(V1H, V2H)`.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: Brian D. Sutton. Computing the complete CS decomposition. Numer. Algorithms,
    50(1):33-65, 2009.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Same can be entered via subblocks without the need of `p` and `q`. Also let’s
    skip the computation of `u`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
