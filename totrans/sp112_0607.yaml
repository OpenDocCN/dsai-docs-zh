- en: scipy.integrate.odeint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Integrate a system of ordinary differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For new code, use [`scipy.integrate.solve_ivp`](scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") to solve a differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: Solve a system of ordinary differential equations using lsoda from the FORTRAN
    library odepack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solves the initial value problem for stiff or non-stiff systems of first order
    ode-s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where y can be a vector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, the required order of the first two arguments of *func* are in the
    opposite order of the arguments in the system definition function used by the
    [`scipy.integrate.ode`](scipy.integrate.ode.html#scipy.integrate.ode "scipy.integrate.ode")
    class and the function [`scipy.integrate.solve_ivp`](scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"). To use a function with the signature `func(t, y,
    ...)`, the argument *tfirst* must be set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable(y, t, …) or callable(t, y, …)'
  prefs: []
  type: TYPE_NORMAL
- en: Computes the derivative of y at t. If the signature is `callable(t, y, ...)`,
    then the argument *tfirst* must be set `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '**y0**array'
  prefs: []
  type: TYPE_NORMAL
- en: Initial condition on y (can be a vector).
  prefs: []
  type: TYPE_NORMAL
- en: '**t**array'
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of time points for which to solve for y. The initial value point
    should be the first element of this sequence. This sequence must be monotonically
    increasing or monotonically decreasing; repeated values are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments to pass to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dfun**callable(y, t, …) or callable(t, y, …)'
  prefs: []
  type: TYPE_NORMAL
- en: Gradient (Jacobian) of *func*. If the signature is `callable(t, y, ...)`, then
    the argument *tfirst* must be set `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '**col_deriv**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: True if *Dfun* defines derivatives down columns (faster), otherwise *Dfun* should
    define derivatives across rows.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: True if to return a dictionary of optional outputs as the second output
  prefs: []
  type: TYPE_NORMAL
- en: '**printmessg**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to print the convergence message
  prefs: []
  type: TYPE_NORMAL
- en: '**tfirst**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, the first two arguments of *func* (and *Dfun*, if given) must `t, y`
    instead of the default `y, t`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**y**array, shape (len(t), len(y0))'
  prefs: []
  type: TYPE_NORMAL
- en: Array containing the value of y for each desired time in t, with the initial
    value *y0* in the first row.
  prefs: []
  type: TYPE_NORMAL
- en: '**infodict**dict, only returned if full_output == True'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary containing additional output information
  prefs: []
  type: TYPE_NORMAL
- en: '| key | meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ‘hu’ | vector of step sizes successfully used for each time step |'
  prefs: []
  type: TYPE_TB
- en: '| ‘tcur’ | vector with the value of t reached for each time step (will always
    be at least as large as the input times) |'
  prefs: []
  type: TYPE_TB
- en: '| ‘tolsf’ | vector of tolerance scale factors, greater than 1.0, computed when
    a request for too much accuracy was detected |'
  prefs: []
  type: TYPE_TB
- en: '| ‘tsw’ | value of t at the time of the last method switch (given for each
    time step) |'
  prefs: []
  type: TYPE_TB
- en: '| ‘nst’ | cumulative number of time steps |'
  prefs: []
  type: TYPE_TB
- en: '| ‘nfe’ | cumulative number of function evaluations for each time step |'
  prefs: []
  type: TYPE_TB
- en: '| ‘nje’ | cumulative number of jacobian evaluations for each time step |'
  prefs: []
  type: TYPE_TB
- en: '| ‘nqu’ | a vector of method orders for each successful step |'
  prefs: []
  type: TYPE_TB
- en: '| ‘imxer’ | index of the component of largest magnitude in the weighted local
    error vector (e / ewt) on an error return, -1 otherwise |'
  prefs: []
  type: TYPE_TB
- en: '| ‘lenrw’ | the length of the double work array required |'
  prefs: []
  type: TYPE_TB
- en: '| ‘leniw’ | the length of integer work array required |'
  prefs: []
  type: TYPE_TB
- en: '| ‘mused’ | a vector of method indicators for each successful time step: 1:
    adams (nonstiff), 2: bdf (stiff) |'
  prefs: []
  type: TYPE_TB
- en: 'Other Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ml, mu**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If either of these are not None or non-negative, then the Jacobian is assumed
    to be banded. These give the number of lower and upper non-zero diagonals in this
    banded matrix. For the banded case, *Dfun* should return a matrix whose rows contain
    the non-zero bands (starting with the lowest diagonal). Thus, the return matrix
    *jac* from *Dfun* should have shape `(ml + mu + 1, len(y0))` when `ml >=0` or
    `mu >=0`. The data in *jac* must be stored such that `jac[i - j + mu, j]` holds
    the derivative of the `i`th equation with respect to the `j`th state variable.
    If *col_deriv* is True, the transpose of this *jac* must be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol, atol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The input parameters *rtol* and *atol* determine the error control performed
    by the solver. The solver will control the vector, e, of estimated local errors
    in y, according to an inequality of the form `max-norm of (e / ewt) <= 1`, where
    ewt is a vector of positive error weights computed as `ewt = rtol * abs(y) + atol`.
    rtol and atol can be either vectors the same length as y or scalars. Defaults
    to 1.49012e-8.
  prefs: []
  type: TYPE_NORMAL
- en: '**tcrit**ndarray, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Vector of critical points (e.g., singularities) where integration care should
    be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '**h0**float, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: The step size to be attempted on the first step.
  prefs: []
  type: TYPE_NORMAL
- en: '**hmax**float, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum absolute step size allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '**hmin**float, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum absolute step size allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '**ixpr**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to generate extra printing at method switches.
  prefs: []
  type: TYPE_NORMAL
- en: '**mxstep**int, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of (internally defined) steps allowed for each integration point
    in t.
  prefs: []
  type: TYPE_NORMAL
- en: '**mxhnil**int, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of messages printed.
  prefs: []
  type: TYPE_NORMAL
- en: '**mxordn**int, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum order to be allowed for the non-stiff (Adams) method.
  prefs: []
  type: TYPE_NORMAL
- en: '**mxords**int, (0: solver-determined), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum order to be allowed for the stiff (BDF) method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve_ivp`](scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp "scipy.integrate.solve_ivp")'
  prefs: []
  type: TYPE_NORMAL
- en: solve an initial value problem for a system of ODEs
  prefs: []
  type: TYPE_NORMAL
- en: '[`ode`](scipy.integrate.ode.html#scipy.integrate.ode "scipy.integrate.ode")'
  prefs: []
  type: TYPE_NORMAL
- en: a more object-oriented integrator based on VODE
  prefs: []
  type: TYPE_NORMAL
- en: '[`quad`](scipy.integrate.quad.html#scipy.integrate.quad "scipy.integrate.quad")'
  prefs: []
  type: TYPE_NORMAL
- en: for finding the area under a curve
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'The second order differential equation for the angle *theta* of a pendulum
    acted on by gravity with friction can be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'where *b* and *c* are positive constants, and a prime (’) denotes a derivative.
    To solve this equation with [`odeint`](#scipy.integrate.odeint "scipy.integrate.odeint"),
    we must first convert it to a system of first order equations. By defining the
    angular velocity `omega(t) = theta''(t)`, we obtain the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let *y* be the vector [*theta*, *omega*]. We implement this system in Python
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We assume the constants are *b* = 0.25 and *c* = 5.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For initial conditions, we assume the pendulum is nearly vertical with *theta(0)*
    = *pi* - 0.1, and is initially at rest, so *omega(0)* = 0\. Then the vector of
    initial conditions is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will generate a solution at 101 evenly spaced samples in the interval 0
    <= *t* <= 10\. So our array of times is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Call [`odeint`](#scipy.integrate.odeint "scipy.integrate.odeint") to generate
    the solution. To pass the parameters *b* and *c* to *pend*, we give them to [`odeint`](#scipy.integrate.odeint
    "scipy.integrate.odeint") using the *args* argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The solution is an array with shape (101, 2). The first column is *theta(t)*,
    and the second is *omega(t)*. The following code plots both components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-integrate-odeint-1.png](../Images/edb06c2ae7ec4c56b9fae3ee1ee06c49.png)'
  prefs: []
  type: TYPE_IMG
