["```py\nclass sympy.utilities.iterables.NotIterable\n```", "```py\nsympy.utilities.iterables.binary_partitions(n)\n```", "```py\n>>> from sympy.utilities.iterables import binary_partitions\n>>> for i in binary_partitions(5):\n...     print(i)\n...\n[4, 1]\n[2, 2, 1]\n[2, 1, 1, 1]\n[1, 1, 1, 1, 1] \n```", "```py\nsympy.utilities.iterables.bracelets(n, k)\n```", "```py\nsympy.utilities.iterables.capture(func)\n```", "```py\n>>> from sympy.utilities.iterables import capture\n>>> from sympy import pprint\n>>> from sympy.abc import x\n>>> def foo():\n...     print('hello world!')\n...\n>>> 'hello' in capture(foo) # foo, not foo()\nTrue\n>>> capture(lambda: pprint(2/x))\n'2\\n-\\nx\\n' \n```", "```py\nsympy.utilities.iterables.common_prefix(*seqs)\n```", "```py\n>>> from sympy.utilities.iterables import common_prefix\n>>> common_prefix(list(range(3)))\n[0, 1, 2]\n>>> common_prefix(list(range(3)), list(range(4)))\n[0, 1, 2]\n>>> common_prefix([1, 2, 3], [1, 2, 5])\n[1, 2]\n>>> common_prefix([1, 2, 3], [1, 3, 5])\n[1] \n```", "```py\nsympy.utilities.iterables.common_suffix(*seqs)\n```", "```py\n>>> from sympy.utilities.iterables import common_suffix\n>>> common_suffix(list(range(3)))\n[0, 1, 2]\n>>> common_suffix(list(range(3)), list(range(4)))\n[]\n>>> common_suffix([1, 2, 3], [9, 2, 3])\n[2, 3]\n>>> common_suffix([1, 2, 3], [9, 7, 3])\n[3] \n```", "```py\nsympy.utilities.iterables.connected_components(G)\n```", "```py\ngraph {\n    A -- B\n    C -- D\n} \n```", "```py\n>>> from sympy.utilities.iterables import connected_components\n\n>>> V = ['A', 'B', 'C', 'D']\n>>> E = [('A', 'B'), ('B', 'A'), ('C', 'D'), ('D', 'C')]\n>>> connected_components((V, E))\n[['A', 'B'], ['C', 'D']] \n```", "```py\nsympy.utilities.iterables.dict_merge(*dicts)\n```", "```py\nsympy.utilities.iterables.filter_symbols(iterator, exclude)\n```", "```py\nsympy.utilities.iterables.flatten(iterable, levels=None, cls=None)\n```", "```py\n>>> from sympy import flatten \n```", "```py\n>>> flatten([1, 2, 3])\n[1, 2, 3]\n>>> flatten([1, 2, [3]])\n[1, 2, 3]\n>>> flatten([1, [2, 3], [4, 5]])\n[1, 2, 3, 4, 5]\n>>> flatten([1.0, 2, (1, None)])\n[1.0, 2, 1, None] \n```", "```py\n>>> ls = [[(-2, -1), (1, 2)], [(0, 0)]] \n```", "```py\n>>> flatten(ls, levels=1)\n[(-2, -1), (1, 2), (0, 0)] \n```", "```py\n>>> from sympy import Basic, S\n>>> class MyOp(Basic):\n...     pass\n...\n>>> flatten([MyOp(S(1), MyOp(S(2), S(3)))], cls=MyOp)\n[1, 2, 3] \n```", "```py\nsympy.utilities.iterables.generate_bell(n)\n```", "```py\n>>> from itertools import permutations\n>>> from sympy.utilities.iterables import generate_bell\n>>> from sympy import zeros, Matrix \n```", "```py\n>>> list(permutations(range(4)))[:5]\n[(0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1), (0, 3, 1, 2)]\n>>> list(generate_bell(4))[:5]\n[(0, 1, 2, 3), (0, 1, 3, 2), (0, 3, 1, 2), (3, 0, 1, 2), (3, 0, 2, 1)] \n```", "```py\n>>> m = zeros(4, 24)\n>>> for i, p in enumerate(generate_bell(4)):\n...     m[:, i] = Matrix([j - 3 for j in list(p)])  # make largest zero\n>>> m.print_nonzero('X')\n[XXX  XXXXXX  XXXXXX  XXX]\n[XX XX XXXX XX XXXX XX XX]\n[X XXXX XX XXXX XX XXXX X]\n[ XXXXXX  XXXXXX  XXXXXX ] \n```", "```py\nsympy.utilities.iterables.generate_derangements(s)\n```", "```py\n>>> from sympy.utilities.iterables import generate_derangements\n>>> list(generate_derangements([0, 1, 2]))\n[[1, 2, 0], [2, 0, 1]]\n>>> list(generate_derangements([0, 1, 2, 2]))\n[[2, 2, 0, 1], [2, 2, 1, 0]]\n>>> list(generate_derangements([0, 1, 1]))\n[] \n```", "```py\nsympy.utilities.iterables.generate_involutions(n)\n```", "```py\n>>> from sympy.utilities.iterables import generate_involutions\n>>> list(generate_involutions(3))\n[(0, 1, 2), (0, 2, 1), (1, 0, 2), (2, 1, 0)]\n>>> len(list(generate_involutions(4)))\n10 \n```", "```py\nsympy.utilities.iterables.generate_oriented_forest(n)\n```", "```py\n>>> from sympy.utilities.iterables import generate_oriented_forest\n>>> list(generate_oriented_forest(4))\n[[0, 1, 2, 3], [0, 1, 2, 2], [0, 1, 2, 1], [0, 1, 2, 0],     [0, 1, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]] \n```", "```py\nsympy.utilities.iterables.group(seq, multiple=True)\n```", "```py\n>>> from sympy import group \n```", "```py\n>>> group([1, 1, 1, 2, 2, 3])\n[[1, 1, 1], [2, 2], [3]]\n>>> group([1, 1, 1, 2, 2, 3], multiple=False)\n[(1, 3), (2, 2), (3, 1)]\n>>> group([1, 1, 3, 2, 2, 1], multiple=False)\n[(1, 2), (3, 1), (2, 2), (1, 1)] \n```", "```py\nsympy.utilities.iterables.has_dups(seq)\n```", "```py\n>>> from sympy import has_dups, Dict, Set\n>>> has_dups((1, 2, 1))\nTrue\n>>> has_dups(range(3))\nFalse\n>>> all(has_dups(c) is False for c in (set(), Set(), dict(), Dict()))\nTrue \n```", "```py\nsympy.utilities.iterables.has_variety(seq)\n```", "```py\n>>> from sympy import has_variety \n```", "```py\n>>> has_variety((1, 2, 1))\nTrue\n>>> has_variety((1, 1, 1))\nFalse \n```", "```py\nsympy.utilities.iterables.ibin(n, bits=None, str=False)\n```", "```py\n>>> from sympy.utilities.iterables import ibin\n>>> ibin(2)\n[1, 0]\n>>> ibin(2, 4)\n[0, 0, 1, 0] \n```", "```py\n>>> bits = 2\n>>> for i in ibin(2, 'all'):\n...     print(i)\n(0, 0)\n(0, 1)\n(1, 0)\n(1, 1) \n```", "```py\n>>> n = 123\n>>> bits = 10\n>>> ibin(n, bits, str=True)\n'0001111011'\n>>> ibin(n, bits, str=True)[::-1]  # small bits left\n'1101111000'\n>>> list(ibin(3, 'all', str=True))\n['000', '001', '010', '011', '100', '101', '110', '111'] \n```", "```py\nsympy.utilities.iterables.iproduct(*iterables)\n```", "```py\n>>> from sympy.utilities.iterables import iproduct\n>>> sorted(iproduct([1,2], [3,4]))\n[(1, 3), (1, 4), (2, 3), (2, 4)] \n```", "```py\n>>> from sympy import S\n>>> (3,) in iproduct(S.Integers)\nTrue\n>>> (3, 4) in iproduct(S.Integers, S.Integers)\nTrue \n```", "```py\nsympy.utilities.iterables.is_palindromic(s, i=0, j=None)\n```", "```py\n>>> from sympy.utilities.iterables import is_palindromic\n>>> is_palindromic([1, 0, 1])\nTrue\n>>> is_palindromic('abcbb')\nFalse\n>>> is_palindromic('abcbb', 1)\nFalse \n```", "```py\n>>> is_palindromic('abcbb', 1, -1)\nTrue\n>>> is_palindromic('abcbb', -4, -1)\nTrue \n```", "```py\nsympy.utilities.iterables.is_sequence(i, include=None)\n```", "```py\n>>> from sympy.utilities.iterables import is_sequence\n>>> from types import GeneratorType\n>>> is_sequence([])\nTrue\n>>> is_sequence(set())\nFalse\n>>> is_sequence('abc')\nFalse\n>>> is_sequence('abc', include=str)\nTrue\n>>> generator = (c for c in 'abc')\n>>> is_sequence(generator)\nFalse\n>>> is_sequence(generator, include=(str, GeneratorType))\nTrue \n```", "```py\nsympy.utilities.iterables.iterable(i, exclude=(<class 'str'>, <class 'dict'>, <class 'sympy.utilities.iterables.NotIterable'>))\n```", "```py\n>>> from sympy.utilities.iterables import iterable\n>>> from sympy import Tuple\n>>> things = [[1], (1,), set([1]), Tuple(1), (j for j in [1, 2]), {1:2}, '1', 1]\n>>> for i in things:\n...     print('%s  %s' % (iterable(i), type(i)))\nTrue <... 'list'>\nTrue <... 'tuple'>\nTrue <... 'set'>\nTrue <class 'sympy.core.containers.Tuple'>\nTrue <... 'generator'>\nFalse <... 'dict'>\nFalse <... 'str'>\nFalse <... 'int'> \n```", "```py\n>>> iterable({}, exclude=None)\nTrue\n>>> iterable({}, exclude=str)\nTrue\n>>> iterable(\"no\", exclude=str)\nFalse \n```", "```py\nsympy.utilities.iterables.kbins(l, k, ordered=None)\n```", "```py\n>>> from sympy.utilities.iterables import kbins\n>>> for p in kbins(list(range(5)), 2):\n...     print(p)\n...\n[[0], [1, 2, 3, 4]]\n[[0, 1], [2, 3, 4]]\n[[0, 1, 2], [3, 4]]\n[[0, 1, 2, 3], [4]] \n```", "```py\nA = [[0], [1, 2]]\nB = [[1, 2], [0]]\nC = [[2, 1], [0]]\nD = [[0], [2, 1]] \n```", "```py\n00 means A == B == C == D\n01 means A == B\n10 means A == D\n11 means A == A \n```", "```py\n>>> for ordered_flag in [None, 0, 1, 10, 11]:\n...     print('ordered = %s' % ordered_flag)\n...     for p in kbins(list(range(3)), 2, ordered=ordered_flag):\n...         print(' %s' % p)\n...\nordered = None\n [[0], [1, 2]]\n [[0, 1], [2]]\nordered = 0\n [[0, 1], [2]]\n [[0, 2], [1]]\n [[0], [1, 2]]\nordered = 1\n [[0], [1, 2]]\n [[0], [2, 1]]\n [[1], [0, 2]]\n [[1], [2, 0]]\n [[2], [0, 1]]\n [[2], [1, 0]]\nordered = 10\n [[0, 1], [2]]\n [[2], [0, 1]]\n [[0, 2], [1]]\n [[1], [0, 2]]\n [[0], [1, 2]]\n [[1, 2], [0]]\nordered = 11\n [[0], [1, 2]]\n [[0, 1], [2]]\n [[0], [2, 1]]\n [[0, 2], [1]]\n [[1], [0, 2]]\n [[1, 0], [2]]\n [[1], [2, 0]]\n [[1, 2], [0]]\n [[2], [0, 1]]\n [[2, 0], [1]]\n [[2], [1, 0]]\n [[2, 1], [0]] \n```", "```py\nsympy.utilities.iterables.least_rotation(x, key=None)\n```", "```py\n>>> from sympy.utilities.iterables import least_rotation, rotate_left\n>>> a = [3, 1, 5, 1, 2]\n>>> least_rotation(a)\n3\n>>> rotate_left(a, _)\n[1, 2, 3, 1, 5] \n```", "```py\nsympy.utilities.iterables.minlex(seq, directed=True, key=None)\n```", "```py\n>>> from sympy.combinatorics.polyhedron import minlex\n>>> minlex((1, 2, 0))\n(0, 1, 2)\n>>> minlex((1, 0, 2))\n(0, 2, 1)\n>>> minlex((1, 0, 2), directed=False)\n(0, 1, 2) \n```", "```py\n>>> minlex('11010011000', directed=True)\n'00011010011'\n>>> minlex('11010011000', directed=False)\n'00011001011' \n```", "```py\n>>> minlex(('bb', 'aaa', 'c', 'a'))\n('a', 'bb', 'aaa', 'c')\n>>> minlex(('bb', 'aaa', 'c', 'a'), key=len)\n('c', 'a', 'bb', 'aaa') \n```", "```py\nsympy.utilities.iterables.multiset(seq)\n```", "```py\n>>> from sympy.utilities.iterables import multiset\n>>> multiset('mississippi')\n{'i': 4, 'm': 1, 'p': 2, 's': 4} \n```", "```py\nsympy.utilities.iterables.multiset_combinations(m, n, g=None)\n```", "```py\n>>> from sympy.utilities.iterables import multiset_combinations\n>>> from itertools import combinations\n>>> [''.join(i) for i in  multiset_combinations('baby', 3)]\n['abb', 'aby', 'bby'] \n```", "```py\n>>> def count(f, s): return len(list(f(s, 3))) \n```", "```py\n>>> s1 = 'abracadabra'\n>>> s2 = 'banana tree'\n>>> count(combinations, s1), count(multiset_combinations, s1)\n(165, 23)\n>>> count(combinations, s2), count(multiset_combinations, s2)\n(165, 54) \n```", "```py\nsympy.utilities.iterables.multiset_derangements(s)\n```", "```py\n>>> from sympy.utilities.iterables import multiset_derangements, uniq \n```", "```py\n>>> list(uniq([i for i in multiset_derangements('1233')]))\n[[None, None, None, None]]\n>>> [i.copy() for i in multiset_derangements('1233')]\n[['3', '3', '1', '2'], ['3', '3', '2', '1']]\n>>> [''.join(i) for i in multiset_derangements('1233')]\n['3312', '3321'] \n```", "```py\nsympy.utilities.iterables.multiset_partitions(multiset, m=None)\n```", "```py\n>>> from sympy.utilities.iterables import multiset_partitions\n>>> list(multiset_partitions([1, 2, 3, 4], 2))\n[[[1, 2, 3], [4]], [[1, 2, 4], [3]], [[1, 2], [3, 4]],\n[[1, 3, 4], [2]], [[1, 3], [2, 4]], [[1, 4], [2, 3]],\n[[1], [2, 3, 4]]]\n>>> list(multiset_partitions([1, 2, 3, 4], 1))\n[[[1, 2, 3, 4]]] \n```", "```py\n>>> a = [1, 2, 2, 1]\n>>> ans = list(multiset_partitions(a, 2))\n>>> a.sort()\n>>> list(multiset_partitions(a, 2)) == ans\nTrue\n>>> a = range(3, 1, -1)\n>>> (list(multiset_partitions(a)) ==\n...  list(multiset_partitions(sorted(a))))\nTrue \n```", "```py\n>>> list(multiset_partitions([1, 1, 2]))\n[[[1, 1, 2]], [[1, 1], [2]], [[1, 2], [1]], [[1], [1], [2]]]\n>>> list(multiset_partitions([1]*3))\n[[[1, 1, 1]], [[1], [1, 1]], [[1], [1], [1]]] \n```", "```py\n>>> from sympy import bell\n>>> len(list(multiset_partitions(5))) == bell(5) == 52\nTrue \n```", "```py\n>>> from sympy.functions.combinatorial.numbers import stirling\n>>> stirling(5, 2) == len(list(multiset_partitions(5, 2))) == 15\nTrue \n```", "```py\nsympy.utilities.iterables.multiset_permutations(m, size=None, g=None)\n```", "```py\n>>> from sympy.utilities.iterables import multiset_permutations\n>>> from sympy import factorial\n>>> [''.join(i) for i in multiset_permutations('aab')]\n['aab', 'aba', 'baa']\n>>> factorial(len('banana'))\n720\n>>> len(list(multiset_permutations('banana')))\n60 \n```", "```py\nsympy.utilities.iterables.necklaces(n, k, free=False)\n```", "```py\n>>> from sympy.utilities.iterables import necklaces, bracelets\n>>> def show(s, i):\n...     return ''.join(s[j] for j in i) \n```", "```py\n>>> B = [show('ABC', i) for i in bracelets(3, 3)]\n>>> N = [show('ABC', i) for i in necklaces(3, 3)]\n>>> set(N) - set(B)\n{'ACB'} \n```", "```py\n>>> list(necklaces(4, 2))\n[(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 1, 1),\n (0, 1, 0, 1), (0, 1, 1, 1), (1, 1, 1, 1)] \n```", "```py\n>>> [show('.o', i) for i in bracelets(4, 2)]\n['....', '...o', '..oo', '.o.o', '.ooo', 'oooo'] \n```", "```py\nsympy.utilities.iterables.numbered_symbols(prefix='x', cls=None, start=0, exclude=(), *args, **assumptions)\n```", "```py\nsympy.utilities.iterables.ordered_partitions(n, m=None, sort=True)\n```", "```py\n>>> from sympy.utilities.iterables import ordered_partitions \n```", "```py\n>>> for p in ordered_partitions(5):\n...     print(p)\n[1, 1, 1, 1, 1]\n[1, 1, 1, 2]\n[1, 1, 3]\n[1, 2, 2]\n[1, 4]\n[2, 3]\n[5] \n```", "```py\n>>> for p in ordered_partitions(5, 2):\n...     print(p)\n[1, 4]\n[2, 3] \n```", "```py\n>>> [p for p in ordered_partitions(7, 3)]\n[[1, 1, 1], [1, 1, 1], [1, 1, 1], [2, 2, 2]]\n>>> [list(p) for p in ordered_partitions(7, 3)]\n[[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]] \n```", "```py\n>>> for p in ordered_partitions(6, 2):\n...     print(p)\n[1, 5]\n[2, 4]\n[3, 3] \n```", "```py\n>>> for p in ordered_partitions(6, 2, sort=False):\n...     print(p)\n[1, 5]\n[3, 3]\n[2, 4] \n```", "```py\nsympy.utilities.iterables.partitions(n, m=None, k=None, size=False)\n```", "```py\n>>> from sympy.utilities.iterables import partitions \n```", "```py\n>>> for p in partitions(6, k=2):  \n...     print(p)\n{2: 3}\n{1: 2, 2: 2}\n{1: 4, 2: 1}\n{1: 6} \n```", "```py\n>>> for p in partitions(6, m=2):  \n...     print(p)\n...\n{6: 1}\n{1: 1, 5: 1}\n{2: 1, 4: 1}\n{3: 2} \n```", "```py\nsympy.utilities.iterables.permute_signs(t)\n```", "```py\n>>> from sympy.utilities.iterables import permute_signs\n>>> list(permute_signs((0, 1, 2)))\n[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2)] \n```", "```py\nsympy.utilities.iterables.postfixes(seq)\n```", "```py\n>>> from sympy.utilities.iterables import postfixes \n```", "```py\n>>> list(postfixes([1,2,3,4]))\n[[4], [3, 4], [2, 3, 4], [1, 2, 3, 4]] \n```", "```py\nsympy.utilities.iterables.prefixes(seq)\n```", "```py\n>>> from sympy.utilities.iterables import prefixes \n```", "```py\n>>> list(prefixes([1,2,3,4]))\n[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]] \n```", "```py\nsympy.utilities.iterables.random_derangement(t, choice=None, strict=True)\n```", "```py\n>>> from sympy.utilities.iterables import random_derangement\n>>> t = 'SymPy: a CAS in pure Python'\n>>> d = random_derangement(t)\n>>> all(i != j for i, j in zip(d, t))\nTrue \n```", "```py\n>>> from sympy.core.random import seed, choice as c\n>>> seed(1)\n>>> d = [''.join(random_derangement(t, c)) for i in range(5)]\n>>> assert len(set(d)) != 1  # we got different values \n```", "```py\n>>> seed(1)\n>>> d2 = [''.join(random_derangement(t, c)) for i in range(5)]\n>>> assert d == d2 \n```", "```py\nsympy.utilities.iterables.reshape(seq, how)\n```", "```py\n>>> from sympy.utilities import reshape\n>>> seq = list(range(1, 9)) \n```", "```py\n>>> reshape(seq, [4]) # lists of 4\n[[1, 2, 3, 4], [5, 6, 7, 8]] \n```", "```py\n>>> reshape(seq, (4,)) # tuples of 4\n[(1, 2, 3, 4), (5, 6, 7, 8)] \n```", "```py\n>>> reshape(seq, (2, 2)) # tuples of 4\n[(1, 2, 3, 4), (5, 6, 7, 8)] \n```", "```py\n>>> reshape(seq, (2, [2])) # (i, i, [i, i])\n[(1, 2, [3, 4]), (5, 6, [7, 8])] \n```", "```py\n>>> reshape(seq, ((2,), [2])) # etc....\n[((1, 2), [3, 4]), ((5, 6), [7, 8])] \n```", "```py\n>>> reshape(seq, (1, [2], 1))\n[(1, [2, 3], 4), (5, [6, 7], 8)] \n```", "```py\n>>> reshape(tuple(seq), ([[1], 1, (2,)],))\n(([[1], 2, (3, 4)],), ([[5], 6, (7, 8)],)) \n```", "```py\n>>> reshape(tuple(seq), ([1], 1, (2,)))\n(([1], 2, (3, 4)), ([5], 6, (7, 8))) \n```", "```py\n>>> reshape(list(range(12)), [2, [3], {2}, (1, (3,), 1)])\n[[0, 1, [2, 3, 4], {5, 6}, (7, (8, 9, 10), 11)]] \n```", "```py\nsympy.utilities.iterables.rotate_left(x, y)\n```", "```py\n>>> from sympy.utilities.iterables import rotate_left\n>>> a = [0, 1, 2]\n>>> rotate_left(a, 1)\n[1, 2, 0] \n```", "```py\nsympy.utilities.iterables.rotate_right(x, y)\n```", "```py\n>>> from sympy.utilities.iterables import rotate_right\n>>> a = [0, 1, 2]\n>>> rotate_right(a, 1)\n[2, 0, 1] \n```", "```py\nsympy.utilities.iterables.rotations(s, dir=1)\n```", "```py\n>>> from sympy import rotations\n>>> list(rotations([1,2,3]))\n[[1, 2, 3], [2, 3, 1], [3, 1, 2]]\n>>> list(rotations([1,2,3], -1))\n[[1, 2, 3], [3, 1, 2], [2, 3, 1]] \n```", "```py\nsympy.utilities.iterables.roundrobin(*iterables)\n```", "```py\nsympy.utilities.iterables.runs(seq, op=<built-in function gt>)\n```", "```py\n>>> from sympy.utilities.iterables import runs\n>>> from operator import ge\n>>> runs([0, 1, 2, 2, 1, 4, 3, 2, 2])\n[[0, 1, 2], [2], [1, 4], [3], [2], [2]]\n>>> runs([0, 1, 2, 2, 1, 4, 3, 2, 2], op=ge)\n[[0, 1, 2, 2], [1, 4], [3], [2, 2]] \n```", "```py\nsympy.utilities.iterables.sequence_partitions(l, n, /)\n```", "```py\n>>> from sympy.utilities.iterables import sequence_partitions\n>>> for out in sequence_partitions([1, 2, 3, 4], 2):\n...     print(out)\n[[1], [2, 3, 4]]\n[[1, 2], [3, 4]]\n[[1, 2, 3], [4]] \n```", "```py\nsympy.utilities.iterables.sequence_partitions_empty(l, n, /)\n```", "```py\n>>> from sympy.utilities.iterables import sequence_partitions_empty\n>>> for out in sequence_partitions_empty([1, 2, 3, 4], 2):\n...     print(out)\n[[], [1, 2, 3, 4]]\n[[1], [2, 3, 4]]\n[[1, 2], [3, 4]]\n[[1, 2, 3], [4]]\n[[1, 2, 3, 4], []] \n```", "```py\nsympy.utilities.iterables.sift(seq, keyfunc, binary=False)\n```", "```py\n>>> from sympy.utilities import sift\n>>> from sympy.abc import x, y\n>>> from sympy import sqrt, exp, pi, Tuple \n```", "```py\n>>> sift(range(5), lambda x: x % 2)\n{0: [0, 2, 4], 1: [1, 3]} \n```", "```py\n>>> sift([x], lambda x: x.is_commutative)\n{True: [x]}\n>>> _[False]\n[] \n```", "```py\n>>> sift([sqrt(x), exp(x), (y**x)**2],\n...      lambda x: x.as_base_exp()[0])\n{E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]} \n```", "```py\n>>> sift(range(4), lambda x: x % 2, binary=True)\n([1, 3], [0, 2])\n>>> sift(Tuple(1, pi), lambda x: x.is_rational, binary=True)\n([1], [pi]) \n```", "```py\n>>> unknown = exp(1) - pi  # the rationality of this is unknown\n>>> args = Tuple(1, pi, unknown)\n>>> sift(args, lambda x: x.is_rational, binary=True)\nTraceback (most recent call last):\n...\nValueError: keyfunc gave non-binary output \n```", "```py\n>>> set(sift(args, lambda x: x.is_rational).keys())\n{None, False, True} \n```", "```py\nsympy.utilities.iterables.signed_permutations(t)\n```", "```py\n>>> from sympy.utilities.iterables import signed_permutations\n>>> list(signed_permutations((0, 1, 2)))\n[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2), (0, 2, 1),\n(0, -2, 1), (0, 2, -1), (0, -2, -1), (1, 0, 2), (-1, 0, 2),\n(1, 0, -2), (-1, 0, -2), (1, 2, 0), (-1, 2, 0), (1, -2, 0),\n(-1, -2, 0), (2, 0, 1), (-2, 0, 1), (2, 0, -1), (-2, 0, -1),\n(2, 1, 0), (-2, 1, 0), (2, -1, 0), (-2, -1, 0)] \n```", "```py\nsympy.utilities.iterables.strongly_connected_components(G)\n```", "```py\ndigraph {\n    A -> B\n    A -> C\n    B -> C\n    C -> B\n    B -> D\n} \n```", "```py\n>>> V = ['A', 'B', 'C', 'D']\n>>> E = [('A', 'B'), ('A', 'C'), ('B', 'C'), ('C', 'B'), ('B', 'D')] \n```", "```py\n>>> from sympy.utilities.iterables import strongly_connected_components \n```", "```py\n>>> strongly_connected_components((V, E))\n[['D'], ['B', 'C'], ['A']] \n```", "```py\nsympy.utilities.iterables.subsets(seq, k=None, repetition=False)\n```", "```py\n>>> from sympy import subsets \n```", "```py\n>>> list(subsets([1, 2], 2))\n[(1, 2)]\n>>> list(subsets([1, 2]))\n[(), (1,), (2,), (1, 2)]\n>>> list(subsets([1, 2, 3], 2))\n[(1, 2), (1, 3), (2, 3)] \n```", "```py\n>>> list(subsets([1, 2], 2, repetition=True))\n[(1, 1), (1, 2), (2, 2)] \n```", "```py\n>>> list(subsets([0, 1], 3, repetition=False))\n[]\n>>> list(subsets([0, 1], 3, repetition=True))\n[(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)] \n```", "```py\nsympy.utilities.iterables.take(iter, n)\n```", "```py\nsympy.utilities.iterables.topological_sort(graph, key=None)\n```", "```py\n+---+     +---+     +---+\n| 7 |\\    | 5 |     | 3 |\n+---+ \\   +---+     +---+\n  |   _\\___/ ____   _/ |\n  |  /  \\___/    \\ /   |\n  V  V           V V   |\n +----+         +---+  |\n | 11 |         | 8 |  |\n +----+         +---+  |\n  | | \\____   ___/ _   |\n  | \\      \\ /    / \\  |\n  V  \\     V V   /  V  V\n+---+ \\   +---+ |  +----+\n| 2 |  |  | 9 | |  | 10 |\n+---+  |  +---+ |  +----+\n       \\________/ \n```", "```py\n>>> V = [2, 3, 5, 7, 8, 9, 10, 11]\n>>> E = [(7, 11), (7, 8), (5, 11), (3, 8), (3, 10),\n...      (11, 2), (11, 9), (11, 10), (8, 9)] \n```", "```py\n>>> from sympy.utilities.iterables import topological_sort\n\n>>> topological_sort((V, E))\n[3, 5, 7, 8, 11, 2, 9, 10] \n```", "```py\n>>> topological_sort((V, E), key=lambda v: -v)\n[7, 5, 11, 3, 10, 8, 9, 2] \n```", "```py\n>>> topological_sort((V, E + [(10, 7)]))\nTraceback (most recent call last):\n...\nValueError: cycle detected \n```", "```py\nsympy.utilities.iterables.unflatten(iter, n=2)\n```", "```py\nsympy.utilities.iterables.uniq(seq, result=None)\n```", "```py\n>>> from sympy.utilities.iterables import uniq\n>>> dat = [1, 4, 1, 5, 4, 2, 1, 2]\n>>> type(uniq(dat)) in (list, tuple)\nFalse \n```", "```py\n>>> list(uniq(dat))\n[1, 4, 5, 2]\n>>> list(uniq(x for x in dat))\n[1, 4, 5, 2]\n>>> list(uniq([[1], [2, 1], [1]]))\n[[1], [2, 1]] \n```", "```py\nsympy.utilities.iterables.variations(seq, n, repetition=False)\n```", "```py\n>>> from sympy import variations\n>>> list(variations([1, 2], 2))\n[(1, 2), (2, 1)] \n```", "```py\n>>> list(variations([1, 2], 2, repetition=True))\n[(1, 1), (1, 2), (2, 1), (2, 2)] \n```", "```py\n>>> list(variations([0, 1], 3, repetition=False))\n[]\n>>> list(variations([0, 1], 3, repetition=True))[:4]\n[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)] \n```", "```py\n>>> from sympy.utilities.iterables import variations\n>>> list(variations([1,2,3], 2))\n[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]\n>>> list(variations([1,2,3], 2, True))\n[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)] \n```", "```py\n>>> from sympy.utilities.iterables import partitions\n>>> [p.copy() for s, p in partitions(7, m=2, size=True) if s == 2]\n[{1: 1, 6: 1}, {2: 1, 5: 1}, {3: 1, 4: 1}] \n```", "```py\n>>> from sympy.utilities.iterables import multiset_partitions\n>>> [p for p in multiset_partitions(3, 2)]\n[[[0, 1], [2]], [[0, 2], [1]], [[0], [1, 2]]]\n>>> [p for p in multiset_partitions([1, 1, 1, 2], 2)]\n[[[1, 1, 1], [2]], [[1, 1, 2], [1]], [[1, 1], [1, 2]]] \n```", "```py\n>>> from sympy.utilities.iterables import kbins\n>>> def show(k):\n...     rv = []\n...     for p in k:\n...         rv.append(','.join([''.join(j) for j in p]))\n...     return sorted(rv)\n...\n>>> show(kbins(\"ABCD\", 2))\n['A,BCD', 'AB,CD', 'ABC,D']\n>>> show(kbins(\"ABC\", 2))\n['A,BC', 'AB,C']\n>>> show(kbins(\"ABC\", 2, ordered=0))  # same as multiset_partitions\n['A,BC', 'AB,C', 'AC,B']\n>>> show(kbins(\"ABC\", 2, ordered=1))\n['A,BC', 'A,CB',\n 'B,AC', 'B,CA',\n 'C,AB', 'C,BA']\n>>> show(kbins(\"ABC\", 2, ordered=10))\n['A,BC', 'AB,C', 'AC,B',\n 'B,AC', 'BC,A',\n 'C,AB']\n>>> show(kbins(\"ABC\", 2, ordered=11))\n['A,BC', 'A,CB', 'AB,C', 'AC,B',\n 'B,AC', 'B,CA', 'BA,C', 'BC,A',\n 'C,AB', 'C,BA', 'CA,B', 'CB,A'] \n```"]