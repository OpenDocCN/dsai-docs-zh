# scipy.special.iv

> 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.special.iv.html#scipy.special.iv](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.special.iv.html#scipy.special.iv)

```py
scipy.special.iv(v, z, out=None) = <ufunc 'iv'>
```

实数阶数的修改贝塞尔函数第一类。

参数：

**v**array_like

阶数。如果*z*是实型且为负数，则*v*必须是整数值。

**z**float或复数的array_like

参数。

**out**ndarray, optional

可选的输出数组用于函数值

返回：

标量或ndarray

修改过的贝塞尔函数的值。

另请参见

[`ive`](scipy.special.ive.html#scipy.special.ive "scipy.special.ive")

带有前导指数行为剥离的此函数。

[`i0`](scipy.special.i0.html#scipy.special.i0 "scipy.special.i0")

此函数的阶数0的更快版本。

[`i1`](scipy.special.i1.html#scipy.special.i1 "scipy.special.i1")

此函数的阶数1的更快版本。

注

对于实数*z*和\(v \in [-50, 50]\)，使用Temme方法[[1]](#r3a80f286b9e7-1)进行评估。对于更大的阶数，应用均匀渐近展开。

对于复数*z*和正数*v*，调用AMOS[[2]](#r3a80f286b9e7-2)的*zbesi*例程。它对小*z*使用幂级数，对大*abs(z)*使用渐近展开，使用由Wronskian归一化的Miller算法和中间量级的Neumann级数，并对大阶数的\(I_v(z)\)和\(J_v(z)\)使用均匀渐近展开。当必要时使用反向递归生成序列或减少阶数。

上述计算在右半平面完成，并通过公式延伸到左半平面，

\[I_v(z \exp(\pm\imath\pi)) = \exp(\pm\pi v) I_v(z)\]

（当*z*的实部为正时有效）。对于负数*v*，使用公式

\[I_{-v}(z) = I_v(z) + \frac{2}{\pi} \sin(\pi v) K_v(z)\]

其中\(K_v(z)\)是第二类修改贝塞尔函数，使用AMOS例程*zbesk*进行评估。

参考

[[1](#id1)]

Temme, Journal of Computational Physics, vol 21, 343 (1976)

[[2](#id2)]

Donald E. Amos，“AMOS, A Portable Package for Bessel Functions of a Complex Argument and Nonnegative Order”，[http://netlib.org/amos/](http://netlib.org/amos/)

示例

在一个点评估阶数0的函数。

```py
>>> from scipy.special import iv
>>> iv(0, 1.)
1.2660658777520084 
```

为不同阶数的一个点评估函数。

```py
>>> iv(0, 1.), iv(1, 1.), iv(1.5, 1.)
(1.2660658777520084, 0.565159103992485, 0.2935253263474798) 
```

可通过提供列表或NumPy数组作为*v*参数的参数，在一次调用中评估不同阶数。

```py
>>> iv([0, 1, 1.5], 1.)
array([1.26606588, 0.5651591 , 0.29352533]) 
```

通过提供*z*的数组，在阶数0处评估函数。

```py
>>> import numpy as np
>>> points = np.array([-2., 0., 3.])
>>> iv(0, points)
array([2.2795853 , 1\.        , 4.88079259]) 
```

如果*z*是一个数组，则如果要在一次调用中计算不同阶数，阶数参数*v*必须能广播到正确的形状。要计算1D数组的阶数0和1：

```py
>>> orders = np.array([[0], [1]])
>>> orders.shape
(2, 1) 
```

```py
>>> iv(orders, points)
array([[ 2.2795853 ,  1\.        ,  4.88079259],
 [-1.59063685,  0\.        ,  3.95337022]]) 
```

绘制从-5到5的0到3阶函数。

```py
>>> import matplotlib.pyplot as plt
>>> fig, ax = plt.subplots()
>>> x = np.linspace(-5., 5., 1000)
>>> for i in range(4):
...     ax.plot(x, iv(i, x), label=f'$I_{i!r}$')
>>> ax.legend()
>>> plt.show() 
```

![../../_images/scipy-special-iv-1.png](../Images/0dfee6cf3f1fe2f4f0a1daa65bbf76bb.png)
