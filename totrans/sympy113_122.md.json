["```py\n1) The Indexed class represents the entire indexed object.\n           |\n        ___|___\n       '       '\n        M[i, j]\n       /   \\__\\______\n       |             |\n       |             |\n       |     2) The Idx class represents indices; each Idx can\n       |        optionally contain information about its range.\n       |\n 3) IndexedBase represents the 'stem' of an indexed object, here `M`.\n    The stem used by itself is usually taken to represent the entire\n    array. \n```", "```py\n>>> from sympy import symbols, IndexedBase, Idx\n>>> M = IndexedBase('M')\n>>> i, j = symbols('i j', cls=Idx)\n>>> M[i, j]\nM[i, j] \n```", "```py\n>>> x = IndexedBase('x')\n>>> M[i, j]*x[j]\nM[i, j]*x[j] \n```", "```py\n>>> dim1, dim2 = symbols('dim1 dim2', integer=True)\n>>> A = IndexedBase('A', shape=(dim1, 2*dim1, dim2))\n>>> A.shape\n(dim1, 2*dim1, dim2)\n>>> A[i, j, 3].shape\n(dim1, 2*dim1, dim2) \n```", "```py\n>>> n, m = symbols('n m', integer=True)\n>>> i = Idx('i', m)\n>>> j = Idx('j', n)\n>>> M[i, j].shape\n(m, n)\n>>> M[i, j].ranges\n[(0, m - 1), (0, n - 1)] \n```", "```py\n>>> A[i, 2, j].shape\n(dim1, 2*dim1, dim2)\n>>> A[i, 2, j].ranges\n[(0, m - 1), None, (0, n - 1)] \n```", "```py\n>>> from sympy.tensor import get_indices, get_contraction_structure\n>>> get_indices(A[i, j, j])\n({i}, {})\n>>> get_contraction_structure(A[i, j, j])\n{(j,): {A[i, j, j]}} \n```", "```py\nclass sympy.tensor.indexed.Idx(label, range=None, **kw_args)\n```", "```py\n>>> from sympy import Idx, symbols, oo\n>>> n, i, L, U = symbols('n i L U', integer=True) \n```", "```py\n>>> idx = Idx('qwerty'); idx\nqwerty\n>>> idx.lower, idx.upper\n(None, None) \n```", "```py\n>>> idx = Idx(i, (L, U)); idx\ni\n>>> idx.lower, idx.upper\n(L, U) \n```", "```py\n>>> idx = Idx(i, n); idx.lower, idx.upper\n(0, n - 1)\n>>> idx = Idx(i, 4); idx.lower, idx.upper\n(0, 3)\n>>> idx = Idx(i, oo); idx.lower, idx.upper\n(0, oo) \n```", "```py\nproperty label\n```", "```py\n>>> from sympy import Idx, Symbol\n>>> x = Symbol('x', integer=True)\n>>> Idx(x).label\nx\n>>> j = Symbol('j', integer=True)\n>>> Idx(j).label\nj\n>>> Idx(j + 1).label\nj + 1 \n```", "```py\nproperty lower\n```", "```py\n>>> from sympy import Idx\n>>> Idx('j', 2).lower\n0\n>>> Idx('j', 5).lower\n0\n>>> Idx('j').lower is None\nTrue \n```", "```py\nproperty upper\n```", "```py\n>>> from sympy import Idx\n>>> Idx('j', 2).upper\n1\n>>> Idx('j', 5).upper\n4\n>>> Idx('j').upper is None\nTrue \n```", "```py\nclass sympy.tensor.indexed.Indexed(base, *args, **kw_args)\n```", "```py\n>>> from sympy import Indexed, IndexedBase, Idx, symbols\n>>> i, j = symbols('i j', cls=Idx)\n>>> Indexed('A', i, j)\nA[i, j] \n```", "```py\n>>> A = IndexedBase('A')\n>>> a_ij = A[i, j]           # Prefer this,\n>>> b_ij = Indexed(A, i, j)  # over this.\n>>> a_ij == b_ij\nTrue \n```", "```py\nproperty base\n```", "```py\n>>> from sympy import Indexed, IndexedBase, Idx, symbols\n>>> i, j = symbols('i j', cls=Idx)\n>>> Indexed('A', i, j).base\nA\n>>> B = IndexedBase('B')\n>>> B == B[i, j].base\nTrue \n```", "```py\nproperty indices\n```", "```py\n>>> from sympy import Indexed, Idx, symbols\n>>> i, j = symbols('i j', cls=Idx)\n>>> Indexed('A', i, j).indices\n(i, j) \n```", "```py\nproperty ranges\n```", "```py\n>>> from sympy import Indexed,Idx, symbols\n>>> Indexed('A', Idx('i', 2), Idx('j', 4), Idx('k', 8)).ranges\n[(0, 1), (0, 3), (0, 7)]\n>>> Indexed('A', Idx('i', 3), Idx('j', 3), Idx('k', 3)).ranges\n[(0, 2), (0, 2), (0, 2)]\n>>> x, y, z = symbols('x y z', integer=True)\n>>> Indexed('A', x, y, z).ranges\n[None, None, None] \n```", "```py\nproperty rank\n```", "```py\n>>> from sympy import Indexed, Idx, symbols\n>>> i, j, k, l, m = symbols('i:m', cls=Idx)\n>>> Indexed('A', i, j).rank\n2\n>>> q = Indexed('A', i, j, k, l, m)\n>>> q.rank\n5\n>>> q.rank == len(q.indices)\nTrue \n```", "```py\nproperty shape\n```", "```py\n>>> from sympy import IndexedBase, Idx, symbols\n>>> n, m = symbols('n m', integer=True)\n>>> i = Idx('i', m)\n>>> j = Idx('j', m)\n>>> A = IndexedBase('A', shape=(n, n))\n>>> B = IndexedBase('B')\n>>> A[i, j].shape\n(n, n)\n>>> B[i, j].shape\n(m, m) \n```", "```py\nclass sympy.tensor.indexed.IndexedBase(label, shape=None, *, offset=0, strides=None, **kw_args)\n```", "```py\n>>> from sympy.tensor import IndexedBase, Idx\n>>> from sympy import symbols\n>>> A = IndexedBase('A'); A\nA\n>>> type(A)\n<class 'sympy.tensor.indexed.IndexedBase'> \n```", "```py\n>>> i, j = symbols('i j', integer=True)\n>>> A[i, j, 2]\nA[i, j, 2]\n>>> type(A[i, j, 2])\n<class 'sympy.tensor.indexed.Indexed'> \n```", "```py\n>>> m, n, o, p = symbols('m n o p', integer=True)\n>>> i = Idx('i', m)\n>>> j = Idx('j', n)\n>>> A[i, j].shape\n(m, n)\n>>> B = IndexedBase('B', shape=(o, p))\n>>> B[i, j].shape\n(o, p) \n```", "```py\n>>> A_real = IndexedBase('A', real=True)\n>>> A_real.is_real\nTrue\n>>> A != A_real\nTrue \n```", "```py\n>>> I = symbols('I', integer=True)\n>>> C_inherit = IndexedBase(I)\n>>> C_explicit = IndexedBase('I', integer=True)\n>>> C_inherit == C_explicit\nTrue \n```", "```py\nproperty label\n```", "```py\n>>> from sympy import IndexedBase\n>>> from sympy.abc import x, y\n>>> IndexedBase('A', shape=(x, y)).label\nA \n```", "```py\nproperty offset\n```", "```py\n>>> from sympy.printing import ccode\n>>> from sympy.tensor import IndexedBase, Idx\n>>> from sympy import symbols\n>>> l, m, n, o = symbols('l m n o', integer=True)\n>>> A = IndexedBase('A', strides=(l, m, n), offset=o)\n>>> i, j, k = map(Idx, 'ijk')\n>>> ccode(A[i, j, k])\n'A[l*i + m*j + n*k + o]' \n```", "```py\nproperty shape\n```", "```py\n>>> from sympy import IndexedBase, Idx\n>>> from sympy.abc import x, y\n>>> IndexedBase('A', shape=(x, y)).shape\n(x, y) \n```", "```py\n>>> A = IndexedBase('A', shape=(x, y))\n>>> B = IndexedBase('B')\n>>> i = Idx('i', 2)\n>>> j = Idx('j', 1)\n>>> A[i, j].shape\n(x, y)\n>>> B[i, j].shape\n(2, 1) \n```", "```py\nproperty strides\n```"]