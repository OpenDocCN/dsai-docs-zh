- en: Extending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/random/extending.html](https://numpy.org/doc/1.26/reference/random/extending.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The BitGenerators have been designed to be extendable using standard tools for
    high-performance Python – numba and Cython. The [`Generator`](generator.html#numpy.random.Generator
    "numpy.random.Generator") object can also be used with user-provided BitGenerators
    as long as these export a small set of required functions.
  prefs: []
  type: TYPE_NORMAL
- en: Numba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators
    all export a small set of functions through both interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how numba can be used to produce gaussian samples using a
    pure Python implementation which is then compiled. The random numbers are provided
    by `ctypes.next_double`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both CTypes and CFFI allow the more complicated distributions to be used directly
    in Numba after compiling the file distributions.c into a `DLL` or `so`. An example
    showing the use of a more complicated distribution is in the [Examples](#examples)
    section below.
  prefs: []
  type: TYPE_NORMAL
- en: '## Cython'
  prefs: []
  type: TYPE_NORMAL
- en: Cython can be used to unpack the `PyCapsule` provided by a BitGenerator. This
    example uses [`PCG64`](bit_generators/pcg64.html#numpy.random.PCG64 "numpy.random.PCG64")
    and the example from above. The usual caveats for writing high-performance code
    using Cython – removing bounds checks and wrap around, providing array alignment
    information – still apply.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The BitGenerator can also be directly accessed using the members of the `bitgen_t`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Cython can be used to directly access the functions in `numpy/random/c_distributions.pxd`.
    This requires linking with the `npyrandom` library located in `numpy/random/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See [Extending numpy.random via Cython](examples/cython/index.html#extending-cython-example)
    for the complete listings of these examples and a minimal `setup.py` to build
    the c-extension modules.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CFFI can be used to directly access the functions in `include/numpy/random/distributions.h`.
    Some “massaging” of the header file is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the header is parsed by `ffi.cdef`, the functions can be accessed directly
    from the `_generator` shared object, using the [`BitGenerator.cffi`](bit_generators/generated/numpy.random.BitGenerator.cffi.html#numpy.random.BitGenerator.cffi
    "numpy.random.BitGenerator.cffi") interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: New Bit Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`Generator`](generator.html#numpy.random.Generator "numpy.random.Generator")
    can be used with user-provided [`BitGenerator`](bit_generators/generated/numpy.random.BitGenerator.html#numpy.random.BitGenerator
    "numpy.random.BitGenerator")s. The simplest way to write a new BitGenerator is
    to examine the pyx file of one of the existing BitGenerators. The key structure
    that must be provided is the `capsule` which contains a `PyCapsule` to a struct
    pointer of type `bitgen_t`,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: which provides 5 pointers. The first is an opaque pointer to the data structure
    used by the BitGenerators. The next three are function pointers which return the
    next 64- and 32-bit unsigned integers, the next random double and the next raw
    value. This final function is used for testing and so can be set to the next 64-bit
    unsigned integer function if not needed. Functions inside `Generator` use this
    structure as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Numba](examples/numba.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CFFI + Numba](examples/numba_cffi.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cython](examples/cython/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[meson.build](examples/cython/meson.build.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[extending.pyx](examples/cython/extending.pyx.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[extending_distributions.pyx](examples/cython/extending_distributions.pyx.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CFFI](examples/cffi.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators
    all export a small set of functions through both interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how numba can be used to produce gaussian samples using a
    pure Python implementation which is then compiled. The random numbers are provided
    by `ctypes.next_double`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both CTypes and CFFI allow the more complicated distributions to be used directly
    in Numba after compiling the file distributions.c into a `DLL` or `so`. An example
    showing the use of a more complicated distribution is in the [Examples](#examples)
    section below.
  prefs: []
  type: TYPE_NORMAL
- en: '## Cython'
  prefs: []
  type: TYPE_NORMAL
- en: Cython can be used to unpack the `PyCapsule` provided by a BitGenerator. This
    example uses [`PCG64`](bit_generators/pcg64.html#numpy.random.PCG64 "numpy.random.PCG64")
    and the example from above. The usual caveats for writing high-performance code
    using Cython – removing bounds checks and wrap around, providing array alignment
    information – still apply.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The BitGenerator can also be directly accessed using the members of the `bitgen_t`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Cython can be used to directly access the functions in `numpy/random/c_distributions.pxd`.
    This requires linking with the `npyrandom` library located in `numpy/random/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See [Extending numpy.random via Cython](examples/cython/index.html#extending-cython-example)
    for the complete listings of these examples and a minimal `setup.py` to build
    the c-extension modules.
  prefs: []
  type: TYPE_NORMAL
- en: CFFI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CFFI can be used to directly access the functions in `include/numpy/random/distributions.h`.
    Some “massaging” of the header file is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once the header is parsed by `ffi.cdef`, the functions can be accessed directly
    from the `_generator` shared object, using the [`BitGenerator.cffi`](bit_generators/generated/numpy.random.BitGenerator.cffi.html#numpy.random.BitGenerator.cffi
    "numpy.random.BitGenerator.cffi") interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: New Bit Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`Generator`](generator.html#numpy.random.Generator "numpy.random.Generator")
    can be used with user-provided [`BitGenerator`](bit_generators/generated/numpy.random.BitGenerator.html#numpy.random.BitGenerator
    "numpy.random.BitGenerator")s. The simplest way to write a new BitGenerator is
    to examine the pyx file of one of the existing BitGenerators. The key structure
    that must be provided is the `capsule` which contains a `PyCapsule` to a struct
    pointer of type `bitgen_t`,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: which provides 5 pointers. The first is an opaque pointer to the data structure
    used by the BitGenerators. The next three are function pointers which return the
    next 64- and 32-bit unsigned integers, the next random double and the next raw
    value. This final function is used for testing and so can be set to the next 64-bit
    unsigned integer function if not needed. Functions inside `Generator` use this
    structure as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Numba](examples/numba.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CFFI + Numba](examples/numba_cffi.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cython](examples/cython/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[meson.build](examples/cython/meson.build.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[extending.pyx](examples/cython/extending.pyx.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[extending_distributions.pyx](examples/cython/extending_distributions.pyx.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CFFI](examples/cffi.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
