# `numpy.lib.format`

> 原文：[`numpy.org/doc/1.26/reference/generated/numpy.lib.format.html`](https://numpy.org/doc/1.26/reference/generated/numpy.lib.format.html)

二进制序列化

## NPY 格式

一个简单的格式，用于将 NumPy 数组保存到磁盘，并包含有关它们的完整信息。

`.npy` 格式是 NumPy 中用于将*单个*任意 NumPy 数组持久化到磁盘的标准二进制文件格式。该格式存储了重建数组所需的所有形状和数据类型信息，即使在具有不同架构的另一台机器上也能正确重建数组。该格式旨在尽可能简单，同时实现其有限的目标。

`.npz` 格式是将*多个* NumPy 数组持久化到磁盘的标准格式。一个`.npz`文件是一个 zip 文件，包含多个`.npy`文件，每个文件对应一个数组。

### 能力

+   可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。

+   以其本机二进制形式表示数据。

+   直接支持 Fortran 连续数组。

+   存储了重建数组所需的所有信息，包括在不同架构的机器上的形状和数据类型。支持小端和大端数组，具有小端数字的文件将在任何读取该文件的机器上产生小端数组。类型是根据它们的实际大小描述的。例如，如果一个具有 64 位 C “long int”的机器写出一个带有“long ints”的数组，那么一个具有 32 位 C “long ints”的读取机器将产生一个带有 64 位整数的数组。

+   容易被逆向工程。数据集通常比创建它们的程序存在时间更长。一个称职的开发者应该能够用他们喜欢的编程语言创建一个解决方案，以读取大部分没有太多文档的`.npy`文件。

+   允许内存映射数据。参见`open_memmap`。

+   可以从类似文件的流对象而不是实际文件中读取。

+   存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不能进行内存映射，但可以读取和写入磁盘。

### 限制

+   numpy.ndarray 的任意子类并不完全保留。子类将被接受用于写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray 对象。

警告

由于对结构化数据类型的解释存在限制，具有空名称字段的数据类型将被替换为‘f0’、‘f1’等。这样的数组将无法完全准确地通过格式循环。数据是完整的；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用`loadedarray.view(correct_dtype)`方法恢复正确的数据类型。

### 文件扩展名

我们建议使用`.npy`和`.npz`扩展名保存此格式的文件。这绝不是必须的；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。

### 版本编号

这些格式的版本编号与 NumPy 版本编号是独立的。如果格式升级，*numpy.io*中的代码仍将能够读取和写入版本 1.0 文件。

### 格式版本 1.0

前 6 个字节是一个魔术字符串：正好为`\x93NUMPY`。

接下来的 1 个字节是无符号字节：文件格式的主要版本号，例如`\x01`。

接下来的 1 个字节是无符号字节：文件格式的次要版本号，例如`\x00`。注意：文件格式的版本与 numpy 软件包的版本无关。

接下来的 2 个字节形成一个小端无符号短整型：头数据 HEADER_LEN 的长度。

接下来的 HEADER_LEN 字节形成描述数组格式的头数据。这是一个 ASCII 字符串，包含一个字典的 Python 文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic string) + 2 + len(length) + HEADER_LEN`的总和能够被 64 整除，以��对齐。

字典包含三个键：

> “descr”dtype.descr
> 
> 可作为参数传递给`numpy.dtype`构造函数以创建数组 dtype 的对象。
> 
> “fortran_order”布尔值
> 
> 数组数据是否是 Fortran 连续的。由于 Fortran 连续数组是一种常见的非 C 连续形式，我们允许它们直接写入磁盘以提高效率。
> 
> “shape”整数元组
> 
> 数组的形状。

为了重复性和可读性，字典键按字母顺序排序。这仅为方便起见。作者应尽可能实现这一点。读者不应依赖于此。

在头部之后是数组数据。如果 dtype 包含 Python 对象（即`dtype.hasobject is True`），则数据是数组的 Python pickle。否则，数据是数组的连续（无论是 C 还是 Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数量相乘（注意`shape=()`表示有 1 个元素）乘以`dtype.itemsize`来计算字节数。

### 格式版本 2.0

版本 1.0 格式仅允许数组头的总大小为 65535 字节。结构化数组的列数较多时可能会超过此限制。版本 2.0 格式将头大小扩展到 4 GiB。`numpy.save`将根据数据的需要自动保存为 2.0 格式，否则将始终使用更兼容的 1.0 格式。

因此，头的第四个元素的描述变为：“接下来的 4 个字节形成一个小端无符号整型：头数据 HEADER_LEN 的长度。”

### 格式版本 3.0

这个版本用 utf8 编码的字符串替换了 ASCII 字符串（实际上是 latin1），因此支持具有任何 Unicode 字段名称的结构化类型。

### 注意

`.npy` 格式，包括创建动机和替代方案的比较，在 [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html "(in NumPy Enhancement Proposals)") 中有描述，但随着时间的推移，细节已经发生变化，本文档更为当前。

函数

| `descr_to_dtype`(descr) | 根据给定描述返回 dtype。 |
| --- | --- |
| `dtype_to_descr`(dtype) | 从 dtype 获取可序列化的描述符。 |
| `header_data_from_array_1_0`(array) | 从 numpy.ndarray 获取头部元数据的字典。 |
| `magic`(major, minor) | 返回给定文件格式版本的魔术字符串。 |
| `open_memmap`(filename[, mode, dtype, shape, ...]) | 将 .npy 文件作为内存映射数组打开。 |
| `read_array`(fp[, allow_pickle, ...]) | 从 NPY 文件中读取数组。 |
| `read_array_header_1_0`(fp[, max_header_size]) | 使用 1.0 文件格式版本从文件对象中读取数组头。 |
| `read_array_header_2_0`(fp[, max_header_size]) | 使用 2.0 文件格式版本从文件对象中读取数组头。 |
| `read_magic`(fp) | 读取魔术字符串以获取文件格式的版本。 |
| `write_array`(fp, array[, version, ...]) | 将数组写入 NPY 文件，包括头部。 |
| `write_array_header_1_0`(fp, d) | 使用 1.0 格式写入数组头。 |
| `write_array_header_2_0`(fp, d) | 使用 2.0 格式写入数组头。 |

## NPY 格式

用于将 numpy 数组保存到磁盘的简单格式，包含有关它们的所有信息。

`.npy` 格式是 NumPy 中用于在磁盘上持久化*单个*任意 NumPy 数组的标准二进制文件格式。该格式存储了重建数组所需的所有形状和 dtype 信息，即使在具有不同架构的另一台机器上也能正确重建数组。该格式旨在尽可能简单，同时实现其有限的目标。

`.npz` 格式是在磁盘上持久化*多个* NumPy 数组的标准格式。一个 `.npz` 文件是一个 zip 文件，包含多个 `.npy` 文件，每个文件对应一个数组。

### 能力

+   可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。

+   以其本机二进制形式表示数据。

+   直接支持 Fortran 连续数组。

+   存储了重建数组所需的所有信息，包括形状和 dtype，在具有不同架构的机器上。支持小端和大端数组，并且具有小端数字的文件将在读取文件的任何机器上产生小端数组。类型是根据其实际大小描述的。例如，如果具有 64 位 C “long int”的机器写出一个带有“long ints”的数组，那么具有 32 位 C “long ints”的读取机器将产生一个带有 64 位整数的数组。

+   易于逆向工程。数据集通常比创建它们的程序存在时间更长。一位称职的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取大部分给定的 `.npy` 文件而无需太多文档。

+   允许对数据进行内存映射。参见 `open_memmap`。

+   可以从类似文件流对象而不是实际文件中读取。

+   存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不能进行内存映射，但可以读取和写入磁盘。

### 限制

+   任意的 numpy.ndarray 子类并不完全保留。子类将被接受进行写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray 对象。

警告

由于对结构化 dtypes 的解释存在限制，具有空名称字段的 dtypes 将其名称替换为‘f0’、‘f1’等。这样的数组将无法完全准确地通过格式循环。数据完整；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用 `loadedarray.view(correct_dtype)` 方法恢复正确的 dtype。

### 文件扩展名

我们建议使用`.npy`和`.npz`扩展名保存以这种格式保存的文件。这绝不是一个要求；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。

### 版本编号

这些格式的版本编号与 NumPy 版本编号无关。如果格式升级，*numpy.io*中的代码仍将能够读取和写入版本 1.0 文件。

### 格式版本 1.0

前 6 个字节是一个魔术字符串：确切地为`\x93NUMPY`。

下一个字节是一个无符号字节：文件格式的主版本号，例如`\x01`。

下一个字节是一个无符号字节：文件格式的次版本号，例如`\x00`。注意：文件格式的版本与 numpy 软件包的版本无关。

接下来的 2 个字节形成一个小端无符号短整数：头部数据 HEADER_LEN 的长度。

接下来的 HEADER_LEN 字节形成描述数组格式的头部数据。这是一个 ASCII 字符串，其中包含一个字典的 Python 文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic string) + 2 + len(length) + HEADER_LEN`的总和能够被 64 整除，以便对齐。

字典包含三个键：

> “descr”dtype.descr
> 
> 一个可以作为参数传递给`numpy.dtype`构造函数以创建数组 dtype 的对象。
> 
> “fortran_order”布尔值
> 
> 数组数据是否是 Fortran 连续的。由于 Fortran 连续数组是一种常见的非 C 连续形式，我们允许它们直接写入磁盘以提高效率。
> 
> “shape”整数元组
> 
> 数组的形状。

为了重复性和可读性，字典键按字母顺序排序。这仅供方便。如果可能的话，写入者应该实现这一点。读者不应该依赖于此。

在头部之后是数组数据。如果 dtype 包含 Python 对象（即`dtype.hasobject`为 True），那么数据是数组的 Python pickle。否则，数据是数组的连续（无论是 C 还是 Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数乘以`dtype.itemsize`来计算字节数（注意`shape=()`表示有 1 个元素）。

### 格式版本 2.0

版本 1.0 格式只允许数组头部的总大小为 65535 字节。这可以被具有大量列的结构化数组超过。版本 2.0 格式将头部大小扩展到 4 GiB。如果数据需要，`numpy.save`将自动保存为 2.0 格式，否则它将始终使用更兼容的 1.0 格式。

因此，头部的第四个元素的描述变为：“接下来的 4 个字节形成一个小端无符号整数：头部数据 HEADER_LEN 的长度。”

### 格式版本 3.0

此版本将 ASCII 字符串（实际上是 latin1）替换为 utf8 编码的字符串，因此支持具有任何 Unicode 字段名称的结构化类型。

### 注意事项

描述了`.npy`格式，包括创建动机和与其他格式的比较，在[“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html)中，然而细节随着时间的推移而发展，这份文档更为当前。

### 功能

+   可以表示所有 NumPy 数组，包括嵌套记录数组和对象数组。

+   以其本机二进制形式表示数据。

+   直接支持 Fortran 连续数组。

+   存储重建数组所需的所有信息，包括在不同架构的机器上的形状和数据类型。支持小端和大端数组，并且具有小端数字的文件将在任何读取文件的机器上产生小端数组。类型是根据它们的实际大小描述的。例如，如果一个具有 64 位 C “long int”的机器写出一个带有“long ints”的数组，那么一个具有 32 位 C “long ints”的读取机器将产生一个带有 64 位整数的数组。

+   易于逆向工程。数据集通常比创建它们的程序存在时间更长。一位称职的开发人员应该能够使用他们喜欢的编程语言创建一个解决方案，以读取大多数给定的`.npy`文件而无需太多文档。

+   允许对数据进行内存映射。请参阅`open_memmap`。

+   可以从类似文件流对象而不是实际文件中读取。

+   存储对象数组，即包含任意 Python 对象的数组。具有对象数组的文件不可进行内存映射，但可以读取和写入磁盘。

### 限制

+   任意的 numpy.ndarray 子类不会完全保留。子类将被接受进行写入，但只有数组数据将被写出。在读取文件时将创建一个常规的 numpy.ndarray 对象。

警告

由于对结构化数据类型的解释存在限制，具有空字段名称的数据类型将被替换为‘f0’、‘f1’等。这样的数组将无法完全准确地循环通过格式。数据是完整的；只有字段名称会有所不同。我们正在努力解决这个问题。这个修复不需要更改文件格式。具有这种结构的数组仍然可以保存和恢复，并且可以通过使用`loadedarray.view(correct_dtype)`方法恢复正确的数据类型。

### 文件扩展名

我们建议使用`.npy`和`.npz`扩展名保存以这种格式保存的文件。这绝不是一个要求；应用程序可能希望使用这些文件格式，但使用特定于应用程序的扩展名。然而，在没有明显替代方案的情况下，我们建议使用`.npy`和`.npz`。

### 版本编号

这些格式的版本编号与 NumPy 版本编号是独立的。如果格式升级，*numpy.io*中的代码仍然能够读取和写入 Version 1.0 文件。

### 格式版本 1.0

前 6 个字节是一个魔术字符串：正好是`\x93NUMPY`。

接下来的 1 个字节是一个无符号字节：文件格式的主要版本号，例如`\x01`。

接下来的 1 个字节是一个无符号字节：文件格式的次要版本号，例如`\x00`。注意：文件格式的版本与 numpy 软件包的版本无关。

接下来的 2 个字节形成一个小端无符号短整数：头部数据 HEADER_LEN 的长度。

接下来的 HEADER_LEN 字节形成描述数组格式的头部数据。它是一个 ASCII 字符串，其中包含一个字典的 Python 文字表达式。它以换行符（`\n`）结尾，并用空格（`\x20`）填充，使得`len(magic string) + 2 + len(length) + HEADER_LEN`的总和能够被 64 整除，以便对齐。

字典包含三个键：

> “descr”dtype.descr
> 
> 可以作为参数传递给`numpy.dtype`构造函数以创建数组 dtype 的对象。
> 
> “fortran_order”bool
> 
> 数组数据是否是 Fortran 连续的。由于 Fortran 连续数组是一种常见的非 C 连续形式，我们允许它们直接写入磁盘以提高效率。
> 
> “shape”int 元组
> 
> 数组的形状。

为了重复性和可读性，字典键按字母顺序排序。这仅仅是为了方便。如果可能的话，写入者应该实现这一点。读者不应该依赖于此。

在头部之后是数组数据。如果 dtype 包含 Python 对象（即`dtype.hasobject is True`），那么数据是数组的 Python pickle。否则，数据是数组的连续（无论是 C 还是 Fortran，取决于`fortran_order`）字节。消费者可以通过将形状给定的元素数量相乘（注意`shape=()`表示有 1 个元素）来计算字节数，乘以`dtype.itemsize`。

### 格式版本 2.0

版本 1.0 格式只允许数组头部的总大小为 65535 字节。这可以被具有大量列的结构化数组超过。版本 2.0 格式将头部大小扩展到 4 GiB。`numpy.save`将自动保存为 2.0 格式，如果数据需要，否则它将始终使用更兼容的 1.0 格式。

因此，头部的第四个元素的描述变为：“接下来的 4 个字节形成一个小端无符号整数：头部数据 HEADER_LEN 的长度。”

### 格式版本 3.0

这个版本用 utf8 编码的字符串替换了 ASCII 字符串（实际上是 latin1），因此支持具有任何 Unicode 字段名称的结构化类型。

### 注意

`.npy` 格式，包括创建动机和与其他替代方案的比较，在 [“npy-format” NEP](https://numpy.org/neps/nep-0001-npy-format.html "(在 NumPy Enhancement Proposals 中)") 中有描述，然而随着时间的推移，细节已经发生变化，本文档更为当前。
