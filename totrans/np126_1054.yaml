- en: Typing (numpy.typing)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/typing.html](https://numpy.org/doc/1.26/reference/typing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: 'Large parts of the NumPy API have [**PEP 484**](https://peps.python.org/pep-0484/)-style
    type annotations. In addition a number of type aliases are available to users,
    most prominently the two below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ArrayLike`](#numpy.typing.ArrayLike "numpy.typing.ArrayLike"): objects that
    can be converted to arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DTypeLike`](#numpy.typing.DTypeLike "numpy.typing.DTypeLike"): objects that
    can be converted to dtypes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mypy plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.21.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [mypy](http://mypy-lang.org/) plugin for managing a number of platform-specific
    annotations. Its functionality can be split into three distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the (platform-dependent) precisions of certain [`number`](arrays.scalars.html#numpy.number
    "numpy.number") subclasses, including the likes of [`int_`](arrays.scalars.html#numpy.int_
    "numpy.int_"), [`intp`](arrays.scalars.html#numpy.intp "numpy.intp") and [`longlong`](arrays.scalars.html#numpy.longlong
    "numpy.longlong"). See the documentation on [scalar types](arrays.scalars.html#arrays-scalars-built-in)
    for a comprehensive overview of the affected classes. Without the plugin the precision
    of all relevant classes will be inferred as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.11)").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing all extended-precision [`number`](arrays.scalars.html#numpy.number
    "numpy.number") subclasses that are unavailable for the platform in question.
    Most notably this includes the likes of [`float128`](arrays.scalars.html#numpy.float128
    "numpy.float128") and [`complex256`](arrays.scalars.html#numpy.complex256 "numpy.complex256").
    Without the plugin *all* extended-precision types will, as far as mypy is concerned,
    be available to all platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning the (platform-dependent) precision of [`c_intp`](routines.ctypeslib.html#numpy.ctypeslib.c_intp
    "numpy.ctypeslib.c_intp"). Without the plugin the type will default to [`ctypes.c_int64`](https://docs.python.org/3/library/ctypes.html#ctypes.c_int64
    "(in Python v3.11)").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.22.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable the plugin, one must add it to their mypy [configuration file](https://mypy.readthedocs.io/en/stable/config_file.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Differences from the runtime NumPy API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy is very flexible. Trying to describe the full range of possibilities statically
    would result in types that are not very helpful. For that reason, the typed NumPy
    API is often stricter than the runtime NumPy API. This section describes some
    notable differences.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`ArrayLike`](#numpy.typing.ArrayLike "numpy.typing.ArrayLike") type tries
    to avoid creating object arrays. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'is valid NumPy code which will create a 0-dimensional object array. Type checkers
    will complain about the above example when using the NumPy types however. If you
    really intended to do the above, then you can either use a `# type: ignore` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'or explicitly type the array like object as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.11)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ndarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s possible to mutate the dtype of an array at runtime. For example, the
    following code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This sort of mutation is not allowed by the types. Users who want to write statically
    typed code should instead use the [`numpy.ndarray.view`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") method to create a view of the array with a different dtype.
  prefs: []
  type: TYPE_NORMAL
- en: DTypeLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`DTypeLike`](#numpy.typing.DTypeLike "numpy.typing.DTypeLike") type tries
    to avoid creation of dtype objects using dictionary of fields like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is valid NumPy code, the type checker will complain about it,
    since its usage is discouraged. Please see : [Data type objects](arrays.dtypes.html#arrays-dtypes)'
  prefs: []
  type: TYPE_NORMAL
- en: Number precision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The precision of [`numpy.number`](arrays.scalars.html#numpy.number "numpy.number")
    subclasses is treated as a covariant generic parameter (see [`NBitBase`](#numpy.typing.NBitBase
    "numpy.typing.NBitBase")), simplifying the annotating of processes involving precision-based
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, the likes of [`float16`](arrays.scalars.html#numpy.float16 "numpy.float16"),
    [`float32`](arrays.scalars.html#numpy.float32 "numpy.float32") and [`float64`](arrays.scalars.html#numpy.float64
    "numpy.float64") are still sub-types of [`floating`](arrays.scalars.html#numpy.floating
    "numpy.floating"), but, contrary to runtime, they’re not necessarily considered
    as sub-classes.
  prefs: []
  type: TYPE_NORMAL
- en: Timedelta64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`timedelta64`](arrays.scalars.html#numpy.timedelta64 "numpy.timedelta64")
    class is not considered a subclass of [`signedinteger`](arrays.scalars.html#numpy.signedinteger
    "numpy.signedinteger"), the former only inheriting from [`generic`](arrays.scalars.html#numpy.generic
    "numpy.generic") while static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 0D arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During runtime numpy aggressively casts any passed 0D arrays into their corresponding
    [`generic`](arrays.scalars.html#numpy.generic "numpy.generic") instance. Until
    the introduction of shape typing (see [**PEP 646**](https://peps.python.org/pep-0646/))
    it is unfortunately not possible to make the necessary distinction between 0D
    and >0D arrays. While thus not strictly correct, all operations are that can potentially
    perform a 0D-array -> scalar cast are currently annotated as exclusively returning
    an *ndarray*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is known in advance that an operation _will_ perform a 0D-array -> scalar
    cast, then one can consider manually remedying the situation with either [`typing.cast`](https://docs.python.org/3/library/typing.html#typing.cast
    "(in Python v3.11)") or a `# type: ignore` comment.'
  prefs: []
  type: TYPE_NORMAL
- en: Record array dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dtype of [`numpy.recarray`](generated/numpy.recarray.html#numpy.recarray
    "numpy.recarray"), and the `numpy.rec` functions in general, can be specified
    in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly via the `dtype` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With up to five helper arguments that operate via [`numpy.format_parser`](generated/numpy.format_parser.html#numpy.format_parser
    "numpy.format_parser"): `formats`, `names`, `titles`, `aligned` and `byteorder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two approaches are currently typed as being mutually exclusive, *i.e.*
    if `dtype` is specified than one may not specify `formats`. While this mutual
    exclusivity is not (strictly) enforced during runtime, combining both dtype specifiers
    can lead to unexpected or even downright buggy behavior.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A [`Union`](https://docs.python.org/3/library/typing.html#typing.Union "(in
    Python v3.11)") representing objects that can be coerced into an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others this includes the likes of:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Nested) sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects implementing the *__array__* protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs: []
  type: TYPE_NORMAL
- en: '[array_like](../glossary.html#term-array_like):'
  prefs: []
  type: TYPE_NORMAL
- en: Any scalar or sequence that can be interpreted as an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A [`Union`](https://docs.python.org/3/library/typing.html#typing.Union "(in
    Python v3.11)") representing objects that can be coerced into a [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype").
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others this includes the likes of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type`](https://docs.python.org/3/library/functions.html#type "(in Python
    v3.11)") objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character codes or the names of [`type`](https://docs.python.org/3/library/functions.html#type
    "(in Python v3.11)") objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects with the `.dtype` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying and constructing data types](arrays.dtypes.html#arrays-dtypes-constructing)'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive overview of all objects that can be coerced into data types.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A [generic](https://docs.python.org/3/glossary.html#term-generic-type "(in Python
    v3.11)") version of [`np.ndarray[Any, np.dtype[+ScalarType]]`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs: []
  type: TYPE_NORMAL
- en: Can be used during runtime for typing arrays with a given dtype and unspecified
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.21.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A type representing [`numpy.number`](arrays.scalars.html#numpy.number "numpy.number")
    precision during static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Used exclusively for the purpose static type checking, [`NBitBase`](#numpy.typing.NBitBase
    "numpy.typing.NBitBase") represents the base of a hierarchical set of subclasses.
    Each subsequent subclass is herein used for representing a lower level of precision,
    *e.g.* `64Bit > 32Bit > 16Bit`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is a typical usage example: [`NBitBase`](#numpy.typing.NBitBase "numpy.typing.NBitBase")
    is herein used for annotating a function that takes a float and integer of arbitrary
    precision as arguments and returns a new float of whichever precision is largest
    (*e.g.* `np.float16 + np.int64 -> np.float64`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Mypy plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.21.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [mypy](http://mypy-lang.org/) plugin for managing a number of platform-specific
    annotations. Its functionality can be split into three distinct parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the (platform-dependent) precisions of certain [`number`](arrays.scalars.html#numpy.number
    "numpy.number") subclasses, including the likes of [`int_`](arrays.scalars.html#numpy.int_
    "numpy.int_"), [`intp`](arrays.scalars.html#numpy.intp "numpy.intp") and [`longlong`](arrays.scalars.html#numpy.longlong
    "numpy.longlong"). See the documentation on [scalar types](arrays.scalars.html#arrays-scalars-built-in)
    for a comprehensive overview of the affected classes. Without the plugin the precision
    of all relevant classes will be inferred as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.11)").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing all extended-precision [`number`](arrays.scalars.html#numpy.number
    "numpy.number") subclasses that are unavailable for the platform in question.
    Most notably this includes the likes of [`float128`](arrays.scalars.html#numpy.float128
    "numpy.float128") and [`complex256`](arrays.scalars.html#numpy.complex256 "numpy.complex256").
    Without the plugin *all* extended-precision types will, as far as mypy is concerned,
    be available to all platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning the (platform-dependent) precision of [`c_intp`](routines.ctypeslib.html#numpy.ctypeslib.c_intp
    "numpy.ctypeslib.c_intp"). Without the plugin the type will default to [`ctypes.c_int64`](https://docs.python.org/3/library/ctypes.html#ctypes.c_int64
    "(in Python v3.11)").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.22.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable the plugin, one must add it to their mypy [configuration file](https://mypy.readthedocs.io/en/stable/config_file.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable the plugin, one must add it to their mypy [configuration file](https://mypy.readthedocs.io/en/stable/config_file.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Differences from the runtime NumPy API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy is very flexible. Trying to describe the full range of possibilities statically
    would result in types that are not very helpful. For that reason, the typed NumPy
    API is often stricter than the runtime NumPy API. This section describes some
    notable differences.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`ArrayLike`](#numpy.typing.ArrayLike "numpy.typing.ArrayLike") type tries
    to avoid creating object arrays. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'is valid NumPy code which will create a 0-dimensional object array. Type checkers
    will complain about the above example when using the NumPy types however. If you
    really intended to do the above, then you can either use a `# type: ignore` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'or explicitly type the array like object as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.11)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ndarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s possible to mutate the dtype of an array at runtime. For example, the
    following code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This sort of mutation is not allowed by the types. Users who want to write statically
    typed code should instead use the [`numpy.ndarray.view`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") method to create a view of the array with a different dtype.
  prefs: []
  type: TYPE_NORMAL
- en: DTypeLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`DTypeLike`](#numpy.typing.DTypeLike "numpy.typing.DTypeLike") type tries
    to avoid creation of dtype objects using dictionary of fields like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is valid NumPy code, the type checker will complain about it,
    since its usage is discouraged. Please see : [Data type objects](arrays.dtypes.html#arrays-dtypes)'
  prefs: []
  type: TYPE_NORMAL
- en: Number precision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The precision of [`numpy.number`](arrays.scalars.html#numpy.number "numpy.number")
    subclasses is treated as a covariant generic parameter (see [`NBitBase`](#numpy.typing.NBitBase
    "numpy.typing.NBitBase")), simplifying the annotating of processes involving precision-based
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, the likes of [`float16`](arrays.scalars.html#numpy.float16 "numpy.float16"),
    [`float32`](arrays.scalars.html#numpy.float32 "numpy.float32") and [`float64`](arrays.scalars.html#numpy.float64
    "numpy.float64") are still sub-types of [`floating`](arrays.scalars.html#numpy.floating
    "numpy.floating"), but, contrary to runtime, they’re not necessarily considered
    as sub-classes.
  prefs: []
  type: TYPE_NORMAL
- en: Timedelta64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`timedelta64`](arrays.scalars.html#numpy.timedelta64 "numpy.timedelta64")
    class is not considered a subclass of [`signedinteger`](arrays.scalars.html#numpy.signedinteger
    "numpy.signedinteger"), the former only inheriting from [`generic`](arrays.scalars.html#numpy.generic
    "numpy.generic") while static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 0D arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During runtime numpy aggressively casts any passed 0D arrays into their corresponding
    [`generic`](arrays.scalars.html#numpy.generic "numpy.generic") instance. Until
    the introduction of shape typing (see [**PEP 646**](https://peps.python.org/pep-0646/))
    it is unfortunately not possible to make the necessary distinction between 0D
    and >0D arrays. While thus not strictly correct, all operations are that can potentially
    perform a 0D-array -> scalar cast are currently annotated as exclusively returning
    an *ndarray*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is known in advance that an operation _will_ perform a 0D-array -> scalar
    cast, then one can consider manually remedying the situation with either [`typing.cast`](https://docs.python.org/3/library/typing.html#typing.cast
    "(in Python v3.11)") or a `# type: ignore` comment.'
  prefs: []
  type: TYPE_NORMAL
- en: Record array dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dtype of [`numpy.recarray`](generated/numpy.recarray.html#numpy.recarray
    "numpy.recarray"), and the `numpy.rec` functions in general, can be specified
    in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly via the `dtype` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With up to five helper arguments that operate via [`numpy.format_parser`](generated/numpy.format_parser.html#numpy.format_parser
    "numpy.format_parser"): `formats`, `names`, `titles`, `aligned` and `byteorder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two approaches are currently typed as being mutually exclusive, *i.e.*
    if `dtype` is specified than one may not specify `formats`. While this mutual
    exclusivity is not (strictly) enforced during runtime, combining both dtype specifiers
    can lead to unexpected or even downright buggy behavior.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`ArrayLike`](#numpy.typing.ArrayLike "numpy.typing.ArrayLike") type tries
    to avoid creating object arrays. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'is valid NumPy code which will create a 0-dimensional object array. Type checkers
    will complain about the above example when using the NumPy types however. If you
    really intended to do the above, then you can either use a `# type: ignore` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'or explicitly type the array like object as [`Any`](https://docs.python.org/3/library/typing.html#typing.Any
    "(in Python v3.11)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ndarray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s possible to mutate the dtype of an array at runtime. For example, the
    following code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This sort of mutation is not allowed by the types. Users who want to write statically
    typed code should instead use the [`numpy.ndarray.view`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") method to create a view of the array with a different dtype.
  prefs: []
  type: TYPE_NORMAL
- en: DTypeLike
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`DTypeLike`](#numpy.typing.DTypeLike "numpy.typing.DTypeLike") type tries
    to avoid creation of dtype objects using dictionary of fields like below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is valid NumPy code, the type checker will complain about it,
    since its usage is discouraged. Please see : [Data type objects](arrays.dtypes.html#arrays-dtypes)'
  prefs: []
  type: TYPE_NORMAL
- en: Number precision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The precision of [`numpy.number`](arrays.scalars.html#numpy.number "numpy.number")
    subclasses is treated as a covariant generic parameter (see [`NBitBase`](#numpy.typing.NBitBase
    "numpy.typing.NBitBase")), simplifying the annotating of processes involving precision-based
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Consequently, the likes of [`float16`](arrays.scalars.html#numpy.float16 "numpy.float16"),
    [`float32`](arrays.scalars.html#numpy.float32 "numpy.float32") and [`float64`](arrays.scalars.html#numpy.float64
    "numpy.float64") are still sub-types of [`floating`](arrays.scalars.html#numpy.floating
    "numpy.floating"), but, contrary to runtime, they’re not necessarily considered
    as sub-classes.
  prefs: []
  type: TYPE_NORMAL
- en: Timedelta64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`timedelta64`](arrays.scalars.html#numpy.timedelta64 "numpy.timedelta64")
    class is not considered a subclass of [`signedinteger`](arrays.scalars.html#numpy.signedinteger
    "numpy.signedinteger"), the former only inheriting from [`generic`](arrays.scalars.html#numpy.generic
    "numpy.generic") while static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 0D arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During runtime numpy aggressively casts any passed 0D arrays into their corresponding
    [`generic`](arrays.scalars.html#numpy.generic "numpy.generic") instance. Until
    the introduction of shape typing (see [**PEP 646**](https://peps.python.org/pep-0646/))
    it is unfortunately not possible to make the necessary distinction between 0D
    and >0D arrays. While thus not strictly correct, all operations are that can potentially
    perform a 0D-array -> scalar cast are currently annotated as exclusively returning
    an *ndarray*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is known in advance that an operation _will_ perform a 0D-array -> scalar
    cast, then one can consider manually remedying the situation with either [`typing.cast`](https://docs.python.org/3/library/typing.html#typing.cast
    "(in Python v3.11)") or a `# type: ignore` comment.'
  prefs: []
  type: TYPE_NORMAL
- en: Record array dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dtype of [`numpy.recarray`](generated/numpy.recarray.html#numpy.recarray
    "numpy.recarray"), and the `numpy.rec` functions in general, can be specified
    in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly via the `dtype` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With up to five helper arguments that operate via [`numpy.format_parser`](generated/numpy.format_parser.html#numpy.format_parser
    "numpy.format_parser"): `formats`, `names`, `titles`, `aligned` and `byteorder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two approaches are currently typed as being mutually exclusive, *i.e.*
    if `dtype` is specified than one may not specify `formats`. While this mutual
    exclusivity is not (strictly) enforced during runtime, combining both dtype specifiers
    can lead to unexpected or even downright buggy behavior.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A [`Union`](https://docs.python.org/3/library/typing.html#typing.Union "(in
    Python v3.11)") representing objects that can be coerced into an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others this includes the likes of:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Nested) sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects implementing the *__array__* protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs: []
  type: TYPE_NORMAL
- en: '[array_like](../glossary.html#term-array_like):'
  prefs: []
  type: TYPE_NORMAL
- en: Any scalar or sequence that can be interpreted as an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A [`Union`](https://docs.python.org/3/library/typing.html#typing.Union "(in
    Python v3.11)") representing objects that can be coerced into a [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype").
  prefs: []
  type: TYPE_NORMAL
- en: 'Among others this includes the likes of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`type`](https://docs.python.org/3/library/functions.html#type "(in Python
    v3.11)") objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character codes or the names of [`type`](https://docs.python.org/3/library/functions.html#type
    "(in Python v3.11)") objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects with the `.dtype` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying and constructing data types](arrays.dtypes.html#arrays-dtypes-constructing)'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive overview of all objects that can be coerced into data types.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A [generic](https://docs.python.org/3/glossary.html#term-generic-type "(in Python
    v3.11)") version of [`np.ndarray[Any, np.dtype[+ScalarType]]`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray").
  prefs: []
  type: TYPE_NORMAL
- en: Can be used during runtime for typing arrays with a given dtype and unspecified
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.21.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A type representing [`numpy.number`](arrays.scalars.html#numpy.number "numpy.number")
    precision during static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Used exclusively for the purpose static type checking, [`NBitBase`](#numpy.typing.NBitBase
    "numpy.typing.NBitBase") represents the base of a hierarchical set of subclasses.
    Each subsequent subclass is herein used for representing a lower level of precision,
    *e.g.* `64Bit > 32Bit > 16Bit`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.20.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is a typical usage example: [`NBitBase`](#numpy.typing.NBitBase "numpy.typing.NBitBase")
    is herein used for annotating a function that takes a float and integer of arbitrary
    precision as arguments and returns a new float of whichever precision is largest
    (*e.g.* `np.float16 + np.int64 -> np.float64`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
