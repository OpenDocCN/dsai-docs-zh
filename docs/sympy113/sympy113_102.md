# 数值计算

> 原文链接：[https://docs.sympy.org/latest/modules/numeric-computation.html](https://docs.sympy.org/latest/modules/numeric-computation.html)

像SymPy这样的符号计算代数系统有助于构建和操作数学表达式。但是，当需要对数值数据进行评估时，符号系统的性能通常较差。

幸运的是，SymPy提供了许多易于使用的钩子，可以连接到其他数值系统，允许您在SymPy中创建数学表达式，然后将其传送到您选择的数值系统。本页记录了许多可用选项，包括`math`库、流行的数组计算包`numpy`、在Fortran或C中生成代码以及使用数组编译器`Aesara`。

## Subs/evalf

Subs是最慢但最简单的选项。它以SymPy的速度运行。`.subs(...).evalf()`方法可以用数值值替换符号值，然后在SymPy中评估结果。

```py
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x
>>> expr.evalf(subs={x: 3.14})
0.000507214304613640 
```

这种方法速度较慢。仅在性能不是问题时，才应在生产中使用此方法。你可以预期`.subs`耗时数十微秒。在原型设计阶段或者只需查看值时，这可能很有用。

## Lambdify

`lambdify`函数将SymPy表达式转换为Python函数，利用各种数值库。其用法如下：

```py
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x
>>> f = lambdify(x, expr)
>>> f(3.14)
0.000507214304614 
```

在这里，lambdify创建一个计算`f(x) = sin(x)/x`的函数。默认情况下，lambdify依赖于`math`标准库中的实现。这种数值评估大约需要数百纳秒，比`.subs`方法快大约两个数量级。这是SymPy和原始Python之间的速度差异。

Lambdify可以利用多种数值后端。默认情况下使用`math`库。但它也支持`mpmath`和最显著的是`numpy`。使用`numpy`库可以让生成的函数访问由编译的C代码支持的强大的矢量化ufuncs。

```py
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x
>>> f = lambdify(x, expr, "numpy") 
```

```py
>>> import numpy
>>> data = numpy.linspace(1, 10, 10000)
>>> f(data)
[ 0.84147098  0.84119981  0.84092844 ... -0.05426074 -0.05433146
 -0.05440211] 
```

如果你有基于数组的数据，这可能会显著加快速度，每个元素大约在10纳秒左右。不幸的是，NumPy会产生一些启动时间，并引入几微秒的额外开销。

CuPy是一个与NumPy兼容的数组库，主要运行在CUDA上，但也越来越多地支持其他GPU制造商。在许多情况下，它可以作为numpy的即插即用替代品。

```py
>>> f = lambdify(x, expr, "cupy")
>>> import cupy as cp
>>> data = cp.linspace(1, 10, 10000)
>>> y = f(data) # perform the computation
>>> cp.asnumpy(y) # explicitly copy from GPU to CPU / numpy array
[ 0.84147098  0.84119981  0.84092844 ... -0.05426074 -0.05433146
 -0.05440211] 
```

JAX是CuPy的类似替代方案，通过即时编译到XLA提供GPU和TPU加速。在某些情况下，它也可以作为numpy的即插即用替代品。

```py
>>> f = lambdify(x, expr, "jax")
>>> import jax.numpy as jnp
>>> data = jnp.linspace(1, 10, 10000)
>>> y = f(data) # perform the computation
>>> numpy.asarray(y) # explicitly copy to CPU / numpy array
array([ 0.84147096,  0.8411998 ,  0.84092844, ..., -0.05426079,
 -0.05433151, -0.05440211], dtype=float32) 
```

## uFuncify

内联代码（`autowrap`）模块包含一些能够帮助进行高效计算的方法。

+   [autowrap](codegen.html#id1)方法用于编译由[codegen](codegen.html#codegen-prose)模块生成的代码，并将二进制包装供Python使用。

+   [binary_function](codegen.html#binary-function)方法自动化了将SymPy表达式自动包装并附加到`Function`对象的步骤。

+   [ufuncify](codegen.html#ufuncify-method)生成一个二元函数，支持在numpy数组上进行广播，使用不同的后端比`subs/evalf`和`lambdify`更快。

所有上述内容的API参考在这里列出：[`sympy.utilities.autowrap()`](utilities/autowrap.html#module-sympy.utilities.autowrap "sympy.utilities.autowrap")。

## Aesara

SymPy与[Aesara](https://aesara.readthedocs.io/en/latest/)有着紧密的连接，是一个数学数组编译器。SymPy表达式可以轻松转换为Aesara图，然后使用Aesara编译器链进行编译。

```py
>>> from sympy import *
>>> from sympy.abc import x
>>> expr = sin(x)/x 
```

```py
>>> from sympy.printing.aesaracode import aesara_function
>>> f = aesara_function([x], [expr]) 
```

如果希望进行数组广播或者类型处理，Aesara需要额外的信息。

```py
>>> f = aesara_function([x], [expr], dims={x: 1}, dtypes={x: 'float64'}) 
```

Aesara比SymPy的C/Fortran代码打印机有一个更复杂的代码生成系统。除其他外，它处理常见的子表达式，并编译到GPU上。Aesara还支持SymPy的Matrix和Matrix Expression对象。

## 所以我应该使用哪一个？

这里的选项按从最慢和最少依赖到最快和最多依赖的顺序列出。例如，如果安装了Aesara，则通常是最佳选择。如果没有安装Aesara但安装了`f2py`，则应使用`ufuncify`。如果您一直使用numpy模块使用lambdify，并且有GPU，那么CuPy和JAX可以提供显著的加速效果而几乎没有额外工作。

| 工具 | 速度 | 特性 | 依赖项 |
| --- | --- | --- | --- |
| subs/evalf | 50us | 简单 | None |
| lambdify | 1us | 标量函数 | math |
| lambdify-numpy | 10ns | 向量函数 | numpy |
| ufuncify | 10ns | 复杂向量表达式 | f2py, Cython |
| lambdify-cupy | 10ns | GPU上的向量函数 | cupy |
| lambdify-jax | 10ns | CPU、GPU和TPU上的向量函数 | jax |
| Aesara | 10ns | 多输出，CSE，GPU | Aesara |
