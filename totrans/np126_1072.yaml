- en: Array API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组API
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/array.html](https://numpy.org/doc/1.26/reference/c-api/array.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/c-api/array.html](https://numpy.org/doc/1.26/reference/c-api/array.html)
- en: 'The test of a first-rate intelligence is the ability to hold twoopposed ideas
    in the mind at the same time, and still retain theability to function.— *F. Scott
    Fitzgerald*For a successful technology, reality must take precedence over publicrelations,
    for Nature cannot be fooled.— *Richard P. Feynman* ## Array structure and data
    access'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '一流智慧的试金石是能够同时保持两种相反的想法，并仍然保持能够正常运作的能力。— *F. Scott Fitzgerald*对于成功的技术，现实必须优先于公关，因为自然不能被愚弄。—
    *理查德·P·费曼* ## 数组结构和数据访问'
- en: These macros access the [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") structure members and are defined in `ndarraytypes.h`. The input
    argument, *arr*, can be any [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that is directly interpretable as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")* (any instance of the [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and its sub-types).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏访问[`PyArrayObject`](types-and-structures.html#c.PyArrayObject "PyArrayObject")结构成员，并在`ndarraytypes.h`中定义。输入参数*arr*可以是任何可直接解释为[PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")（`PyArray_Type`及其子类型的任何实例）的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(在Python v3.11中)")*。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The number of dimensions in the array.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的维度数量。
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Returns an integer representing the [array-flags](#array-flags).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表示[array-flags](#array-flags)的整数。
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Return the (builtin) typenumber for the elements of this array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此数组元素的（内置）类型编号。
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Convert obj and place it in the ndarray, *arr*, at the place pointed to by itemptr.
    Return -1 if an error occurs or 0 on success.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象转换并放置在由itemptr指向的位置的ndarray，*arr*中。如果发生错误则返回-1，成功则返回0。
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: New in version 1.7.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中新增。
- en: Enables the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 启用指定的数组标志。此函数不进行验证，假定您知道自己在做什么。
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: New in version 1.7.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中新增。
- en: Clears the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清除指定的数组标志。此函数不进行验证，假定您知道自己在做什么。
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These two macros are similar and obtain the pointer to the data-buffer for the
    array. The first macro can (and should be) assigned to a particular pointer where
    the second is for generic processing. If you have not guaranteed a contiguous
    and/or aligned array then be sure you understand how to access the data in the
    array to avoid memory and/or alignment problems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏类似，并获取数组的数据缓冲区指针。第一个宏可以（并且应该）分配给特定指针，而第二个用于通用处理。如果您没有保证数组是连续的和/或对齐的，请确保了解如何访问数组中的数据，以避免内存和/或对齐问题。
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Returns a pointer to the dimensions/shape of the array. The number of elements
    matches the number of dimensions of the array. Can return `NULL` for 0-dimensional
    arrays.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的维度/形状的指针。元素数量与数组的维度数量相匹配。对于0维数组可以返回`NULL`。
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: New in version 1.7.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中新增。
- en: A synonym for [`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS"), named to be
    consistent with the [`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape") usage within Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS")同义，命名一致以符合Python中的[`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape")用法。
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Returns a pointer to the strides of the array. The number of elements matches
    the number of dimensions of the array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的步幅的指针。元素数量与数组的维度数量相匹配。
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Return the shape in the *n* \(^{\textrm{th}}\) dimension.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第*n*（第n个）维度的形状。
- en: '[PRE12]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Return the stride in the *n* \(^{\textrm{th}}\) dimension.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 返回第*n*（第n个）维度的步幅。
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Return the itemsize for the elements of this array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此数组元素的项大小。
- en: Note that, in the old API that was deprecated in version 1.7, this function
    had the return type `int`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在版本1.7中弃用的旧API中，此函数的返回类型为`int`。
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Returns the total size (in number of elements) of the array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的总大小（元素数量）。
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Returns 0 if *obj* is not a sub-class of ndarray. Otherwise, returns the total
    number of elements in the array. Safer version of [`PyArray_SIZE`](#c.PyArray_SIZE
    "PyArray_SIZE") (*obj*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*不是ndarray的子类，则返回0。否则，返回数组中元素的总数。[`PyArray_SIZE`](#c.PyArray_SIZE "PyArray_SIZE")（*obj*）的更安全版本。
- en: '[PRE16]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Returns the total number of bytes consumed by the array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组消耗的总字节数。
- en: '[PRE17]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This returns the base object of the array. In most cases, this means the object
    which owns the memory the array is pointing at.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的基础对象。在大多数情况下，这意味着拥有数组指向的内存的对象。
- en: If you are constructing an array using the C API, and specifying your own memory,
    you should use the function [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject") to set the base to an object which owns the memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用C API构建数组，并指定自己的内存，您应该使用函数[`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject")将基础设置为拥有内存的对象。
- en: If the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag is set, it has a different meaning, namely base is the array into which the
    current array will be copied upon copy resolution. This overloading of the base
    property for two functions is likely to change in a future version of NumPy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")标志，它具有不同的含义，即基础是当前数组解析时将被复制到的数组。这种对两个函数的基础属性的重载可能在未来的NumPy版本中发生变化。
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Returns a borrowed reference to the dtype property of the array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的dtype属性的借用引用。
- en: '[PRE19]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: New in version 1.7.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.7起新增。
- en: A synonym for PyArray_DESCR, named to be consistent with the ‘dtype’ usage within
    Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个和PyArray_DESCR同义的名字，命名一致是为了符合Python中“dtype”的用法。
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Get a Python object of a builtin type from the ndarray, *arr*, at the location
    pointed to by itemptr. Return `NULL` on failure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从ndarray *arr*在itemptr指向的位置获取一个内置类型的Python对象。失败时返回`NULL`。
- en: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item") is identical to PyArray_GETITEM.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item")等同于PyArray_GETITEM。'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The function pointed to by the [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__"). The first argument is the newly created sub-type.
    The second argument (if not NULL) is the “parent” array (if the array was created
    using slicing or some other operation where a clearly-distinguishable parent is
    present). This routine can do anything it wants to. It should return a -1 on error
    and 0 otherwise.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in
    Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__")指向的函数。第一个参数是新创建的子类型。第二个参数（如果不是NULL）是“父”数组（如果数组是使用分片或某些其他操作创建的，其中存在清晰可区分的父对象）。此例程可以执行任何它想要的操作。它应该在错误时返回-1，否则返回0。
- en: Data access
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据访问
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数和宏为从C语言轻松访问ndarray的元素提供了便利。这对所有数组都有效。但是，如果要访问数组中的数据，需要注意如果数据不符合机器字节顺序，未对齐或不可写。换句话说，请务必遵守标志的状态，除非您知道您正在做什么，或者之前已经使用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")保证了一个可写，对齐和机器字节顺序的数组。如果希望处理所有类型的数组，各类型的copyswap函数用于处理行为不端的数组非常有用。一些平台（例如Solaris）不喜欢不对齐的数据，如果您取消引用一个不对齐的指针，它们就会崩溃。其他平台（例如x86
    Linux）会在处理不对齐的数据时工作得更慢。
- en: '[PRE22]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向ndarray *aobj*在由c数组*ind*给出的N维索引处的数据的指针（该指针的大小必须至少为*aobj*->nd）。您可能需要将返回的指针强制转换为ndarray的数据类型。
- en: '[PRE23]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ndarray * obj * 中给定坐标的快速内联访问，* obj * 必须分别具有 1、2、3 或 4 个维度（未检查此）。对应的* i *、*
    j *、* k *和* l *坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针类型转换为阵列的数据类型。
- en: Creating arrays
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: From scratch
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从零开始
- en: '[PRE27]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数窃取了对* descr *的引用。获取它的最简单方法是使用[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")。
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的数组创建函数。大多数新数组都是使用这个灵活的函数创建的。
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象是 Python 类型 *subtype* 的对象，它必须是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的子类型。数组具有 *nd* 维度，由 *dims* 描述。新数组的数据类型描述符是 *descr*。
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果* subtype *是数组子类的而不是基本的[`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")，那么* obj *是要传递给子类的[`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__")方法的对象。
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *data* 为`NULL`，则将分配新的未初始化内存，并且 *flags* 可以为非零，表示 Fortran 风格连续数组。使用[`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE")来初始化内存。
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *data* 不为`NULL`，则假定它指向要用于数组的内存，并且 *flags* 参数将用作数组的新标志（除了 [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA
    "NPY_ARRAY_OWNDATA")、[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") 标志的新数组状态将被重置）。
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果* data *不为 NULL，则还可以提供* strides *。如果* strides *为`NULL`，则数组步幅将计算为 C 风格连续（默认）或
    Fortran 风格连续（* data * =`NULL`或* flags * & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")为非零非NULL* data *）。为新数组对象复制任何提供的* dims *和* strides *。
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides")可帮助验证非`NULL`的步幅信息。'
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 *data*，则它必须在数组的生命周期内保持存活。通过[`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject")来管理这一点是一种方法。
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: New in version 1.6.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.6 的新功能。
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果* descr *不为 NULL，则此函数将窃取对*descr*的引用。此数组创建例程允许方便地创建与现有数组的形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER")时，如果*prototype*是Fortran数组，则结果顺序为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，否则为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")。当*order*为[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")时，结果顺序与*prototype*的顺序匹配，即使*prototype*的轴不是C或Fortran顺序。
- en: If *descr* is NULL, the data type of *prototype* is used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*descr*为NULL，则使用*prototype*的数据类型。
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*subok*为1，则新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")（…），除了您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义的）类型。如果类型始终具有相同的字节数，则*itemsize*将被忽略。否则，*itemsize*指定此数组的特定大小。
- en: Warning
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据被传递给[`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")或[`PyArray_New`](#c.PyArray_New
    "PyArray_New")，则在删除新数组之前不得释放此内存。如果此数据来自另一个Python对象，则可以通过对该对象使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)")并将新数组的base成员指向该对象来实现。如果传入了步幅，则它们必须与数组的维数、itemsize和数据一致。
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的未初始化数组，其类型为*typenum*，每个*nd*维中的大小由整数数组*dims*给出。数组的内存是未初始化的（除非typenum为[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")，在这种情况下，数组中的每个元素都设置为NULL）。*typenum*参数允许指定任何内置数据类型，例如[`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT")或[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")。如果需要，可以使用[`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE")（return_object, 0）将数组的内存设置为零。此函数不能用于创建灵活类型的数组（未给出itemsize）。
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定指针指向的*data*周围创建一个数组包装器。数组标志将具有默认设置，即数据区域是良好行为的，并且是C风格连续的。数组的形状由长度为*nd*的*dims*
    c数组确定。数组的数据类型由*typenum*指示。如果数据来自另一个引用计数的Python对象，则应该在传入指针之后增加此对象的引用计数，并且返回的ndarray的base成员应指向拥有数据的Python对象。这将确保在返回的数组存在时不会释放提供的内存。
- en: '[PRE32]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function steals a reference to *descr*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数会偷取对*descr*的引用。
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的数据类型描述符*descr*，创建一个形状由*nd*和*dims*确定的新数组。
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 填充被*obj*指向的数组，*obj*必须是一个ndarray的子类，用*val*的内容（作为字节评估）。此宏调用memset，因此obj必须是连续的。
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个形状由*dims*确定，数据类型由*dtype*确定的新*nd*维数组。如果*fortran*不是零，则创建一个Fortran顺序数组，否则创建一个C顺序数组。用零填充内存（或如果*dtype*对应于[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ，则填充为0对象）。
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 宏形式的[`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") ，其参数为类型数字而不是数据类型对象。
- en: '[PRE36]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个形状由*dims*确定，数据类型由*dtype*确定的新*nd*维数组。如果*fortran*非零，则创建一个Fortran顺序的数组，否则创建一个C顺序的数组。该数组未初始化，除非数据类型对应于[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ，此时数组将填充为[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)")。
- en: '[PRE37]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 宏形式的[`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") ，其参数为类型数字*typenum*而不是数据类型对象。
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个新的一维数据类型为*typenum*的数组，范围从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**(*start*,
    *stop*, *step*, dtype)。
- en: '[PRE39]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个由`descr`确定数据类型的新的一维数组，范围从`start`到`stop`（不包括`stop`），步长为`step`。相当于arange(`start`,
    `stop`, `step`, typenum)。
- en: '[PRE40]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: New in version 1.7.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.7版开始。
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数**偷取一个引用**，将`obj`设为`arr`的基本属性。
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过将自己的内存缓冲区作为参数传递来构建数组，则需要设置数组的*base*属性，以确保内存缓冲区的生命周期适当。
- en: The return value is 0 on success, -1 on failure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值为成功时为0，失败时为-1。
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的对象是一个数组，则此函数遍历*base*指针链，以使每个数组直接指向内存的所有者。一旦设定了基本值，就不能将其更改为另一个值。
- en: From other objects
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自其他对象
- en: '[PRE41]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从任何嵌套序列或暴露数组接口的对象*op*中获取数组的主要函数。参数允许指定所需的*dtype*，最小(*min_depth*)和最大(*max_depth*)可接受的维数，以及数组的其他*requirements*。这个函数**窃取了对dtype参数的引用**，它需要是一个表示所需数据类型（包括所需的字节顺序）的[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")结构。*dtype*参数可能是`NULL`，表示任何数据类型（以及字节顺序）都可接受。除非[`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST")在`flags`中出现，否则此调用将生成错误，如果无法安全地从对象中获取数据类型。如果要对*dtype*使用`NULL`并确保数组没有被交换，则使用[`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny")。深度参数为0表示忽略该参数。可以向*requirements*参数中添加以下任何数组标志（*例如*使用|）。如果您的代码可以处理一般的（*例如*分步，字节交换或不对齐的数组），则*requirements*可能为0。此外，如果*op*不是一个数组（或者不公开数组接口），那么将创建一个新的数组（并使用序列协议从*op*中填充）。新数组的flags成员将具有[`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")。*context*参数未使用。
- en: '[PRE42]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Make sure the returned array is C-style contiguous
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是C风格连续的
- en: '[PRE43]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Make sure the returned array is Fortran-style contiguous.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是Fortran风格连续的。
- en: '[PRE44]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组对其数据类型有适当的边界。一个对齐的数组具有数据指针和每个步幅因子都是数据类型描述符的对齐因子的倍数。
- en: '[PRE45]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure the returned array can be written to.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组可写。
- en: '[PRE46]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对*op*进行了复制。如果没有此标志，则只有在可以避免时才不会复制数据。
- en: '[PRE47]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确保结果是一个基类的ndarray。默认情况下，如果*op*是ndarray的子类的实例，则会返回该相同子类的实例。如果设置了这个标志，则会返回一个ndarray对象。
- en: '[PRE48]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 强制对输出类型进行转换，即使不能安全地进行。如果没有这个标志，只有在可以安全地进行数据转换时才会发生数据转换，否则将引发错误。
- en: '[PRE49]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*已经是一个数组，但不符合要求，则会进行复制（这将满足要求）。 如果存在此标志，并且必须复制（已经是数组的对象的复制），则在返回的复制中设置相应的[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志，并使*op*为只读。 您必须确保调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")将内容复制回*op*，并且*op*数组将再次变为可写。 如果*op*一开始就不可写，或者它不是一个数组，则会引发错误。
- en: '[PRE50]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE52]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE53]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE54]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE55]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE56]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE57]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE58]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE59]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE60]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE61]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE62]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE63]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎与[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")（…）相同，只是*requirements*可以包含[`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED")（覆盖*dtype*中的规范）和[`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES")，表明数组应以步幅是元素大小的倍数的意义对齐。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 的 1.6 版本及之前版本中，以下标志没有使用_ARRAY_宏命名空间。1.7 版本中不再使用该形式的常量名称。
- en: '[PRE64]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组具有机器字节顺序的数据类型描述符，覆盖*dtype*参数中的任何规范。通常，字节顺序要求由*dtype*参数确定。如果设置了此标志并且dtype参数未指示机器字节顺序描述符（或为
    NULL 并且对象已经是具有非机器字节顺序的数据类型描述符的数组），则创建一个新的数据类型描述符并将其用于其字节顺序字段设置为 native。
- en: '[PRE65]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
- en: '[PRE66]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure the returned array has strides that are multiples of the element size.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组的步幅是元素大小的倍数。
- en: '[PRE67]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") 的特殊情况，当*op*已经是一个数组但需要是特定的*newtype*（包括字节顺序）或具有某些*要求*时。'
- en: '[PRE68]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露数组接口协议并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在 Python v3.11)")的借用引用。
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在 Python v3.11)")的借用引用。
- en: '[PRE70]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露[`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")方法的Python对象返回一个ndarray对象。[`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__")方法可以接受0个或1个参数`([dtype])`。*context*未使用。
- en: '[PRE71]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或数组接口导出的对象*op*返回一个(C样式)连续和行为良好的函数数组，其类型由枚举*typenum*给出，最小深度为*min_depth*，最大深度为*max_depth*。(非灵活)。相当于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")，并将要求设置为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")和类型参数的type_num成员设置为*typenum*。
- en: '[PRE72]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或数组接口导出的对象返回一个良好行为的C样式连续数组。数组可以具有的最小维数由*min_depth*给出，最大维数由*max_depth*给出。这相当于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")，并将要求设置为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")和[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")。
- en: '[PRE73]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何嵌套序列或数组接口导出的对象**op**返回一个对齐的、本地字节顺序的数组，其类型由枚举类型号给出。数组可以具有的最小维数由*min_depth*给出，最大维数由*max_depth*给出。这相当于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")，并将要求设置为BEHAVED。
- en: '[PRE74]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数**窃取对op的引用**，并确保op是一个基类ndarray。它特殊处理数组标量，否则调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")(`op`，NULL，0，0，[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")，NULL)。
- en: '[PRE75]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从长度为*slen*的二进制或（ASCII）文本`string`构造一个单一类型的一维ndarray。要创建的数组的数据类型由`dtype`给出。如果*num*为-1，则**复制**整个字符串并返回一个适当大小的数组，否则，`num`是从字符串中**复制**的项数。如果`sep`为NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型为`dtype`的项。某些数据类型在文本模式下可能无法读取，如果发生这种情况，将引发错误。所有错误都返回NULL。
- en: '[PRE76]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制或文本文件中构造单一类型的一维ndarray。打开的文件指针是`fp`，要创建的数组的数据类型由`dtype`给出。这必须与文件中的数据匹配。如果`num`为-1，则读取到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项目数。如果`sep`为NULL（或“”），则从文件中以二进制模式读取，否则以文本模式从文件中读取，并使用`sep`提供项目分隔符。有些数组类型无法以文本模式读取，此时会引发错误。
- en: '[PRE77]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从导出（单一段）缓冲区协议的对象`buf`构造单一类型的一维ndarray。首先尝试可写缓冲区，然后尝试只读缓冲区。返回的数组的[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")标志将反映哪种操作成功。假定数据从对象的内存位置的起始位置偏移`offset`字节开始。缓冲区中的数据类型将根据数据类型描述符`dtype`进行解释。如果`count`为负，则它将根据缓冲区的大小和请求的itemsize来确定，否则，`count`表示应从缓冲区转换多少元素。
- en: '[PRE78]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从源数组`src`复制到目标数组`dest`，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回0）。`src`的形状必须可以广播到`dest`的形状。目标数组和源数组的数据区域不能重叠。
- en: '[PRE79]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数组强制转换规则，将对象`src`分配给NumPy数组`dest`。这基本上与[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")相同，但直接分配给输出数组。成功返回0，失败返回-1。
- en: '[PRE80]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将源数组`src`中的数据移动到目标数组`dest`中，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回0）。`src`的形状必须可以广播到`dest`的形状。目标数组和源数组的数据区域可能重叠。
- en: '[PRE81]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`已经（C风格）是连续且表现良好的数组，那么只需返回一个引用，否则返回一个（连续且表现良好的）数组的副本。参数`op`必须是一个（多维数组的）ndarray的子类，并且没有进行其他检查。
- en: '[PRE82]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将`obj`转换为ndarray。参数可以是任何嵌套序列或导出数组接口的对象。这是使用`NULL`、0、0、0作为其他参数的[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")的宏形式。您的代码必须能够处理任何数据类型描述符和使用此宏的数据标志的任何组合。
- en: '[PRE83]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，只是它可以接受一个*requirements*参数，指示返回的数组必须具有的属性。可强制执行的可用要求包括[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")、[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")、[`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")、[`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY")、[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")、[`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST")和[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")。还可以使用标准的标志组合：
- en: '[PRE84]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，只是它可以接受一个*typenum*参数，指定返回数组的类型码。
- en: '[PRE85]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结合[`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF")和[`PyArray_FROM_OT`](#c.PyArray_FROM_OT
    "PyArray_FROM_OT")，允许提供*typenum*和*flags*两个参数。
- en: '[PRE86]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")，但是数据类型通过类型码指定。[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*)直接传递给[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。如果传入`NPY_ARRAY_ENSURECOPY`作为要求，此宏还会将[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")添加到要求中。
- en: '[PRE87]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 封装了以axis=关键字作为输入参数，以None作为axis参数的函数和方法的功能。输入数组是`obj`，而`*axis`是一个转换后的整数（使得>=MAXDIMS表示None值），`requirements`给出了`obj`的所需属性。输出是输入的转换版本，以满足要求，并且如果需要则执行了展平操作。在输出中，负数值的`*axis`会被转换，并检查新值以确保与`obj`的形状一致。
- en: Dealing with types
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理类型
- en: General check of Python Type
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python类型的一般检查
- en: '[PRE88]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是一个Python对象，并且其类型是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的子类型，则求值为真。
- en: '[PRE89]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是一个Python对象，并且其类型是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")，则求值为真。
- en: '[PRE90]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`实现了数组接口的任何部分，则`out`将包含对使用接口创建的新ndarray的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，`out`将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented)的借用引用，并且不会设置错误条件。
- en: '[PRE91]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`实现了数组接口的任何部分，则`out`将包含对使用接口创建的新ndarray的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，`out`将包含对Py_NotImplemented的借用引用，并且不会设置错误条件。此版本允许在寻找[`__array__`](../arrays.classes.html#numpy.class.__array__)属性的数组接口的部分中设置数据类型。*context*未使用。
- en: '[PRE92]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是（子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type)的实例且维数为0，则评估为真。
- en: '[PRE93]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是`Py{cls}ArrType_Type`的实例，则评估为真。
- en: '[PRE94]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是数组标量（`PyGenericArr_Type`的子类型的实例）或者（子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type)的实例且维数为0，则评估为真。
- en: '[PRE95]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是内置数值类型（int、float、complex、long、bool）的实例，则评估为真。
- en: '[PRE96]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是内置的Python标量对象（int、float、complex、bytes、str、long、bool），则评估为真。
- en: '[PRE97]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python标量对象（请参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar)）或数组标量（`PyGenericArr_Type`的子类型的实例）的实例，则评估为真。
- en: '[PRE98]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python标量对象（请参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar)）、数组标量（`PyGenericArr_Type`的子类型的实例）或者维数为0的[`PyArray_Type`](types-and-structures.html#c.PyArray_Type)的子类型的实例，则评估为真。
- en: Data-type checking
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型检查
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于typenum宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可以直接解释为[PyArrayObject](types-and-structures.html#c.PyArrayObject)的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject)。
- en: '[PRE99]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Type represents an unsigned integer.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示无符号整数。
- en: '[PRE102]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Type represents a signed integer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示有符号整数。
- en: '[PRE105]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Type represents any integer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任何整数。
- en: '[PRE108]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Type represents any floating point number.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任何浮点数。
- en: '[PRE111]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Type represents any complex floating point number.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任何复数浮点数。
- en: '[PRE114]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Type represents any integer, floating point, or complex floating point number.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任何整数、浮点数或复数浮点数。
- en: '[PRE117]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Type represents a string data type.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示字符串数据类型。
- en: '[PRE120]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示枚举类型，对应于标准Python标量中的一个（bool、int、float或complex）。
- en: '[PRE123]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表了一种灵活的数组类型（[`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING "NPY_STRING")，[`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE
    "NPY_UNICODE")或者[`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID")）。
- en: '[PRE126]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 类型没有附加的大小信息，并且可以重新调整大小。应仅在灵活的数据类型上调用。附加到数组的类型始终会有大小，因此不存在该宏的数组形式。
- en: Changed in version 1.18.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.18 开始更改。
- en: For structured datatypes with no fields this function now returns False.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有字段的结构化数据类型，此函数现在返回 False。
- en: '[PRE127]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Type represents a user-defined type.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表用户定义的类型。
- en: '[PRE130]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Type is either flexible or user-defined.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是灵活的或用户定义的。
- en: '[PRE133]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Type represents object data type.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表对象数据类型。
- en: '[PRE136]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Type represents Boolean data type.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表布尔数据类型。
- en: '[PRE139]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Type has fields associated with it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 类型有与之关联的字段。
- en: '[PRE141]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ndarray *m* 的数据区域按照数组的数据类型描述符是机器字节顺序的话，则评估为真。
- en: '[PRE142]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ndarray *m* 的数据区域 **不** 按照数组的数据类型描述符是机器字节顺序的话，则评估为真。
- en: '[PRE143]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *type1* 和 *type2* 在此平台上实际上表示等效类型（忽略每种类型的 fortran 成员），则返回[`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE")。例如，在 32 位平台上，[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")
    和 [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") 是等效的。否则返回[`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")。
- en: '[PRE144]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a1* 和 *a2* 是在此平台上具有等效类型的数组，则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。
- en: '[PRE145]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")（…）的特殊情况，不接受灵活的数据类型，但可能更容易调用。'
- en: '[PRE146]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字节顺序字符 *b1* 和 *b2*（[`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE")，[`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG")，[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")，[`NPY_IGNORE`](#c.NPY_IGNORE
    "NPY_IGNORE")）相等或等效，则为真。因此，在小端机器上，[`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") 和
    [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE") 是等效的，而在大端机器上不等效。
- en: Converting data types
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换数据类型
- en: '[PRE147]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于向后兼容 Numeric C-API 和简单地将类型转换为非灵活类型。返回一个新的数组对象，其元素为 *arr* 转换为数据类型 *typenum*，*typenum*
    必须是枚举类型之一，而不是灵活类型。
- en: '[PRE148]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定的 *type* 的新数组，将 *arr* 的元素转换为适当的类型。fortran 参数指定输出数组的顺序。
- en: '[PRE149]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.6 开始，此函数只是调用了 [`PyArray_CopyInto`](#c.PyArray_CopyInto "PyArray_CopyInto")，它处理了类型转换。
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组 *in* 的元素转换为数组 *out*。输出数组应可写，具有输入数组中元素数量的整数倍（可以在 out 中放置多个副本），并具有一个内建类型的数据类型。成功时返回
    0，如果发生错误则返回 -1。
- en: '[PRE150]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从给定描述符转换为内置类型数的低级转换函数。如果没有转换函数存在，则返回`NULL`并设置错误。使用此函数而不是直接访问*from*->f->cast将允许支持添加到描述符的转换字典中的任何用户定义的转换函数。
- en: '[PRE151]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*fromtype*数据类型的数组可以转换为*toptype*数据类型的数组而不会丢失信息，则返回非零值。唯一的例外是64位整数可以转换为64位浮点数，即使这样做会丢失大整数的精度，这是为了避免在没有显式请求的情况下过多使用长双精度。此函数不检查灵活数组类型的长度。
- en: '[PRE152]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")在NumPy
    1.6及更高版本中已被弃用。'
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)。
- en: '[PRE153]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: New in version 1.6.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中加入。
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*fromtype*数据类型的数组（可以包括灵活类型）可以根据*casting*规则安全地转换为*toptype*数据类型的数组（可以包括灵活类型），则返回非零值。对于使用[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")的简单类型来说，这基本上只是[`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely")的一个包装器，但对于字符串或unicode等灵活类型，它会考虑它们的大小生成结果。只有整数和浮点类型（使用[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")）能够转换为足够大以容纳转换前的整数/浮点类型的最大值的字符串或unicode类型。
- en: '[PRE154]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: New in version 1.6.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中加入。
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*arr*可以根据*casting*规则转换为*totype*，则返回非零值。如果*arr*是数组标量，则其值也会被考虑在内，当将其转换为较小类型时，值不会溢出或被截断时也会返回非零值。
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), toptype, casting)的结果相同，但它还处理了一个特殊情况，因为具有相同位数的类型中uint值的集合不是int值的子集。
- en: '[PRE155]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: New in version 1.6.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中加入。
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*arr*是一个数组，则返回其数据类型描述符，但如果*arr*是一个数组标量（维度为0），则找到可以将值转换为而不会溢出或截断为整数的最小大小的数据类型。
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会将复数降级为浮点数或任何东西降级为布尔值，但在标量值为正数时，将有符号整数降级为无符号整数。
- en: '[PRE156]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: New in version 1.6.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中加入。
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 查找*type1*和*type2*可以安全转换为的最小大小和种类的数据类型。此函数是对称的和可结合的。字符串或unicode结果将是适当大小，以存储转换为字符串或unicode的输入类型的最大值。
- en: '[PRE157]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: New in version 1.6.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6中的新功能。
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用类型提升到所有输入数组和dtype对象，使用NumPy规则来组合标量和数组，以确定给定操作的输出类型的输出类型。这是ufuncs产生的相同结果类型。
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有关类型提升算法的更多详细信息，请参阅[`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type")的文档。
- en: '[PRE158]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数已被[`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")和/或[`PyArray_ResultType`](#c.PyArray_ResultType
    "PyArray_ResultType")取代。
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于确定两个或多个数组可以转换为的公共类型。它仅适用于非灵活的数组类型，因为没有传递itemsize信息。*mintype*参数表示可接受的最小类型，*op*表示将转换为数组的对象。返回值是表示*op*应具有的数据类型的枚举类型编号。
- en: '[PRE159]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能的功能在1.6中引入的迭代器[`NpyIter`](iterator.html#c.NpyIter "NpyIter")或所有操作数的相同dtype参数的标志[`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE")已大部分被取代。
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含在*op*中的Python对象序列转换为具有相同数据类型的ndarrays数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，并且*n*
    -长度的[`PyArrayObject`](types-and-structures.html#c.PyArrayObject "PyArrayObject")指针数组是返回值（如果发生错误，则返回`NULL`）。返回的数组必须由此例程的调用者释放（使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE")），并且其中的所有数组对象都必须`DECREF`，否则将发生内存泄漏。下面的示例模板代码显示了典型的用法：
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.18.0开始更改：标量和零维数组的混合现在会产生一个能够容纳标量值的类型。先前优先考虑数组的dtype。
- en: '[PRE160]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的大小为*arr* ->itemsize的内存的指针，该内存保存该类型的0的表示。返回的指针*ret*在不再需要时**必须**使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret)释放。
- en: '[PRE162]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的大小为*arr* ->itemsize的内存的指针，该内存保存该类型的1的表示。返回的指针*ret*在不再需要时**必须**使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret)释放。
- en: '[PRE163]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*typenum*表示有效的类型编号（内置或用户定义或字符代码），则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。否则，此函数返回[`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")。
- en: User-defined data types
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的数据类型
- en: '[PRE164]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Initialize all function pointers and members to `NULL`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有函数指针和成员初始化为`NULL`。
- en: '[PRE165]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为数组注册一个新的用户定义的数据类型。该类型必须填充了大部分条目。这通常不会被检查，错误可能会导致段错误。特别地，`dtype` 结构的 typeobj
    成员必须填充为具有与 *dtype* 的 elsize 成员对应的固定大小元素大小的 Python 类型。此外，如果不需要某些转换函数，`f` 成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem
    和 cast（如果不需要支持，则一些转换函数可能为`NULL`）。为了避免混淆，应选择一个唯一的字符类型代码，但这并不是强制执行的，也不是内部依赖的。
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个用户定义的类型编号，用于唯一标识该类型。然后，可以使用返回的类型编号从[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")中获取到新结构的指针。如果发生错误，则返回-1。如果此 *dtype* 已经被注册（仅通过指针的地址进行检查），则返回先前分配的类型编号。
- en: '[PRE166]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注册低级转换函数*castfunc*，将数据类型*descr*转换为给定的数据类型编号*totype*。任何旧的转换功能都将被覆盖。成功返回`0`，失败返回`-1`。
- en: '[PRE167]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据类型编号*totype*注册为可以从给定*totype*的数据类型对象*descr*进行类型转换。使用*scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")表示可以安全地将数据类型*descr*的数组转换为类型编号为*totype*的数据类型。成功返回0，失败返回-1。
- en: '[PRE168]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串，返回该字符串作为类型对象名称的数据类型编号。如果找不到类型，则不设置错误返回`NPY_NOTYPE`。仅适用于用户定义的数据类型。
- en: Special functions for NPY_OBJECT
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPY_OBJECT的特殊函数
- en: Warning
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理填充有对象的数组或缓冲区时，NumPy会尽量确保这些缓冲区在可以读取任何数据之前都填充了`None`。然而，可能存在代码路径，其中数组只被初始化为`NULL`。NumPy本身将`NULL`视为`None`的别名，但在调试模式下可能会`assert`非`NULL`。
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '因为NumPy在初始化None方面还不一致，用户在处理由NumPy创建的缓冲区时**必须**预期得到`NULL`的值。用户**也应**确保将完全初始化的缓冲区传递给NumPy，因为在将来NumPy可能会将此变为强制要求。 '
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有意确保 NumPy 总是在可能被读取之前初始化对象数组。任何不这样做的失败都将被视为一个错误。将来，用户可能可以在从任何数组中读取时依赖非NULL的值，尽管对于在ufunc代码中写入新创建的数组的输出数组可能仍然存在一些例外情况（例如，对于
    NumPy 1.23 中存在的已知代码路径，没有进行正确的填充）。
- en: '[PRE169]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何 Python 对象的数组*op*。根据*op*的数据类型递增数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回0。
- en: '[PRE170]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 用于根据数据类型*dtype*增加位置*ptr*处的所有对象的引用计数的函数。如果*ptr*是具有任何偏移量处的对象的结构类型的开头，则（递归地）增加结构类型中所有类似对象的引用计数。
- en: '[PRE171]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何 Python 对象的数组*op*。根据*op*的数据类型递减数组中每个对象的引用计数。正常返回值为0。如果发生错误，则返回-1。
- en: '[PRE172]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在数据类型*dtype*中记录的位置*ptr*上的所有类似对象的函数。这样递归地工作，因此如果`dtype`本身具有包含类似对象的数据类型的字段，则所有类似对象字段都将被XDECREF
    `'d`。
- en: '[PRE173]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 用单个值obj在所有具有对象数据类型的结构位置上填充新创建的数组。不执行任何检查，但*arr*必须是[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")数据类型的单段未初始化的拷贝（位置上没有先前的对象）。如果需要在调用此函数之前递减对象数组中的所有项，则使用[`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF")(*arr*)。
- en: '[PRE174]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件：`arr`是`base`的一个拷贝（尽管可能具有不同的步幅、顺序等）。设置[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志和`arr->base`，并将`base`设置为READONLY。在调用*Py_DECREF*之前调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")以便将任何更改复制回`base`并重置READONLY标志。
- en: Returns 0 for success, -1 for failure.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回0，失败返回-1。
- en: '## Array flags'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数组标志'
- en: The `flags` attribute of the `PyArrayObject` structure contains important information
    about the memory used by the array (pointed to by the data member) This flag information
    must be kept accurate or strange results and even segfaults may result.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyArrayObject`结构的`flags`属性包含有关数组（由数据成员指向）使用的内存的重要信息。这些标志信息必须保持准确，否则可能会产生奇怪的结果，甚至可能导致段错误。'
- en: There are 6 (binary) flags that describe the memory area used by the data buffer.
    These constants are defined in `arrayobject.h` and determine the bit-position
    of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like
    interface for getting (and, if appropriate, setting) these flags.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有6个（二进制）标志描述了数据缓冲区所使用的内存区域。这些常量在`arrayobject.h`中定义，并确定标志的位位置。Python公开了一个良好的基于属性的接口以及一个类似字典的接口，用于获取（如果合适，则设置）这些标志。
- en: Memory areas of all kinds can be pointed to by an ndarray, necessitating these
    flags. If you get an arbitrary `PyArrayObject` in C-code, you need to be aware
    of the flags that are set. If you need to guarantee a certain kind of array (like
    [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    and [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")), then pass
    these requirements into the PyArray_FromAny function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 所有种类的内存区域都可以被ndarray指向，因此需要这些标志。如果在C代码中获得一个随意的`PyArrayObject`，则需要了解设置的标志。如果需要保证某种类型的数组（例如[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")和[`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")），则将这些要求传递给PyArray_FromAny函数。
- en: Basic Array Flags
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数组标志
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ndarray可以有一个数据段，它不是一个简单的连续的可操作的内存块。它可能与字边界不对齐（在一些平台上非常重要）。它可能以机器不认识的另一种字节顺序存储数据。它可能是不可写的。它可能是以Fortran连续的顺序。数组标志用于指示与数组相关联的数据的特性。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy的1.6版本及更早版本中，以下标志没有在它们的常量名称中使用_ARRAY_宏命名空间。在1.7中，这种常量名称形式已被弃用。
- en: '[PRE175]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The data area is in C-style contiguous order (last index varies the fastest).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域是C风格的连续顺序（最后一个索引变化最快）。
- en: '[PRE176]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域是以Fortran风格的连续顺序（第一个索引变化最快）。
- en: Note
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以同时是C风格和Fortran风格的连续数组。对于1维数组很明显，但对于更高维的数组也可能成立。
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于连续的数组，对于给定维度的步幅`arr.strides[dim]`，如果`arr.shape[dim] == 1`或数组没有元素，则可能是*任意的*。对于C风格的连续数组或Fortran风格的连续数组，一般而言不成立`self.strides[-1]
    == self.itemsize`或`self.strides[0] == self.itemsize`。从C API访问数组的`itemsize`的正确方法是`PyArray_ITEMSIZE(arr)`。
- en: See also
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarray的内部内存布局](../arrays.ndarray.html#arrays-ndarray)'
- en: '[PRE177]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域归此数组所有。不应手动设置，而是创建一个包装数据的`PyObject`，并将数组的基设置为该对象。例如，请参见`test_mem_policy`中的测试。
- en: '[PRE178]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The data area and all array elements are aligned appropriately.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域和所有数组元素都被适当对齐。
- en: '[PRE179]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The data area can be written to.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域可以被写入。
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述三个标志被定义为新的、行为良好的数组具有这些标志为真。
- en: '[PRE180]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域代表一个（行为良好的）副本，其信息在调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")时应传递回原始数据。
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊标志，如果这个数组表示一个用户由于在[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")中需要某些标志而制作的副本，那么必须对其他数组进行复制（并且用户要求在这种情况下设置此标志）。
    然后基本属性指向“表现不当”的数组（设置为只读）。 [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")将其内容拷贝回“表现不当”的数组（必要时进行转换），并将“表现不当”的数组重置为[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")。 如果“表现不当”的数组一开始就不是[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")，那么 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")就会返回一个错误，因为
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    是不可能的。
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags")（obj，flags）将为
    `flags` 更新 `obj->flags`，可以是 [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    或 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") 中的任意一个。'
- en: Combinations of array flags
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组标志的组合
- en: '[PRE181]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE182]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE183]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE184]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE185]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE186]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE187]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: Flag-like constants
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似标志的常量
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量用于 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")（及其宏形式）中，以指定新数组的期望属性。
- en: '[PRE188]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Cast to the desired type, even if it can’t be done without losing information.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为所需类型，即使这样做会导致信息的丢失。
- en: '[PRE189]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Make sure the resulting array is a copy of the original.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 确保生成的数组是原始数组的副本。
- en: '[PRE190]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 确保生成的对象是一个实际的 ndarray，而不是一个子类。
- en: Flag checking
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志检查
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些宏，arr必须是（或其子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的实例。
- en: '[PRE191]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个参数arr必须是ndarray或其子类。参数*flags*应该是一个整数，包含数组可以具有的可能标志的按位组合: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")。'
- en: '[PRE192]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Evaluates true if *arr* is C-style contiguous.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr是C风格连续的，则为真。
- en: '[PRE193]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Evaluates true if *arr* is Fortran-style contiguous.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr是Fortran风格连续的，则为真。
- en: '[PRE194]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr是Fortran风格连续的且*不是*C风格连续的，使用[`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS
    "PyArray_IS_F_CONTIGUOUS")是测试Fortran风格连续性的正确方法。
- en: '[PRE195]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Evaluates true if the data area of *arr* can be written to
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区可以写入，则为真。
- en: '[PRE196]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区在机器上适当对齐，则为真。
- en: '[PRE197]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区对齐且可写，并且符合其描述符的机器字节顺序，则为真。
- en: '[PRE198]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区对齐且符合机器字节顺序，则为真。
- en: '[PRE199]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区是C风格连续的，并且[`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*)为true，则为真。
- en: '[PRE200]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区是Fortran风格连续的，并且[`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*)为true，则为真。
- en: '[PRE201]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区是C风格连续的，对齐，并且在机器字节顺序中，则为真。
- en: '[PRE202]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区是Fortran风格连续的，对齐，并且在机器字节顺序**中，则为真。
- en: '[PRE203]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果arr的数据区由一个（C风格或Fortran风格）连续的段组成，则为真。
- en: '[PRE204]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")和[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")数组标志可以从数组对象本身“计算”出来。此例程根据*flagmask*中指定的要求执行所需的计算，更新*arr*的一个或多个这些标志。'
- en: Warning
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行可能导致这些标志发生改变的数组操作时，保持标志的更新是很重要的（可以使用[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags")帮助进行更新）。NumPy中后续依赖于这些标志状态的计算不会重复计算以更新它们。
- en: '[PRE205]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*是可写的，则此函数不会执行任何操作并返回0。如果*obj*不可写，则引发异常并返回-1。它也可以执行其他一些工作，例如对正在转换为视图的数组发出警告。在向数组写入之前一定要调用此函数。
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*是数组的名称，用于提供更好的错误消息。它可以是“分配目标”、“输出数组”或甚至只是“数组”之类的东西。'
- en: Array method alternative API
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组方法替代API
- en: Conversion
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: '[PRE206]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield")（*self*，*dtype*，*offset*）。该函数[窃取一个引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*，并使用当前数组中指定*offset*字节的数据返回给定*dtype*类型的新数组。新数组类型的*offset*加itemsize必须小于`self
    ->descr->elsize`，否则会引发错误。使用与原始数组相同的形状和步幅。因此，该函数的作用类似于从结构化数组中返回字段。但它也可以用于从任何数组类型中选择特定的字节或字节组。
- en: '[PRE207]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield")（*self*，*val*，*dtype*，*offset*）。从*offset*字节处开始，将给定*dtype*类型的字段设置为*val*。*offset*加*dtype*→elsize必须小于*self*→descr→elsize，否则会引发错误。否则，将*val*参数转换为数组并复制到指向的字段。必要时，将重复*val*的元素以填充目标数组，但目标数组中的元素数量必须是*val*中元素数量的整数倍。
- en: '[PRE208]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap")（*self*，*inplace*）。返回一个数据区域进行字节交换的数组。如果*inplace*非零，则在原地执行字节交换并返回对自身的引用。否则，创建一个进行字节交换的副本，保持原数组不变。
- en: '[PRE209]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy")（*self*，*fortran*）。复制*old*数组。返回的数组始终是对齐且可写的，数据解释与旧数组相同。如果*order*是[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则返回一个C样式连续的数组。如果*order*是[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，则返回一个Fortran样式连续的数组。如果*order*是[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，那么只有当旧数组是Fortran样式连续时，才返回Fortran样式连续的数组；否则，就是C样式连续的数组。
- en: '[PRE210]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist")（*self*）。从*self*返回一个嵌套的Python列表。
- en: '[PRE211]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes")（*self*，*order*）。以Python字符串的形式返回这个数组的字节。
- en: '[PRE212]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以C风格连续的方式将*self*的内容写入文件指针*fp*。如果*sep*是字符串“”或`NULL`，则以二进制字节形式写入数据。否则，使用*sep*字符串作为项分隔符，将*self*的内容作为文本写入文件。每个项将被打印到文件中。如果*format*字符串不是`NULL`或“”，那么它是一个Python打印语句格式字符串，显示如何编写这些项。
- en: '[PRE213]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 将*self*中的对象封装为给定的*file*（可以是字符串或Python文件对象）。如果*file*是Python字符串，则被认为是一个文件的名称，然后以二进制模式打开。使用给定的*protocol*（如果*protocol*为负值，则使用最高可用级别）。这只是cPickle.dump(*self*,
    *file*, *protocol*)的一个简单封装。
- en: '[PRE214]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 将*self*中的对象封装成Python字符串并返回。使用提供的Pickle *protocol*（如果*protocol*为负值，则使用可用的最高级别）。
- en: '[PRE215]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 用给定的标量对象*obj*填充数组*arr*。首先将对象转换为*arr*的数据类型，然后将其复制到每个位置。如果发生错误，返回-1，否则返回0。
- en: '[PRE216]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view")（*self*，*dtype*）。将数组*self*作为可能是不同数据类型*dtype*和不同数组子类*ptype*的新视图返回。
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*dtype*为`NULL`，则返回的数组将具有与*self*相同的数据类型。新数据类型必须与*self*的大小一致。要么项大小必须相同，要么*self*必须是单段的，总字节数必须相同。在后一种情况下，返回的数组的维度将在最后一个（或对于Fortran风格连续数组为第一个）维度上发生变化。返回的数组和*self*的数据区域完全相同。
- en: Shape Manipulation
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状操作
- en: '[PRE217]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个新数组（如果可能的话指向与*self*相同的内存位置），但形状由*newshape*给出。如果新形状与*self*的步幅不兼容，那么将返回一个具有新指定形状的数组的副本。
- en: '[PRE218]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape")（*self*，*shape*），其中*shape*是一个序列。将*shape*转换为一个[`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims
    "PyArray_Dims")结构并在内部调用[`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")。出于向后兼容性
    - 不推荐使用
- en: '[PRE219]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*)。返回一个从*self*中去除所有长度为1的维度的新视图。
- en: Warning
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象始终是2维的。因此，对矩阵子类的数组，[`PyArray_Squeeze`](#c.PyArray_Squeeze "PyArray_Squeeze")
    没有任何效果。
- en: '[PRE220]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*)。返回的数组是数据在*self*中给定轴*a1*和*a2*交换后的新视图。
- en: '[PRE221]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    )。这个函数只能用于单片段数组。它会改变*self*的形状并且如果*newshape*与旧形状的元素总数不同时将重新分配*self*的内存。如果需要重新分配，则*self*必须拥有它的数据，有*self*
    - `>base==NULL`，有*self* - `>weakrefs==NULL`，且（除非refcheck为0）不被任何其他数组引用。fortran参数可以是[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")，或者[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")。它目前没有任何效果。最终它可以用于确定重新调整操作在构建不同维度的数组时如何查看数据。成功时返回None，错误时返回NULL。
- en: '[PRE222]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*)。根据数据结构*permute*重新排列ndarray对象*self*的轴并返回结果。如果*permute*为`NULL`，则结果数组的轴被反转。例如，如果*self*的形状为\(10\times20\times30\)，并且*permute*
    `.ptr`为(0,2,1)，则结果的形状为\(10\times30\times20\)。如果*permute*为`NULL`，则结果的形状为\(30\times20\times10\)。
- en: '[PRE223]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*)。返回数组的1维拷贝。如果*order*为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，则按Fortran顺序扫描元素（第一维变化最快）。如果*order*为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则按C顺序扫描*self*的元素（最后一维变化最快）。如果*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，则使用[`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN")
    (*self*)的结果来确定要展平的顺序。
- en: '[PRE224]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 *self*.ravel(*order*)。与 [`PyArray_Flatten`](#c.PyArray_Flatten "PyArray_Flatten")
    (*self*, *order*) 具有相同的基本功能，除非 *order* 为 0 并且 *self* 是 C 样式连续的，否则形状会改变，但不会执行复制操作。
- en: Item selection and manipulation
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目选择和操作
- en: '[PRE225]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*)，除了在 Python
    中 *axis* =None 对应的 C 语言中 *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")。沿着给定的
    *axis* 提取由整数值 *indices* 指示的 self 中的项目。clipmode 参数可以是 [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE")、[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP") 或 [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP")，表示如何处理超出边界的索引。*ret* 参数可以指定一个输出数组，而不是在内部创建一个数组。
- en: '[PRE226]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 *self*.put(*values*, *indices*, *clipmode* )。在相应的（扁平化的）*indices* 中将 *values*
    放入 *self*。如果 *values* 太小，将根据需要重复它。
- en: '[PRE227]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *values* 放入 *self* 中，其中对应位置（使用扁平化的上下文）在 *mask* 中为 true。*mask* 和 *self* 数组必须具有相同数量的元素。如果
    *values* 太小，将根据需要重复它。
- en: '[PRE228]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*)。沿着给定的 *axis* 将 *self* 的元素复制 *op*
    次。*op* 可以是一个标量整数或者长度为 *self* ->dimensions[ *axis* ] 的序列，指示沿着轴重复每个项目的次数。
- en: '[PRE229]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*)。根据 *self* 中的整数值从 *op*
    中的数组序列中选择元素创建一个新数组。这些数组必须都可以广播到相同的形状，而 *self* 中的条目应该在 0 和 len(*op*) 之间。输出放在 *ret*
    中，除非它是 `NULL`，在这种情况下会创建一个新的输出。*clipmode* 参数确定当 *self* 中的条目不在 0 和 len(*op*) 之间时的行为。
- en: '[PRE230]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: raise a ValueError;
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 ValueError；
- en: '[PRE231]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 len(*op*) 包装值 < 0，通过减去 len(*op*) 包装值 >=len(*op*)，直到它们在范围内；
- en: '[PRE232]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: all values are clipped to the region [0, len(*op*) ).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都被剪切到区间 [0, len(*op*) )。
- en: '[PRE233]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于 [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*)。返回沿着 *axis* 排序的 *self* 的项目数组。数组使用由
    *kind* 指示的算法排序，这是一个指向使用的排序算法类型的整数/枚举。
- en: '[PRE234]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort")(*self*, *axis*)。返回一个索引数组，以便沿给定的`axis`选择这些索引会返回一个排序后的*self*。如果*self*->descr是带字段定义的数据类型，则会使用self->descr->names来确定排序顺序。
    当第一个字段相等时，将使用第二个字段，以此类推。要更改结构数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。
- en: '[PRE235]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个相同形状的数组序列（*sort_keys*），返回一个索引数组（类似于[`PyArray_ArgSort`](#c.PyArray_ArgSort
    "PyArray_ArgSort") (…)）可按字典顺序排序数组。字典顺序指定当两个键被发现相等时，顺序是基于后续键的比较。对于类型，需要定义一种合并排序（遗留相等条目）。
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数组都被收集到一个结构数组中，那么[`PyArray_Sort`](#c.PyArray_Sort "PyArray_Sort") (…)也可以用来直接对数组进行排序。
- en: '[PRE236]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted")(*self*, *values*, *side*, *perm*)。假设*self*是按升序排列的一维数组，那么输出就是一个与*values*相同形状的索引数组，以便按顺序插入*values*中的元素，将保持*self*的顺序。不会对*self*是否按升序进行检查。
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*side*参数指示返回的索引是第一个合适位置的（如果[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")），还是最后一个的（如果[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）。'
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sorter*参数不是`NULL`，必须是一个与*self*长度相同的整数索引的一维数组，用于将其按升序排序。这通常是对[`PyArray_ArgSort`](#c.PyArray_ArgSort
    "PyArray_ArgSort") (…)的调用结果。二元搜索用于找到所需的插入点。
- en: '[PRE237]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于 [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition")（*self*、*ktharray*、*axis*、*kind*）。分区数组，使得由*ktharray*索引的元素的值位于如果数组完全排序后它们应处的位置，并将所有小于kth的元素放在kth之前，所有等于或大于kth的元素放在kth之后。所有分区内元素的排序是未定义的。如果*self*->descr是具有字段定义的数据类型，则使用self->descr->names来确定排序顺序。如果第一个字段相等，则使用第二个字段，依此类推。要更改结构化数组的排序顺序，创建一个字段名称顺序不同的新数据类型，并用这种新数据类型构造数组的视图。成功返回零，失败返回-1。
- en: '[PRE238]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于 [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition")（*self*、*ktharray*、*axis*、*kind*）。返回一个索引数组，这些索引沿着给定的`axis`选择时会返回*self*的一个分区版本。
- en: '[PRE239]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于 [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal")（*self*、*offset*、*axis1*、*axis2*）。返回由*axis1*和*axis2*定义的2维数组的*offset*对角线。
- en: '[PRE240]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: New in version 1.6.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6版中的新功能。
- en: Counts the number of non-zero elements in the array object *self*.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 计数数组对象*self*中的非零元素数量。
- en: '[PRE241]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于 [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero")（*self*）。返回一个索引数组的元组，这些索引数组选取*self*中的非零元素。如果（nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM")（`self`））==1，则返回一个索引数组。索引数组的数据类型为 [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP
    "NPY_INTP")。如果返回的是元组（nd \(\neq\) 1），则其长度为nd。
- en: '[PRE242]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于 [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress")（*self*、*condition*、*axis*）。返回沿*axis*的元素，对应于*condition*中为真的元素。
- en: Calculation
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算
- en: Tip
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在axis中传入 [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") 以达到与在Python中传入`axis=None`（将数组视为一维数组）时获得的同样效果。
- en: Note
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: out参数指定结果的放置位置。如果out为NULL，则创建输出数组；否则，输出将放在out中，out必须具有正确的大小和类型。即使out不为NULL，也总是返回对输出数组的新引用。如果out不为NULL，调用此函数的人有责任使用
    `Py_DECREF` out，否则将发生内存泄漏。
- en: '[PRE243]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*)。返回 *self* 沿 *axis* 的最大元素的索引。
- en: '[PRE244]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*)。返回 *self* 沿 *axis* 的最小元素的索引。
- en: '[PRE245]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max "numpy.ndarray.max")
    (*self*, *axis*)。返回 *self* 沿给定 *axis* 的最大元素。当结果是单个元素时，返回一个 numpy 标量而不是一个 ndarray。
- en: '[PRE246]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min "numpy.ndarray.min")
    (*self*, *axis*)。返回 *self* 沿给定 *axis* 的最小元素。当结果是单个元素时，返回一个 numpy 标量而不是一个 ndarray。
- en: '[PRE247]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp "numpy.ndarray.ptp")
    (*self*, *axis*)。返回 *self* 沿 *axis* 的最大元素与沿 *axis* 的最小元素之间的差异。当结果是单个元素时，返回一个 numpy
    标量而不是一个 ndarray。
- en: Note
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: rtype 参数指定了减少应该在其上进行的数据类型。如果数组的数据类型不足以处理输出，则这一点很重要。默认情况下，所有整数数据类型都至少与 [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") 一样大，用于“add”和“multiply”ufuncs（这些是平均值、和、累加和、乘积和累积乘积函数的基础）。
- en: '[PRE248]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*)。返回沿给定 *axis* 的元素的平均值，使用枚举类型 *rtype*
    作为求和时的数据类型。默认求和行为使用 [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE "NPY_NOTYPE") 作为 *rtype*。
- en: '[PRE249]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*)。返回由 *axis1*
    和 *axis2* 变量定义的 2 维数组的 *offset* 对角线元素的总和（使用 *rtype* 作为求和的数据类型）。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。
- en: '[PRE250]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*)。裁剪数组 *self*，使大于 *max* 的值固定为 *max*，小于
    *min* 的值固定为 *min*。
- en: '[PRE251]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*)。返回 *self* 的复共轭。如果 *self* 不是复数数据类型，则返回一个带有引用的
    *self*。
- en: '[PRE252]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*，*decimals*，*out*)。返回将元素四舍五入到最接近小数位的数组。小数位定义为 \(\(10^{-\textrm{decimals}}\)
    位，因此负 *decimals* 导致四舍五入到最接近的10、100 等。如果 out 为 `NULL`，则创建输出数组，否则将输出放置在 *out* 中，
    *out* 必须具有正确的大小和类型。
- en: '[PRE253]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std "numpy.ndarray.std")
    (*self*，*axis*，*rtype*)。返回使用沿着 *axis* 转换为数据类型 *rtype* 的数据的标准差。
- en: '[PRE254]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum "numpy.ndarray.sum")
    (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的一维向量和。在将数据转换为数据类型 *rtype* 后执行求和。
- en: '[PRE255]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的累积一维和。在将数据转换为数据类型
    *rtype* 后执行求和。
- en: '[PRE256]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的一维乘积。在将数据转换为数据类型
    *rtype* 后执行乘积。
- en: '[PRE257]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") （*self*，*axis*，*rtype*）。返回`self`沿着`axis`累积乘积的一维数组。在将数据转换为数据类型`rtype`后执行乘积。
- en: '[PRE258]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all "numpy.ndarray.all")
    (*self*，*axis*)。对于由`axis`定义的`self`的每个一维子数组，返回具有True元素的数组，其中所有元素为True。
- en: '[PRE259]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any "numpy.ndarray.any")
    (*self*, *axis*)。对于由*axis*定义的*self*的每个一维子数组，返回具有True元素的数组，其中任何元素为True。
- en: Functions
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Array Functions
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组函数
- en: '[PRE260]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将多维数组视为 C 风格的多维数组是有用的，以便可以使用 C 的 a[i][j][k] 语法实现算法。此例程返回一个指针，*ptr*，模拟这种类型的
    C 风格数组，用于 1、2 和 3 维ndarrays。
- en: 'Parameters:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op** – 任何 Python 对象的地址。此 Python 对象将被替换为等效的良好行为的、C 风格的连续的给定数据类型的 ndarray。请确保以这种方式窃取输入对象的引用是合理的。'
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ptr** – 一个（1-d的ctype*，2-d的ctype**，或3-d的ctype***）变量的地址，其中ctype是该数据类型的等效C类型。在返回时，*ptr*将作为1-d，2-d或3-d数组可寻址。'
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dims** – 一个包含数组对象形状的输出数组。这个数组给出了任何即将发生的循环的边界。'
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nd** – 数组的维度（1、2或3）。'
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**typedescr** – 一个 [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") 结构，表示所需的数据类型（包括所需的字节顺序）。该调用将会窃取参数的引用。'
- en: Note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2-d和3-d数组，C风格数组的模拟是不完整的。例如，模拟的指针数组不能传递给期望特定的静态定义的2-d和3-d数组的子例程。要传递给需要这些类型输入的函数，必须静态定义所需的数组并复制数据。
- en: '[PRE261]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 必须与从[`PyArray_AsCArray`](#c.PyArray_AsCArray "PyArray_AsCArray")返回的相同对象和内存位置一起调用（…）。此函数清理了否则将会泄漏的内存。
- en: '[PRE262]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 将*obj*中的对象序列沿着*axis*合并成单个数组。如果维度或类型不兼容，则会引发错误。
- en: '[PRE263]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在*obj1*和*obj2*的最后维度上计算一个积和。两个数组都不是共轭的。
- en: '[PRE264]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在*obj1*的最后一个维度和*obj2*的倒数第二个维度上计算一个积和。对于2-d数组而言，这是一个矩阵积。两个数组都不是共轭的。
- en: '[PRE265]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: New in version 1.6.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.6版本新增。
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyArray_MatrixProduct相同，但将结果存储在*out*中。输出数组必须具有正确的形状、类型，并且是C连续的，否则将引发异常。
- en: '[PRE266]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: New in version 1.6.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.6版本新增。
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对所提供的数组操作数应用爱因斯坦求和约定，返回一个新数组或将结果放在*out*中。*subscripts*中的字符串是索引字母的逗号分隔列表。操作数数量由*nop*确定，*op_in*是包含这些操作数的数组。可以使用*dtype*强制输出的数据类型，可以使用*order*强制输出的顺序（推荐使用[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")），当指定*dtype*时，*casting*表示数据转换应该有多宽容。
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多细节，请参见[`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")函数。
- en: '[PRE267]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 一个仅适用于2-d数组的专门的复制和转置函数。返回的数组是*op*的转置副本。
- en: '[PRE268]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 计算1-d数组*op1*和*op2*的1-d相关性。相关性是通过将*op1*乘以*op2*的一个移位版本并求和来计算的。由于移位，*op1*和*op2*定义范围之外所需的值被解释为零。模式确定要返回多少移位：0
    - 仅返回不需要假设零值的移位；1 - 返回一个与*op1*大小相同的对象；2 - 返回所有可能的移位（任何重叠都被接受）。
- en: Notes
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这不计算通常的相关性：如果op2比op1大，则会交换参数，并且对于复杂数组，永远不会进行共轭。有关通常的信号处理相关性，请参见PyArray_Correlate2。
- en: '[PRE269]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 更新版本的PyArray_Correlate，它使用了1d数组的常规相关定义。相关性是通过在每个输出点上将*op1*乘以*op2*的一个移位版本并求和来计算的。由于移位，
    *op1* 和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少移位：0 - 仅返回不需要假设零值的移位；1 - 返回一个与*op1*大小相同的对象；2
    - 返回所有可能的移位（任何重叠都被接受）。
- en: Notes
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Compute z as follows:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 计算z如下：
- en: '[PRE270]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`和`y`都是`NULL`，那么返回[`PyArray_Nonzero`](#c.PyArray_Nonzero "PyArray_Nonzero")(*condition*)。否则，*x*和*y*必须都给出且返回的对象的形状与*condition*相同，并且在*condition*分别为True或False时的元素是*x*和*y*。
- en: Other functions
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他函数
- en: '[PRE272]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 确定*newstrides*是否是与具有形状`dims`和元素大小*elsize*的*nd*维数组的内存一致的跨度数组。将检查*newstrides*数组，以查看每个方向跳跃所需的字节数是否会超过*numbytes*，而*numbytes*是可用内存段的假定大小。如果*numbytes*为0，那么将计算出一个等效的*numbytes*，假设*nd*，*dims*和*elsize*指的是单段数组。如果*newstrides*可接受，则返回[`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE")，否则返回[`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE")。
- en: '[PRE273]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例程都会将*n*长度的整数数组*seq*相乘并返回结果。不执行溢出检查。
- en: '[PRE275]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个长度为*n*的整数数组*l1*和*l2*，如果列表相同，则返回1；否则，返回0。
- en: Auxiliary Data With Object Semantics
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有对象语义的辅助数据
- en: New in version 1.7.0.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7.0中的新内容。
- en: '[PRE276]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: When working with more complex dtypes which are composed of other dtypes, such
    as the struct dtype, creating inner loops that manipulate the dtypes requires
    carrying along additional data. NumPy supports this idea through a struct [`NpyAuxData`](#c.NpyAuxData
    "NpyAuxData"), mandating a few conventions so that it is possible to do this.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用更复杂的由其他dtype组成的dtype（例如struct dtype）时，创建操作dtype的内部循环需要携带额外的数据。NumPy通过一个struct
    [`NpyAuxData`](#c.NpyAuxData "NpyAuxData")来支持这个想法，要求一些约定，以便可以做到这一点。
- en: Defining an [`NpyAuxData`](#c.NpyAuxData "NpyAuxData") is similar to defining
    a class in C++, but the object semantics have to be tracked manually since the
    API is in C. Here’s an example for a function which doubles up an element using
    an element copier function as a primitive.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 定义[`NpyAuxData`](#c.NpyAuxData "NpyAuxData")类似于在C++中定义类，但由于API是用C编写的，因此必须手动跟踪对象语义。以下是使用元素复制函数作为原始函数来双倍元素的函数的示例。
- en: '[PRE277]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The function pointer type for NpyAuxData free functions.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: NpyAuxData释放函数的函数指针类型。
- en: '[PRE279]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: The function pointer type for NpyAuxData clone functions. These functions should
    never set the Python exception on error, because they may be called from a multi-threaded
    context.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: NpyAuxData克隆函数的函数指针类型。这些函数在错误时不应设置Python异常，因为它们可能会在多线程上下文中被调用。
- en: '[PRE280]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: A macro which calls the auxdata’s free function appropriately, does nothing
    if auxdata is NULL.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 一个宏，适当地调用辅助数据的释放函数，如果auxdata为NULL则不执行任何操作。
- en: '[PRE281]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: A macro which calls the auxdata’s clone function appropriately, returning a
    deep copy of the auxiliary data.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 一个宏，适当地调用辅助数据的克隆函数，返回辅助数据的深层副本。
- en: Array Iterators
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组迭代器
- en: As of NumPy 1.6.0, these array iterators are superseded by the new array iterator,
    [`NpyIter`](iterator.html#c.NpyIter "NpyIter").
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 自NumPy 1.6.0起，这些数组迭代器已被新的数组迭代器[`NpyIter`](iterator.html#c.NpyIter "NpyIter")取代。
- en: An array iterator is a simple way to access the elements of an N-dimensional
    array quickly and efficiently, as seen in [the example](iterator.html#iteration-example)
    which provides more description of this useful approach to looping over an array
    from C.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 数组迭代器是一种快速有效地访问N维数组元素的简单方法，如[示例](iterator.html#iteration-example)所示，该示例提供了关于从C中循环遍历数组的此有用方法的更多描述。
- en: '[PRE282]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Return an array iterator object from the array, *arr*. This is equivalent to
    *arr*. **flat**. The array iterator object makes it easy to loop over an N-dimensional
    non-contiguous array in C-style contiguous fashion.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组*arr*返回一个数组迭代器对象。这相当于*arr*。**flat**。数组迭代器对象使得以C风格连续方式循环遍历N维非连续数组变得容易。
- en: '[PRE283]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Return an array iterator that will iterate over all axes but the one provided
    in **axis*. The returned iterator cannot be used with [`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D"). This iterator could be used to write something similar
    to what ufuncs do wherein the loop over the largest axis is done by a separate
    sub-routine. If **axis* is negative then **axis* will be set to the axis having
    the smallest stride and that axis will be used.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个数组迭代器，它将遍历除了**axis*之外的所有轴。返回的迭代器不能与[`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D")一起使用。该迭代器可用于编写类似于ufunc的东西，其中最大轴的循环由单独的子例程完成。如果**axis*为负，则将**axis*设置为具有最小步幅的轴，并使用该轴。
- en: '[PRE284]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Return an array iterator that is broadcast to iterate as an array of the shape
    provided by *dimensions* and *nd*.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个广播为按*dimensions*和*nd*提供的形状的数组的数组迭代器。
- en: '[PRE285]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Evaluates true if *op* is an array iterator (or instance of a subclass of the
    array iterator type).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是数组迭代器（或数组迭代器类型的子类的实例），则评估为true。
- en: '[PRE286]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Reset an *iterator* to the beginning of the array.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*重置为数组的开头。
- en: '[PRE287]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Incremement the index and the dataptr members of the *iterator* to point to
    the next element of the array. If the array is not (C-style) contiguous, also
    increment the N-dimensional coordinates array.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*的索引和dataptr成员递增，指向数组的下一个元素。如果数组不是（C风格的）连续的，则还要递增N维坐标数组。
- en: '[PRE288]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: A pointer to the current element of the array.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的当前元素的指针。
- en: '[PRE289]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Set the *iterator* index, dataptr, and coordinates members to the location in
    the array indicated by the N-dimensional c-array, *destination*, which must have
    size at least *iterator* ->nd_m1+1.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*的索引、dataptr和coordinates成员设置为由N维C数组*destination*指示的数组位置，*destination*的大小必须至少为*iterator*->nd_m1+1。
- en: '[PRE290]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Set the *iterator* index and dataptr to the location in the array indicated
    by the integer *index* which points to an element in the C-styled flattened array.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*的索引和dataptr设置为由整数*index*指示的位置，该位置指向C风格展开的数组中的元素。
- en: '[PRE291]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Evaluates TRUE as long as the iterator has not looped through all of the elements,
    otherwise it evaluates FALSE.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 只要迭代器尚未遍历所有元素，就将TRUE评估为真，否则评估为假。
- en: Broadcasting (multi-iterators)
  id: totrans-679
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播（多迭代器）
- en: '[PRE292]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: A simplified interface to broadcasting. This function takes the number of arrays
    to broadcast and then *num* extra ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)") ) arguments. These arguments are converted to arrays and
    iterators are created. [`PyArray_Broadcast`](#c.PyArray_Broadcast "PyArray_Broadcast")
    is then called on the resulting multi-iterator object. The resulting, broadcasted
    mult-iterator object is then returned. A broadcasted operation can then be performed
    using a single loop and using [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的简化接口。此函数接受要进行广播的数组数量，然后获取 *num* 个额外的 ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)") ) 参数。这些参数将被转换为数组，并创建迭代器。然后在得到的多迭代器对象上调用 [`PyArray_Broadcast`](#c.PyArray_Broadcast
    "PyArray_Broadcast")。然后返回产生的广播多迭代器对象。然后可以使用单个循环执行广播操作，并使用 [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)
- en: '[PRE293]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Reset all the iterators to the beginning in a multi-iterator object, *multi*.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 重置多迭代器对象 *multi* 中所有迭代器到开始位置。
- en: '[PRE294]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Advance each iterator in a multi-iterator object, *multi*, to its next (broadcasted)
    element.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到其下一个（广播的）元素。
- en: '[PRE295]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Return the data-pointer of the *i* \(^{\textrm{th}}\) iterator in a multi-iterator
    object.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多迭代器对象中第 *i* \(^{\textrm{th}}\) 迭代器的数据指针。
- en: '[PRE296]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: Advance the pointer of only the *i* \(^{\textrm{th}}\) iterator.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 仅推进第 *i* \(^{\textrm{th}}\) 迭代器的指针。
- en: '[PRE297]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: Advance each iterator in a multi-iterator object, *multi*, to the given \(N\)
    -dimensional *destination* where \(N\) is the number of dimensions in the broadcasted
    array.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到给定的 \(N\) -维度 *destination*，其中 \(N\) 是广播数组中的维数。
- en: '[PRE298]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Advance each iterator in a multi-iterator object, *multi*, to the corresponding
    location of the *index* into the flattened broadcasted array.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到展开广播数组中 *index* 的相应位置。
- en: '[PRE299]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Evaluates TRUE as long as the multi-iterator has not looped through all of the
    elements (of the broadcasted result), otherwise it evaluates FALSE.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 只要多迭代器还没有遍历所有元素（广播结果的元素），它就会评估为 TRUE，否则评估为 FALSE。
- en: '[PRE300]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This function encapsulates the broadcasting rules. The *mit* container should
    already contain iterators for all the arrays that need to be broadcast. On return,
    these iterators will be adjusted so that iteration over each simultaneously will
    accomplish the broadcasting. A negative number is returned if an error occurs.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数封装了广播规则。*mit* 容器应已包含需要进行广播的所有数组的迭代器。返回时，这些迭代器将被调整，以便同时迭代每个数组可以完成广播。如果发生错误，将返回负数。
- en: '[PRE301]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: This function takes a multi-iterator object that has been previously “broadcasted,”
    finds the dimension with the smallest “sum of strides” in the broadcasted result
    and adapts all the iterators so as not to iterate over that dimension (by effectively
    making them of length-1 in that dimension). The corresponding dimension is returned
    unless *mit* ->nd is 0, then -1 is returned. This function is useful for constructing
    ufunc-like routines that broadcast their inputs correctly and then call a strided
    1-d version of the routine as the inner-loop. This 1-d version is usually optimized
    for speed and for this reason the loop should be performed over the axis that
    won’t require large stride jumps.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受先前已经“广播”的多迭代器对象，找到在广播结果中具有最小“步幅总和”的维度，并调整所有迭代器，以便在该维度上不进行迭代（实际上使它们在该维度上的长度为
    1）。返回相应的维度，除非 *mit* ->nd 为 0，那么返回 -1 。此函数对构造类似 ufunc 的例程非常有用，这些例程正确广播它们的输入，然后调用该例程的跨步
    1-d 版本作为内部循环。此 1-d 版本通常被优化为速度，因此应该沿着不需要大跨度跳跃的轴执行循环。
- en: Neighborhood iterator
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻域迭代器
- en: New in version 1.4.0.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.0 版的新增内容。
- en: Neighborhood iterators are subclasses of the iterator object, and can be used
    to iter over a neighborhood of a point. For example, you may want to iterate over
    every voxel of a 3d image, and for every such voxel, iterate over an hypercube.
    Neighborhood iterator automatically handle boundaries, thus making this kind of
    code much easier to write than manual boundaries handling, at the cost of a slight
    overhead.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 邻域迭代器是迭代器对象的子类，可用于迭代某一点的邻域。例如，您可能希望对 3D 图像的每个体素进行迭代，并对每个这样的体素进行超立方体的迭代。邻域迭代器会自动处理边界，因此使得这种代码的编写比手动处理边界容易得多，尽管会稍微增加一些开销。
- en: '[PRE302]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: This function creates a new neighborhood iterator from an existing iterator.
    The neighborhood will be computed relatively to the position currently pointed
    by *iter*, the bounds define the shape of the neighborhood iterator, and the mode
    argument the boundaries handling mode.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会根据iter当前指向的位置相对地创建一个新的邻域迭代器，bounds定义了邻域迭代器的形状，mode参数定义了边界处理模式。
- en: The *bounds* argument is expected to be a (2 * iter->ao->nd) arrays, such as
    the range bound[2*i]->bounds[2*i+1] defines the range where to walk for dimension
    i (both bounds are included in the walked coordinates). The bounds should be ordered
    for each dimension (bounds[2*i] <= bounds[2*i+1]).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '*bounds*参数应该是一个(2 * iter->ao->nd)的数组，比如范围bound[2*i]->bounds[2*i+1]定义了维度i上的范围（两个边界都包括在内）。每个维度的边界都应该是有序的（bounds[2*i]
    <= bounds[2*i+1]）。'
- en: 'The mode should be one of:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: mode应该是以下之一：
- en: '[PRE303]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Zero padding. Outside bounds values will be 0.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 零填充。超出边界的值将会是0。
- en: '[PRE304]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: One padding, Outside bounds values will be 1.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 单一填充，超出边界的值将会是1。
- en: '[PRE305]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Constant padding. Outside bounds values will be the same as the first item in
    fill_value.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 常量填充。超出边界的值将与fill_value的第一个项目相同。
- en: '[PRE306]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Mirror padding. Outside bounds values will be as if the array items were mirrored.
    For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will be 1, x[4]
    will be 4, x[5] will be 1, etc…
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像填充。超出边界的值将会像数组项一样做镜像处理。例如，对于数组 [1, 2, 3, 4]，x[-2] 将会是 2，x[-2] 将会是 1，x[4] 将会是
    4，x[5] 将会是 1，依此类推…
- en: '[PRE307]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: Circular padding. Outside bounds values will be as if the array was repeated.
    For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4]
    will be 1, x[5] will be 2, etc…
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 循环填充。超出边界的值将会被看作数组重复的值。例如，对于数组 [1, 2, 3, 4]，x[-2] 将会是 3，x[-2] 将会是 4，x[4] 将会是
    1，x[5] 将会是 2，依此类推…
- en: If the mode is constant filling (*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*),
    fill_value should point to an array object which holds the filling value (the
    first item will be the filling value if the array contains more than one item).
    For other cases, fill_value may be NULL.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果mode是常量填充（*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*），fill_value应该指向一个保存填充值的数组对象（如果数组包含多个项目，第一个项目将是填充值）。对于其他情况，fill_value可以是NULL。
- en: The iterator holds a reference to iter
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器持有对iter的引用
- en: Return NULL on failure (in which case the reference count of iter is not changed)
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时返回NULL（在这种情况下，iter的引用计数不会改变）
- en: 'iter itself can be a Neighborhood iterator: this can be useful for .e.g automatic
    boundaries handling'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iter本身可以是一个邻域迭代器：这对于自动处理边界很有用。
- en: the object returned by this function should be safe to use as a normal iterator
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数返回的对象应该可以安全地用作普通迭代器
- en: If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next
    is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果iter的位置被改变，任何对PyArrayNeighborhoodIter_Next的后续调用都是未定义行为，并且必须调用PyArrayNeighborhoodIter_Reset。
- en: If the position of iter is not the beginning of the data and the underlying
    data for iter is contiguous, the iterator will point to the start of the data
    instead of position pointed by iter. To avoid this situation, iter should be moved
    to the required position only after the creation of iterator, and PyArrayNeighborhoodIter_Reset
    must be called.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果iter的位置不是数据的开头，并且iter的底层数据是连续的，那么迭代器会指向数据的开头，而不是iter指向的位置。为了避免这种情况，应该在创建迭代器后只移动iter到所需位置，并且必须调用PyArrayNeighborhoodIter_Reset。
- en: '[PRE308]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Reset the iterator position to the first point of the neighborhood. This should
    be called whenever the iter argument given at PyArray_NeighborhoodIterObject is
    changed (see example)
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器位置重置到邻域的第一个点。每当在PyArray_NeighborhoodIterObject中给定iter参数被改变时，都应该调用这个函数（参见示例）。
- en: '[PRE310]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: After this call, iter->dataptr points to the next point of the neighborhood.
    Calling this function after every point of the neighborhood has been visited is
    undefined.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数后，iter->dataptr指向邻域的下一个点。在访问邻域的每个点后调用这个函数是未定义的。
- en: Array mapping
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组映射
- en: Array mapping is the machinery behind advanced indexing.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 数组映射是高级索引背后的机制。
- en: '[PRE311]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: Use advanced indexing to iterate an array.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级索引来迭代一个数组。
- en: '[PRE312]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Swap the axes to or from their inserted form. `MapIter` always puts the advanced
    (array) indices first in the iteration. But if they are consecutive, it will insert/transpose
    them back before returning. This is stored as `mit->consec != 0` (the place where
    they are inserted). For assignments, the opposite happens: the values to be assigned
    are transposed (`getmap=1` instead of `getmap=0`). `getmap=0` and `getmap=1` undo
    the other operation.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '交换轴以插入或从插入的形式中取消。`MapIter`始终将高级（数组）索引放在迭代中的第一位。但如果它们是连续的，它将在返回之前插入/转置它们。这存储为`mit->consec
    != 0`（它们被插入的位置）。对于赋值，相反会发生: 要分配的值会被转置（`getmap=1`而不是`getmap=0`）。`getmap=0`和`getmap=1`会撤消另一个操作。'
- en: '[PRE313]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: This function needs to update the state of the map iterator and point `mit->dataptr`
    to the memory-location of the next object.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要更新地图迭代器的状态，并将`mit->dataptr`指向下一个对象的内存位置。
- en: Note that this function never handles an extra operand but provides compatibility
    for an old (exposed) API.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数从不处理额外的操作数，但提供了旧（已公开）API的兼容性。
- en: '[PRE314]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Similar to [`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")
    but with an additional `copy_if_overlap` argument. If `copy_if_overlap != 0`,
    checks if `a` has memory overlap with any of the arrays in `index` and with `extra_op`,
    and make copies as appropriate to avoid problems if the input is modified during
    the iteration. `iter->array` may contain a copied array (WRITEBACKIFCOPY set).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")，但有一个额外的`copy_if_overlap`参数。如果`copy_if_overlap
    != 0`，则检查`a`是否与`index`中的任何数组以及`extra_op`有内存重叠，并根据需要进行复制，以避免在迭代过程中修改输入时出现问题。`iter->array`可能包含一个已复制的数组（设置了WRITEBACKIFCOPY）。
- en: Array Scalars
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组标量
- en: '[PRE315]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: This function steals a reference to *arr*.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数窃取对*arr*的引用。
- en: This function checks to see if *arr* is a 0-dimensional array and, if so, returns
    the appropriate array scalar. It should be used whenever 0-dimensional arrays
    could be returned to Python.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查*arr*是否为0维数组，如果是，则返回适当的数组标量。每当可能返回0维数组到Python时应使用此函数。
- en: '[PRE316]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: Return an array scalar object of the given *dtype* by **copying** from memory
    pointed to by *data*. *base* is expected to be the array object that is the owner
    of the data. *base* is required if *dtype* is a `void` scalar, or if the `NPY_USE_GETITEM`
    flag is set and it is known that the `getitem` method uses the `arr` argument
    without checking if it is `NULL`. Otherwise *base* may be `NULL`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**复制**从由*data*指向的内存中返回给定*dtype*的数组标量对象。如果*dtype*是`void`标量，则期望*base*是拥有数据的数组对象。如果设置了`NPY_USE_GETITEM`标志，并且知道`getitem`方法使用`arr`参数而不检查它是否为`NULL`，则需要*base*。否则*base*可以是`NULL`。
- en: If the data is not in native byte order (as indicated by `dtype->byteorder`)
    then this function will byteswap the data, because array scalars are always in
    correct machine-byte order.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据不是本机字节顺序（由`dtype->byteorder`指示），那么此函数将进行字节交换，因为数据总是处于正确的机器字节顺序中。
- en: '[PRE317]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: Return an array scalar object of the type and itemsize indicated by the array
    object *arr* copied from the memory pointed to by *data* and swapping if the data
    in *arr* is not in machine byte-order.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 从由*data*指向的内存中复制以及如果*arr*中的数据不是机器字节顺序则进行交换，返回*arr*指示的给定*dtype*的数组标量对象。
- en: '[PRE318]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Return a 0-dimensional array of type determined by *outcode* from *scalar* which
    should be an array-scalar object. If *outcode* is NULL, then the type is determined
    from *scalar*.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 从*scalar*中返回一个由*outcode*确定类型的0维数组，*scalar*应该是一个数组标量对象。如果*outcode*为NULL，则类型从*scalar*确定。
- en: '[PRE319]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Return in *ctypeptr* a pointer to the actual value in an array scalar. There
    is no error checking so *scalar* must be an array-scalar object, and ctypeptr
    must have enough space to hold the correct type. For flexible-sized types, a pointer
    to the data is copied into the memory of *ctypeptr*, for all other types, the
    actual data is copied into the address pointed to by *ctypeptr*.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ctypeptr*中返回一个指向数组标量中实际值的指针。没有错误检查，因此*scalar*必须是一个数组标量对象，而ctypeptr必须有足够的空间来容纳正确的类型。
- en: '[PRE320]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Return the data (cast to the data type indicated by *outcode*) from the array-scalar,
    *scalar*, into the memory pointed to by *ctypeptr* (which must be large enough
    to handle the incoming memory).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组标量*scalar*中的数据（转换为*outcode*指示的数据类型）返回到由*ctypeptr*指向的内存中（必须足够大以处理传入的内存）。
- en: '[PRE321]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Returns a scalar type-object from a type-number, *type* . Equivalent to [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj except for reference counting and error-checking.
    Returns a new reference to the typeobject on success or `NULL` on failure.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型编号*type*返回一个标量类型对象。等效于[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj，除了引用计数和错误检查。成功时返回对类型对象的新引用，失败时返回`NULL`。
- en: '[PRE322]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: See the function [`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")
    for an alternative mechanism introduced in NumPy 1.6.0.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 详见函数[`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")，介绍了NumPy
    1.6.0中引入的另一种机制。
- en: Return the kind of scalar represented by *typenum* and the array in **arr* (if
    *arr* is not `NULL` ). The array is assumed to be rank-0 and only used if *typenum*
    represents a signed integer. If *arr* is not `NULL` and the first element is negative
    then [`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR "NPY_INTNEG_SCALAR")
    is returned, otherwise [`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR") is returned. The possible return values are the enumerated
    values in [`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND").
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由*typenum*和**arr*（如果*arr*不是`NULL`）所代表的标量的种类和数组。假定数组的秩为0，仅当*typenum*表示有符号整数时使用*arr*。如果*arr*不是`NULL`并且第一个元素为负数，则返回[`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR
    "NPY_INTNEG_SCALAR")，否则返回[`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR")。可能的返回值是[`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND")中的枚举值。
- en: '[PRE323]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: See the function [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")
    for details of NumPy type promotion, updated in NumPy 1.6.0.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解NumPy类型提升的功能[`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")，在NumPy
    1.6.0中更新。
- en: Implements the rules for scalar coercion. Scalars are only silently coerced
    from thistype to neededtype if this function returns nonzero. If scalar is [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR"), then this function is equivalent to [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"). The rule is that scalars of the same KIND can be coerced
    into arrays of the same KIND. This rule means that high-precision scalars will
    never cause low-precision arrays of the same KIND to be upcast.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 实现标量强制转换的规则。只有当此函数返回非零值时，标量才能从这种类型默默地转换为所需类型。如果标量为[`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")，则此函数等效于[`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely "PyArray_CanCastSafely")。规则是，相同种类的标量可以强制转换为相同种类的数组。这条规则意味着高精度标量永远不会导致相同种类的低精度数组被向上转换。
- en: Data-type descriptors
  id: totrans-763
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型描述符
- en: Warning
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Data-type objects must be reference counted so be aware of the action on the
    data-type reference of different C-API calls. The standard rule is that when a
    data-type object is returned it is a new reference. Functions that take [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* objects and return arrays steal references to the data-type
    their inputs unless otherwise noted. Therefore, you must own a reference to any
    data-type object used as input to such a function.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型对象必须引用计数，因此要注意不同的C-API调用对数据类型引用的影响。标准规则是，当返回一个数据类型对象时，这是一个新引用。接受[PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")*对象并返回数组的函数会窃取对其输入数据类型的引用，除非另有说明。因此，您必须拥有作为此类函数输入的任何数据类型对象的引用。
- en: '[PRE324]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Evaluates as true if *obj* is a data-type object ( [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* ).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*是数据类型对象（[PyArray_Descr](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")*），则评估为真。
- en: '[PRE325]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Return a new data-type object copied from *obj* (the fields reference is just
    updated so that the new object points to the same fields dictionary if any).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从*obj*（如果有fields字典，则更新引用）复制的新数据类型对象。
- en: '[PRE326]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: Create a new data-type object from the built-in (or user-registered) data-type
    indicated by *typenum*. All builtin types should not have any of their fields
    changed. This creates a new copy of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure so that you can fill it in as appropriate. This function
    is especially needed for flexible data-types which need to have a new elsize member
    in order to be meaningful in array construction.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 从内置（或用户注册）的数据类型中创建一个新的数据类型对象，指示*typenum*。所有内置类型不应更改其任何字段。这将创建[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")结构的一个新副本，以便您可以适当地填入它。这个函数对于需要在数组构造中具有新elsize成员的灵活数据类型尤为重要。
- en: '[PRE327]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: Create a new data-type object with the byteorder set according to *newendian*.
    All referenced data-type objects (in subdescr and fields members of the data-type
    object) are also changed (recursively).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的数据类型对象，其中字节顺序按照*newendian*设置。所有引用的数据类型对象（在数据类型对象的subdescr和fields成员中）也会进行更改（递归）。
- en: 'The value of *newendian* is one of these macros:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '*newendian*的值是以下这些宏之一：'
- en: '[PRE328]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: If a byteorder of [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") is encountered
    it is left alone. If newendian is [`NPY_SWAP`](#c.NPY_SWAP "NPY_SWAP"), then all
    byte-orders are swapped. Other valid newendian values are [`NPY_NATIVE`](#c.NPY_NATIVE
    "NPY_NATIVE"), [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"), and [`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG") which all cause the returned data-typed descriptor (and all it’s referenced
    data-type descriptors) to have the corresponding byte- order.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到[`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE")的字节顺序，它将保持不变。如果newendian为[`NPY_SWAP`](#c.NPY_SWAP
    "NPY_SWAP")，则会交换所有字节顺序。其他有效的newendian值为[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")、[`NPY_LITTLE`](#c.NPY_LITTLE
    "NPY_LITTLE")和[`NPY_BIG`](#c.NPY_BIG "NPY_BIG")，它们都会导致返回的数据类型描述符（以及所有引用的数据类型描述符）具有相应的字节顺序。
- en: '[PRE333]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: Determine an appropriate data-type object from the object *op* (which should
    be a “nested” sequence object) and the minimum data-type descriptor mintype (which
    can be `NULL` ). Similar in behavior to array(*op*).dtype. Don’t confuse this
    function with [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter").
    This function essentially looks at all the objects in the (nested) sequence and
    determines the data-type from the elements it finds.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象*op*（应为“嵌套”序列对象）和最小数据类型描述符mintype（可以为`NULL`）确定合适的数据类型对象。行为类似于array(*op*).dtype。不要将此函数与[`PyArray_DescrConverter`](#c.PyArray_DescrConverter
    "PyArray_DescrConverter")混淆。该函数主要查看（嵌套）序列中的所有对象，并根据找到的元素确定数据类型。
- en: '[PRE334]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: Return a data-type object from an array-scalar object. No checking is done to
    be sure that *scalar* is an array scalar. If no suitable data-type can be determined,
    then a data-type of [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    is returned by default.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组标量对象返回一个数据类型对象。不会检查*scalar*是否为数组标量。如果无法确定合适的数据类型，则默认返回一个[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")数据类型。
- en: '[PRE335]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: Returns a data-type object corresponding to *typenum*. The *typenum* can be
    one of the enumerated types, a character code for one of the enumerated types,
    or a user-defined type. If you want to use a flexible size array, then you need
    to `flexible typenum` and set the results `elsize` parameter to the desired size.
    The typenum is one of the [`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES").
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与*typenum*相对应的数据类型对象。*typenum*可以是枚举类型之一，用于枚举类型之一的字符代码，或用户定义的类型。如果要使用可变大小数组，则需要`flexible
    typenum`并将结果`elsize`参数设置为所需的大小。typenum是[`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES")之一。
- en: '[PRE336]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    A large number of Python objects can be converted to data-type objects. See [Data
    type objects (dtype)](../arrays.dtypes.html#arrays-dtypes) for a complete description.
    This version of the converter converts None objects to a [`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE") data-type object. This function can be used with the “O&”
    character code in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") processing.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何兼容的Python对象*obj*转换为数据类型对象在*dtype*中。大量Python对象可以转换为数据类型对象。有关完整描述，请参见[数据类型对象（dtype）](../arrays.dtypes.html#arrays-dtypes)。此转换器的版本将None对象转换为[`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE")数据类型对象。此函数可与PyArg_ParseTuple处理中的“O&”字符代码一起使用。
- en: '[PRE337]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    This version of the converter converts None objects so that the returned data-type
    is `NULL`. This function can also be used with the “O&” character in PyArg_ParseTuple
    processing.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何兼容的Python对象*obj*转换为*dtype*中的数据类型对象。此转换器的版本将None对象转换为返回的数据类型为`NULL`。此函数也可与PyArg_ParseTuple处理中的“O&”字符一起使用。
- en: '[PRE338]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Like [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")类似，但它会将类似于C结构的对象与编译器对齐在字边界上。
- en: '[PRE339]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Like [`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")类似，但它将
    C 结构对象与编译器一样对齐到字边界。
- en: '[PRE340]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: Take the fields dictionary, *dict*, such as the one attached to a data-type
    object and construct an ordered-list of field names such as is stored in the names
    field of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")
    object.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 获取字段字典 *dict*，例如附加到数据类型对象的字典，并构造一个字段名称的有序列表，例如存储在[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")对象的 names 字段中。
- en: Conversion Utilities
  id: totrans-797
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换工具
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都可以在 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) 中使用“O&”格式说明符，自动将任何 Python 对象转换为所需的 C 对象。所有这些函数如果成功则返回[`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED")，如果失败则返回[`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL")。所有这些函数的第一个参数是一个 Python
    对象。第二个参数是要将 Python 对象转换为的 C 类型的 **address**。
- en: Warning
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 确保理解在使用这些转换函数时应该采取哪些步骤来管理内存。这些函数可能需要释放内存，并且/或者根据您的使用情况更改特定对象的引用计数。
- en: '[PRE341]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何 Python 对象转换为[`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")。如果 [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") （*obj*）为真，则增加其引用计数并将引用放入
    *address* 中。如果 *obj* 不是数组，则使用 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    将其转换为数组。无论返回什么，当完成后你必须在 *address* 中减少此函数返回的对象的引用计数。
- en: '[PRE342]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 这是给定给函数的输出数组的默认转换器。如果 *obj* 是[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)")或 `NULL`，那么 **address* 将为 `NULL` 但调用将成功。如果 [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") （*obj*）为真，则在不增加其引用计数的情况下将其返回到 **address* 中。
- en: '[PRE343]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何小于[`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")的 Python 序列 *obj* 转换为[`npy_intp`](dtype.html#c.npy_intp
    "npy_intp")的 C 数组。Python 对象也可以是单个数字。*seq* 变量是一个具有成员 ptr 和 len 的结构体指针。成功返回时，*seq*
    ->ptr 包含必须通过调用 [`PyDimMem_FREE`](#c.PyDimMem_FREE "PyDimMem_FREE") 来释放内存以避免内存泄漏的内存指针。对内存大小的限制使得可以方便地将此转换器用于预期被解释为数组形状的序列。
- en: '[PRE344]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 把任何 Python 对象 *obj*，具有（单段）缓冲区接口的，转换为具有详细描述对象内存块使用情况的成员的变量。*buf* 变量是指向具有 base、ptr、len
    和 flags 成员的结构体的指针。[`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk
    "PyArray_Chunk") 结构体在 32 位平台上通过其 len 成员和 64 位平台上的 ptr 成员与 Python 的缓冲区对象二进制兼容。返回时，base
    成员设置为 *obj*（或其基类，如果 *obj* 已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加 base 成员的引用计数。内存块由 *buf*->ptr
    成员指向，并且长度为 *buf*->len。 *buf* 的 flags 成员是 [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")，如果 *obj* 具有可写的缓冲区接口，则设置[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") 标志。
- en: '[PRE345]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 对象 *obj* 表示的轴参数转换为传递给接受整数轴的函数的正确值。具体来说，如果 *obj* 是 None，则 *axis* 设置为[`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS")，这由接受轴参数的 C-API 函数正确解释。
- en: '[PRE346]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 把任何 Python 对象 *obj* 转换为 [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") 或 [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")，并将结果放入 *value* 中。
- en: '[PRE347]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为对应的字节顺序字符：‘>’、‘<’、‘s’、‘=’ 或 ‘|’。
- en: '[PRE348]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为其中之一的[`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT "NPY_QUICKSORT")（以‘q’或‘Q’开头），[`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT")（以‘h’或‘H’开头），[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")（以‘m’或‘M’开头）或
    [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT") （以‘t’或‘T’开头）。[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT")和[ `NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    是为了向后兼容而彼此别名，并且基于数据类型可能指代多种稳定的排序算法之一。
- en: '[PRE349]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为其中之一的[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT "NPY_SEARCHLEFT")（以‘l’或‘L’开头），或[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")（以‘r’或‘R’开头）。
- en: '[PRE350]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串 ‘C’、‘F’、‘A’ 和 ‘K’ 转换为 [`NPY_ORDER`](#c.NPY_ORDER "NPY_ORDER") 枚举[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")、[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")、[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER") 和 [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")。
- en: '[PRE351]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串‘no’、‘equiv’、‘safe’、‘same_kind’和‘unsafe’转换为[`NPY_CASTING`](#c.NPY_CASTING
    "NPY_CASTING") 枚举[`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。
- en: '[PRE352]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串‘clip’、‘wrap’和‘raise’转换为[`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE")
    枚举 [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP")、[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP
    "NPY_WRAP")和[`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE "NPY_RAISE")。
- en: '[PRE353]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列剪裁模式或单个剪裁模式转换为[`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE")值的 C 数组。在调用此函数之前必须知道剪裁模式*n*的数量。为了帮助函数允许每个维度选择不同的剪裁模式，提供了此函数。
- en: Other conversions
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他转换
- en: '[PRE354]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的 Python 对象（包括数组和数组标量）转换为标准整数。发生错误时返回-1并设置异常。您可能会发现宏有用：
- en: '[PRE355]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的 Python 对象（包括数组和数组标量）转换为（平台指针大小的）整数。发生错误时返回-1并设置异常。
- en: '[PRE357]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 将传入的任何 Python 序列（或单个 Python 数字）*seq* 转换为（最多）*maxvals* 个指针大小的整数，并将它们放入 *vals*
    数组中。由于转换对象的数量会返回，所以序列可以比 *maxvals* 小。
- en: '[PRE358]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型字符串字符（带 *itemsize*）转换为基本的枚举数据类型。识别并转换了符号和无符号整数、浮点数和复数浮点数对应的类型字符串字符。返回其他值的
    gentype。例如，此函数可用于将字符串‘f4’转换为[`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32")。
- en: Miscellaneous
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项
- en: Importing the API
  id: totrans-839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 API
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从另一个扩展模块中使用 C-API，必须调用[`import_array`](#c.import_array "import_array")函数。如果扩展模块是一个单独的.c文件，那么只需要做这些。然而，如果扩展模块涉及需要
    C-API 的多个文件，则必须采取一些额外的步骤。
- en: '[PRE359]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在将使用 C-API 的模块的初始化部分中调用此函数。它将导入存储函数指针表的模块，并将正确的变量指向它。
- en: '[PRE360]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这些 #defines，你可以在单个扩展模块的多个文件中使用 C-API。在每个文件中，你必须将 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") 定义为一个将保存 C-API 的名称（*例如* myextension_ARRAY_API）。这必须在包含
    numpy/arrayobject.h 文件之前完成。在模块初始化例程中，你调用 [`import_array`](#c.import_array "import_array")。此外，在没有模块初始化子例程的文件中，在包含
    numpy/arrayobject.h 之前定义 [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY")。'
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有两个文件 coolmodule.c 和 coolhelper.c 需要编译并链接成一个单独的扩展模块。假设 coolmodule.c 包含所需的
    initcool 模块初始化函数（调用了 import_array() 函数）。那么，coolmodule.c 将包含如下内容：
- en: '[PRE362]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: 'On the other hand, coolhelper.c would contain at the top:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，coolhelper.c 将包含如下内容：
- en: '[PRE363]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将常见的最后两行放入扩展本地标头文件中，只要确保在包含该文件之前定义了 NO_IMPORT_ARRAY。
- en: 'Internally, these #defines work as follows:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '在内部，这些 #defines 的工作原理如下：'
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  id: totrans-852
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都未定义，则 C-API 被声明为 `static void**`，因此它只能在包含 numpy/arrayobject.h 的编译单元中可见。
- en: ''
  id: totrans-853
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  id: totrans-855
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    被 #defined，但 [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") 没有被定义，那么
    C-API 被声明为 `void**`，以便它也可见于其他编译单元。'
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-857
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  id: totrans-858
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") 被 #defined，无论
    [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    是否被定义，C-API 被声明为 `extern void**`，因此预计将在另一个编译单元中定义。'
- en: ''
  id: totrans-859
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每当 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    被 #defined 时，它也会更改保存 C-API 的变量名称（默认为 `PyArray_API`）为宏所定义的任何内容。'
- en: Checking the API Version
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 API 版本
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python扩展在大多数平台上不像通常的库那样被使用，所以一些错误不能在构建时甚至运行时自动检测到。例如，如果您使用仅适用于numpy >= 1.3.0的函数构建扩展，然后稍后使用numpy
    1.2导入扩展，您将不会得到导入错误（但几乎肯定在调用该函数时会导致段错误）。这就是为什么提供了几个函数来检查numpy版本。宏[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION")和[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")对应于用于构建扩展的numpy版本，而函数[`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion")和[`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion")返回的版本对应于运行时numpy的版本。
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: ABI和API兼容性的规则可以总结如下：
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`时，扩展都必须重新编译（ABI不兼容性）。
- en: ''
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`，而[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`意味着向后兼容的更改。'
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: ABI不兼容性在每个numpy版本中都会自动检测到。API不兼容性检测在numpy 1.4.0中添加。如果您希望支持许多不同的numpy版本，使用一个扩展二进制文件，您必须尽可能以最低的[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")构建您的扩展。
- en: '[PRE364]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray对象的当前版本（检查此变量是否定义以确保正在使用`numpy/arrayobject.h`头文件）。
- en: '[PRE365]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: The current version of the C-API.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: C-API的当前版本。
- en: '[PRE366]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是返回值[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION")。每当ABI级别发生向后不兼容的更改时，[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION")会发生变化。然而，因为它在C-API中，比较此函数的输出与当前头文件中定义的值可以测试C-API是否已更改，从而需要重新编译使用C-API的扩展模块。这在函数[`import_array`](#c.import_array
    "import_array")中自动检查。
- en: '[PRE367]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: New in version 1.4.0.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4.0中的新功能。
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是返回值[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")。当API变化时（例如，添加了一个函数），[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")会发生变化。改变的值并不总是需要重新编译。
- en: Internal Flexibility
  id: totrans-879
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部灵活性
- en: '[PRE368]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy存储了一个内部的Python可调用对象表，用于为数组实现算术运算以及某些数组计算方法。此函数允许用户用自己的版本替换任何或所有这些Python对象。字典*dict*的键是要替换的命名函数，配对值是要使用的Python可调用对象。应谨慎处理要用于替换内部数组操作的函数，不要自己回调该内部数组操作（除非你已经设计了该函数来处理），否则可能会导致未检查的无限递归（可能导致程序崩溃）。可以替换表示操作的关键名称是：
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**添加**，**减去**，**乘以**，**除以**，**余数**，**幂**，**平方**，**倒数**，**ones_like**，**sqrt**，**负数**，**正数**，**绝对值**，**倒数**，**左移**，**右移**，**按位与**，**按位异或**，**按位或**，**小于**，**小于等于**，**等于**，**不等于**，**大于**，**大于等于**，**地板除**，**真除**，**逻辑或**，**逻辑与**，**地板**，**上取整**，**最大值**，**最小值**，**rint**。'
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数包含在此处是因为它们至少在数组对象的方法中使用一次。如果要分配的其中一个对象不可调用，则函数返回-1（而不设置Python错误）。
- en: Deprecated since version 1.16.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16开始已过时。
- en: '[PRE369]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含存储在内部算术运算表中的可调用Python对象的Python字典。此字典的键在[`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps
    "PyArray_SetNumericOps")的解释中给出。
- en: Deprecated since version 1.16.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16开始已过时。
- en: '[PRE370]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许您将数组对象的tp_str和tp_repr方法更改为任何Python函数。因此，您可以更改Python调用时对所有数组进行str(arr)或repr(arr)的操作。要调用的函数传递为*op*。如果*repr*非零，则将在repr(arr)中调用此函数，否则将在str(arr)中调用此函数。不执行有关*op*是否可调用的检查。传递给*op*的可调用对象应期望一个数组参数，并应返回要打印的字符串。
- en: Memory management
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: '[PRE371]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配，释放和重新分配内存的宏。这些宏在内部用于创建数组。
- en: '[PRE374]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配，释放和重新分配维度和步幅内存的宏。
- en: '[PRE377]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏使用不同的内存分配器，取决于常量[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")。当[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM")为0时，使用系统malloc，如果[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM")为1，则使用Python内存分配器。
- en: '[PRE380]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`具有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，则此函数会清除标志，减少*obj->base*的引用计数并使其可写，并将`obj->base`设置为NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与[`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase")的相反操作。通常，在完成`obj`后及时调用此函数，就在`Py_DECREF(obj)`之前。可以多次调用此函数，或使用`NULL`输入。另请参见[`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy")。
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未执行任何操作，则返回0；发生错误，则返回-1；执行操作，则返回1。
- en: Threading support
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程支持
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏仅在扩展模块的编译期间，当[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")评估为True时才有意义。否则，这些宏等同于空格。Python为每个Python进程使用了单个全局解释器锁（Global
    Interpreter Lock，GIL），因此一次只能执行一个线程（即使在多CPU的机器上）。在调用需要一段时间计算的编译函数时（且不对其他线程产生副作用，如更新全局变量），GIL应该被释放，以便其他Python线程可以在执行耗时计算时运行。这可以通过两组宏来实现。通常，如果在代码块中使用一组宏，那么同一代码块中必须使用所有宏。当前，[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为Python定义的[`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS")常量，除非设置环境变量`NPY_NOSMP`，在这种情况下，[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为0。
- en: '[PRE382]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Group 1
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组1
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此组用于调用可能需要一些时间但不使用任何Python C-API调用的代码。因此，在计算其过程中应释放GIL。
- en: ''
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE384]'
- en: ''
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等效于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)")，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定是否将宏替换为空格。
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE385]'
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE385]'
- en: ''
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等效于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)")，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定是否将宏替换为空格。
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE386]'
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在变量声明区域。此宏设置存储Python状态所需的变量。
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE387]'
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在不需要Python解释器的代码之前（没有Python C-API调用）。此宏保存Python状态并释放GIL。
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE388]'
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE388]'
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在不需要Python解释器的代码之后。此宏获取GIL并从保存的变量恢复Python状态。
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE389]'
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅当*dtype*不包含可能在循环执行期间需要Python解释器的任意Python对象时，才释放GIL是有用的。
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE390]'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用此宏的BEGIN形式释放GIL的情况下，有用于重新获得GIL。
- en: ''
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE391]'
  id: totrans-942
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE391]'
- en: ''
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅当*loop_size*超过最小阈值（当前设置为500）时才释放GIL是有用的。应该与[`NPY_END_THREADS`](#c.NPY_END_THREADS
    "NPY_END_THREADS")配对以重新获得GIL。
- en: Group 2
  id: totrans-945
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2组
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此组用于在释放后重新获取Python GIL。例如，假设已释放GIL（使用前面的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用Python
    C-API，则这些宏对获取GIL很有用。这些宏基本上完成了前三个的反向操作（获取锁并保存其状态），然后使用保存的状态重新释放它。
- en: ''
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE392]'
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE392]'
- en: ''
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在变量声明区域以设置必要的变量。
- en: ''
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE393]'
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在需要调用Python C-API的代码之前（已知GIL已被释放时）。
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE394]'
- en: ''
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在需要调用Python C-API（以重新释放GIL）的代码之后。
- en: Tip
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never use semicolons after the threading support macros.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程支持宏后面永远不要使用分号。
- en: Priority
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级
- en: '[PRE395]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: Default priority for arrays.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的默认优先级。
- en: '[PRE396]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: Default subtype priority.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 默认子类型优先级。
- en: '[PRE397]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: Default scalar priority (very small)
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 默认标量优先级（非常小）
- en: '[PRE398]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*obj*或*def*的[`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__")属性（转换为double），如果不存在该名称的属性，则返回。对于类型为[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的对象，提供了避免属性查找的快速返回。
- en: Default buffers
  id: totrans-970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认缓冲区
- en: '[PRE399]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Default size of the user-settable internal buffers.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的默认大小。
- en: '[PRE400]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: Smallest size of user-settable internal buffers.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的最小大小。
- en: '[PRE401]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: Largest size allowed for the user-settable buffers.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置缓冲区的最大大小。
- en: Other constants
  id: totrans-977
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常数
- en: '[PRE402]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: The number of floating-point types
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的数量
- en: '[PRE403]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: The maximum number of dimensions allowed in arrays.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中允许的最大维数。
- en: '[PRE404]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: The maximum number of array arguments that can be used in functions.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 可在函数中使用的最大数组参数数。
- en: '[PRE405]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Defined as 0 for use with Bool.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Bool使用定义为0。
- en: '[PRE406]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: Defined as 1 for use with Bool.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Bool使用定义为1。
- en: '[PRE407]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like函数中使用“O&”语法调用的失败转换器函数的返回值。
- en: '[PRE408]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like函数中使用“O&”语法调用的成功转换器函数的返回值。
- en: Miscellaneous Macros
  id: totrans-992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项宏
- en: '[PRE409]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组*a1*和*a2*具有相同的形状，则为True。
- en: '[PRE410]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*a*和*b*的最大值。如果(*a*)或(*b*)是表达式，则它们将被评估两次。
- en: '[PRE411]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*a*和*b*的最小值。如果(*a*)或(*b*)是表达式，则它们将被评估两次。
- en: '[PRE412]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy定义的排序方式，实现两个复数（具有实部和虚部成员的结构）之间的复杂比较，即词典排序：首先比较实部，然后比较复数部分（如果实部相等）。
- en: '[PRE418]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Returns the reference count of any Python object.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 返回任何Python对象的引用计数。
- en: '[PRE419]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`标有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，则此函数会清除标志，*DECREF*
    *obj->base* 使其可写，并将`obj->base`设置为NULL。与[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")相比，它不会尝试从*obj->base*复制数据。这会撤销[`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase")。通常在错误发生后，当你已经完成对`obj`的操作时，在`Py_DECREF(obj)`之前调用此函数。可以多次调用，或者使用`NULL`输入。
- en: Enumerated Types
  id: totrans-1010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举类型
- en: '[PRE420]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的变量类型，可以采用不同的值来指示正在使用的排序算法。
- en: '[PRE421]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 用作[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")的别名，反之亦然。
- en: '[PRE425]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为排序数目。由于向后兼容性的需要，它固定为三个，因此 [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") 和 [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    相互别名，并可以引用多个稳定排序算法中的一个，具体取决于数据类型。
- en: '[PRE426]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的变量类型，指示在确定标量强制转换规则时区分的标量“种类”的数量。此变量可以采用以下值：
- en: '[PRE427]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为标量种类的数量（不包括[`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR "NPY_NOSCALAR")）。
- en: '[PRE435]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 一个枚举类型，指示应如何解释数组的元素顺序。当创建全新的数组时，通常只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而当提供一个或多个输入时，顺序可以基于它们。
- en: '[PRE436]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: Fortran order if all the inputs are Fortran, C otherwise.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有输入都是Fortran，则为Fortran顺序，否则为C。
- en: '[PRE437]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: C order.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: C顺序。
- en: '[PRE438]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: Fortran order.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran顺序。
- en: '[PRE439]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能接近输入顺序的顺序，即使输入既不是C顺序也不是Fortran顺序。
- en: '[PRE440]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示在某些函数中应用的剪裁类型。
- en: '[PRE441]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: The default for most operations, raises an exception if an index is out of bounds.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作的默认值，如果索引越界则引发异常。
- en: '[PRE442]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Clips an index to the valid range if it is out of bounds.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引越界，则将其剪裁到有效范围内。
- en: '[PRE443]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: Wraps an index to the valid range if it is out of bounds.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引越界，则将其包装到有效范围内。
- en: '[PRE444]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示返回的索引是第一个合适位置的（如果是[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")）还是最后一个的（如果是[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）。
- en: '[PRE445]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: A variable type indicating the selection algorithm being used.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示正在使用的选择算法。
- en: '[PRE448]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: New in version 1.6.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.6版引入。
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型，指示数据转换应该多么宽松。这由NumPy 1.6中添加的迭代器使用，并计划在未来版本中更广泛地使用。
- en: '[PRE450]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: Only allow identical types.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许相同类型的转换。
- en: '[PRE451]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: Allow identical and casts involving byte swapping.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 允许相同和涉及字节交换的类型转换。
- en: '[PRE452]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 只允许不会导致值四舍五入、截断或以其他方式改变的转换。
- en: '[PRE453]'
  id: totrans-1065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何安全的类型转换，以及相同类型的类型转换。例如，`float64` -> `float32` 的转换符合此规则。
- en: '[PRE454]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Allow any cast, no matter what kind of data loss may occur.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何类型的转换，无论可能发生什么样的数据丢失。
- en: '## Array structure and data access'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数组结构和数据访问'
- en: These macros access the [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") structure members and are defined in `ndarraytypes.h`. The input
    argument, *arr*, can be any [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that is directly interpretable as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")* (any instance of the [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and its sub-types).
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏访问 [`PyArrayObject`](types-and-structures.html#c.PyArrayObject "PyArrayObject")
    结构成员，并在 `ndarraytypes.h` 中定义。输入参数 *arr* 可以是任何可直接解释为 [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*（任何 [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") 及其子类型的实例）的 [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")*。
- en: '[PRE455]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: The number of dimensions in the array.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的维度数。
- en: '[PRE456]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: Returns an integer representing the [array-flags](#array-flags).
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表示 [数组标志](#array-flags) 的整数。
- en: '[PRE457]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: Return the (builtin) typenumber for the elements of this array.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此数组元素的（内置）类型编号。
- en: '[PRE458]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: Convert obj and place it in the ndarray, *arr*, at the place pointed to by itemptr.
    Return -1 if an error occurs or 0 on success.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 将 obj 转换并将其放置在 *arr* 中，位置由 itemptr 指向。如果发生错误则返回 -1，成功返回 0。
- en: '[PRE459]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: New in version 1.7.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中的新功能。
- en: Enables the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 启用指定的数组标志。此函数不进行验证，并假定您知道自己在做什么。
- en: '[PRE460]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: New in version 1.7.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中的新功能。
- en: Clears the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 清除指定的数组标志。此函数不进行验证，并假定您知道自己在做什么。
- en: '[PRE461]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: These two macros are similar and obtain the pointer to the data-buffer for the
    array. The first macro can (and should be) assigned to a particular pointer where
    the second is for generic processing. If you have not guaranteed a contiguous
    and/or aligned array then be sure you understand how to access the data in the
    array to avoid memory and/or alignment problems.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏很相似，并获取数组数据缓冲区的指针。第一个宏可以（也应该）分配给特定指针，而第二个用于通用处理。如果您没有保证数组是连续和/或对齐的，请确保了解如何访问数组中的数据，以避免内存和/或对齐问题。
- en: '[PRE463]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: Returns a pointer to the dimensions/shape of the array. The number of elements
    matches the number of dimensions of the array. Can return `NULL` for 0-dimensional
    arrays.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向数组的维度/形状的指针。元素数量与数组的维度数相匹配。对于0维数组，可能返回 `NULL`。
- en: '[PRE464]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: New in version 1.7.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.7中的新功能。
- en: A synonym for [`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS"), named to be
    consistent with the [`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape") usage within Python.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS") 同义，命名以与 Python 中的 [`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape") 用法一致。
- en: '[PRE465]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: Returns a pointer to the strides of the array. The number of elements matches
    the number of dimensions of the array.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向数组步幅的指针。元素数量与数组的维度数相匹配。
- en: '[PRE466]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: Return the shape in the *n* \(^{\textrm{th}}\) dimension.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在*n* \(^{\textrm{th}}\) 维度中返回形状。
- en: '[PRE467]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: Return the stride in the *n* \(^{\textrm{th}}\) dimension.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*n* \(^{\textrm{th}}\) 维度中的步幅。
- en: '[PRE468]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Return the itemsize for the elements of this array.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此数组元素的项大小。
- en: Note that, in the old API that was deprecated in version 1.7, this function
    had the return type `int`.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在版本1.7中已弃用的旧API中，此函数的返回类型为 `int`。
- en: '[PRE469]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: Returns the total size (in number of elements) of the array.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的总大小（元素数）。
- en: '[PRE470]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: Returns 0 if *obj* is not a sub-class of ndarray. Otherwise, returns the total
    number of elements in the array. Safer version of [`PyArray_SIZE`](#c.PyArray_SIZE
    "PyArray_SIZE") (*obj*).
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *obj* 不是 ndarray 的子类，则返回 0。否则，返回数组中的元素总数。[`PyArray_SIZE`](#c.PyArray_SIZE
    "PyArray_SIZE") (*obj*) 的更安全版本。
- en: '[PRE471]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: Returns the total number of bytes consumed by the array.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组消耗的总字节数。
- en: '[PRE472]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: This returns the base object of the array. In most cases, this means the object
    which owns the memory the array is pointing at.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的基本对象。在大多数情况下，这意味着数组指向的内存的所有者对象。
- en: If you are constructing an array using the C API, and specifying your own memory,
    you should use the function [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject") to set the base to an object which owns the memory.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 C API 构建数组，并指定自己的内存，你应该使用函数[`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject")来将基础设置为一个拥有该内存的对象。
- en: If the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag is set, it has a different meaning, namely base is the array into which the
    current array will be copied upon copy resolution. This overloading of the base
    property for two functions is likely to change in a future version of NumPy.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")标志，则其含义不同，即基本是当前数组将在复制解析时复制到的数组。这两个函数的基本属性的重载可能会在
    NumPy 的将来版本中更改。
- en: '[PRE473]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: Returns a borrowed reference to the dtype property of the array.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回数组的 dtype 属性的借用引用。
- en: '[PRE474]'
  id: totrans-1114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: New in version 1.7.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 自 NumPy 版本 1.7 起新增。
- en: A synonym for PyArray_DESCR, named to be consistent with the ‘dtype’ usage within
    Python.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: PyArray_DESCR 的同义词，命名为与 Python 中的 'dtype' 用法一致。
- en: '[PRE475]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: Get a Python object of a builtin type from the ndarray, *arr*, at the location
    pointed to by itemptr. Return `NULL` on failure.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ndarray *arr* 的位置指针 itemptr 获取内置类型的 Python 对象。失败时返回 `NULL`。
- en: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item") is identical to PyArray_GETITEM.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item") 与 PyArray_GETITEM 完全相同。'
- en: '[PRE476]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: The function pointed to by the [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__"). The first argument is the newly created sub-type.
    The second argument (if not NULL) is the “parent” array (if the array was created
    using slicing or some other operation where a clearly-distinguishable parent is
    present). This routine can do anything it wants to. It should return a -1 on error
    and 0 otherwise.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in
    Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") 所指向的函数。第一个参数是新创建的子类型。第二个参数（如果不为 NULL）是“父”数组（如果数组是使用切片或某些其他操作创建的，则存在一个明显可区分的父数组）。此例程可以执行任何操作。错误时应返回
    -1，否则返回 0。'
- en: Data access
  id: totrans-1122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据访问
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数和宏提供了从 C 语言访问 ndarray 元素的简便方法。这对所有数组都有效。但是，如果数组中的数据不是机器字节顺序、未对齐或不可写入，你可能需要小心访问数组中的数据。换句话说，一定要尊重标志的状态，除非你知道自己在做什么，或者之前已经通过[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")确保了可写入、对齐且处于机器字节顺序的数组。如果你希望处理所有类型的数组，每种类型的 copyswap 函数对于处理不规范的数组非常有用。某些平台（例如
    Solaris）不喜欢未对齐的数据，并且如果你对未对齐的指针进行解引用，它们将崩溃。其他平台（例如 x86 Linux）在处理未对齐的数据时会变得更慢。
- en: '[PRE477]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 ndarray *aobj* 在由 c 数组 *ind* 指定的 N 维索引处的数据的指针（*ind* 的大小必须至少为 *aobj* ->nd）。你可能需要将返回的指针类型转换为
    ndarray 的数据类型。
- en: '[PRE478]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在ndarray *obj*中以给定坐标快速内联访问元素，*obj* 必须分别具有 1、2、3 或 4 个维度（未经检查）。相应的 *i*、*j*、*k*
    和 *l* 坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针强制转换为ndarray的数据类型。
- en: Data access
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据访问
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数和宏为从C中轻松访问ndarray的元素提供了便利。这些适用于所有数组。但是，如果数组不符合机器字节顺序、未对齐或不可写，那么在访问数组中的数据时，您可能需要小心。换句话说，请确保尊重标志的状态，除非您知道自己在做什么，或者之前已经保证了一个可写、对齐并且符合机器字节顺序的数组，使用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。如果希望处理所有类型的数组，每种类型的复制交换功能可用于处理表现不佳的数组。某些平台（例如 Solaris）不喜欢不对齐数据，如果您对一个不对齐的指针进行反引用，它们将崩溃。其他平台（例如
    x86 Linux）将更慢地处理不对齐数据。
- en: '[PRE482]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在由c数组*ind*给出的N维索引处返回ndarray *aobj* 的数据指针（数组大小至少为*aobj*->nd）。您可能希望将返回的指针强制转换为ndarray的数据类型。
- en: '[PRE483]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 在ndarray *obj*中以给定坐标快速内联访问元素，*obj* 必须分别具有 1、2、3 或 4 个维度（未经检查）。相应的 *i*、*j*、*k*
    和 *l* 坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针强制转换为ndarray的数据类型。
- en: Creating arrays
  id: totrans-1140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: From scratch
  id: totrans-1141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从最基础开始
- en: '[PRE487]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将引用*descr*。获取它的最简单方法是使用[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")。
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的数组创建函数。大多数新数组都是使用此灵活函数创建的。
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象是Python类型*subtype*的对象，它必须是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的子类型。数组具有*nd*维，由*dims*描述。新数组的数据类型描述符是*descr*。
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*subtype*是数组子类的而不是基本[`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")，则*obj*是传递给子类的[`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__")方法的对象。
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*data*为`NULL`，则将分配新的未初始化内存，而*flags*可以非零以指示Fortran风格连续数组。使用[`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE")来初始化内存。
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*data*不为`NULL`，那么假定它指向要用于数组的内存，*flags*参数将用作数组的新标志（除了新数组的[`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA
    "NPY_ARRAY_OWNDATA")、[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志状态将被重置之外）。
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果*data*非NULL，则还可以提供*strides*。如果*strides*为`NULL`，则数组步幅将计算为C风格连续（默认）或Fortran风格连续（*data*为`NULL`或*flags*
    & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")为非空非NULL*data*）。任何提供的*dims*和*strides*都将复制到新分配的维度和步幅数组中，以供新数组对象使用。
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") 可以帮助验证非`NULL`的步幅信息。'
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`data`，它必须在数组的生命周期内保持活动状态。管理其方式之一是通过[`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject")。
- en: '[PRE488]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: New in version 1.6.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.6版开始新添加的功能。
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数会在*descr*不为NULL的情况下窃取一个引用。这个数组创建例程允许方便地创建一个与现有数组形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 当*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER")时，如果*prototype*是一个Fortran数组，则结果顺序为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，否则为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")。当*order*为[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")时，结果顺序与*prototype*匹配，即使*prototype*的轴不按照C或Fortran顺序。
- en: If *descr* is NULL, the data type of *prototype* is used.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*descr*为NULL，将使用*prototype*的数据类型。
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*subok*为1，新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。
- en: '[PRE489]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")（…），只是您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义）类型。如果该类型始终具有相同数量的字节，则itemsize将被忽略。否则，itemsize指定了此数组的特定大小。
- en: Warning
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据传递给[`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")或[`PyArray_New`](#c.PyArray_New
    "PyArray_New")，则在删除新数组之前不能释放此内存。如果这些数据来自另一个Python对象，可以通过对该对象使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(在Python v3.11中)")并将新数组的基础成员设置为指向该对象来实现。如果传入了步幅，它们必须与数组的维度、项大小和数据一致。
- en: '[PRE490]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个未初始化的类型为*typenum*的新数组，每个*nd*维度的大小由整数数组*dims*给出。数组的内存未初始化（除非typenum是[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")，在这种情况下数组中的每个元素都设置为NULL）。*typenum*参数允许指定任何内置数据类型，如[`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT")或[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")。如果需要，可以使用[`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE")（return_object，0）将数组的内存设置为零。此函数不能用于创建灵活类型数组（未给出itemsize）。
- en: '[PRE491]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定指针指向的*data*周围创建一个数组包装器。数组标志将具有数据区域是良好行为和C风格连续的默认值。数组的形状由长度为*nd*的*c*数组*dims*给出。数组的数据类型由*typenum*指示。如果数据来自另一个引用计数的Python对象，则在传入指针后应增加此对象的引用计数，并且返回的ndarray的基础成员应指向拥有数据的Python对象。这将确保在返回的数组存在时不会释放提供的内存。
- en: '[PRE492]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: This function steals a reference to *descr*.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数窃取了对*descr*的引用。
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的数据类型描述符*descr*创建一个新数组，其形状由*nd*和*dims*确定。
- en: '[PRE493]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 填充由*obj*指向的数组（必须是ndarray的子类）的内容为*val*（作为一个字节进行评估）。此宏调用memset，因此obj必须是连续的。
- en: '[PRE494]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用由*dims*给定的形状和由*dtype*给定的数据类型构造一个新的*nd*维数组。如果*fortran*非零，则创建一个Fortran顺序数组，否则创建一个C顺序数组。用零（或如果*dtype*对应于[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")则为0对象）填充内存。
- en: '[PRE495]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 宏形式的[`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros")，它接受一个类型编号而不是数据类型对象。
- en: '[PRE496]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用由*dims*给定形状和*dtype*给定数据类型构建一个新的*nd* -维数组。如果*fortran*非零，则创建一个Fortran顺序数组，否则创建一个C顺序数组。除非数据类型对应于[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")，否则数组未经初始化，此时数组将填充为[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)")。
- en: '[PRE497]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty")的宏表单，它使用类型编号*typenum*，而不是数据类型对象。'
- en: '[PRE498]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个数据类型为*typenum*的新的一维数组，范围从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**（*start*，*stop*，*step*，dtype）。
- en: '[PRE499]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个由`descr`确定的数据类型为`typenum`的新的一维数组，范围从`start`到`stop`（不包括`stop`），增量为`step`。相当于arange（`start`，`stop`，`step`，`typenum`）。
- en: '[PRE500]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: New in version 1.7.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 1.7版本新增。
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数**窃取一个引用**到`obj`并将其设置为`arr`的基本属性。
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过将自己的内存缓冲区作为参数传递来构建数组，则需要设置数组的*base*属性以确保内存缓冲区的生命周期合适。
- en: The return value is 0 on success, -1 on failure.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值：成功返回0，失败返回-1。
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的对象是一个数组，该函数将遍历*base*指针链，以便每个数组直接指向内存的所有者。一旦设置了*base*，就不能将其更改为另一个值。
- en: From other objects
  id: totrans-1189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他对象
- en: '[PRE501]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从任何嵌套序列或暴露数组接口的对象*op*获取数组的主要函数。参数允许指定所需的*dtype*，可接受的最小（*min_depth*）和最大（*max_depth*）维数，以及数组的其他*要求*。此函数**窃取一个引用**到dtype参数，它应该是指示所需数据类型（包括所需的字节顺序）的[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")结构。*dtype*参数可以为`NULL`，表示接受任何数据类型（和字节顺序）。除非在`flags`中包含[`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST")，否则如果无法安全地从对象获取数据类型，此调用将生成错误。如果您想为*dtype*使用`NULL`并确保数组不会被交换，则使用[`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny")。深度参数的值为0会使该参数被忽略。可以将以下任何数组标志（*例如*使用|）添加到*要求*参数中。如果您的代码可以处理一般的（*例如*分布、字节交换或非对齐的数组），那么*要求*可以是0。此外，如果*op*不已经是数组（或不公开数组接口），那么将创建一个新数组（并使用序列协议从*op*中填充）。新数组将具有[`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")作为其标志成员。*context*参数未使用。
- en: '[PRE502]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: Make sure the returned array is C-style contiguous
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是以C风格连续的
- en: '[PRE503]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: Make sure the returned array is Fortran-style contiguous.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是以Fortran风格连续的。
- en: '[PRE504]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组在其数据类型的适当边界上对齐。对齐的数组具有与数据类型描述符的对齐因子的数据指针和每个步幅因子的倍数。
- en: '[PRE505]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: Make sure the returned array can be written to.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组可以被写入。
- en: '[PRE506]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 确保对*op*进行复制。如果不存在此标志，则只有在可以避免复制数据时才不会复制数据。
- en: '[PRE507]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 确保结果是基类的ndarray。默认情况下，如果*op*是ndarray的子类的实例，则返回相同子类的实例。如果设置了这个标志，则将返回一个ndarray对象。
- en: '[PRE508]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 强制对输出类型进行转换，即使不能安全地进行。如果没有这个标志，只有在可以安全进行数据转换时才会发生数据转换，否则会引发错误。
- en: '[PRE509]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*已经是一个数组，但不符合要求，那么就会制作一个副本（该副本将符合要求）。如果此标志存在并且必须创建副本（一个已经是数组的对象），那么在返回的副本中设置对应的[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志，并且*op*将被设置为只读。您必须确保调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")将内容复制回*op*，并且*op*数组将会重新变得可写。如果*op*一开始就不可写，或者如果它不已经是一个数组，那么将会引发错误。
- en: '[PRE510]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
- en: '[PRE511]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE512]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE513]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE514]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE515]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE516]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE517]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE518]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE519]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE520]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE521]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE522]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE523]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")（…）几乎相同，除了*requirements*可以包含[`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED")（覆盖*dtype*中的规定）和[`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES")，其中表明数组应该在步幅是元素大小的倍数的意义上对齐。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy的1.6版本及更早版本中，以下标志的命名形式中没有 ARRAY 宏命名空间。该常量名称的形式在1.7中已不推荐使用。
- en: '[PRE524]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组具有机器字节顺序的数据类型描述符，覆盖*dtype*参数中的任何规定。通常，字节顺序要求由*dtype*参数确定。如果设置了此标志并且dtype参数未指示机器字节顺序描述符（或为NULL且对象已经是一个不在机器字节顺序中的数据类型描述符的数组），则会创建一个新的数据类型描述符并使用其字节顺序字段设置为本机。
- en: '[PRE525]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
- en: '[PRE526]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: Make sure the returned array has strides that are multiples of the element size.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组具有元素大小的倍数步幅。
- en: '[PRE527]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")的特例，当*op*已经是一个数组但需要是特定的*newtype*（包括字节顺序）或具有特定的*requirements*时。'
- en: '[PRE528]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露[`__array_struct__`](../arrays.interface.html#object.__array_struct__ "object.__array_struct__")属性并遵循数组接口协议的Python对象中返回一个ndarray对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在Python v3.11)")的借用引用。
- en: '[PRE529]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露[`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__")属性并遵循数组接口协议的Python对象中返回一个ndarray对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在Python v3.11)")的借用引用。
- en: '[PRE530]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 从公开[`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")方法的Python对象返回一个ndarray对象。[`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__")方法可以采取0或1个参数（[dtype]）。`context`未使用。
- en: '[PRE531]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或数组接口导出的对象*op*返回一个（C风格）连续且行为良好的函数数组，类型由枚举*typenum*给出，最小深度为*min_depth*，最大深度为*max_depth*。等同于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")并将需求设置为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")，并将类型参数的类型号成员设置为*typenum*。
- en: '[PRE532]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或数组接口导出的对象返回一个行为良好的C风格连续数组。数组的最小维数由*min_depth*给出，最大维数为*max_depth*。这等同于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")并将需求设置为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")和[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")。
- en: '[PRE533]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何嵌套序列或数组接口导出的对象*op*返回一个对齐且以本机字节序排列的数组，类型由枚举typenum给出。数组的最小维数由min_depth给出，最大维数为max_depth。这相当于调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")并将需求设置为BEHAVED。
- en: '[PRE534]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数**窃取一个引用**并确保`op`是一个基类ndarray。它特殊处理数组标量，否则调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")（`op`，NULL，0，0，[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")，NULL）。
- en: '[PRE535]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 从长度为slen的二进制或（ASCII）文本`string`构建一个单一类型的一维ndarray。要创建的数组的数据类型由`dtype`给出。如果num为-1，则**复制**整个字符串并返回大小合适的数组，否则，num是从字符串中**复制**的项目数。如果`sep`为NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型`dtype`的项。一些数据类型在文本模式下可能无法读取，并且如果发生这种情况，将会引发错误。所有错误都会返回NULL。
- en: '[PRE536]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制或文本文件构建一个单一类型的一维ndarray。打开的文件指针为`fp`，要创建的数组的数据类型由`dtype`给出。这必须与文件中的数据匹配。
    如果`num`为-1，则读取直到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项数。 如果`sep`为NULL（或“”），则以二进制模式从文件读取，否则以`sep`提供的项分隔符以文本模式从文件读取。有些数组类型在文本模式下无法读取，在这种情况下会引发错误。
- en: '[PRE537]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个导出（单一段）缓冲区协议的对象`buf`构建一个单一类型的一维ndarray（或者具有返回导出缓冲区协议的对象的属性`__buffer__`）。首先尝试可写缓冲区，然后尝试只读缓冲区。返回的数组的[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")标志将反映哪一个成功。假定数据从对象的内存位置开始的`offset`字节。根据数据类型描述符`dtype`解释缓冲区中的数据类型。如果`count`为负数，则将根据缓冲区的大小和要求的项大小确定，否则，`count`表示应从缓冲区中转换多少个元素。
- en: '[PRE538]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 从源数组`src`复制数据到目标数组`dest`中，必要时执行数据类型转换。 如果出现错误，则返回-1（否则返回0）。 `src`的形状必须可以广播到`dest`的形状。
    目标和源的数据区域不能重叠。
- en: '[PRE539]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数组强制转换规则，将对象`src`分配给NumPy数组`dest`。这基本上与[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")相同，但直接分配给输出数组。成功时返回0，失败时返回-1。
- en: '[PRE540]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 将源数组`src`中的数据移动到目标数组`dest`中，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回0）。 `src`的形状必须可以广播到`dest`的形状。目标和源的数据区域可能重叠。
- en: '[PRE541]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`已经（C风格）是连续且行为良好的，则只返回一个引用，否则返回数组的（连续和行为良好的）副本。参数`op`必须是（ndarray的子类的）ndarray，并且不做检查。
- en: '[PRE542]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 将`obj`转换为ndarray。该参数可以是任何嵌套序列或导出数组接口的对象。 这是使用`NULL`，0，0，0作为其他参数的[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")的宏形式。您的代码必须能够处理任何数据类型描述符和任何数据标志的组合以使用此宏。
- en: '[PRE543]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，只是它可以接受一个 *requirements*
    参数，指示结果数组必须具有的属性。可以强制执行的可用要求包括 [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")、[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")、[`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")、[`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY")、[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")、[`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST")
    和 [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY")。也可以使用标准组合的标志：
- en: '[PRE544]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，只是它可以接受一个 *typenum*
    参数，指定返回的数组的类型编号。
- en: '[PRE545]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") 和 [`PyArray_FROM_OT`](#c.PyArray_FROM_OT
    "PyArray_FROM_OT")，允许同时提供 *typenum* 和 *flags* 参数。
- en: '[PRE546]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")，只是数据类型使用 typenumber
    来指定。将 [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType")（*typenum*）直接传递给
    [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")。如果传入 [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") 作为要求，则此宏还会添加 [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")。
- en: '[PRE547]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 封装了使用 axis= 关键字并正确处理 None 作为轴参数的函数和方法的功能。输入数组为 `obj`，而 `*axis` 是转换后的整数（所以 >=MAXDIMS
    就是 None 值），而 `requirements` 给出了 `obj` 的所需属性。输出是输入的转换版本，以满足要求，如有需要，已执行了扁平化。在输出中，`*axis`
    的负值被转换，并检查新值以确保与 `obj` 的形状一致。
- en: From scratch
  id: totrans-1285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始
- en: '[PRE548]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数会获取对 *descr* 的引用。最简单的方法是使用 [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")。
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的数组创建函数。大多数新数组都是使用这个灵活的函数创建的。
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象是 Python 类型 *subtype* 的对象，它必须是 [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") 的一个子类型。数组具有 *nd* 维，由 *dims* 描述。新数组的数据类型描述符是 *descr*。
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*subtype*是一个数组子类而不是基础[`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")，那么*obj*就是将传递给子类的[`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__")方法的对象。
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*data*为`NULL`，那么将分配新的未初始化内存，并且*flags*可以是非零以指示Fortran风格连续数组。使用[`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE")来初始化内存。
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*data*不为`NULL`，则假定它指向要用于数组的内存，并且 *flags* 参数将用作数组的新标志（除了新数组的[`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA
    "NPY_ARRAY_OWNDATA")、[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") 标志的状态将被重置）。
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果*data*为非NULL，那么也可以提供*strides*。如果*strides*为`NULL`，则计算数组的步幅为C风格连续（默认）或Fortran风格连续（*data*=`NULL`或*flags*&[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")为非零non-NULL*data*）。任何提供的*dims*和*strides*都将被复制到新分配的维度和步幅数组中，用于新的数组对象。
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides")可以帮助验证非`NULL`的步幅信息。'
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`data`，它必须在数组的生存期内保持活动。管理此情况的一种方法是通过[`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject")
- en: '[PRE549]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: New in version 1.6.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.6版开始。
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数会偷走*descr*的引用，如果不是NULL的话。这个数组创建程序允许方便地创建一个与现有数组形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 当*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER")时，结果顺序为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，如果*prototype*是Fortran数组，则为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")。当*order*为[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")时，结果顺序与*prototype*的顺序匹配，即使*prototype*的轴不是按C或Fortran顺序排列。
- en: If *descr* is NULL, the data type of *prototype* is used.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*descr*为NULL，则使用*prototype*的数据类型。
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*subok*为1，则新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。
- en: '[PRE550]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于[`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")(...)，不同之处在于您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义）类型。如果该类型始终具有相同数量的字节，则itemsize会被忽略。否则，itemsize指定该数组的特定大小。
- en: Warning
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据被传递给 [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    或 [`PyArray_New`](#c.PyArray_New "PyArray_New")，则在删除新数组之前不能释放该内存。如果此数据来自另一个 Python
    对象，可以使用 [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") 增加该对象的引用计数，并将新数组的基类成员设置为指向该对象。如果传入了步幅，它们必须与数组的维度、项大小和数据一致。
- en: '[PRE551]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个未初始化的类型为 *typenum* 的新数组，每个维度的大小都由整数数组 *dims* 给出。数组的内存未初始化（除非 typenum 是 [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ，此时数组中的每个元素都设置为 NULL）。*typenum* 参数允许指定任何内置的数据类型，例如 [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") 或 [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")。如果需要，可以使用
    [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE "PyArray_FILLWBYTE")（return_object，0）将数组的内存设置为零。此函数不能用于创建灵活类型的数组（未给出项大小）。
- en: '[PRE552]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定指针指向的 *data* 上创建一个数组包装器。数组标志将具有默认值，即数据区域是良好行为并且 C 风格连续的。数组的形状由长度为 *nd* 的
    *dims* c 数组给出。数组的数据类型由 *typenum* 指示。如果数据来自另一个引用计数的 Python 对象，则要在指针传递后增加此对象的引用计数，并且返回的
    ndarray 的基类成员应指向拥有数据的 Python 对象。这样可以确保在返回的数组存在时，提供的内存不会被释放。
- en: '[PRE553]'
  id: totrans-1310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: This function steals a reference to *descr*.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数引用了 *descr*。
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的数据类型描述符 *descr* 和由 *nd* 和 *dims* 确定的形状创建一个新数组。
- en: '[PRE554]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *val* 的内容（作为字节评估）填充 *obj* 指向的数组。此宏调用 memset，因此 obj 必须是连续的。
- en: '[PRE555]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的 *dims* 形状和 *dtype* 数据类型构建一个新的 *nd* 维数组。如果 *fortran* 不为零，则创建一个 Fortran
    顺序数组，否则创建一个 C 顺序数组。用零填充内存（或者如果 *dtype* 对应 [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ，则填充 0 对象）。
- en: '[PRE556]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为宏形式的 [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros")，它接受类型编号而不是数据类型对象。
- en: '[PRE557]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个由*dims*给定形状和*dtype*给定数据类型的新*nd*维数组。如果*fortran*非零，则创建一个Fortran顺序数组，否则创建一个C顺序数组。该数组未初始化，除非数据类型对应于[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")，在这种情况下，数组将填充[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(在 Python v3.11)")。
- en: '[PRE558]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 以宏形式的[`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty")，它接受一个类型编号*typenum*，而不是数据类型对象。
- en: '[PRE559]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的一维数据类型数组，*typenum*，它的范围是从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**(*start*,
    *stop*, *step*, dtype)。
- en: '[PRE560]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个新的一维由`descr`确定数据类型的数组，范围是从`start`到`stop`（不包括`stop`），增量为`step`。相当于arange(`start`,
    `stop`, `step`, `typenum`)。
- en: '[PRE561]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: New in version 1.7.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.7 版中新增。
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数**窃取了一个引用**到`obj`，并将其设置为`arr`的基本属性。
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过传入自己的内存缓冲区来构造一个数组，你需要设置数组的*base*属性以确保内存缓冲区的生命周期是适当的。
- en: The return value is 0 on success, -1 on failure.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回值为0，失败时为-1。
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的对象是一个数组，这个函数会遍历*基本*指针链，以便每个数组直接指向内存的所有者。一旦设置了基本值，就不能更改为另一个值。
- en: From other objects
  id: totrans-1333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自其他对象
- en: '[PRE562]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于从任何嵌套序列或暴露数组接口的对象（*op*）中获取数组的主要函数。参数允许指定所需的*dtype*、可接受的最小（*min_depth*）和最大（*max_depth*）维数以及数组的其他*requirements*。此函数会**窃取一个引用**用于
    dtype 参数，该参数需要一个[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")
    结构，指示所需的数据类型（包括所需的字节序）。*dtype* 参数可以为 `NULL`，表示可以接受任何数据类型（和字节序）。除非 [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") 在 `flags` 中存在，否则如果无法安全地从对象中获取数据类型，则此调用将引发错误。如果希望将 *dtype*
    设置为 `NULL`，并确保数组未交换，则使用 [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny "PyArray_CheckFromAny")。任何一个深度参数为
    0 都会导致该参数被忽略。可以添加以下任何数组标志（例如使用 |）来获取 *requirements* 参数。如果您的代码可以处理一般的（例如分段的、字节交换的或未对齐的数组），则
    *requirements* 可以设置为 0。此外，如果 *op* 尚未是数组（或未暴露数组接口），则将创建一个新的数组（并使用序列协议从 *op* 中填充）。新数组的
    flags 成员将为[`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")。*context*
    参数未使用。
- en: '[PRE563]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: Make sure the returned array is C-style contiguous
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是 C 风格的连续数组。
- en: '[PRE564]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Make sure the returned array is Fortran-style contiguous.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组是 Fortran 风格的连续数组。
- en: '[PRE565]'
  id: totrans-1340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组在其数据类型的适当边界上对齐。对齐数组的数据指针以及每个步幅因子都是数据类型描述符的对齐因子的倍数。
- en: '[PRE566]'
  id: totrans-1342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: Make sure the returned array can be written to.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组可以写入。
- en: '[PRE567]'
  id: totrans-1344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: '确保对 *op* 进行复制。如果没有设置该标志，将尽可能避免复制数据。 '
- en: '[PRE568]'
  id: totrans-1346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 确保结果是一个基类 ndarray。默认情况下，如果 *op* 是 ndarray 的子类的实例，则返回相同子类的实例。如果设置了此标志，则返回一个 ndarray
    对象。
- en: '[PRE569]'
  id: totrans-1348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 强制将输出类型转换，即使不能安全地进行转换。如果没有设置该标志，则只有在可以安全地进行数据转换时才会发生数据转换，否则将引发错误。
- en: '[PRE570]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*已经是一个数组，但不满足要求，那么就会进行复制（以满足要求）。如果设置了这个标识并且必须进行复制（复制一个已经是数组的对象），那么返回的副本将设置相应的[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志，并且*op*将被设为只读。您必须确保调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")将内容复制回*op*，并且*op*数组将重新变为可写。如果*op*一开始就不可写，或者不是一个数组，那么将会引发错误。
- en: '[PRE571]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
- en: '[PRE572]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE573]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE574]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE575]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE576]'
  id: totrans-1362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE577]'
  id: totrans-1364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE578]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE579]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE580]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE581]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
- en: '[PRE582]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE583]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
- en: '[PRE584]'
  id: totrans-1378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") (…) 几乎相同，但 *requirements*
    可以包含 [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")（覆盖
    *dtype* 中的规范）和 [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES "NPY_ARRAY_ELEMENTSTRIDES")，这表示数组应该对齐，即步幅是元素大小的倍数。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 的 1.6 版本及更早版本中，以下标志的命名中没有包含 _ARRAY_ 宏命名空间。该常量名称形式在 1.7 版本中已被弃用。
- en: '[PRE585]'
  id: totrans-1381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组具有机器字节顺序的数据类型描述符，覆盖 *dtype* 参数中的任何规范。通常，字节顺序要求由 *dtype* 参数确定。如果设置了此标志并且
    *dtype* 参数没有指示机器字节顺序描述符（或者为 NULL 并且对象已经是一个具有不在机器字节顺序中的数据类型描述符的数组），则会创建一个新的数据类型描述符并使用其字节顺序字段设置为本机。
- en: '[PRE586]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
- en: '[PRE587]'
  id: totrans-1385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: Make sure the returned array has strides that are multiples of the element size.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 确保返回的数组的步幅是元素大小的倍数。
- en: '[PRE588]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") 的特殊情况，当 *op* 已经是一个数组但它需要是一个特定的
    *newtype*（包括字节顺序）或具有某些 *requirements*。'
- en: '[PRE589]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个暴露了[`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") 属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") 的借用引用。
- en: '[PRE590]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个暴露了[`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") 属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") 的借用引用。
- en: '[PRE591]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 从暴露[`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")方法的Python对象返回一个ndarray对象。[`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__")方法可以接受0个或1个参数`([dtype])`。`context`未使用。
- en: '[PRE592]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或数组接口导出的对象*op*返回一个（C风格）连续且表现良好的函数数组，其类型由枚举*typenum*给定，最小深度为*min_depth*，最大深度为*max_depth*。（非灵活）类型为*typenum*的等同于调用具有要求设置为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")和类型参数的type_num成员设置为*typenum*的[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。
- en: '[PRE593]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从任何嵌套序列或导出数组接口的对象返回一个表现良好的C风格连续数组。数组可以具有的最小维数由*min_depth*给出，而最大维数为*max_depth*。这等同于使用要求为[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT")和[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY")的调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。
- en: '[PRE594]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何嵌套序列或导出数组接口的对象`op`返回一个对齐的本机字节顺序数组，该数组的类型由枚举类型标号给出。数组可以具有的最小维数由`min_depth`给出，而最大维数由`max_depth`给出。这相当于使用要求设置为BEHAVED的调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。
- en: '[PRE595]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数**窃取引用**`op`并确保`op`是一个基类ndarray。它特殊处理数组标量，但否则调用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")（ `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL）。
- en: '[PRE596]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 从长度为`slen`的二进制或（ASCII）文本`string`构建一个单一类型的一维ndarray。将要创建的数组的数据类型由`dtype`给出。如果`num`为-1，则**复制**整个字符串并返回一个适当大小的数组，否则，`num`是从字符串中**复制**的项目数。如果`sep`为NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型`dtype`的项。某些数据类型在文本模式下可能无法读取，如果发生这种情况，则会引发错误。所有错误都返回NULL。
- en: '[PRE597]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制或文本文件构造一个单一类型的一维ndarray。 打开的文件指针是`fp`，要创建的数组的数据类型由`dtype`给出。 这必须与文件中的数据匹配。
    如果`num`为-1，则读取直到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项目数。 如果`sep`为NULL（或“”），则以二进制模式从文件中读取，否则使用`sep`以文本模式从文件中读取，`sep`提供项目分隔符。
    有些数组类型无法以文本模式读取，这将引发错误。
- en: '[PRE598]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 从导出（单段）缓冲区协议的对象`buf`构造单一类型的一维ndarray（或具有返回导出缓冲区协议的对象的属性__buffer__）。 首先尝试可写缓冲区，然后尝试只读缓冲区。
    返回的数组的[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")标志将反映哪种是成功的。
    假定数据从对象的内存位置的起始处偏移`offset`字节。 缓冲区中的数据类型将根据数据类型描述符`dtype`进行解释。 如果`count`为负，则将从缓冲区的大小和请求的项大小确定它，否则，`count`表示应从缓冲区中转换多少元素。
- en: '[PRE599]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 从源数组`src`复制到目标数组`dest`，必要时执行数据类型转换。 如果发生错误，则返回-1（否则返回0）。 `src`的形状必须可广播至`dest`的形状。
    dest和src的数据区域不得重叠。
- en: '[PRE600]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数组强制规则，将对象`src`分配给NumPy数组`dest`。 这基本上与[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")相同，但直接分配给输出数组。 成功返回0，失败返回-1。
- en: '[PRE601]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从源数组`src`移动到目标数组`dest`，必要时执行数据类型转换。 如果发生错误，则返回-1（否则返回0）。 `src`的形状必须可广播到`dest`的形状。
    dest和src的数据区域可能重叠。
- en: '[PRE602]'
  id: totrans-1415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`已经（C样式）连续且行为良好，则只返回引用，否则返回数组的（连续且行为良好）副本。 参数op必须是ndarray的（子类的）并且不对其进行检查。
- en: '[PRE603]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 将`obj`转换为ndarray。 该参数可以是任何嵌套序列或导出数组接口的对象。 这是使用`NULL`、0、0、0作为其他参数的[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")的宏形式。 您的代码必须能够处理任何数据类型描述符和任何数据标志的组合以使用此宏。
- en: '[PRE604]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，除了它可以接受一个*requirements*参数，指示生成的数组必须具有的属性。可以强制执行的可用要求包括[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")，[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")，[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")，[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")，[`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")，[`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY")，[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")，[`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST")，和[`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY")。也可以使用标准组合标志：
- en: '[PRE605]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O")，除了它可以接受一个*typenum*参数，指定返回的数组的类型编号。
- en: '[PRE606]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 结合[`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF")和[`PyArray_FROM_OT`](#c.PyArray_FROM_OT
    "PyArray_FROM_OT")，允许提供*typenum*和*flags*参数。
- en: '[PRE607]'
  id: totrans-1425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")，除了使用typenumber指定数据类型之外。[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")（*typenum*）直接传递给[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")。如果作为requirements传入了[`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY")，则此宏还会将[`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")添加到requirements中。
- en: '[PRE608]'
  id: totrans-1427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 封装了使用axis=关键字并且能够正确处理None作为axis参数的函数和方法的功能。输入数组是`obj`，而`*axis`是转换后的整数（使得>=MAXDIMS为None值），`requirements`给出了`obj`的所需属性。输出是输入的转换版本，以满足要求，并且如果需要进行了展平。输出时将会转换`*axis`的负值，并将检查新值以确保与`obj`的形状一致。
- en: Dealing with types
  id: totrans-1429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理类型
- en: General check of Python Type
  id: totrans-1430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python类型的通用检查
- en: '[PRE609]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是类型是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")的子类型的Python对象，则评估为true。
- en: '[PRE610]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是一个具有类型[`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")的Python对象，则评估为true。
- en: '[PRE611]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`实现了数组接口的任何部分，则`out`将包含使用接口创建的新ndarray的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，out将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在Python v3.11)")的借用引用，并且不设置错误条件。
- en: '[PRE612]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`op`实现了数组接口的任何部分，则`out`将包含使用接口创建的新ndarray的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，out将包含对Py_NotImplemented的借用引用，并且不设置错误条件。此版本允许在查找[`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__")属性的数组接口的部分中设置dtype。*context*未使用。
- en: '[PRE613]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是（子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")的实例，并且维度为0，则评估为真。
- en: '[PRE614]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是`Py{cls}ArrType_Type`的实例，则评估为真。
- en: '[PRE615]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是数组标量（`PyGenericArr_Type`子类型的实例）或者是（子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")且维度为0的实例，则评估为真。
- en: '[PRE616]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是内置数字类型（int、float、complex、long、bool）的实例，则评估为真。
- en: '[PRE617]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python内置标量对象（int、float、complex、bytes、str、long、bool），则评估为真。
- en: '[PRE618]'
  id: totrans-1449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python标量对象（参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar "PyArray_IsPythonScalar")）或者数组标量（`PyGenericArr_Type`子类型的实例），则评估为真。
- en: '[PRE619]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python标量对象（参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar "PyArray_IsPythonScalar")）、数组标量（`PyGenericArr_Type`子类型的实例）或者是（`PyArray_Type`子类型的）维度为0的实例的（子类的）实例，则评估为真。
- en: Data-type checking
  id: totrans-1453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型检查
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于typenum宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可直接解释为[PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(在Python v3.11)")。
- en: '[PRE620]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: Type represents an unsigned integer.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示无符号整数。
- en: '[PRE623]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: Type represents a signed integer.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示有符号整数。
- en: '[PRE626]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: Type represents any integer.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任意整数。
- en: '[PRE629]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: Type represents any floating point number.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任意浮点数。
- en: '[PRE632]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-1472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: Type represents any complex floating point number.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任意复数浮点数。
- en: '[PRE635]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-1477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: Type represents any integer, floating point, or complex floating point number.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示任意整数、浮点数或复数浮点数。
- en: '[PRE638]'
  id: totrans-1479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-1481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: Type represents a string data type.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示字符串数据类型。
- en: '[PRE641]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-1485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示对应于标准Python标量（bool、int、float或complex）之一的枚举类型。
- en: '[PRE644]'
  id: totrans-1487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: '[PRE645]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示灵活数组类型之一（[`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING "NPY_STRING")，[`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE
    "NPY_UNICODE")或[`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID")）。
- en: '[PRE647]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 类型没有附加的大小信息，并且可以调整大小。只应在灵活的数据类型上调用。附加到数组的类型将始终被分配大小，因此不存在此宏的数组形式。
- en: Changed in version 1.18.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.18中更改。
- en: For structured datatypes with no fields this function now returns False.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有字段的结构化数据类型，此函数现在返回False。
- en: '[PRE648]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: Type represents a user-defined type.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示用户定义的类型。
- en: '[PRE651]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: Type is either flexible or user-defined.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是灵活的或用户定义的。
- en: '[PRE654]'
  id: totrans-1503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: Type represents object data type.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 类型表示对象数据类型。
- en: '[PRE657]'
  id: totrans-1507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: Type represents Boolean data type.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表布尔数据类型。
- en: '[PRE660]'
  id: totrans-1511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: Type has fields associated with it.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 类型具有与其关联的字段。
- en: '[PRE662]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组* m*的数据区根据数组的数据类型描述符处于机器字节顺序中，则评估为true。
- en: '[PRE663]'
  id: totrans-1516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根据数组的数据类型描述符，数组* m*的数据区不处于机器字节顺序中，则评估为True。
- en: '[PRE664]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果* type1*和* type2*实际上表示此平台上等效的类型（忽略每种类型的fortran成员），则返回[`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE")。例如，在32位平台上，[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")和[`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT
    "NPY_INT")是等效的。否则返回[`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE")。
- en: '[PRE665]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*a1*和*a2*是此平台上具有等效类型的数组，则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。
- en: '[PRE666]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")的特殊情况（…），不接受灵活数据类型，但可能更容易调用。'
- en: '[PRE667]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字节顺序字符*b1*和*b2*（[`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE")，[`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG")，[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")，[`NPY_IGNORE`](#c.NPY_IGNORE
    "NPY_IGNORE")）相等或等价于它们对本机字节顺序的规定，则返回True。因此，在小端机器上，[`NPY_LITTLE`](#c.NPY_LITTLE
    "NPY_LITTLE")和[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")是等价的，在大端机器上它们是不等价的。
- en: Converting data types
  id: totrans-1526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型转换
- en: '[PRE668]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于向后兼容Numeric C-API和向非灵活类型的简单转换。返回一个新的数组对象，其中元素* arr*转换为* typenum*的数据类型，它必须是列举类型之一，而不是灵活类型。
- en: '[PRE669]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定*类型*的新数组，适当地将*arr*的元素转换。 Fortran 参数指定输出数组的排序方式。
- en: '[PRE670]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 从1.6开始，此函数简单地调用[`PyArray_CopyInto`](#c.PyArray_CopyInto "PyArray_CopyInto")，处理类型转换。
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组* in*的元素转换为数组* out*。输出数组应可写，具有输入数组元素数量的整数倍（out中可以放置多于一个副本），并且具有内置类型之一。成功时返回0，如果发生错误则返回-1。
- en: '[PRE671]'
  id: totrans-1534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从给定描述符到内置类型编号的低级转换函数。如果不存在转换函数，则返回`NULL`并设置错误。使用此函数而不是直接访问*from*->f->cast，可以支持添加到描述符转换字典的任何用户定义的转换函数。
- en: '[PRE672]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*fromtype*的数据类型数组可以在不丢失信息的情况下转换为*totype*的数据类型数组，则返回非零值。有一个例外，即允许将64位整数转换为64位浮点值，即使这可能会在大整数上丢失精度，以便不会在没有明确要求的情况下扩散使用长双精度值。此函数不根据灵活数组类型的长度进行检查。
- en: '[PRE673]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy 1.6及更高版本中，[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")取代了此函数。
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)。
- en: '[PRE674]'
  id: totrans-1541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: New in version 1.6.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中新增。
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 根据转换规则*casting*，如果数据类型*fromtype*（可以包括灵活类型）的数组可以安全地转换为数据类型*totype*（可以包括灵活类型）的数组，则返回非零值。对于[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")的简单类型，基本上这是一个围绕[`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely")的包装器，但对于字符串或unicode等灵活类型，它会生成结果，考虑到它们的大小。只有当字符串或unicode类型足够大以容纳转换的整数/浮点类型的最大值时，整数和浮点类型才能使用[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")转换为字符串或unicode类型。
- en: '[PRE675]'
  id: totrans-1544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: New in version 1.6.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中新增。
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根据*casting*给定的转换规则*arr*可以转换为*totype*，则返回非零值。如果*arr*是一个数组标量，则其值会被考虑在内，当值转换为较小类型时，如果值不会溢出或被截断为整数，则也会返回非零值。
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与PyArray_CanCastTypeTo(PyArray_MinScalarType(arr)，totype，casting)的结果相同，但它还处理了一种特殊情况，因为uint值的集合不是具有相同位数的int值的子集。
- en: '[PRE676]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: New in version 1.6.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中新增。
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*arr*是一个数组，则返回其数据类型描述符，但如果*arr*是一个数组标量（具有0个维度），则找到可以将值转换为整数且不会溢出或截断的最小尺寸的数据类型。
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会将复数降级为浮点数或任何东西降级为布尔值，但当标量值为正时，将有符号整数降级为无符号整数。
- en: '[PRE677]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: New in version 1.6.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.6中新增。
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 找到*type1*和*type2*可以安全转换为的最小大小和种类的数据类型。此函数对称且可结合。字符串或Unicode结果将是为存储输入类型的最大值转换为字符串或Unicode而正确的大小。
- en: '[PRE678]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: New in version 1.6.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6中的新功能。
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对所有输入数组和dtype对象应用类型提升，使用NumPy规则来组合标量和数组，以确定给定操作的操作数集合的输出类型。这与ufuncs产生的相同结果类型相同。
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type")的文档，以了解有关类型提升算法的更多细节。
- en: '[PRE679]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被[`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")和/或[`PyArray_ResultType`](#c.PyArray_ResultType
    "PyArray_ResultType")取代。
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于确定两个或多个数组可以转换为的共同类型。它仅适用于非灵活的数组类型，因为没有传递任何`itemsize`信息。*mintype*参数表示可接受的最小类型，*op*表示将被转换为数组的对象。返回值是代表*op*应具有的数据类型的枚举类型编号。
- en: '[PRE680]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数提供的功能在1.6中引入的迭代器[`NpyIter`](iterator.html#c.NpyIter "NpyIter")中基本被取代，使用标志[`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE")或对所有操作数使用相同的dtype参数。
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 将*op*中包含的Python对象序列转换为具有相同数据类型的ndarrays数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，返回值是长度为*n*的[`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")指针数组（如果发生错误则返回`NULL`）。返回的数组必须由此例程的调用者（使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE")）释放，否则会发生内存泄漏。下面是一个典型用法的示例模板代码：
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.18.0版本中更改：标量和零维数组的组合现在产生一个能容纳标量值的类型。先前优先考虑了数组的dtype。
- en: '[PRE681]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的、大小为*arr* ->itemsize的内存的指针，其中保存了该类型的0的表示。返回的指针*ret*在不再需要时，**必须被**使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret)释放。
- en: '[PRE683]'
  id: totrans-1569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的、大小为*arr* ->itemsize的内存的指针，其中保存了该类型的1的表示。返回的指针*ret*在不再需要时，**必须被**使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret)释放。
- en: '[PRE684]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*typenum*表示有效的类型编号（内置、用户定义或字符码），则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。否则，此函数返回[`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")。
- en: User-defined data types
  id: totrans-1573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的数据类型
- en: '[PRE685]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: Initialize all function pointers and members to `NULL`.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有函数指针和成员初始化为`NULL`。
- en: '[PRE686]'
  id: totrans-1576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据类型注册为数组的新用户定义数据类型。该类型必须填写大部分条目。这不总是被检查的，错误可能会产生段错误。特别是，`dtype`结构的typeobj成员必须填写为具有与*dtype*的elsize成员对应的固定大小元素大小的Python类型。此外，如果不需要支持，`f`成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem和cast（一些转换函数可能为`NULL`）。为避免混淆，应选择一个唯一的字符类型码，但这并不是强制执行的，也不能在内部依赖它。
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个唯一标识该类型的用户定义类型编号。然后，可以使用返回的类型编号从[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")中获取指向新结构的指针。如果发生错误，则返回-1。如果此*dtype*已经注册（仅根据指针的地址进行检查），则返回先前分配的类型编号。
- en: '[PRE687]'
  id: totrans-1579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 注册一个低级转换函数*castfunc*，以将数据类型*descr*转换为给定的数据类型编号*totype*。成功返回`0`，失败返回`-1`。
- en: '[PRE688]'
  id: totrans-1581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据类型对象*descr*的标量类型注册为可以安全转换为类型编号为*totype*的数据类型。当*scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")时，注册数据类型*descr*的数组可以安全地转换为类型编号为*totype*的数据类型。成功返回值为0，失败返回值为-1。
- en: '[PRE689]'
  id: totrans-1583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串，返回具有该字符串作为类型对象名称的数据类型的类型编号。如果找不到类型，则返回`NPY_NOTYPE`而不设置错误。仅适用于用户定义的数据类型。
- en: Special functions for NPY_OBJECT
  id: totrans-1585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPY_OBJECT的特殊函数
- en: Warning
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数组或填充有对象的缓冲区时，NumPy会尽量确保在任何数据被读取之前用`None`填充这些缓冲区。但是，可能存在代码路径，其中数组只初始化为`NULL`。NumPy本身接受`NULL`作为`None`的别名，但在调试模式编译时，可能会`assert`非`NULL`。
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 因为NumPy尚未在None初始化方面保持一致，用户**必须**预计在处理NumPy创建的缓冲区时会得到`NULL`的值。用户**还应**确保将完全初始化的缓冲区传递给NumPy，因为将来NumPy可能使这成为一个严格要求。
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有意确保在读取之前始终初始化对象数组。任何未能这样做的情况都将被视为错误。将来，用户可能可以在从任何数组中读取时依赖非空值，尽管对于刚创建的数组可能会保留例外（例如，在ufunc代码中的输出数组）。截至NumPy
    1.23，已知存在未正确填充的代码路径。
- en: '[PRE690]'
  id: totrans-1590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何Python对象的数组*op*，根据*op*的数据类型，增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回0。
- en: '[PRE691]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据类型*dtype*，增加位置*ptr*处的所有对象的引用计数的函数。如果*ptr*是具有任何偏移量处的对象的结构化类型的开始，则这将（递归地）增加结构化类型中所有类似对象的引用计数。
- en: '[PRE692]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何Python对象的数组*op*，根据*op*的数据类型，减少数组中每个对象的引用计数。正常返回值为0。如果发生错误，则返回-1。
- en: '[PRE693]'
  id: totrans-1596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 根据记录在数据类型*dtype*中的对象类似项，XDECREF位置*ptr*处的所有对象。这将递归地进行，以便如果`dtype`本身具有包含类似对象的数据类型的字段，则将XDECREF所有类似对象字段。
- en: '[PRE694]'
  id: totrans-1598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 用值*obj*填充新创建的数组中所有包含对象数据类型的位置。不执行任何检查，但*arr*必须是数据类型[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")的单一段并且未初始化（位置中没有先前的对象）。如果需要在调用此函数之前减少对象数组中所有项目的引用计数，请使用[`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF")（*arr*）。
- en: '[PRE695]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 前提条件：`arr`是`base`的副本（尽管可能有不同的步幅、顺序等）。设置[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志以及`arr->base`，并将`base`设置为只读。在调用*Py_DECREF*之前调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")，以便将任何更改复制回`base`并重置只读标志。
- en: Returns 0 for success, -1 for failure.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 成功返回0，失败返回-1。
- en: General check of Python Type
  id: totrans-1603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python类型的一般检查
- en: '[PRE696]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python对象，并且其类型是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")的子类型，则返回true。
- en: '[PRE697]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是Python对象，并且其类型是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type")，则返回true。
- en: '[PRE698]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `op` 实现了数组接口的任何部分，则 `out` 将包含使用该接口新创建的 ndarray 的新引用，或者如果在转换过程中发生错误，则 `out`
    将包含 `NULL`。否则，out 将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(在 Python v3.11 中)") 的借用引用，并且不设置错误条件。
- en: '[PRE699]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `op` 实现了数组接口的任何部分，则 `out` 将包含使用该接口新创建的 ndarray 的新引用，或者如果在转换过程中发生错误，则 `out`
    将包含 `NULL`。否则，out 将包含对 Py_NotImplemented 的借用引用，并且不设置错误条件。此版本允许在查找 [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") 属性的数组接口的部分中设置 dtype。*context* 未使用。
- en: '[PRE700]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是 [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")
    的实例（子类）且维度为 0，则评估为真。
- en: '[PRE701]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是 `Py{cls}ArrType_Type` 的实例，则评估为真。
- en: '[PRE702]'
  id: totrans-1616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是数组标量（`PyGenericArr_Type` 子类型的实例）之一，或者是维度为 0 的 [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") 的实例（子类），则评估为真。
- en: '[PRE703]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是内置数字类型（int、float、complex、long、bool）的实例，则评估为真。
- en: '[PRE704]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是内置 Python 标量对象（int、float、complex、bytes、str、long、bool）的实例，则评估为真。
- en: '[PRE705]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是 Python 标量对象（参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")）或者数组标量（`PyGenericArr_Type` 子类型的实例）之一，则评估为真。
- en: '[PRE706]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *op* 是 Python 标量对象（参见[`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")）、数组标量（`PyGenericArr_Type` 子类型的实例）或者维度为 0 的 [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") 子类型的实例之一，则评估为真。
- en: Data-type checking
  id: totrans-1626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型检查
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 typenum 宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可直接解释为 [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")* 的 [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(在 Python v3.11 中)")*。
- en: '[PRE707]'
  id: totrans-1628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: Type represents an unsigned integer.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示无符号整数。
- en: '[PRE710]'
  id: totrans-1632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-1633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: Type represents a signed integer.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示有符号整数。
- en: '[PRE713]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: '[PRE714]'
  id: totrans-1637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: Type represents any integer.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示任何整数。
- en: '[PRE716]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-1641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-1642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: Type represents any floating point number.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示任何浮点数。
- en: '[PRE719]'
  id: totrans-1644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-1646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: Type represents any complex floating point number.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示任何复数浮点数。
- en: '[PRE722]'
  id: totrans-1648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: Type represents any integer, floating point, or complex floating point number.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示任何整数、浮点数或复数浮点数。
- en: '[PRE725]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-1653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: '[PRE727]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: Type represents a string data type.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示字符串数据类型。
- en: '[PRE728]'
  id: totrans-1656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: '[PRE729]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: Type 表示枚举类型，对应于标准 Python 标量类型之一（bool、int、float 或 complex）。
- en: '[PRE731]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表灵活数组类型之一（[`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING "NPY_STRING")，[`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE
    "NPY_UNICODE")，或[`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID")）。
- en: '[PRE734]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 类型没有附加大小信息，并且可以调整大小。应仅在灵活的数据类型上调用。附加到数组的类型将始终具有尺寸，因此该宏的数组形式不存在。
- en: Changed in version 1.18.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.18版本中更改。
- en: For structured datatypes with no fields this function now returns False.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有字段的结构化数据类型，此函数现在返回False。
- en: '[PRE735]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-1669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: Type represents a user-defined type.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表用户定义的类型。
- en: '[PRE738]'
  id: totrans-1672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-1673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: '[PRE740]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: Type is either flexible or user-defined.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是灵活的或用户定义的。
- en: '[PRE741]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-1677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: Type represents object data type.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表对象数据类型。
- en: '[PRE744]'
  id: totrans-1680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-1681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-1682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: Type represents Boolean data type.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 类型代表布尔数据类型。
- en: '[PRE747]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: Type has fields associated with it.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 类型具有与之关联的字段。
- en: '[PRE749]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组*m*的数据区域根据数组的数据类型描述符符合机器字节顺序，则评估为真。
- en: '[PRE750]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组*m*的数据区域根据数组的数据类型描述符*不*符合机器字节顺序，则评估为真。
- en: '[PRE751]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*type1*和*type2*实际上代表此平台上的等效类型（忽略每种类型的fortran成员），则返回[`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE")。例如，在32位平台上，[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG")和[`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT
    "NPY_INT")是等效的。否则返回[`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE")。
- en: '[PRE752]'
  id: totrans-1693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*a1*和*a2*是具有等效类型（对于此平台）的数组，则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。
- en: '[PRE753]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")（…）的特殊情况，不接受灵活的数据类型，但可能更容易调用。'
- en: '[PRE754]'
  id: totrans-1697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字节顺序字符*b1*和*b2*（[`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE")，[`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG")，[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")，[`NPY_IGNORE`](#c.NPY_IGNORE
    "NPY_IGNORE")）相等或相等于它们对本机字节顺序的规范，则为真。因此，在小端机器上，[`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE")和[`NPY_NATIVE`](#c.NPY_NATIVE
    "NPY_NATIVE")是等效的，在大端机器上则不是。
- en: Converting data types
  id: totrans-1699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换数据类型
- en: '[PRE755]'
  id: totrans-1700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于向后兼容Numeric C-API和对非灵活类型进行简单转换。返回一个新的数组对象，其中的元素被转换为数据类型*typenum*，它必须是枚举类型之一而不是灵活类型。
- en: '[PRE756]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定*类型*的新数组，将*arr*的元素适当转换。fortran参数指定输出数组的排序方式。
- en: '[PRE757]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 截至1.6版本，此函数只是调用[`PyArray_CopyInto`](#c.PyArray_CopyInto "PyArray_CopyInto")来处理转换。
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 将*in*数组的元素转换为*out*数组。输出数组应该是可写的，具有输入数组的元素数量的整数倍（可以将多个副本放入out），并且具有内置类型之一的数据类型。成功时返回0，如果发生错误则返回-1。
- en: '[PRE758]'
  id: totrans-1707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从给定描述符转换为内置类型编号的低级转换函数。如果不存在转换函数，则返回 `NULL` 并设置错误。使用此函数而不是直接访问 *from* ->f->cast
    将允许支持添加到描述符转换字典的任何用户定义的转换函数。
- en: '[PRE759]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *fromtype* 的数组可以在不丢失信息的情况下转换为 *totype* 的数组，则返回非零值。例外情况是允许将 64 位整数转换为 64 位浮点值，即使这可能导致大整数失去精度，也不会隐式请求使用
    long double。此函数不根据灵活数组类型的长度进行检查。
- en: '[PRE760]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    在 NumPy 1.6 及更高版本中取代了这个函数。'
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于 `PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)`。
- en: '[PRE761]'
  id: totrans-1714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: New in version 1.6.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.6 版本开始提供。
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据类型为 *fromtype*（包括灵活类型），根据转换规则 *casting*，可以安全地转换为数据类型为 *totype*（包括灵活类型）的数组，则返回非零值。对于简单类型，使用
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING")，基本上是
    [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely "PyArray_CanCastSafely") 的一个包装器，但对于字符串或
    Unicode 等灵活类型，它会考虑到它们的大小。只有当字符串或 Unicode 类型足够大以容纳要转换的整数/浮点数类型的最大值时，整数和浮点数类型才可以使用
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING") 转换为字符串或
    Unicode 类型。
- en: '[PRE762]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: New in version 1.6.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.6 版本开始提供。
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 根据给定的 *casting* 规则，如果 *arr* 可以根据转换规则转换为 *totype*，则返回非零值。如果 *arr* 是数组标量，则还将考虑其值，并且当值转换为较小类型时不会溢出或截断时也返回非零值。
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与 PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting) 的结果相同，但它还处理了一个特殊情况，因为具有相同位数的类型的
    uint 值集合不是 int 值集合的子集。
- en: '[PRE763]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: New in version 1.6.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.6 版本开始提供。
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 是数组，则返回其数据类型描述符；但如果 *arr* 是数组标量（维度为 0），则找到可将值转换为的最小尺寸的数据类型，而不会溢出或截断为整数。
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会将复数转换为浮点数，也不会将任何值转换为布尔值，但当标量值为正时，会将有符号整数转换为无符号整数。
- en: '[PRE764]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: New in version 1.6.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.6 版本开始提供。
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 *type1* 和 *type2* 可以安全转换为的最小大小和种类的数据类型。这个函数是对称的和可结合的。字符串或unicode结果将是存储将输入类型转换为字符串或unicode的最大值所需的正确大小。
- en: '[PRE765]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: New in version 1.6.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6 版本中新增。
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 这将类型提升应用于所有输入数组和dtype对象，使用NumPy规则来组合标量和数组，以确定给定操作的输出类型。这是ufuncs产生的相同结果类型。
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细了解类型提升算法的文档，请参阅[`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type")。
- en: '[PRE766]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数已被 [`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")
    和/或 [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType") 取代。
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对确定两个或更多数组可以转换为的共同类型非常有用。它仅适用于非灵活数组类型，因为没有传递任何项目大小信息。*mintype* 参数表示可接受的最小类型，*op*
    表示将转换为数组的对象。返回值是代表 *op* 应该具有的数据类型的枚举类型号。
- en: '[PRE767]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供的功能在1.6中引入了带有标志[`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE")或对所有操作数具有相同dtype参数的迭代器[`NpyIter`](iterator.html#c.NpyIter
    "NpyIter")中大部分已被取代。
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 将包含在*op*中的Python对象的序列转换为具有相同数据类型的ndarrays数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，返回值为*n*长度的[`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")指针数组（如果发生错误，则返回`NULL`）。调用此例程的调用者必须释放返回的数组（使用[`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE")），并且其中的所有数组对象都必须被`DECREF`‘d，否则将发生内存泄漏。下面的示例模板代码显示了典型的用法：
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.18.0 更改：标量和零维数组的混合现在会产生一个能够容纳标量值的类型。以前，优先考虑数组的dtype。
- en: '[PRE768]'
  id: totrans-1739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-1740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的大小为*arr* ->itemsize的内存的指针，该内存保存该类型的表示为0的表示。返回的指针*ret*，**必须使用** [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) **释放**，当不再需要时。
- en: '[PRE770]'
  id: totrans-1742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新创建的大小为*arr* ->itemsize的内存的指针，该内存保存该类型的表示为1的表示。返回的指针*ret*，**必须使用** [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) **释放**，当不再需要时。
- en: '[PRE771]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*typenum*表示有效的类型号（内置的或用户定义的或字符代码），则返回[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")。否则，该函数返回[`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")。
- en: User-defined data types
  id: totrans-1746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的数据类型
- en: '[PRE772]'
  id: totrans-1747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: Initialize all function pointers and members to `NULL`.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化所有函数指针和成员为`NULL`。
- en: '[PRE773]'
  id: totrans-1749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 注册一个数据类型为数组的新用户定义数据类型。该类型必须填写大部分条目。这通常不会被检查，并且会产生段错误。特别是，`dtype`结构的typeobj成员必须填写有一个具有与*dtype*中的元素大小相对应的固定大小元素大小的Python类型。此外，`f`成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem和cast（如果不需要支持，则一些转换函数可能为`NULL`）。为避免混淆，应选择一个唯一的字符类型码，但这并未强制执行，且在内部不依赖于此。
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个用户定义类型数字，用于唯一标识该类型。然后可以使用返回的类型号从[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType")中获取到新结构的指针。如果发生错误则返回-1。如果已经注册过这个*dtype*(只根据指针的地址检查)，则返回先前分配的类型号。
- en: '[PRE774]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 注册一个低级转换函数*castfunc*，以从数据类型*descr*转换为给定的数据类型号*totype*。任何旧的转换函数都将被覆盖。成功时返回`0`，失败时返回`-1`。
- en: '[PRE775]'
  id: totrans-1754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据类型号*totype*注册为可以从给定*scalar*类型的数据类型对象*descr*进行转换。使用*scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")来注册，即一个数据类型为*descr*的数组可以安全地转换为类型编号为*totype*的数据类型。成功时返回值为0，失败时返回-1。
- en: '[PRE776]'
  id: totrans-1756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串，返回具有该字符串为类型对象名称的数据类型的类型号。如果找不到类型，则返回`NPY_NOTYPE`而不设置错误。仅适用于用户定义的数据类型。
- en: Special functions for NPY_OBJECT
  id: totrans-1758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPY_OBJECT的特殊功能
- en: Warning
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用填充有对象的数组或缓冲区时，NumPy会尽量确保在可以读取任何数据之前，这些缓冲区都填充有`None`。但是，可能存在代码路径，其中数组只被初始化为`NULL`。NumPy本身接受`NULL`作为`None`的别名，但在调试模式下编译时，可能会`assert`非`NULL`。
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 因为NumPy在初始化为None方面尚不一致，用户**必须**在处理由NumPy创建的缓冲区时，预期得到一个`NULL`值。用户**还应该**确保向NumPy传递完全初始化的缓冲区，因为NumPy将来可能会将此作为强制要求。
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 目前打算确保NumPy在可以读取对象数组之前总是初始化它们。任何未能这样做的情况将被视为错误。将来，用户可以依赖于从任何数组中读取时为非NULL值，尽管可能会为新创建的数组的写入保留异常（例如，在ufunc代码中的输出数组）。截至NumPy
    1.23，存在已知的代码路径存在未进行正确填充的情况。
- en: '[PRE777]'
  id: totrans-1763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何Python对象的数组 *op*。根据*op*的数据类型来增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回0。
- en: '[PRE778]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数，根据数据类型 *dtype* 来增加位置*ptr*处的所有对象的引用计数。如果*ptr*是具有偏移量处的对象的结构类型的起始位置，则这将（递归地）增加结构类型中所有类似对象的引用计数。
- en: '[PRE779]'
  id: totrans-1767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 用于包含任何Python对象的数组 *op*。它根据*op*的数据类型来递减数组中每个对象的引用计数。正常的返回值是0。如果发生错误，返回-1。
- en: '[PRE780]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数，用于按照数据类型 *dtype* 中记录的位置 *ptr* 来XDECREF所有类似对象的项目。这将递归地工作，以便如果 `dtype` 本身具有包含类似对象的数据类型的字段，则将XDECREF所有类似对象的字段。
- en: '[PRE781]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 用单个值 obj 填充新创建的数组中结构的所有位置，该结构具有对象数据类型。不执行任何检查，但 *arr* 必须是[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")数据类型的单段且未初始化（位置中没有以前的对象）。如果需要在调用此函数之前递减对象数组中的所有项目，请使用[`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*)。
- en: '[PRE782]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 先决条件：`arr`是`base`的副本（尽管可能具有不同的步幅、顺序等）。设置[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")标志和`arr->base`，并将`base`设置为只读。在调用 *Py_DECREF* 之前，调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")以将任何更改复制回`base`并重置只读标志。
- en: Returns 0 for success, -1 for failure.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 返回0表示成功，-1表示失败。
- en: '## Array flags'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数组标志'
- en: The `flags` attribute of the `PyArrayObject` structure contains important information
    about the memory used by the array (pointed to by the data member) This flag information
    must be kept accurate or strange results and even segfaults may result.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 结构`PyArrayObject`的`flags`属性包含有关数组使用的内存的重要信息（由数据成员指向）。此标志信息必须保持准确，否则可能会产生奇怪的结果，甚至可能会出现段错误。
- en: There are 6 (binary) flags that describe the memory area used by the data buffer.
    These constants are defined in `arrayobject.h` and determine the bit-position
    of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like
    interface for getting (and, if appropriate, setting) these flags.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 有 6 个（二进制）标志描述了数据缓冲区使用的内存区域。这些常量在 `arrayobject.h` 中定义，并确定了标志的位位置。Python公开了一个很好的基于属性的接口，以及一个类似于字典的接口，用于获取（如果合适，设置）这些标志。
- en: Memory areas of all kinds can be pointed to by an ndarray, necessitating these
    flags. If you get an arbitrary `PyArrayObject` in C-code, you need to be aware
    of the flags that are set. If you need to guarantee a certain kind of array (like
    [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    and [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")), then pass
    these requirements into the PyArray_FromAny function.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的内存区域都可以由 ndarray 指向，这需要这些标志。如果你在 C 代码中得到一个任意的 `PyArrayObject`，你需要注意已设置的标志。如果你需要保证某种类型的数组（例如
    [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    和 [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")），那么将这些要求传递给
    PyArray_FromAny 函数。
- en: Basic Array Flags
  id: totrans-1780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数组标志
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ndarray 可以有一个数据段，不是一个简单连续的良好内存块，你可以操纵它。它可能不会与字边界对齐（在某些平台上非常重要）。它的数据可能与机器识别的字节顺序不同。它可能不可写。它可能是
    Fortran 连续的顺序。数组标志用于指示与数组相关的数据可以说什么。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 的 1.6 版本及更早版本中，以下标志中没有在它们中间使用 _ARRAY_ 宏命名空间。这种常量命名形式在 1.7 版本中已经过时。
- en: '[PRE783]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: The data area is in C-style contiguous order (last index varies the fastest).
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域是以 C 风格连续顺序排列的（最后一个索引变化最快）。
- en: '[PRE784]'
  id: totrans-1785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域是以 Fortran 风格连续顺序排列的（第一个索引变化最快）。
- en: Note
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以同时是 C 风格和 Fortran 风格连续的。这对于 1 维数组是清楚的，但对于更高维度的数组也是真实的。
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于连续的数组，对于给定维度 `arr.strides[dim]` 的步幅可能是*任意*的，如果 `arr.shape[dim] == 1` 或数组没有元素。对于
    C 风格连续数组或 Fortran 风格连续数组，通常不会满足 `self.strides[-1] == self.itemsize` 或 `self.strides[0]
    == self.itemsize`。从 C API 中访问数组的 `itemsize` 的正确方法是 `PyArray_ITEMSIZE(arr)`。
- en: See also
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarray 的内部内存布局](../arrays.ndarray.html#arrays-ndarray)'
- en: '[PRE785]'
  id: totrans-1792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域是由该数组拥有的。不应该手动设置，而是创建一个包装数据的 `PyObject` 并将数组的基础设置为该对象。例如，请参阅 `test_mem_policy`
    中的测试。
- en: '[PRE786]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: The data area and all array elements are aligned appropriately.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域和所有数组元素都适当地对齐。
- en: '[PRE787]'
  id: totrans-1796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: The data area can be written to.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域可以被写入。
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述 3 个标志被定义为一个新的、良好的数组，这些标志被定义为 true。
- en: '[PRE788]'
  id: totrans-1799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域表示一个（良好的）副本，在调用 [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") 时应将其信息传输回原始副本。
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的标志，如果此数组表示的是因用户在 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    中需要某些标志而创建的副本，并且必须对某个其他数组进行复制（且用户要求在这种情况下设置此标志），则设置此标志。然后，基本属性将指向“不规范”数组（设置为只读）。[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") 将其内容复制回“不规范”数组（必要时进行转换），并将“不规范”数组重置为 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")。如果“不规范”数组一开始就不是 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")，则 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    将返回一个错误，因为无法进行 [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")。
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) 将更新`obj->flags`，使其符合`flags`，而`flags`可以是[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")或[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")之一。'
- en: Combinations of array flags
  id: totrans-1803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组标志的组合
- en: '[PRE789]'
  id: totrans-1804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE790]'
  id: totrans-1806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE791]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE792]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE793]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE794]'
  id: totrans-1814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE795]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: Flag-like constants
  id: totrans-1818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似标志的常量
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量用于[`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")（及其宏形式）中，以指定新数组的期望属性。
- en: '[PRE796]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: Cast to the desired type, even if it can’t be done without losing information.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换为所需类型，即使这样做会丢失信息。
- en: '[PRE797]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE797]'
- en: Make sure the resulting array is a copy of the original.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 确保结果数组是原始数组的副本。
- en: '[PRE798]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE798]'
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 确保结果对象是一个真正的 ndarray，而不是一个子类。
- en: Flag checking
  id: totrans-1826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志检查
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些宏，*arr* 必须是（子类的）[`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") 的实例。
- en: '[PRE799]'
  id: totrans-1828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE799]'
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数arr必须是一个ndarray或其子类。参数*flags*应该是一个整数，由数组可能拥有的标志的位组合组成：[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")。
- en: '[PRE800]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE800]'
- en: Evaluates true if *arr* is C-style contiguous.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 是C风格连续的，则为真。
- en: '[PRE801]'
  id: totrans-1832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE801]'
- en: Evaluates true if *arr* is Fortran-style contiguous.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 是Fortran风格连续的，则为真。
- en: '[PRE802]'
  id: totrans-1834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE802]'
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 是Fortran风格的连续存储且*不是* C风格的连续存储，则为真。 [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS
    "PyArray_IS_F_CONTIGUOUS") 是测试Fortran风格连续性的正确方式。
- en: '[PRE803]'
  id: totrans-1836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE803]'
- en: Evaluates true if the data area of *arr* can be written to
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域可以写入，则为真。
- en: '[PRE804]'
  id: totrans-1838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE804]'
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域在机器上是正确对齐的，则为真。
- en: '[PRE805]'
  id: totrans-1840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE805]'
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域根据其描述符是对齐的且可写，并且符合机器字节顺序，则为真。
- en: '[PRE806]'
  id: totrans-1842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE806]'
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域是对齐的并且符合机器字节顺序，则为真。
- en: '[PRE807]'
  id: totrans-1844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE807]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域是C风格连续的，并且 [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*) 为true，则为真。
- en: '[PRE808]'
  id: totrans-1846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE808]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域是Fortran风格连续的，并且 [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*) 为true，则为真。
- en: '[PRE809]'
  id: totrans-1848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE809]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域是C风格的连续存储，对齐且符合机器字节顺序，则为真。
- en: '[PRE810]'
  id: totrans-1850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE810]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域是Fortran风格连续的，对齐且符合机器字节顺序**，** 则为真。
- en: '[PRE811]'
  id: totrans-1852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE811]'
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *arr* 的数据区域由一个（C风格或Fortran风格）连续段组成，则为真。
- en: '[PRE812]'
  id: totrans-1854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE812]'
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") 和 [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    数组标志可以从数组对象本身 "计算" 出来。此程序根据 *flagmask* 指定的方式通过进行所需的计算来更新 *arr* 中的一个或多个标志。'
- en: Warning
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组进行操作可能导致这些标志发生变化时，保持标志更新是很重要的。稍后在NumPy中依赖这些标志状态进行的计算不会重复进行计算以更新它们。
- en: '[PRE813]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE813]'
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*是可写的，此函数不执行任何操作并返回0。如果*obj*不可写，则引发异常并返回-1。它也可以执行其他一些工作，比如对即将成为视图的数组发出警告。写入数组之前一定要在某个时刻调用此函数。
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*是数组的名称，用于提供更好的错误消息。它可以是类似于“分配目标”、“输出数组”甚至只是“数组”之类的东西。'
- en: Basic Array Flags
  id: totrans-1861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本数组标志
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ndarray可能有一个数据段，它不是一个简单的连续的行为良好的内存块，你可以对其进行操作。它可能不与字边界对齐（在一些平台上非常重要）。它可能具有与机器识别不同的字节顺序。它可能是不可写的。它可能是Fortran连续顺序的。数组标志用于指示与数组关联的数据可以说什么。
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy的1.6版本及更早版本中，以下标志没有在它们中包含_MACRO_名称空间。这种常量名称形式在1.7中已经被弃用。
- en: '[PRE814]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE814]'
- en: The data area is in C-style contiguous order (last index varies the fastest).
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域以C风格的连续顺序排列（最后一个索引变化最快）。
- en: '[PRE815]'
  id: totrans-1866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE815]'
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域以Fortran风格的连续顺序排列（第一个索引变化最快）。
- en: Note
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以同时是C风格和Fortran风格连续的。这对于1维数组是显而易见的，但对于更高维的数组也可能成立。
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于连续数组，对于给定维度的步长`arr.strides[dim]`可能是*任意的*，如果`arr.shape[dim] == 1`或者数组没有元素。对于C风格的连续数组，通常`self.strides[-1]
    == self.itemsize`或者对于Fortran风格的连续数组`self.strides[0] == self.itemsize`是错误的。从C API访问数组的`itemsize`的正确方式是`PyArray_ITEMSIZE(arr)`。
- en: See also
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarray的内部内存布局](../arrays.ndarray.html#arrays-ndarray)'
- en: '[PRE816]'
  id: totrans-1873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE816]'
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域归此数组所有。不应手动设置，而是创建一个包装数据的`PyObject`，并将数组的基础设置为该对象。例如，请参阅`test_mem_policy`中的测试。
- en: '[PRE817]'
  id: totrans-1875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE817]'
- en: The data area and all array elements are aligned appropriately.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域和所有数组元素都被适当地对齐。
- en: '[PRE818]'
  id: totrans-1877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE818]'
- en: The data area can be written to.
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域可以被写入。
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述的3个标志被定义为一个新的、行为良好的数组具有这些标志为真。
- en: '[PRE819]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE819]'
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 数据区域表示一个（行为良好的）副本，当调用[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")时，其信息应被传输回原始数组。
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊标志，如果该数组代表因用户要求 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    中存在某些特定标志而必须对其他数组进行复制而产生的副本，那么就会设置这个标志。然后，base 属性指向“不端正”的数组（设置为只读）。 [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") 将把其内容复制回“不端正”的数组（必要时转换类型），并将“不端正”的数组重置为 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")。如果“不端正”的数组一开始就不是 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")，那么 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    将返回错误，因为此时不可能设置 [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")。
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) 将为 `flags` 更新 `obj->flags`，其中 `flags` 可以是 [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")、[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")、[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    或 [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") 中的任何一个。'
- en: Combinations of array flags
  id: totrans-1884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组标志的组合
- en: '[PRE820]'
  id: totrans-1885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE820]'
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
- en: '[PRE821]'
  id: totrans-1887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE821]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE822]'
  id: totrans-1889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE822]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE823]'
  id: totrans-1891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE823]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
- en: '[PRE824]'
  id: totrans-1893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE824]'
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: '[PRE825]'
  id: totrans-1895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE825]'
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
- en: '[PRE826]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE826]'
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
- en: Flag-like constants
  id: totrans-1899
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类似标志的常量
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量用于 [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")（及其宏形��）中，用于指定新数组的期望属性。
- en: '[PRE827]'
  id: totrans-1901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE827]'
- en: Cast to the desired type, even if it can’t be done without losing information.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换为所需类型，即使在不丢失信息的情况下也无法执行。
- en: '[PRE828]'
  id: totrans-1903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE828]'
- en: Make sure the resulting array is a copy of the original.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 确保生成的数组是原始数组的副本。
- en: '[PRE829]'
  id: totrans-1905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE829]'
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 确保生成的对象是一个实际的ndarray，而不是一个子类。
- en: Flag checking
  id: totrans-1907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志检查
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些宏，*arr*必须是[`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")的实例或子类。
- en: '[PRE830]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE830]'
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，arr，必须是一个ndarray或其子类。参数*flags*应该是一个整数，由数组可能具有的所有标志的位组合组成：[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS")，[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS")，[`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA")，[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")，[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")，[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")。
- en: '[PRE831]'
  id: totrans-1911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE831]'
- en: Evaluates true if *arr* is C-style contiguous.
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*是C风格连续的是真。
- en: '[PRE832]'
  id: totrans-1913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE832]'
- en: Evaluates true if *arr* is Fortran-style contiguous.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*是Fortran风格连续的是真。
- en: '[PRE833]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE833]'
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*是Fortran风格连续并且*不是* C风格连续。[`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS
    "PyArray_IS_F_CONTIGUOUS") 是测试Fortran风格连续性的正确方式。
- en: '[PRE834]'
  id: totrans-1917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE834]'
- en: Evaluates true if the data area of *arr* can be written to
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域可以被写入是真
- en: '[PRE835]'
  id: totrans-1919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE835]'
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域在机器上正确对齐是真。
- en: '[PRE836]'
  id: totrans-1921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE836]'
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域是对齐的、可写的并且按照其描述符的机器字节顺序排列是真。
- en: '[PRE837]'
  id: totrans-1923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE837]'
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 评估*arr*的数据区域是否对齐并且按照机器字节顺序排列是真。
- en: '[PRE838]'
  id: totrans-1925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE838]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域是C风格连续的，且[`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*)为真，则为真。
- en: '[PRE839]'
  id: totrans-1927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE839]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域是Fortran风格连续的，并且[`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED "PyArray_ISBEHAVED")
    (*arr*)是真。
- en: '[PRE840]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE840]'
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域是C风格连续的、对齐的并且按照机器字节顺序排列是真。
- en: '[PRE841]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE841]'
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域是Fortran风格连续的、对齐的并且按照机器字节顺序排列**.**是真。
- en: '[PRE842]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE842]'
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 评估如果*arr*的数据区域由单个（C风格或Fortran风格）连续段组成是真。
- en: '[PRE843]'
  id: totrans-1935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE843]'
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")，[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")和[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")数组标志可以从数组对象本身“计算”出来。该例程通过执行所需的计算，根据*flagmask*指定的参数更新*arr*的一个或多个标志。'
- en: Warning
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行可能导致它们发生变化的数组处理时，保持标志的更新（使用[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags")可以有所帮助）是非常重要的。 NumPy中依赖于这些标志状态的后续计算不会重复计算以更新它们。
- en: '[PRE844]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE844]'
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*可写，该函数什么也不做并返回0。如果*obj*不可写，它会引发异常并返回-1。它还可能进行其他一些内部管理工作，比如针对正在转换为视图的数组发出警告。在对数组进行写操作之前，一定要在某个时候调用此函数。
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '*name*是数组的名称，用于提供更好的错误消息。可以是“赋值目标”，“输出数组”，甚至只是“数组”之类的东西。'
- en: Array method alternative API
  id: totrans-1942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组方法的替代API
- en: Conversion
  id: totrans-1943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: '[PRE845]'
  id: totrans-1944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE845]'
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*)。此函数[窃取引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*并返回一个使用当前数组中指定*offset*字节位置上的数据创建的给定*dtype*的新数组。新数组类型的*offset*加上其itemsize必须小于`self
    ->descr->elsize`，否则会引发错误。使用原始数组的相同形状和跨度。因此，此函数的效果是从结构化数组中返回字段。但它也可以用于从任何数组类型中选择特定的字节或字节组。
- en: '[PRE846]'
  id: totrans-1946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE846]'
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* )。将从指定*offset*字节开始并且具有给定*dtype*的字段设置为*val*。*offset*加上*dtype*
    ->elsize必须小于*self* ->descr->elsize，否则会引发错误。否则，将*val*参数转换为数组并复制到所指向的字段中。如有必要，目标数组的元素将重复以填充，但目标数组中的元素数量必须是*val*元素数量的整数倍。
- en: '[PRE847]'
  id: totrans-1948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE847]'
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*)。返回一个数据区域进行字节交换的数组。如果*inplace*非零，那么就原地进行字节交换并返回对自身的引用。否则，创建一个字节交换的副本，并保持自身不变。
- en: '[PRE848]'
  id: totrans-1950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE848]'
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*)。创建一个*old*数组的副本。返回的数组始终是对齐的和可写的，并且数据的解释与旧数组相同。如果*order*是[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则返回一个C风格的连续数组。如果*order*是[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，则返回一个Fortran风格的连续数组。如果*order is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，则返回的数组仅在旧数组为Fortran风格连续时才是Fortran风格连续；否则，它就是C风格连续的。
- en: '[PRE849]'
  id: totrans-1952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE849]'
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*)。从*自我*返回一个嵌套的Python列表。
- en: '[PRE850]'
  id: totrans-1954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE850]'
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*)。以Python字符串的形式返回此数组的字节。
- en: '[PRE851]'
  id: totrans-1956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE851]'
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 以C风格的连续方式将*自我*的内容写入文件指针*fp*中。如果*sep*是字符串“”或`NULL`，则以二进制字节形式写入数据。否则，使用*sep*字符串作为项目分隔符，以文本形式写入*自我*的内容。将每个项目打印到文件中。如果*format*字符串不是`NULL`或“”，那么它是一个Python打印语句格式字符串，显示如何写入项目。
- en: '[PRE852]'
  id: totrans-1958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE852]'
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象*自我*在给定的*文件*（可以是字符串或Python文件对象）中保存起来。如果*file*是Python字符串，则被视为文件的名称，然后以二进制模式打开。使用给定的*protocol*（如果*protocol*为负数，则使用最高可用值）。这只是cPickle.dump(*self*,
    *file*, *protocol*)的简单包装。
- en: '[PRE853]'
  id: totrans-1960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE853]'
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: 将*自我*中的对象pickle为Python字符串并返回它。使用提供的Pickle *protocol*（如果*protocol*为负数，则使用最高可用值）。
- en: '[PRE854]'
  id: totrans-1962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE854]'
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: 用给定的标量对象*obj*填充数组*arr*。首先将对象转换为*arr*的数据类型，然后复制到每个位置。如果发生错误，则返回-1，否则返回0。
- en: '[PRE855]'
  id: totrans-1964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE855]'
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*)。将数组*自我*作为可能不同数据类型的新视图返回，并作为不同的数组子类*ptype*。
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*dtype*为`NULL`，则返回的数组将具有与*自我*相同的数据类型。新数据类型必须与*自我*的大小一致。要么项目大小必须相同，要么*自我*必须是单段的，并且总字节数必须相同。在后一种情况下，返回的数组的维数将在最后一个（或第一个对于Fortran样式连续数组）维度上进行更改。返回数组的数据区域与*自我*完全相同。
- en: Shape Manipulation
  id: totrans-1967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状操作
- en: '[PRE856]'
  id: totrans-1968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE856]'
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个新数组（如果可能的话指向与*自我*相同的内存位置），但具有*newshape*给定的形状。如果新形状与*自我*的步幅不兼容，则将返回具有新指定形状的数组的副本。
- en: '[PRE857]'
  id: totrans-1970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE857]'
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*)，其中*shape*是一个序列。将*shape*转换为[`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims
    "PyArray_Dims")结构，并在内部调用[`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")。为了向后兼容
    - 不建议使用
- en: '[PRE858]'
  id: totrans-1972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE858]'
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze")（*self*）。返回* self *的所有长度为1的维度均已移除的新视图。
- en: Warning
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象始终是2维的。因此，数组的矩阵子类上调用[`PyArray_Squeeze`](#c.PyArray_Squeeze "PyArray_Squeeze")不产生任何效果。
- en: '[PRE859]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE859]'
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes")（*self*，*a1*，*a2*）。返回的数组是* self *中给定轴*a1*和*a2*交换后的新视图。
- en: '[PRE860]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE860]'
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize")（*self*，*newshape*，refcheck `=` *refcheck*，order=fortran）。此函数仅适用于单段数组。它会就地更改*
    self *的形状，并且如果* newshape *的元素总数与旧形状不同时，将为* self *重新分配内存。如果需要重新分配，则* self *必须拥有其数据，*self*
    - `>base==NULL`，*self* - `>weakrefs==NULL`，并且（除非refcheck为0）不能被任何其他数组引用。 fortran参数可以是[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")、[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")或[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")。目前对它没有影响。将来可能用于确定在构建维度不同的数组时，调整大小操作应如何查看数据。成功时返回None，出错时返回NULL。
- en: '[PRE861]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE861]'
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose")（*self*，*permute*）。根据数据结构* permute *重新排列ndarray对象* self
    *的轴并返回结果。如果* permute *为`NULL`，则结果数组的轴被颠倒。例如，如果*self*的形状为\(10\times20\times30\)，并且*permute*`.ptr`为（0,2,1），则结果的形状为\(10\times30\times20.\)如果*
    permute *为`NULL`，则结果的形状为\(30\times20\times10.\)
- en: '[PRE862]'
  id: totrans-1982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE862]'
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten")（*self*，*order*）。返回数组的1维副本。如果*order*为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，则按Fortran顺序扫描元素（第一维最快变化）。如果*order*为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则按C顺序扫描`self`的元素（最后一维最快变化）。如果*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，则使用[`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN")（*self*）的结果确定要展平的顺序。
- en: '[PRE863]'
  id: totrans-1984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE863]'
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于*self*.ravel(*order*)。与[`PyArray_Flatten`](#c.PyArray_Flatten "PyArray_Flatten")
    (*self*, *order*)具有相同的基本功能，除了如果*order*为0且*self*是C风格连续的，则形状会被改变但不执行复制。
- en: Item selection and manipulation
  id: totrans-1986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目选择和操作。
- en: '[PRE864]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE864]'
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*)，除了在Python中*axis*
    =None的情况下通过在C中设置*axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")来获得。沿给定的*axis*提取*self*中由整数值*indices*指定的项目。clipmode参数可以是[`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE")、[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP")或[`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP")，以表示对越界索引的处理方式。*ret*参数可以指定输出数组，而不是在内部创建一个新的。
- en: '[PRE865]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE865]'
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于*self*.put(*values*, *indices*, *clipmode*)。将*values*放入*self*中对应（展平的）*indices*的位置。如果*values*太小，它将根据需要重复。
- en: '[PRE866]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE866]'
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 在*mask*对应为真的位置（使用展平的上下文）将*values*放入*self*中。*mask*和*self*数组必须具有相同的元素总数。如果*values*太小，将根据需要重复。
- en: '[PRE867]'
  id: totrans-1993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE867]'
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*)。沿给定的*axis*复制*self*中的元素*op*次。*op*可以是一个标量整数或长度为*self*
    ->dimensions[*axis*]的序列，表示在轴上重复每个项目的次数。
- en: '[PRE868]'
  id: totrans-1995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE868]'
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*)。根据*self*中的整数值，从*op*中的数组序列中选择元素，创建一个新数组。这些数组必须全部可以广播到相同的形状，并且*self*中的条目应在0和len(*op*)之间。如果*ret*为NULL，则输出被放置在*ret*中，否则将创建新的输出。*clipmode*参数决定当*self*中的条目不在0和len(*op*)之间时的行为。
- en: '[PRE869]'
  id: totrans-1997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE869]'
- en: raise a ValueError;
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 ValueError;
- en: '[PRE870]'
  id: totrans-1999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE870]'
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 将小于0的值通过添加len(*op*)来封装，将大于等于len(*op*)的值通过减去len(*op*)来封装，直到它们在范围内；
- en: '[PRE871]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE871]'
- en: all values are clipped to the region [0, len(*op*) ).
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都被限制在[0, len(*op*) )的范围内。
- en: '[PRE872]'
  id: totrans-2003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE872]'
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于[`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*)。返回一个按*axis*排序的*self*数组。数组使用由*kind*表示的算法排序，它是一个整数/枚举，指向所使用的排序算法的类型。
- en: '[PRE873]'
  id: totrans-2005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE873]'
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort")（*self*，*axis*）。返回一个索引数组，按给定的`axis`选择这些索引将返回*self*的排序版本。如果*self*->descr是一个已定义字段的数据类型，则使用self->descr->names来确定排序顺序。第一个字段相等的比较将使用第二个字段，依此类推。要更改结构化数组的排序顺序，需创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。
- en: '[PRE874]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE874]'
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个相同形状的数组序列（*sort_keys*），返回一个与[`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")（…）类似的索引数组，该数组按字典顺序对数组进行排序。字典顺序指定当找到两个键相等时，基于后续键的比较顺序。合并排序（使相等的条目不动）需要为类型进行定义。排序通过首先使用第一个*sort_key*，然后使用第二个*sort_key*，依此类推来对索引进行排序来完成。这等同于
    Python 命令 lexsort(*sort_keys*, *axis*)。由于合并排序的工作方式，一定要理解*sort_keys*的顺序（与比较两个元素时使用的顺序相反）。
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数组都被收集到一个结构化数组中，那么[`PyArray_Sort`](#c.PyArray_Sort "PyArray_Sort")（…）也可以用来直接对数组进行排序。
- en: '[PRE875]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE875]'
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted")（*self*，*values*，*side*，*perm*）。假设*self*是一个按升序排列的一维数组，则输出是一个与*values*形状相同的索引数组，使得，如果将*values*中的元素插入到这些索引之前，*self*的顺序将被保留。不会对*self*是否按升序排列进行检查。
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '*side*参数指示返回的索引应该是第一个合适位置（如果是[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")）或最后一个位置（如果是[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）。'
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*sorter*参数不是`NULL`，必须是一个与*self*相同长度的整数索引的一维数组，可以将*self*排序为升序。这通常是对[`PyArray_ArgSort`](#c.PyArray_ArgSort
    "PyArray_ArgSort")（…）的调用结果。二分搜索用于找到所需的插入点。
- en: '[PRE876]'
  id: totrans-2014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE876]'
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*)。将数组分区，使得由*ktharray*索引的元素值位于数组全排序后的位置，并将所有小于第k个元素的元素放在第k个元素之前，大于或等于第k个元素的元素放在第k个元素之后。分区内所有元素的排序是未定义的。如果*self*->descr是具有字段定义的数据类型，则使用self->descr->names来确定排序顺序。如果第一个字段相等，则使用第二个字段，依此类推。要改变结构化数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构建数组的视图。成功返回零，失败返回-1。
- en: '[PRE877]'
  id: totrans-2016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE877]'
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*)。返回一个索引数组，选择这些索引沿着给定的`axis`将返回分区版本的*self*。
- en: '[PRE878]'
  id: totrans-2018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE878]'
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* )。返回由*axis1*和*axis2*定义的2维数组的*offset*对角线。
- en: '[PRE879]'
  id: totrans-2020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE879]'
- en: New in version 1.6.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.6 中新增。
- en: Counts the number of non-zero elements in the array object *self*.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 计算数组对象*self*中非零元素的数量。
- en: '[PRE880]'
  id: totrans-2023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE880]'
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*)。返回一个数组的索引数组元组，选择*self*中不为零的元素。如果（nd=`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM")(`self`))==1，则返回单个索引数组。索引数组具有数据类型[`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP
    "NPY_INTP")。如果返回一个元组（nd \(\neq\) 1），则其长度为nd。
- en: '[PRE881]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE881]'
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* )。返回沿着*axis*对应于*condition*中为真的元素。
- en: Calculation
  id: totrans-2027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算
- en: Tip
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到在Python中传入`axis=None`的效果（将数组视为1维数组），在轴上传入[`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS")。
- en: Note
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: out参数指定结果放置的位置。如果out为NULL，则创建输出数组，否则将输出放置在必须是正确大小和类型的out中。即使out不为NULL，始终返回对输出数组的新引用。如果不为NULL，则调用该例程的调用者有责任`Py_DECREF`
    out，否则将导致内存泄漏。
- en: '[PRE882]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE882]'
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax")（*self*，*axis*）。返回*self*沿*axis*的最大元素的索引。
- en: '[PRE883]'
  id: totrans-2034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE883]'
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin")（*self*，*axis*）。返回*self*沿*axis*的最小元素的索引。
- en: '[PRE884]'
  id: totrans-2036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE884]'
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max "numpy.ndarray.max")（*self*，*axis*）。返回沿指定*axis*的*self*的最大元素。当结果是单个元素时，返回的是numpy标量而不是ndarray。
- en: '[PRE885]'
  id: totrans-2038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE885]'
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min "numpy.ndarray.min")（*self*，*axis*）。返回沿指定*axis*的*self*的最小元素。当结果是单个元素时，返回的是numpy标量而不是ndarray。
- en: '[PRE886]'
  id: totrans-2040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE886]'
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp "numpy.ndarray.ptp")（*self*，*axis*）。返回*self*沿*axis*的最大元素与*self*沿*axis*的最小元素之差。当结果是单个元素时，返回的是numpy标量而不是ndarray。
- en: Note
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: rtype参数指定应该进行归约的数据类型。如果数组的数据类型不足以处理输出，这一点非常重要。默认情况下，所有整数数据类型都至少与[`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG")一样大，用于“add”和“multiply”ufuncs（这构成了mean、sum、cumsum、prod和cumprod函数的基础）。
- en: '[PRE887]'
  id: totrans-2044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE887]'
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean")（*self*，*axis*，*rtype*）。返回沿指定*axis*的元素的平均值，使用列举类型*rtype*作为要累加的数据类型。默认的求和行为使用[`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE")作为*rtype*。
- en: '[PRE888]'
  id: totrans-2046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE888]'
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace")（*self*，*offset*，*axis1*，*axis2*，*rtype*）。返回沿由*axis1*和*axis2*变量定义的2维数组的*offset*对角元素的和（使用*rtype*作为求和的数据类型）。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。
- en: '[PRE889]'
  id: totrans-2048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE889]'
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip")（*self*，*min*，*max*）。夹取数组*self*，使大于*max*的值固定为*max*，小于*min*的值固定为*min*。
- en: '[PRE890]'
  id: totrans-2050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE890]'
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate")（*self*）。返回*self*的复共轭。如果*self*不是复数数据类型，则返回一个带有引用的*self*。
- en: '[PRE891]'
  id: totrans-2052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE891]'
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*)。返回将元素四舍五入到最接近的小数位的数组。小数位被定义为
    \(10^{-\textrm{decimals}}\) 位，因此负的 *decimals* 会导致四舍五入到最接近的10、100等位。如果 *out* 为
    `NULL`，则创建输出数组，否则输出放入 *out* 中，*out* 必须是正确的大小和类型。
- en: '[PRE892]'
  id: totrans-2054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE892]'
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std "numpy.ndarray.std")
    (*self*, *axis*, *rtype*)。返回使用沿 *axis* 转换为数据类型 *rtype* 的数据的标准偏差。
- en: '[PRE893]'
  id: totrans-2056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE893]'
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum "numpy.ndarray.sum")
    (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的 1-d 向量和。在将数据转换为数据类型 *rtype*
    后执行求和。
- en: '[PRE894]'
  id: totrans-2058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE894]'
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的累积 1-d
    和。在将数据转换为数据类型 *rtype* 后执行累积和。
- en: '[PRE895]'
  id: totrans-2060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE895]'
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的 1-d 乘积。在将数据转换为数据类型
    *rtype* 后执行乘积。
- en: '[PRE896]'
  id: totrans-2062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE896]'
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的累积 1-d
    乘积。在将数据转换为数据类型 *rtype* 后执行累积乘积。
- en: '[PRE897]'
  id: totrans-2064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE897]'
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all "numpy.ndarray.all")
    (*self*, *axis*)。返回一个数组，其中对于 *self* 中由 *axis* 定义的每个 1-d 子数组，所有元素都为 True。
- en: '[PRE898]'
  id: totrans-2066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE898]'
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any "numpy.ndarray.any")
    (*self*, *axis*)。返回一个数组，其中对于 *self* 中由 *axis* 定义的每个 1-d 子数组，只要有一个元素为 True，就返回
    True 元素。
- en: Conversion
  id: totrans-2068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: '[PRE899]'
  id: totrans-2069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE899]'
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*)。此函数[窃取一个引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*，并返回使用当前数组中指定偏移量（以字节为单位）的数据生成的给定*dtype*的新数组。
    新数组类型的*offset*加上itemsize必须小于`self ->descr->elsize`，否则将引发错误。使用与原始数组相同的形状和步幅。因此，此函数的效果是从结构化数组返回字段。但是，它还可用于从任何数组类型中选择特定字节或字节组。
- en: '[PRE900]'
  id: totrans-2071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE900]'
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield")（*self*，*val*，*dtype*，*offset*）。将从指定偏移量（以字节为单位）开始并具有给定*dtype*的字段设置为*val*。
    *offset*加上*dtype*->elsize必须小于*self* ->descr->elsize，否则将引发错误。否则，将*val*参数转换为数组并复制到指向的字段中。如有必要，将重复*val*的元素以填充目标数组，但是目标中的元素数必须是*val*中元素数的整数倍。
- en: '[PRE901]'
  id: totrans-2073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE901]'
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*)。返回一个数据区域进行字节交换的数组。 如果*inplace*非零，则就地执行字节交换并返回自身的引用。否则，创建一个进行字节交换的副本，并保持自身不变。
- en: '[PRE902]'
  id: totrans-2075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE902]'
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*)。复制*old*数组。返回的数组始终对齐和可写，数据解释与旧数组相同。如果*order*为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则返回一个C风格的连续数组。 如果*order*为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，则返回一个Fortran风格的连续数组。 如果*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，则仅当旧数组为Fortran风格连续时，返回的数组才是Fortran风格连续；否则，它是C风格连续。
- en: '[PRE903]'
  id: totrans-2077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE903]'
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist")（*self*）。从* self *返回一个嵌套的Python列表。
- en: '[PRE904]'
  id: totrans-2079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE904]'
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes")（*self*，*order*）。以Python字符串形式返回此数组的字节。
- en: '[PRE905]'
  id: totrans-2081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE905]'
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 以 C 风格的连续方式将 *self* 的内容写入文件指针 *fp*。如果 *sep* 为字符串“”或 `NULL`，则以二进制字节写入数据。否则，使用
    *sep* 字符串作为项目分隔符，将 *self* 的内容作为文本写入。每个项目都将打印到文件中。如果 *format* 字符串不是 `NULL` 或 “”，则它是一个
    Python 的打印语句格式字���串，显示如何写入项目。
- en: '[PRE906]'
  id: totrans-2083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE906]'
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *self* 中的对象保存到给定的 *file* （可以是字符串或Python文件对象）中。如果 *file* 是一个Python字符串，则被认为是一个文件的名称，然后以二进制模式打开。使用给定的
    *protocol*（如果 *protocol* 是负数，则使用最高可用的 *protocol*）。这只是对 cPickle.dump(*self*, *file*,
    *protocol*) 的简单包装器。
- en: '[PRE907]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE907]'
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *self* 中的对象存储为 Python 字符串并返回。使用所提供的 Pickle *protocol*（或者如果 *protocol* 是负数，则使用最高可用的
    *protocol*）。
- en: '[PRE908]'
  id: totrans-2087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE908]'
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的标量对象 *obj* 填充数组 *arr*。首先将对象转换为 *arr* 的数据类型，然后将其复制到每个位置。如果发生错误，则返回 -1，否则返回
    0。
- en: '[PRE909]'
  id: totrans-2089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE909]'
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于 [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*)。返回一个新的数组 *self* 的视图，可能具有不同的数据类型 *dtype*
    和不同的数组子类 *ptype*。
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *dtype* 为 `NULL`，则返回的数组将与 *self* 具有相同的数据类型。新的数据类型必须与 *self* 的大小一致。要么项目大小必须相同，要么
    *self* 必须是单段的，并且字节的总数必须相同。在后一种情况下，返回的数组的维度将在最后一个维度（或者对于 Fortran 风格连续的数组，在第一个维度）进行更改。返回的数组的数据区域与
    self 完全相同。
- en: Shape Manipulation
  id: totrans-2092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状操作
- en: '[PRE910]'
  id: totrans-2093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE910]'
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个新的数组（如果可能，则指向与 *self* 相同的内存位置），但具有 *newshape* 给定的形状。如果新形状与 *self* 的步幅不兼容，则返回具有新指定形状的数组的副本。
- en: '[PRE911]'
  id: totrans-2095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE911]'
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于 [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*)，其中 *shape* 是一个序列。将 *shape* 转换为 [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims
    "PyArray_Dims") 结构，并在内部调用 [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")。为保持向后兼容性
    - 不推荐使用
- en: '[PRE912]'
  id: totrans-2097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE912]'
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于 [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*)。返回 *self* 的一个新的视图，其中已删除所有长度为 1 的维度。
- en: Warning
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象始终是二维的。因此，对于矩阵子类的数组，[`PyArray_Squeeze`](#c.PyArray_Squeeze "PyArray_Squeeze")
    没有任何效果。
- en: '[PRE913]'
  id: totrans-2101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE913]'
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*)。返回的数组是* self*中给定轴*a1*和*a2*互换后的数据的新视图。
- en: '[PRE914]'
  id: totrans-2103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE914]'
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    )。此函数仅适用于单一片段的数组。它会在原地改变*self*的形状，并且如果*newshape*的总元素数与旧形状不同，则会重新分配*self*的内存。如果需要重新分配，则*self*必须拥有其数据，*self*
    - `>base==NULL`，*self* - `>weakrefs==NULL`，而且（除非refcheck为0）不能被任何其他数组引用。fortran参数可以是[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")、[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")或[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")。目前它没有任何效果。最终它可以用来确定重塑操作在构造不同尺寸数组时应如何查看数据。成功时返回None，出错时返回NULL。
- en: '[PRE915]'
  id: totrans-2105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE915]'
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*)。根据数据结构*permute*对ndarray对象*self*的轴进行置换，并返回结果。如果*permute*为`NULL`，则结果数组的轴将被颠倒。例如，如果*self*的形状为\(10\times20\times30\)，*permute*`.ptr`为（0,2,1），则结果的形状为\(10\times30\times20\)。如果*permute*为`NULL`，结果的形状为\(30\times20\times10\)。
- en: '[PRE916]'
  id: totrans-2107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE916]'
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*)。返回数组的1维拷贝。如果*order*为[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER")，元素按Fortran顺序扫描（第一维变化最快）。如果*order*为[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")，则`self`的元素按C顺序扫描（最后一维变化最快）。如果*order*为[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")，则使用[`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN")
    (*self*)的结果来确定要展平的顺序。
- en: '[PRE917]'
  id: totrans-2109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE917]'
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于*self*.ravel(*order*)。与[`PyArray_Flatten`](#c.PyArray_Flatten "PyArray_Flatten")
    (*self*, *order*)具有相同的基本功能，除非*order*为0且*self*是C风格连续的，形状会改变但不会进行复制。
- en: Item selection and manipulation
  id: totrans-2111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目选择和操作
- en: '[PRE918]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE918]'
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*)，在Python中除了*axis*
    =None是通过在C中设置*axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") 而获得的。沿着给定的*axis*提取由整数值*indices*指示的*self*中的项目。*clipmode*参数可以是[`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE")、[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP")或[`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP")，表示对超出边界索引该怎么办。*ret*参数可以指定一个输出数组而不是在内部创建一个。
- en: '[PRE919]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE919]'
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于*self*.put(*values*, *indices*, *clipmode* )。在相应的（扁平化的）*indices*中将*values*放入*self*。如果*values*太小，则将根据需要重复。
- en: '[PRE920]'
  id: totrans-2116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE920]'
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*mask*为真的相应位置（使用扁平化的上下文）中将*values*放入*self*。 *mask*和*self*数组必须具有相同数量的元素。如果*values*太小，将根据需要重复。
- en: '[PRE921]'
  id: totrans-2118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE921]'
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*)。沿着给定的*axis*复制*self*的元素*op*次。 *op*可以是标量整数或与长度*self*->dimensions[*axis*]相同的长度序列，指示沿着该轴重复每个项目的次数。
- en: '[PRE922]'
  id: totrans-2120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE922]'
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*)。根据*self*中的整数值从*op*的数组序列中选择元素创建一个新的数组。这些数组必须都能广播到相同的形状，并且*self*中的条目应在0和len(*op*)之间。除非*ret*为`NULL`，否则输出将放在*ret*中，在这种情况下将创建一个新的输出。*clipmode*参数确定当*self*中的条目不在0和len(*op*)之间时的行为。
- en: '[PRE923]'
  id: totrans-2122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE923]'
- en: raise a ValueError;
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出一个 ValueError；
- en: '[PRE924]'
  id: totrans-2124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE924]'
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加len(*op*)将小于0的值进行包裹，并通过减去len(*op*)使大于等于len(*op*)的值在范围内；
- en: '[PRE925]'
  id: totrans-2126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE925]'
- en: all values are clipped to the region [0, len(*op*) ).
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值被剪切到区间[0, len(*op*) )内。
- en: '[PRE926]'
  id: totrans-2128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE926]'
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于[`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*)。沿着*axis*对*self*的项目进行排序并返回一个数组。该数组使用由*kind*表示的算法进行排序，*kind*是一个指向使用的排序算法类型的整数/枚举。
- en: '[PRE927]'
  id: totrans-2130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE927]'
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort")（*self*, *axis*）。返回一个索引数组，以便沿着给定的[`axis`](../generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") 选择这些索引将返回*sefl*的排序版本。如果*self*->descr 是一个已定义字段的数据类型，则会使用self->descr->names
    来确定排序顺序。当第一个字段相等时，将使用第二个字段，依此类推。要更改结构化数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型的视图构造数组。
- en: '[PRE928]'
  id: totrans-2132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE928]'
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有相同形状的数组序列(*sort_keys*)，返回一个索引数组（类似于[`PyArray_ArgSort`](#c.PyArray_ArgSort
    "PyArray_ArgSort")（…）），该数组按字典顺序对数组进行排序。字典排序指出，当两个键被发现相等时，顺序是基于后续键的比较。需要为类型定义一个合并排序（使相等条目不动）。通过首先使用第一个*sort_key*对索引进行排序，然后使用第二个*sort_key*等等来完成排序。这等效于
    Python 命令 lexsort(*sort_keys*, *axis*)。由于合并排序的工作方式，务必了解必须对*sort_keys*进行的排序顺序（与比较两个元素时使用的顺序相反）。
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数组都集成在一个结构化数组中，那么[`PyArray_Sort`](#c.PyArray_Sort "PyArray_Sort")（…）也可以用于直接对数组进行排序。
- en: '[PRE929]'
  id: totrans-2135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE929]'
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted")（*self*, *values*, *side*, *perm*）。假设*self*是按升序排列的
    1 维数组，则输出是一个与*values*相同形状的索引数组，以便如果*values*中的元素在这些索引之前插入，则*self* 的顺序将被保留。不会检查*self*
    是否按升序排列。
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: '*side* 参数指示返回的索引是第一个合适位置的（如果是[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")）还是最后一个的（如果是[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）。'
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: '*sorter* 参数，如果不是`NULL`，必须是一个与*self*长度相同的整数索引的 1D 数组，用于将其按升序排序。这通常是由调用[`PyArray_ArgSort`](#c.PyArray_ArgSort
    "PyArray_ArgSort")（…）而得到的结果。使用二分搜索来找到必要的插入点。'
- en: '[PRE930]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE930]'
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). 对数组进行分区，使得索引为*ktharray*的元素的值处于数组完全排序时的位置，并将所有小于第kth个元素的元素放在之前，所有相等或大于第kth个元素的元素放在之后。分区内所有元素的排序是未定义的。如果*self*->descr是一个有定义字段的数据类型，那么self->descr->names会用来确定排序顺序。当第一个字段相等时，将使用第二个字段，以此类推。要更改结构化数组的排序顺序，可以创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。成功返回零，失败返回-1。
- en: '[PRE931]'
  id: totrans-2141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE931]'
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). 返回一个索引数组，选择这些索引沿给定`axis`会返回*self*的分区版本。
- en: '[PRE932]'
  id: totrans-2143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE932]'
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). 返回由*axis1*和*axis2*定义的2-d数组的*offset*对角线。
- en: '[PRE933]'
  id: totrans-2145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE933]'
- en: New in version 1.6.
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6版中的新功能。
- en: Counts the number of non-zero elements in the array object *self*.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组对象*self*中的非零元素的数量进行计数。
- en: '[PRE934]'
  id: totrans-2148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE934]'
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). 返回选择非零元素的*self*的索引数组元组。如果(nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1,则返回单个索引数组。索引数组具有数据类型[`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP
    "NPY_INTP")。如果返回元组(nd \(\neq\) 1)，那么其长度为nd。
- en: '[PRE935]'
  id: totrans-2150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE935]'
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). 返回沿*axis*对应于*condition*中为真的元素。
- en: Calculation
  id: totrans-2152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算
- en: Tip
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现与在Python中传入`axis=None`相同的效果（将数组视为1-d数组），在`NPY_MAXDIMS`中传入[`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS")。
- en: Note
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: out参数指定了结果放在哪里。如果out为NULL，那么将创建输出数组，否则结果将放在必须是正确大小和类型的out中。即使out不为NULL，也总是返回对输出数组的新引用。如果out不为NULL，调用该例程的人有责任释放out或者会发生内存泄漏。
- en: '[PRE936]'
  id: totrans-2157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE936]'
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax")（*self*，*axis*）。返回*self*沿*axis*的最大元素的索引。
- en: '[PRE937]'
  id: totrans-2159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE937]'
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin")（*self*，*axis*）。返回*self*沿*axis*的最小元素的索引。
- en: '[PRE938]'
  id: totrans-2161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE938]'
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max "numpy.ndarray.max")（*self*，*axis*）。返回*self*沿给定*axis*的最大元素。当结果是单个元素时，返回一个numpy标量而不是ndarray。
- en: '[PRE939]'
  id: totrans-2163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE939]'
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min "numpy.ndarray.min")（*self*，*axis*）。返回*self*沿给定*axis*的最小元素。当结果是单个元素时，返回一个numpy标量而不是ndarray。
- en: '[PRE940]'
  id: totrans-2165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE940]'
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp "numpy.ndarray.ptp")（*self*，*axis*）。返回*self*沿*axis*的最大元素与*self*沿*axis*的最小元素之间的差值。当结果是单个元素时，返回一个numpy标量而不是ndarray。
- en: Note
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: rtype参数指定应执行规约的数据类型。如果数组的数据类型不足以处理输出，则这一点非常重要。默认情况下，所有整数数据类型至少比“add”和“multiply”
    ufuncs（它们构成mean、sum、cumsum、prod和cumprod函数的基础）大得多。
- en: '[PRE941]'
  id: totrans-2169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE941]'
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean")（*self*，*axis*，*rtype*）。返回沿给定*axis*的元素平均值，使用枚举类型*rtype*作为求和的数据类型。默认求和行为使用[`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE")作为*rtype*。
- en: '[PRE942]'
  id: totrans-2171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE942]'
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace")（*self*，*offset*，*axis1*，*axis2*，*rtype*）。返回对以*axis1*和*axis2*变量定义的2-d数组的*offset*对角线元素（使用*rtype*作为求和数据类型）的总和。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。
- en: '[PRE943]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE943]'
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip")（*self*，*min*，*max*）。剪辑数组*self*，使大于*max*的值固定为*max*，小于*min*的值固定为*min*。
- en: '[PRE944]'
  id: totrans-2175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE944]'
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于[`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate")（*self*）。返回*self*的复共轭。如果*self*不是复数数据类型，则返回具有引用的*self*。
- en: '[PRE945]'
  id: totrans-2177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE945]'
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*)。返回将元素四舍五入到最近小数位的数组。小数点位定义为\(10^{-\textrm{decimals}}\)位，因此负数*decimals*会导致四舍五入到最近的10、100等。如果out为`NULL`，则创建输出数组，否则将输出放置在*out*中，其必须是正确的大小和类型。
- en: '[PRE946]'
  id: totrans-2179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE946]'
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std "numpy.ndarray.std")
    (*self*, *axis*, *rtype*)。使用沿着*axis*转换为数据类型*rtype*的数据返回标准差。
- en: '[PRE947]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE947]'
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum "numpy.ndarray.sum")
    (*self*, *axis*, *rtype*)。返回在*axis*沿着*self*的元素中的1-d矢量和。在将数据转换为数据类型*rtype*后执行求和。
- en: '[PRE948]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE948]'
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*)。返回*self*沿*axis*的累积1-d元素和。在将数据转换为数据类型*rtype*后执行求和。
- en: '[PRE949]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE949]'
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*)。返回在*axis*沿着*self*的元素中的1-d积。在将数据转换为数据类型*rtype*后执行积。
- en: '[PRE950]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE950]'
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*)。返回1-d `self`中沿着`axis`的元素的累积乘积。在将数据转换为数据类型`rtype`后执行乘积。
- en: '[PRE951]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE951]'
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all "numpy.ndarray.all")
    (*self*, *axis*)。对于由*axis*定义的`self`的每个 1-d 子数组，返回一个包含True元素的数组，其中所有元素都为True。
- en: '[PRE952]'
  id: totrans-2191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE952]'
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 等效于[`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any "numpy.ndarray.any")
    (*self*, *axis*)。对于由*axis*定义的*self*的每个 1-d 子数组，返回一个包含True元素的数组，其中任何元素为True。
- en: Functions
  id: totrans-2193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: Array Functions
  id: totrans-2194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组函数
- en: '[PRE953]'
  id: totrans-2195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE953]'
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，以C风格的多维数组的方式访问多维数组是有用的，以便可以使用C的a[i][j][k]语法来实现算法。该例程返回一个指针*ptr*，模拟这种C风格数组的方式，用于
    1-、2- 和 3-d ndarrays。
- en: 'Parameters:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  id: totrans-2198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op** – 任何Python对象的地址。该Python对象将被替换为一个等价的，行为良好的，C风格连续的ndarray，其数据类型由最后两个参数指定。请确保以这种方式窃取输入对象的引用是合理的。'
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  id: totrans-2199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ptr** - （针对1维，2维或3维分别为ctype*，ctype**或ctype***）变量的地址，其中ctype是数据类型的等效C类型。返回时，*ptr*将作为1维、2维或3维数组的地址。'
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  id: totrans-2200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dims** - 一个包含数组对象形状的输出数组。这个数组给出了任何循环的边界。'
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  id: totrans-2201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nd** - 数组的维数（1、2或3）。'
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  id: totrans-2202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**typedescr** - 一个 [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") 结构，指示所需的数据类型（包括所需的字节顺序）。调用会窃取参数的引用。'
- en: Note
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2维和3维数组，C风格数组的模拟并不完整。例如，无法将模拟的指针数组传递给需要特定、静态定义的2维和3维数组的子例程。要传递给需要这种输入的函数，必须静态定义所需的数组并复制数据。
- en: '[PRE954]'
  id: totrans-2205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE954]'
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用从[`PyArray_AsCArray`](#c.PyArray_AsCArray "PyArray_AsCArray")（…）返回的相同对象和内存位置调用此函数。该函数会清理否则可能会泄漏的内存。
- en: '[PRE955]'
  id: totrans-2207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE955]'
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着*axis*连接*obj*中的对象序列成为单个数组。如果维度或类型不兼容，则会引发错误。
- en: '[PRE956]'
  id: totrans-2209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE956]'
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 在*obj1*和*obj2*的最后维度上计算一个乘积和。两个数组都不是共轭的。
- en: '[PRE957]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE957]'
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 在*obj1*的最后维度和*obj2*的倒数第二个维度上计算一个乘积和。对于2维数组，这是一个矩阵乘积。两个数组都不是共轭的。
- en: '[PRE958]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE958]'
- en: New in version 1.6.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6版中的新增功能。
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyArray_MatrixProduct相同，但将结果存储在*out*中。输出数组必须具有正确的形状、类型，并且是C连续的，否则会引发异常。
- en: '[PRE959]'
  id: totrans-2216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE959]'
- en: New in version 1.6.
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 1.6版中的新增内容。
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 将爱因斯坦求和约定应用于提供的数组操作数，返回一个新数组或将结果放在*out*中。 *subscripts*中的字符串是索引字母的逗号分隔列表。操作数的数量为*nop*，*op_in*是包含这些操作数的数组。可以通过*dtype*强制输出的数据类型，可以通过*order*强制输出顺序（建议使用[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")），并且在指定*dtype*时，*casting*表示数据转换应有多大宽松度。
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请参见[`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")函数。
- en: '[PRE960]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE960]'
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于2维数组的专用复制和转置函数。返回的数组是*op*的转置副本。
- en: '[PRE961]'
  id: totrans-2222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE961]'
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 1 维数组 *op1* 和 *op2* 的 1 维相关性。通过将 *op1* 乘以 *op2* 的位移版本并将结果相加来计算每个输出点的相关性。由于位移，*op1*
    和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少位移：0 - 仅返回不需要假设零值的位移；1 - 返回与 *op1* 大小相同的对象；2
    - 返回所有可能的位移（任何重叠都被接受）。
- en: Notes
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是计算通常的相关性：如果 op2 大于 op1，则交换参数，并且对复数数组不进行共轭。参见 PyArray_Correlate2 以获得通常的信号处理相关性。
- en: '[PRE962]'
  id: totrans-2226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE962]'
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: PyArray_Correlate 的更新版本，使用了 1 维数组的常规相关性定义。通过将 *op1* 乘以 *op2* 的位移版本并将结果相加来计算每个输出点的相关性。由于位移，*op1*
    和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少位移：0 - 仅返回不需要假设零值的位移；1 - 返回与 *op1* 大小相同的对象；2
    - 返回所有可能的位移（任何重叠都被接受）。
- en: Notes
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记
- en: 'Compute z as follows:'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 将 z 计算如下：
- en: '[PRE963]'
  id: totrans-2230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE963]'
- en: '[PRE964]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE964]'
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 和 `y` 都是 `NULL`，则返回 [`PyArray_Nonzero`](#c.PyArray_Nonzero "PyArray_Nonzero")（*condition*）。否则，必须提供
    *x* 和 *y*，返回的对象的形状类似 *condition*，并且具有 *x* 和 *y* 的元素，*condition* 分别是 True 或 False。
- en: Other functions
  id: totrans-2233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他函数
- en: '[PRE965]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE965]'
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 *newstrides* 是否是与形状 `dims`、元素大小 *elsize* 和内存一致的 *nd* 维数组的跨度数组。将检查 *newstrides*
    数组以查看每个方向跳过提供的字节数是否会导致跳过超过 *numbytes*，*numbytes* 是假定的可用内存段的大小。如果 *numbytes* 为
    0，则假定 *nd*、*dims* 和 *elsize* 指的是单个段的数组，如果 *newstrides* 可接受，则返回[`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE")，否则返回[`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE")。
- en: '[PRE966]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE966]'
- en: '[PRE967]'
  id: totrans-2237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE967]'
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例程都是将长度为 *n* 的整数数组 *seq* 相乘并返回结果。不执行溢出检查。
- en: '[PRE968]'
  id: totrans-2239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE968]'
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个长度为 *n* 的整数数组 *l1* 和 *l2*，如果列表相同，则返回 1；否则返回 0。
- en: Array Functions
  id: totrans-2241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组函数
- en: '[PRE969]'
  id: totrans-2242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE969]'
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，以 C 风格的多维数组形式访问多维数组是有用的，以便可以使用 C 的 a[i][j][k] 语法来实现算法。此例程返回一个指针，*ptr*，它模拟这种
    C 风格数组，用于 1 维、2 维和 3 维 ndarray。
- en: 'Parameters:'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  id: totrans-2245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**op** – Python对象的地址。此Python对象将被替换为等效的、C风格的连续ndarray的地址，其数据类型由最后两个参数指定。确保以这种方式偷窃输入对象的引用是合理的。'
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  id: totrans-2246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ptr** – 指向变量（1-d用ctype*，2-d用ctype**，3-d用ctype***）的地址，其中ctype是数据类型的等效C类型。返回时，*ptr*
    将作为1-d、2-d或3-d数组可寻址。'
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  id: totrans-2247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dims** – 一个包含数组对象形状的输出数组。此数组给出任何将发生的循环的边界。'
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  id: totrans-2248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nd** – 数组的维数（1、2或3）。'
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  id: totrans-2249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**typedescr** – 一个[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") 结构，指示所需的数据类型（包括所需的字节顺序）。调用将偷取参数的引用。'
- en: Note
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于2维和3维数组，C风格数组的模拟不完整。例如，模拟的指针数组不能传递给期望特定的静态定义的2维和3维数组的子程序。要传递给需要这种输入的函数，必须静态定义所需的数组并复制数据。
- en: '[PRE970]'
  id: totrans-2252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE970]'
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 必须使用从[`PyArray_AsCArray`](#c.PyArray_AsCArray "PyArray_AsCArray")返回的相同对象和内存位置来调用（...）。该函数会清理否则将泄漏的内存。
- en: '[PRE971]'
  id: totrans-2254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE971]'
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着 *axis* 将 *obj* 中的对象序列连接成一个单一的数组。如果维度或类型不兼容，将引发错误。
- en: '[PRE972]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE972]'
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *obj1* 和 *obj2* 的最后一维进行产品和求和。两个数组都不是共轭的。
- en: '[PRE973]'
  id: totrans-2258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE973]'
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *obj1* 的最后一维和 *obj2* 的倒数第二维进行产品和求和。对于2维数组，这是一个矩阵乘积。两个数组都不是共轭的。
- en: '[PRE974]'
  id: totrans-2260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE974]'
- en: New in version 1.6.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.6中的新内容。
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyArray_MatrixProduct相同，但是将结果存储在 *out* 中。输出数组必须具有正确的形状、类型，并且是C连续的，否则会引发异常。
- en: '[PRE975]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE975]'
- en: New in version 1.6.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.6中的新内容。
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 对提供的数组操作数应用爱因斯坦求和约定，返回一个新数组或将结果放置在 *out* 中。 *subscripts* 中的字符串是逗号分隔的索引字母列表。操作数的数量在
    *nop* 中，*op_in* 是一个包含这些操作数的数组。可以使用 *dtype* 强制输出的数据类型，可以使用 *order* 强制输出的顺序（建议使用[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER")），当指定 *dtype* 时，*casting* 指示数据转换应该有多宽容。
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参见[`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    函数。
- en: '[PRE976]'
  id: totrans-2267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE976]'
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: 仅适用于2维数组的专用复制和转置函数。返回的数组是 *op* 的转置副本。
- en: '[PRE977]'
  id: totrans-2269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE977]'
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 1-d 数组 *op1* 和 *op2* 的 1-d 相关性。每个输出点的相关性是通过将 *op1* 乘以 *op2* 的一个偏移版本并对结果进行求和来计算的。由于偏移，需要的值超出了
    *op1* 和 *op2* 的定义范围被解释为零。模式确定要返回多少个偏移量：0 - 仅返回不需要假定零值的偏移；1 - 返回与 *op1* 相同大小的对象；2
    - 返回所有可能的偏移量（接受任何重叠）。
- en: Notes
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是计算常规相关性的方法：如果 op2 大于 op1，则交换参数，并且复数数组不需要取共轭。详见 PyArray_Correlate2 获取常规信号处理的相关性。
- en: '[PRE978]'
  id: totrans-2273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE978]'
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: PyArray_Correlate 的更新版本，使用了 1d 数组的常规相关性定义。每个输出点的相关性是通过将 *op1* 乘以 *op2* 的一个偏移版本并对结果进行求和来计算的。由于偏移，需要的值超出了
    *op1* 和 *op2* 的定义范围被解释为零。模式确定要返回多少个偏移量：0 - 仅返回不需要假定零值的偏移；1 - 返回与 *op1* 相同大小的对象；2
    - 返回所有可能的偏移量（接受任何重叠）。
- en: Notes
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Compute z as follows:'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 z 如下所示：
- en: '[PRE979]'
  id: totrans-2277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE979]'
- en: '[PRE980]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE980]'
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 和 `y` 都是 `NULL`，则返回 [`PyArray_Nonzero`](#c.PyArray_Nonzero "PyArray_Nonzero")
    (*condition*)。否则，必须提供 *x* 和 *y*，并且返回的对象的形状与 *condition* 相同，并且在*condition* 分别为真和假时，返回
    *x* 和 *y* 的元素。
- en: Other functions
  id: totrans-2280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他函数
- en: '[PRE981]'
  id: totrans-2281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE981]'
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 确定 *newstrides* 是否是与形状 `dims` 和元素大小 *elsize* 相对应的内存中 *nd* 维数组的偏移数组。将检查 *newstrides*
    数组以查看每个方向按提供的字节数跳跃是否意味着跳跃超过假定的可用内存段的大小 *numbytes*。如果 *numbytes* 为 0，则假定 *nd*、*dims*
    和 *elsize* 指的是单段数组。如果 *newstrides* 可接受，则返回 [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")，否则返回
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE")。
- en: '[PRE982]'
  id: totrans-2283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE982]'
- en: '[PRE983]'
  id: totrans-2284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE983]'
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例程都会将整数数组 *seq* 的 *n* 长度相乘并返回结果。不进行溢出检查。
- en: '[PRE984]'
  id: totrans-2286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE984]'
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个 *n* 长度的整数数组 *l1* 和 *l2*，如果列表相同则返回 1；否则返回 0。
- en: Auxiliary Data With Object Semantics
  id: totrans-2288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有对象语义辅助数据
- en: New in version 1.7.0.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.7.0 中的新内容。
- en: '[PRE985]'
  id: totrans-2290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE985]'
- en: When working with more complex dtypes which are composed of other dtypes, such
    as the struct dtype, creating inner loops that manipulate the dtypes requires
    carrying along additional data. NumPy supports this idea through a struct [`NpyAuxData`](#c.NpyAuxData
    "NpyAuxData"), mandating a few conventions so that it is possible to do this.
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理由其他数据类型组成的更复杂的数据类型时（比如结构化数据类型），创建操作数据类型的内部循环需要携带额外的数据。NumPy通过结构 [`NpyAuxData`](#c.NpyAuxData
    "NpyAuxData") 来支持这个想法，并通过一些约定来实现这一点。
- en: Defining an [`NpyAuxData`](#c.NpyAuxData "NpyAuxData") is similar to defining
    a class in C++, but the object semantics have to be tracked manually since the
    API is in C. Here’s an example for a function which doubles up an element using
    an element copier function as a primitive.
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个[`NpyAuxData`](#c.NpyAuxData "NpyAuxData")类似于在C++中定义类，但由于API是C语言，需要手动跟踪对象语义。以下是一个使用元素复制函数作为原语实现元素翻倍的函数的示例。
- en: '[PRE986]'
  id: totrans-2293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE986]'
- en: '[PRE987]'
  id: totrans-2294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE987]'
- en: The function pointer type for NpyAuxData free functions.
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 用于NpyAuxData自由函数的函数指针类型。
- en: '[PRE988]'
  id: totrans-2296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE988]'
- en: The function pointer type for NpyAuxData clone functions. These functions should
    never set the Python exception on error, because they may be called from a multi-threaded
    context.
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 用于NpyAuxData克隆函数的函数指针类型。这些函数在发生错误时不应该设置Python异常，因为它们可能会从多线程上下文中调用。
- en: '[PRE989]'
  id: totrans-2298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE989]'
- en: A macro which calls the auxdata’s free function appropriately, does nothing
    if auxdata is NULL.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 适当调用auxdata的释放函数的宏，如果auxdata为NULL，则什么也不做。
- en: '[PRE990]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE990]'
- en: A macro which calls the auxdata’s clone function appropriately, returning a
    deep copy of the auxiliary data.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 适当调用auxdata的克隆函数的宏，返回辅助数据的深层副本。
- en: Array Iterators
  id: totrans-2302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组迭代器
- en: As of NumPy 1.6.0, these array iterators are superseded by the new array iterator,
    [`NpyIter`](iterator.html#c.NpyIter "NpyIter").
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 从NumPy 1.6.0开始，这些数组迭代器被新的数组迭代器[`NpyIter`](iterator.html#c.NpyIter "NpyIter")取代。
- en: An array iterator is a simple way to access the elements of an N-dimensional
    array quickly and efficiently, as seen in [the example](iterator.html#iteration-example)
    which provides more description of this useful approach to looping over an array
    from C.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组迭代器是一种快速高效地访问N维数组元素的简单方法，可以在[示例](iterator.html#iteration-example)中看到更多关于这种循环数组的有用方法的描述。
- en: '[PRE991]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE991]'
- en: Return an array iterator object from the array, *arr*. This is equivalent to
    *arr*. **flat**. The array iterator object makes it easy to loop over an N-dimensional
    non-contiguous array in C-style contiguous fashion.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组*arr*返回一个数组迭代器对象。这等同于*arr*。**flat**。数组迭代器对象使在C风格连续方式下轻松循环遍历N维非连续数组成为可能。
- en: '[PRE992]'
  id: totrans-2307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE992]'
- en: Return an array iterator that will iterate over all axes but the one provided
    in **axis*. The returned iterator cannot be used with [`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D"). This iterator could be used to write something similar
    to what ufuncs do wherein the loop over the largest axis is done by a separate
    sub-routine. If **axis* is negative then **axis* will be set to the axis having
    the smallest stride and that axis will be used.
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个数组迭代器，该迭代器将在除了**axis*以外的所有轴上迭代。返回的迭代器不能使用[`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D")。此迭代器可用于编写类似于ufuncs的内容，其中在最大轴上的循环由一个单独的子例程完成。如果**axis*为负数，则将**axis*设置为具有最小步幅的轴，并使用该轴。
- en: '[PRE993]'
  id: totrans-2309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE993]'
- en: Return an array iterator that is broadcast to iterate as an array of the shape
    provided by *dimensions* and *nd*.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个广播到由*dimensions*和*nd*提供的形状的数组迭代器对象。
- en: '[PRE994]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE994]'
- en: Evaluates true if *op* is an array iterator (or instance of a subclass of the
    array iterator type).
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*op*是数组迭代器（或数组迭代器类型的子类的实例），则评估为True。
- en: '[PRE995]'
  id: totrans-2313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE995]'
- en: Reset an *iterator* to the beginning of the array.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*重置为数组的开头。
- en: '[PRE996]'
  id: totrans-2315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE996]'
- en: Incremement the index and the dataptr members of the *iterator* to point to
    the next element of the array. If the array is not (C-style) contiguous, also
    increment the N-dimensional coordinates array.
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: 增加*iterator*的索引和dataptr成员以指向数组的下一个元素。如果数组不是（C风格）连续的，则还要增加N维坐标数组。
- en: '[PRE997]'
  id: totrans-2317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE997]'
- en: A pointer to the current element of the array.
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的当前元素的指针。
- en: '[PRE998]'
  id: totrans-2319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE998]'
- en: Set the *iterator* index, dataptr, and coordinates members to the location in
    the array indicated by the N-dimensional c-array, *destination*, which must have
    size at least *iterator* ->nd_m1+1.
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*的索引、dataptr和坐标成员设置为N维c数组*destination*指示的数组中的位置，该数组的大小至少为*iterator*
    ->nd_m1+1。
- en: '[PRE999]'
  id: totrans-2321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE999]'
- en: Set the *iterator* index and dataptr to the location in the array indicated
    by the integer *index* which points to an element in the C-styled flattened array.
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 将*iterator*的索引和dataptr设置为整数*index*指示的位置，在C风格的扁平化数组中指向一个元素。
- en: '[PRE1000]'
  id: totrans-2323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1000]'
- en: Evaluates TRUE as long as the iterator has not looped through all of the elements,
    otherwise it evaluates FALSE.
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 只要迭代器尚未循环遍历所有元素，就评估为True，否则评估为False。
- en: Broadcasting (multi-iterators)
  id: totrans-2325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播（多个迭代器）
- en: '[PRE1001]'
  id: totrans-2326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1001]'
- en: A simplified interface to broadcasting. This function takes the number of arrays
    to broadcast and then *num* extra ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)") ) arguments. These arguments are converted to arrays and
    iterators are created. [`PyArray_Broadcast`](#c.PyArray_Broadcast "PyArray_Broadcast")
    is then called on the resulting multi-iterator object. The resulting, broadcasted
    mult-iterator object is then returned. A broadcasted operation can then be performed
    using a single loop and using [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简化的广播接口。这个函数接受要广播的数组数量，以及 *num* 个额外（[`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(在 Python v3.11 中)") ）参数。这些参数被转换为数组，并创建迭代器。然后在生成的多迭代器对象上调用 [`PyArray_Broadcast`](#c.PyArray_Broadcast
    "PyArray_Broadcast")。然后返回生成的广播多迭代器对象。然后可以使用单个循环执行广播操作，并使用 [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)。
- en: '[PRE1002]'
  id: totrans-2328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1002]'
- en: Reset all the iterators to the beginning in a multi-iterator object, *multi*.
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 重置多迭代器对象 *multi* 中的所有迭代器到开头。
- en: '[PRE1003]'
  id: totrans-2330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1003]'
- en: Advance each iterator in a multi-iterator object, *multi*, to its next (broadcasted)
    element.
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到其下一个（广播的）元素。
- en: '[PRE1004]'
  id: totrans-2332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1004]'
- en: Return the data-pointer of the *i* \(^{\textrm{th}}\) iterator in a multi-iterator
    object.
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多迭代器对象中第 *i*（^{\textrm{th}}）个迭代器的数据指针。
- en: '[PRE1005]'
  id: totrans-2334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1005]'
- en: Advance the pointer of only the *i* \(^{\textrm{th}}\) iterator.
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 只推进第 *i*（^{\textrm{th}}）个迭代器的指针。
- en: '[PRE1006]'
  id: totrans-2336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1006]'
- en: Advance each iterator in a multi-iterator object, *multi*, to the given \(N\)
    -dimensional *destination* where \(N\) is the number of dimensions in the broadcasted
    array.
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到给定的 \(N\) -维 *destination*，其中 \(N\) 是广播数组中的维数。
- en: '[PRE1007]'
  id: totrans-2338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1007]'
- en: Advance each iterator in a multi-iterator object, *multi*, to the corresponding
    location of the *index* into the flattened broadcasted array.
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 将多迭代器对象 *multi* 中的每个迭代器推进到展平广播数组的 *index* 对应位置。
- en: '[PRE1008]'
  id: totrans-2340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1008]'
- en: Evaluates TRUE as long as the multi-iterator has not looped through all of the
    elements (of the broadcasted result), otherwise it evaluates FALSE.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: 只要多迭代器尚未循环完所有元素（广播结果的元素），则评估为 TRUE，否则评估为 FALSE。
- en: '[PRE1009]'
  id: totrans-2342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1009]'
- en: This function encapsulates the broadcasting rules. The *mit* container should
    already contain iterators for all the arrays that need to be broadcast. On return,
    these iterators will be adjusted so that iteration over each simultaneously will
    accomplish the broadcasting. A negative number is returned if an error occurs.
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包装了广播规则。*mit* 容器应该已经包含了需要进行广播的所有数组的迭代器。返回时，这些迭代器将被调整，以便同时对每个进行迭代完成广播。如果发生错误，则返回负数。
- en: '[PRE1010]'
  id: totrans-2344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1010]'
- en: This function takes a multi-iterator object that has been previously “broadcasted,”
    finds the dimension with the smallest “sum of strides” in the broadcasted result
    and adapts all the iterators so as not to iterate over that dimension (by effectively
    making them of length-1 in that dimension). The corresponding dimension is returned
    unless *mit* ->nd is 0, then -1 is returned. This function is useful for constructing
    ufunc-like routines that broadcast their inputs correctly and then call a strided
    1-d version of the routine as the inner-loop. This 1-d version is usually optimized
    for speed and for this reason the loop should be performed over the axis that
    won’t require large stride jumps.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受先前已经“广播”的多迭代器对象，找到在广播结果中具有最小“步幅之和”的维度，并适应所有迭代器，以便不在该维度上进行迭代（通过有效地使它们在该维度上为长度-1）。除非
    *mit* ->nd 为 0，则返回相应的维度。这个函数用于构造类似于 ufunc 的例程，正确传播其输入然后调用一个针对速度进行了优化的 strided
    1-d 版本的例程作为内循环。这个 1-d 版本通常针对速度进行了优化，因此循环应该在不需要大步跳跃的轴上执行。
- en: Neighborhood iterator
  id: totrans-2346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻域迭代器
- en: New in version 1.4.0.
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4.0 中新增。
- en: Neighborhood iterators are subclasses of the iterator object, and can be used
    to iter over a neighborhood of a point. For example, you may want to iterate over
    every voxel of a 3d image, and for every such voxel, iterate over an hypercube.
    Neighborhood iterator automatically handle boundaries, thus making this kind of
    code much easier to write than manual boundaries handling, at the cost of a slight
    overhead.
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 邻域迭代器是迭代器对象的子类，可用于迭代点的邻域。例如，您可能希望遍历 3d 图像的每个体素，并对每个这样的体素遍历一个超立方体。邻域迭代器自动处理边界，因此使得编写这种代码比手动处理边界更容易，代价是稍微增加一些开销。
- en: '[PRE1011]'
  id: totrans-2349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1011]'
- en: This function creates a new neighborhood iterator from an existing iterator.
    The neighborhood will be computed relatively to the position currently pointed
    by *iter*, the bounds define the shape of the neighborhood iterator, and the mode
    argument the boundaries handling mode.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从现有迭代器创建一个新的邻域迭代器。邻域将相对于 *iter* 当前指向的位置计算，bounds 定义了邻域迭代器的形状，mode 参数定义了边界处理模式。
- en: The *bounds* argument is expected to be a (2 * iter->ao->nd) arrays, such as
    the range bound[2*i]->bounds[2*i+1] defines the range where to walk for dimension
    i (both bounds are included in the walked coordinates). The bounds should be ordered
    for each dimension (bounds[2*i] <= bounds[2*i+1]).
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: '*bounds* 参数应为一个 (2 * iter->ao->nd) 数组，例如范围 bound[2*i]->bounds[2*i+1] 定义了在维度
    i 上遍历的范围（这两个边界都包含在遍历的坐标中）。边界应对每个维度进行排序（bounds[2*i] <= bounds[2*i+1]）。'
- en: 'The mode should be one of:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
  zh: 模式应为以下之一：
- en: '[PRE1012]'
  id: totrans-2353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1012]'
- en: Zero padding. Outside bounds values will be 0.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 零填充。超出边界的值将为 0。
- en: '[PRE1013]'
  id: totrans-2355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1013]'
- en: One padding, Outside bounds values will be 1.
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 单个填充，超出边界的值将为 1。
- en: '[PRE1014]'
  id: totrans-2357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1014]'
- en: Constant padding. Outside bounds values will be the same as the first item in
    fill_value.
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
  zh: 常量填充。超出边界的值将与 fill_value 中的第一个项目相同。
- en: '[PRE1015]'
  id: totrans-2359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1015]'
- en: Mirror padding. Outside bounds values will be as if the array items were mirrored.
    For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will be 1, x[4]
    will be 4, x[5] will be 1, etc…
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像填充。超出边界的值将如同数组项被镜像一样。例如，对于数组 [1, 2, 3, 4]，x[-2] 将为 2，x[-2] 将为 1，x[4] 将为 4，x[5]
    将为 1，等等...
- en: '[PRE1016]'
  id: totrans-2361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1016]'
- en: Circular padding. Outside bounds values will be as if the array was repeated.
    For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4]
    will be 1, x[5] will be 2, etc…
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 循环填充。超出边界的值将如同数组被重复一样。例如，对于数组 [1, 2, 3, 4]，x[-2] 将为 3，x[-2] 将为 4，x[4] 将为 1，x[5]
    将为 2，等等...
- en: If the mode is constant filling (*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*),
    fill_value should point to an array object which holds the filling value (the
    first item will be the filling value if the array contains more than one item).
    For other cases, fill_value may be NULL.
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式为常量填充（*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*），则 fill_value 应指向一个包含填充值的数组对象（如果数组包含多个项，则第一项将是填充值）。对于其他情况，fill_value
    可能为 NULL。
- en: The iterator holds a reference to iter
  id: totrans-2364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器持有对 iter 的引用
- en: Return NULL on failure (in which case the reference count of iter is not changed)
  id: totrans-2365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时返回 NULL（在此情况下，iter 的引用计数不会更改）
- en: 'iter itself can be a Neighborhood iterator: this can be useful for .e.g automatic
    boundaries handling'
  id: totrans-2366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iter 本身可以是邻域迭代器：这对于例如自动边界处理很有用
- en: the object returned by this function should be safe to use as a normal iterator
  id: totrans-2367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数返回的对象应安全用作普通迭代器
- en: If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next
    is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.
  id: totrans-2368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果更改了 iter 的位置，则后续对 PyArrayNeighborhoodIter_Next 的任何调用都是未定义行为，并且必须调用 PyArrayNeighborhoodIter_Reset。
- en: If the position of iter is not the beginning of the data and the underlying
    data for iter is contiguous, the iterator will point to the start of the data
    instead of position pointed by iter. To avoid this situation, iter should be moved
    to the required position only after the creation of iterator, and PyArrayNeighborhoodIter_Reset
    must be called.
  id: totrans-2369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 iter 的位置不是数据的开头且 iter 的底层数据是连续的，则迭代器将指向数据的开头而不是 iter 指向的位置。为避免此情况，应在迭代器创建后仅将
    iter 移动到所需位置，并且必须调用 PyArrayNeighborhoodIter_Reset。
- en: '[PRE1017]'
  id: totrans-2370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1017]'
- en: '[PRE1018]'
  id: totrans-2371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1018]'
- en: Reset the iterator position to the first point of the neighborhood. This should
    be called whenever the iter argument given at PyArray_NeighborhoodIterObject is
    changed (see example)
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器位置重置为邻域的第一个点。每当在 PyArray_NeighborhoodIterObject 中给出 iter 参数被更改时应调用此函数（见示例）
- en: '[PRE1019]'
  id: totrans-2373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1019]'
- en: After this call, iter->dataptr points to the next point of the neighborhood.
    Calling this function after every point of the neighborhood has been visited is
    undefined.
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用后，iter->dataptr 指向邻域的下一个点。在访问完邻域的每个点后调用此函数是未定义的。
- en: Array mapping
  id: totrans-2375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组映射
- en: Array mapping is the machinery behind advanced indexing.
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
  zh: 数组映射是高级索引背后的机制。
- en: '[PRE1020]'
  id: totrans-2377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1020]'
- en: Use advanced indexing to iterate an array.
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级索引来迭代数组。
- en: '[PRE1021]'
  id: totrans-2379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1021]'
- en: 'Swap the axes to or from their inserted form. `MapIter` always puts the advanced
    (array) indices first in the iteration. But if they are consecutive, it will insert/transpose
    them back before returning. This is stored as `mit->consec != 0` (the place where
    they are inserted). For assignments, the opposite happens: the values to be assigned
    are transposed (`getmap=1` instead of `getmap=0`). `getmap=0` and `getmap=1` undo
    the other operation.'
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: 将轴与其插入形式互换。`MapIter`始终将高级（数组）索引放在迭代中的第一位。但如果它们是连续的，则在返回之前会插入/转置它们。这存储为`mit->consec
    != 0`（它们被插入的位置）。对于赋值，相反的情况发生：要分配的值被转置（而不是`getmap=0`而是`getmap=1`）。`getmap=0`和`getmap=1`撤消另一个操作。
- en: '[PRE1022]'
  id: totrans-2381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1022]'
- en: This function needs to update the state of the map iterator and point `mit->dataptr`
    to the memory-location of the next object.
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数需要更新地图迭代器的状态，并将`mit->dataptr`指向下一个对象的内存位置。
- en: Note that this function never handles an extra operand but provides compatibility
    for an old (exposed) API.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数从不处理额外的操作数，但为旧的（公开的）API提供兼容性。
- en: '[PRE1023]'
  id: totrans-2384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1023]'
- en: Similar to [`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")
    but with an additional `copy_if_overlap` argument. If `copy_if_overlap != 0`,
    checks if `a` has memory overlap with any of the arrays in `index` and with `extra_op`,
    and make copies as appropriate to avoid problems if the input is modified during
    the iteration. `iter->array` may contain a copied array (WRITEBACKIFCOPY set).
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")类似，但增加了一个`copy_if_overlap`参数。如果`copy_if_overlap
    != 0`，则检查`a`是否与`index`中的任何数组以及`extra_op`有内存重叠，并根据需要进行复制，以避免在迭代期间修改输入时出现问题。`iter->array`可能包含一个已复制的数组（设置了WRITEBACKIFCOPY）。
- en: Array Scalars
  id: totrans-2386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组标量
- en: '[PRE1024]'
  id: totrans-2387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1024]'
- en: This function steals a reference to *arr*.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数窃取了对*arr*的引用。
- en: This function checks to see if *arr* is a 0-dimensional array and, if so, returns
    the appropriate array scalar. It should be used whenever 0-dimensional arrays
    could be returned to Python.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查*arr*是否为零维数组，并在是的情况下返回适当的数组标量。每当可能返回0维数组到Python时应使用它。
- en: '[PRE1025]'
  id: totrans-2390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1025]'
- en: Return an array scalar object of the given *dtype* by **copying** from memory
    pointed to by *data*. *base* is expected to be the array object that is the owner
    of the data. *base* is required if *dtype* is a `void` scalar, or if the `NPY_USE_GETITEM`
    flag is set and it is known that the `getitem` method uses the `arr` argument
    without checking if it is `NULL`. Otherwise *base* may be `NULL`.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从由*data*指向的内存中**复制**到指定的*dtype*的数组标量对象返回。 *base*应为拥有数据的数组对象。如果*dtype*是`void`标量，或者设置了`NPY_USE_GETITEM`标志并且已知`getitem`方法使用`arr`参数而不检查它是否为`NULL`，则需要*base*。否则，*base*可能为`NULL`。
- en: If the data is not in native byte order (as indicated by `dtype->byteorder`)
    then this function will byteswap the data, because array scalars are always in
    correct machine-byte order.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据不是本机字节顺序（由`dtype->byteorder`指示），则此函数将对数据进行字节交换，因为数组标量始终以正确的机器字节顺序排列。
- en: '[PRE1026]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1026]'
- en: Return an array scalar object of the type and itemsize indicated by the array
    object *arr* copied from the memory pointed to by *data* and swapping if the data
    in *arr* is not in machine byte-order.
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从由*data*指向的内存复制并在*arr*中的数据不是机器字节顺序时交换的类型和项目大小指示的数组标量对象。
- en: '[PRE1027]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1027]'
- en: Return a 0-dimensional array of type determined by *outcode* from *scalar* which
    should be an array-scalar object. If *outcode* is NULL, then the type is determined
    from *scalar*.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 从*scalar*（应为数组标量对象）返回由*outcode*指定类型的0维数组。如果*outcode*为NULL，则类型由*scalar*确定。
- en: '[PRE1028]'
  id: totrans-2397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1028]'
- en: Return in *ctypeptr* a pointer to the actual value in an array scalar. There
    is no error checking so *scalar* must be an array-scalar object, and ctypeptr
    must have enough space to hold the correct type. For flexible-sized types, a pointer
    to the data is copied into the memory of *ctypeptr*, for all other types, the
    actual data is copied into the address pointed to by *ctypeptr*.
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ctypeptr*中返回指向数组标量中实际值的指针。没有错误检查，因此*scalar*必须是一个数组标量对象，而*ctypeptr*必须有足够的空间来容纳正确的类型。对于可变大小的类型，将数据的指针复制到*ctypeptr*的内存中，对于所有其他类型，将实际数据复制到*ctypeptr*指向的地址中。
- en: '[PRE1029]'
  id: totrans-2399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1029]'
- en: Return the data (cast to the data type indicated by *outcode*) from the array-scalar,
    *scalar*, into the memory pointed to by *ctypeptr* (which must be large enough
    to handle the incoming memory).
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组标量*scalar*中返回数据（转换为*outcode*指示的数据类型），并复制到指向*ctypeptr*（必须足够大以处理传入内存）的内存中。
- en: '[PRE1030]'
  id: totrans-2401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1030]'
- en: Returns a scalar type-object from a type-number, *type* . Equivalent to [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj except for reference counting and error-checking.
    Returns a new reference to the typeobject on success or `NULL` on failure.
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型编号*type*返回一个标量类型对象。相当于[`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj，除了引用计数和错误检查。成功时返回对类型对象的新引用，失败时返回`NULL`。
- en: '[PRE1031]'
  id: totrans-2403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1031]'
- en: See the function [`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")
    for an alternative mechanism introduced in NumPy 1.6.0.
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看NumPy 1.6.0中引入的另一种机制的函数[`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType")。
- en: Return the kind of scalar represented by *typenum* and the array in **arr* (if
    *arr* is not `NULL` ). The array is assumed to be rank-0 and only used if *typenum*
    represents a signed integer. If *arr* is not `NULL` and the first element is negative
    then [`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR "NPY_INTNEG_SCALAR")
    is returned, otherwise [`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR") is returned. The possible return values are the enumerated
    values in [`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND").
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由*typenum*表示的标量类型和数组**arr*（如果*arr*不是`NULL`）。假定数组的秩为0，仅当*typenum*表示有符号整数时才使用该数组。如果*arr*不是`NULL`且第一个元素为负数，则返回[`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR
    "NPY_INTNEG_SCALAR")，否则返回[`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR")。可能的返回值是[`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND")中的枚举值。
- en: '[PRE1032]'
  id: totrans-2406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1032]'
- en: See the function [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")
    for details of NumPy type promotion, updated in NumPy 1.6.0.
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解NumPy类型提升的函数[`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")，在NumPy
    1.6.0中更新。
- en: Implements the rules for scalar coercion. Scalars are only silently coerced
    from thistype to neededtype if this function returns nonzero. If scalar is [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR"), then this function is equivalent to [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"). The rule is that scalars of the same KIND can be coerced
    into arrays of the same KIND. This rule means that high-precision scalars will
    never cause low-precision arrays of the same KIND to be upcast.
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 实现标量强制转换的规则。只有当此函数返回非零值时，标量才会从此类型默默转换为需要的类型。如果标量是[`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")，那么此函数相当于[`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely "PyArray_CanCastSafely")。规则是相同KIND的标量可以强制转换为相同KIND的数组。这个规则意味着高精度标量永远不会导致相同KIND的低精度数组被上升。
- en: Data-type descriptors
  id: totrans-2409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型描述符
- en: Warning
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Data-type objects must be reference counted so be aware of the action on the
    data-type reference of different C-API calls. The standard rule is that when a
    data-type object is returned it is a new reference. Functions that take [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* objects and return arrays steal references to the data-type
    their inputs unless otherwise noted. Therefore, you must own a reference to any
    data-type object used as input to such a function.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型对象必须进行引用计数，因此要注意不同的C-API调用对数据类型引用的影响。标准规则是当返回数据类型对象时，它是一个新的引用。除非另有说明，否则接受[PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")*对象并返回数组的函数会窃取其输入的数据类型的引用。因此，您必须拥有任何用作此类函数输入的数据类型对象的引用。
- en: '[PRE1033]'
  id: totrans-2412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1033]'
- en: Evaluates as true if *obj* is a data-type object ( [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* ).
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*obj*是数据类型对象（[PyArray_Descr](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")*），则评估为真。
- en: '[PRE1034]'
  id: totrans-2414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1034]'
- en: Return a new data-type object copied from *obj* (the fields reference is just
    updated so that the new object points to the same fields dictionary if any).
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 从*obj*（如果有的话，字段引用仅更新，以便新对象指向相同的字段字典）复制一个新的数据类型对象。
- en: '[PRE1035]'
  id: totrans-2416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1035]'
- en: Create a new data-type object from the built-in (or user-registered) data-type
    indicated by *typenum*. All builtin types should not have any of their fields
    changed. This creates a new copy of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure so that you can fill it in as appropriate. This function
    is especially needed for flexible data-types which need to have a new elsize member
    in order to be meaningful in array construction.
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 从由*typenum*指示的内置（或用户注册的）数据类型创建一个新的数据类型对象。所有内置类型都不应更改其任何字段。这将创建一个[`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")结构的新副本，以便您可以根据需要填充它。这个函数对于灵活的数据类型尤其需要，因为它们需要一个新的elsize成员以便在数组构造中有意义。
- en: '[PRE1036]'
  id: totrans-2418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1036]'
- en: Create a new data-type object with the byteorder set according to *newendian*.
    All referenced data-type objects (in subdescr and fields members of the data-type
    object) are also changed (recursively).
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用根据*newendian*设置字节顺序创建一个新的数据类型对象。所有引用的数据类型对象（子描述符和数据类型对象的字段成员）也会被更改（递归地）。
- en: 'The value of *newendian* is one of these macros:'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: '*newendian*的值是以下这些宏之一：'
- en: '[PRE1037]'
  id: totrans-2421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1037]'
- en: '[PRE1038]'
  id: totrans-2422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1038]'
- en: '[PRE1039]'
  id: totrans-2423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1039]'
- en: '[PRE1040]'
  id: totrans-2424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1040]'
- en: '[PRE1041]'
  id: totrans-2425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1041]'
- en: If a byteorder of [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") is encountered
    it is left alone. If newendian is [`NPY_SWAP`](#c.NPY_SWAP "NPY_SWAP"), then all
    byte-orders are swapped. Other valid newendian values are [`NPY_NATIVE`](#c.NPY_NATIVE
    "NPY_NATIVE"), [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"), and [`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG") which all cause the returned data-typed descriptor (and all it’s referenced
    data-type descriptors) to have the corresponding byte- order.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到一个[`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE")的字节顺序，则会被保留。如果newendian是[`NPY_SWAP`](#c.NPY_SWAP
    "NPY_SWAP")，则所有字节顺序都会被交换。其他有效的newendian值包括[`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")、[`NPY_LITTLE`](#c.NPY_LITTLE
    "NPY_LITTLE")和[`NPY_BIG`](#c.NPY_BIG "NPY_BIG")，它们都会导致返回的数据类型描述符（以及它引用的所有数据类型描述符）具有相应的字节顺序。
- en: '[PRE1042]'
  id: totrans-2427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1042]'
- en: Determine an appropriate data-type object from the object *op* (which should
    be a “nested” sequence object) and the minimum data-type descriptor mintype (which
    can be `NULL` ). Similar in behavior to array(*op*).dtype. Don’t confuse this
    function with [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter").
    This function essentially looks at all the objects in the (nested) sequence and
    determines the data-type from the elements it finds.
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象*op*（应该是一个“嵌套”序列对象）和最小数据类型描述符mintype（可以是`NULL`）确定合适的数据类型对象。与array(*op*).dtype的行为类似。不要将此函数与[`PyArray_DescrConverter`](#c.PyArray_DescrConverter
    "PyArray_DescrConverter")混淆。这个函数基本上查看（嵌套）序列中的所有对象，并从找到的元素中确定数据类型。
- en: '[PRE1043]'
  id: totrans-2429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1043]'
- en: Return a data-type object from an array-scalar object. No checking is done to
    be sure that *scalar* is an array scalar. If no suitable data-type can be determined,
    then a data-type of [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    is returned by default.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组标量对象返回一个数据类型对象。不检查*scalar*是否是数组标量。如果无法确定合适的数据类型，则默认返回一个[`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT")的数据类型。
- en: '[PRE1044]'
  id: totrans-2431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1044]'
- en: Returns a data-type object corresponding to *typenum*. The *typenum* can be
    one of the enumerated types, a character code for one of the enumerated types,
    or a user-defined type. If you want to use a flexible size array, then you need
    to `flexible typenum` and set the results `elsize` parameter to the desired size.
    The typenum is one of the [`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES").
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与*typenum*对应的数据类型对象。*typenum*可以是枚举类型之一，枚举类型的字符代码，或用户定义的类型。如果要使用灵活大小的数组，那么你需要`flexible
    typenum`，并将结果`elsize`参数设置为所需的大小。typenum是[`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES")之一。
- en: '[PRE1045]'
  id: totrans-2433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1045]'
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    A large number of Python objects can be converted to data-type objects. See [Data
    type objects (dtype)](../arrays.dtypes.html#arrays-dtypes) for a complete description.
    This version of the converter converts None objects to a [`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE") data-type object. This function can be used with the “O&”
    character code in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") processing.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何兼容的Python对象*obj*转换为*dtype*中的数据类型对象。许多Python对象可以转换为数据类型对象。有关完整描述，请参见[数据类型对象（dtype）](../arrays.dtypes.html#arrays-dtypes)。这个转换器的版本将None对象转换为[`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE")数据类型对象。此函数可以在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")处理中使用“O&”字符代码。
- en: '[PRE1046]'
  id: totrans-2435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1046]'
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    This version of the converter converts None objects so that the returned data-type
    is `NULL`. This function can also be used with the “O&” character in PyArg_ParseTuple
    processing.
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何兼容的Python对象*obj*转换为*dtype*中的数据类型对象。这个转换器的版本将None对象转换为`NULL`，这样返回的数据类型就是`NULL`。此函数还可以与PyArg_ParseTuple处理中的“O&”字符一起使用。
- en: '[PRE1047]'
  id: totrans-2437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1047]'
- en: Like [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")类似，但它将C结构类对象与编译器一样对齐到字边界。
- en: '[PRE1048]'
  id: totrans-2439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1048]'
- en: Like [`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")类似，不过它会像编译器一样将
    C 结构对象按照字边界对齐。
- en: '[PRE1049]'
  id: totrans-2441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1049]'
- en: Take the fields dictionary, *dict*, such as the one attached to a data-type
    object and construct an ordered-list of field names such as is stored in the names
    field of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")
    object.
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字段字典 *dict*，例如附加到数据类型对象上的字段，并构造字段名的有序列表，如存储在 [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") 对象的 names 字段中。
- en: Conversion Utilities
  id: totrans-2443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换实用程序
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  id: totrans-2444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")。
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都可以在 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) 中与“O&”格式说明符一起使用，以自动将任何 Python 对象转换为所需的 C 对象。如果成功，所有这些函数都返回
    [`NPY_SUCCEED`](#c.NPY_SUCCEED "NPY_SUCCEED")，如果失败则返回 [`NPY_FAIL`](#c.NPY_FAIL
    "NPY_FAIL")。所有这些函数的第一个参数是一个 Python 对象。第二个参数是将 Python 对象转换为的 C 类型的**address**。
- en: Warning
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 确保了解在使用这些转换函数时应该采取哪些步骤来管理内存。这些函数可能需要释放内存，和/或者根据您的使用来改变特定对象的引用计数。
- en: '[PRE1050]'
  id: totrans-2448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1050]'
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何 Python 对象转换为 [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")。如果 [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    为 TRUE，则增加其引用计数并在 *address* 中放置一个引用。如果 *obj* 不是数组，则使用 [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") 将其转换为数组。无论返回什么，你在完成后必须 DECREF 这个地址中返回的对象。
- en: '[PRE1051]'
  id: totrans-2450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1051]'
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 这是给定给函数的输出数组的默认转换器。如果 *obj* 是 [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)") 或 `NULL`，则 **address** 将是 `NULL`，但是调用会成功。如果 [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) 为 TRUE，则返回其 **address** 而不增加其引用计数。
- en: '[PRE1052]'
  id: totrans-2452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1052]'
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 将小于 [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") 的任何 Python 序列 *obj* 转换为 [`npy_intp`](dtype.html#c.npy_intp
    "npy_intp") 的 C 数组。Python 对象也可以是单个数字。*seq* 变量是一个指向具有成员 ptr 和 len 的结构体的指针。成功返回后，*seq*
    ->ptr 包含必须通过调用 [`PyDimMem_FREE`](#c.PyDimMem_FREE "PyDimMem_FREE") 来释放内存，以避免内存泄漏的内存指针。对内存大小的限制使得这个转换器可以方便地用于被视为数组形状的序列。
- en: '[PRE1053]'
  id: totrans-2454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1053]'
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何具有（单片段）缓冲区接口的Python对象*obj*转换为一个具有详细描述对象在内存块中使用的成员的变量。*buf*变量是一个指向具有base、ptr、len和flags成员的结构体指针。[`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk
    "PyArray_Chunk") 结构与Python的缓冲区对象二进制兼容（在32位平台上通过其len成员，在64位平台上通过其ptr成员）。返回时，base成员设置为*obj*（或其基础如果*obj*已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加引用计数（INCREF）base成员。内存块由*buf*->ptr成员指向，并具有长度*buf*->len。*buf*的flags成员是[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")，如果*obj*具有可写的缓冲区接口，则设置[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")标志。
- en: '[PRE1054]'
  id: totrans-2456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1054]'
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
  zh: 将表示轴参数的Python对象*obj*转换为适合传递给需要整数轴的函数的值。具体来说，如果*obj*为None，则axis设置为[`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS")，C-API函数将正确解释带轴参数的函数。
- en: '[PRE1055]'
  id: totrans-2458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1055]'
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何Python对象*obj*转换为[`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE")或[`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")，并将结果放在*value*中。
- en: '[PRE1056]'
  id: totrans-2460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1056]'
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串转换为相应的字节顺序字符：‘>’、‘<’、‘s’、‘=’或‘|’。
- en: '[PRE1057]'
  id: totrans-2462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1057]'
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串转换为[`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT "NPY_QUICKSORT")之一（以‘q’或‘Q’开头）、[`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT")之一（以‘h’或‘H’开头）、[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT")之一（以‘m’或‘M’开头）或[`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT")之一（以‘t’或‘T’开头）。[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT")和[`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")彼此别名以保持向后兼容性，并根据数据类型可能指的是几种稳定排序算法之一。
- en: '[PRE1058]'
  id: totrans-2464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1058]'
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串转换为[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT "NPY_SEARCHLEFT")之一（以‘l’或‘L’开头），或[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")之一（以‘r’或‘R’开头）。
- en: '[PRE1059]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1059]'
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串‘C’、‘F’、‘A’和‘K’转换成[`NPY_ORDER`](#c.NPY_ORDER "NPY_ORDER")枚举[`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")、[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")、[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER")和[`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")。
- en: '[PRE1060]'
  id: totrans-2468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1060]'
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串‘no’，‘equiv’，‘safe’，‘same_kind’和‘unsafe’转换为[`NPY_CASTING`](#c.NPY_CASTING
    "NPY_CASTING")枚举[`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING "NPY_NO_CASTING")，[`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING
    "NPY_EQUIV_CASTING")，[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING")，[`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING")和[`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")的枚举。
- en: '[PRE1061]'
  id: totrans-2470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1061]'
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 将Python字符串‘clip’，‘wrap’和‘raise’转换为[`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE")枚举[`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP")，[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP")和[`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE")。
- en: '[PRE1062]'
  id: totrans-2472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1062]'
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
  zh: 将剪裁模式序列或单个剪裁模式转换为[`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE")值的C数组。 在调用此函数之前必须知道剪裁模式的数量*n*。
    提供此函数以帮助函数为每个维度允许不同的剪裁模式。
- en: Other conversions
  id: totrans-2474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他转换
- en: '[PRE1063]'
  id: totrans-2475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1063]'
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的Python对象（包括数组和数组标量）转换为标准整数。 出现错误时，返回-1并设置异常。 您可能会发现以下宏有用：
- en: '[PRE1064]'
  id: totrans-2477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1064]'
- en: '[PRE1065]'
  id: totrans-2478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1065]'
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的Python对象（包括数组和数组标量）转换为（平台指针大小的）整数。 出现错误时，返回-1并设置异常。
- en: '[PRE1066]'
  id: totrans-2480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1066]'
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为*seq*传递的任何Python序列（或单个Python数字）转换为（最多）*maxvals*指针大小的整数，并将它们放在*vals*数组中。 序列可以小于*maxvals*，因为返回转换对象的数量。
- en: '[PRE1067]'
  id: totrans-2482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1067]'
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型字符串字符（带有*itemsize*）转换为基本枚举数据类型。 识别并转换相对应于有符号和无符号整数，浮点数和复数浮点数的类型字符串字符。 返回其他值的gentype。
    例如，可以使用此函数将字符串‘f4’转换为[`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32 "NPY_FLOAT32")。
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  id: totrans-2484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(在 Python v3.11 中)")
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都可以在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(在 Python v3.11 中)") (…)中使用，使用“O&”格式说明符自动将任何Python对象转换为所需的C对象。 所有这些函数如果成功，则返回[`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED")，否则返回[`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL")。 所有这些函数的第一个参数是Python对象。
    第二个参数是要将Python对象转换为的C类型的**地址**。
- en: Warning
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要了解在使用这些转换函数时应采取哪些步骤来管理内存。这些函数可能需要释放内存，和/或根据您的使用情况改变特定对象的引用计数。
- en: '[PRE1068]'
  id: totrans-2488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1068]'
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何 Python 对象转换为[`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")。如果[`PyArray_Check`](#c.PyArray_Check "PyArray_Check")（*obj*）为
    TRUE，则增加其引用计数并在 *address* 中放置一个引用。如果 *obj* 不是数组，则使用[`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny")将其转换为数组。无论返回什么，当使用完这个例程返回的对象时，必须在 *address* 中减少对该对象的引用。
- en: '[PRE1069]'
  id: totrans-2490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1069]'
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 这是给定给函数的输出数组的默认转换器。如果 *obj* 是[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)")或`NULL`，那么**address* 将为`NULL`，但调用会成功。如果[`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check")（*obj*）为 TRUE，则会在**address* 中返回它而不增加其引用计数。
- en: '[PRE1070]'
  id: totrans-2492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1070]'
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何小于[`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")的 Python 序列 *obj* 转换为[`npy_intp`](dtype.html#c.npy_intp
    "npy_intp")的 C 数组。Python 对象也可以是单个数字。*seq* 变量是指向具有成员 ptr 和 len 的结构体的指针。成功返回后，*seq*
    ->ptr 包含一个必须通过调用[`PyDimMem_FREE`](#c.PyDimMem_FREE "PyDimMem_FREE")释放的内存的指针，以避免内存泄漏。对内存大小的限制允许方便地将此转换器用于被解释为数组形状的序列。
- en: '[PRE1071]'
  id: totrans-2494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1071]'
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有（单一段）缓冲区接口的任何 Python 对象 *obj* 转换为具有详细成员的变量，以详细说明对象对其内存块的使用。*buf* 变量是指向具有基址、ptr、len
    和 flags 成员的结构体的指针。[`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk
    "PyArray_Chunk") 结构与 Python 的缓冲区对象二进制兼容（通过其 32 位平台上的 len 成员和 64 位平台上的 ptr 成员）。返回时，将
    base 成员设置为 *obj*（或其基址，如果 *obj* 已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加 base 成员的引用计数。内存块由
    *buf* ->ptr 成员指向，并具有长度 *buf* ->len。如果 *obj* 具有可写缓冲区接口，则 *buf* 的 flags 成员是[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")，并设置了[`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")标志。
- en: '[PRE1072]'
  id: totrans-2496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1072]'
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 将代表轴参数的 Python 对象 *obj* 转换为适当的值，以便传递给接受整数轴的函数。具体来说，如果 *obj* 是 None，则 *axis*
    设置为[`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")，这样 C-API 函数就能正确解释轴参数。
- en: '[PRE1073]'
  id: totrans-2498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1073]'
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何 Python 对象 *obj* 转换为 [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") 或 [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE")，并将结果放置在 *value* 中。
- en: '[PRE1074]'
  id: totrans-2500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1074]'
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为相应的字节顺序字符：'>'、'<'、's'、'=' 或 '|'。
- en: '[PRE1075]'
  id: totrans-2502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1075]'
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为 [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT "NPY_QUICKSORT")（以
    'q' 或 'Q' 开头）、[`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT "NPY_HEAPSORT")（以
    'h' 或 'H' 开头）、[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")（以
    'm' 或 'M' 开头）或 [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")（以
    't' 或 'T' 开头）中的一个。对于向后兼容性，[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")和
    [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT") 会相互别名，并且可能根据数据类型指代多种稳定的排序算法之一。
- en: '[PRE1076]'
  id: totrans-2504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1076]'
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串转换为 [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT "NPY_SEARCHLEFT")（以
    'l' 或 'L' 开头），或 [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT "NPY_SEARCHRIGHT")（以
    'r' 或 'R' 开头）。
- en: '[PRE1077]'
  id: totrans-2506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1077]'
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串 'C'、 'F'、 'A' 和 'K' 转换为枚举 [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER")、[`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")、[`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER") 和 [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER")。
- en: '[PRE1078]'
  id: totrans-2508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1078]'
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串 'no'、 'equiv'、'safe'、'same_kind' 和 'unsafe' 转换为枚举 [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING")、[`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING")、[`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING")、[`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING") 和 [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING")。
- en: '[PRE1079]'
  id: totrans-2510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1079]'
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 字符串 'clip'、'wrap' 和 'raise' 转换为枚举 [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP")、[`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP") 和 [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE")。
- en: '[PRE1080]'
  id: totrans-2512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1080]'
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列 clipmodes 或单个 clipmode 转换为存储 [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE")
    值的 C 数组。在调用此函数之前，必须知道 clipmodes 的数量 *n*。此函数用于帮助函数允许每个维度使用不同的 clipmode。
- en: Other conversions
  id: totrans-2514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他转换
- en: '[PRE1081]'
  id: totrans-2515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1081]'
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的 Python 对象（包括数组和数组标量）转换为标准整数。出现错误时，返回-1并设置异常。您可能会发现以下宏有用：
- en: '[PRE1082]'
  id: totrans-2517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1082]'
- en: '[PRE1083]'
  id: totrans-2518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1083]'
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有类型的 Python 对象（包括数组和数组标量）转换为（平台指针大小的）整数。出现错误时，返回-1并设置异常。
- en: '[PRE1084]'
  id: totrans-2520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1084]'
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为*seq*传递的任何Python序列（或单个Python数字）转换为（最多）*maxvals*个指针大小的整数，并将它们放入*vals*数组中。由于返回已转换对象的数量，因此序列可以小于*maxvals*。
- en: '[PRE1085]'
  id: totrans-2522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1085]'
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型字符串字符（带有*itemsize*）转换为基本枚举数据类型。识别并转换有符号和无符号整数、浮点数和复数浮点数对应的类型字符串字符。并返回gentype的其他值。例如，此函数可用于将字符串‘f4’转换为[`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32")。
- en: Miscellaneous
  id: totrans-2524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他
- en: Importing the API
  id: totrans-2525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入API
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从另一个扩展模块中使用C-API，必须调用[`import_array`](#c.import_array "import_array")函数。如果扩展模块包含在单个.c文件中，则只需完成这些步骤。但是，如果扩展模块涉及需要C-API的多个文件，则必须执行一些额外的步骤。
- en: '[PRE1086]'
  id: totrans-2527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1086]'
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数必须在将使用C-API的模块的初始化部分中调用。它导入存储函数指针表的模块，并将正确的变量指向它。
- en: '[PRE1087]'
  id: totrans-2529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1087]'
- en: '[PRE1088]'
  id: totrans-2530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1088]'
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些#定义，您可以在单个扩展模块的多个文件中使用C-API。在每个文件中，您必须将[`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL")定义为将保存C-API的一些名称（如myextension_ARRAY_API）。这必须在包含numpy/arrayobject.h文件**之前**完成。在模块初始化例程中，调用[`import_array`](#c.import_array
    "import_array")。此外，在没有模块初始化子例程的文件中，在包含numpy/arrayobject.h之前，定义[`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY
    "NO_IMPORT_ARRAY")。
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有两个文件coolmodule.c和coolhelper.c，需要编译并链接成单个扩展模块。假设coolmodule.c包含所需的initcool模块初始化函数（调用了import_array()函数）。那么，coolmodule.c应该在顶部包含：
- en: '[PRE1089]'
  id: totrans-2533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1089]'
- en: 'On the other hand, coolhelper.c would contain at the top:'
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，coolhelper.c应该在顶部包含：
- en: '[PRE1090]'
  id: totrans-2535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1090]'
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将常见的最后两行放入局部扩展头文件中，只要在#包含该文件之前确保已定义了NO_IMPORT_ARRAY。
- en: 'Internally, these #defines work as follows:'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些#定义的工作方式如下：
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  id: totrans-2538
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都没有定义，则C-API被声明为`static void**`，因此它仅在包含numpy/arrayobject.h的编译单元中可见。
- en: ''
  id: totrans-2539
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2540
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  id: totrans-2541
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经定义了[`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")，但没有定义[`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY
    "NO_IMPORT_ARRAY")，则C-API被声明为`void**`，以便它也可被其他编译单元看到。
- en: ''
  id: totrans-2542
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2543
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  id: totrans-2544
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY")被定义，无论是否[`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL")被定义，C-API都声明为`extern void**`，因此预计它将在另一个编译单元中定义。
- en: ''
  id: totrans-2545
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2546
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  id: totrans-2547
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当[`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")被定义，它还会改变默认情况下保存C-API的变量名称`PyArray_API`，变成宏所定义的任何名称。
- en: Checking the API Version
  id: totrans-2548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查API版本
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在大多数平台上，python扩展的使用方式与通常库不同，所以某些错误在构建时甚至运行时都不能自动检测到。例如，如果你使用了仅适用于numpy >=
    1.3.0的函数来构建扩展，并且稍后在numpy 1.2下导入扩展，你将不会得到导入错误（但在调用函数时几乎肯定会发生分段错误）。这就是为什么提供了几个函数来检查numpy版本。宏[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION")和[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")对应于用于构建扩展的numpy版本，而函数[`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion")和[`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion")返回的版本对应于运行时numpy的版本。
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
  zh: ABI和API兼容性的规则可以总结如下：
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  id: totrans-2551
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`时，扩展都必须重新编译（ABI不兼容）。
- en: ''
  id: totrans-2552
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2553
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  id: totrans-2554
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`和[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`表示向后兼容的更改。'
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个numpy版本中自动检测ABI不兼容性。在numpy 1.4.0中添加了API不兼容性检测。如果要支持多个不同的numpy版本，并且使用一个扩展二进制文件，就必须尽可能用最低的[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")来构建扩展。
- en: '[PRE1091]'
  id: totrans-2556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1091]'
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray对象的当前版本（检查是否定义了这个变量，以确保正在使用`numpy/arrayobject.h`头文件）。
- en: '[PRE1092]'
  id: totrans-2558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1092]'
- en: The current version of the C-API.
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: C-API的当前版本。
- en: '[PRE1093]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1093]'
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是返回值[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION")。每当ABI级别发生向后不兼容的变化时，[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION")就会改变。但由于它在C-API中，因此比较该函数输出的值与当前头文件中定义的值可以测试C-API是否发生了变化，从而需要重新编译使用C-API的扩展模块。这在函数[`import_array`](#c.import_array
    "import_array")中会自动检查。
- en: '[PRE1094]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1094]'
- en: New in version 1.4.0.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4.0中添加。
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是返回值[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")。每当API发生变化（例如添加函数），[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")就会改变。更改的值并不总是需要重新编译。
- en: Internal Flexibility
  id: totrans-2565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部灵活性
- en: '[PRE1095]'
  id: totrans-2566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1095]'
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy存储了一个内部表格，其中包含用于实现数组的算术运算以及某些数组计算方法的Python可调用对象。此函数允许用户用自己的版本替换这些Python对象中的任意一个或全部。字典*dict*的键是要替换的命名函数，配对的值是要使用的Python可调用对象。应注意要替换内部数组操作的函数不能调用回该内部数组操作（除非您设计了能处理该问题的函数），否则可能导致未经检查的无限递归（可能导致程序崩溃）。可以替换的操作的键名包括：
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  id: totrans-2568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**add**,**subtract**,**multiply**,**divide**,**remainder**,**power**,**square**,**reciprocal**,**ones_like**,**sqrt**,**negative**,**positive**,**absolute**,**invert**,**left_shift**,**right_shift**,**bitwise_and**,**bitwise_xor**,**bitwise_or**,**less**,**less_equal**,**equal**,**not_equal**,**greater**,**greater_equal**,**floor_divide**,**true_divide**,**logical_or**,**logical_and**,**floor**,**ceil**,**maximum**,**minimum**,**rint**。'
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在此处列出，因为它们至少在数组对象的方法中被使用一次。如果要分配的对象之一不可调用，则函数将返回-1（而不设置Python错误）。
- en: Deprecated since version 1.16.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16起不推荐使用。
- en: '[PRE1096]'
  id: totrans-2571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1096]'
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含存储在内部算术操作表中的可调用Python对象的Python字典。该字典的键在[`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps
    "PyArray_SetNumericOps")的说明中给出。
- en: Deprecated since version 1.16.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16起不推荐使用。
- en: '[PRE1097]'
  id: totrans-2574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1097]'
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许您将数组对象的`tp_str`和`tp_repr`方法更改为任何Python函数。因此，您可以更改在Python调用`str(arr)`或`repr(arr)`时发生的情况。要调用的函数作为*op*传递。如果*repr*非零，则该函数将在回应`repr(arr)`时被调用，否则将在回应`str(arr)`时调用。不会检查*op*是否可调用。传递给*op*的可调用对象应期望一个数组参数，并应返回要打印的字符串。
- en: Memory management
  id: totrans-2576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: '[PRE1098]'
  id: totrans-2577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1098]'
- en: '[PRE1099]'
  id: totrans-2578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1099]'
- en: '[PRE1100]'
  id: totrans-2579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1100]'
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配、释放和重新分配内存的宏。这些宏在内部用于创建数组。
- en: '[PRE1101]'
  id: totrans-2581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1101]'
- en: '[PRE1102]'
  id: totrans-2582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1102]'
- en: '[PRE1103]'
  id: totrans-2583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1103]'
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配、释放和重新分配维度和步长内存的宏。
- en: '[PRE1104]'
  id: totrans-2585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1104]'
- en: '[PRE1105]'
  id: totrans-2586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1105]'
- en: '[PRE1106]'
  id: totrans-2587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1106]'
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏使用不同的内存分配器，具体取决于常量[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")。当[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM")为0时，使用系统malloc，如果[`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM")为1，则使用Python内存分配器。
- en: '[PRE1107]'
  id: totrans-2589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1107]'
- en: '[PRE1108]'
  id: totrans-2590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1108]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`具有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，则此函数清除标志，*DECREF*
    *obj->base*并使其可写，并将`obj->base`设置为NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与[`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase")相反。通常情况下，一旦完成`obj`的使用，就会调用此函数，就在`Py_DECREF(obj)`之前。可以多次调用，或使用`NULL`输入。另请参阅[`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy")。
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有进行任何操作，则返回0，发生错误时返回-1，如果进行了操作则返回1。
- en: Threading support
  id: totrans-2593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程支持
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏仅在扩展模块的编译期间评估[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")为True时才有意义。否则，这些宏等同于空白。Python为每个Python进程使用单个全局解释器锁（GIL），因此一次只能执行一个线程（即使在多CPU机器上也是如此）。当调用编译函数可能需要时间来计算（并且对其他线程没有副作用，比如更新全局变量）时，应释放GIL，以便其他Python线程在进行耗时计算时可以运行。这可以通过两组宏来实现。通常，如果在代码块中使用了一个组中的宏，则所有这些宏都必须在同一个代码块中使用。当前，[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为python定义的[`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS")常量，除非环境变量`NPY_NOSMP`被设置，否则[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为0。
- en: '[PRE1109]'
  id: totrans-2595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1109]'
- en: '[PRE1110]'
  id: totrans-2596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1110]'
- en: Group 1
  id: totrans-2597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一组
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  id: totrans-2598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个组用于调用可能需要一些时间但不使用任何Python C-API调用的代码。因此，在计算期间应释放GIL。
- en: ''
  id: totrans-2599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1111]'
  id: totrans-2600
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1111]'
- en: ''
  id: totrans-2601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等同于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(在Python v3.11中)")，除了它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定宏是否被替换为空格。
- en: ''
  id: totrans-2603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1112]'
  id: totrans-2604
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1112]'
- en: ''
  id: totrans-2605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等同于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(在Python v3.11中)")，除了它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定宏是否被替换为空格。
- en: ''
  id: totrans-2607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1113]'
  id: totrans-2608
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1113]'
- en: ''
  id: totrans-2609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  id: totrans-2610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在变量声明区域。此宏设置了存储Python状态所需的变量。
- en: ''
  id: totrans-2611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1114]'
  id: totrans-2612
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1114]'
- en: ''
  id: totrans-2613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  id: totrans-2614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在不需要Python解释器的代码之前。此宏保存Python状态并释放GIL。
- en: ''
  id: totrans-2615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1115]'
  id: totrans-2616
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1115]'
- en: ''
  id: totrans-2617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  id: totrans-2618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在不需要Python解释器的代码之后。此宏获取GIL并从保存的变量中恢复Python状态。
- en: ''
  id: totrans-2619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1116]'
  id: totrans-2620
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1116]'
- en: ''
  id: totrans-2621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  id: totrans-2622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有当*dtype*不包含在执行循环期间可能需要Python解释器的任意Python对象时才有用。
- en: ''
  id: totrans-2623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1117]'
  id: totrans-2624
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1117]'
- en: ''
  id: totrans-2625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  id: totrans-2626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用此宏的BEGIN形式释放GIL后，有助于恢复GIL。
- en: ''
  id: totrans-2627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1118]'
  id: totrans-2628
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1118]'
- en: ''
  id: totrans-2629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  id: totrans-2630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有在*loop_size*超过最小阈值（当前设置为500）时才有用。应该与[`NPY_END_THREADS`](#c.NPY_END_THREADS
    "NPY_END_THREADS")配对，以恢复GIL。
- en: Group 2
  id: totrans-2631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二组
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  id: totrans-2632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个组用于在释放后重新获取 Python GIL。例如，假设已释放 GIL（使用以前的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用 Python
    C-API，则这些宏有助于获取 GIL。这些宏基本上实现了先前三个的反转（获取 LOCK 并保存其状态），然后使用保存的状态重新释放它。
- en: ''
  id: totrans-2633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1119]'
  id: totrans-2634
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1119]'
- en: ''
  id: totrans-2635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  id: totrans-2636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在变量声明区域以设置所需变量。
- en: ''
  id: totrans-2637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1120]'
  id: totrans-2638
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1120]'
- en: ''
  id: totrans-2639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  id: totrans-2640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在需要调用 Python C-API 的代码之前（当已知 GIL 已经被释放时）。
- en: ''
  id: totrans-2641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1121]'
  id: totrans-2642
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1121]'
- en: ''
  id: totrans-2643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  id: totrans-2644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在需要调用 Python C-API 的代码之后（以释放 GIL）。
- en: Tip
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never use semicolons after the threading support macros.
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程支持宏后永远不要使用分号。
- en: Priority
  id: totrans-2647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级
- en: '[PRE1122]'
  id: totrans-2648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1122]'
- en: Default priority for arrays.
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的默认优先级。
- en: '[PRE1123]'
  id: totrans-2650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1123]'
- en: Default subtype priority.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 默认子类型优先级。
- en: '[PRE1124]'
  id: totrans-2652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1124]'
- en: Default scalar priority (very small)
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 默认标量优先级（非常小）
- en: '[PRE1125]'
  id: totrans-2654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1125]'
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *obj* 或 *def* 的 [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") 属性（转换为 double），如果该名称的属性不存在，则提供快速返回避免属性查找对象的类型为
    [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type")。
- en: Default buffers
  id: totrans-2656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认缓冲区
- en: '[PRE1126]'
  id: totrans-2657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1126]'
- en: Default size of the user-settable internal buffers.
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的默认大小。
- en: '[PRE1127]'
  id: totrans-2659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1127]'
- en: Smallest size of user-settable internal buffers.
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的最小大小。
- en: '[PRE1128]'
  id: totrans-2661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1128]'
- en: Largest size allowed for the user-settable buffers.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置缓冲区的最大大小。
- en: Other constants
  id: totrans-2663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常量
- en: '[PRE1129]'
  id: totrans-2664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1129]'
- en: The number of floating-point types
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的数量
- en: '[PRE1130]'
  id: totrans-2666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1130]'
- en: The maximum number of dimensions allowed in arrays.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中允许的最大维数。
- en: '[PRE1131]'
  id: totrans-2668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1131]'
- en: The maximum number of array arguments that can be used in functions.
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中可以使用的数组参数的最大数量。
- en: '[PRE1132]'
  id: totrans-2670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1132]'
- en: Defined as 0 for use with Bool.
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为 0 以与 Bool 一起使用。
- en: '[PRE1133]'
  id: totrans-2672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1133]'
- en: Defined as 1 for use with Bool.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为 1 以与 Bool 一起使用。
- en: '[PRE1134]'
  id: totrans-2674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1134]'
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的转换器函数的返回值，这些函数使用类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(在 Python v3.11 中)")的函数中的“O&”语法调用。
- en: '[PRE1135]'
  id: totrans-2676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1135]'
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的转换器函数的返回值，这些函数使用类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(在 Python v3.11 中)")的函数中的“O&”语法调用。
- en: Miscellaneous Macros
  id: totrans-2678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他宏
- en: '[PRE1136]'
  id: totrans-2679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1136]'
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组 *a1* 和 *a2* 具有相同的形状，则评估为 True。
- en: '[PRE1137]'
  id: totrans-2681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1137]'
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *a* 和 *b* 的最大值。如果 (*a*) 或 (*b*) 是表达式，则会评估两次。
- en: '[PRE1138]'
  id: totrans-2683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1138]'
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 *a* 和 *b* 的最小值。如果 (*a*) 或 (*b*) 是表达式，则会评估两次。
- en: '[PRE1139]'
  id: totrans-2685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1139]'
- en: '[PRE1140]'
  id: totrans-2686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1140]'
- en: '[PRE1141]'
  id: totrans-2687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1141]'
- en: '[PRE1142]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1142]'
- en: '[PRE1143]'
  id: totrans-2689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1143]'
- en: '[PRE1144]'
  id: totrans-2690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1144]'
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy 的两个复数（具有实部和虚部成员的结构）之间的复杂比较实现了基于词法顺序的 NumPy 定义的比较：首先比较实部，然后如果实部相等，则比较复数部分。
- en: '[PRE1145]'
  id: totrans-2692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1145]'
- en: Returns the reference count of any Python object.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 返回任何 Python 对象的引用计数。
- en: '[PRE1146]'
  id: totrans-2694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1146]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`具有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，此函数清除标志，*DECREF*
    s *obj->base*并使其可写，并将`obj->base`设置为NULL。与[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")相比，它不会尝试从*obj->base*复制数据。这是在发生错误时，当你完成`obj`时，即在`Py_DECREF(obj)`之前通常调用的。可多次调用，或使用`NULL`输入。
- en: Enumerated Types
  id: totrans-2696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举类型
- en: '[PRE1147]'
  id: totrans-2697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1147]'
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的变量类型，可以采用不同值来指示正在使用的排序算法。
- en: '[PRE1148]'
  id: totrans-2699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1148]'
- en: '[PRE1149]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1149]'
- en: '[PRE1150]'
  id: totrans-2701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1150]'
- en: '[PRE1151]'
  id: totrans-2702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1151]'
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
  zh: 用作[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")的别名，反之亦然。
- en: '[PRE1152]'
  id: totrans-2704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1152]'
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为排序的数量。由于向后兼容性的需要，此值固定为三，因此[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT")和[`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")互为别名，并可以引用几种稳定排序算法之一，具体取决于数据类型。
- en: '[PRE1153]'
  id: totrans-2706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1153]'
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的变量类型，表示在确定标量强制转换规则时区分的“种类”数量。此变量可以取以下值：
- en: '[PRE1154]'
  id: totrans-2708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1154]'
- en: '[PRE1155]'
  id: totrans-2709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1155]'
- en: '[PRE1156]'
  id: totrans-2710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1156]'
- en: '[PRE1157]'
  id: totrans-2711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1157]'
- en: '[PRE1158]'
  id: totrans-2712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1158]'
- en: '[PRE1159]'
  id: totrans-2713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1159]'
- en: '[PRE1160]'
  id: totrans-2714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1160]'
- en: '[PRE1161]'
  id: totrans-2715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1161]'
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为标量种类的数量（不包括[`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR "NPY_NOSCALAR")）。
- en: '[PRE1162]'
  id: totrans-2717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1162]'
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应解释数组的元素顺序的枚举类型。创建全新数组时，一般只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而在提供一个或多个输入时，顺序可以基于它们。
- en: '[PRE1163]'
  id: totrans-2719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1163]'
- en: Fortran order if all the inputs are Fortran, C otherwise.
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有输入都是Fortran，则为Fortran顺序，否则为C顺序。
- en: '[PRE1164]'
  id: totrans-2721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1164]'
- en: C order.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
  zh: C顺序。
- en: '[PRE1165]'
  id: totrans-2723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1165]'
- en: Fortran order.
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran顺序。
- en: '[PRE1166]'
  id: totrans-2725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1166]'
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能接近输入顺序的顺序，即使输入既不是C顺序也不是Fortran顺序。
- en: '[PRE1167]'
  id: totrans-2727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1167]'
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应在某些函数中应用的裁剪类型的变量类型。
- en: '[PRE1168]'
  id: totrans-2729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1168]'
- en: The default for most operations, raises an exception if an index is out of bounds.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 对大多数操作来说是默认的，在索引越界时会引发异常。
- en: '[PRE1169]'
  id: totrans-2731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1169]'
- en: Clips an index to the valid range if it is out of bounds.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超出范围，则将索引剪辑到有效范围内。
- en: '[PRE1170]'
  id: totrans-2733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1170]'
- en: Wraps an index to the valid range if it is out of bounds.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超出范围，则将索引包裹到有效范围内。
- en: '[PRE1171]'
  id: totrans-2735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1171]'
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 表示返回的索引是第一个合适位置的索引（如果[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT "NPY_SEARCHLEFT")）还是最后一个位置的索引（如果[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）的变量类型。
- en: '[PRE1172]'
  id: totrans-2737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1172]'
- en: '[PRE1173]'
  id: totrans-2738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1173]'
- en: '[PRE1174]'
  id: totrans-2739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1174]'
- en: A variable type indicating the selection algorithm being used.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
  zh: 表示正在使用的选择算法的变量类型。
- en: '[PRE1175]'
  id: totrans-2741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1175]'
- en: '[PRE1176]'
  id: totrans-2742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1176]'
- en: New in version 1.6.
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.6中新增。
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数据转换应有多宽松的枚举类型。在NumPy 1.6中添加的迭代器中使用，计划在将来的版本中更广泛地使用。
- en: '[PRE1177]'
  id: totrans-2745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1177]'
- en: Only allow identical types.
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许相同类型。
- en: '[PRE1178]'
  id: totrans-2747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1178]'
- en: Allow identical and casts involving byte swapping.
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 允许相同和涉及字节交换的强制转换。
- en: '[PRE1179]'
  id: totrans-2749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1179]'
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许不会导致值四舍五入、截断或以其他方式更改的强制转换。
- en: '[PRE1180]'
  id: totrans-2751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1180]'
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何安全的转换和相同类型的转换。例如，float64 -> float32 可以使用此规则进行转换。
- en: '[PRE1181]'
  id: totrans-2753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1181]'
- en: Allow any cast, no matter what kind of data loss may occur.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 允许进行任何类型的转换，无论可能发生什么样的数据损失。
- en: Importing the API
  id: totrans-2755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 API
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 要从另一个扩展模块中使用 C-API，必须调用 [`import_array`](#c.import_array "import_array") 函数。如果扩展模块是包含在一个单独的
    .c 文件中的自包含模块，则只需要做这些。然而，如果扩展模块涉及到需要 C-API 的多个文件，则需要进行一些额外的步骤。
- en: '[PRE1182]'
  id: totrans-2757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1182]'
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数必须在将要使用 C-API 的模块的初始化部分中调用。它导入存储函数指针表的模块，并将正确的变量指向它。
- en: '[PRE1183]'
  id: totrans-2759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1183]'
- en: '[PRE1184]'
  id: totrans-2760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1184]'
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这些 #define，你可以在单个扩展模块的多个文件中使用 C-API。在每个文件中，必须将 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") 定义为某个保存 C-API 的名称（例如，myextension_ARRAY_API）。在模块初始化例程中，调用
    [`import_array`](#c.import_array "import_array")。此外，在不具有模块初始化子例程的文件中，在包含 numpy/arrayobject.h
    之前定义 [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY")。'
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我有两个需要编译和链接到单个扩展模块的文件coolmodule.c和coolhelper.c。假设coolmodule.c 包含所需的initcool模块初始化函数（其中调用了import_array()函数）。那么，coolmodule.c
    的顶部应有以下内容：
- en: '[PRE1185]'
  id: totrans-2763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1185]'
- en: 'On the other hand, coolhelper.c would contain at the top:'
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，coolhelper.c 的顶部应有以下内容：
- en: '[PRE1186]'
  id: totrans-2765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1186]'
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以将最后两行的通用内容放入扩展的本地头文件中，只要在 #include 该文件之前，确保 NO_IMPORT_ARRAY 被 #defined。'
- en: 'Internally, these #defines work as follows:'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: '在内部，这些 #define 的工作原理如下：'
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  id: totrans-2768
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果都没有定义，C-API 声明为 `static void**`，因此它仅在包含 numpy/arrayobject.h 的编译单元内可见。
- en: ''
  id: totrans-2769
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2770
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  id: totrans-2771
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 #defined 了 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")，但未定义
    [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY")，则 C-API 声明为 `void**`，以便它也对其他编译单元可见。'
- en: ''
  id: totrans-2772
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2773
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  id: totrans-2774
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果 #defined 了 [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY")，无论
    [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    是否被定义，都将 C-API 声明为 `extern void**`，因此它应该在另一个编译单元中定义。'
- en: ''
  id: totrans-2775
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2776
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  id: totrans-2777
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当定义了 [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")，它也会更改保存
    C-API 的变量的名称，默认为 `PyArray_API`，改为宏定义所指定的名称。
- en: Checking the API Version
  id: totrans-2778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查 API 版本
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在大多数平台上，Python扩展的使用方式与通常的库不同，因此有些错误无法在构建时甚至运行时自动检测到。例如，如果使用仅在numpy >= 1.3.0可用的函数构建扩展，然后稍后在numpy
    1.2上导入该扩展，您将不会收到导入错误（但几乎可以肯定在调用该函数时会导致分段错误）。这就是为什么提供了多个函数来检查numpy版本。宏[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") 和 [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    对应于用于构建扩展的numpy版本，而函数[`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") 和 [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") 返回的版本对应于运行时numpy的版本。
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: ABI和API兼容性的规则可以总结如下：
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  id: totrans-2781
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`时，就需要重新编译扩展（ABI不兼容）。
- en: ''
  id: totrans-2782
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-2783
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  id: totrans-2784
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`，并且[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()` 意味着向后兼容的变化。'
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: 每个numpy版本都会自动检测ABI不兼容性。API不兼容性检测是在numpy 1.4.0中添加的。如果要使用一个扩展二进制文件支持许多不同的numpy版本，就必须尽可能使用最低的[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")构建扩展。
- en: '[PRE1187]'
  id: totrans-2786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1187]'
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray对象的当前版本（检查是否定义了此变量，以确保使用了`numpy/arrayobject.h`头文件）。
- en: '[PRE1188]'
  id: totrans-2788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1188]'
- en: The current version of the C-API.
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: C-API的当前版本。
- en: '[PRE1189]'
  id: totrans-2790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1189]'
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 这只返回值[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION")。每当ABI级别发生向后不兼容的更改时，[`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION")就会改变。由于它在C-API中，可以通过比较此函数的输出和当前头文件中定义的值来测试C-API是否已更改，从而需要重新编译使用C-API的扩展模块。这在函数[`import_array`](#c.import_array
    "import_array")中自动检查。
- en: '[PRE1190]'
  id: totrans-2792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1190]'
- en: New in version 1.4.0.
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4.0的新增内容。
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 这只返回值[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")。每当API发生变化（例如增加了一个函数），[`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION")就会改变。改变的值并不总是需要重新编译。
- en: Internal Flexibility
  id: totrans-2795
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部灵活性
- en: '[PRE1191]'
  id: totrans-2796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1191]'
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 'NumPy 存储了一个内部表格，其中包含用于实现数组的算术操作以及某些数组计算方法的 Python 可调用对象。该函数允许用户用自己的版本替换这些 Python
    对象中的任意几个或全部。字典 *dict* 的键是要替换的以及要使用的 Python 可调用对象的命名函数。应注意，用于替换内部数组操作的函数不应调用该内部数组操作（除非您已设计该函数来处理），否则可能导致未经检查的无限递归（可能导致程序崩溃）。可替换操作的键名包括:'
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  id: totrans-2798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**add**，**subtract**，**multiply**，**divide**，**remainder**，**power**，**square**，**reciprocal**，**ones_like**，**sqrt**，**negative**，**positive**，**absolute**，**invert**，**left_shift**，**right_shift**，**bitwise_and**，**bitwise_xor**，**bitwise_or**，**less**，**less_equal**，**equal**，**not_equal**，**greater**，**greater_equal**，**floor_divide**，**true_divide**，**logical_or**，**logical_and**，**floor**，**ceil**，**maximum**，**minimum**，**rint**。'
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在这里包含，因为它们至少在数组对象的方法中使用一次。如果分配的对象中有一个不是可调用的，则函数返回 -1（而不设置 Python 错误）。
- en: Deprecated since version 1.16.
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16起被弃用。
- en: '[PRE1192]'
  id: totrans-2801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1192]'
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含内部算术操作表中存储的可调用 Python 对象的 Python 字典。该字典的键在 [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps
    "PyArray_SetNumericOps") 的解释中给出。
- en: Deprecated since version 1.16.
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16起被弃用。
- en: '[PRE1193]'
  id: totrans-2804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1193]'
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数允许您将数组对象的 *tp_str* 和 *tp_repr* 方法更改为任何 Python 函数。因此，您可以更改当从 Python 调用 str(arr)
    或 repr(arr) 时发生的情况。要调用的函数传递为 *op*。如果 *repr* 非零，则会在响应 repr(arr) 时调用该函数，否则将在响应 str(arr)
    时调用该函数。不会执行 *op* 是否可调用的检查。传递给 *op* 的可调用对象应期望一个数组参数，并应返回一个要打印的字符串。
- en: Memory management
  id: totrans-2806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存管理
- en: '[PRE1194]'
  id: totrans-2807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1194]'
- en: '[PRE1195]'
  id: totrans-2808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1195]'
- en: '[PRE1196]'
  id: totrans-2809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1196]'
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配、释放和重新分配内存的宏。这些宏在内部用于创建数组。
- en: '[PRE1197]'
  id: totrans-2811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1197]'
- en: '[PRE1198]'
  id: totrans-2812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1198]'
- en: '[PRE1199]'
  id: totrans-2813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1199]'
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配、释放和重新分配维度和步幅内存的宏。
- en: '[PRE1200]'
  id: totrans-2815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1200]'
- en: '[PRE1201]'
  id: totrans-2816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1201]'
- en: '[PRE1202]'
  id: totrans-2817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1202]'
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏使用不同的内存分配器，具体取决于常量 [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")。当
    [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM") 为 0 时，将使用系统
    malloc，如果 [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    为 1，则将使用 Python 内存分配器。
- en: '[PRE1203]'
  id: totrans-2819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1203]'
- en: '[PRE1204]'
  id: totrans-2820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1204]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`具有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，此函数会清除标志，*DECREF*
    *obj->base*并使其可写，并将`obj->base`设置为NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与[`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase")相反。通常在完成对`obj`的操作后，就在`Py_DECREF(obj)`之前调用此函数。可以多次调用，或者使用`NULL`输入。另请参阅[`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy")。
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未执行任何操作则返回0，出错返回-1，执行操作返回1。
- en: Threading support
  id: totrans-2823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程支持
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏仅在编译扩展模块时[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")评估为True时才有意义。否则，这些宏等效于空格。Python为每个Python进程使用单个全局解释器锁（GIL），因此一次只能执行一个线程（即使在多CPU机器上也是如此）。当调用编译函数可能需要时间来计算（并且不会对其他线程产生副作用，如更新全局变量）时，应释放GIL，以便其他Python线程在进行耗时计算时可以运行。可以使用两组宏来实现这一点。通常，如果在代码块中使用一组宏，则必须在同一代码块中使用所有宏。当前，[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为python定义的[`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS")常量，除非设置了环境变量`NPY_NOSMP`，在这种情况下，[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS")被定义为0。
- en: '[PRE1205]'
  id: totrans-2825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1205]'
- en: '[PRE1206]'
  id: totrans-2826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1206]'
- en: Group 1
  id: totrans-2827
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一组
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  id: totrans-2828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此组用于调用可能需要一些时间但不使用任何Python C-API调用的代码。因此，在计算过程中应释放GIL。
- en: ''
  id: totrans-2829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1207]'
  id: totrans-2830
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1207]'
- en: ''
  id: totrans-2831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等效于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(在Python v3.11中)")，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定宏是否替换为空格。
- en: ''
  id: totrans-2833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1208]'
  id: totrans-2834
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1208]'
- en: ''
  id: totrans-2835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等效于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(在Python v3.11中)")，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS")来确定宏是否替换为空格。
- en: ''
  id: totrans-2837
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1209]'
  id: totrans-2838
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1209]'
- en: ''
  id: totrans-2839
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  id: totrans-2840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在变量声明区域。此宏设置了存储Python状态所需的变量。
- en: ''
  id: totrans-2841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1210]'
  id: totrans-2842
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1210]'
- en: ''
  id: totrans-2843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  id: totrans-2844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在不需要Python解释器的代码之前。此宏保存Python状态并释放GIL。
- en: ''
  id: totrans-2845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1211]'
  id: totrans-2846
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1211]'
- en: ''
  id: totrans-2847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  id: totrans-2848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在不需要 Python 解释器的代码之后。这个宏获取 GIL 并从保存的变量恢复 Python 状态。
- en: ''
  id: totrans-2849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1212]'
  id: totrans-2850
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1212]'
- en: ''
  id: totrans-2851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  id: totrans-2852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '只有在 *dtype* 不包含在循环执行过程中可能需要 Python 解释器的任意 Python 对象时才有用于释放 GIL。 '
- en: ''
  id: totrans-2853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1213]'
  id: totrans-2854
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1213]'
- en: ''
  id: totrans-2855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  id: totrans-2856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用此宏的 BEGIN 形式后释放 GIL 的情况下，有助于重新获得 GIL。
- en: ''
  id: totrans-2857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1214]'
  id: totrans-2858
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1214]'
- en: ''
  id: totrans-2859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  id: totrans-2860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有在 *loop_size* 超过最小阈值时有用于释放 GIL，目前设置为 500。应与 [`NPY_END_THREADS`](#c.NPY_END_THREADS)
    一起匹配以重新获得 GIL。
- en: Group 2
  id: totrans-2861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组 2
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  id: totrans-2862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个组用于在释放后重新获取 Python GIL。例如，假设已经释放了 GIL（使用之前的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用
    Python C-API，那么这些宏很有用，用于获取 GIL。这些宏基本上完成了前三个操作的反向操作（获取锁保存其状态），然后用保存的状态重新释放它。
- en: ''
  id: totrans-2863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1215]'
  id: totrans-2864
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1215]'
- en: ''
  id: totrans-2865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  id: totrans-2866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在变量声明区域以设置必要的变量。
- en: ''
  id: totrans-2867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1216]'
  id: totrans-2868
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1216]'
- en: ''
  id: totrans-2869
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  id: totrans-2870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在需要调用 Python C-API 的代码之前（已知已释放 GIL）。
- en: ''
  id: totrans-2871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1217]'
  id: totrans-2872
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1217]'
- en: ''
  id: totrans-2873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  id: totrans-2874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在需要调用 Python C-API 的代码之后（用于重新释放 GIL）。
- en: Tip
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never use semicolons after the threading support macros.
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程支持宏后面不要使用分号。
- en: Group 1
  id: totrans-2877
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组 1
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  id: totrans-2878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此，在其计算过程中应释放 GIL。
- en: ''
  id: totrans-2879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1218]'
  id: totrans-2880
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1218]'
- en: ''
  id: totrans-2881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS)相当，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS)来确定该宏是否替换为空格还是不替换。
- en: ''
  id: totrans-2883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1219]'
  id: totrans-2884
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1219]'
- en: ''
  id: totrans-2885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  id: totrans-2886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS)相当，只是它使用[`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS)来确定该宏是否替换为空格还是不替换。
- en: ''
  id: totrans-2887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1220]'
  id: totrans-2888
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1220]'
- en: ''
  id: totrans-2889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  id: totrans-2890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在变量声明区域。此宏设置所需的用于存储 Python 状态的变量。
- en: ''
  id: totrans-2891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1221]'
  id: totrans-2892
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1221]'
- en: ''
  id: totrans-2893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  id: totrans-2894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在不需要 Python 解释器（没有 Python C-API 调用）的代码之前。此宏保存 Python 状态并释放 GIL。
- en: ''
  id: totrans-2895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1222]'
  id: totrans-2896
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1222]'
- en: ''
  id: totrans-2897
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  id: totrans-2898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放在不需要 Python 解释器的代码之后。这个宏获取 GIL 并从保存的变量恢复 Python 状态。
- en: ''
  id: totrans-2899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1223]'
  id: totrans-2900
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1223]'
- en: ''
  id: totrans-2901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  id: totrans-2902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有在 *dtype* 不包含在循环执行过程中可能需要 Python 解释器的任意 Python 对象时才有用于释放 GIL。
- en: ''
  id: totrans-2903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1224]'
  id: totrans-2904
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1224]'
- en: ''
  id: totrans-2905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  id: totrans-2906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用此宏的 BEGIN 形式后释放 GIL 的情况下，有助于重新获得 GIL。
- en: ''
  id: totrans-2907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1225]'
  id: totrans-2908
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1225]'
- en: ''
  id: totrans-2909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  id: totrans-2910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有在 *loop_size* 超过最小阈值时才有用于释放 GIL，目前设置为 500。应与 [`NPY_END_THREADS`](#c.NPY_END_THREADS)
    一起匹配以重新获得 GIL。
- en: Group 2
  id: totrans-2911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组 2
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  id: totrans-2912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此组用于在释放后重新获取Python GIL。例如，假设GIL已经被释放（使用先前的调用），然后代码中的一些路径（也许在不同的子例程中）需要使用Python
    C-API，那么这些宏就可以用于获取GIL。这些宏基本上完成了前三个的反向操作（获取锁保存其状态），然后使用保存的状态重新释放。
- en: ''
  id: totrans-2913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1226]'
  id: totrans-2914
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1226]'
- en: ''
  id: totrans-2915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  id: totrans-2916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 放置在变量声明区域以设置必要的变量。
- en: ''
  id: totrans-2917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1227]'
  id: totrans-2918
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1227]'
- en: ''
  id: totrans-2919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  id: totrans-2920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在需要调用Python C-API的代码之前放置（当已知GIL已经被释放时）。
- en: ''
  id: totrans-2921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1228]'
  id: totrans-2922
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1228]'
- en: ''
  id: totrans-2923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  id: totrans-2924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在需要调用Python C-API的代码后面放置（重新释放GIL）。
- en: Tip
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never use semicolons after the threading support macros.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程支持宏后永远不要使用分号。
- en: Priority
  id: totrans-2927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先级
- en: '[PRE1229]'
  id: totrans-2928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1229]'
- en: Default priority for arrays.
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的默认优先级。
- en: '[PRE1230]'
  id: totrans-2930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1230]'
- en: Default subtype priority.
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 默认子类型优先级。
- en: '[PRE1231]'
  id: totrans-2932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1231]'
- en: Default scalar priority (very small)
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 默认标量优先级（非常小）
- en: '[PRE1232]'
  id: totrans-2934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1232]'
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*obj*或*def*的[`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__)属性（转换为double），如果不存在该名称的属性，则提供避免属性查找的快速返回。为[`PyArray_Type`](types-and-structures.html#c.PyArray_Type)类型的对象提供了实现。
- en: Default buffers
  id: totrans-2936
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认缓冲区
- en: '[PRE1233]'
  id: totrans-2937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1233]'
- en: Default size of the user-settable internal buffers.
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的默认尺寸。
- en: '[PRE1234]'
  id: totrans-2939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1234]'
- en: Smallest size of user-settable internal buffers.
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置内部缓冲区的最小尺寸。
- en: '[PRE1235]'
  id: totrans-2941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1235]'
- en: Largest size allowed for the user-settable buffers.
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可设置缓冲区的最大大小。
- en: Other constants
  id: totrans-2943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常量
- en: '[PRE1236]'
  id: totrans-2944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1236]'
- en: The number of floating-point types
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的数量
- en: '[PRE1237]'
  id: totrans-2946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1237]'
- en: The maximum number of dimensions allowed in arrays.
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中允许的最大维数。
- en: '[PRE1238]'
  id: totrans-2948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1238]'
- en: The maximum number of array arguments that can be used in functions.
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中可以使用的数组参数的最大数量。
- en: '[PRE1239]'
  id: totrans-2950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1239]'
- en: Defined as 0 for use with Bool.
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为0，以与Bool一起使用。
- en: '[PRE1240]'
  id: totrans-2952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1240]'
- en: Defined as 1 for use with Bool.
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为1，以与Bool一起使用。
- en: '[PRE1241]'
  id: totrans-2954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1241]'
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“O&”语法在类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple)的函数中调用的失败转换函数的返回值。
- en: '[PRE1242]'
  id: totrans-2956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1242]'
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 成功转换函数的返回值，这些函数是在类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple)的函数中使用“O&”语法调用的。
- en: Miscellaneous Macros
  id: totrans-2958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项宏
- en: '[PRE1243]'
  id: totrans-2959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1243]'
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组*a1*和*a2*具有相同的形状，则评估为True。
- en: '[PRE1244]'
  id: totrans-2961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1244]'
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*a*和*b*的最大值。如果(*a*)或(*b*)是表达式，则会评估两次。
- en: '[PRE1245]'
  id: totrans-2963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1245]'
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: 返回*a*和*b*的最小值。如果(*a*)或(*b*)是表达式，则会评估两次。
- en: '[PRE1246]'
  id: totrans-2965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1246]'
- en: '[PRE1247]'
  id: totrans-2966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1247]'
- en: '[PRE1248]'
  id: totrans-2967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1248]'
- en: '[PRE1249]'
  id: totrans-2968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1249]'
- en: '[PRE1250]'
  id: totrans-2969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1250]'
- en: '[PRE1251]'
  id: totrans-2970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1251]'
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy的复数进行复杂比较（具有实部和虚部成员的结构）的实现，其排序定义为字典顺序：首先比较实部，如果实部相等，则比较虚部。
- en: '[PRE1252]'
  id: totrans-2972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1252]'
- en: Returns the reference count of any Python object.
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 返回任何Python对象的引用计数。
- en: '[PRE1253]'
  id: totrans-2974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1253]'
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`obj->flags`具有[`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")，此函数会清除标志，*DECREF*
    *obj->base* 并使其可写，并将`obj->base`设置为NULL。与[`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy")相反，它不会尝试从*obj->base*复制数据。这会撤消[`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase")。通常在错误发生时并且在使用`obj`完成后，即在`Py_DECREF(obj)`之前调用此函数。它可以被多次调用，或者带有`NULL`输入。
- en: Enumerated Types
  id: totrans-2976
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举类型
- en: '[PRE1254]'
  id: totrans-2977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1254]'
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的变量类型，可以采用不同的值表示所使用的排序算法。
- en: '[PRE1255]'
  id: totrans-2979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1255]'
- en: '[PRE1256]'
  id: totrans-2980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1256]'
- en: '[PRE1257]'
  id: totrans-2981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1257]'
- en: '[PRE1258]'
  id: totrans-2982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1258]'
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
  zh: 用作[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")的别名，反之亦然。
- en: '[PRE1259]'
  id: totrans-2984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1259]'
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为排序的数量。由于向后兼容性的需要，它被固定为三个，并且因此[`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT")和[`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")等彼此别名，并可能指代取决于数据类型的几种稳定排序算法之一。
- en: '[PRE1260]'
  id: totrans-2986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1260]'
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的变量类型，用于指示在确定标量强制规则时区分的标量“种类”的数量。该变量可以取以下值：
- en: '[PRE1261]'
  id: totrans-2988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1261]'
- en: '[PRE1262]'
  id: totrans-2989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1262]'
- en: '[PRE1263]'
  id: totrans-2990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1263]'
- en: '[PRE1264]'
  id: totrans-2991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1264]'
- en: '[PRE1265]'
  id: totrans-2992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1265]'
- en: '[PRE1266]'
  id: totrans-2993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1266]'
- en: '[PRE1267]'
  id: totrans-2994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1267]'
- en: '[PRE1268]'
  id: totrans-2995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1268]'
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为标量种类的数量（不包括[`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR "NPY_NOSCALAR")）。
- en: '[PRE1269]'
  id: totrans-2997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1269]'
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数组应该以哪种顺序解释的枚举类型。创建全新数组时，通常只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而当提供一个或多个输入时，顺序可以基于它们。
- en: '[PRE1270]'
  id: totrans-2999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1270]'
- en: Fortran order if all the inputs are Fortran, C otherwise.
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有输入都是Fortran，则为Fortran顺序，否则为C顺序。
- en: '[PRE1271]'
  id: totrans-3001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1271]'
- en: C order.
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
  zh: C顺序。
- en: '[PRE1272]'
  id: totrans-3003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1272]'
- en: Fortran order.
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: Fortran顺序。
- en: '[PRE1273]'
  id: totrans-3005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1273]'
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量接近输入顺序的顺序，即使输入的顺序既不是C顺序也不是Fortran顺序。
- en: '[PRE1274]'
  id: totrans-3007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1274]'
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示在某些函数中应用的剪裁类型。
- en: '[PRE1275]'
  id: totrans-3009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1275]'
- en: The default for most operations, raises an exception if an index is out of bounds.
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作的默认值，如果索引超出范围会引发异常。
- en: '[PRE1276]'
  id: totrans-3011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1276]'
- en: Clips an index to the valid range if it is out of bounds.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引超出范围，则将其剪裁到有效范围。
- en: '[PRE1277]'
  id: totrans-3013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1277]'
- en: Wraps an index to the valid range if it is out of bounds.
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引超出范围，则将其包裹到有效范围。
- en: '[PRE1278]'
  id: totrans-3015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1278]'
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示返回的索引应该是第一个合适位置的（如果是[`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")）还是最后一个位置的（如果是[`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")）。
- en: '[PRE1279]'
  id: totrans-3017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1279]'
- en: '[PRE1280]'
  id: totrans-3018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1280]'
- en: '[PRE1281]'
  id: totrans-3019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1281]'
- en: A variable type indicating the selection algorithm being used.
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量类型，指示正在使用的选择算法。
- en: '[PRE1282]'
  id: totrans-3021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1282]'
- en: '[PRE1283]'
  id: totrans-3022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1283]'
- en: New in version 1.6.
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.6���本中新增。
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数据转换应该多宽松的枚举类型。这是NumPy 1.6中添加的迭代器使用的，未来版本中打算更广泛使用。
- en: '[PRE1284]'
  id: totrans-3025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1284]'
- en: Only allow identical types.
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许相同类型。
- en: '[PRE1285]'
  id: totrans-3027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1285]'
- en: Allow identical and casts involving byte swapping.
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
  zh: 允许相同类型和涉及字节交换的强制转换。
- en: '[PRE1286]'
  id: totrans-3029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1286]'
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
  zh: 仅允许不会导致值四舍五入、截断或以其他方式更改的强制转换。
- en: '[PRE1287]'
  id: totrans-3031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1287]'
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何安全转换，以及同类别之间的转换。例如，float64 -> float32 符合这个规则。
- en: '[PRE1288]'
  id: totrans-3033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1288]'
- en: Allow any cast, no matter what kind of data loss may occur.
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何类型的转换，无论可能发生何种数据损失。
