- en: Testing the numpy.i Typemaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/swig.testing.html](https://numpy.org/doc/1.26/reference/swig.testing.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests for the `numpy.i` [SWIG](http://www.swig.org) interface file is
    a combinatorial headache. At present, 12 different data types are supported, each
    with 74 different argument signatures, for a total of 888 typemaps supported “out
    of the box”. Each of these typemaps, in turn, might require several unit tests
    in order to verify expected behavior for both proper and improper inputs. Currently,
    this results in more than 1,000 individual unit tests executed when `make test`
    is run in the `numpy/tools/swig` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this many similar unit tests, some high-level programming techniques
    are employed, including C and [SWIG](http://www.swig.org) macros, as well as Python
    inheritance. The purpose of this document is to describe the testing infrastructure
    employed to verify that the `numpy.i` typemaps are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three independent testing frameworks supported, for one-, two-, and
    three-dimensional arrays respectively. For one-dimensional arrays, there are two
    C++ files, a header and a source, named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'that contain prototypes and code for a variety of functions that have one-dimensional
    arrays as function arguments. The file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: is a [SWIG](http://www.swig.org) interface file that defines a python module
    `Vector` that wraps the functions in `Vector.h` while utilizing the typemaps in
    `numpy.i` to correctly handle the C arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The `Makefile` calls `swig` to generate `Vector.py` and `Vector_wrap.cxx`, and
    also executes the `setup.py` script that compiles `Vector_wrap.cxx` and links
    together the extension module `_Vector.so` or `_Vector.dylib`, depending on the
    platform. This extension module and the proxy file `Vector.py` are both placed
    in a subdirectory under the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual testing takes place with a Python script named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: that uses the standard Python library module `unittest`, which performs several
    tests of each function defined in `Vector.h` for each data type supported.
  prefs: []
  type: TYPE_NORMAL
- en: Two-dimensional arrays are tested in exactly the same manner. The above description
    applies, but with `Matrix` substituted for `Vector`. For three-dimensional tests,
    substitute `Tensor` for `Vector`. For four-dimensional tests, substitute `SuperTensor`
    for `Vector`. For flat in-place array tests, substitute `Flat` for `Vector`. For
    the descriptions that follow, we will reference the `Vector` tests, but the same
    information applies to `Matrix`, `Tensor` and `SuperTensor` tests.
  prefs: []
  type: TYPE_NORMAL
- en: The command `make test` will ensure that all of the test software is built and
    then run all three test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Header Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.h` is a C++ header file that defines a C macro called `TEST_FUNC_PROTOS`
    that takes two arguments: `TYPE`, which is a data type name such as `unsigned
    int`; and `SNAME`, which is a short name for the same data type with no spaces,
    e.g. `uint`. This macro defines several function prototypes that have the prefix
    `SNAME` and have at least one argument that is an array of type `TYPE`. Those
    functions that have return arguments return a `TYPE` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST_FUNC_PROTOS` is then implemented for all of the data types supported
    by `numpy.i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signed char`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned char`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned short`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned int`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Source Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.cxx` is a C++ source file that implements compilable code for each
    of the function prototypes specified in `Vector.h`. It defines a C macro `TEST_FUNCS`
    that has the same arguments and works in the same way as `TEST_FUNC_PROTOS` does
    in `Vector.h`. `TEST_FUNCS` is implemented for each of the 12 data types as above.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing SWIG Interface Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.i` is a [SWIG](http://www.swig.org) interface file that defines python
    module `Vector`. It follows the conventions for using `numpy.i` as described in
    this chapter. It defines a [SWIG](http://www.swig.org) macro `%apply_numpy_typemaps`
    that has a single argument `TYPE`. It uses the [SWIG](http://www.swig.org) directive
    `%apply` to apply the provided typemaps to the argument signatures found in `Vector.h`.
    This macro is then implemented for all of the data types supported by `numpy.i`.
    It then does a `%include "Vector.h"` to wrap all of the function prototypes in
    `Vector.h` using the typemaps in `numpy.i`.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Python Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After `make` is used to build the testing extension modules, `testVector.py`
    can be run to execute the tests. As with other scripts that use `unittest` to
    facilitate unit testing, `testVector.py` defines a class that inherits from `unittest.TestCase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this class is not run directly. Rather, it serves as a base class
    to several other python classes, each one specific to a particular data type.
    The `VectorTestCase` class stores two strings for typing information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**self.typeStr**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A string that matches one of the `SNAME` prefixes used in `Vector.h` and `Vector.cxx`.
    For example, `"double"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**self.typeCode**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A short (typically single-character) string that represents a data type in numpy
    and corresponds to `self.typeStr`. For example, if `self.typeStr` is `"double"`,
    then `self.typeCode` should be `"d"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each test defined by the `VectorTestCase` class extracts the python function
    it is trying to test by accessing the `Vector` module’s dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the case of double precision tests, this will return the python function
    `Vector.doubleLength`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a new test case class for each supported data type with a short
    definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each of these 12 classes is collected into a `unittest.TestSuite`, which is
    then executed. Errors and failures are summed together and returned as the exit
    argument. Any non-zero result indicates that at least one test did not pass.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests for the `numpy.i` [SWIG](http://www.swig.org) interface file is
    a combinatorial headache. At present, 12 different data types are supported, each
    with 74 different argument signatures, for a total of 888 typemaps supported “out
    of the box”. Each of these typemaps, in turn, might require several unit tests
    in order to verify expected behavior for both proper and improper inputs. Currently,
    this results in more than 1,000 individual unit tests executed when `make test`
    is run in the `numpy/tools/swig` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this many similar unit tests, some high-level programming techniques
    are employed, including C and [SWIG](http://www.swig.org) macros, as well as Python
    inheritance. The purpose of this document is to describe the testing infrastructure
    employed to verify that the `numpy.i` typemaps are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three independent testing frameworks supported, for one-, two-, and
    three-dimensional arrays respectively. For one-dimensional arrays, there are two
    C++ files, a header and a source, named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'that contain prototypes and code for a variety of functions that have one-dimensional
    arrays as function arguments. The file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: is a [SWIG](http://www.swig.org) interface file that defines a python module
    `Vector` that wraps the functions in `Vector.h` while utilizing the typemaps in
    `numpy.i` to correctly handle the C arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The `Makefile` calls `swig` to generate `Vector.py` and `Vector_wrap.cxx`, and
    also executes the `setup.py` script that compiles `Vector_wrap.cxx` and links
    together the extension module `_Vector.so` or `_Vector.dylib`, depending on the
    platform. This extension module and the proxy file `Vector.py` are both placed
    in a subdirectory under the `build` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual testing takes place with a Python script named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: that uses the standard Python library module `unittest`, which performs several
    tests of each function defined in `Vector.h` for each data type supported.
  prefs: []
  type: TYPE_NORMAL
- en: Two-dimensional arrays are tested in exactly the same manner. The above description
    applies, but with `Matrix` substituted for `Vector`. For three-dimensional tests,
    substitute `Tensor` for `Vector`. For four-dimensional tests, substitute `SuperTensor`
    for `Vector`. For flat in-place array tests, substitute `Flat` for `Vector`. For
    the descriptions that follow, we will reference the `Vector` tests, but the same
    information applies to `Matrix`, `Tensor` and `SuperTensor` tests.
  prefs: []
  type: TYPE_NORMAL
- en: The command `make test` will ensure that all of the test software is built and
    then run all three test scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Header Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.h` is a C++ header file that defines a C macro called `TEST_FUNC_PROTOS`
    that takes two arguments: `TYPE`, which is a data type name such as `unsigned
    int`; and `SNAME`, which is a short name for the same data type with no spaces,
    e.g. `uint`. This macro defines several function prototypes that have the prefix
    `SNAME` and have at least one argument that is an array of type `TYPE`. Those
    functions that have return arguments return a `TYPE` value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST_FUNC_PROTOS` is then implemented for all of the data types supported
    by `numpy.i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`signed char`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned char`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned short`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned int`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`long long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`unsigned long long`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Source Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.cxx` is a C++ source file that implements compilable code for each
    of the function prototypes specified in `Vector.h`. It defines a C macro `TEST_FUNCS`
    that has the same arguments and works in the same way as `TEST_FUNC_PROTOS` does
    in `Vector.h`. `TEST_FUNCS` is implemented for each of the 12 data types as above.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing SWIG Interface Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Vector.i` is a [SWIG](http://www.swig.org) interface file that defines python
    module `Vector`. It follows the conventions for using `numpy.i` as described in
    this chapter. It defines a [SWIG](http://www.swig.org) macro `%apply_numpy_typemaps`
    that has a single argument `TYPE`. It uses the [SWIG](http://www.swig.org) directive
    `%apply` to apply the provided typemaps to the argument signatures found in `Vector.h`.
    This macro is then implemented for all of the data types supported by `numpy.i`.
    It then does a `%include "Vector.h"` to wrap all of the function prototypes in
    `Vector.h` using the typemaps in `numpy.i`.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing Python Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After `make` is used to build the testing extension modules, `testVector.py`
    can be run to execute the tests. As with other scripts that use `unittest` to
    facilitate unit testing, `testVector.py` defines a class that inherits from `unittest.TestCase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this class is not run directly. Rather, it serves as a base class
    to several other python classes, each one specific to a particular data type.
    The `VectorTestCase` class stores two strings for typing information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**self.typeStr**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A string that matches one of the `SNAME` prefixes used in `Vector.h` and `Vector.cxx`.
    For example, `"double"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**self.typeCode**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A short (typically single-character) string that represents a data type in numpy
    and corresponds to `self.typeStr`. For example, if `self.typeStr` is `"double"`,
    then `self.typeCode` should be `"d"`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each test defined by the `VectorTestCase` class extracts the python function
    it is trying to test by accessing the `Vector` module’s dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the case of double precision tests, this will return the python function
    `Vector.doubleLength`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a new test case class for each supported data type with a short
    definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Each of these 12 classes is collected into a `unittest.TestSuite`, which is
    then executed. Errors and failures are summed together and returned as the exit
    argument. Any non-zero result indicates that at least one test did not pass.
  prefs: []
  type: TYPE_NORMAL
