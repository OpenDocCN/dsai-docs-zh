- en: scipy.linalg.solve_discrete_are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_discrete_are.html#scipy.linalg.solve_discrete_are](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_discrete_are.html#scipy.linalg.solve_discrete_are)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solves the discrete-time algebraic Riccati equation (DARE).
  prefs: []
  type: TYPE_NORMAL
- en: The DARE is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[A^HXA - X - (A^HXB) (R + B^HXB)^{-1} (B^HXA) + Q = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations for a solution to exist are :'
  prefs: []
  type: TYPE_NORMAL
- en: All eigenvalues of \(A\) outside the unit disc, should be controllable.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The associated symplectic pencil (See Notes), should have eigenvalues sufficiently
    away from the unit circle.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, if `e` and `s` are not both precisely `None`, then the generalized
    version of DARE
  prefs: []
  type: TYPE_NORMAL
- en: \[A^HXA - E^HXE - (A^HXB+S) (R+B^HXB)^{-1} (B^HXA+S^H) + Q = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: is solved. When omitted, `e` is assumed to be the identity and `s` is assumed
    to be the zero matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(M, M) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**b**(M, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**q**(M, M) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**r**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**e**(M, M) array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Nonsingular square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**s**(M, N) array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**balanced**bool'
  prefs: []
  type: TYPE_NORMAL
- en: The boolean that indicates whether a balancing step is performed on the data.
    The default is set to True.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**(M, M) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the discrete algebraic Riccati equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: For cases where the stable subspace of the pencil could not be isolated. See
    Notes section and the references for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve_continuous_are`](scipy.linalg.solve_continuous_are.html#scipy.linalg.solve_continuous_are
    "scipy.linalg.solve_continuous_are")'
  prefs: []
  type: TYPE_NORMAL
- en: Solves the continuous algebraic Riccati equation
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The equation is solved by forming the extended symplectic matrix pencil, as
    described in [[1]](#rd293c2673a30-1), \(H - \lambda J\) given by the block matrices
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and using a QZ decomposition method.
  prefs: []
  type: TYPE_NORMAL
- en: In this algorithm, the fail conditions are linked to the symmetry of the product
    \(U_2 U_1^{-1}\) and condition number of \(U_1\). Here, \(U\) is the 2m-by-m matrix
    that holds the eigenvectors spanning the stable subspace with 2-m rows and partitioned
    into two m-row matrices. See [[1]](#rd293c2673a30-1) and [[2]](#rd293c2673a30-2)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In order to improve the QZ decomposition accuracy, the pencil goes through a
    balancing step where the sum of absolute values of \(H\) and \(J\) rows/cols (after
    removing the diagonal entries) is balanced following the recipe given in [[3]](#rd293c2673a30-3).
    If the data has small numerical noise, balancing may amplify their effects and
    some clean up is required.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id1),[2](#id2))'
  prefs: []
  type: TYPE_NORMAL
- en: P. van Dooren , “A Generalized Eigenvalue Approach For Solving Riccati Equations.”,
    SIAM Journal on Scientific and Statistical Computing, Vol.2(2), [DOI:10.1137/0902010](https://doi.org/10.1137/0902010)
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'A.J. Laub, “A Schur Method for Solving Algebraic Riccati Equations.”, Massachusetts
    Institute of Technology. Laboratory for Information and Decision Systems. LIDS-R
    ; 859\. Available online : [http://hdl.handle.net/1721.1/1301](http://hdl.handle.net/1721.1/1301)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: P. Benner, “Symplectic Balancing of Hamiltonian Matrices”, 2001, SIAM J. Sci.
    Comput., 2001, Vol.22(5), [DOI:10.1137/S1064827500367993](https://doi.org/10.1137/S1064827500367993)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Given *a*, *b*, *q*, and *r* solve for *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
