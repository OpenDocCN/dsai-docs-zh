
<h1><span class="yiyi-st" id="yiyi-14">numpy.polynomial.legendre.legfit</span></h1>
        <blockquote>
        <p>原文：<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfit.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polynomial.legendre.legfit.html</a></p>
        <p>译者：<a href="https://github.com/wizardforcel">飞龙</a> <a href="http://usyiyi.cn/">UsyiyiCN</a></p>
        <p>校对：（虚位以待）</p>
        </blockquote>
    
<dl class="function">
<dt id="numpy.polynomial.legendre.legfit"><span class="yiyi-st" id="yiyi-15"> <code class="descclassname">numpy.polynomial.legendre.</code><code class="descname">legfit</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>deg</em>, <em>rcond=None</em>, <em>full=False</em>, <em>w=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/numpy/numpy/blob/v1.11.3/numpy/polynomial/legendre.py#L1398-L1593"><span class="viewcode-link">[source]</span></a></span></dt>
<dd><p><span class="yiyi-st" id="yiyi-16">Legendre系列的最小二乘法拟合数据。</span></p>
<p><span class="yiyi-st" id="yiyi-17">返回度数<em class="xref py py-obj">deg</em>的系数，该系数是在点<em class="xref py py-obj">x</em>给出的数据值<em class="xref py py-obj">y</em>的最小二乘拟合。</span><span class="yiyi-st" id="yiyi-18">如果<em class="xref py py-obj">y</em>是1-D，则返回的系数也将是1-D。</span><span class="yiyi-st" id="yiyi-19">如果<em class="xref py py-obj">y</em>是2-D多重拟合，对于<em class="xref py py-obj">y</em>的每一列进行一次，并且所得到的系数存储在2-D返回的相应列中。</span><span class="yiyi-st" id="yiyi-20">拟合的多项式是形式</span></p>
<div class="math">
<p></p>
</div><p><span class="yiyi-st" id="yiyi-21">其中<em class="xref py py-obj">n</em>是<em class="xref py py-obj">deg</em>。</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name">
<col class="field-body">
<tbody valign="top">
<tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-22">参数：</span></th><td class="field-body"><p class="first"><span class="yiyi-st" id="yiyi-23"><strong>x</strong>：array_like，shape（M，）</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-24">M个采样点<code class="docutils literal"><span class="pre">（x [i]，</span> <span class="pre">y [i]）</span></code>的x坐标。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-25"><strong>y</strong>：array_like，shape（M，）或（M，K）</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-26">y坐标。</span><span class="yiyi-st" id="yiyi-27">通过传递每列包含一个数据集的2D阵列，可以一次拟合共享相同x坐标的样本点的若干数据集。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-28"><strong>deg</strong>：int或1-D array_like</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-29">拟合多项式的度（s）。</span><span class="yiyi-st" id="yiyi-30">如果<em class="xref py py-obj">deg</em>是单个整数，则包括<em class="xref py py-obj">deg</em>项的所有项包括在拟合中。</span><span class="yiyi-st" id="yiyi-31">对于Numpy版本&gt; = 1.11，可以使用指定要包括的术语的度数的整数列表。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-32"><strong>rcond</strong>：float，可选</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-33">相对条件编号。</span><span class="yiyi-st" id="yiyi-34">相对于最大奇异值小于该值的奇异值将被忽略。</span><span class="yiyi-st" id="yiyi-35">默认值为len（x）* eps，其中eps是float类型的相对精度，在大多数情况下约为2e-16。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-36"><strong>full</strong>：bool，可选</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-37">开关确定返回值的性质。</span><span class="yiyi-st" id="yiyi-38">当它为False（默认值）时，只返回系数，当来自奇异值分解的True诊断信息也返回时。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-39"><strong>w</strong>：array_like，shape（<em class="xref py py-obj">M</em>，），可选</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-40">重量。</span><span class="yiyi-st" id="yiyi-41">如果不是无，则通过<em class="xref py py-obj">w [i]</em>加权每个点<code class="docutils literal"><span class="pre">(x[i],y[i])</span></code>对拟合的贡献。</span><span class="yiyi-st" id="yiyi-42">理想地，选择权重使得乘积<code class="docutils literal"><span class="pre">w[i]*y[i]</span></code>的误差都具有相同的方差。</span><span class="yiyi-st" id="yiyi-43">默认值为“无”。</span></p>
<div class="versionadded">
<p><span class="yiyi-st" id="yiyi-44"><span class="versionmodified">版本1.5.0中的新功能。</span></span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name"><span class="yiyi-st" id="yiyi-45">返回：</span></th><td class="field-body"><p class="first"><span class="yiyi-st" id="yiyi-46"><strong>coef</strong>：ndarray，shape（M，）或（M，K）</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-47">勒让德系数从低到高排序。</span><span class="yiyi-st" id="yiyi-48">如果<em class="xref py py-obj">y</em>是2-D，则<em class="xref py py-obj">y</em>的列k中的数据的系数在列<em class="xref py py-obj">k</em>中。如果<em class="xref py py-obj">deg</em>被指定为列表，则在返回的<em class="xref py py-obj">coef</em>中将未包括在拟合中的项的系数设置为等于零。</span></p>
</div></blockquote>
<p><span class="yiyi-st" id="yiyi-49"><strong>[residuals，rank，singular_values，rcond]</strong>：list</span></p>
<blockquote>
<div><p><span class="yiyi-st" id="yiyi-50">只有<em class="xref py py-obj">full</em> = True时，才会返回这些值</span></p>
<p><span class="yiyi-st" id="yiyi-51">resid – sum of squared residuals of the least squares fit rank – the numerical rank of the scaled Vandermonde matrix sv – singular values of the scaled Vandermonde matrix rcond – value of <em class="xref py py-obj">rcond</em>.</span></p>
<p><span class="yiyi-st" id="yiyi-52">有关详细信息，请参阅<em class="xref py py-obj">linalg.lstsq</em>。</span></p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name"><span class="yiyi-st" id="yiyi-53">警告：</span></th><td class="field-body"><p class="first"><span class="yiyi-st" id="yiyi-54"><strong>RankWarning</strong></span></p>
<blockquote class="last">
<div><p><span class="yiyi-st" id="yiyi-55">最小二乘法拟合中的系数矩阵的秩是不足的。</span><span class="yiyi-st" id="yiyi-56">只有在<em class="xref py py-obj">满</em> = False时，才会发出警告。</span><span class="yiyi-st" id="yiyi-57">警告可以通过关闭</span></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&apos;ignore&apos;</span><span class="p">,</span> <span class="n">RankWarning</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title"><span class="yiyi-st" id="yiyi-58">也可以看看</span></p>
<p><span class="yiyi-st" id="yiyi-59"><code class="xref py py-obj docutils literal"><span class="pre">chebfit</span></code>，<code class="xref py py-obj docutils literal"><span class="pre">polyfit</span></code>，<code class="xref py py-obj docutils literal"><span class="pre">lagfit</span></code>，<code class="xref py py-obj docutils literal"><span class="pre">hermfit</span></code>，<code class="xref py py-obj docutils literal"><span class="pre">hermefit</span></code></span></p>
<dl class="last docutils">
<dt><span class="yiyi-st" id="yiyi-60"><a class="reference internal" href="numpy.polynomial.legendre.legval.html#numpy.polynomial.legendre.legval" title="numpy.polynomial.legendre.legval"><code class="xref py py-obj docutils literal"><span class="pre">legval</span></code></a></span></dt>
<dd><span class="yiyi-st" id="yiyi-61">评估Legendre系列。</span></dd>
<dt><span class="yiyi-st" id="yiyi-62"><a class="reference internal" href="numpy.polynomial.legendre.legvander.html#numpy.polynomial.legendre.legvander" title="numpy.polynomial.legendre.legvander"><code class="xref py py-obj docutils literal"><span class="pre">legvander</span></code></a></span></dt>
<dd><span class="yiyi-st" id="yiyi-63">Vandermonde矩阵的Legendre系列。</span></dd>
<dt><span class="yiyi-st" id="yiyi-64"><a class="reference internal" href="numpy.polynomial.legendre.legweight.html#numpy.polynomial.legendre.legweight" title="numpy.polynomial.legendre.legweight"><code class="xref py py-obj docutils literal"><span class="pre">legweight</span></code></a></span></dt>
<dd><span class="yiyi-st" id="yiyi-65">Legendre权重函数（= 1）。</span></dd>
<dt><span class="yiyi-st" id="yiyi-66"><code class="xref py py-obj docutils literal"><span class="pre">linalg.lstsq</span></code></span></dt>
<dd><span class="yiyi-st" id="yiyi-67">从矩阵计算最小二乘拟合。</span></dd>
<dt><span class="yiyi-st" id="yiyi-68"><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.UnivariateSpline.html#scipy.interpolate.UnivariateSpline" title="(in SciPy v0.18.1)"><code class="xref py py-obj docutils literal"><span class="pre">scipy.interpolate.UnivariateSpline</span></code></a></span></dt>
<dd><span class="yiyi-st" id="yiyi-69">计算样条拟合。</span></dd>
</dl>
</div>
<p class="rubric"><span class="yiyi-st" id="yiyi-70">笔记</span></p>
<p><span class="yiyi-st" id="yiyi-71">解决方案是Legendre系列<em class="xref py py-obj">p</em>的系数，其使加权平方误差的和最小化</span></p>
<div class="math">
<p></p>
</div><p><span class="yiyi-st" id="yiyi-72">其中<img alt="w_j" class="math" src="../../_images/math/4eb155e91e0cd74d0e76874e46314e8c6ae17d8b.png" style="vertical-align: -4px">是权重。</span><span class="yiyi-st" id="yiyi-73">这个问题通过设置为（通常）过度确定的矩阵方程来解决</span></p>
<div class="math">
<p></p>
</div><p><span class="yiyi-st" id="yiyi-74">其中<em class="xref py py-obj">V</em>是<em class="xref py py-obj">x</em>的加权伪Vandermonde矩阵，<em class="xref py py-obj">c</em>是要求解的系数，<em class="xref py py-obj">w</em>权重和<em class="xref py py-obj">y</em>是观察值。</span><span class="yiyi-st" id="yiyi-75">然后使用<em class="xref py py-obj">V</em>的奇异值分解来求解该方程。</span></p>
<p><span class="yiyi-st" id="yiyi-76">如果<em class="xref py py-obj">V</em>的一些奇异值如此小以至于被忽略，则将发出<em class="xref py py-obj">RankWarning</em>。</span><span class="yiyi-st" id="yiyi-77">这意味着可能不良地确定系数值。</span><span class="yiyi-st" id="yiyi-78">使用较低的顺序通常会摆脱警告。</span><span class="yiyi-st" id="yiyi-79"><em class="xref py py-obj">rcond</em>参数也可以设置为小于其默认值的值，但是所得到的拟合可能是假的并且具有来自舍入误差的较大贡献。</span></p>
<p><span class="yiyi-st" id="yiyi-80">使用Legendre系列的适配器通常比使用幂级数的适配器更好，但很大程度上取决于采样点的分布和数据的平滑度。</span><span class="yiyi-st" id="yiyi-81">如果拟合的质量不够，花键可能是一个好的选择。</span></p>
<p class="rubric"><span class="yiyi-st" id="yiyi-82">参考文献</span></p>
<table class="docutils citation" frame="void" id="r64" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><span class="yiyi-st" id="yiyi-83"><a class="fn-backref" href="#id1">[R64]</a></span></td><td><span class="yiyi-st" id="yiyi-84">维基百科，“曲线拟合”，<a class="reference external" href="http://en.wikipedia.org/wiki/Curve_fitting">http://en.wikipedia.org/wiki/Curve_fitting</a></span></td></tr>
</tbody>
</table>
</dd></dl>
