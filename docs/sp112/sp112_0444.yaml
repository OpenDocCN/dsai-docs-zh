- en: scipy.optimize.differential_evolution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: scipy.optimize.differential_evolution
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution)
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finds the global minimum of a multivariate function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 找到多元函数的全局最小值。
- en: The differential evolution method [[1]](#r108fc14fa019-1) is stochastic in nature.
    It does not use gradient methods to find the minimum, and can search large areas
    of candidate space, but often requires larger numbers of function evaluations
    than conventional gradient-based techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化方法[[1]](#r108fc14fa019-1)具有随机性质。它不使用梯度方法来找到最小值，可以搜索候选空间的大面积，但通常需要比传统的基于梯度的技术更多的函数评估次数。
- en: The algorithm is due to Storn and Price [[2]](#r108fc14fa019-2).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是由斯托恩和普赖斯[[2]](#r108fc14fa019-2)提出的。
- en: 'Parameters:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**func**callable'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**func**可调用'
- en: The objective function to be minimized. Must be in the form `f(x, *args)`, where
    `x` is the argument in the form of a 1-D array and `args` is a tuple of any additional
    fixed parameters needed to completely specify the function. The number of parameters,
    N, is equal to `len(x)`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要最小化的目标函数。必须以 `f(x, *args)` 的形式存在，其中 *x* 是形式为1-D数组的参数，*args* 是任何额外的固定参数元组，用于完全指定函数。参数数量
    *N* 等于 `len(x)`。
- en: '**bounds**sequence or [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**bounds**序列或[`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")'
- en: 'Bounds for variables. There are two ways to specify the bounds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的边界。有两种指定边界的方式：
- en: Instance of [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    class.
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    类的实例。'
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(min, max)` pairs for each element in `x`, defining the finite lower and upper
    bounds for the optimizing argument of *func*.'
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(min, max)`对，用于定义 *func* 优化参数 *x* 的有限下限和上限。'
- en: The total number of bounds is used to determine the number of parameters, N.
    If there are parameters whose bounds are equal the total number of free parameters
    is `N - N_equal`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用总边界数来确定参数数量 *N*。如果有参数的边界相等，则自由参数的总数为 `N - N_equal`。
- en: '**args**tuple, optional'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**args**元组，可选'
- en: Any additional fixed parameters needed to completely specify the objective function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 用于完全指定目标函数的任何额外固定参数。
- en: '**strategy**{str, callable}, optional'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**strategy**{str, 可调用}，可选'
- en: 'The differential evolution strategy to use. Should be one of:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的差分进化策略。应为以下之一：
- en: ‘best1bin’
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘best1bin’
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best1exp’
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘best1exp’
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand1bin’
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘rand1bin’
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand1exp’
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘rand1exp’
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand2bin’
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘rand2bin’
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘rand2exp’
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘rand2exp’
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘randtobest1bin’
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘randtobest1bin’
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘randtobest1exp’
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘randtobest1exp’
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘currenttobest1bin’
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘currenttobest1bin’
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘currenttobest1exp’
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘currenttobest1exp’
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best2exp’
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘best2exp’
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘best2bin’
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘best2bin’
- en: 'The default is ‘best1bin’. Strategies that may be implemented are outlined
    in ‘Notes’. Alternatively the differential evolution strategy can be customized
    by providing a callable that constructs a trial vector. The callable must have
    the form `strategy(candidate: int, population: np.ndarray, rng=None)`, where `candidate`
    is an integer specifying which entry of the population is being evolved, `population`
    is an array of shape `(S, N)` containing all the population members (where S is
    the total population size), and `rng` is the random number generator being used
    within the solver. `candidate` will be in the range `[0, S)`. `strategy` must
    return a trial vector with shape *(N,)*. The fitness of this trial vector is compared
    against the fitness of `population[candidate]`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '默认为‘best1bin’。可以实施的策略在‘Notes’中有概述。另外，差分进化策略可以通过提供一个构建试验向量的可调用对象来进行定制化。该可调用对象必须具有形式`strategy(candidate:
    int, population: np.ndarray, rng=None)`，其中`candidate`是一个整数，指定要进化的种群条目，`population`是形状为`(S,
    N)`的数组，包含所有种群成员（其中S是总种群大小），`rng`是求解器内使用的随机数生成器。`candidate`的范围为`[0, S)`。`strategy`必须返回一个形状为*(N,)*的试验向量。将此试验向量的适应度与`population[candidate]`的适应度进行比较。'
- en: 'Changed in version 1.12.0: Customization of evolution strategy via a callable.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.12.0起更改：通过可调用对象定制进化策略。
- en: '**maxiter**int, optional'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**maxiter**int，可选'
- en: 'The maximum number of generations over which the entire population is evolved.
    The maximum number of function evaluations (with no polishing) is: `(maxiter +
    1) * popsize * (N - N_equal)`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 演化整个种群的最大代数。没有优化的最大函数评估次数为：`(maxiter + 1) * popsize * (N - N_equal)`。
- en: '**popsize**int, optional'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**popsize**int, optional'
- en: A multiplier for setting the total population size. The population has `popsize
    * (N - N_equal)` individuals. This keyword is overridden if an initial population
    is supplied via the *init* keyword. When using `init='sobol'` the population size
    is calculated as the next power of 2 after `popsize * (N - N_equal)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用于设置总种群大小的乘数。种群包含`popsize * (N - N_equal)`个个体。如果通过*init*关键字提供了初始种群，则此关键字将被覆盖。使用`init='sobol'`时，种群大小计算为`popsize
    * (N - N_equal)`后的下一个2的幂。
- en: '**tol**float, optional'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**tol**float, optional'
- en: Relative tolerance for convergence, the solving stops when `np.std(pop) <= atol
    + tol * np.abs(np.mean(population_energies))`, where and *atol* and *tol* are
    the absolute and relative tolerance respectively.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛的相对容差，当`np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))`时停止求解，其中*atol*和*tol*分别为绝对容差和相对容差。
- en: '**mutation**float or tuple(float, float), optional'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**mutation**float or tuple(float, float), optional'
- en: The mutation constant. In the literature this is also known as differential
    weight, being denoted by F. If specified as a float it should be in the range
    [0, 2]. If specified as a tuple `(min, max)` dithering is employed. Dithering
    randomly changes the mutation constant on a generation by generation basis. The
    mutation constant for that generation is taken from `U[min, max)`. Dithering can
    help speed convergence significantly. Increasing the mutation constant increases
    the search radius, but will slow down convergence.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 变异常数。在文献中，这也被称为差分权重，用F表示。如果指定为浮点数，则应在[0, 2]范围内。如果指定为元组`(min, max)`，则采用抖动。抖动会随机地在每代基础上改变变异常数。该代的变异常数取自`U[min,
    max)`。抖动可以显著加快收敛速度。增加变异常数会增加搜索半径，但会减慢收敛速度。
- en: '**recombination**float, optional'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**recombination**float, optional'
- en: The recombination constant, should be in the range [0, 1]. In the literature
    this is also known as the crossover probability, being denoted by CR. Increasing
    this value allows a larger number of mutants to progress into the next generation,
    but at the risk of population stability.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 重组常数，应在[0, 1]范围内。在文献中，这也被称为交叉概率，用CR表示。增加此值允许更多的突变体进入下一代，但会有种群稳定性的风险。
- en: '**seed**{None, int, [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)"), [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)")}, optional'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**seed**{None, int, [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(在NumPy v2.0.dev0中)"), [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(在NumPy v2.0.dev0中)")}, optional'
- en: If *seed* is None (or *np.random*), the [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)") singleton is used. If *seed* is an int, a new `RandomState`
    instance is used, seeded with *seed*. If *seed* is already a `Generator` or `RandomState`
    instance then that instance is used. Specify *seed* for repeatable minimizations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*seed*为None（或*np.random*），则使用[`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(在NumPy v2.0.dev0中)")单例。如果*seed*为整数，则使用一个新的`RandomState`实例，并用*seed*进行种子化。如果*seed*已经是`Generator`或`RandomState`实例，则使用该实例。为了重复最小化操作，请指定*seed*。
- en: '**disp**bool, optional'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**disp**bool, optional'
- en: Prints the evaluated *func* at every iteration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代时打印评估的*func*。
- en: '**callback**callable, optional'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**callback**callable, optional'
- en: 'A callable called after each iteration. Has the signature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代后调用的可调用对象，具有以下签名：
- en: '`callback(intermediate_result: OptimizeResult)`'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`callback(intermediate_result: OptimizeResult)`。'
- en: where `intermediate_result` is a keyword parameter containing an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") with attributes `x` and `fun`, the best solution
    found so far and the objective function. Note that the name of the parameter must
    be `intermediate_result` for the callback to be passed an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`intermediate_result`是一个包含[`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")属性`x`和`fun`的关键字参数，表示到目前为止找到的最佳解和目标函数值。请注意，回调函数必须传递一个名为`intermediate_result`的[`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")。
- en: 'The callback also supports a signature like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回调还支持类似的签名：
- en: '`callback(x, convergence: float=val)`'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`callback(x, convergence: float=val)`'
- en: '`val` represents the fractional value of the population convergence. When `val`
    is greater than `1.0`, the function halts.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`val`表示种群收敛的分数值。当`val`大于`1.0`时，函数停止。'
- en: Introspection is used to determine which of the signatures is invoked.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内省来确定调用的签名之一。
- en: Global minimization will halt if the callback raises `StopIteration` or returns
    `True`; any polishing is still carried out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 全局最小化将在回调引发`StopIteration`或返回`True`时终止；仍会执行任何调整。
- en: 'Changed in version 1.12.0: callback accepts the `intermediate_result` keyword.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.12.0中更改：回调接受`intermediate_result`关键字。
- en: '**polish**bool, optional'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**polish**bool，可选'
- en: If True (default), then [`scipy.optimize.minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize") with the *L-BFGS-B* method is used to polish the best
    population member at the end, which can improve the minimization slightly. If
    a constrained problem is being studied then the *trust-constr* method is used
    instead. For large problems with many constraints, polishing can take a long time
    due to the Jacobian computations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为True（默认），则最后使用*L-BFGS-B*方法的[`scipy.optimize.minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize
    "scipy.optimize.minimize")来优化最佳种群成员，这可能会略微改善最小化。如果正在研究受约束问题，则改为使用*trust-constr*方法。对于具有许多约束的大问题，由于雅可比计算，优化可能需要很长时间。
- en: '**init**str or array-like, optional'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**init**str或类数组，可选'
- en: 'Specify which type of population initialization is performed. Should be one
    of:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 指定执行的种群初始化类型。应为以下之一：
- en: ‘latinhypercube’
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘latinhypercube’
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘sobol’
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘sobol’
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘halton’
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘halton’
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ‘random’
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ‘random’
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: array specifying the initial population. The array should have shape `(S, N)`,
    where S is the total population size and N is the number of parameters. *init*
    is clipped to *bounds* before use.
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组指定初始种群。数组应具有形状`(S, N)`，其中S为总种群大小，N为参数数量。在使用之前，*init*将被剪辑到*bounds*内。
- en: The default is ‘latinhypercube’. Latin Hypercube sampling tries to maximize
    coverage of the available parameter space.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为‘latinhypercube’。拉丁超立方体采样试图最大化可用参数空间的覆盖。
- en: ‘sobol’ and ‘halton’ are superior alternatives and maximize even more the parameter
    space. ‘sobol’ will enforce an initial population size which is calculated as
    the next power of 2 after `popsize * (N - N_equal)`. ‘halton’ has no requirements
    but is a bit less efficient. See [`scipy.stats.qmc`](../stats.qmc.html#module-scipy.stats.qmc
    "scipy.stats.qmc") for more details.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ‘sobol’和‘halton’是更优的选择，甚至更大程度地最大化参数空间。‘sobol’将强制初始种群大小计算为`popsize * (N - N_equal)`后的下一个2的幂。‘halton’没有要求，但效率稍低。有关更多详情，请参见[`scipy.stats.qmc`](../stats.qmc.html#module-scipy.stats.qmc
    "scipy.stats.qmc")。
- en: ‘random’ initializes the population randomly - this has the drawback that clustering
    can occur, preventing the whole of parameter space being covered. Use of an array
    to specify a population could be used, for example, to create a tight bunch of
    initial guesses in an location where the solution is known to exist, thereby reducing
    time for convergence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ‘random’随机初始化种群 - 这样做的缺点是可能会发生聚类，从而阻止参数空间的整体覆盖。例如，可以使用数组来指定种群，以在已知解存在的位置创建一组紧密的初始猜测，从而减少收敛时间。
- en: '**atol**float, optional'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**atol**float，可选'
- en: Absolute tolerance for convergence, the solving stops when `np.std(pop) <= atol
    + tol * np.abs(np.mean(population_energies))`, where and *atol* and *tol* are
    the absolute and relative tolerance respectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 收敛的绝对容差，当`np.std(pop) <= atol + tol * np.abs(np.mean(population_energies))`时，求解停止，其中*atol*和*tol*分别是绝对容差和相对容差。
- en: '**updating**{‘immediate’, ‘deferred’}, optional'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**updating**{‘immediate’, ‘deferred’}, optional'
- en: If `'immediate'`, the best solution vector is continuously updated within a
    single generation [[4]](#r108fc14fa019-4). This can lead to faster convergence
    as trial vectors can take advantage of continuous improvements in the best solution.
    With `'deferred'`, the best solution vector is updated once per generation. Only
    `'deferred'` is compatible with parallelization or vectorization, and the *workers*
    and *vectorized* keywords can over-ride this option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是`'immediate'`，则最佳解向量在单一生成过程中持续更新[[4]](#r108fc14fa019-4)。这可以加快收敛速度，因为试验向量可以利用最佳解的持续改进。如果是`'deferred'`，则最佳解向量每代更新一次。只有`'deferred'`与并行化或向量化兼容，且*workers*和*vectorized*关键字可以覆盖此选项。
- en: New in version 1.2.0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.2.0版新增。
- en: '**workers**int or map-like callable, optional'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作者**int或类似映射的可调用对象，可选'
- en: If *workers* is an int the population is subdivided into *workers* sections
    and evaluated in parallel (uses [`multiprocessing.Pool`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(in Python v3.12)")). Supply -1 to use all available CPU cores. Alternatively
    supply a map-like callable, such as *multiprocessing.Pool.map* for evaluating
    the population in parallel. This evaluation is carried out as `workers(func, iterable)`.
    This option will override the *updating* keyword to `updating='deferred'` if `workers
    != 1`. This option overrides the *vectorized* keyword if `workers != 1`. Requires
    that *func* be pickleable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*workers*是整数，则将种群细分为*workers*部分，并并行评估（使用[`multiprocessing.Pool`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(在Python v3.12中)")）。提供-1以使用所有可用CPU核心。或者提供类似映射的可调用对象，例如*multiprocessing.Pool.map*以并行评估种群。此评估以`workers(func,
    iterable)`进行。如果`workers != 1`，此选项将覆盖*updating*关键字为`updating='deferred'`。如果`workers
    != 1`，此选项将覆盖*vectorized*关键字。要求*func*可pickle化。
- en: New in version 1.2.0.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.2.0版新增。
- en: '**constraints**{NonLinearConstraint, LinearConstraint, Bounds}'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**约束条件**{非线性约束，线性约束，边界}'
- en: Constraints on the solver, over and above those applied by the *bounds* kwd.
    Uses the approach by Lampinen [[5]](#r108fc14fa019-5).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解算器的约束条件，除了*bounds* kwd应用的约束外。使用Lampinen的方法[[5]](#r108fc14fa019-5)。
- en: New in version 1.4.0.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.4.0版新增。
- en: '**x0**None or array-like, optional'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**x0**None或类似数组，可选'
- en: Provides an initial guess to the minimization. Once the population has been
    initialized this vector replaces the first (best) member. This replacement is
    done even if *init* is given an initial population. `x0.shape == (N,)`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 提供最小化的初始猜测。一旦种群被初始化，此向量替换第一个（最佳）成员。即使*init*给出了初始种群，也会进行此替换。`x0.shape == (N,)`。
- en: New in version 1.7.0.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.7.0版新增。
- en: '**integrality**1-D array, optional'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**整数性**1-D数组，可选'
- en: For each decision variable, a boolean value indicating whether the decision
    variable is constrained to integer values. The array is broadcast to `(N,)`. If
    any decision variables are constrained to be integral, they will not be changed
    during polishing. Only integer values lying between the lower and upper bounds
    are used. If there are no integer values lying between the bounds then a *ValueError*
    is raised.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个决策变量，一个布尔值，指示决策变量是否约束为整数值。该数组广播到`(N,)`。如果有任何决策变量被约束为整数，则在精炼过程中它们不会改变。只使用介于下限和上限之间的整数值。如果在边界之间没有整数值，则会引发*ValueError*。
- en: New in version 1.9.0.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.9.0版新增。
- en: '**vectorized**bool, optional'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量化**bool，可选'
- en: If `vectorized is True`, *func* is sent an *x* array with `x.shape == (N, S)`,
    and is expected to return an array of shape `(S,)`, where *S* is the number of
    solution vectors to be calculated. If constraints are applied, each of the functions
    used to construct a *Constraint* object should accept an *x* array with `x.shape
    == (N, S)`, and return an array of shape `(M, S)`, where *M* is the number of
    constraint components. This option is an alternative to the parallelization offered
    by *workers*, and may help in optimization speed by reducing interpreter overhead
    from multiple function calls. This keyword is ignored if `workers != 1`. This
    option will override the *updating* keyword to `updating='deferred'`. See the
    notes section for further discussion on when to use `'vectorized'`, and when to
    use `'workers'`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`vectorized`为True，则将使用形状为`(N, S)`的*x*数组发送给*func*，并期望返回一个形状为`(S,)`的数组，其中*S*是要计算的解向量数量。如果应用了约束条件，则用于构建*Constraint*对象的每个函数应接受形状为`(N,
    S)`的*x*数组，并返回形状为`(M, S)`的数组，其中*M*是约束组件的数量。这个选项是*workers*提供的并行化的替代方案，并且可以通过减少从多个函数调用中的解释器开销来提高优化速度。如果`workers
    != 1`，则将忽略此关键字。此选项将覆盖*updating*关键字为`updating='deferred'`。有关何时使用`'vectorized'`和何时使用`'workers'`的进一步讨论，请参见备注部分。
- en: New in version 1.9.0.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.9.0中的更新。
- en: 'Returns:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**res**OptimizeResult'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**res**OptimizeResult'
- en: 'The optimization result represented as a [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") object. Important attributes are: `x` the solution
    array, `success` a Boolean flag indicating if the optimizer exited successfully,
    `message` which describes the cause of the termination, `population` the solution
    vectors present in the population, and `population_energies` the value of the
    objective function for each entry in `population`. See [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") for a description of other attributes. If *polish*
    was employed, and a lower minimum was obtained by the polishing, then OptimizeResult
    also contains the `jac` attribute. If the eventual solution does not satisfy the
    applied constraints `success` will be *False*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 优化结果表示为[`OptimizeResult`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")对象。重要属性包括：`x`解向量数组，`success`布尔标志，指示优化器是否成功退出，`message`描述终止原因，`population`种群中的解向量以及`population_energies`每个`population`条目的目标函数值。有关其他属性的描述，请参见[`OptimizeResult`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult")。如果使用了*polish*，并且通过打磨获得了更低的最小值，则OptimizeResult还包含`jac`属性。如果最终解决方案不满足应用的约束条件，则`success`将为*False*。
- en: Notes
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'Differential evolution is a stochastic population based method that is useful
    for global optimization problems. At each pass through the population the algorithm
    mutates each candidate solution by mixing with other candidate solutions to create
    a trial candidate. There are several strategies [[3]](#r108fc14fa019-3) for creating
    trial candidates, which suit some problems more than others. The ‘best1bin’ strategy
    is a good starting point for many systems. In this strategy two members of the
    population are randomly chosen. Their difference is used to mutate the best member
    (the ‘best’ in ‘best1bin’), \(x_0\), so far:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化是一种基于随机种群的方法，适用于全局优化问题。在每次种群遍历过程中，算法通过与其他候选解混合来生成一个试验候选解，对每个候选解进行突变。有几种策略[[3]](#r108fc14fa019-3)用于创建试验候选解，适用于不同的问题。"best1bin"策略对许多系统而言是一个良好的起点。在这种策略中，随机选择种群中的两个成员。他们的差异用于突变迄今为止最佳成员（"best"在"best1bin"中的意思），\(x_0\)：
- en: \[b' = x_0 + mutation * (x_{r_0} - x_{r_1})\]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: \[b' = x_0 + mutation * (x_{r_0} - x_{r_1})\]
- en: A trial vector is then constructed. Starting with a randomly chosen ith parameter
    the trial is sequentially filled (in modulo) with parameters from `b'` or the
    original candidate. The choice of whether to use `b'` or the original candidate
    is made with a binomial distribution (the ‘bin’ in ‘best1bin’) - a random number
    in [0, 1) is generated. If this number is less than the *recombination* constant
    then the parameter is loaded from `b'`, otherwise it is loaded from the original
    candidate. The final parameter is always loaded from `b'`. Once the trial candidate
    is built its fitness is assessed. If the trial is better than the original candidate
    then it takes its place. If it is also better than the best overall candidate
    it also replaces that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后构造一个试验向量。从随机选择的第i个参数开始，依次用来自`b'`或原始候选者的参数填充（取模）。使用`b'`或原始候选者的选择是通过二项分布（'best1bin'中的'bin'）进行的
    - 生成一个介于[0, 1)的随机数。如果此数小于*recombination*常数，则参数从`b'`加载，否则从原始候选者加载。最后一个参数始终从`b'`加载。构建完试验候选者后，评估其适应度。如果试验结果比原始候选者好，则替换它。如果它还优于整体最佳候选者，则也替换该候选者。
- en: The other strategies available are outlined in Qiang and Mitchell (2014) [[3]](#r108fc14fa019-3).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的策略见Qiang和Mitchell（2014）[[3]](https://r108fc14fa019-3)。
- en: '\[ \begin{align}\begin{aligned}rand1* : b'' = x_{r_0} + mutation*(x_{r_1} -
    x_{r_2})\\rand2* : b'' = x_{r_0} + mutation*(x_{r_1} + x_{r_2} - x_{r_3} - x_{r_4})\\best1*
    : b'' = x_0 + mutation*(x_{r_0} - x_{r_1})\\best2* : b'' = x_0 + mutation*(x_{r_0}
    + x_{r_1} - x_{r_2} - x_{r_3})\\currenttobest1* : b'' = x_i + mutation*(x_0 -
    x_i + x_{r_0} - x_{r_1})\\randtobest1* : b'' = x_{r_0} + mutation*(x_0 - x_{r_0}
    + x_{r_1} - x_{r_2})\end{aligned}\end{align} \]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '\[ \begin{align}\begin{aligned}rand1* : b'' = x_{r_0} + mutation*(x_{r_1} -
    x_{r_2})\\rand2* : b'' = x_{r_0} + mutation*(x_{r_1} + x_{r_2} - x_{r_3} - x_{r_4})\\best1*
    : b'' = x_0 + mutation*(x_{r_0} - x_{r_1})\\best2* : b'' = x_0 + mutation*(x_{r_0}
    + x_{r_1} - x_{r_2} - x_{r_3})\\currenttobest1* : b'' = x_i + mutation*(x_0 -
    x_i + x_{r_0} - x_{r_1})\\randtobest1* : b'' = x_{r_0} + mutation*(x_0 - x_{r_0}
    + x_{r_1} - x_{r_2})\end{aligned}\end{align} \]'
- en: where the integers \(r_0, r_1, r_2, r_3, r_4\) are chosen randomly from the
    interval [0, NP) with *NP* being the total population size and the original candidate
    having index *i*. The user can fully customize the generation of the trial candidates
    by supplying a callable to `strategy`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其中整数\(r_0, r_1, r_2, r_3, r_4\)从区间[0, NP)随机选择，其中*NP*是总体大小，原始候选者索引为*i*。用户可以通过向`strategy`提供可调用对象来完全自定义试验候选者的生成方式。
- en: To improve your chances of finding a global minimum use higher *popsize* values,
    with higher *mutation* and (dithering), but lower *recombination* values. This
    has the effect of widening the search radius, but slowing convergence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要提高找到全局最小值的机会，可以使用更高的*popsize*值，更高的*mutation*值和（抖动），但更低的*recombination*值。这样做会扩大搜索半径，但会减慢收敛速度。
- en: By default the best solution vector is updated continuously within a single
    iteration (`updating='immediate'`). This is a modification [[4]](#r108fc14fa019-4)
    of the original differential evolution algorithm which can lead to faster convergence
    as trial vectors can immediately benefit from improved solutions. To use the original
    Storn and Price behaviour, updating the best solution once per iteration, set
    `updating='deferred'`. The `'deferred'` approach is compatible with both parallelization
    and vectorization (`'workers'` and `'vectorized'` keywords). These may improve
    minimization speed by using computer resources more efficiently. The `'workers'`
    distribute calculations over multiple processors. By default the Python [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(in Python v3.12)") module is used, but other approaches are also possible, such
    as the Message Passing Interface (MPI) used on clusters [[6]](#r108fc14fa019-6)
    [[7]](#r108fc14fa019-7). The overhead from these approaches (creating new Processes,
    etc) may be significant, meaning that computational speed doesn’t necessarily
    scale with the number of processors used. Parallelization is best suited to computationally
    expensive objective functions. If the objective function is less expensive, then
    `'vectorized'` may aid by only calling the objective function once per iteration,
    rather than multiple times for all the population members; the interpreter overhead
    is reduced.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，最佳解向量在单次迭代中持续更新（`updating='immediate'`）。这是对原始差分进化算法的修改[[4]](#r108fc14fa019-4)，可以使试验向量立即从改进的解决方案中获益。要使用斯托恩和普莱斯的原始行为，即每次迭代更新一次最佳解，设置`updating='deferred'`。`'deferred'`方法既兼容并行化和矢量化（`'workers'`和`'vectorized'`关键字）。这些方法可能通过更有效地利用计算资源来提高最小化速度。`'workers'`将计算分布到多个处理器上。默认情况下，Python的[`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(在Python v3.12中)")模块用于此，但也可以使用其他方法，例如在集群上使用消息传递接口（MPI）[[6]](#r108fc14fa019-6)
    [[7]](#r108fc14fa019-7)。这些方法（创建新进程等）可能会带来一定的开销，这意味着计算速度并不一定随使用处理器数量的增加而线性扩展。并行化最适合计算密集型目标函数。如果目标函数较为简单，则`'vectorized'`可能会有所帮助，因为它每次迭代仅调用一次目标函数，而不是为所有种群成员多次调用；解释器开销减少。
- en: New in version 0.15.0.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 0.15.0版新增内容。
- en: References
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[1](#id1)]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1](#id1)]'
- en: Differential evolution, Wikipedia, [http://en.wikipedia.org/wiki/Differential_evolution](http://en.wikipedia.org/wiki/Differential_evolution)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 差分进化，维基百科，[http://en.wikipedia.org/wiki/Differential_evolution](http://en.wikipedia.org/wiki/Differential_evolution)
- en: '[[2](#id2)]'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[[2](#id2)]'
- en: Storn, R and Price, K, Differential Evolution - a Simple and Efficient Heuristic
    for Global Optimization over Continuous Spaces, Journal of Global Optimization,
    1997, 11, 341 - 359.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 斯托恩（Storn, R）和普莱斯（Price, K），差分进化 - 一种简单高效的连续空间全局优化启发式算法，全球优化期刊，1997年，11，341
    - 359。
- en: '[3] ([1](#id5),[2](#id6))'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] ([1](#id5),[2](#id6))'
- en: Qiang, J., Mitchell, C., A Unified Differential Evolution Algorithm for Global
    Optimization, 2014, [https://www.osti.gov/servlets/purl/1163659](https://www.osti.gov/servlets/purl/1163659)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 强（Qiang, J.），米切尔（Mitchell, C.），统一差分进化算法用于全局优化，2014年，[https://www.osti.gov/servlets/purl/1163659](https://www.osti.gov/servlets/purl/1163659)
- en: '[4] ([1](#id3),[2](#id7))'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] ([1](#id3),[2](#id7))'
- en: Wormington, M., Panaccione, C., Matney, K. M., Bowen, D. K., - Characterization
    of structures from X-ray scattering data using genetic algorithms, Phil. Trans.
    R. Soc. Lond. A, 1999, 357, 2827-2848
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 沃明顿（Wormington, M.），帕纳乔内（Panaccione, C.），马特尼（Matney, K. M.），鲍文（Bowen, D. K.），利用遗传算法从X射线散射数据中表征结构，伦敦皇家学会A类学报，1999年，357，2827-2848
- en: '[[5](#id4)]'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[[5](#id4)]'
- en: Lampinen, J., A constraint handling approach for the differential evolution
    algorithm. Proceedings of the 2002 Congress on Evolutionary Computation. CEC’02
    (Cat. No. 02TH8600). Vol. 2\. IEEE, 2002.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 兰皮宁（Lampinen, J.），差分进化算法的约束处理方法。2002年进化计算大会论文集。CEC’02（Cat. No. 02TH8600）。第2卷。IEEE，2002年。
- en: '[[6](#id8)]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[[6](#id8)]'
- en: '[https://mpi4py.readthedocs.io/en/stable/](https://mpi4py.readthedocs.io/en/stable/)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mpi4py.readthedocs.io/en/stable/](https://mpi4py.readthedocs.io/en/stable/)'
- en: '[[7](#id9)]'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7](#id9)]'
- en: '[https://schwimmbad.readthedocs.io/en/latest/](https://schwimmbad.readthedocs.io/en/latest/)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://schwimmbad.readthedocs.io/en/latest/](https://schwimmbad.readthedocs.io/en/latest/)'
- en: Examples
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: Let us consider the problem of minimizing the Rosenbrock function. This function
    is implemented in [`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen "scipy.optimize.rosen")
    in [`scipy.optimize`](../optimize.html#module-scipy.optimize "scipy.optimize").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑最小化 Rosenbrock 函数的问题。这个函数在 [`rosen`](scipy.optimize.rosen.html#scipy.optimize.rosen
    "scipy.optimize.rosen") 中实现于 [`scipy.optimize`](../optimize.html#module-scipy.optimize
    "scipy.optimize")。
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now repeat, but with parallelization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复，但使用并行化。
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s do a constrained minimization.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行有约束的最小化。
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We add the constraint that the sum of `x[0]` and `x[1]` must be less than or
    equal to 1.9\. This is a linear constraint, which may be written `A @ x <= 1.9`,
    where `A = array([[1, 1]])`. This can be encoded as a [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") instance:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增加约束条件，即 `x[0]` 和 `x[1]` 的和必须小于或等于 1.9。这是一个线性约束，可以写成 `A @ x <= 1.9`，其中 `A
    = array([[1, 1]])`。这可以编码为 [`LinearConstraint`](scipy.optimize.LinearConstraint.html#scipy.optimize.LinearConstraint
    "scipy.optimize.LinearConstraint") 实例：
- en: '[PRE4]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Specify limits using a [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds
    "scipy.optimize.Bounds") object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Bounds`](scipy.optimize.Bounds.html#scipy.optimize.Bounds "scipy.optimize.Bounds")
    对象指定限制。
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next find the minimum of the Ackley function ([https://en.wikipedia.org/wiki/Test_functions_for_optimization](https://en.wikipedia.org/wiki/Test_functions_for_optimization)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找 Ackley 函数的最小值（[https://en.wikipedia.org/wiki/Test_functions_for_optimization](https://en.wikipedia.org/wiki/Test_functions_for_optimization)）。
- en: '[PRE6]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Ackley function is written in a vectorized manner, so the `'vectorized'`
    keyword can be employed. Note the reduced number of function evaluations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ackley 函数以矢量化方式编写，因此可以使用 `'vectorized'` 关键字。请注意减少的函数评估次数。
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following custom strategy function mimics ‘best1bin’:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下自定义策略函数模仿 'best1bin'：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
