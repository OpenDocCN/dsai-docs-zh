# scipy.signal.istft

> 原文链接：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.istft.html#scipy.signal.istft](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.istft.html#scipy.signal.istft)

```py
scipy.signal.istft(Zxx, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None, input_onesided=True, boundary=True, time_axis=-1, freq_axis=-2, scaling='spectrum')
```

执行反短时傅立叶变换（iSTFT）。

传统

此函数被视为遗留版本，将不再接收更新。这也可能意味着它将在未来的SciPy版本中删除。[`ShortTimeFFT`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")是一个新的STFT / ISTFT实现，具有更多功能。可以在[SciPy用户指南](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/signal.html#tutorial-stft-legacy-stft)的[短时傅立叶变换](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/signal.html#tutorial-stft)部分找到这些实现的比较。

参数：

**Zxx**array_like

要重构的信号的STFT。如果传递的是纯实数组，则将其转换为复杂数据类型。

**fs**float，可选

时间序列的采样频率。默认为1.0。

**window**str或tuple或array_like，可选

所需使用的窗口。如果*window*是字符串或元组，则将其传递给[`get_window`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window "scipy.signal.get_window")以生成窗口值，默认为DFT-even。详见[`get_window`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window "scipy.signal.get_window")获取窗口列表和所需参数。如果*window*是array_like，则直接用作窗口，其长度必须为nperseg。默认为Hann窗口。必须与用于生成STFT的窗口匹配，以确保忠实反演。

**nperseg**int，可选

数据点数对应于每个STFT段。如果每段数据点数为奇数，或者STFT通过`nfft > nperseg`进行填充，则必须指定此参数。如果为*None*，则其值取决于*Zxx*和*input_onesided*的形状。如果*input_onesided*为True，则`nperseg=2*(Zxx.shape[freq_axis] - 1)`。否则，`nperseg=Zxx.shape[freq_axis]`。默认为*None*。

**noverlap**int，可选

点之间重叠的点数。如果为*None*，则为段长度的一半。默认为*None*。在指定时，必须满足COLA约束（参见下面的注释），并且应与用于生成STFT的参数匹配。默认为*None*。

**nfft**int，可选

FFT点数对应于每个STFT段。如果STFT通过`nfft > nperseg`进行填充，则必须指定此参数。如果为*None*，则默认值与*nperseg*相同，详见上文，但有一例外：如果*input_onesided*为True且`nperseg==2*Zxx.shape[freq_axis] - 1`，则*nfft*也取该值。这种情况允许使用`nfft=None`正确反演奇数长度未填充的STFT。默认为*None*。

**input_onesided**bool，可选

如果为*True*，将输入数组解释为单边FFT，例如由[`stft`](scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft")返回的`return_onesided=True`和[`numpy.fft.rfft`](https://numpy.org/devdocs/reference/generated/numpy.fft.rfft.html#numpy.fft.rfft "(in NumPy v2.0.dev0)")。如果为*False*，将输入解释为双边FFT。默认为*True*。

**boundary**bool, 可选

指定输入信号是否通过向 [`stft`](scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft") 提供非*None* `boundary` 参数来在其边界上扩展。默认为*True*。

**time_axis**int, 可选

STFT的时间段所在位置；默认为最后一轴（即`axis=-1`）。

**freq_axis**int, 可选

STFT的频率轴所在位置；默认为倒数第二轴（即`axis=-2`）。

**scaling: {‘spectrum’, ‘psd’}**

默认的'spectrum'缩放允许解释*Zxx*的每个频率线为幅度谱。'psd'选项将每行缩放到功率谱密度 - 允许通过数值积分计算信号的能量 `abs(Zxx)**2`。

返回:

**t**ndarray

输出数据数组的时间。

**x**ndarray

*Zxx*的逆短时傅立叶变换。

另请参阅

[`stft`](scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft")

短时傅立叶变换

[`ShortTimeFFT`](scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")

更多功能的新STFT/ISTFT实现。

[`check_COLA`](scipy.signal.check_COLA.html#scipy.signal.check_COLA "scipy.signal.check_COLA")

检查是否满足Constant OverLap Add (COLA)约束

[`check_NOLA`](scipy.signal.check_NOLA.html#scipy.signal.check_NOLA "scipy.signal.check_NOLA")

检查是否满足Nonzero Overlap Add (NOLA)约束

注意事项

为了通过[`istft`](#scipy.signal.istft "scipy.signal.istft")反转STFT以进行反STFT，信号窗必须遵守“非零重叠添加”（NOLA）约束：

\[\sum_{t}w^{2}[n-tH] \ne 0\]

这确保了出现在重叠添加重建方程分母中的归一化因子

\[x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}\]

不为零。使用[`check_NOLA`](scipy.signal.check_NOLA.html#scipy.signal.check_NOLA "scipy.signal.check_NOLA")函数可以检查NOLA约束。

已修改的STFT（通过掩蔽或其他方式）不能保证与确切可实现信号对应。该函数通过最小二乘估计算法实现了iSTFT，该算法详细说明见[[2]](#r9884493677cb-2)，其生成的信号最小化了返回信号的STFT和修改后STFT之间的均方误差。

版本0.19.0中的新功能。

参考文献

[1]

Oppenheim, Alan V., Ronald W. Schafer, John R. Buck “离散时间信号处理”，Prentice Hall，1999年。

[[2](#id1)]

Daniel W. Griffin, Jae S. Lim “从修改后的短时傅里叶变换估计信号”, IEEE 1984, 10.1109/TASSP.1984.1164317

示例

```py
>>> import numpy as np
>>> from scipy import signal
>>> import matplotlib.pyplot as plt
>>> rng = np.random.default_rng() 
```

生成一个测试信号，一个2 Vrms的50Hz正弦波，受1024 Hz采样的0.001 V**2/Hz白噪声的影响。

```py
>>> fs = 1024
>>> N = 10*fs
>>> nperseg = 512
>>> amp = 2 * np.sqrt(2)
>>> noise_power = 0.001 * fs / 2
>>> time = np.arange(N) / float(fs)
>>> carrier = amp * np.sin(2*np.pi*50*time)
>>> noise = rng.normal(scale=np.sqrt(noise_power),
...                    size=time.shape)
>>> x = carrier + noise 
```

计算STFT，并绘制其幅度

```py
>>> f, t, Zxx = signal.stft(x, fs=fs, nperseg=nperseg)
>>> plt.figure()
>>> plt.pcolormesh(t, f, np.abs(Zxx), vmin=0, vmax=amp, shading='gouraud')
>>> plt.ylim([f[1], f[-1]])
>>> plt.title('STFT Magnitude')
>>> plt.ylabel('Frequency [Hz]')
>>> plt.xlabel('Time [sec]')
>>> plt.yscale('log')
>>> plt.show() 
```

![../../_images/scipy-signal-istft-1_00_00.png](../Images/b5004a747ecfc2233dc72eeab37e2bdc.png)

将幅度为载波幅度的10%或更少的分量置零，然后通过逆STFT转换回时间序列

```py
>>> Zxx = np.where(np.abs(Zxx) >= amp/10, Zxx, 0)
>>> _, xrec = signal.istft(Zxx, fs) 
```

将清理后的信号与原始和真实的载波信号进行比较。

```py
>>> plt.figure()
>>> plt.plot(time, x, time, xrec, time, carrier)
>>> plt.xlim([2, 2.1])
>>> plt.xlabel('Time [sec]')
>>> plt.ylabel('Signal')
>>> plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
>>> plt.show() 
```

![../../_images/scipy-signal-istft-1_01_00.png](../Images/13bac3031e2f7077ae84ed15aad87c12.png)

注意，清理后的信号并不像原始信号那样突然开始，因为某些瞬态的系数也被移除了：

```py
>>> plt.figure()
>>> plt.plot(time, x, time, xrec, time, carrier)
>>> plt.xlim([0, 0.1])
>>> plt.xlabel('Time [sec]')
>>> plt.ylabel('Signal')
>>> plt.legend(['Carrier + Noise', 'Filtered via STFT', 'True Carrier'])
>>> plt.show() 
```

![../../_images/scipy-signal-istft-1_02_00.png](../Images/d7f9032568b1d5274cb0b56cb3f1c48c.png)
