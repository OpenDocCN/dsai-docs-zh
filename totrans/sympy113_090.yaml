- en: Diophantine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/solvers/diophantine.html](https://docs.sympy.org/latest/modules/solvers/diophantine.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a beginner-friendly guide focused on solving Diophantine equations, refer
    to [Solve a Diophantine Equation Algebraically](../../guides/solving/solve-diophantine-equation.html#solving-guide-diophantine).
  prefs: []
  type: TYPE_NORMAL
- en: Diophantine equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word “Diophantine” comes with the name Diophantus, a mathematician lived
    in the great city of Alexandria sometime around 250 AD. Often referred to as the
    “father of Algebra”, Diophantus in his famous work “Arithmetica” presented 150
    problems that marked the early beginnings of number theory, the field of study
    about integers and their properties. Diophantine equations play a central and
    an important part in number theory.
  prefs: []
  type: TYPE_NORMAL
- en: We call a “Diophantine equation” to an equation of the form, \(f(x_1, x_2, \ldots
    x_n) = 0\) where \(n \geq 2\) and \(x_1, x_2, \ldots x_n\) are integer variables.
    If we can find \(n\) integers \(a_1, a_2, \ldots a_n\) such that \(x_1 = a_1,
    x_2 = a_2, \ldots x_n = a_n\) satisfies the above equation, we say that the equation
    is solvable. You can read more about Diophantine equations in [[1]](#id5) and
    [[2]](#id6).
  prefs: []
  type: TYPE_NORMAL
- en: Currently, following five types of Diophantine equations can be solved using
    [`diophantine()`](#sympy.solvers.diophantine.diophantine.diophantine "sympy.solvers.diophantine.diophantine.diophantine")
    and other helper functions of the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear Diophantine equations: \(a_1x_1 + a_2x_2 + \ldots + a_nx_n = b\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General binary quadratic equation: \(ax^2 + bxy + cy^2 + dx + ey + f = 0\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Homogeneous ternary quadratic equation: \(ax^2 + by^2 + cz^2 + dxy + eyz +
    fzx = 0\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extended Pythagorean equation: \(a_{1}x_{1}^2 + a_{2}x_{2}^2 + \ldots + a_{n}x_{n}^2
    = a_{n+1}x_{n+1}^2\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'General sum of squares: \(x_{1}^2 + x_{2}^2 + \ldots + x_{n}^2 = k\)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module contains [`diophantine()`](#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine") and helper functions that
    are needed to solve certain Diophantine equations. It’s structured in the following
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[`diophantine()`](#sympy.solvers.diophantine.diophantine.diophantine "sympy.solvers.diophantine.diophantine.diophantine")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve "sympy.solvers.diophantine.diophantine.diop_solve")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`classify_diop()`](#sympy.solvers.diophantine.diophantine.classify_diop "sympy.solvers.diophantine.diophantine.classify_diop")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_linear()`](#sympy.solvers.diophantine.diophantine.diop_linear "sympy.solvers.diophantine.diophantine.diop_linear")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_quadratic
    "sympy.solvers.diophantine.diophantine.diop_quadratic")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_ternary_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_ternary_quadratic_normal()`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic_normal
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic_normal")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_general_pythagorean()`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_general_sum_of_squares()`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`diop_general_sum_of_even_powers()`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_even_powers
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_even_powers")'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`merge_solution()`](#sympy.solvers.diophantine.diophantine.merge_solution
    "sympy.solvers.diophantine.diophantine.merge_solution")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When an equation is given to [`diophantine()`](#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine"), it factors the equation(if
    possible) and solves the equation given by each factor by calling [`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve
    "sympy.solvers.diophantine.diophantine.diop_solve") separately. Then all the results
    are combined using [`merge_solution()`](#sympy.solvers.diophantine.diophantine.merge_solution
    "sympy.solvers.diophantine.diophantine.merge_solution").
  prefs: []
  type: TYPE_NORMAL
- en: '[`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve "sympy.solvers.diophantine.diophantine.diop_solve")
    internally uses [`classify_diop()`](#sympy.solvers.diophantine.diophantine.classify_diop
    "sympy.solvers.diophantine.diophantine.classify_diop") to find the type of the
    equation(and some other details) given to it and then calls the appropriate solver
    function based on the type returned. For example, if [`classify_diop()`](#sympy.solvers.diophantine.diophantine.classify_diop
    "sympy.solvers.diophantine.diophantine.classify_diop") returned “linear” as the
    type of the equation, then [`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve
    "sympy.solvers.diophantine.diophantine.diop_solve") calls [`diop_linear()`](#sympy.solvers.diophantine.diophantine.diop_linear
    "sympy.solvers.diophantine.diophantine.diop_linear") to solve the equation.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the functions, [`diop_linear()`](#sympy.solvers.diophantine.diophantine.diop_linear
    "sympy.solvers.diophantine.diophantine.diop_linear"), [`diop_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_quadratic
    "sympy.solvers.diophantine.diophantine.diop_quadratic"), [`diop_ternary_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic"), [`diop_general_pythagorean()`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean") and [`diop_general_sum_of_squares()`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares") solves a
    specific type of equations and the type can be easily guessed by it’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these functions, there are a considerable number of other functions
    in the “Diophantine Module” and all of them are listed under User functions and
    Internal functions.
  prefs: []
  type: TYPE_NORMAL
- en: Tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s import the highest API of the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we start solving the equations, we need to define the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start by solving the easiest type of Diophantine equations, i.e. linear
    Diophantine equations. Let’s solve \(2x + 3y = 5\). Note that although we write
    the equation in the above form, when we input the equation to any of the functions
    in Diophantine module, it needs to be in the form \(eq = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that stepping one more level below the highest API, we can solve the very
    same equation by calling [`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve
    "sympy.solvers.diophantine.diophantine.diop_solve").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that it returns a tuple rather than a set. [`diophantine()`](#sympy.solvers.diophantine.diophantine.diophantine
    "sympy.solvers.diophantine.diophantine.diophantine") always return a set of tuples.
    But [`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve "sympy.solvers.diophantine.diophantine.diop_solve")
    may return a single tuple or a set of tuples depending on the type of the equation
    given.
  prefs: []
  type: TYPE_NORMAL
- en: We can also solve this equation by calling [`diop_linear()`](#sympy.solvers.diophantine.diophantine.diop_linear
    "sympy.solvers.diophantine.diophantine.diop_linear"), which is what [`diop_solve()`](#sympy.solvers.diophantine.diophantine.diop_solve
    "sympy.solvers.diophantine.diophantine.diop_solve") calls internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the given equation has no solutions then the outputs will look like below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that except for the highest level API, in case of no solutions, a tuple
    of \(None\) are returned. Size of the tuple is the same as the number of variables.
    Also, one can specifically set the parameter to be used in the solutions by passing
    a customized parameter. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For linear Diophantine equations, the customized parameter is the prefix used
    for each free variable in the solution. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the solution above, m_0 and m_1 are independent free variables.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that for the moment, users can set the parameter only for linear
    Diophantine equations and binary quadratic equations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try solving a binary quadratic equation which is an equation with two
    variables and has a degree of two. Before trying to solve these equations, an
    idea about various cases associated with the equation would help a lot. Please
    refer [[3]](#id7) and [[4]](#id8) for detailed analysis of different cases and
    the nature of the solutions. Let us define \(\Delta = b^2 - 4ac\) w.r.t. the binary
    quadratic \(ax^2 + bxy + cy^2 + dx + ey + f = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: When \(\Delta < 0\), there are either no solutions or only a finite number of
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the above equation \(\Delta = (-4)^2 - 4*1*8 = -16\) and hence only a finite
    number of solutions exist.
  prefs: []
  type: TYPE_NORMAL
- en: When \(\Delta = 0\) we might have either no solutions or parameterized solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting case is when \(\Delta > 0\) and it is not a perfect square.
    In this case, the equation has either no solutions or an infinite number of solutions.
    Consider the below cases where \(\Delta = 8\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here \(n\) is an integer. Although x_n and y_n may not look like integers, substituting
    in specific values for n (and simplifying) shows that they are. For example consider
    the following example where we set n equal to 9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Any binary quadratic of the form \(ax^2 + bxy + cy^2 + dx + ey + f = 0\) can
    be transformed to an equivalent form \(X^2 - DY^2 = N\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So, the above equation is equivalent to the equation \(X^2 - 5Y^2 = 920\) after
    a linear transformation. If we want to find the linear transformation, we can
    use [`transformation_to_DN()`](#sympy.solvers.diophantine.diophantine.transformation_to_DN
    "sympy.solvers.diophantine.diophantine.transformation_to_DN")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here A is a 2 X 2 matrix and B is a 2 X 1 matrix such that the transformation
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{bmatrix} X\\Y \end{bmatrix} = A \begin{bmatrix} x\\y \end{bmatrix}
    + B\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: gives the equation \(X^2 -5Y^2 = 920\). Values of \(A\) and \(B\) are as belows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can solve an equation of the form \(X^2 - DY^2 = N\) by passing \(D\) and
    \(N\) to [`diop_DN()`](#sympy.solvers.diophantine.diophantine.diop_DN "sympy.solvers.diophantine.diophantine.diop_DN")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, our equation has no solution.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s turn to homogeneous ternary quadratic equations. These equations are
    of the form \(ax^2 + by^2 + cz^2 + dxy + eyz + fzx = 0\). These type of equations
    either have infinitely many solutions or no solutions (except the obvious solution
    (0, 0, 0))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you are only interested in a base solution rather than the parameterized
    general solution (to be more precise, one of the general solutions), you can use
    [`diop_ternary_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[`diop_ternary_quadratic()`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic") first converts
    the given equation to an equivalent equation of the form \(w^2 = AX^2 + BY^2\)
    and then it uses [`descent()`](#sympy.solvers.diophantine.diophantine.descent
    "sympy.solvers.diophantine.diophantine.descent") to solve the latter equation.
    You can refer to the docs of [`transformation_to_normal()`](#sympy.solvers.diophantine.diophantine.transformation_to_normal
    "sympy.solvers.diophantine.diophantine.transformation_to_normal") to find more
    on this. The equation \(w^2 = AX^2 + BY^2\) can be solved more easily by using
    the Aforementioned [`descent()`](#sympy.solvers.diophantine.diophantine.descent
    "sympy.solvers.diophantine.diophantine.descent").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here the solution tuple is in the order (w, Y, Z)
  prefs: []
  type: TYPE_NORMAL
- en: The extended Pythagorean equation, \(a_{1}x_{1}^2 + a_{2}x_{2}^2 + \ldots +
    a_{n}x_{n}^2 = a_{n+1}x_{n+1}^2\) and the general sum of squares equation, \(x_{1}^2
    + x_{2}^2 + \ldots + x_{n}^2 = k\) can also be solved using the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: function [`diop_general_pythagorean()`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean") can also be
    called directly to solve the same equation. Either you can call [`diop_general_pythagorean()`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean") or use the high
    level API. For the general sum of squares, this is also true, but one advantage
    of calling [`diop_general_sum_of_squares()`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares") is that you
    can control how many solutions are returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`sum_of_squares()`](#sympy.solvers.diophantine.diophantine.sum_of_squares
    "sympy.solvers.diophantine.diophantine.sum_of_squares") routine will providean
    iterator that returns solutions and one may control whether the solutions contain
    zeros or not (and the solutions not containing zeros are returned first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple Eqyptian fractions can be found with the Diophantine module, too. For
    example, here are the ways that one might represent 1/2 as a sum of two unit fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To get a more thorough understanding of the Diophantine module, please refer
    to the following blog.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://thilinaatsympy.wordpress.com/](https://thilinaatsympy.wordpress.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This functions is imported into the global namespace with `from sympy import
    *`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Simplify the solution procedure of diophantine equation `eq` by converting it
    into a product of terms which should equal zero.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For example, when solving, \(x^2 - y^2 = 0\) this is treated as \((x + y)(x
    - y) = 0\) and \(x + y = 0\) and \(x - y = 0\) are solved independently and combined.
    Each term is solved by calling `diop_solve()`. (Although it is possible to call
    `diop_solve()` directly, one must be careful to pass an equation in the correct
    form and to interpret the output correctly; `diophantine()` is the public-facing
    function to use in general.)
  prefs: []
  type: TYPE_NORMAL
- en: Output of `diophantine()` is a set of tuples. The elements of the tuple are
    the solutions for each variable in the equation and are arranged according to
    the alphabetic ordering of the variables. e.g. For an equation with two variables,
    \(a\) and \(b\), the first element of the tuple is the solution for \(a\) and
    the second for \(b\).
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diophantine(eq, t, syms)`: Solve the diophantine equation `eq`. `t` is the
    optional parameter to be used by `diop_solve()`. `syms` is an optional list of
    symbols which determines the order of the elements in the returned tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the base solution is returned. If `permute` is set to True
    then permutations of the base solution and/or permutations of the signs of the
    values will be returned when applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` should be an expression which is assumed to be zero. `t` is the parameter
    to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diop_solve`](#sympy.solvers.diophantine.diophantine.diop_solve "sympy.solvers.diophantine.diophantine.diop_solve"),
    [`sympy.utilities.iterables.permute_signs`](../utilities/iterables.html#sympy.utilities.iterables.permute_signs
    "sympy.utilities.iterables.permute_signs"), [`sympy.utilities.iterables.signed_permutations`](../utilities/iterables.html#sympy.utilities.iterables.signed_permutations
    "sympy.utilities.iterables.signed_permutations")'
  prefs: []
  type: TYPE_NORMAL
- en: 'And this function is imported with `from sympy.solvers.diophantine import *`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Internal Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These functions are intended for internal use in the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Solves the diophantine equation `eq`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `diophantine()`, factoring of `eq` is not attempted. Uses `classify_diop()`
    to determine the type of the equation and calls the appropriate solver function.
  prefs: []
  type: TYPE_NORMAL
- en: Use of `diophantine()` is recommended over other helper functions. `diop_solve()`
    can return either a set or a tuple depending on the nature of the equation.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_solve(eq, t)`: Solve diophantine equation, `eq` using `t` as a parameter
    if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` should be an expression which is assumed to be zero. `t` is a parameter
    to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diophantine`](#sympy.solvers.diophantine.diophantine.diophantine "sympy.solvers.diophantine.diophantine.diophantine")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Solves linear diophantine equations.
  prefs: []
  type: TYPE_NORMAL
- en: A linear diophantine equation is an equation of the form \(a_{1}x_{1} + a_{2}x_{2}
    + .. + a_{n}x_{n} = 0\) where \(a_{1}, a_{2}, ..a_{n}\) are integer constants
    and \(x_{1}, x_{2}, ..x_{n}\) are integer variables.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_linear(eq)`: Returns a tuple containing solutions to the diophantine
    equation `eq`. Values in the tuple is arranged in the same order as the sorted
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` is a linear diophantine equation which is assumed to be zero. `param`
    is the parameter to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here x = -3*t_0 - 5 and y = -2*t_0 - 5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diop_quadratic`](#sympy.solvers.diophantine.diophantine.diop_quadratic "sympy.solvers.diophantine.diophantine.diop_quadratic"),
    [`diop_ternary_quadratic`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic"), [`diop_general_pythagorean`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean"), [`diop_general_sum_of_squares`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Return the base solution for the linear equation, \(ax + by = c\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Used by `diop_linear()` to find the base solution of a linear Diophantine equation.
    If `t` is given then the parametrized solution is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`base_solution_linear(c, a, b, t)`: `a`, `b`, `c` are coefficients in \(ax
    + by = c\) and `t` is the parameter to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Solves quadratic diophantine equations.
  prefs: []
  type: TYPE_NORMAL
- en: i.e. equations of the form \(Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0\). Returns
    a set containing the tuples \((x, y)\) which contains the solutions. If there
    are no solutions then \((None, None)\) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_quadratic(eq, param)`: `eq` is a quadratic binary diophantine equation.
    `param` is used to indicate the parameter to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` should be an expression which is assumed to be zero. `param` is a parameter
    to be used in the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diop_linear`](#sympy.solvers.diophantine.diophantine.diop_linear "sympy.solvers.diophantine.diophantine.diop_linear"),
    [`diop_ternary_quadratic`](#sympy.solvers.diophantine.diophantine.diop_ternary_quadratic
    "sympy.solvers.diophantine.diophantine.diop_ternary_quadratic"), [`diop_general_sum_of_squares`](#sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares
    "sympy.solvers.diophantine.diophantine.diop_general_sum_of_squares"), [`diop_general_pythagorean`](#sympy.solvers.diophantine.diophantine.diop_general_pythagorean
    "sympy.solvers.diophantine.diophantine.diop_general_pythagorean")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R858](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods to solve Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0, [online], Available:
    [https://www.alpertron.com.ar/METHODS.HTM](https://www.alpertron.com.ar/METHODS.HTM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R859](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the equation ax^2+ bxy + cy^2 + dx + ey + f= 0, [online], Available:
    [https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf](https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Solves the equation \(x^2 - Dy^2 = N\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Mainly concerned with the case \(D > 0, D\) is not a perfect square, which is
    the same as the generalized Pell equation. The LMM algorithm [[R860]](#r860) is
    used to solve this equation.
  prefs: []
  type: TYPE_NORMAL
- en: Returns one solution tuple, (\(x, y)\) for each class of the solutions. Other
    solutions of the class can be constructed according to the values of `D` and `N`.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_DN(D, N, t)`: D and N are integers as in \(x^2 - Dy^2 = N\) and `t` is
    the parameter to be used in the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`D` and `N` correspond to D and N in the equation. `t` is the parameter to
    be used in the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output can be interpreted as follows: There are three fundamental solutions
    to the equation \(x^2 - 13y^2 = -4\) given by (3, 1), (393, 109) and (36, 10).
    Each tuple is in the form (x, y), i.e. solution (3, 1) means that \(x = 3\) and
    \(y = 1\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`find_DN`](#sympy.solvers.diophantine.diophantine.find_DN "sympy.solvers.diophantine.diophantine.find_DN"),
    [`diop_bf_DN`](#sympy.solvers.diophantine.diophantine.diop_bf_DN "sympy.solvers.diophantine.diophantine.diop_bf_DN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R860] ([1](#id11),[2](#id12))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the generalized Pell equation x**2 - D*y**2 = N, John P. Robertson,
    July 31, 2004, Pages 16 - 17\. [online], Available: [https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf](https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Solves \(ax^2 + by^2 = m\) where \(\gcd(a, b) = 1 = gcd(a, m)\) and \(a, b >
    0\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Uses the algorithm due to Cornacchia. The method only finds primitive solutions,
    i.e. ones with \(\gcd(x, y) = 1\). So this method cannot be used to find the solutions
    of \(x^2 + y^2 = 20\) since the only solution to former is \((x, y) = (4, 2)\)
    and it is not primitive. When \(a = b\), only the solutions with \(x \leq y\)
    are found. For more details, see the References.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.signed_permutations`](../utilities/iterables.html#sympy.utilities.iterables.signed_permutations
    "sympy.utilities.iterables.signed_permutations")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R861](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: Nitaj, “L’algorithme de Cornacchia”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[[R862](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the diophantine equation ax**2 + by**2 = m by Cornacchia’s method,
    [online], Available: [http://www.numbertheory.org/php/cornacchia.html](http://www.numbertheory.org/php/cornacchia.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Uses brute force to solve the equation, \(x^2 - Dy^2 = N\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Mainly concerned with the generalized Pell equation which is the case when \(D
    > 0, D\) is not a perfect square. For more information on the case refer [[R863]](#r863).
    Let \((t, u)\) be the minimal positive solution of the equation \(x^2 - Dy^2 =
    1\). Then this method requires \(\sqrt{\\frac{\mid N \mid (t \pm 1)}{2D}}\) to
    be small.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_bf_DN(D, N, t)`: `D` and `N` are coefficients in \(x^2 - Dy^2 = N\) and
    `t` is the parameter to be used in the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`D` and `N` correspond to D and N in the equation. `t` is the parameter to
    be used in the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diop_DN`](#sympy.solvers.diophantine.diophantine.diop_DN "sympy.solvers.diophantine.diophantine.diop_DN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R863] ([1](#id15),[2](#id16))'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the generalized Pell equation x**2 - D*y**2 = N, John P. Robertson,
    July 31, 2004, Page 15\. [https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf](https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This function transforms general quadratic, \(ax^2 + bxy + cy^2 + dx + ey +
    f = 0\) to more easy to deal with \(X^2 - DY^2 = N\) form.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is used to solve the general quadratic equation by transforming it to the
    latter form. Refer to [[R864]](#r864) for more detailed information on the transformation.
    This function returns a tuple (A, B) where A is a 2 X 2 matrix and B is a 2 X
    1 matrix such that,
  prefs: []
  type: TYPE_NORMAL
- en: Transpose([x y]) = A * Transpose([X Y]) + B
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`transformation_to_DN(eq)`: where `eq` is the quadratic to be transformed.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: A, B returned are such that Transpose((x y)) = A * Transpose((X Y)) + B. Substituting
    these values for \(x\) and \(y\) and a bit of simplifying work will give an equation
    of the form \(x^2 - Dy^2 = N\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Next we will substitute these formulas for \(x\) and \(y\) and do `simplify()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: By multiplying the denominator appropriately, we can get a Pell equation in
    the standard form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If only the final equation is needed, `find_DN()` can be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`find_DN`](#sympy.solvers.diophantine.diophantine.find_DN "sympy.solvers.diophantine.diophantine.find_DN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R864] ([1](#id17),[2](#id18))'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0, John P.Robertson,
    May 8, 2003, Page 7 - 11. [https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf](https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns the transformation Matrix that converts a general ternary quadratic
    equation `eq` (\(ax^2 + by^2 + cz^2 + dxy + eyz + fxz\)) to a form without cross
    terms: \(ax^2 + by^2 + cz^2 = 0\). This is not used in solving ternary quadratics;
    it is only implemented for the sake of completeness.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a tuple, \((D, N)\) of the simplified form, \(x^2 - Dy^2
    = N\), corresponding to the general quadratic, \(ax^2 + bxy + cy^2 + dx + ey +
    f = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Solving the general quadratic is then equivalent to solving the equation \(X^2
    - DY^2 = N\) and transforming the solutions by using the transformation matrices
    returned by `transformation_to_DN()`.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`find_DN(eq)`: where `eq` is the quadratic to be transformed.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Interpretation of the output is that we get \(X^2 -13Y^2 = -884\) after transforming
    \(x^2 - 3xy - y^2 - 2y + 1\) using the transformation returned by `transformation_to_DN()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`transformation_to_DN`](#sympy.solvers.diophantine.diophantine.transformation_to_DN
    "sympy.solvers.diophantine.diophantine.transformation_to_DN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R865](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the equation ax^2 + bxy + cy^2 + dx + ey + f = 0, John P.Robertson,
    May 8, 2003, Page 7 - 11. [https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf](https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Solves the general quadratic ternary form, \(ax^2 + by^2 + cz^2 + fxy + gyz
    + hxz = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Returns a tuple \((x, y, z)\) which is a base solution for the above equation.
    If there are no solutions, \((None, None, None)\) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_ternary_quadratic(eq)`: Return a tuple containing a basic solution to
    `eq`.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` should be an homogeneous expression of degree two in three variables and
    it is assumed to be zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Returns an integer \(c\) s.t. \(a = c^2k, \ c,k \in Z\). Here \(k\) is square
    free. \(a\) can be given as an integer or a dictionary of factors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.core`](../ntheory.html#sympy.ntheory.factor_.core "sympy.ntheory.factor_.core")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Returns a non-trivial solution, (x, y, z), to \(x^2 = Ay^2 + Bz^2\) using Lagrange’s
    descent method with lattice-reduction. \(A\) and \(B\) are assumed to be valid
    for such a solution to exist.
  prefs: []
  type: TYPE_NORMAL
- en: This is faster than the normal Lagrange’s descent algorithm because the Gaussian
    reduction is used.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: \((x, y, z) = (1, 0, 1)\) is a solution to the above equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R866](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics. Mathematics
    of Computation, 72(243), 1417-1441. [https://doi.org/10.1090/S0025-5718-02-01480-1](https://doi.org/10.1090/S0025-5718-02-01480-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Solves the general pythagorean equation, \(a_{1}^2x_{1}^2 + a_{2}^2x_{2}^2 +
    . . . + a_{n}^2x_{n}^2 - a_{n + 1}^2x_{n + 1}^2 = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Returns a tuple which contains a parametrized solution to the equation, sorted
    in the same order as the input variables.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_general_pythagorean(eq, param)`: where `eq` is a general pythagorean
    equation which is assumed to be zero and `param` is the base parameter used to
    construct other parameters by subscripting.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Solves the equation \(x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Returns at most `limit` number of solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`general_sum_of_squares(eq, limit)` : Here `eq` is an expression which is assumed
    to be zero. Also, `eq` should be in the form, \(x_{1}^2 + x_{2}^2 + . . . + x_{n}^2
    - k = 0\).'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: When \(n = 3\) if \(k = 4^a(8m + 7)\) for some \(a, m \in Z\) then there will
    be no solutions. Refer to [[R867]](#r867) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Reference
  prefs: []
  type: TYPE_NORMAL
- en: '[[R867](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing an integer as a sum of three squares, [online], Available: [https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares](https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Solves the equation \(x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0\) where \(e\)
    is an even, integer power.
  prefs: []
  type: TYPE_NORMAL
- en: Returns at most `limit` number of solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`general_sum_of_even_powers(eq, limit)` : Here `eq` is an expression which
    is assumed to be zero. Also, `eq` should be in the form, \(x_{1}^e + x_{2}^e +
    . . . + x_{n}^e - k = 0\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`power_representation`](#sympy.solvers.diophantine.diophantine.power_representation
    "sympy.solvers.diophantine.diophantine.power_representation")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Returns a generator for finding k-tuples of integers, \((n_{1}, n_{2}, . . .
    n_{k})\), such that \(n = n_{1}^p + n_{2}^p + . . . n_{k}^p\).
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`power_representation(n, p, k, zeros)`: Represent non-negative number `n` as
    a sum of `k` `p`th powers. If `zeros` is true, then the solutions is allowed to
    contain zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Represent 1729 as a sum of two cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag \(zeros\) is True, the solution may contain tuples with zeros;
    any such solutions will be generated after the solutions without zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For even \(p\) the \(permute_sign\) function can be used to get all signed
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'All possible signed permutations can also be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Returns a generator that can be used to generate partitions of an integer \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A partition of \(n\) is a set of positive integers which add up to \(n\). For
    example, partitions of 3 are 3, 1 + 2, 1 + 1 + 1\. A partition is returned as
    a tuple. If `k` equals None, then all possible partitions are returned irrespective
    of their size, otherwise only the partitions of size `k` are returned. If the
    `zero` parameter is set to True then a suitable number of zeros are added at the
    end of every partition of size less than `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '`zero` parameter is considered only if `k` is not None. When the partitions
    are over, the last \(next()\) call throws the `StopIteration` exception, so this
    function should always be used inside a try - except block.'
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: '`partition(n, k)`: Here `n` is a positive integer and `k` is the size of the
    partition which is also positive integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Returns a 3-tuple \((a, b, c)\) such that \(a^2 + b^2 + c^2 = n\) and \(a, b,
    c \geq 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Returns None if \(n = 4^a(8m + 7)\) for some \(a, m \in \mathbb{Z}\). See [[R868]](#r868)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: non-negative integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(int, int, int) | None** : 3-tuple non-negative integers `(a, b, c)` satisfying
    `a**2 + b**2 + c**2 = n`.'
  prefs: []
  type: TYPE_NORMAL
- en: a,b,c are sorted in ascending order. `None` if no such `(a,b,c)`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is a negative integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`power_representation`](#sympy.solvers.diophantine.diophantine.power_representation
    "sympy.solvers.diophantine.diophantine.power_representation")'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum_of_three_squares(n)` is one of the solutions output by `power_representation(n,
    2, 3, zeros=True)`'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R868] ([1](#id22),[2](#id23))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing a number as a sum of three squares, [online], Available: [https://schorn.ch/lagrange.html](https://schorn.ch/lagrange.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Returns a 4-tuple \((a, b, c, d)\) such that \(a^2 + b^2 + c^2 + d^2 = n\).
    Here \(a, b, c, d \geq 0\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: non-negative integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(int, int, int, int)** : 4-tuple non-negative integers `(a, b, c, d)` satisfying
    `a**2 + b**2 + c**2 + d**2 = n`.'
  prefs: []
  type: TYPE_NORMAL
- en: a,b,c,d are sorted in ascending order.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is a negative integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`power_representation`](#sympy.solvers.diophantine.diophantine.power_representation
    "sympy.solvers.diophantine.diophantine.power_representation")'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum_of_four_squares(n)` is one of the solutions output by `power_representation(n,
    2, 4, zeros=True)`'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R869](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing a number as a sum of four squares, [online], Available: [https://schorn.ch/lagrange.html](https://schorn.ch/lagrange.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Returns a generator for finding k-tuples of integers, \((n_{1}, n_{2}, . . .
    n_{k})\), such that \(n = n_{1}^p + n_{2}^p + . . . n_{k}^p\).
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`power_representation(n, p, k, zeros)`: Represent non-negative number `n` as
    a sum of `k` `p`th powers. If `zeros` is true, then the solutions is allowed to
    contain zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Represent 1729 as a sum of two cubes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If the flag \(zeros\) is True, the solution may contain tuples with zeros;
    any such solutions will be generated after the solutions without zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'For even \(p\) the \(permute_sign\) function can be used to get all signed
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'All possible signed permutations can also be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Return a generator that yields the k-tuples of nonnegative values, the squares
    of which sum to n. If zeros is False (default) then the solution will not contain
    zeros. The nonnegative elements of a tuple are sorted.
  prefs: []
  type: TYPE_NORMAL
- en: If k == 1 and n is square, (n,) is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If k == 2 then n can only be written as a sum of squares if every prime in the
    factorization of n that has the form 4*k + 3 has an even multiplicity. If n is
    prime then it can only be written as a sum of two squares if it is in the form
    4*k + 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if k == 3 then n can be written as a sum of squares if it does not have the
    form 4**m*(8*k + 7).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: all integers can be written as the sum of 4 squares.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if k > 4 then n can be partitioned and each partition can be written as a sum
    of 4 squares; if n is not evenly divisible by 4 then n can be written as a sum
    of squares only if the an additional partition can be written as sum of squares.
    For example, if k = 6 then n is partitioned into two parts, the first being written
    as a sum of 4 squares and the second being written as a sum of 2 squares – which
    can only be done if the condition above for k = 2 can be met, so this will automatically
    reject certain partitions of n.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.utilities.iterables.signed_permutations`](../utilities/iterables.html#sympy.utilities.iterables.signed_permutations
    "sympy.utilities.iterables.signed_permutations")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This is used to construct the full solution from the solutions of sub equations.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For example when solving the equation \((x - y)(x^2 + y^2 - z^2) = 0\), solutions
    for each of the equations \(x - y = 0\) and \(x^2 + y^2 - z^2\) are found independently.
    Solutions for \(x - y = 0\) are \((x, y) = (t, t)\). But we should introduce a
    value for z when we output the solution for the original equation. This function
    converts \((t, t)\) into \((t, t, n_{1})\) where \(n_{1}\) is an integer parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Returns \(True\) if `a` is divisible by `b` and \(False\) otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Returns useful information needed to solve the Pell equation.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: There are six sequences of integers defined related to the continued fraction
    representation of \(\\frac{P + \sqrt{D}}{Q}\), namely {\(P_{i}\)}, {\(Q_{i}\)},
    {\(a_{i}\)},{\(A_{i}\)}, {\(B_{i}\)}, {\(G_{i}\)}. `PQa()` Returns these values
    as a 6-tuple in the same order as mentioned above. Refer [[R870]](#r870) for more
    detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`PQa(P_0, Q_0, D)`: `P_0`, `Q_0` and `D` are integers corresponding to \(P_{0}\),
    \(Q_{0}\) and \(D\) in the continued fraction \(\\frac{P_{0} + \sqrt{D}}{Q_{0}}\).
    Also it’s assumed that \(P_{0}^2 == D mod(|Q_{0}|)\) and \(D\) is square free.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R870] ([1](#id25),[2](#id26))'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the generalized Pell equation x^2 - Dy^2 = N, John P. Robertson, July
    31, 2004, Pages 4 - 8\. [https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf](https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if two solutions \((u, v)\) and \((r, s)\) of \(x^2 - Dy^2 = N\)
    belongs to the same equivalence class and False otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Two solutions \((u, v)\) and \((r, s)\) to the above equation fall to the same
    equivalence class iff both \((ur - Dvs)\) and \((us - vr)\) are divisible by \(N\).
    See reference [[R871]](#r871). No test is performed to test whether \((u, v)\)
    and \((r, s)\) are actually solutions to the equation. User should take care of
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`equivalent(u, v, r, s, D, N)`: \((u, v)\) and \((r, s)\) are two solutions
    of the equation \(x^2 - Dy^2 = N\) and all parameters involved are integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R871] ([1](#id27),[2](#id28))'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the generalized Pell equation x**2 - D*y**2 = N, John P. Robertson,
    July 31, 2004, Page 12\. [https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf](https://web.archive.org/web/20160323033128/http://www.jpr2718.org/pell.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Returns the parametrized general solution for the ternary quadratic equation
    `eq` which has the form \(ax^2 + by^2 + cz^2 + fxy + gyz + hxz = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The parametrized solution may be returned with three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'There might also be only two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider `p` and `q` in the previous 2-parameter solution and observe that
    more than one solution can be represented by a given pair of parameters. If \(p\)
    and `q` are not coprime, this is trivially true since the common factor will also
    be a common factor of the solution values. But it may also be true even when `p`
    and `q` are coprime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Except for sign and a common factor, these are equivalent to the solution of
    (1, 2, 2).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R872](#id29)]'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithmic resolution of Diophantine equations, Nigel P. Smart, London
    Mathematical Society Student Texts 41, Cambridge University Press, Cambridge,
    1998.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Solves the quadratic ternary diophantine equation, \(ax^2 + by^2 + cz^2 = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Here the coefficients \(a\), \(b\), and \(c\) should be non zero. Otherwise
    the equation will be a quadratic binary or univariate equation. If solvable, returns
    a tuple \((x, y, z)\) that satisfies the given equation. If the equation does
    not have integer solutions, \((None, None, None)\) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs: []
  type: TYPE_NORMAL
- en: '`diop_ternary_quadratic_normal(eq)`: where `eq` is an equation of the form
    \(ax^2 + by^2 + cz^2 = 0\).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Return a non-trivial solution to \(w^2 = Ax^2 + By^2\) using Lagrange’s method;
    return None if there is no such solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: non-zero integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(int, int, int) | None** : a tuple \((w_0, x_0, y_0)\) which is a solution
    to the above equation.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This means that \(x = -1, y = 0\) and \(w = 2\) is a solution to the equation
    \(w^2 = 4x^2 - 7y^2\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R873](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithmic resolution of Diophantine equations, Nigel P. Smart, London
    Mathematical Society Student Texts 41, Cambridge University Press, Cambridge,
    1998.
  prefs: []
  type: TYPE_NORMAL
- en: '[[R874](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics. Mathematics
    of Computation, 72(243), 1417-1441. [https://doi.org/10.1090/S0025-5718-02-01480-1](https://doi.org/10.1090/S0025-5718-02-01480-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Returns a reduced solution \((x, z)\) to the congruence \(X^2 - aZ^2 \equiv
    0 \pmod{b}\) so that \(x^2 + |a|z^2\) is as small as possible. Here `w` is a solution
    of the congruence \(x^2 \equiv a \pmod{b}\).
  prefs: []
  type: TYPE_NORMAL
- en: This function is intended to be used only for `descent()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**w** : int'
  prefs: []
  type: TYPE_NORMAL
- en: '`w` s.t. \(w^2 \equiv a \pmod{b}\)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**a** : int'
  prefs: []
  type: TYPE_NORMAL
- en: square-free nonzero integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b** : int'
  prefs: []
  type: TYPE_NORMAL
- en: square-free nonzero integer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Gaussian reduction can find the shortest vector for any norm. So we define
    the special norm for the vectors \(u = (u_1, u_2)\) and \(v = (v_1, v_2)\) as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: \[u \cdot v := (wu_1 + bu_2)(wv_1 + bv_2) + |a|u_1v_1\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, given the mapping \(f: (u_1, u_2) \to (wu_1 + bu_2, u_1)\), \(f((u_1,u_2))\)
    is the solution to \(X^2 - aZ^2 \equiv 0 \pmod{b}\). In other words, finding the
    shortest vector in this norm will yield a solution with smaller \(X^2 + |a|Z^2\).
    The algorithm starts from basis vectors \((0, 1)\) and \((1, 0)\) (corresponding
    to solutions \((b, 0)\) and \((w, 1)\), respectively) and finds the shortest vector.
    The shortest vector does not necessarily correspond to the smallest solution,
    but since `descent()` only wants the smallest possible solution, it is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: It does not always return the smallest solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R875](#id32)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gaussian lattice Reduction [online]. Available: [https://web.archive.org/web/20201021115213/http://home.ie.cuhk.edu.hk/~wkshum/wordpress/?p=404](https://web.archive.org/web/20201021115213/http://home.ie.cuhk.edu.hk/~wkshum/wordpress/?p=404)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R876](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics. Mathematics
    of Computation, 72(243), 1417-1441. [https://doi.org/10.1090/S0025-5718-02-01480-1](https://doi.org/10.1090/S0025-5718-02-01480-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Simplify the solution \((x, y, z)\) of the equation \(ax^2 + by^2 = cz^2\) with
    \(a, b, c > 0\) and \(z^2 \geq \mid ab \mid\) to a new reduced solution \((x',
    y', z')\) such that \(z'^2 \leq \mid ab \mid\).
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is an interpretation of Mordell’s reduction as described on page
    8 of Cremona and Rusin’s paper [[R877]](#r877) and the work of Mordell in reference
    [[R878]](#r878).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R877] ([1](#id34),[2](#id36))'
  prefs: []
  type: TYPE_NORMAL
- en: Cremona, J. E., Rusin, D. (2003). Efficient Solution of Rational Conics. Mathematics
    of Computation, 72(243), 1417-1441. [https://doi.org/10.1090/S0025-5718-02-01480-1](https://doi.org/10.1090/S0025-5718-02-01480-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[R878] ([1](#id35),[2](#id37))'
  prefs: []
  type: TYPE_NORMAL
- en: Diophantine Equations, L. J. Mordell, page 48.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Represent a prime \(p\) as a unique sum of two squares; this can only be done
    if the prime is congruent to 1 mod 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : Integer'
  prefs: []
  type: TYPE_NORMAL
- en: A prime that is congruent to 1 mod 4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(int, int) | None** : Pair of positive integers `(x, y)` satisfying `x**2
    + y**2 = p`.'
  prefs: []
  type: TYPE_NORMAL
- en: None if `p` is not congruent to 1 mod 4.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If `p` is not prime number
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Reference
  prefs: []
  type: TYPE_NORMAL
- en: '[R879]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing a number as a sum of four squares, [online], Available: [https://schorn.ch/lagrange.html](https://schorn.ch/lagrange.html)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sum_of_squares`](#sympy.solvers.diophantine.diophantine.sum_of_squares "sympy.solvers.diophantine.diophantine.sum_of_squares")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Return \(a'', b'', c''\), the coefficients of the square-free normal form of
    \(ax^2 + by^2 + cz^2 = 0\), where \(a'', b'', c''\) are pairwise prime. If \(steps\)
    is True then also return three tuples: \(sq\), \(sqf\), and \((a'', b'', c'')\)
    where \(sq\) contains the square factors of \(a\), \(b\) and \(c\) after removing
    the \(gcd(a, b, c)\); \(sqf\) contains the values of \(a\), \(b\) and \(c\) after
    removing both the \(gcd(a, b, c)\) and the square factors.'
  prefs: []
  type: TYPE_NORMAL
- en: The solutions for \(ax^2 + by^2 + cz^2 = 0\) can be recovered from the solutions
    of \(a'x^2 + b'y^2 + c'z^2 = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reconstruct`](#sympy.solvers.diophantine.diophantine.reconstruct "sympy.solvers.diophantine.diophantine.reconstruct")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R880](#id38)]'
  prefs: []
  type: TYPE_NORMAL
- en: Legendre’s Theorem, Legrange’s Descent, [https://public.csusm.edu/aitken_html/notes/legendre.pdf](https://public.csusm.edu/aitken_html/notes/legendre.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Reconstruct the \(z\) value of an equivalent solution of \(ax^2 + by^2 + cz^2\)
    from the \(z\) value of a solution of the square-free normal form of the equation,
    \(a'*x^2 + b'*y^2 + c'*z^2\), where \(a'\), \(b'\) and \(c'\) are square free
    and \(gcd(a', b', c') == 1\).
  prefs: []
  type: TYPE_NORMAL
- en: Internal Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These classes are intended for internal use in the Diophantine module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Container for a set of solutions to a particular diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: The base representation is a set of tuples representing each of the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**symbols** : list'
  prefs: []
  type: TYPE_NORMAL
- en: List of free symbols in the original equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**parameters: list**'
  prefs: []
  type: TYPE_NORMAL
- en: List of parameters to be used in the solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversion of solutions into dicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Substituting values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluation at specific values. Positional arguments are given in the same order
    as the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Internal representation of a particular diophantine equation type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**equation :**'
  prefs: []
  type: TYPE_NORMAL
- en: The diophantine equation that is being solved.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**free_symbols** : list (optional)'
  prefs: []
  type: TYPE_NORMAL
- en: The symbols being solved for.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Attributes
  prefs: []
  type: TYPE_NORMAL
- en: '| total_degree : | The maximum of the degrees of all terms in the equation
    |'
  prefs: []
  type: TYPE_TB
- en: '| homogeneous : | Does the equation contain a term of degree 0 |'
  prefs: []
  type: TYPE_TB
- en: '| homogeneous_order : | Does the equation contain any coefficient that is in
    the symbols being solved for |'
  prefs: []
  type: TYPE_TB
- en: '| dimension : | The number of symbols being solved for |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether the given equation can be matched to the particular equation
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a univariate diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: A univariate diophantine equation is an equation of the form \(a_{0} + a_{1}x
    + a_{2}x^2 + .. + a_{n}x^n = 0\) where \(a_{1}, a_{2}, ..a_{n}\) are integer constants
    and \(x\) is an integer variable.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a linear diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: A linear diophantine equation is an equation of the form \(a_{1}x_{1} + a_{2}x_{2}
    + .. + a_{n}x_{n} = 0\) where \(a_{1}, a_{2}, ..a_{n}\) are integer constants
    and \(x_{1}, x_{2}, ..x_{n}\) are integer variables.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Here x = -3*t_0 - 5 and y = -2*t_0 - 5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a binary quadratic diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: A binary quadratic diophantine equation is an equation of the form \(Ax^2 +
    Bxy + Cy^2 + Dx + Ey + F = 0\), where \(A, B, C, D, E, F\) are integer constants
    and \(x\) and \(y\) are integer variables.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R881](#id39)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods to solve Ax^2 + Bxy + Cy^2 + Dx + Ey + F = 0, [online], Available:
    [https://www.alpertron.com.ar/METHODS.HTM](https://www.alpertron.com.ar/METHODS.HTM)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R882](#id40)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the equation ax^2+ bxy + cy^2 + dx + ey + f= 0, [online], Available:
    [https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf](https://web.archive.org/web/20160323033111/http://www.jpr2718.org/ax2p.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Representation of an inhomogeneous ternary quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: No solver is currently implemented for this equation type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a homogeneous ternary quadratic normal diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a homogeneous ternary quadratic diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Representation of an inhomogeneous general quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: No solver is currently implemented for this equation type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a homogeneous general quadratic.
  prefs: []
  type: TYPE_NORMAL
- en: No solver is currently implemented for this equation type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Representation of the diophantine equation
  prefs: []
  type: TYPE_NORMAL
- en: \(x_{1}^2 + x_{2}^2 + . . . + x_{n}^2 - k = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs: []
  type: TYPE_NORMAL
- en: When \(n = 3\) if \(k = 4^a(8m + 7)\) for some \(a, m \in Z\) then there will
    be no solutions. Refer [[R883]](#r883) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'By default only 1 solution is returned. Use the \(limit\) keyword for more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R883] ([1](#id41),[2](#id42))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing an integer as a sum of three squares, [online], Available: [https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares](https://www.proofwiki.org/wiki/Integer_as_Sum_of_Three_Squares)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Representation of the general pythagorean equation, \(a_{1}^2x_{1}^2 + a_{2}^2x_{2}^2
    + . . . + a_{n}^2x_{n}^2 - a_{n + 1}^2x_{n + 1}^2 = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Representation of a cubic Thue diophantine equation.
  prefs: []
  type: TYPE_NORMAL
- en: A cubic Thue diophantine equation is a polynomial of the form \(f(x, y) = r\)
    of degree 3, where \(x\) and \(y\) are integers and \(r\) is a rational number.
  prefs: []
  type: TYPE_NORMAL
- en: No solver is currently implemented for this equation type.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Representation of the diophantine equation
  prefs: []
  type: TYPE_NORMAL
- en: \(x_{1}^e + x_{2}^e + . . . + x_{n}^e - k = 0\)
  prefs: []
  type: TYPE_NORMAL
- en: where \(e\) is an even, integer power.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
