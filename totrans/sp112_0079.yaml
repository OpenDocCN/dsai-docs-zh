- en: scipy.fft.next_fast_len
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.fft.next_fast_len.html#scipy.fft.next_fast_len](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.fft.next_fast_len.html#scipy.fft.next_fast_len)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find the next fast size of input data to `fft`, for zero-padding, etc.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy’s FFT algorithms gain their speed by a recursive divide and conquer strategy.
    This relies on efficient functions for small prime factors of the input length.
    Thus, the transforms are fastest when using composites of the prime factors handled
    by the fft implementation. If there are efficient functions for all radices <=
    *n*, then the result will be a number *x* >= `target` with only prime factors
    < *n*. (Also known as *n*-smooth numbers)
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**target**int'
  prefs: []
  type: TYPE_NORMAL
- en: Length to start searching from. Must be a positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: '**real**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: True if the FFT involves real input or output (e.g., [`rfft`](scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft") or [`hfft`](scipy.fft.hfft.html#scipy.fft.hfft "scipy.fft.hfft")
    but not [`fft`](scipy.fft.fft.html#scipy.fft.fft "scipy.fft.fft")). Defaults to
    False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out**int'
  prefs: []
  type: TYPE_NORMAL
- en: The smallest fast length greater than or equal to `target`.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The result of this function may change in future as performance considerations
    change, for example, if new prime factors are added.
  prefs: []
  type: TYPE_NORMAL
- en: Calling [`fft`](scipy.fft.fft.html#scipy.fft.fft "scipy.fft.fft") or [`ifft`](scipy.fft.ifft.html#scipy.fft.ifft
    "scipy.fft.ifft") with real input data performs an `'R2C'` transform internally.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'On a particular machine, an FFT of prime length takes 11.4 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Zero-padding to the next regular length reduces computation time to 1.6 ms,
    a speedup of 7.3 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Rounding up to the next power of 2 is not optimal, taking 3.0 ms to compute;
    1.9 times longer than the size given by `next_fast_len`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
