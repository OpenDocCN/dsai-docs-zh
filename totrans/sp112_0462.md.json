["```py\nscipy.optimize.root(fun, x0, args=(), method='hybr', jac=None, tol=None, callback=None, options=None)\n```", "```py\n>>> import numpy as np\n>>> def fun(x):\n...     return [x[0]  + 0.5 * (x[0] - x[1])**3 - 1.0,\n...             0.5 * (x[1] - x[0])**3 + x[1]] \n```", "```py\n>>> def jac(x):\n...     return np.array([[1 + 1.5 * (x[0] - x[1])**2,\n...                       -1.5 * (x[0] - x[1])**2],\n...                      [-1.5 * (x[1] - x[0])**2,\n...                       1 + 1.5 * (x[1] - x[0])**2]]) \n```", "```py\n>>> from scipy import optimize\n>>> sol = optimize.root(fun, [0, 0], jac=jac, method='hybr')\n>>> sol.x\narray([ 0.8411639,  0.1588361]) \n```", "```py\n>>> from scipy import optimize\n>>> # parameters\n>>> nx, ny = 75, 75\n>>> hx, hy = 1./(nx-1), 1./(ny-1) \n```", "```py\n>>> P_left, P_right = 0, 0\n>>> P_top, P_bottom = 1, 0 \n```", "```py\n>>> def residual(P):\n...    d2x = np.zeros_like(P)\n...    d2y = np.zeros_like(P)\n...\n...    d2x[1:-1] = (P[2:]   - 2*P[1:-1] + P[:-2]) / hx/hx\n...    d2x[0]    = (P[1]    - 2*P[0]    + P_left)/hx/hx\n...    d2x[-1]   = (P_right - 2*P[-1]   + P[-2])/hx/hx\n...\n...    d2y[:,1:-1] = (P[:,2:] - 2*P[:,1:-1] + P[:,:-2])/hy/hy\n...    d2y[:,0]    = (P[:,1]  - 2*P[:,0]    + P_bottom)/hy/hy\n...    d2y[:,-1]   = (P_top   - 2*P[:,-1]   + P[:,-2])/hy/hy\n...\n...    return d2x + d2y - 10*np.cosh(P).mean()**2 \n```", "```py\n>>> guess = np.zeros((nx, ny), float)\n>>> sol = optimize.root(residual, guess, method='krylov')\n>>> print('Residual: %g' % abs(residual(sol.x)).max())\nResidual: 5.7972e-06  # may vary \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> x, y = np.mgrid[0:1:(nx*1j), 0:1:(ny*1j)]\n>>> plt.pcolormesh(x, y, sol.x, shading='gouraud')\n>>> plt.colorbar()\n>>> plt.show() \n```"]