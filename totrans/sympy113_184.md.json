["```py\n% double_pendulum.al\n%-------------------\nMOTIONVARIABLES' Q{2}', U{2}'\nCONSTANTS L,M,G\nNEWTONIAN N\nFRAMES A,B\nSIMPROT(N, A, 3, Q1)\n% -> N_A = [COS(Q1), -SIN(Q1), 0; SIN(Q1), COS(Q1), 0; 0, 0, 1]\nSIMPROT(N, B, 3, Q2)\n% -> N_B = [COS(Q2), -SIN(Q2), 0; SIN(Q2), COS(Q2), 0; 0, 0, 1]\nW_A_N>=U1*N3>\n% -> W_A_N> = U1*N3>\nW_B_N>=U2*N3>\n% -> W_B_N> = U2*N3>\nPOINT O\nPARTICLES P,R\nP_O_P> = L*A1>\n% -> P_O_P> = L*A1>\nP_P_R> = L*B1>\n% -> P_P_R> = L*B1>\nV_O_N> = 0>\n% -> V_O_N> = 0>\nV2PTS(N, A, O, P)\n% -> V_P_N> = L*U1*A2>\nV2PTS(N, B, P, R)\n% -> V_R_N> = L*U1*A2> + L*U2*B2>\nMASS P=M, R=M\nQ1' = U1\nQ2' = U2\nGRAVITY(G*N1>)\n% -> FORCE_P> = G*M*N1>\n% -> FORCE_R> = G*M*N1>\nZERO = FR() + FRSTAR()\n% -> ZERO[1] = -L*M*(2*G*SIN(Q1)+L*(U2^2*SIN(Q1-Q2)+2*U1'+COS(Q1-Q2)*U2'))\n% -> ZERO[2] = -L*M*(G*SIN(Q2)-L*(U1^2*SIN(Q1-Q2)-U2'-COS(Q1-Q2)*U1'))\nKANE()\nINPUT M=1,G=9.81,L=1\nINPUT Q1=.1,Q2=.2,U1=0,U2=0\nINPUT TFINAL=10, INTEGSTP=.01\nCODE DYNAMICS() some_filename.c \n```", "```py\n>>> from sympy.parsing.autolev import parse_autolev\n>>> sympy_code = parse_autolev(open('double_pendulum.al'), include_numeric=True)\n\n# The include_pydy flag is False by default. Setting it to True will\n# enable PyDy simulation code to be outputted if applicable.\n\n>>> print(sympy_code)\nimport sympy.physics.mechanics as me\nimport sympy as sm\nimport math as m\nimport numpy as np\n\nq1, q2, u1, u2 = me.dynamicsymbols('q1 q2 u1 u2')\nq1d, q2d, u1d, u2d = me.dynamicsymbols('q1 q2 u1 u2', 1)\nl, m, g=sm.symbols('l m g', real=True)\nframe_n=me.ReferenceFrame('n')\nframe_a=me.ReferenceFrame('a')\nframe_b=me.ReferenceFrame('b')\nframe_a.orient(frame_n, 'Axis', [q1, frame_n.z])\n# print(frame_n.dcm(frame_a))\nframe_b.orient(frame_n, 'Axis', [q2, frame_n.z])\n# print(frame_n.dcm(frame_b))\nframe_a.set_ang_vel(frame_n, u1*frame_n.z)\n# print(frame_a.ang_vel_in(frame_n))\nframe_b.set_ang_vel(frame_n, u2*frame_n.z)\n# print(frame_b.ang_vel_in(frame_n))\npoint_o=me.Point('o')\nparticle_p=me.Particle('p', me.Point('p_pt'), sm.Symbol('m'))\nparticle_r=me.Particle('r', me.Point('r_pt'), sm.Symbol('m'))\nparticle_p.point.set_pos(point_o, l*frame_a.x)\n# print(particle_p.point.pos_from(point_o))\nparticle_r.point.set_pos(particle_p.point, l*frame_b.x)\n# print(particle_p.point.pos_from(particle_r.point))\npoint_o.set_vel(frame_n, 0)\n# print(point_o.vel(frame_n))\nparticle_p.point.v2pt_theory(point_o,frame_n,frame_a)\n# print(particle_p.point.vel(frame_n))\nparticle_r.point.v2pt_theory(particle_p.point,frame_n,frame_b)\n# print(particle_r.point.vel(frame_n))\nparticle_p.mass = m\nparticle_r.mass = m\nforce_p = particle_p.mass*(g*frame_n.x)\n# print(force_p)\nforce_r = particle_r.mass*(g*frame_n.x)\n# print(force_r)\nkd_eqs = [q1d - u1, q2d - u2]\nforceList = [(particle_p.point,particle_p.mass*(g*frame_n.x)), (particle_r.point,particle_r.mass*(g*frame_n.x))]\nkane = me.KanesMethod(frame_n, q_ind=[q1,q2], u_ind=[u1, u2], kd_eqs = kd_eqs)\nfr, frstar = kane.kanes_equations([particle_p, particle_r], forceList)\nzero = fr+frstar\n# print(zero)\n#---------PyDy code for integration----------\nfrom pydy.system import System\nsys = System(kane, constants = {l:1, m:1, g:9.81},\nspecifieds={},\ninitial_conditions={q1:.1, q2:.2, u1:0, u2:0},\ntimes = np.linspace(0.0, 10, 10/.01))\n\ny=sys.integrate() \n```", "```py\n    %Autolev Code\n    %------------\n    LAMBDA = EIG(M) \n    ```", "```py\n    #SymPy Code\n    #----------\n    lambda = sm.Matrix([i.evalf() for i in (m).eigenvals().keys()]) \n    ```", "```py\n    %Autolev Code\n    %------------\n    VARIABLES X,Y\n    FRAMES A\n    A> = X*A1> + Y*A2>\n    A = X+Y \n    ```", "```py\n    #SymPy Code\n    #----------\n    x, y = me.dynamicsymbols('x y')\n    frame_a = me.ReferenceFrame('a')\n    a = x*frame_a.x + y*frame_a.y\n    a = x + y\n    # Note how frame_a is named differently so it doesn't cause a problem.\n    # On the other hand, 'a' gets rewritten from a scalar to a vector.\n    # This should be changed in the future. \n    ```", "```py\n    %Autolev Code\n    %------------\n    EIG(M, E1, E2)\n    % -> [5; 14; 13]\n    E2ROW = ROWS(E2, 1)\n    EIGVEC> = VECTOR(A, E2ROW) \n    ```", "```py\n    #SymPy Code\n    #----------\n    e1 = sm.Matrix([i.evalf() for i in m.eigenvals().keys()])\n    # sm.Matrix([5;13;14]) different order\n    e2 = sm.Matrix([i[2][0].evalf() for i in m.eigenvects()]).reshape(m.shape[0], m.shape[1])\n    e2row = e2.row(0)\n    # This result depends on the order of the vectors in the eigenvecs.\n    eigenvec = e2row[0]*a.x + e2row[1]*a.y + e2row[2]*a.y \n    ```", "```py\n    %Autolev Code\n    %------------\n    A> = Q1*A1> + Q2*A2>\n    B> = EVALUATE(A>, Q1:30*UNITS(DEG,RAD)) \n    ```", "```py\n    #SymPy Code\n    #----------\n    a = q1*a.frame_a.x + q2*frame_a.y\n    b = a.subs({q1:30*0.0174533})\n    # b = a.subs({q1:np.deg2rad(30)} \n    ```", "```py\n    %Autolev Code\n    %------------\n    % COEF([E1;E2],[U1,U2,U3])\n    M = [COEF(E1,U1),COEF(E1,U2),COEF(E1,U3) &\n        ;COEF(E2,U1),COEF(E2,U2),COEF(E2,U3)] \n    ```", "```py\n    %Autolev Code\n    %------------\n    MOTIONVARIABLES' Q{2}', U{2}'\n    % ----- OTHER LINES ----\n    Q1' = U1\n    Q2' = U2\n    ----- OTHER LINES ----\n    ZERO = FR() + FRSTAR() \n    ```", "```py\n    #SymPy Code\n    #----------\n    q1, q2, u1, u2 = me.dynamicsymbols('q1 q2 u1 u2')\n    q1d, q2d, u1d, u2d = me.dynamicsymbols('q1 q2 u1 u2', 1)\n\n    # ------- other lines -------\n\n    kd_eqs = [q1d - u1, q2d - u2]\n    kane = me.KanesMethod(frame_n, q_ind=[q1,q2], u_ind=[u1, u2], kd_eqs = kd_eqs)\n    fr, frstar = kane.kanes_equations([particle_p, particle_r], forceList)\n    zero = fr+frstar \n    ```", "```py\n    %Autolev Code\n    %------------\n    VARIABLES X, Y\n    E = X + Y\n    X = 2*Y\n\n    RHS_X = RHS(X)\n\n    I1 = X\n    I2 = Y\n    I3 = X + Y\n\n    INERTIA B,I1,I2,I3\n    % -> I_B_BO>> = I1*B1>*B1> + I2*B2>*B2> + I3*B3>*B3> \n    ```", "```py\n    #SymPy Code\n    #----------\n    x,y = me.dynamicsymbols('x y')\n    e = x + y  # No symbol is made out of 'e'\n\n    # an entry like {x:2*y} is stored in an rhs dictionary\n\n    rhs_x = 2*y\n\n    i1 = x  # again these are not made into SymPy symbols\n    i2 = y\n    i3 = x + y\n\n    body_b.inertia = (me.inertia(body_b_f, i1, i2, i3), b_cm)\n    # This prints as:\n    # x*b_f.x*b_f.x + y*b_f.y*b_f.y + (x+y)*b_f.z*b_f.z\n    # while Autolev's output has I1,I2 and I3 in it.\n    # Autolev however seems to know when to use the RHS of I1,I2 and I3\n    # based on the context. \n    ```", "```py\n    %Autolev Code\n    %------------\n    SOLVE(ZERO,X,Y)\n    A = RHS(X)*2 + RHS(Y) \n    ```", "```py\n    #SymPy Code\n    #----------\n    print(sm.solve(zero,x,y))\n    # Behind the scenes the rhs of x\n    # is set to sm.solve(zero,x,y)[x].\n    a = sm.solve(zero,x,y)[x]*2 + sm.solve(zero,x,y)[y] \n    ```", "```py\n    %Autolev Code\n    %------------\n    INERTIA B,I1,I2,I3\n    I_B_BO>> = X*A1>*A1> + Y*A2>*A2>  % Parser will set the inertia of B\n    I_P_Q>> = X*A1>*A1> + Y^2*A2>*A2> % Parser just parses it as i_p_q = expr\n\n    E1 = 2*EXPRESS(I_B_O>>,A)\n    E2 =  I_P_Q>>\n    E3 = EXPRESS(I_P_O>>,A)\n    E4 = EXPRESS(INERTIA(O),A)\n\n    % In E1 we are using the EXPRESS command with I_B_O>> which makes\n    % the parser and SymPy compute the inertia of Body B about point O.\n\n    % In E2 we are just using the dyadic object I_P_Q>> (as I_P_Q>> = expr\n    % doesn't act as a setter) defined above and not asking the parser\n    % or SymPy to compute anything.\n\n    % E3 asks the parser to compute the inertia of P about point O.\n\n    % E4 asks the parser to compute the inertias of all bodies wrt about O. \n    ```", "```py\n    %Autolev Code\n    %------------\n    P_SO_O> = X*A1>\n    INERTIA S_(O) I1,I2,I3 \n    ```"]