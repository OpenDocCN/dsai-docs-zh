- en: Statistics (scipy.stats)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计（scipy.stats）
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html)
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In this tutorial, we discuss many, but certainly not all, features of `scipy.stats`.
    The intention here is to provide a user with a working knowledge of this package.
    We refer to the [reference manual](../reference/stats.html#statsrefmanual) for
    further details.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们讨论了许多`scipy.stats`的功能，但肯定不是所有功能。这里的意图是为用户提供对此包的工作知识。我们参考[参考手册](../reference/stats.html#statsrefmanual)获取更多详细信息。
- en: 'Note: This documentation is work in progress.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本文档正在进行中。
- en: '[Discrete Statistical Distributions](stats/discrete.html)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[离散统计分布](stats/discrete.html)'
- en: '[Continuous Statistical Distributions](stats/continuous.html)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连续统计分布](stats/continuous.html)'
- en: '[Universal Non-Uniform Random Number Sampling in SciPy](stats/sampling.html)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy中的通用非均匀随机数采样](stats/sampling.html)'
- en: '[Resampling and Monte Carlo Methods](stats/resampling.html)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重采样和蒙特卡罗方法](stats/resampling.html)'
- en: Random variables
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机变量
- en: There are two general distribution classes that have been implemented for encapsulating
    [continuous random variables](stats/continuous.html#continuous-random-variables)
    and [discrete random variables](stats/discrete.html#discrete-random-variables).
    Over 80 continuous random variables (RVs) and 10 discrete random variables have
    been implemented using these classes. Besides this, new routines and distributions
    can be easily added by the end user. (If you create one, please contribute it.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 已经实现了两个通用分布类，用于封装[连续随机变量](stats/continuous.html#continuous-random-variables)和[离散随机变量](stats/discrete.html#discrete-random-variables)。使用这些类已经实现了超过80个连续随机变量（RVs）和10个离散随机变量。此外，用户可以轻松地添加新的例程和分布（如果您创建了一个，请贡献出来）。
- en: All of the statistics functions are located in the sub-package [`scipy.stats`](../reference/stats.html#module-scipy.stats
    "scipy.stats") and a fairly complete listing of these functions can be obtained
    using `info(stats)`. The list of the random variables available can also be obtained
    from the docstring for the stats sub-package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有统计函数位于子包[`scipy.stats`](../reference/stats.html#module-scipy.stats "scipy.stats")中，可以使用`info(stats)`获取这些函数的相当完整的列表。还可以从stats子包的文档字符串中获取可用的随机变量列表。
- en: 'In the discussion below, we mostly focus on continuous RVs. Nearly everything
    also applies to discrete variables, but we point out some differences here: [Specific
    points for discrete distributions](#discrete-points-label).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下讨论中，我们主要关注连续RVs。几乎所有内容也适用于离散变量，但我们在这里指出了一些差异：[离散分布的特定点](#discrete-points-label)。
- en: In the code samples below, we assume that the [`scipy.stats`](../reference/stats.html#module-scipy.stats
    "scipy.stats") package is imported as
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们假设[`scipy.stats`](../reference/stats.html#module-scipy.stats "scipy.stats")包已经导入为
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and in some cases we assume that individual objects are imported as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们假设已经导入了个别对象
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Getting help
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'First of all, all distributions are accompanied with help functions. To obtain
    just some basic information, we print the relevant docstring: `print(stats.norm.__doc__)`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有分布都伴随有帮助函数。要仅获得一些基本信息，我们打印相关的文档字符串：`print(stats.norm.__doc__)`。
- en: 'To find the support, i.e., upper and lower bounds of the distribution, call:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到支持区间，即分布的上限和下限，请调用：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can list all methods and properties of the distribution with `dir(norm)`.
    As it turns out, some of the methods are private, although they are not named
    as such (their names do not start with a leading underscore), for example `veccdf`,
    are only available for internal calculation (those methods will give warnings
    when one tries to use them, and will be removed at some point).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`dir(norm)`列出分布的所有方法和属性。事实证明，一些方法是私有的，尽管它们没有以下划线开头（它们的名称不是这样命名的），例如`veccdf`，只能用于内部计算（当试图使用它们时会发出警告，并且将在某个时候删除）。
- en: To obtain the *real* main methods, we list the methods of the frozen distribution.
    (We explain the meaning of a *frozen* distribution below).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得*真正*的主要方法，我们列出冻结分布的方法。（我们将在下面解释*冻结*分布的含义）。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we can obtain the list of available distribution through introspection:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过内省获得可用分布的列表：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Common methods
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见方法
- en: 'The main public methods for continuous RVs are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 连续RVs的主要公共方法包括：
- en: 'rvs: Random Variates'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rvs：随机变量
- en: 'pdf: Probability Density Function'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pdf：概率密度函数
- en: 'cdf: Cumulative Distribution Function'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cdf：累积分布函数
- en: 'sf: Survival Function (1-CDF)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sf：生存函数（1-CDF）
- en: 'ppf: Percent Point Function (Inverse of CDF)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ppf：百分点函数（CDF的逆）
- en: 'isf: Inverse Survival Function (Inverse of SF)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: isf：逆生存函数（SF的逆）
- en: 'stats: Return mean, variance, (Fisher’s) skew, or (Fisher’s) kurtosis'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计：返回均值、方差、（Fisher的）偏度或（Fisher的）峰度
- en: 'moment: non-central moments of the distribution'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: moment：分布的非中心矩
- en: Let’s take a normal RV as an example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以正态随机变量为例。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To compute the `cdf` at a number of points, we can pass a list or a numpy array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个点计算`cdf`，可以传递一个列表或NumPy数组。
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thus, the basic methods, such as *pdf*, *cdf*, and so on, are vectorized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本方法，如*pdf*、*cdf*等，都是矢量化的。
- en: 'Other generally useful methods are supported too:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他通常有用的方法也受到支持：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To find the median of a distribution, we can use the percent point function
    `ppf`, which is the inverse of the `cdf`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到分布的中位数，我们可以使用百分点函数`ppf`，它是`cdf`的逆函数：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To generate a sequence of random variates, use the `size` keyword argument:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一系列随机变量，使用`size`关键字参数：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Don’t think that `norm.rvs(5)` generates 5 variates:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为`norm.rvs(5)`会生成5个变量：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `5` with no keyword is being interpreted as the first possible keyword
    argument, `loc`, which is the first of a pair of keyword arguments taken by all
    continuous distributions. This brings us to the topic of the next subsection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`5`而没有关键字被解释为第一个可能的关键字参数`loc`，它是所有连续分布采用的一对关键字参数中的第一个。这将我们带到下一小节的主题。
- en: Random number generation
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机数生成
- en: 'Drawing random numbers relies on generators from [`numpy.random`](https://numpy.org/devdocs/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0.dev0)") package. In the examples above, the specific stream of
    random numbers is not reproducible across runs. To achieve reproducibility, you
    can explicitly *seed* a random number generator. In NumPy, a generator is an instance
    of [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)"). Here is the canonical way to create a generator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 抽取随机数依赖于[`numpy.random`](https://numpy.org/devdocs/reference/random/index.html#module-numpy.random
    "(在 NumPy v2.0.dev0 中)")包中的生成器。在上述示例中，特定的随机数流在多次运行中无法重现。要实现可重复性，可以显式地*种子*一个随机数生成器。在NumPy中，生成器是[`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(在 NumPy v2.0.dev0 中)")的实例。以下是创建生成器的标准方式：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And fixing the seed can be done like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以通过以下方式固定种子：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Warning
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Do not use this number or common values such as 0\. Using just a small set
    of seeds to instantiate larger state spaces means that there are some initial
    states that are impossible to reach. This creates some biases if everyone uses
    such values. A good way to get a seed is to use a [`numpy.random.SeedSequence`](https://numpy.org/devdocs/reference/random/bit_generators/generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "(in NumPy v2.0.dev0)"):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '不要使用此数或常见值，如0\. 仅使用一小组种子来实例化更大的状态空间意味着存在一些不可能达到的初始状态。如果每个人都使用这样的值，会造成一些偏差。获取种子的好方法是使用[`numpy.random.SeedSequence`](https://numpy.org/devdocs/reference/random/bit_generators/generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "(在 NumPy v2.0.dev0 中)"):'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The *random_state* parameter in distributions accepts an instance of [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)") class, or an integer, which is then used to seed an internal
    `Generator` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 分布中的*random_state*参数接受一个[`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(在 NumPy v2.0.dev0 中)")类的实例或一个整数，然后用于种子化内部的`Generator`对象：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For further info, see [NumPy’s documentation](https://numpy.org/doc/stable/reference/random/index.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参阅[NumPy文档](https://numpy.org/doc/stable/reference/random/index.html)。
- en: To learn more about the random number samplers implemented in SciPy, see [non-uniform
    random number sampling tutorial](stats/sampling.html#non-uniform-random-number-sampling)
    and [quasi monte carlo tutorial](#quasi-monte-carlo)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SciPy中实现的随机数采样器，请参阅[非均匀随机数采样教程](stats/sampling.html#non-uniform-random-number-sampling)和[准蒙特卡洛教程](#quasi-monte-carlo)
- en: Shifting and scaling
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移位和缩放
- en: All continuous distributions take `loc` and `scale` as keyword parameters to
    adjust the location and scale of the distribution, e.g., for the standard normal
    distribution, the location is the mean and the scale is the standard deviation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连续分布都接受`loc`和`scale`作为关键参数，以调整分布的位置和尺度，例如，对于标准正态分布，位置是均值，尺度是标准差。
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In many cases, the standardized distribution for a random variable `X` is obtained
    through the transformation `(X - loc) / scale`. The default values are `loc =
    0` and `scale = 1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，随机变量`X`的标准化分布是通过变换`(X - loc) / scale`来获得的。 默认值为`loc = 0`和`scale = 1`。
- en: Smart use of `loc` and `scale` can help modify the standard distributions in
    many ways. To illustrate the scaling further, the `cdf` of an exponentially distributed
    RV with mean \(1/\lambda\) is given by
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 智能使用`loc`和`scale`可以帮助以许多方式修改标准分布。 为了进一步说明缩放，指数分布随机变量的`cdf`是
- en: \[F(x) = 1 - \exp(-\lambda x)\]
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: \[F(x) = 1 - \exp(-\lambda x)\]
- en: By applying the scaling rule above, it can be seen that by taking `scale  =
    1./lambda` we get the proper scale.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用上述的缩放规则，可以看到通过取`scale = 1./lambda`，我们得到了适当的比例。
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Distributions that take shape parameters may require more than simple application
    of `loc` and/or `scale` to achieve the desired form. For example, the distribution
    of 2-D vector lengths given a constant vector of length \(R\) perturbed by independent
    N(0, \(\sigma^2\)) deviations in each component is rice(\(R/\sigma\), scale= \(\sigma\)).
    The first argument is a shape parameter that needs to be scaled along with \(x\).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要形状参数\(a\)的分布可能需要不仅仅是简单地应用`loc`和/或`scale`来实现所需的形式。 例如，给定长度为\(R\)的恒定向量，每个分量受独立的N(0,
    \(\sigma^2\))扰动影响的2-D向量长度分布为rice(\(R/\sigma\), scale= \(\sigma\))。 第一个参数是一个需要与\(x\)一起缩放的形状参数。
- en: 'The uniform distribution is also interesting:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀分布也很有趣：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, recall from the previous paragraph that we are left with the problem
    of the meaning of `norm.rvs(5)`. As it turns out, calling a distribution like
    this, the first argument, i.e., the 5, gets passed to set the `loc` parameter.
    Let’s see:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请回顾前段提到的问题，即我们需要理解`norm.rvs(5)`的含义。 结果表明，像这样调用分布时，第一个参数即5被传递以设置`loc`参数。 让我们看看：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thus, to explain the output of the example of the last section: `norm.rvs(5)`
    generates a single normally distributed random variate with mean `loc=5`, because
    of the default `size=1`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要解释上一节示例的输出：`norm.rvs(5)`生成具有均值`loc=5`的单个正态分布随机变量，因为默认的`size=1`。
- en: We recommend that you set `loc` and `scale` parameters explicitly, by passing
    the values as keywords rather than as arguments. Repetition can be minimized when
    calling more than one method of a given RV by using the technique of [Freezing
    a Distribution](#freezing-a-distribution), as explained below.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过将值作为关键词而不是作为参数明确设置`loc`和`scale`参数。 当调用同一随机变量的多个方法时，可以使用[冻结分布](#freezing-a-distribution)的技术来最小化重复，如下所述。
- en: Shape parameters
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状参数
- en: While a general continuous random variable can be shifted and scaled with the
    `loc` and `scale` parameters, some distributions require additional shape parameters.
    For instance, the gamma distribution with density
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一般连续随机变量可以通过`loc`和`scale`参数进行移位和缩放，但某些分布需要额外的形状参数。 例如，具有密度的伽玛分布
- en: \[\gamma(x, a) = \frac{\lambda (\lambda x)^{a-1}}{\Gamma(a)} e^{-\lambda x}\;,\]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: \[\gamma(x, a) = \frac{\lambda (\lambda x)^{a-1}}{\Gamma(a)} e^{-\lambda x}\;,\]
- en: requires the shape parameter \(a\). Observe that setting \(\lambda\) can be
    obtained by setting the `scale` keyword to \(1/\lambda\).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要形状参数\(a\)的分布。 注意，通过将`scale`关键字设置为\(1/\lambda\)可以获得\(\lambda\)。
- en: Let’s check the number and name of the shape parameters of the gamma distribution.
    (We know from the above that this should be 1.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查伽玛分布的形状参数的数量和名称。 （我们从上面知道应该是1。）
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we set the value of the shape variable to 1 to obtain the exponential distribution,
    so that we compare easily whether we get the results we expect.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将形状变量的值设为1，以获得指数分布，以便轻松比较我们是否得到预期的结果。
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that we can also specify shape parameters as keywords:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以将形状参数指定为关键词：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Freezing a distribution
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冻结分布
- en: Passing the `loc` and `scale` keywords time and again can become quite bothersome.
    The concept of *freezing* a RV is used to solve such problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 反复传递`loc`和`scale`关键字可能会变得非常麻烦。 使用*冻结*随机变量的概念来解决此类问题。
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By using `rv` we no longer have to include the scale or the shape parameters
    anymore. Thus, distributions can be used in one of two ways, either by passing
    all distribution parameters to each method call (such as we did earlier) or by
    freezing the parameters for the instance of the distribution. Let us check this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`rv`，我们不再需要在每次方法调用中包含尺度或形状参数了。因此，分布可以通过两种方式之一使用，要么将所有分布参数传递给每个方法调用（例如之前所做的），要么冻结分布实例的参数。让我们来检查一下：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is, indeed, what we should get.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是我们应该得到的结果。
- en: Broadcasting
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播
- en: The basic methods `pdf`, and so on, satisfy the usual numpy broadcasting rules.
    For example, we can calculate the critical values for the upper tail of the t
    distribution for different probabilities and degrees of freedom.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本方法`pdf`等符合通常的numpy广播规则。例如，我们可以计算不同概率和自由度的t分布上尾的临界值。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, the first row contains the critical values for 10 degrees of freedom
    and the second row for 11 degrees of freedom (d.o.f.). Thus, the broadcasting
    rules give the same result of calling `isf` twice:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，第一行包含10自由度的临界值，第二行包含11自由度（d.o.f.）。因此，广播规则使得两次调用`isf`得到相同的结果： '
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the array with probabilities, i.e., `[0.1, 0.05, 0.01]` and the array of
    degrees of freedom i.e., `[10, 11, 12]`, have the same array shape, then element-wise
    matching is used. As an example, we can obtain the 10% tail for 10 d.o.f., the
    5% tail for 11 d.o.f. and the 1% tail for 12 d.o.f. by calling
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果概率数组，即`[0.1, 0.05, 0.01]`和自由度数组，即`[10, 11, 12]`具有相同的数组形状，则使用逐元素匹配。例如，我们可以通过调用以下方式获得10自由度的10%尾部，11自由度的5%尾部和12自由度的1%尾部。
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '### Specific points for discrete distributions'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '### 离散分布的特定点'
- en: Discrete distributions have mostly the same basic methods as the continuous
    distributions. However `pdf` is replaced by the probability mass function `pmf`,
    no estimation methods, such as fit, are available, and `scale` is not a valid
    keyword parameter. The location parameter, keyword `loc`, can still be used to
    shift the distribution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 离散分布与连续分布大多数具有相同的基本方法。但是，`pdf`被概率质量函数`pmf`替代，没有可用的估计方法（例如拟合），而`scale`不是有效的关键字参数。仍然可以使用位置参数关键字`loc`来移动分布。
- en: 'The computation of the cdf requires some extra attention. In the case of continuous
    distribution, the cumulative distribution function is, in most standard cases,
    strictly monotonic increasing in the bounds (a,b) and has, therefore, a unique
    inverse. The cdf of a discrete distribution, however, is a step function, hence
    the inverse cdf, i.e., the percent point function, requires a different definition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 计算累积分布函数（cdf）需要额外注意。在连续分布的情况下，累积分布函数在界限（a，b）内在大多数标准情况下是严格单调递增的，因此具有唯一的反函数。然而，离散分布的累积分布函数是一个步骤函数，因此反函数即百分位点函数需要不同的定义：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For further info, see the docs [here](stats/discrete.html#discrete-ppf).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 获取更多信息，请参阅此处的文档[here](stats/discrete.html#discrete-ppf)。
- en: We can look at the hypergeometric distribution as an example
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以超几何分布为例
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we use the cdf at some integer points and then evaluate the ppf at those
    cdf values, we get the initial integers back, for example
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在某些整数点使用累积分布函数（cdf），然后在这些cdf值上评估百分位点函数（ppf），我们可以得到初始的整数值，例如
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we use values that are not at the kinks of the cdf step function, we get
    the next higher integer back:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的值不是累积分布函数（cdf）步骤函数的拐点，则会得到下一个更高的整数值：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Fitting distributions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拟合分布
- en: 'The main additional methods of the not frozen distribution are related to the
    estimation of distribution parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 未冻结分布的主要附加方法与分布参数的估计有关：
- en: 'fit: maximum likelihood estimation of distribution parameters, including location'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fit：包括位置的分布参数的最大似然估计
- en: and scale
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和尺度
- en: 'fit_loc_scale: estimation of location and scale when shape parameters are given'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fit_loc_scale：在给定形状参数时估计位置和尺度
- en: 'nnlf: negative log likelihood function'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nnlf：负对数似然函数
- en: 'expect: calculate the expectation of a function against the pdf or pmf'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expect：计算函数对pdf或pmf的期望
- en: '### Performance issues and cautionary remarks'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '### 性能问题和注意事项'
- en: 'The performance of the individual methods, in terms of speed, varies widely
    by distribution and method. The results of a method are obtained in one of two
    ways: either by explicit calculation, or by a generic algorithm that is independent
    of the specific distribution.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就个体方法的性能而言，速度方面有很大的差异，这些方法的结果是通过显式计算或与特定分布无关的通用算法之一获得的。
- en: Explicit calculation, on the one hand, requires that the method is directly
    specified for the given distribution, either through analytic formulas or through
    special functions in `scipy.special` or `numpy.random` for `rvs`. These are usually
    relatively fast calculations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显式计算，一方面要求对于给定的分布直接指定方法，可以是通过解析公式或`scipy.special`或`numpy.random`中的特殊函数进行计算。这些通常是相对快速的计算。
- en: The generic methods, on the other hand, are used if the distribution does not
    specify any explicit calculation. To define a distribution, only one of pdf or
    cdf is necessary; all other methods can be derived using numeric integration and
    root finding. However, these indirect methods can be *very* slow. As an example,
    `rgh = stats.gausshyper.rvs(0.5, 2, 2, 2, size=100)` creates random variables
    in a very indirect way and takes about 19 seconds for 100 random variables on
    my computer, while one million random variables from the standard normal or from
    the t distribution take just above one second.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果分布未指定任何显式计算，则使用通用方法。要定义一个分布，只需要pdf或cdf中的一个；所有其他方法可以使用数值积分和根查找导出。然而，这些间接方法可能非常*慢*。例如，`rgh
    = stats.gausshyper.rvs(0.5, 2, 2, 2, size=100)`以非常间接的方式创建随机变量，在我的计算机上为100个随机变量大约需要19秒，而从标准正态分布或t分布中生成一百万个随机变量仅需要超过一秒。
- en: Remaining issues
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余问题
- en: 'The distributions in `scipy.stats` have recently been corrected and improved
    and gained a considerable test suite; however, a few issues remain:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.stats`中的分布最近已经得到了修正和改进，并增加了相当多的测试套件；然而，还有一些问题存在：'
- en: The distributions have been tested over some range of parameters; however, in
    some corner ranges, a few incorrect results may remain.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经对分布在一些参数范围内进行了测试；然而，在某些角落范围内，可能仍然存在一些不正确的结果。
- en: The maximum likelihood estimation in *fit* does not work with default starting
    parameters for all distributions and the user needs to supply good starting parameters.
    Also, for some distribution using a maximum likelihood estimator might inherently
    not be the best choice.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fit*中的最大似然估计不能使用所有分布的默认起始参数，并且用户需要提供良好的起始参数。此外，对于某些分布来说，使用最大似然估计可能本质上并不是最佳选择。'
- en: Building specific distributions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建特定的分布
- en: The next examples shows how to build your own distributions. Further examples
    show the usage of the distributions and some statistical tests.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何构建自己的分布。更多示例展示了分布的使用和一些统计测试。
- en: Making a continuous distribution, i.e., subclassing `rv_continuous`
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作连续分布，即子类化`rv_continuous`
- en: Making continuous distributions is fairly simple.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 制作连续分布是相当简单的。
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Interestingly, the `pdf` is now computed automatically:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`pdf`现在自动计算：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Be aware of the performance issues mentioned in [Performance issues and cautionary
    remarks](#performance-issues-label). The computation of unspecified common methods
    can become very slow, since only general methods are called, which, by their very
    nature, cannot use any specific information about the distribution. Thus, as a
    cautionary example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[性能问题和警告](#performance-issues-label)中提到的性能问题。未指定的常见方法的计算可能变得非常慢，因为只调用通用方法，这些方法本质上不能使用关于分布的任何具体信息。因此，作为一个警示例子：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But this is not correct: the integral over this pdf should be 1\. Let’s make
    the integration interval smaller:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是不正确的：该pdf的积分应该为1\. 让我们缩小积分区间：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This looks better. However, the problem originated from the fact that the pdf
    is not specified in the class definition of the deterministic distribution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更好了。然而，问题的根源在于确定性分布类定义中未指定pdf。
- en: Subclassing `rv_discrete`
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类化`rv_discrete`
- en: In the following, we use [`stats.rv_discrete`](../reference/generated/scipy.stats.rv_discrete.html#scipy.stats.rv_discrete
    "scipy.stats.rv_discrete") to generate a discrete distribution that has the probabilities
    of the truncated normal for the intervals centered around the integers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们使用[`stats.rv_discrete`](../reference/generated/scipy.stats.rv_discrete.html#scipy.stats.rv_discrete
    "scipy.stats.rv_discrete")生成一个离散分布，该分布具有以整数为中心的间隔的截断正态的概率。
- en: '**General info**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般信息**'
- en: From the docstring of rv_discrete, `help(stats.rv_discrete)`,
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从`help(stats.rv_discrete)`的文档字符串中，
- en: “You can construct an arbitrary discrete rv where P{X=xk} = pk by passing to
    the rv_discrete initialization method (through the values= keyword) a tuple of
    sequences (xk, pk) which describes only those values of X (xk) that occur with
    nonzero probability (pk).”
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “您可以通过将 (xk, pk) 元组传递给 rv_discrete 初始化方法（通过 values= 关键字），来构造一个任意的离散随机变量，其中 P{X=xk}
    = pk，该元组仅描述了具有非零概率的 X 值 (xk)。”
- en: 'Next to this, there are some further requirements for this approach to work:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种方法需要满足一些进一步的要求：
- en: The keyword *name* is required.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 *name* 是必需的。
- en: The support points of the distribution xk have to be integers.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布的支持点 xk 必须是整数。
- en: The number of significant digits (decimals) needs to be specified.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要指定有效数字（小数点位数）。
- en: In fact, if the last two requirements are not satisfied, an exception may be
    raised or the resulting numbers may be incorrect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果不满足最后两个要求，则可能会引发异常或生成的数字可能不正确。
- en: '**An example**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个例子**'
- en: 'Let’s do the work. First:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作。首先：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And, finally, we can subclass `rv_discrete`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以派生自 `rv_discrete`：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we have defined the distribution, we have access to all common methods
    of discrete distributions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了分布，我们可以访问所有离散分布的常用方法。
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Testing the implementation**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试实现**'
- en: Let’s generate a random sample and compare observed frequencies with the probabilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成一个随机样本并比较观察频率与概率。
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '!["An X-Y histogram plot showing the distribution of random variates. A blue
    trace shows a normal bell curve. A blue bar chart perfectly approximates the curve
    showing the true distribution. A red bar chart representing the sample is well
    described by the blue trace but not exact."](../Images/50524857269cde7853e5d5ee82f3a2dd.png)!["An
    X-Y histogram plot showing the cumulative distribution of random variates. A blue
    trace shows a CDF for a typical normal distribution. A blue bar chart perfectly
    approximates the curve showing the true distribution. A red bar chart representing
    the sample is well described by the blue trace but not exact."](../Images/cc47b822846571e2684255cfe466c42f.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '!["显示随机变量分布的 X-Y 直方图图。蓝色曲线显示正态钟形曲线。蓝色柱状图完美地近似显示真实分布的曲线。红色柱状图表示样本很好地由蓝色曲线描述，但并非完全相同。"](../Images/50524857269cde7853e5d5ee82f3a2dd.png)!["显示随机变量累积分布的
    X-Y 直方图图。蓝色曲线显示典型正态分布的累积分布函数（CDF）。蓝色柱状图完美地近似显示真实分布的曲线。红色柱状图表示样本很好地由蓝色曲线描述，但并非完全相同。"](../Images/cc47b822846571e2684255cfe466c42f.png)'
- en: Next, we can test whether our sample was generated by our norm-discrete distribution.
    This also verifies whether the random numbers were generated correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以测试我们的样本是否由我们的离散正态分布生成。这也验证了随机数是否生成正确。
- en: The chisquare test requires that there are a minimum number of observations
    in each bin. We combine the tail bins into larger bins so that they contain enough
    observations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方检验要求每个箱中至少有一定数量的观测值。我们将尾箱合并成更大的箱，以确保它们包含足够的观测值。
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The pvalue in this case is high, so we can be quite confident that our random
    sample was actually generated by the distribution.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，p 值很高，因此我们可以非常确信我们的随机样本确实是由该分布生成的。
- en: Analysing one sample
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析一个样本
- en: 'First, we create some random variables. We set a seed so that in each run we
    get identical results to look at. As an example we take a sample from the Student
    t distribution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一些随机变量。我们设置一个种子，以便每次运行时获得相同的结果以进行查看。例如，我们从学生 t 分布中取一个样本：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we set the required shape parameter of the t distribution, which in statistics
    corresponds to the degrees of freedom, to 10\. Using size=1000 means that our
    sample consists of 1000 independently drawn (pseudo) random numbers. Since we
    did not specify the keyword arguments *loc* and *scale*, those are set to their
    default values zero and one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 t 分布的所需形状参数，它在统计学上对应于自由度，设置 size=1000 意味着我们的样本包含 1000 个独立抽取的（伪）随机数。由于我们未指定关键字参数
    *loc* 和 *scale*，它们被设置为它们的默认值零和一。
- en: Descriptive statistics
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述统计
- en: '*x* is a numpy array, and we have direct access to all array methods, e.g.,'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 是一个 numpy 数组，我们可以直接访问所有数组方法，例如，'
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How do the sample properties compare to their theoretical counterparts?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 样本属性如何与其理论对应物比较？
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note: [`stats.describe`](../reference/generated/scipy.stats.describe.html#scipy.stats.describe
    "scipy.stats.describe") uses the unbiased estimator for the variance, while np.var
    is the biased estimator.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：[`stats.describe`](../reference/generated/scipy.stats.describe.html#scipy.stats.describe
    "scipy.stats.describe") 使用无偏估计器计算方差，而 `np.var` 使用的是有偏估计器。
- en: For our sample the sample statistics differ a by a small amount from their theoretical
    counterparts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的样本，样本统计数据与它们的理论对应物略有不同。
- en: T-test and KS-test
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: T检验和KS检验
- en: We can use the t-test to test whether the mean of our sample differs in a statistically
    significant way from the theoretical expectation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用t检验来测试我们的样本平均值是否在统计上显著地不同于理论期望。
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The pvalue is 0.7, this means that with an alpha error of, for example, 10%,
    we cannot reject the hypothesis that the sample mean is equal to zero, the expectation
    of the standard t-distribution.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: P值为0.7，这意味着在例如10%的alpha误差下，我们无法拒绝样本均值等于零的假设，即标准t分布的期望。
- en: 'As an exercise, we can calculate our ttest also directly without using the
    provided function, which should give us the same answer, and so it does:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们也可以直接计算我们的t检验，而不使用提供的函数，这应该会给我们相同的答案，确实如此：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The Kolmogorov-Smirnov test can be used to test the hypothesis that the sample
    comes from the standard t-distribution
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Kolmogorov-Smirnov检验可用于测试样本是否来自标准t分布的假设。
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Again, the p-value is high enough that we cannot reject the hypothesis that
    the random sample really is distributed according to the t-distribution. In real
    applications, we don’t know what the underlying distribution is. If we perform
    the Kolmogorov-Smirnov test of our sample against the standard normal distribution,
    then we also cannot reject the hypothesis that our sample was generated by the
    normal distribution given that, in this example, the p-value is almost 40%.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，P值足够高，我们无法拒绝随机样本确实按照t分布分布的假设。在实际应用中，我们不知道底层分布是什么。如果我们对样本执行Kolmogorov-Smirnov检验，以检验其是否符合标准正态分布，则同样不能拒绝我们的样本是由正态分布生成的假设，因为在本例中，P值几乎为40%。
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However, the standard normal distribution has a variance of 1, while our sample
    has a variance of 1.29\. If we standardize our sample and test it against the
    normal distribution, then the p-value is again large enough that we cannot reject
    the hypothesis that the sample came form the normal distribution.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标准正态分布的方差为1，而我们的样本方差为1.29。如果我们对样本进行标准化，并将其与正态分布进行检验，则P值再次足够大，我们无法拒绝样本来自正态分布的假设。
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note: The Kolmogorov-Smirnov test assumes that we test against a distribution
    with given parameters, since, in the last case, we estimated mean and variance,
    this assumption is violated and the distribution of the test statistic, on which
    the p-value is based, is not correct.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Kolmogorov-Smirnov检验假定我们针对具有给定参数的分布进行检验，由于在最后一种情况下，我们估计了均值和方差，这一假设被违反，并且基于此的P值的检验统计分布不正确。
- en: Tails of the distribution
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布的尾部
- en: Finally, we can check the upper tail of the distribution. We can use the percent
    point function ppf, which is the inverse of the cdf function, to obtain the critical
    values, or, more directly, we can use the inverse of the survival function
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查分布的上尾部。我们可以使用百分位点函数PPF，它是CDF函数的反函数，来获取临界值，或者更直接地，我们可以使用生存函数的反函数。
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In all three cases, our sample has more weight in the top tail than the underlying
    distribution. We can briefly check a larger sample to see if we get a closer match.
    In this case, the empirical frequency is quite close to the theoretical probability,
    but if we repeat this several times, the fluctuations are still pretty large.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种情况下，我们的样本在尾部的权重比底层分布更大。我们可以简要检查一个更大的样本，看看是否能更接近匹配。在这种情况下，经验频率与理论概率非常接近，但如果我们重复几次，波动仍然相当大。
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also compare it with the tail of the normal distribution, which has
    less weight in the tails:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将其与正态分布的尾部进行比较，正态分布在尾部的权重较小：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The chisquare test can be used to test whether for a finite number of bins,
    the observed frequencies differ significantly from the probabilities of the hypothesized
    distribution.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 卡方检验可用于测试有限数量的箱子，观察到的频率是否显著不同于假设分布的概率。
- en: '[PRE56]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We see that the standard normal distribution is clearly rejected, while the
    standard t-distribution cannot be rejected. Since the variance of our sample differs
    from both standard distributions, we can again redo the test taking the estimate
    for scale and location into account.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到标准正态分布明显被拒绝，而标准 t 分布则无法被拒绝。由于我们样本的方差与两个标准分布都不同，我们可以再次考虑估计尺度和位置来重新进行测试。
- en: The fit method of the distributions can be used to estimate the parameters of
    the distribution, and the test is repeated using probabilities of the estimated
    distribution.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 分布的拟合方法可用于估计分布的参数，并且使用估计分布的概率重复进行测试。
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Taking account of the estimated parameters, we can still reject the hypothesis
    that our sample came from a normal distribution (at the 5% level), but again,
    with a p-value of 0.95, we cannot reject the t-distribution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到估计的参数，我们仍然可以拒绝我们的样本来自正态分布的假设（在 5% 的水平上），但同样地，我们无法拒绝 t 分布，其 p 值为 0.95。
- en: Special tests for normal distributions
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正态分布的特殊测试
- en: Since the normal distribution is the most common distribution in statistics,
    there are several additional functions available to test whether a sample could
    have been drawn from a normal distribution.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正态分布是统计学中最常见的分布，有几个额外的函数可用于测试样本是否可能来自正态分布。
- en: 'First, we can test if skew and kurtosis of our sample differ significantly
    from those of a normal distribution:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以测试我们样本的偏度和峰度是否显著不同于正态分布：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: These two tests are combined in the normality test
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试被合并到正态性测试中
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In all three tests, the p-values are very low and we can reject the hypothesis
    that the our sample has skew and kurtosis of the normal distribution.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三个测试中，p 值非常低，我们可以拒绝我们的样本具有正态分布的假设。
- en: 'Since skew and kurtosis of our sample are based on central moments, we get
    exactly the same results if we test the standardized sample:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们样本的偏度和峰度基于中心矩，如果我们测试标准化样本，我们得到完全相同的结果：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because normality is rejected so strongly, we can check whether the normaltest
    gives reasonable results for other cases:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正态性被强烈拒绝，我们可以检查正态测试是否对其他情况给出合理的结果：
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When testing for normality of a small sample of t-distributed observations and
    a large sample of normal-distributed observations, then in neither case can we
    reject the null hypothesis that the sample comes from a normal distribution. In
    the first case, this is because the test is not powerful enough to distinguish
    a t and a normally distributed random variable in a small sample.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试小样本的 t 分布观测值和大样本的正态分布观测值的正态性时，在两种情况下我们都无法拒绝样本来自正态分布的原假设。在第一种情况下，这是因为测试不足以区分小样本中的
    t 分布和正态分布随机变量。
- en: Comparing two samples
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较两个样本
- en: In the following, we are given two samples, which can come either from the same
    or from different distribution, and we want to test whether these samples have
    the same statistical properties.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们得到了两个样本，可以来自相同或不同的分布，我们想要测试这些样本是否具有相同的统计特性。
- en: Comparing means
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较均值
- en: 'Test with sample with identical means:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试样本的均值是否相同：
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Test with sample with different means:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 测试具有不同均值的样本：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Kolmogorov-Smirnov test for two samples ks_2samp
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kolmogorov-Smirnov 测试两个样本的 ks_2samp
- en: For the example, where both samples are drawn from the same distribution, we
    cannot reject the null hypothesis, since the pvalue is high
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从同一分布中抽取的样本，我们无法拒绝原假设，因为 p 值很高。
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the second example, with different location, i.e., means, we can reject the
    null hypothesis, since the pvalue is below 1%
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，即具有不同位置（即均值）的情况下，我们可以拒绝原假设，因为 p 值低于 1%。
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Kernel density estimation
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核密度估计
- en: A common task in statistics is to estimate the probability density function
    (PDF) of a random variable from a set of data samples. This task is called density
    estimation. The most well-known tool to do this is the histogram. A histogram
    is a useful tool for visualization (mainly because everyone understands it), but
    doesn’t use the available data very efficiently. Kernel density estimation (KDE)
    is a more efficient tool for the same task. The [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") estimator can be used to estimate the PDF of univariate
    as well as multivariate data. It works best if the data is unimodal.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中的一个常见任务是从一组数据样本中估计随机变量的概率密度函数（PDF）。这个任务被称为密度估计。最著名的工具是直方图。直方图是一种用于可视化的有用工具（主要是因为每个人都能理解它），但是它没有有效地使用可用的数据。核密度估计（KDE）是同一任务的更有效工具。[`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde)
    估计器可用于估计单变量和多变量数据的PDF。如果数据是单峰的话，它的效果最好。
- en: Univariate estimation
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单变量估计
- en: 'We start with a minimal amount of data in order to see how [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") works and what the different options for bandwidth
    selection do. The data sampled from the PDF are shown as blue dashes at the bottom
    of the figure (this is called a rug plot):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最少量的数据开始，以了解[`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde)的工作原理以及带宽选择的不同选项。从PDF中采样的数据显示为图的底部蓝色虚线（称为拉格图）：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![" "](../Images/999859b9f1bdb01b50f77fc17168c334.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/999859b9f1bdb01b50f77fc17168c334.png)'
- en: We see that there is very little difference between Scott’s Rule and Silverman’s
    Rule, and that the bandwidth selection with a limited amount of data is probably
    a bit too wide. We can define our own bandwidth function to get a less smoothed-out
    result.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现**Scott's Rule**和**Silverman's Rule**之间的差异非常小，而且在有限的数据量下，带宽选择可能有点过宽。我们可以定义自己的带宽函数来获得更少平滑的结果。
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![" "](../Images/22dada26ab14103a09b802c241471c4a.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/22dada26ab14103a09b802c241471c4a.png)'
- en: We see that if we set bandwidth to be very narrow, the obtained estimate for
    the probability density function (PDF) is simply the sum of Gaussians around each
    data point.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，如果将带宽设置得非常窄，得到的概率密度函数（PDF）估计值就简单地是围绕每个数据点的高斯函数之和。
- en: We now take a more realistic example and look at the difference between the
    two available bandwidth selection rules. Those rules are known to work well for
    (close to) normal distributions, but even for unimodal distributions that are
    quite strongly non-normal they work reasonably well. As a non-normal distribution
    we take a Student’s T distribution with 5 degrees of freedom.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个更现实的例子，并比较两种可用带宽选择规则之间的差异。这些规则已知对（接近）正态分布很有效，但即使对于非常强烈非正态的单峰分布，它们也能工作得相当好。作为一个非正态分布，我们采用自由度为5的学生T分布。
- en: '[PRE75]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![" "](../Images/95c55c39eeb87b0055a47ebcd6fc28db.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/95c55c39eeb87b0055a47ebcd6fc28db.png)'
- en: We now take a look at a bimodal distribution with one wider and one narrower
    Gaussian feature. We expect that this will be a more difficult density to approximate,
    due to the different bandwidths required to accurately resolve each feature.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个双峰分布，其中一个特征的高斯较宽，另一个特征的高斯较窄。我们预期这将是一个更难近似的密度，因为需要精确解析每个特征所需的不同带宽。
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '![" "](../Images/9c2feee5e554adae99dabb2238559bb6.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/9c2feee5e554adae99dabb2238559bb6.png)'
- en: As expected, the KDE is not as close to the true PDF as we would like due to
    the different characteristic size of the two features of the bimodal distribution.
    By halving the default bandwidth (`Scott * 0.5`), we can do somewhat better, while
    using a factor 5 smaller bandwidth than the default doesn’t smooth enough. What
    we really need, though, in this case, is a non-uniform (adaptive) bandwidth.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于双峰分布两个特征的不同特征尺寸，KDE与真实PDF的接近程度并不如我们希望的那样。通过将默认带宽减半（`Scott * 0.5`），我们可以稍微改善一些，而使用比默认带宽小5倍的因子则不足以平滑。然而，在这种情况下，我们真正需要的是非均匀（自适应）带宽。
- en: Multivariate estimation
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多变量估计
- en: With [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") we can perform multivariate, as well as univariate
    estimation. We demonstrate the bivariate case. First, we generate some random
    data with a model in which the two variates are correlated.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") 我们可以进行多变量以及单变量估计。这里展示了双变量情况。首先，我们生成一些随机数据，模拟两个变量之间的相关性。
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then we apply the KDE to the data:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将KDE应用于数据：
- en: '[PRE86]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Finally, we plot the estimated bivariate distribution as a colormap and plot
    the individual data points on top.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将估计的双变量分布作为色彩映射图绘制出来，并在顶部绘制个别数据点。
- en: '[PRE87]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '!["An X-Y plot showing a random scattering of points around a 2-D gaussian.
    The distribution has a semi-major axis at 45 degrees with a semi-minor axis about
    half as large. Each point in the plot is highlighted with the outer region in
    red, then yellow, then green, with the center in blue. "](../Images/d07675295fa3a9c5c4716026552854e7.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![“显示点围绕二维高斯随机散布的X-Y图。分布的半长轴呈45度，半短轴大约是其一半。图中每个点都用外围区域标为红色、黄色、绿色，中心为蓝色。”](../Images/d07675295fa3a9c5c4716026552854e7.png)'
- en: Multiscale Graph Correlation (MGC)
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多尺度图相关性（MGC）
- en: 'With [`multiscale_graphcorr`](../reference/generated/scipy.stats.multiscale_graphcorr.html#scipy.stats.multiscale_graphcorr
    "scipy.stats.multiscale_graphcorr"), we can test for independence on high dimensional
    and nonlinear data. Before we start, let’s import some useful packages:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`multiscale_graphcorr`](../reference/generated/scipy.stats.multiscale_graphcorr.html#scipy.stats.multiscale_graphcorr
    "scipy.stats.multiscale_graphcorr")，我们可以对高维和非线性数据进行独立性测试。在开始之前，让我们导入一些有用的包：
- en: '[PRE91]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let’s use a custom plotting function to plot the data relationship:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用自定义绘图函数来绘制数据关系：
- en: '[PRE92]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let’s look at some linear data first:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一些线性数据：
- en: '[PRE93]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The simulation relationship can be plotted below:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下方绘制模拟关系：
- en: '[PRE94]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '![" "](../Images/70b40b36230d43e18094daaefc5d9455.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![“ ”](../Images/70b40b36230d43e18094daaefc5d9455.png)'
- en: 'Now, we can see the test statistic, p-value, and MGC map visualized below.
    The optimal scale is shown on the map as a red “x”:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到测试统计量、p值和MGC地图在下方进行了可视化。最优尺度显示为地图上的红色“x”：
- en: '[PRE95]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '![" "](../Images/bf2f505a205c76ed9bf00832fc1145ad.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![“ ”](../Images/bf2f505a205c76ed9bf00832fc1145ad.png)'
- en: It is clear from here, that MGC is able to determine a relationship between
    the input data matrices because the p-value is very low and the MGC test statistic
    is relatively high. The MGC-map indicates a **strongly linear relationship**.
    Intuitively, this is because having more neighbors will help in identifying a
    linear relationship between \(x\) and \(y\). The optimal scale in this case is
    **equivalent to the global scale**, marked by a red spot on the map.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可以清楚地看出，MGC能够确定输入数据矩阵之间的关系，因为p值非常低，而MGC检验统计量相对较高。MGC地图指示出**强烈的线性关系**。直观上来说，这是因为拥有更多的邻居将有助于识别
    \(x\) 和 \(y\) 之间的线性关系。在这种情况下，最优尺度等同于全局尺度，用地图上的红点标记。
- en: 'The same can be done for nonlinear data sets. The following \(x\) and \(y\)
    arrays are derived from a nonlinear simulation:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非线性数据集，同样可以执行相同操作。以下的 \(x\) 和 \(y\) 数组来自非线性模拟：
- en: '[PRE96]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The simulation relationship can be plotted below:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在下方绘制模拟关系：
- en: '[PRE97]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '![" "](../Images/12d7e85c2ab600adb6197d6591909048.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![“ ”](../Images/12d7e85c2ab600adb6197d6591909048.png)'
- en: 'Now, we can see the test statistic, p-value, and MGC map visualized below.
    The optimal scale is shown on the map as a red “x”:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到测试统计量、p值和MGC地图在下方进行了可视化。最优尺度显示为地图上的红色“x”：
- en: '[PRE98]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '![" "](../Images/a450e054c3a723a385379175db9c099f.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![“ ”](../Images/a450e054c3a723a385379175db9c099f.png)'
- en: It is clear from here, that MGC is able to determine a relationship again because
    the p-value is very low and the MGC test statistic is relatively high. The MGC-map
    indicates a **strongly nonlinear relationship**. The optimal scale in this case
    is **equivalent to the local scale**, marked by a red spot on the map.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里可以清楚地看出，MGC能够再次确定关系，因为p值非常低，而MGC检验统计量相对较高。MGC地图指示出**强烈的非线性关系**。在这种情况下，最优尺度等同于局部尺度，用地图上的红点标记。
- en: '## Quasi-Monte Carlo'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '## 拟准蒙特卡罗'
- en: 'Before talking about Quasi-Monte Carlo (QMC), a quick introduction about Monte
    Carlo (MC). MC methods, or MC experiments, are a broad class of computational
    algorithms that rely on repeated random sampling to obtain numerical results.
    The underlying concept is to use randomness to solve problems that might be deterministic
    in principle. They are often used in physical and mathematical problems and are
    most useful when it is difficult or impossible to use other approaches. MC methods
    are mainly used in three problem classes: optimization, numerical integration,
    and generating draws from a probability distribution.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论准蒙特卡洛（QMC）之前，先快速介绍一下蒙特卡洛（MC）。MC方法，或MC实验，是一类广泛的计算算法，依赖于重复随机抽样来获得数值结果。其基本概念是利用随机性来解决在原则上可能是确定性的问题。它们通常用于物理和数学问题，并且在难以或不可能使用其他方法时最为有用。MC方法主要用于三类问题：优化、数值积分和从概率分布中生成抽样。
- en: Generating random numbers with specific properties is a more complex problem
    than it sounds. Simple MC methods are designed to sample points to be independent
    and identically distributed (IID). But generating multiple sets of random points
    can produce radically different results.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特定属性的随机数生成比听起来更复杂。简单的MC方法旨在采样独立同分布的点。但生成多组随机点可能会产生完全不同的结果。
- en: '![" "](../Images/c8b0e03b61a94c47004310d063a31309.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/c8b0e03b61a94c47004310d063a31309.png)'
- en: In both cases in the plot above, points are generated randomly without any knowledge
    about previously drawn points. It is clear that some regions of the space are
    left unexplored - which can cause problems in simulations as a particular set
    of points might trigger a totally different behaviour.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述图中的两种情况中，点是随机生成的，不了解之前绘制的点。显然，空间的某些区域未被探索——这可能在模拟中造成问题，因为特定的点集可能会触发完全不同的行为。
- en: 'A great benefit of MC is that it has known convergence properties. Let’s look
    at the mean of the squared sum in 5 dimensions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛（MC）的一个巨大优势是它具有已知的收敛性质。让我们来看看在5维空间中平方和的均值：
- en: \[f(\mathbf{x}) = \left( \sum_{j=1}^{5}x_j \right)^2,\]
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: \[f(\mathbf{x}) = \left( \sum_{j=1}^{5}x_j \right)^2,\]
- en: with \(x_j \sim \mathcal{U}(0,1)\). It has a known mean value, \(\mu = 5/3+5(5-1)/4\).
    Using MC sampling, we can compute that mean numerically, and the approximation
    error follows a theoretical rate of \(O(n^{-1/2})\).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，\(x_j \sim \mathcal{U}(0,1)\)。它具有已知的均值，\(\mu = 5/3+5(5-1)/4\)。使用MC抽样，我们可以数值计算这个均值，并且近似误差遵循理论速率\(O(n^{-1/2})\)。
- en: '![" "](../Images/a796255c383c0c75178d5631e20c4783.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/a796255c383c0c75178d5631e20c4783.png)'
- en: 'Although the convergence is ensured, practitioners tend to want to have an
    exploration process which is more deterministic. With normal MC, a seed can be
    used to have a repeatable process. But fixing the seed would break the convergence
    property: a given seed could work for a given class of problem and break for another
    one.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管收敛性是确保的，实践者倾向于希望有一个更确定性的探索过程。使用普通的MC，可以使用种子来获得可重复的过程。但是固定种子会破坏收敛性质：一个给定的种子可以对一类问题有效，但对另一类问题无效。
- en: What is commonly done to walk through the space in a deterministic manner, is
    to use a regular grid spanning all parameter dimensions, also called a saturated
    design. Let’s consider the unit-hypercube, with all bounds ranging from 0 to 1\.
    Now, having a distance of 0.1 between points, the number of points required to
    fill the unit interval would be 10\. In a 2-dimensional hypercube the same spacing
    would require 100, and in 3 dimensions 1,000 points. As the number of dimensions
    grows, the number of experiments which is required to fill the space rises exponentially
    as the dimensionality of the space increases. This exponential growth is called
    “the curse of dimensionality”.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以确定性方式穿过空间，通常使用跨越所有参数维度的常规网格，也称为饱和设计。让我们考虑单位超立方体，所有边界从0到1。现在，点之间的距离为0.1，填充单位间隔所需的点数将是10。在二维超立方体中，相同的间距需要100个点，而在三维中则需要1,000个点。随着维度数量的增加，填充空间所需的实验数量将呈指数增长。这种指数增长被称为“维数灾难”。
- en: '[PRE99]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '![" "](../Images/de858c495c1c5ebc0870ec483f7835c5.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/de858c495c1c5ebc0870ec483f7835c5.png)'
- en: To mitigate this issue, QMC methods have been designed. They are deterministic,
    have a good coverage of the space and some of them can be continued and retain
    good properties. The main difference with MC methods is that the points are not
    IID but they know about previous points. Hence, some methods are also referred
    to as sequences.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，设计了QMC方法。它们是确定性的，对空间覆盖良好，其中一些可以继续并保持良好的特性。与MC方法的主要区别在于，这些点不是独立同分布的，而是知道之前的点。因此，有些方法也被称为序列。
- en: '![" "](../Images/adcb64ba701338ef5728a030fa9dd160.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/adcb64ba701338ef5728a030fa9dd160.png)'
- en: This figure presents 2 sets of 256 points. The design of the left is a plain
    MC whereas the design of the right is a QMC design using the *Sobol’* method.
    We clearly see that the QMC version is more uniform. The points sample better
    near the boundaries and there are less clusters or gaps.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此图展示了2组256个点。左侧的设计是普通的MC，而右侧的设计是使用*Sobol’* 方法的QMC设计。我们清楚地看到QMC版本更均匀。点样本更接近边界，且聚集和间隙较少。
- en: One way to assess the uniformity is to use a measure called the discrepancy.
    Here the discrepancy of *Sobol’* points is better than crude MC.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 评估均匀性的一种方法是使用称为差异的度量。这里*Sobol’*点的差异比粗糙的MC方法更好。
- en: 'Coming back to the computation of the mean, QMC methods also have better rates
    of convergence for the error. They can achieve \(O(n^{-1})\) for this function,
    and even better rates on very smooth functions. This figure shows that the *Sobol’*
    method has a rate of \(O(n^{-1})\):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 回到平均值的计算，QMC方法对于误差的收敛速率也更好。它们可以实现\(O(n^{-1})\)的速率，对于非常平滑的函数甚至可以实现更好的速率。此图表明*Sobol’*方法具有\(O(n^{-1})\)的速率：
- en: '![" "](../Images/1d34a8884e12406bf5f80a540235690b.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/1d34a8884e12406bf5f80a540235690b.png)'
- en: We refer to the documentation of [`scipy.stats.qmc`](../reference/stats.qmc.html#module-scipy.stats.qmc
    "scipy.stats.qmc") for more mathematical details.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考[`scipy.stats.qmc`](../reference/stats.qmc.html#module-scipy.stats.qmc "scipy.stats.qmc")的文档以获取更多数学细节。
- en: Calculate the discrepancy
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算差异
- en: Let’s consider two sets of points. From the figure below, it is clear that the
    design on the left covers more of the space than the design on the right. This
    can be quantified using a [`discrepancy`](../reference/generated/scipy.stats.qmc.discrepancy.html#scipy.stats.qmc.discrepancy
    "scipy.stats.qmc.discrepancy") measure. The lower the discrepancy, the more uniform
    a sample is.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两组点集。从下图可以明显看出，左侧的设计覆盖了更多的空间，而右侧的设计则较少。可以使用称为[`discrepancy`](../reference/generated/scipy.stats.qmc.discrepancy.html#scipy.stats.qmc.discrepancy
    "scipy.stats.qmc.discrepancy")的度量来量化。差异越低，样本越均匀。
- en: '[PRE100]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![" "](../Images/e11d70f50b9578a2a46e30ec94614d73.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/e11d70f50b9578a2a46e30ec94614d73.png)'
- en: Using a QMC engine
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QMC引擎
- en: 'Several QMC samplers/engines are implemented. Here we look at two of the most
    used QMC methods: [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") and [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") sequences.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了几个QMC抽样器/引擎。这里我们看看两种最常用的QMC方法：[`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") 和 [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") 序列。
- en: '[PRE101]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '![" "](../Images/89ea2a381733ddf2abbdaee679862827.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/89ea2a381733ddf2abbdaee679862827.png)'
- en: Warning
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: QMC methods require particular care and the user must read the documentation
    to avoid common pitfalls. *Sobol’* for instance requires a number of points following
    a power of 2\. Also, thinning, burning or other point selection can break the
    properties of the sequence and result in a set of points which would not be better
    than MC.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: QMC方法需要特别小心，用户必须阅读文档以避免常见的陷阱。例如，*Sobol’* 方法要求点数是2的幂次方。此外，稀疏化、燃烧或其他点选择可能会破坏序列的性质，导致点集比MC方法更差。
- en: 'QMC engines are state-aware. Meaning that you can continue the sequence, skip
    some points, or reset it. Let’s take 5 points from [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton"). And then ask for a second set of 5 points:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: QMC引擎是状态感知的。这意味着可以继续序列、跳过某些点或重置它。让我们从[`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton")获取5个点。然后请求第二组5个点：
- en: '[PRE102]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now we reset the sequence. Asking for 5 points leads to the same first 5 points:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重置序列。请求5个点会得到相同的第一个5个点：
- en: '[PRE103]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And here we advance the sequence to get the same second set of 5 points:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们推进序列以获取相同的第二组5个点：
- en: '[PRE104]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, both [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") and [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") are scrambled. The convergence properties are better,
    and it prevents the appearance of fringes or noticeable patterns of points in
    high dimensions. There should be no practical reason not to use the scrambled
    version.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol")和[`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") 都是乱序的。收敛性能更好，并且防止在高维度中出现点的边缘或明显的模式。没有实际理由不使用乱序版本。
- en: Making a QMC engine, i.e., subclassing `QMCEngine`
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作QMC引擎，即继承`QMCEngine`
- en: To make your own [`QMCEngine`](../reference/generated/scipy.stats.qmc.QMCEngine.html#scipy.stats.qmc.QMCEngine
    "scipy.stats.qmc.QMCEngine"), a few methods have to be defined. Following is an
    example wrapping [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)").
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的[`QMCEngine`](../reference/generated/scipy.stats.qmc.QMCEngine.html#scipy.stats.qmc.QMCEngine
    "scipy.stats.qmc.QMCEngine")，必须定义几种方法。以下是一个包装[`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(在 NumPy v2.0.dev0 中)")的示例。
- en: '[PRE105]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Then we use it as any other QMC engine:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像任何其他QMC引擎一样使用它：
- en: '[PRE106]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Guidelines on using QMC
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QMC的指南
- en: QMC has rules! Be sure to read the documentation or you might have no benefit
    over MC.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QMC有规则！确保阅读文档，否则可能不会比MC有任何好处。
- en: Use [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") if you need **exactly** \(2^m\) points.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要**精确**\(2^m\)个点，请使用[`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol")。
- en: '[`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") allows to sample, or skip, an arbitrary number of points.
    This is at the cost of a slower rate of convergence than *Sobol’*.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton")允许采样或跳过任意数量的点。这是以比*Sobol''*更慢的收敛速率为代价的。'
- en: Never remove the first points of the sequence. It will destroy the properties.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要移除序列的第一个点。这将破坏其属性。
- en: Scrambling is always better.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乱序总是更好的。
- en: If you use LHS based methods, you cannot add points without losing the LHS properties.
    (There are some methods to do so, but this is not implemented.)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用基于LHS的方法，不能添加点而不丢失LHS属性。（有一些方法可以做到，但这些方法尚未实现。）
