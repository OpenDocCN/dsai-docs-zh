- en: Fourier Transforms (scipy.fft)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 傅里叶变换（scipy.fft）
- en: Original text：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html)
- en: Contents
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内容
- en: '[Fourier Transforms (](#fourier-transforms-scipy-fft)[`scipy.fft`](../reference/fft.html#module-scipy.fft
    "scipy.fft"))'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[傅里叶变换（](#fourier-transforms-scipy-fft)[`scipy.fft`](../reference/fft.html#module-scipy.fft
    "scipy.fft"))'
- en: '[Fast Fourier transforms](#fast-fourier-transforms)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速傅里叶变换](#fast-fourier-transforms)'
- en: '[1-D discrete Fourier transforms](#d-discrete-fourier-transforms)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1D离散傅里叶变换](#d-discrete-fourier-transforms)'
- en: '[2- and N-D discrete Fourier transforms](#and-n-d-discrete-fourier-transforms)'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2D和ND离散傅里叶变换](#and-n-d-discrete-fourier-transforms)'
- en: '[Discrete Cosine Transforms](#discrete-cosine-transforms)'
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[离散余弦变换](#discrete-cosine-transforms)'
- en: '[Type I DCT](#type-i-dct)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type I DCT](#type-i-dct)'
- en: '[Type II DCT](#type-ii-dct)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type II DCT](#type-ii-dct)'
- en: '[Type III DCT](#type-iii-dct)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type III DCT](#type-iii-dct)'
- en: '[Type IV DCT](#type-iv-dct)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type IV DCT](#type-iv-dct)'
- en: '[DCT and IDCT](#dct-and-idct)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DCT和IDCT](#dct-and-idct)'
- en: '[Example](#example)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例](#example)'
- en: '[Discrete Sine Transforms](#discrete-sine-transforms)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[离散正弦变换](#discrete-sine-transforms)'
- en: '[Type I DST](#type-i-dst)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type I DST](#type-i-dst)'
- en: '[Type II DST](#type-ii-dst)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type II DST](#type-ii-dst)'
- en: '[Type III DST](#type-iii-dst)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type III DST](#type-iii-dst)'
- en: '[Type IV DST](#type-iv-dst)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Type IV DST](#type-iv-dst)'
- en: '[DST and IDST](#dst-and-idst)'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[DST和IDST](#dst-and-idst)'
- en: '[Fast Hankel Transform](#fast-hankel-transform)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[快速汉克尔变换](#fast-hankel-transform)'
- en: '[References](#references)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参考文献](#references)'
- en: Fourier analysis is a method for expressing a function as a sum of periodic
    components, and for recovering the signal from those components. When both the
    function and its Fourier transform are replaced with discretized counterparts,
    it is called the discrete Fourier transform (DFT). The DFT has become a mainstay
    of numerical computing in part because of a very fast algorithm for computing
    it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and
    was brought to light in its current form by Cooley and Tukey [[CT65]](#ct65).
    Press et al. [[NR07]](#nr07) provide an accessible introduction to Fourier analysis
    and its applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Fourier分析是将函数表达为周期分量之和并从这些分量中恢复信号的方法。当函数及其傅里叶变换被替换为离散化的对应物时，称为离散傅里叶变换（DFT）。由于一种名为快速傅里叶变换（FFT）的非常快速计算算法的存在，DFT已成为数值计算的重要工具之一，该算法由高斯（1805年）知晓，并由库利和图基在现代形式中首次揭示[[CT65]](#ct65)。Press等人提供了傅里叶分析及其应用的易于理解的介绍[[NR07]](#nr07)。
- en: '## [Fast Fourier transforms](#id11)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '## [快速傅里叶变换](#id11)'
- en: '[1-D discrete Fourier transforms](#id12)'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[1D离散傅里叶变换](#id12)'
- en: The FFT *y[k]* of length \(N\) of the length-\(N\) sequence *x[n]* is defined
    as
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: FFT *y[k]* 长度为\(N\)的序列 *x[n]* 的傅里叶变换定义为
- en: \[y[k] = \sum_{n=0}^{N-1} e^{-2 \pi j \frac{k n}{N} } x[n] \, ,\]
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = \sum_{n=0}^{N-1} e^{-2 \pi j \frac{k n}{N} } x[n] \, ,\]
- en: and the inverse transform is defined as follows
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反变换定义如下
- en: \[x[n] = \frac{1}{N} \sum_{k=0}^{N-1} e^{2 \pi j \frac{k n}{N} } y[k] \, .\]
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: \[x[n] = \frac{1}{N} \sum_{k=0}^{N-1} e^{2 \pi j \frac{k n}{N} } y[k] \, .\]
- en: These transforms can be calculated by means of [`fft`](../reference/generated/scipy.fft.fft.html#scipy.fft.fft
    "scipy.fft.fft") and [`ifft`](../reference/generated/scipy.fft.ifft.html#scipy.fft.ifft
    "scipy.fft.ifft"), respectively, as shown in the following example.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变换可以通过[`fft`](../reference/generated/scipy.fft.fft.html#scipy.fft.fft "scipy.fft.fft")和[`ifft`](../reference/generated/scipy.fft.ifft.html#scipy.fft.ifft
    "scipy.fft.ifft")来计算，如下例所示。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the definition of the FFT it can be seen that
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从FFT的定义可以看出
- en: \[y[0] = \sum_{n=0}^{N-1} x[n] \, .\]
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[0] = \sum_{n=0}^{N-1} x[n] \, .\]
- en: In the example
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: which corresponds to \(y[0]\). For N even, the elements \(y[1]...y[N/2-1]\)
    contain the positive-frequency terms, and the elements \(y[N/2]...y[N-1]\) contain
    the negative-frequency terms, in order of decreasingly negative frequency. For
    N odd, the elements \(y[1]...y[(N-1)/2]\) contain the positive-frequency terms,
    and the elements \(y[(N+1)/2]...y[N-1]\) contain the negative-frequency terms,
    in order of decreasingly negative frequency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于\(y[0]\)。对于偶数N，元素\(y[1]...y[N/2-1]\)包含正频率项，元素\(y[N/2]...y[N-1]\)包含负频率项，按递减负频率顺序排列。对于奇数N，元素\(y[1]...y[(N-1)/2]\)包含正频率项，元素\(y[(N+1)/2]...y[N-1]\)包含负频率项，按递减负频率顺序排列。
- en: In case the sequence x is real-valued, the values of \(y[n]\) for positive frequencies
    is the conjugate of the values \(y[n]\) for negative frequencies (because the
    spectrum is symmetric). Typically, only the FFT corresponding to positive frequencies
    is plotted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列x是实值的，则正频率下的\(y[n]\)值是负频率下\(y[n]\)值的共轭（因为频谱是对称的）。通常只绘制与正频率对应的FFT。
- en: The example plots the FFT of the sum of two sines.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例绘制了两个正弦波的FFT。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '!["This code generates an X-Y plot showing amplitude on the Y axis vs frequency
    on the X axis. A single blue trace has an amplitude of zero all the way across
    with the exception of two peaks. The taller first peak is at 50 Hz with a second
    peak at 80 Hz."](../Images/805f438610f43a63ac427cb01f57d9a7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '!["这段代码生成一个振幅在Y轴上，频率在X轴上的X-Y图。单个蓝色迹象在整个图中除了两个峰值外，其余位置振幅为零。第一个更高的峰值在50 Hz处，第二个峰值在80
    Hz处。"](../Images/805f438610f43a63ac427cb01f57d9a7.png)'
- en: The FFT input signal is inherently truncated. This truncation can be modeled
    as multiplication of an infinite signal with a rectangular window function. In
    the spectral domain this multiplication becomes convolution of the signal spectrum
    with the window function spectrum, being of form \(\sin(x)/x\). This convolution
    is the cause of an effect called spectral leakage (see [[WPW]](#wpw)). Windowing
    the signal with a dedicated window function helps mitigate spectral leakage. The
    example below uses a Blackman window from scipy.signal and shows the effect of
    windowing (the zero component of the FFT has been truncated for illustrative purposes).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: FFT输入信号本质上是被截断的。这种截断可以被建模为无限信号与矩形窗口函数的乘积。在频谱域中，这种乘积变成了信号频谱与窗口函数频谱的卷积，形式为\(\sin(x)/x\)。这种卷积引起了称为频谱泄漏的效应（参见[[WPW]](#wpw)）。使用专用窗口函数对信号进行窗函数处理有助于减轻频谱泄漏。下面的示例使用了scipy.signal中的Blackman窗口，并展示了窗函数效果（FFT的零分量已被截断，仅用于说明目的）。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '!["This code generates an X-Y log-linear plot with amplitude on the Y axis
    vs frequency on the X axis. The first trace is the FFT with two peaks at 50 and
    80 Hz and a noise floor around an amplitude of 1e-2\. The second trace is the
    windowed FFT and has the same two peaks but the noise floor is much lower around
    an amplitude of 1e-7 due to the window function."](../Images/e7e633d9c6d5016d83f442b7117b7a1e.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '!["这段代码生成一个振幅在Y轴上，频率在X轴上的X-Y对数线性图。第一个迹象是FFT，在50和80 Hz有两个峰值，噪声底噪约为1e-2。第二个迹象是窗口FFT，具有相同的两个峰，但由于窗口函数，噪声底噪较低，约为1e-7。"](../Images/e7e633d9c6d5016d83f442b7117b7a1e.png)'
- en: In case the sequence x is complex-valued, the spectrum is no longer symmetric.
    To simplify working with the FFT functions, scipy provides the following two helper
    functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列x是复值的，则频谱不再对称。为了简化使用FFT函数的工作，scipy提供了以下两个辅助函数。
- en: The function [`fftfreq`](../reference/generated/scipy.fft.fftfreq.html#scipy.fft.fftfreq
    "scipy.fft.fftfreq") returns the FFT sample frequency points.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`fftfreq`](../reference/generated/scipy.fft.fftfreq.html#scipy.fft.fftfreq
    "scipy.fft.fftfreq")返回FFT样本频率点。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In a similar spirit, the function [`fftshift`](../reference/generated/scipy.fft.fftshift.html#scipy.fft.fftshift
    "scipy.fft.fftshift") allows swapping the lower and upper halves of a vector,
    so that it becomes suitable for display.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，函数[`fftshift`](../reference/generated/scipy.fft.fftshift.html#scipy.fft.fftshift
    "scipy.fft.fftshift")允许交换向量的下半部分和上半部分，以便于显示。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The example below plots the FFT of two complex exponentials; note the asymmetric
    spectrum.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例绘制了两个复指数的FFT；请注意其不对称的频谱。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '!["This code generates an X-Y plot with amplitude on the Y axis vs frequency
    on the X axis. The trace is zero-valued across the plot except for two sharp peaks
    at -80 and 50 Hz. The 50 Hz peak on the right is twice as tall."](../Images/86cad2500ebb59d90c1c32f347e91b00.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '!["这段代码生成一个振幅在Y轴上，频率在X轴上的X-Y图。在整个图中，迹象除了在-80和50 Hz处有两个尖峰外，其他位置值为零。右侧的50 Hz峰值是左侧峰值的两倍。"](../Images/86cad2500ebb59d90c1c32f347e91b00.png)'
- en: 'The function [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft") calculates the FFT of a real sequence and outputs the complex
    FFT coefficients \(y[n]\) for only half of the frequency range. The remaining
    negative frequency components are implied by the Hermitian symmetry of the FFT
    for a real input (`y[n] = conj(y[-n])`). In case of N being even: \([Re(y[0])
    + 0j, y[1], ..., Re(y[N/2]) + 0j]\); in case of N being odd \([Re(y[0]) + 0j,
    y[1], ..., y[N/2]\). The terms shown explicitly as \(Re(y[k]) + 0j\) are restricted
    to be purely real since, by the hermitian property, they are their own complex
    conjugate.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft "scipy.fft.rfft")计算实序列的FFT，并仅输出半频率范围的复FFT系数\(y[n]\)。剩余的负频率分量由FFT的Hermitian对称性隐含处理，用于实输入的情况（`y[n]
    = conj(y[-n])`）。对于N为偶数：\([Re(y[0]) + 0j, y[1], ..., Re(y[N/2]) + 0j]\)；对于N为奇数：\([Re(y[0])
    + 0j, y[1], ..., y[N/2]\]。显示为\(Re(y[k]) + 0j\)的项受到限制，因为根据Hermitian属性，它们是它们自己的复共轭。
- en: The corresponding function [`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft
    "scipy.fft.irfft") calculates the IFFT of the FFT coefficients with this special
    ordering.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft "scipy.fft.irfft")用特殊顺序计算FFT系数的IFFT。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that the [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft") of odd and even length signals are of the same shape. By default,
    [`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft "scipy.fft.irfft")
    assumes the output signal should be of even length. And so, for odd signals, it
    will give the wrong result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft "scipy.fft.rfft")对于奇偶长度的信号具有相同的形状。默认情况下，[`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft
    "scipy.fft.irfft")假定输出信号应为偶数长度。因此，对于奇数信号，它将给出错误的结果：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To recover the original odd-length signal, we **must** pass the output shape
    by the *n* parameter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复原始的奇数长度信号，**必须**通过*n*参数传递输出形状。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[2- and N-D discrete Fourier transforms](#id13)'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[2- and N-D离散傅里叶变换](#id13)'
- en: The functions [`fft2`](../reference/generated/scipy.fft.fft2.html#scipy.fft.fft2
    "scipy.fft.fft2") and [`ifft2`](../reference/generated/scipy.fft.ifft2.html#scipy.fft.ifft2
    "scipy.fft.ifft2") provide 2-D FFT and IFFT, respectively. Similarly, [`fftn`](../reference/generated/scipy.fft.fftn.html#scipy.fft.fftn
    "scipy.fft.fftn") and [`ifftn`](../reference/generated/scipy.fft.ifftn.html#scipy.fft.ifftn
    "scipy.fft.ifftn") provide N-D FFT, and IFFT, respectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`fft2`](../reference/generated/scipy.fft.fft2.html#scipy.fft.fft2 "scipy.fft.fft2")和[`ifft2`](../reference/generated/scipy.fft.ifft2.html#scipy.fft.ifft2
    "scipy.fft.ifft2")分别提供2-D FFT和IFFT。类似地，[`fftn`](../reference/generated/scipy.fft.fftn.html#scipy.fft.fftn
    "scipy.fft.fftn")和[`ifftn`](../reference/generated/scipy.fft.ifftn.html#scipy.fft.ifftn
    "scipy.fft.ifftn")提供N-D FFT和IFFT。
- en: For real-input signals, similarly to [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft"), we have the functions [`rfft2`](../reference/generated/scipy.fft.rfft2.html#scipy.fft.rfft2
    "scipy.fft.rfft2") and [`irfft2`](../reference/generated/scipy.fft.irfft2.html#scipy.fft.irfft2
    "scipy.fft.irfft2") for 2-D real transforms; [`rfftn`](../reference/generated/scipy.fft.rfftn.html#scipy.fft.rfftn
    "scipy.fft.rfftn") and [`irfftn`](../reference/generated/scipy.fft.irfftn.html#scipy.fft.irfftn
    "scipy.fft.irfftn") for N-D real transforms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实输入信号，类似于[`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft")，我们有函数[`rfft2`](../reference/generated/scipy.fft.rfft2.html#scipy.fft.rfft2
    "scipy.fft.rfft2")和[`irfft2`](../reference/generated/scipy.fft.irfft2.html#scipy.fft.irfft2
    "scipy.fft.irfft2")用于2-D实变换；[`rfftn`](../reference/generated/scipy.fft.rfftn.html#scipy.fft.rfftn
    "scipy.fft.rfftn")和[`irfftn`](../reference/generated/scipy.fft.irfftn.html#scipy.fft.irfftn
    "scipy.fft.irfftn")用于N-D实变换。
- en: The example below demonstrates a 2-D IFFT and plots the resulting (2-D) time-domain
    signals.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了2-D IFFT并绘制了结果的（2-D）时域信号。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '!["This code generates six heatmaps arranged in a 2x3 grid. The top row shows
    mostly blank canvases with the exception of two tiny red peaks on each image.
    The bottom row shows the real-part of the inverse FFT of each image above it.
    The first column has two dots arranged horizontally in the top image and in the
    bottom image a smooth grayscale plot of 5 black vertical stripes representing
    the 2-D time domain signal. The second column has two dots arranged vertically
    in the top image and in the bottom image a smooth grayscale plot of 5 horizontal
    black stripes representing the 2-D time domain signal. In the last column the
    top image has two dots diagonally located; the corresponding image below has perhaps
    20 black stripes at a 60 degree angle."](../Images/5be40428f3d653ccecce1631fbe54705.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '!["这段代码生成了一个2x3网格中排列的六个热图。顶行显示大多是空白画布，除了每幅图像上有两个微小的红色峰。底行显示了每个上面图像的逆FFT的实部。第一列有两个水平排列的点在上面的图像中，在下面的图像中有一个平滑的灰度图，显示了五条黑色垂直条纹，代表2D时域信号。第二列有两个垂直排列的点在上面的图像中，在下面的图像中有一个平滑的灰度图，显示了五条水平黑色条纹，代表2D时域信号。在最后一列中，顶部图像有两个对角线位置的点；对应的下面的图像有大概20条60度角的黑色条纹。"](../Images/5be40428f3d653ccecce1631fbe54705.png)'
- en: '[Discrete Cosine Transforms](#id14)'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[离散余弦变换](#id14)'
- en: SciPy provides a DCT with the function [`dct`](../reference/generated/scipy.fft.dct.html#scipy.fft.dct
    "scipy.fft.dct") and a corresponding IDCT with the function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct"). There are 8 types of the DCT [[WPC]](#wpc), [[Mak]](#mak);
    however, only the first 4 types are implemented in scipy. “The” DCT generally
    refers to DCT type 2, and “the” Inverse DCT generally refers to DCT type 3\. In
    addition, the DCT coefficients can be normalized differently (for most types,
    scipy provides `None` and `ortho`). Two parameters of the dct/idct function calls
    allow setting the DCT type and coefficient normalization.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 提供了函数 [`dct`](../reference/generated/scipy.fft.dct.html#scipy.fft.dct
    "scipy.fft.dct") 和相应的 IDCT 函数 [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") 进行离散余弦变换。总共有 8 种 DCT 类型[[WPC]](#wpc), [[Mak]](#mak); 然而，SciPy
    只实现了前 4 种。通常“DCT” 指的是 DCT 类型 2，“反向 DCT” 指的是 DCT 类型 3\. 此外，DCT 系数可以有不同的标准化方式（对于大多数类型，SciPy
    提供 `None` 和 `ortho`）。dct/idct 函数调用的两个参数允许设置 DCT 类型和系数标准化。
- en: For a single dimension array x, dct(x, norm=’ortho’) is equal to MATLAB dct(x).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维数组 x，使用 `norm='ortho'` 的 dct(x) 等同于 MATLAB 的 dct(x)。
- en: '[Type I DCT](#id15)'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第一类离散余弦变换](#id15)'
- en: 'SciPy uses the following definition of the unnormalized DCT-I (`norm=None`):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 使用以下未归一化 DCT-I 的定义 (`norm=None`)：
- en: \[y[k] = x_0 + (-1)^k x_{N-1} + 2\sum_{n=1}^{N-2} x[n] \cos\left(\frac{\pi nk}{N-1}\right),
    \qquad 0 \le k < N.\]
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = x_0 + (-1)^k x_{N-1} + 2\sum_{n=1}^{N-2} x[n] \cos\left(\frac{\pi nk}{N-1}\right),
    \qquad 0 \le k < N.\]
- en: Note that the DCT-I is only supported for input size > 1.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，DCT-I 仅支持输入大小 > 1。
- en: '[Type II DCT](#id16)'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第二类离散余弦变换](#id16)'
- en: 'SciPy uses the following definition of the unnormalized DCT-II (`norm=None`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 使用以下未归一化 DCT-II 的定义 (`norm=None`)：
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos \left({\pi(2n+1)k \over 2N} \right) \qquad
    0 \le k < N.\]
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos \left({\pi(2n+1)k \over 2N} \right) \qquad
    0 \le k < N.\]
- en: 'In case of the normalized DCT (`norm=''ortho''`), the DCT coefficients \(y[k]\)
    are multiplied by a scaling factor *f*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在归一化 DCT 的情况下 (`norm='ortho'`)，DCT 系数 \(y[k]\) 乘以一个缩放因子 *f*：
- en: \[\begin{split}f = \begin{cases} \sqrt{1/(4N)}, & \text{if $k = 0$} \\ \sqrt{1/(2N)},
    & \text{otherwise} \end{cases} \, .\end{split}\]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}f = \begin{cases} \sqrt{1/(4N)}, & \text{如果 $k = 0$} \\ \sqrt{1/(2N)},
    & \text{否则} \end{cases} \, .\end{split}\]
- en: 'In this case, the DCT “base functions” \(\phi_k[n] = 2 f \cos \left({\pi(2n+1)k
    \over 2N} \right)\) become orthonormal:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，DCT 的“基函数” \(\phi_k[n] = 2 f \cos \left({\pi(2n+1)k \over 2N} \right)\)
    变为正交的：
- en: \[\sum_{n=0}^{N-1} \phi_k[n] \phi_l[n] = \delta_{lk}.\]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: \[\sum_{n=0}^{N-1} \phi_k[n] \phi_l[n] = \delta_{lk}.\]
- en: '[Type III DCT](#id17)'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第三类离散余弦变换](#id17)'
- en: 'SciPy uses the following definition of the unnormalized DCT-III (`norm=None`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 使用以下未归一化 DCT-III 的定义 (`norm=None`)：
- en: \[y[k] = x_0 + 2 \sum_{n=1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right)
    \qquad 0 \le k < N,\]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = x_0 + 2 \sum_{n=1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right)
    \qquad 0 \le k < N,\]
- en: 'or, for `norm=''ortho''`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'or, for `norm=''ortho''`:'
- en: \[y[k] = {x_0\over\sqrt{N}} + {2\over\sqrt{N}} \sum_{n=1}^{N-1} x[n] \cos\left({\pi
    n(2k+1) \over 2N}\right) \qquad 0 \le k < N.\]
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = {x_0\over\sqrt{N}} + {2\over\sqrt{N}} \sum_{n=1}^{N-1} x[n] \cos\left({\pi
    n(2k+1) \over 2N}\right) \qquad 0 \le k < N.\]
- en: '[Type IV DCT](#id18)'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第四类离散余弦变换](#id18)'
- en: 'SciPy uses the following definition of the unnormalized DCT-IV (`norm=None`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 使用以下未归一化 DCT-IV 的定义 (`norm=None`)：
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
- en: 'or, for `norm=''ortho''`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于 `norm='ortho'`：
- en: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N\]
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N\]
- en: '[DCT and IDCT](#id19)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[DCT 和 IDCT](#id19)'
- en: The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up to
    a factor of *2N*. The orthonormalized DCT-III is exactly the inverse of the orthonormalized
    DCT- II. The function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") performs the mappings between the DCT and IDCT types, as well
    as the correct normalization.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （未标准化的）DCT-III 是（未标准化的）DCT-II 的反变换，只差一个因子 *2N*。标准化的 DCT-III 则正好是标准化的 DCT-II
    的反变换。函数 [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct "scipy.fft.idct")
    执行了 DCT 和 IDCT 类型之间的映射，以及正确的归一化。
- en: The following example shows the relation between DCT and IDCT for different
    types and normalizations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了不同类型和归一化的 DCT 和 IDCT 之间的关系。
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The DCT-II and DCT-III are each other’s inverses, so for an orthonormal transform
    we return back to the original signal.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DCT-II 和 DCT-III 是彼此的反变换，因此对于正交变换，我们可以恢复到原始信号。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Doing the same under default normalization, however, we pick up an extra scaling
    factor of \(2N=10\) since the forward transform is unnormalized.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认归一化下进行相同操作时，我们得到一个额外的缩放因子 \(2N=10\)，因为正向变换是未标准化的。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For this reason, we should use the function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") using the same type for both, giving a correctly normalized
    result.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该使用函数 [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") 为两者使用相同类型，以获得正确归一化的结果。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Analogous results can be seen for the DCT-I, which is its own inverse up to
    a factor of \(2(N-1)\).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DCT-I，类似的结果可以看到它本身的反变换，只差一个因子 \(2(N-1)\)。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And for the DCT-IV, which is also its own inverse up to a factor of \(2N\).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 DCT-IV，也是其自身的反变换，只差一个因子 \(2N\)。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example](#id20)'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[示例](#id20)'
- en: The DCT exhibits the “energy compaction property”, meaning that for many signals
    only the first few DCT coefficients have significant magnitude. Zeroing out the
    other coefficients leads to a small reconstruction error, a fact which is exploited
    in lossy signal compression (e.g. JPEG compression).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DCT 表现出“能量压缩特性”，意味着对于许多信号，只有前几个 DCT 系数具有显著的幅度。将其他系数置零会导致小的重构误差，这一事实在损失信号压缩（例如
    JPEG 压缩）中得到利用。
- en: The example below shows a signal x and two reconstructions (\(x_{20}\) and \(x_{15}\))
    from the signal’s DCT coefficients. The signal \(x_{20}\) is reconstructed from
    the first 20 DCT coefficients, \(x_{15}\) is reconstructed from the first 15 DCT
    coefficients. It can be seen that the relative error of using 20 coefficients
    is still very small (~0.1%), but provides a five-fold compression rate.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了信号 x 及其从 DCT 系数重构的两个重构（\(x_{20}\) 和 \(x_{15}\)）。从使用 20 个系数重构的信号 \(x_{20}\)
    中可以看出，相对误差仍然非常小（约 0.1%），但提供了五倍的压缩率。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '!["This code generates an X-Y plot showing amplitude on the Y axis and time
    on the X axis. The first blue trace is the original signal and starts at amplitude
    1 and oscillates down to 0 amplitude over the duration of the plot resembling
    a frequency chirp. The second red trace is the x_20 reconstruction using the DCT
    and closely follows the original signal in the high amplitude region but it is
    unclear to the right side of the plot. The third green trace is the x_15 reconstruction
    using the DCT and is less precise than the x_20 reconstruction but still similar
    to x."](../Images/77d374115738777155f029ee6a65cd4a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '!["此代码生成一个 X-Y 图，显示 Y 轴上的振幅和 X 轴上的时间。第一个蓝色轨迹是原始信号，从振幅 1 开始，在绘图持续时间内振幅下降至 0，类似频率啁啾。第二个红色轨迹是使用
    DCT 生成的 x_20 重构，高振幅区域紧随原始信号，但在绘图右侧不够清晰。第三个绿色轨迹是使用 DCT 生成的 x_15 重构，比 x_20 重构不够精确，但仍类似于
    x。"](../Images/77d374115738777155f029ee6a65cd4a.png)'
- en: '[Discrete Sine Transforms](#id21)'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[离散正弦变换](#id21)'
- en: SciPy provides a DST [[Mak]](#mak) with the function [`dst`](../reference/generated/scipy.fft.dst.html#scipy.fft.dst
    "scipy.fft.dst") and a corresponding IDST with the function [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 提供了使用函数 [`dst`](../reference/generated/scipy.fft.dst.html#scipy.fft.dst
    "scipy.fft.dst") 进行 DST（[Mak](#mak)）计算，并使用函数 [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst") 进行对应的 IDST 计算。
- en: There are, theoretically, 8 types of the DST for different combinations of even/odd
    boundary conditions and boundary offsets [[WPS]](#wps), only the first 4 types
    are implemented in scipy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，有8种DST类型，适用于不同的偶数/奇数边界条件和边界偏移组合[[WPS]](#wps)，但scipy只实现了前4种类型。
- en: '[Type I DST](#id22)'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[类型 I DST](#id22)'
- en: 'DST-I assumes the input is odd around n=-1 and n=N. SciPy uses the following
    definition of the unnormalized DST-I (`norm=None`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'DST-I假设输入在n=-1和n=N周围为奇数。SciPy使用以下未归一化定义DST-I (`norm=None`):'
- en: \[y[k] = 2\sum_{n=0}^{N-1} x[n] \sin\left( \pi {(n+1) (k+1)}\over{N+1} \right),
    \qquad 0 \le k < N.\]
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = 2\sum_{n=0}^{N-1} x[n] \sin\left( \pi {(n+1) (k+1)}\over{N+1} \right),
    \qquad 0 \le k < N.\]
- en: Note also that the DST-I is only supported for input size > 1\. The (unnormalized)
    DST-I is its own inverse, up to a factor of *2(N+1)*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，DST-I仅支持输入大小 > 1。DST-I（未归一化）是其自身的逆变换，除了一个 *2(N+1)* 的因子。
- en: '[Type II DST](#id23)'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[类型 II DST](#id23)'
- en: 'DST-II assumes the input is odd around n=-1/2 and even around n=N. SciPy uses
    the following definition of the unnormalized DST-II (`norm=None`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'DST-II假设输入在n=-1/2周围为奇数，在n=N周围为偶数。SciPy使用以下未归一化定义DST-II (`norm=None`):'
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left( {\pi (n+1/2)(k+1)} \over N \right),
    \qquad 0 \le k < N.\]
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left( {\pi (n+1/2)(k+1)} \over N \right),
    \qquad 0 \le k < N.\]
- en: '[Type III DST](#id24)'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[类型 III DST](#id24)'
- en: 'DST-III assumes the input is odd around n=-1 and even around n=N-1\. SciPy
    uses the following definition of the unnormalized DST-III (`norm=None`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'DST-III假设输入在n=-1周围为奇数，在n=N-1周围为偶数。SciPy使用以下未归一化定义DST-III (`norm=None`):'
- en: \[y[k] = (-1)^k x[N-1] + 2 \sum_{n=0}^{N-2} x[n] \sin \left( {\pi (n+1)(k+1/2)}
    \over N \right), \qquad 0 \le k < N.\]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = (-1)^k x[N-1] + 2 \sum_{n=0}^{N-2} x[n] \sin \left( {\pi (n+1)(k+1/2)}
    \over N \right), \qquad 0 \le k < N.\]
- en: '[Type IV DST](#id25)'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[类型 IV DST](#id25)'
- en: 'SciPy uses the following definition of the unnormalized DST-IV (`norm=None`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'SciPy使用以下未归一化定义DST-IV (`norm=None`):'
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
- en: 'or, for `norm=''ortho''`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于 `norm='ortho'`：
- en: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N,\]
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N,\]
- en: '[DST and IDST](#id26)'
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[DST 和 IDST](#id26)'
- en: The following example shows the relation between DST and IDST for different
    types and normalizations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了不同类型和标准化下DST与IDST之间的关系。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The DST-II and DST-III are each other’s inverses, so for an orthonormal transform
    we return back to the original signal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: DST-II和DST-III是彼此的逆变换，因此对于正交变换，我们可以返回到原始信号。
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Doing the same under default normalization, however, we pick up an extra scaling
    factor of \(2N=10\) since the forward transform is unnormalized.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认标准化下进行相同处理时，由于正向变换未归一化，我们会得到一个额外的缩放因子 \(2N=10\)。
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For this reason, we should use the function [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst") using the same type for both, giving a correctly normalized
    result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该使用函数 [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst") 为两者使用相同的类型，从而得到正确标准化的结果。
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Analogous results can be seen for the DST-I, which is its own inverse up to
    a factor of \(2(N-1)\).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DST-I，其本身是其逆变换，仅相差一个因子 \(2(N-1)\)。
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And for the DST-IV, which is also its own inverse up to a factor of \(2N\).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于DST-IV，其本身也是其逆变换，除了一个因子 \(2N\)。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Fast Hankel Transform](#id27)'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[快速汉克尔变换](#id27)'
- en: SciPy provides the functions `fht` and `ifht` to perform the Fast Hankel Transform
    (FHT) and its inverse (IFHT) on logarithmically-spaced input arrays.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy提供了函数 `fht` 和 `ifht` 来对对数间隔输入数组执行快速汉克尔变换（FHT）及其逆变换（IFHT）。
- en: The FHT is the discretised version of the continuous Hankel transform defined
    by [[Ham00]](#ham00)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 福特变换（FHT）是由[[Ham00]](#ham00)定义的连续汉克尔变换的离散版本。
- en: \[A(k) = \int_{0}^{\infty} \! a(r) \, J_{\mu}(kr) \, k \, dr \;,\]
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: \[A(k) = \int_{0}^{\infty} \! a(r) \, J_{\mu}(kr) \, k \, dr \;,\]
- en: with \(J_{\mu}\) the Bessel function of order \(\mu\). Under a change of variables
    \(r \to \log r\), \(k \to \log k\), this becomes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(J_{\mu}\) 是阶数为 \(\mu\) 的贝塞尔函数。在变量变换 \(r \to \log r\), \(k \to \log k\)
    下，这变为
- en: \[A(e^{\log k}) = \int_{0}^{\infty} \! a(e^{\log r}) \, J_{\mu}(e^{\log k +
    \log r}) \, e^{\log k + \log r} \, d{\log r}\]
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: \[A(e^{\log k}) = \int_{0}^{\infty} \! a(e^{\log r}) \, J_{\mu}(e^{\log k +
    \log r}) \, e^{\log k + \log r} \, d{\log r}\]
- en: which is a convolution in logarithmic space. The FHT algorithm uses the FFT
    to perform this convolution on discrete input data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对数空间中的卷积。FHT算法使用FFT对离散输入数据执行此卷积。
- en: Care must be taken to minimise numerical ringing due to the circular nature
    of FFT convolution. To ensure that the low-ringing condition [[Ham00]](#ham00)
    holds, the output array can be slightly shifted by an offset computed using the
    `fhtoffset` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意由于FFT卷积的循环性质，必须小心减少数值环绕现象。为确保低环绕条件[[Ham00]](#ham00)成立，可以通过使用`fhtoffset`函数计算的偏移量稍微偏移输出数组。
- en: '[References](#id28)'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[References](#id28)'
- en: '[[CT65](#id1)]'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[[CT65](#id1)]'
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
- en: '[[NR07](#id2)]'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[[NR07](#id2)]'
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
- en: '[Mak] ([1](#id5),[2](#id6))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mak] ([1](#id5),[2](#id6))'
- en: J. Makhoul, 1980, ‘A Fast Cosine Transform in One and Two Dimensions’, *IEEE
    Transactions on acoustics, speech and signal processing* vol. 28(1), pp. 27-34,
    [DOI:10.1109/TASSP.1980.1163351](https://doi.org/10.1109/TASSP.1980.1163351)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: J. Makhoul, 1980, ‘A Fast Cosine Transform in One and Two Dimensions’, *IEEE
    Transactions on acoustics, speech and signal processing* vol. 28(1), pp. 27-34,
    [DOI:10.1109/TASSP.1980.1163351](https://doi.org/10.1109/TASSP.1980.1163351)
- en: '[Ham00] ([1](#id8),[2](#id9))'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ham00] ([1](#id8),[2](#id9))'
- en: A. J. S. Hamilton, 2000, “Uncorrelated modes of the non-linear power spectrum”,
    *MNRAS*, 312, 257\. [DOI:10.1046/j.1365-8711.2000.03071.x](https://doi.org/10.1046/j.1365-8711.2000.03071.x)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: A. J. S. Hamilton, 2000, “Uncorrelated modes of the non-linear power spectrum”,
    *MNRAS*, 312, 257\. [DOI:10.1046/j.1365-8711.2000.03071.x](https://doi.org/10.1046/j.1365-8711.2000.03071.x)
- en: '[[WPW](#id3)]'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[[WPW](#id3)]'
- en: '[https://en.wikipedia.org/wiki/Window_function](https://en.wikipedia.org/wiki/Window_function)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Window_function](https://en.wikipedia.org/wiki/Window_function)'
- en: '[[WPC](#id4)]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[[WPC](#id4)]'
- en: '[https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
- en: '[[WPS](#id7)]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[[WPS](#id7)]'
- en: '[https://en.wikipedia.org/wiki/Discrete_sine_transform](https://en.wikipedia.org/wiki/Discrete_sine_transform)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Discrete_sine_transform](https://en.wikipedia.org/wiki/Discrete_sine_transform)'
