- en: ODE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/solvers/ode.html](https://docs.sympy.org/latest/modules/solvers/ode.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a beginner-friendly guide focused on solving ODEs, refer to [Solve an Ordinary
    Differential Equation (ODE) Algebraically](../../guides/solving/solve-ode.html#solving-guide-ode).
  prefs: []
  type: TYPE_NORMAL
- en: '## User Functions'
  prefs: []
  type: TYPE_NORMAL
- en: These are functions that are imported into the global namespace with `from sympy
    import *`. These functions (unlike [Hint Functions](#hint-functions), below) are
    intended for use by ordinary users of SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solves any (supported) kind of ordinary differential equation and system of
    ordinary differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: For Single Ordinary Differential Equation
  prefs: []
  type: TYPE_NORMAL
- en: It is classified under this when number of equation in `eq` is one. **Usage**
  prefs: []
  type: TYPE_NORMAL
- en: '`dsolve(eq, f(x), hint)` -> Solve ordinary differential equation `eq` for function
    `f(x)`, using method `hint`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Details**'
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` can be any supported ordinary differential equation (see the'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") docstring for supported
    methods). This can either be an [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality"), or an expression, which is assumed to be equal
    to `0`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`f(x)` is a function of one variable whose derivatives in that'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: variable make up the ordinary differential equation `eq`. In many cases it is
    not necessary to provide this; it will be autodetected (and an error raised if
    it could not be detected).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`hint` is the solving method that you want dsolve to use. Use'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`classify_ode(eq, f(x))` to get all of the possible hints for an ODE. The default
    hint, `default`, will use whatever hint is returned first by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode"). See Hints below for more options that you can
    use for hint.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`simplify` enables simplification by'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp").
    See its docstring for more information. Turn this off, for example, to disable
    solving of solutions for `func` or simplification of arbitrary constants. It will
    still integrate with this hint. Note that the solution may contain more arbitrary
    constants than the order of the ODE with this option enabled.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`xi` and `eta` are the infinitesimal functions of an ordinary'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: differential equation. They are the infinitesimals of the Lie group of point
    transformations for which the differential equation is invariant. The user can
    specify values for the infinitesimals. If nothing is specified, `xi` and `eta`
    are calculated using [`infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    with the help of various heuristics.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ics` is the set of initial/boundary conditions for the differential equation.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It should be given in the form of `{f(x0): x1, f(x).diff(x).subs(x, x2): x3}`
    and so on. For power series solutions, if no initial conditions are specified
    `f(0)` is assumed to be `C0` and the power series solution is calculated about
    0.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`x0` is the point about which the power series solution of a differential'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: equation is to be evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`n` gives the exponent of the dependent variable up to which the power series'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: solution of a differential equation is to be evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Hints**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the various solving methods, there are also some meta-hints that
    you can pass to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`default`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This uses whatever hint is returned first by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode"). This is the default argument to [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`all`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To make [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    apply all relevant classification hints, use `dsolve(ODE, func, hint="all")`.
    This will return a dictionary of `hint:solution` terms. If a hint causes dsolve
    to raise the `NotImplementedError`, value of that hint’s key will be the exception
    object raised. The dictionary will also include some special keys:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`order`: The order of the ODE. See also [`ode_order()`](solvers.html#sympy.solvers.deutils.ode_order
    "sympy.solvers.deutils.ode_order") in `deutils.py`.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`best`: The simplest hint; what would be returned by `best` below.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`best_hint`: The hint that would produce the solution given by `best`. If more
    than one hint produces the best solution, the first one in the tuple returned
    by [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    is chosen.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`default`: The solution that would be returned by default. This is the one
    produced by the hint that appears first in the tuple returned by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode").'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`all_Integral`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the same as `all`, except if a hint also has a corresponding `_Integral`
    hint, it only returns the `_Integral` hint. This is useful if `all` causes [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") to hang because of a difficult or impossible integral.
    This meta-hint will also be much faster than `all`, because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is an expensive routine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`best`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To have [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") try
    all methods and return the simplest one. This takes into account whether the solution
    is solvable in the function, whether it contains any Integral classes (i.e. unevaluatable
    integrals), and which one is the shortest in size.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also the [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    docstring for more info on hints, and the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode")
    docstring for a list of all supported hints.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Tips**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare the derivative of an unknown function this way:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: See `test_ode.py` for many tests, which serves also as a set of examples for
    how to use [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") always returns
    an [`Equality`](../core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    class (except for the case when the hint is `all` or `all_Integral`). If possible,
    it solves the solution explicitly for the function being solved for. Otherwise,
    it returns an implicit solution.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Arbitrary constants are symbols named `C1`, `C2`, and so on.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Because all solutions should be mathematically equivalent, some hints may return
    the exact same result for an ODE. Often, though, two different hints will return
    the same solution formatted differently. The two should be equivalent. Also note
    that sometimes the values of the arbitrary constants in two different solutions
    may not be the same, because one constant may have “absorbed” other constants
    into it.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Do `help(ode.ode_<hintname>)` to get help more information on a specific hint,
    where `<hintname>` is the name of a hint without `_Integral`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For System Of Ordinary Differential Equations
  prefs: []
  type: TYPE_NORMAL
- en: '**Usage**'
  prefs: []
  type: TYPE_NORMAL
- en: '`dsolve(eq, func)` -> Solve a system of ordinary differential equations `eq`
    for `func` being list of functions including \(x(t)\), \(y(t)\), \(z(t)\) where
    number of functions in the list depends upon the number of equations provided
    in `eq`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Details**'
  prefs: []
  type: TYPE_NORMAL
- en: '`eq` can be any supported system of ordinary differential equations This can
    either be an [`Equality`](../core.html#sympy.core.relational.Equality "sympy.core.relational.Equality"),
    or an expression, which is assumed to be equal to `0`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`func` holds `x(t)` and `y(t)` being functions of one variable which together
    with some of their derivatives make up the system of ordinary differential equation
    `eq`. It is not necessary to provide this; it will be autodetected (and an error
    raised if it could not be detected).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Hints**'
  prefs: []
  type: TYPE_NORMAL
- en: The hints are formed by parameters returned by classify_sysode, combining them
    give hints name used later for forming method name.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Solves any(supported) system of Ordinary Differential Equations
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eqs** : List'
  prefs: []
  type: TYPE_NORMAL
- en: system of ODEs to be solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**funcs** : List or None'
  prefs: []
  type: TYPE_NORMAL
- en: List of dependent variables that make up the system of ODEs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : Symbol or None'
  prefs: []
  type: TYPE_NORMAL
- en: Independent variable in the system of ODEs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ics** : Dict or None'
  prefs: []
  type: TYPE_NORMAL
- en: Set of initial boundary/conditions for the system of ODEs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**doit** : Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the solutions if True. Default value is True. Can be set to false if
    the integral evaluation takes too much time and/or is not required.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify: Boolean**'
  prefs: []
  type: TYPE_NORMAL
- en: Simplify the solutions for the systems. Default value is True. Can be set to
    false if simplification takes too much time and/or is not required.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List of List of Equations
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the system of ODEs is not solvable by this function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the parameters passed are not in the required form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This function takes a system of ODEs as an input, determines if the it is solvable
    by this function, and returns the solution if found any.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can handle: 1\. Linear, First Order, Constant coefficient homogeneous
    system of ODEs 2\. Linear, First Order, Constant coefficient non-homogeneous system
    of ODEs 3\. Linear, First Order, non-constant coefficient homogeneous system of
    ODEs 4\. Linear, First Order, non-constant coefficient non-homogeneous system
    of ODEs 5\. Any implicit system which can be divided into system of ODEs which
    is of the above 4 forms 6\. Any higher order linear system of ODEs that can be
    reduced to one of the 5 forms of systems described above.'
  prefs: []
  type: TYPE_NORMAL
- en: The types of systems described above are not limited by the number of equations,
    i.e. this function can solve the above types irrespective of the number of equations
    in the system passed. But, the bigger the system, the more time it will take to
    solve the system.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns a list of solutions. Each solution is a list of equations
    where LHS is the dependent variable and RHS is an expression in terms of the independent
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Among the non constant coefficient types, not all the systems are solvable by
    this function. Only those which have either a coefficient matrix with a commutative
    antiderivative or those systems which may be divided further so that the divided
    systems may have coefficient matrix with commutative antiderivative.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass the initial conditions for the system of ODEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can pass the dependent variables and the independent variable
    for which the system is to be solved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lets look at an implicit system of ODEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Returns a tuple of possible [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    classifications for an ODE.
  prefs: []
  type: TYPE_NORMAL
- en: The tuple is ordered so that first item is the classification that [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") uses to solve the ODE by default. In general, classifications
    at the near the beginning of the list will produce better solutions faster than
    those near the end, thought there are always exceptions. To make [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") use a different classification, use `dsolve(ODE, func,
    hint=<classification>)`. See also the [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    docstring for different meta-hints you can use.
  prefs: []
  type: TYPE_NORMAL
- en: If `dict` is true, [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    will return a dictionary of `hint:match` expression terms. This is intended for
    internal use by [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    Note that because dictionaries are ordered arbitrarily, this will most likely
    not be in the same order as the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: You can get help on different hints by executing `help(ode.ode_hintname)`, where
    `hintname` is the name of the hint without `_Integral`.
  prefs: []
  type: TYPE_NORMAL
- en: See [`allhints`](#sympy.solvers.ode.allhints "sympy.solvers.ode.allhints") or
    the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") docstring for a list
    of all supported hints that can be returned from [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode").
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: These are remarks on hint names.
  prefs: []
  type: TYPE_NORMAL
- en: '`_Integral`'
  prefs: []
  type: TYPE_NORMAL
- en: If a classification has `_Integral` at the end, it will return the expression
    with an unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") class in it. Note that a hint may do this
    anyway if [`integrate()`](../core.html#sympy.core.expr.Expr.integrate "sympy.core.expr.Expr.integrate")
    cannot do the integral, though just using an `_Integral` will do so much faster.
    Indeed, an `_Integral` hint will always be faster than its corresponding hint
    without `_Integral` because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is an expensive routine. If [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") hangs, it is probably because [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is hanging on a tough or impossible integral.
    Try using an `_Integral` hint or `all_Integral` to get it return something.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that some hints do not have `_Integral` counterparts. This is because [`integrate()`](../integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") is not used in solving the ODE for those
    method. For example, \(n\)th order linear homogeneous ODEs with constant coefficients
    do not require integration to solve, so there is no `nth_linear_homogeneous_constant_coeff_Integrate`
    hint. You can easily evaluate any unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s in an expression by doing `expr.doit()`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ordinals
  prefs: []
  type: TYPE_NORMAL
- en: Some hints contain an ordinal such as `1st_linear`. This is to help differentiate
    them from other hints, as well as from other methods that may not be implemented
    yet. If a hint has `nth` in it, such as the `nth_linear` hints, this means that
    the method used to applies to ODEs of any order.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`indep` and `dep`'
  prefs: []
  type: TYPE_NORMAL
- en: Some hints contain the words `indep` or `dep`. These reference the independent
    variable and the dependent function, respectively. For example, if an ODE is in
    terms of \(f(x)\), then `indep` will refer to \(x\) and `dep` will refer to \(f\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`subs`'
  prefs: []
  type: TYPE_NORMAL
- en: If a hints has the word `subs` in it, it means that the ODE is solved by substituting
    the expression given after the word `subs` for a single dummy variable. This is
    usually in terms of `indep` and `dep` as above. The substituted expression will
    be written only in characters allowed for names of Python objects, meaning operators
    will be spelled out. For example, `indep`/`dep` will be written as `indep_div_dep`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`coeff`'
  prefs: []
  type: TYPE_NORMAL
- en: The word `coeff` in a hint refers to the coefficients of something in the ODE,
    usually of the derivative terms. See the docstring for the individual methods
    for more info (`help(ode)`). This is contrast to `coefficients`, as in `undetermined_coefficients`,
    which refers to the common name of a method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`_best`'
  prefs: []
  type: TYPE_NORMAL
- en: Methods that have more than one fundamental way to solve will have a hint for
    each sub-method and a `_best` meta-classification. This will evaluate all hints
    and return the best, using the same considerations as the normal `best` meta-hint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Substitutes `sol` into `ode` and checks that the result is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: This works when `func` is one function, like \(f(x)\) or a list of functions
    like \([f(x), g(x)]\) when \(ode\) is a system of ODEs. `sol` can be a single
    solution or a list of solutions. Each solution may be an [`Equality`](../core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") that the solution satisfies, e.g. `Eq(f(x),
    C1), Eq(f(x) + C1, 0)`; or simply an [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), e.g. `f(x) - C1`. In most cases it will not be necessary
    to explicitly identify the function, but if the function cannot be inferred from
    the original equation it can be supplied through the `func` argument.
  prefs: []
  type: TYPE_NORMAL
- en: If a sequence of solutions is passed, the same sort of container will be used
    to return the result for each solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'It tries the following methods, in order, until it finds zero equivalence:'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute the solution for \(f\) in the original equation. This only works
    if `ode` is solved for \(f\). It will attempt to solve it first unless `solve_for_func
    == False`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take \(n\) derivatives of the solution, where \(n\) is the order of `ode`, and
    check to see if that is equal to the solution. This only works on exact ODEs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the 1st, 2nd, …, \(n\)th derivatives of the solution, each time solving
    for the derivative of \(f\) of that order (this will always be possible because
    \(f\) is a linear operator). Then back substitute each derivative into `ode` in
    reverse order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function returns a tuple. The first item in the tuple is `True` if the
    substitution results in `0`, and `False` otherwise. The second item in the tuple
    is what the substitution results in. It should always be `0` if the first item
    is `True`. Sometimes this function will return `False` even when an expression
    is identically equal to `0`. This happens when [`simplify()`](../simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") does not reduce the expression to `0`. If
    an expression returned by this function vanishes identically, then `sol` really
    is a solution to the `ode`.
  prefs: []
  type: TYPE_NORMAL
- en: If this function seems to hang, it is probably because of a hard simplification.
  prefs: []
  type: TYPE_NORMAL
- en: To use this function to test, test the first item of the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Returns the order \(n\) if \(g\) is homogeneous and `None` if it is not homogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: Determines if a function is homogeneous and if so of what order. A function
    \(f(x, y, \cdots)\) is homogeneous of order \(n\) if \(f(t x, t y, \cdots) = t^n
    f(x, y, \cdots)\).
  prefs: []
  type: TYPE_NORMAL
- en: If the function is of two variables, \(F(x, y)\), then \(f\) being homogeneous
    of any order is equivalent to being able to rewrite \(F(x, y)\) as \(G(x/y)\)
    or \(H(y/x)\). This fact is used to solve 1st order ordinary differential equations
    whose coefficients are homogeneous of the same order (see the docstrings of [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") and [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep")).
  prefs: []
  type: TYPE_NORMAL
- en: Symbols can be functions, but every argument of the function must be a symbol,
    and the arguments of the function that appear in the expression must match those
    given in the list of symbols. If a declared function appears with different arguments
    than given in the list of symbols, `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The infinitesimal functions of an ordinary differential equation, \(\xi(x,y)\)
    and \(\eta(x,y)\), are the infinitesimals of the Lie group of point transformations
    for which the differential equation is invariant. So, the ODE \(y'=f(x,y)\) would
    admit a Lie group \(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\), \(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)
    such that \((y^*)'=f(x^*, y^*)\). A change of coordinates, to \(r(x,y)\) and \(s(x,y)\),
    can be performed so this Lie group becomes the translation group, \(r^*=r\) and
    \(s^*=s+\varepsilon\). They are tangents to the coordinate curves of the new system.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the transformation \((x, y) \to (X, Y)\) such that the differential
    equation remains invariant. \(\xi\) and \(\eta\) are the tangents to the transformed
    coordinates \(X\) and \(Y\), at \(\varepsilon=0\).
  prefs: []
  type: TYPE_NORMAL
- en: \[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \xi, \left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon }\right)|_{\varepsilon=0}
    = \eta,\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The infinitesimals can be found by solving the following PDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Solving the above mentioned PDE is not trivial, and can be solved only by making
    intelligent assumptions for \(\xi\) and \(\eta\) (heuristics). Once an infinitesimal
    is found, the attempt to find more heuristics stops. This is done to optimise
    the speed of solving the differential equation. If a list of all the infinitesimals
    is needed, `hint` should be flagged as `all`, which gives the complete list of
    infinitesimals. If the infinitesimals for a particular heuristic needs to be found,
    it can be passed as a flag to `hint`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Solving differential equations by Symmetry Groups, John Starrett, pp. 1 - pp.
    14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to check if the given infinitesimals are the actual infinitesimals
    of the given first order differential equation. This method is specific to the
    Lie Group Solver of ODEs.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, it simply checks, by substituting the infinitesimals in the partial
    differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
    - \frac{\partial \xi}{\partial x}\right)*h - \frac{\partial \xi}{\partial y}*h^{2}
    - \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(\eta\), and \(\xi\) are the infinitesimals and \(h(x,y) = \frac{dy}{dx}\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The infinitesimals should be given in the form of a list of dicts `[{xi(x,
    y): inf, eta(x, y): inf}]`, corresponding to the output of the function infinitesimals.
    It returns a list of values of the form `[(True/False, sol)]` where `sol` is the
    value obtained after substituting the infinitesimals in the PDE. If it is `True`,
    then `sol` would be 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Simplifies an expression with arbitrary constants in it.
  prefs: []
  type: TYPE_NORMAL
- en: This function is written specifically to work with [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), and is not intended for general use.
  prefs: []
  type: TYPE_NORMAL
- en: Simplification is done by “absorbing” the arbitrary constants into other arbitrary
    constants, numbers, and symbols that they are not independent of.
  prefs: []
  type: TYPE_NORMAL
- en: The symbols must all have the same name with numbers after it, for example,
    `C1`, `C2`, `C3`. The `symbolname` here would be ‘`C`’, the `startnumber` would
    be 1, and the `endnumber` would be 3. If the arbitrary constants are independent
    of the variable `x`, then the independent symbol would be `x`. There is no need
    to specify the dependent function, such as `f(x)`, because it already has the
    independent symbol, `x`, in it.
  prefs: []
  type: TYPE_NORMAL
- en: Because terms are “absorbed” into arbitrary constants and because constants
    are renumbered after simplifying, the arbitrary constants in expr are not necessarily
    equal to the ones of the same name in the returned result.
  prefs: []
  type: TYPE_NORMAL
- en: If two or more arbitrary constants are added, multiplied, or raised to the power
    of each other, they are first absorbed together into a single arbitrary constant.
    Then the new constant is combined into other terms if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Absorption of constants is done with limited assistance:'
  prefs: []
  type: TYPE_NORMAL
- en: terms of [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")s are
    collected to try join constants so \(e^x (C_1 \cos(x) + C_2 \cos(x))\) will simplify
    to \(e^x C_1 \cos(x)\);
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: powers with exponents that are [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")s
    are expanded so \(e^{C_1 + x}\) will be simplified to \(C_1 e^x\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use [`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")
    to renumber constants after simplification or else arbitrary numbers on constants
    may appear, e.g. \(C_1 + C_3 x\).
  prefs: []
  type: TYPE_NORMAL
- en: In rare cases, a single constant can be “simplified” into two constants. Every
    differential equation solution should have as many arbitrary constants as the
    order of the differential equation. The result here will be technically correct,
    but it may, for example, have \(C_1\) and \(C_2\) in an expression, when \(C_1\)
    is actually equal to \(C_2\). Use your discretion in such situations, and also
    take advantage of the ability to use hints in [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]  ## Hint Functions'
  prefs: []
  type: TYPE_NORMAL
- en: These functions are intended for internal use by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") and others. Unlike [User Functions](#user-functions),
    above, these are not intended for every-day use by ordinary SymPy users. Instead,
    functions such as [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    should be used. Nonetheless, these functions contain useful information in their
    docstrings on the various ODE solving methods. For this reason, they are documented
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Built-in immutable sequence.
  prefs: []
  type: TYPE_NORMAL
- en: If no argument is given, the constructor returns an empty tuple. If iterable
    is specified the tuple is initialized from iterable’s items.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is a tuple, the return value is the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Simplifies solutions of ODEs, including trying to solve for `func` and running
    [`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp").
  prefs: []
  type: TYPE_NORMAL
- en: It may use knowledge of the type of solution that the hint returns to apply
    additional simplifications.
  prefs: []
  type: TYPE_NORMAL
- en: It also attempts to integrate any [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s in the expression, if the hint is not an
    `_Integral` hint.
  prefs: []
  type: TYPE_NORMAL
- en: This function should have no effect on expressions returned by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), as [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    already calls [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp"),
    but the individual hint functions do not call [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") (because the [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") wrapper does). Therefore, this function is designed
    for mainly internal use.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Renumber arbitrary constants in `expr` to use the symbol names as given in `newconstants`.
    In the process, this reorders expression terms in a standard way.
  prefs: []
  type: TYPE_NORMAL
- en: If `newconstants` is not provided then the new constant names will be `C1`,
    `C2` etc. Otherwise `newconstants` should be an iterable giving the new symbols
    to use for the constants in order.
  prefs: []
  type: TYPE_NORMAL
- en: The `variables` argument is a list of non-constant symbols. All other free symbols
    found in `expr` are assumed to be constants and will be renumbered. If `variables`
    is not given then any numbered symbol beginning with `C` (e.g. `C1`) is assumed
    to be a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are renumbered based on `.sort_key()`, so they should be numbered roughly
    in the order that they appear in the final, printed expression. Note that this
    ordering is based in part on hashes, so it can produce different results on different
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of this function is very similar to that of [`constantsimp()`](#sympy.solvers.ode.constantsimp
    "sympy.solvers.ode.constantsimp").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `variables` argument specifies which are constants so that the other symbols
    will not be renumbered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newconstants` argument is used to specify what symbols to use when replacing
    the constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Returns an extended integer representing how simple a solution to an ODE is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following things are considered, in order from most simple to least:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sol` is solved for `func`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sol` is not solved for `func`, but can be if passed to solve (e.g., a solution
    returned by `dsolve(ode, func, simplify=False`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `sol` is not solved for `func`, then base the result on the length of `sol`,
    as computed by `len(str(sol))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `sol` has any unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")s, this will automatically be considered
    less simple than any of the above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function returns an integer such that if solution A is simpler than solution
    B by above metric, then `ode_sol_simplicity(sola, func) < ode_sol_simplicity(solb,
    func)`.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the following are the numbers returned, but if the heuristic is ever
    improved, this may change. Only the ordering is guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: '| Simplicity | Return |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sol` solved for `func` | `-2` |'
  prefs: []
  type: TYPE_TB
- en: '| `sol` not solved for `func` but can be | `-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `sol` is not solved nor solvable for `func` | `len(str(sol))` |'
  prefs: []
  type: TYPE_TB
- en: '| `sol` contains an [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") | `oo` |'
  prefs: []
  type: TYPE_TB
- en: '`oo` here means the SymPy infinity, which should compare greater than any integer.'
  prefs: []
  type: TYPE_NORMAL
- en: If you already know [`solve()`](solvers.html#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    cannot solve `sol`, you can use `trysolving=False` to skip that step, which is
    the only potentially slow step. For example, [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") with the `simplify=False` flag should do this.
  prefs: []
  type: TYPE_NORMAL
- en: If `sol` is a list of solutions, if the worst solution in the list returns `oo`
    it returns that, otherwise it returns `len(str(sol))`, that is, the length of
    the string representation of the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'This function is designed to be passed to `min` as the key argument, such as
    `min(listofsolutions, key=lambda i: ode_sol_simplicity(i, f(x)))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Solves equations having a solvable factor.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used to solve the equation having factors. Factors may be of
    type algebraic or ode. It will try to solve each factor independently. Factors
    will be solved by calling dsolve. We will return the list of solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Solves 1st order exact ordinary differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: A 1st order differential equation is called exact if it is the total differential
    of a function. That is, the differential equation
  prefs: []
  type: TYPE_NORMAL
- en: \[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'is exact if there is some function \(F(x, y)\) such that \(P(x, y) = \partial{}F/\partial{}x\)
    and \(Q(x, y) = \partial{}F/\partial{}y\). It can be shown that a necessary and
    sufficient condition for a first order ODE to be exact is that \(\partial{}P/\partial{}y
    = \partial{}Q/\partial{}x\). Then, the solution will be as given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Where the first partials of \(P\) and \(Q\) exist and are continuous in a simply
    connected region.
  prefs: []
  type: TYPE_NORMAL
- en: 'A note: SymPy currently has no way to represent inert substitution on an expression,
    so the hint `1st_exact_Integral` will return an integral with \(dy\). This is
    supposed to represent the function that you are solving for.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Exact_differential_equation](https://en.wikipedia.org/wiki/Exact_differential_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Returns the best solution to an ODE from the two hints `1st_homogeneous_coeff_subs_dep_div_indep`
    and `1st_homogeneous_coeff_subs_indep_div_dep`.
  prefs: []
  type: TYPE_NORMAL
- en: This is as determined by [`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity
    "sympy.solvers.ode.ode.ode_sol_simplicity").
  prefs: []
  type: TYPE_NORMAL
- en: See the [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep") and [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep") docstrings for more
    information on these hints. Note that there is no `ode_1st_homogeneous_coeff_best_Integral`
    hint.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Solves a 1st order differential equation with homogeneous coefficients using
    the substitution \(u_1 = \frac{\text{<dependent variable>}}{\text{<independent
    variable>}}\).
  prefs: []
  type: TYPE_NORMAL
- en: This is a differential equation
  prefs: []
  type: TYPE_NORMAL
- en: \[P(x, y) + Q(x, y) dy/dx = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: such that \(P\) and \(Q\) are homogeneous and of the same order. A function
    \(F(x, y)\) is homogeneous of order \(n\) if \(F(x t, y t) = t^n F(x, y)\). Equivalently,
    \(F(x, y)\) can be rewritten as \(G(y/x)\) or \(H(x/y)\). See also the docstring
    of [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order").
  prefs: []
  type: TYPE_NORMAL
- en: 'If the coefficients \(P\) and \(Q\) in the differential equation above are
    homogeneous functions of the same order, then it can be shown that the substitution
    \(y = u_1 x\) (i.e. \(u_1 = y/x\)) will turn the differential equation into an
    equation separable in the variables \(x\) and \(u\). If \(h(u_1)\) is the function
    that results from making the substitution \(u_1 = f(x)/x\) on \(P(x, f(x))\) and
    \(g(u_2)\) is the function that results from the substitution on \(Q(x, f(x))\)
    in the differential equation \(P(x, f(x)) + Q(x, f(x)) f''(x) = 0\), then the
    general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Where \(u_1 h(u_1) + g(u_1) \ne 0\) and \(x \ne 0\).
  prefs: []
  type: TYPE_NORMAL
- en: See also the docstrings of [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest") and [`HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Solves a 1st order differential equation with homogeneous coefficients using
    the substitution \(u_2 = \frac{\text{<independent variable>}}{\text{<dependent
    variable>}}\).
  prefs: []
  type: TYPE_NORMAL
- en: This is a differential equation
  prefs: []
  type: TYPE_NORMAL
- en: \[P(x, y) + Q(x, y) dy/dx = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: such that \(P\) and \(Q\) are homogeneous and of the same order. A function
    \(F(x, y)\) is homogeneous of order \(n\) if \(F(x t, y t) = t^n F(x, y)\). Equivalently,
    \(F(x, y)\) can be rewritten as \(G(y/x)\) or \(H(x/y)\). See also the docstring
    of [`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order").
  prefs: []
  type: TYPE_NORMAL
- en: 'If the coefficients \(P\) and \(Q\) in the differential equation above are
    homogeneous functions of the same order, then it can be shown that the substitution
    \(x = u_2 y\) (i.e. \(u_2 = x/y\)) will turn the differential equation into an
    equation separable in the variables \(y\) and \(u_2\). If \(h(u_2)\) is the function
    that results from making the substitution \(u_2 = x/f(x)\) on \(P(x, f(x))\) and
    \(g(u_2)\) is the function that results from the substitution on \(Q(x, f(x))\)
    in the differential equation \(P(x, f(x)) + Q(x, f(x)) f''(x) = 0\), then the
    general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Where \(u_1 g(u_1) + h(u_1) \ne 0\) and \(f(x) \ne 0\).
  prefs: []
  type: TYPE_NORMAL
- en: See also the docstrings of [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest") and [`HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Homogeneous_differential_equation](https://en.wikipedia.org/wiki/Homogeneous_differential_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Solves 1st order linear differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: These are differential equations of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[dy/dx + P(x) y = Q(x)\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'These kinds of differential equations can be solved in a general way. The integrating
    factor \(e^{\int P(x) \,dx}\) will turn the equation into a separable equation.
    The general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients](https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Gives general solutions to the first order Riccati differential equations that
    have atleast one rational particular solution.
  prefs: []
  type: TYPE_NORMAL
- en: \[y' = b_0(x) + b_1(x) y + b_2(x) y^2\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(b_0\), \(b_1\) and \(b_2\) are rational functions of \(x\) with \(b_2
    \ne 0\) (\(b_2 = 0\) would make it a Bernoulli equation).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: 'Riccati ODE: [https://en.wikipedia.org/wiki/Riccati_equation](https://en.wikipedia.org/wiki/Riccati_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'N. Thieu Vo - Rational and Algebraic Solutions of First-Order Algebraic ODEs:
    Algorithm 11, pp. 78 - [https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf](https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Gives solution of the Airy differential equation
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{d^2y}{dx^2} + (a + b x) y(x) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: in terms of Airy special functions airyai and airybi.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Gives solution of the Bessel differential equation
  prefs: []
  type: TYPE_NORMAL
- en: \[x^2 \frac{d^2y}{dx^2} + x \frac{dy}{dx} y(x) + (x^2-n^2) y(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: if \(n\) is integer then the solution is of the form `Eq(f(x), C0 besselj(n,x)
    + C1 bessely(n,x))` as both the solutions are linearly independent else if \(n\)
    is a fraction then the solution is of the form `Eq(f(x), C0 besselj(n,x) + C1
    besselj(-n,x))` which can also transform into `Eq(f(x), C0 besselj(n,x) + C1 bessely(n,x))`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://math24.net/bessel-differential-equation.html](https://math24.net/bessel-differential-equation.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Solves Bernoulli differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: These are equations of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The substitution \(w = 1/y^{1-n}\) will transform an equation of this form
    into one that is linear (see the docstring of [`FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear")). The general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that the equation is separable when \(n = 1\) (see the docstring of [`Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bernoulli_differential_equation](https://en.wikipedia.org/wiki/Bernoulli_differential_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Solves 2nd order Liouville differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: The general form of a Liouville ODE is
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{d^2 y}{dx^2} + g(y) \left(\! \frac{dy}{dx}\!\right)^2 + h(x) \frac{dy}{dx}\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Goldstein and Braun, “Advanced Methods for the Solution of Differential Equations”,
    pp. 98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The general Riccati equation has the form
  prefs: []
  type: TYPE_NORMAL
- en: \[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: While it does not have a general solution [1], the “special” form, \(dy/dx =
    a y^2 - b x^c\), does have solutions in many cases [2]. This routine returns a
    solution for \(a(dy/dx) = b y^2 + c y/x + d/x^2\) that is obtained by using a
    suitable change of variables to reduce it to the special form and is valid when
    neither \(a\) nor \(b\) are zero and either \(c\) or \(d\) is zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati](https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf](https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf)
    - [https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf](https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear homogeneous differential equation with constant
    coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: This is an equation of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = 0\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: These equations can be solved in a general manner, by taking the roots of the
    characteristic equation \(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m + a_0 = 0\).
    The solution will then be the sum of \(C_n x^i e^{r x}\) terms, for each where
    \(C_n\) is an arbitrary constant, \(r\) is a root of the characteristic equation
    and \(i\) is one of each from 0 to the multiplicity of the root - 1 (for example,
    a root 3 of multiplicity 2 would create the terms \(C_1 e^{3 x} + C_2 x e^{3 x}\)).
    The exponential is usually expanded for complex roots using Euler’s equation \(e^{I
    x} = \cos(x) + I \sin(x)\). Complex roots always come in conjugate pairs in polynomials
    with real coefficients, so the two roots will be represented (after simplifying
    the constants) as \(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\).
  prefs: []
  type: TYPE_NORMAL
- en: If SymPy cannot find exact roots to the characteristic equation, a [`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") instance will be return instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note that because this method does not involve integration, there is no `nth_linear_constant_coeff_homogeneous_Integral`
    hint.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Linear_differential_equation](https://en.wikipedia.org/wiki/Linear_differential_equation)
    section: Nonhomogeneous_equation_with_constant_coefficients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear differential equation with constant coefficients
    using the method of undetermined coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: This method works on differential equations of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(P(x)\) is a function that has a finite number of linearly independent
    derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that fit this requirement are finite sums functions of the form \(a
    x^i e^{b x} \sin(c x + d)\) or \(a x^i e^{b x} \cos(c x + d)\), where \(i\) is
    a non-negative integer and \(a\), \(b\), \(c\), and \(d\) are constants. For example
    any polynomial in \(x\), functions like \(x^2 e^{2 x}\), \(x \sin(x)\), and \(e^x
    \cos(x)\) can all be used. Products of \(\sin\)’s and \(\cos\)’s have a finite
    number of derivatives, because they can be expanded into \(\sin(a x)\) and \(\cos(b
    x)\) terms. However, SymPy currently cannot do that expansion, so you will need
    to manually rewrite the expression in terms of the above to use this method. So,
    for example, you will need to manually convert \(\sin^2(x)\) into \((1 + \cos(2
    x))/2\) to properly apply the method of undetermined coefficients on it.
  prefs: []
  type: TYPE_NORMAL
- en: This method works by creating a trial function from the expression and all of
    its linear independent derivatives and substituting them into the original ODE.
    The coefficients for each term will be a system of linear equations, which are
    be solved for and substituted, giving the solution. If any of the trial functions
    are linearly dependent on the solution to the homogeneous equation, they are multiplied
    by sufficient \(x\) to make them linearly independent.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients](https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear differential equation with constant coefficients
    using the method of variation of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This method works on any differential equations of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0 f(x) = P(x)\text{.}\]
  prefs: []
  type: TYPE_NORMAL
- en: This method works by assuming that the particular solution takes the form
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(y_i\) is the \(i\)th solution to the homogeneous equation. The solution
    is then solved using Wronskian’s and Cramer’s Rule. The particular solution is
    given by
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx \right) y_i(x) \text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(W(x)\) is the Wronskian of the fundamental system (the system of \(n\)
    linearly independent solutions to the homogeneous equation), and \(W_i(x)\) is
    the Wronskian of the fundamental system with the \(i\)th column replaced with
    \([0, 0, \cdots, 0, P(x)]\).
  prefs: []
  type: TYPE_NORMAL
- en: This method is general enough to solve any \(n\)th order inhomogeneous linear
    differential equation with constant coefficients, but sometimes SymPy cannot simplify
    the Wronskian well enough to integrate it. If this method hangs, try using the
    `nth_linear_constant_coeff_variation_of_parameters_Integral` hint and simplifying
    the integrals manually. Also, prefer using `nth_linear_constant_coeff_undetermined_coefficients`
    when it applies, because it does not use integration, making it faster and more
    reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Warning, using simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters’
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") may cause
    it to hang, because it will not attempt to simplify the Wronskian before integrating.
    It is recommended that you only use simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters_Integral’
    for this method, especially if the solution to the homogeneous equation has trigonometric
    functions in it.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Variation_of_parameters](https://en.wikipedia.org/wiki/Variation_of_parameters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://planetmath.org/VariationOfParameters](https://planetmath.org/VariationOfParameters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear homogeneous variable-coefficient Cauchy-Euler
    equidimensional ordinary differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: This is an equation with form \(0 = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  prefs: []
  type: TYPE_NORMAL
- en: These equations can be solved in a general manner, by substituting solutions
    of the form \(f(x) = x^r\), and deriving a characteristic equation for \(r\).
    When there are repeated roots, we include extra terms of the form \(C_{r k} \ln^k(x)
    x^r\), where \(C_{r k}\) is an arbitrary integration constant, \(r\) is a root
    of the characteristic equation, and \(k\) ranges over the multiplicity of \(r\).
    In the cases where the roots are complex, solutions of the form \(C_1 x^a \sin(b
    \log(x)) + C_2 x^a \cos(b \log(x))\) are returned, based on expansions with Euler’s
    formula. The general solution is the sum of the terms found. If SymPy cannot find
    exact roots to the characteristic equation, a [`ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") instance will be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that because this method does not involve integration, there is no `nth_linear_euler_eq_homogeneous_Integral`
    hint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is for internal use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`returns = ''sol''` returns the solution to the ODE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returns = ''list''` returns a list of linearly independent solutions, corresponding
    to the fundamental solution set, for use with non homogeneous solution methods
    like variation of parameters and undetermined coefficients. Note that, though
    the solutions should be linearly independent, this function does not explicitly
    check that. You can do `assert simplify(wronskian(sollist)) != 0` to check for
    linear independence. Also, `assert len(sollist) == order` will need to pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returns = ''both''`, return a dictionary `{''sol'': <solution to ODE>, ''list'':
    <list of linearly independent solutions>}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation](https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C. Bender & S. Orszag, “Advanced Mathematical Methods for Scientists and Engineers”,
    Springer 1999, pp. 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear non homogeneous Cauchy-Euler equidimensional
    ordinary differential equation using variation of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This is an equation with form \(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  prefs: []
  type: TYPE_NORMAL
- en: This method works by assuming that the particular solution takes the form
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{x=1}^{n} c_i(x) y_i(x) {a_n} {x^n} \text{, }\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(y_i\) is the \(i\)th solution to the homogeneous equation. The solution
    is then solved using Wronskian’s and Cramer’s Rule. The particular solution is
    given by multiplying eq given below with \(a_n x^{n}\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \, dx \right) y_i(x) \text{,
    }\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(W(x)\) is the Wronskian of the fundamental system (the system of \(n\)
    linearly independent solutions to the homogeneous equation), and \(W_i(x)\) is
    the Wronskian of the fundamental system with the \(i\)th column replaced with
    \([0, 0, \cdots, 0, \frac{x^{- n}}{a_n} g{\left(x \right)}]\).
  prefs: []
  type: TYPE_NORMAL
- en: This method is general enough to solve any \(n\)th order inhomogeneous linear
    differential equation, but sometimes SymPy cannot simplify the Wronskian well
    enough to integrate it. If this method hangs, try using the `nth_linear_constant_coeff_variation_of_parameters_Integral`
    hint and simplifying the integrals manually. Also, prefer using `nth_linear_constant_coeff_undetermined_coefficients`
    when it applies, because it does not use integration, making it faster and more
    reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Warning, using simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters’
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") may cause
    it to hang, because it will not attempt to simplify the Wronskian before integrating.
    It is recommended that you only use simplify=False with ‘nth_linear_constant_coeff_variation_of_parameters_Integral’
    for this method, especially if the solution to the homogeneous equation has trigonometric
    functions in it.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order linear non homogeneous Cauchy-Euler equidimensional
    ordinary differential equation using undetermined coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: This is an equation with form \(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
    \cdots\).
  prefs: []
  type: TYPE_NORMAL
- en: These equations can be solved in a general manner, by substituting solutions
    of the form \(x = exp(t)\), and deriving a characteristic equation of form \(g(exp(t))
    = b_0 f(t) + b_1 f'(t) + b_2 f''(t) \cdots\) which can be then solved by nth_linear_constant_coeff_undetermined_coefficients
    if g(exp(t)) has finite number of linearly independent derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that fit this requirement are finite sums functions of the form \(a
    x^i e^{b x} \sin(c x + d)\) or \(a x^i e^{b x} \cos(c x + d)\), where \(i\) is
    a non-negative integer and \(a\), \(b\), \(c\), and \(d\) are constants. For example
    any polynomial in \(x\), functions like \(x^2 e^{2 x}\), \(x \sin(x)\), and \(e^x
    \cos(x)\) can all be used. Products of \(\sin\)’s and \(\cos\)’s have a finite
    number of derivatives, because they can be expanded into \(\sin(a x)\) and \(\cos(b
    x)\) terms. However, SymPy currently cannot do that expansion, so you will need
    to manually rewrite the expression in terms of the above to use this method. So,
    for example, you will need to manually convert \(\sin^2(x)\) into \((1 + \cos(2
    x))/2\) to properly apply the method of undetermined coefficients on it.
  prefs: []
  type: TYPE_NORMAL
- en: After replacement of x by exp(t), this method works by creating a trial function
    from the expression and all of its linear independent derivatives and substituting
    them into the original ODE. The coefficients for each term will be a system of
    linear equations, which are be solved for and substituted, giving the solution.
    If any of the trial functions are linearly dependent on the solution to the homogeneous
    equation, they are multiplied by sufficient \(x\) to make them linearly independent.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Solves an \(n\)th order ordinary differential equation using algebra and integrals.
  prefs: []
  type: TYPE_NORMAL
- en: There is no general form for the kind of equation that this can solve. The the
    equation is solved algebraically treating differentiation as an invertible algebraic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that this solver can return algebraic solutions that do not have any integration
    constants (f(x) = 0 in the above example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Solves ODEs that only involve derivatives of the dependent variable using a
    substitution of the form \(f^n(x) = g(x)\).
  prefs: []
  type: TYPE_NORMAL
- en: For example any second order ODE of the form \(f''(x) = h(f'(x), x)\) can be
    transformed into a pair of 1st order ODEs \(g'(x) = h(g(x), x)\) and \(f'(x) =
    g(x)\). Usually the 1st order ODE for \(g\) is easier to solve. If that gives
    an explicit solution for \(g\) then \(f\) is found simply by integration.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Solves separable 1st order differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is any differential equation that can be written as \(P(y) \tfrac{dy}{dx}
    = Q(x)\). The solution can then just be found by rearranging terms and integrating:
    \(\int P(y) \,dy = \int Q(x) \,dx\). This hint uses [`sympy.simplify.simplify.separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars") as its back end, so if a separable equation
    is not caught by this solver, it is most likely the fault of that function. [`separatevars()`](../simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars") is smart enough to do most expansion and
    factoring necessary to convert a separable equation \(F(x, y)\) into the proper
    form \(P(x)\cdot{}Q(y)\). The general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: M. Tenenbaum & H. Pollard, “Ordinary Differential Equations”, Dover 1963, pp.
    52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirect doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Solves an almost-linear differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: The general form of an almost linear differential equation is
  prefs: []
  type: TYPE_NORMAL
- en: \[a(x) g'(f(x)) f'(x) + b(x) g(f(x)) + c(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: Here \(f(x)\) is the function to be solved for (the dependent variable). The
    substitution \(g(f(x)) = u(x)\) leads to a linear differential equation for \(u(x)\)
    of the form \(a(x) u' + b(x) u + c(x) = 0\). This can be solved for \(u(x)\) by
    the \(first_linear\) hint and then \(f(x)\) is found by solving \(g(f(x)) = u(x)\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.solvers.ode.single.FirstLinear`](#sympy.solvers.ode.single.FirstLinear
    "sympy.solvers.ode.single.FirstLinear")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Solves a differential equation with linear coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: The general form of a differential equation with linear coefficients is
  prefs: []
  type: TYPE_NORMAL
- en: \[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y + c_2}\!\right) = 0\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(a_1\), \(b_1\), \(c_1\), \(a_2\), \(b_2\), \(c_2\) are constants and
    \(a_1 b_2 - a_2 b_1 \ne 0\).
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be solved by substituting:'
  prefs: []
  type: TYPE_NORMAL
- en: \[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1
    b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1 b_2}\text{.}\end{aligned}\end{align}
    \]
  prefs: []
  type: TYPE_NORMAL
- en: This substitution reduces the equation to a homogeneous differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.solvers.ode.single.HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest"), [`sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"), [`sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep`](#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep
    "sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Solves a differential equation that can be reduced to the separable form.
  prefs: []
  type: TYPE_NORMAL
- en: The general form of this equation is
  prefs: []
  type: TYPE_NORMAL
- en: \[y' + (y/x) H(x^n y) = 0\text{}.\]
  prefs: []
  type: TYPE_NORMAL
- en: This can be solved by substituting \(u(y) = x^n y\). The equation then reduces
    to the separable form \(\frac{u'}{u (\mathrm{power} - H(u))} - \frac{1}{x} = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: 'The general solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.solvers.ode.single.Separable`](#sympy.solvers.ode.single.Separable
    "sympy.solvers.ode.single.Separable")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications of the
    ACM, Volume 14, Number 8, August 1971, pp. 558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This hint implements the Lie group method of solving first order differential
    equations. The aim is to convert the given differential equation from the given
    coordinate system into another coordinate system where it becomes invariant under
    the one-parameter Lie group of translations. The converted ODE can be easily solved
    by quadrature. It makes use of the [`sympy.solvers.ode.infinitesimals()`](#sympy.solvers.ode.infinitesimals
    "sympy.solvers.ode.infinitesimals") function which returns the infinitesimals
    of the transformation.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates \(r\) and \(s\) can be found by solving the following Partial
    Differential Equations.
  prefs: []
  type: TYPE_NORMAL
- en: \[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y} = 0\]\[\xi\frac{\partial
    s}{\partial x} + \eta\frac{\partial s}{\partial y} = 1\]
  prefs: []
  type: TYPE_NORMAL
- en: The differential equation becomes separable in the new coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} + h(x, y)\frac{\partial
    s}{\partial y}}{ \frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial
    y}}\]
  prefs: []
  type: TYPE_NORMAL
- en: After finding the solution by integration, it is then converted back to the
    original coordinate system by substituting \(r\) and \(s\) in terms of \(x\) and
    \(y\) again.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Solving differential equations by Symmetry Groups, John Starrett, pp. 1 - pp.
    14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Solves 2nd order linear differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: It computes special function solutions which can be expressed using the 2F1,
    1F1 or 0F1 hypergeometric functions.
  prefs: []
  type: TYPE_NORMAL
- en: \[y'' + A(x) y' + B(x) y = 0\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(A\) and \(B\) are rational functions.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of differential equations have solution of non-Liouvillian form.
  prefs: []
  type: TYPE_NORMAL
- en: Given linear ODE can be obtained from 2F1 given by
  prefs: []
  type: TYPE_NORMAL
- en: \[(x^2 - x) y'' + ((a + b + 1) x - c) y' + b a y = 0\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where {a, b, c} are arbitrary constants.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm should find any solution of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[y = P(x) _pF_q(..; ..;\frac{\alpha x^k + \beta}{\gamma x^k + \delta})\text{,}\]
  prefs: []
  type: TYPE_NORMAL
- en: where pFq is any of 2F1, 1F1 or 0F1 and \(P\) is an “arbitrary function”. Currently
    only the 2F1 case is implemented in SymPy but the other cases are described in
    the paper and could be implemented in future (contributions welcome!).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: “Non-Liouvillian solutions for second order linear ODEs” by L. Chan, E.S. Cheb-Terrab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The power series solution is a method which gives the Taylor series expansion
    to the solution of a differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: For a first order differential equation \(\frac{dy}{dx} = h(x, y)\), a power
    series solution exists at a point \(x = x_{0}\) if \(h(x, y)\) is analytic at
    \(x_{0}\). The solution is given by
  prefs: []
  type: TYPE_NORMAL
- en: \[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(y(x_{0}) = b\) is the value of y at the initial value of \(x_{0}\).
    To compute the values of the \(F_{n}(x_{0},b)\) the following algorithm is followed,
    until the required number of terms are generated.
  prefs: []
  type: TYPE_NORMAL
- en: \(F_1 = h(x_{0}, b)\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial
    y}F_{1}\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Travis W. Walker, Analytic power series technique for solving first-order differential
    equations, p.p 17, 18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Gives a power series solution to a second order homogeneous differential equation
    with polynomial coefficients at an ordinary point. A homogeneous differential
    equation is of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity it is assumed that \(P(x)\), \(Q(x)\) and \(R(x)\) are polynomials,
    it is sufficient that \(\frac{Q(x)}{P(x)}\) and \(\frac{R(x)}{P(x)}\) exists at
    \(x_{0}\). A recurrence relation is obtained by substituting \(y\) as \(\sum_{n=0}^\infty
    a_{n}x^{n}\), in the differential equation, and equating the nth term. Using this
    relation various terms can be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx](https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: George E. Simmons, “Differential Equations with Applications and Historical
    Notes”, p.p 176 - 184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Gives a power series solution to a second order homogeneous differential equation
    with polynomial coefficients at a regular point. A second order homogeneous differential
    equation is of the form
  prefs: []
  type: TYPE_NORMAL
- en: \[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'A point is said to regular singular at \(x0\) if \(x - x0\frac{Q(x)}{P(x)}\)
    and \((x - x0)^{2}\frac{R(x)}{P(x)}\) are analytic at \(x0\). For simplicity \(P(x)\),
    \(Q(x)\) and \(R(x)\) are assumed to be polynomials. The algorithm for finding
    the power series solutions is:'
  prefs: []
  type: TYPE_NORMAL
- en: Try expressing \((x - x0)P(x)\) and \(((x - x0)^{2})Q(x)\) as power series solutions
    about x0\. Find \(p0\) and \(q0\) which are the constants of the power series
    expansions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve the indicial equation \(f(m) = m(m - 1) + m*p0 + q0\), to obtain the roots
    \(m1\) and \(m2\) of the indicial equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If \(m1 - m2\) is a non integer there exists two series solutions. If \(m1 =
    m2\), there exists only one solution. If \(m1 - m2\) is an integer, then the existence
    of one solution is confirmed. The other solution may or may not exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The power series solution is of the form \(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\).
    The coefficients are determined by the following recurrence relation. \(a_{n}
    = -\frac{\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\). For the case
    in which \(m1 - m2\) is an integer, it can be seen from the recurrence relation
    that for the lower root \(m\), when \(n\) equals the difference of both the roots,
    the denominator becomes zero. So if the numerator is not equal to zero, a second
    series solution exists.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: George E. Simmons, “Differential Equations with Applications and Historical
    Notes”, p.p 176 - 184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lie heuristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These functions are intended for internal use of the Lie Group Solver. Nonetheless,
    they contain useful information in their docstrings on the algorithms implemented
    for the various heuristics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The first heuristic uses the following four sets of assumptions on \(\xi\) and
    \(\eta\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\xi = 0, \eta = f(x)\]\[\xi = 0, \eta = f(y)\]\[\xi = f(x), \eta = 0\]\[\xi
    = f(y), \eta = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: The success of this heuristic is determined by algebraic factorisation. For
    the first assumption \(\xi = 0\) and \(\eta\) to be a function of \(x\), the PDE
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y} - \frac{\partial
    \xi}{\partial x})*h - \frac{\partial \xi}{\partial y}*h^{2} - \xi*\frac{\partial
    h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: reduces to \(f'(x) - f\frac{\partial h}{\partial y} = 0\) If \(\frac{\partial
    h}{\partial y}\) is a function of \(x\), then this can usually be integrated easily.
    A similar idea is applied to the other 3 assumptions as well.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra Solving
    of First Order ODEs Using Symmetry Methods, pp. 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The second heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\eta = 0, \xi = f(x)*g(y)\]\[\eta = f(x)*g(y), \xi = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: The first assumption of this heuristic holds good if \(\frac{1}{h^{2}}\frac{\partial^2}{\partial
    x \partial y}\log(h)\) is separable in \(x\) and \(y\), then the separated factors
    containing \(x\) is \(f(x)\), and \(g(y)\) is obtained by
  prefs: []
  type: TYPE_NORMAL
- en: \[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]
  prefs: []
  type: TYPE_NORMAL
- en: provided \(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\) is a function
    of \(y\) only.
  prefs: []
  type: TYPE_NORMAL
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(y)\), the coordinates are
    again interchanged, to get \(\eta\) as \(f(x)*g(y)\)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 7
    - pp. 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The third heuristic assumes the infinitesimals \(\xi\) and \(\eta\) to be bi-variate
    polynomials in \(x\) and \(y\). The assumption made here for the logic below is
    that \(h\) is a rational function in \(x\) and \(y\) though that may not be necessary
    for the infinitesimals to be bivariate polynomials. The coefficients of the infinitesimals
    are found out by substituting them in the PDE and grouping similar terms that
    are polynomials and since they form a linear system, solve and check for non trivial
    solutions. The degree of the assumed bivariates are increased till a certain maximum
    value.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Lie Groups and Differential Equations pp. 327 - pp. 329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The aim of the fourth heuristic is to find the function \(\chi(x, y)\) that
    satisfies the PDE \(\frac{d\chi}{dx} + h\frac{d\chi}{dx} - \frac{\partial h}{\partial
    y}\chi = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: This assumes \(\chi\) to be a bivariate polynomial in \(x\) and \(y\). By intuition,
    \(h\) should be a rational function in \(x\) and \(y\). The method used here is
    to substitute a general binomial for \(\chi\) up to a certain maximum degree is
    reached. The coefficients of the polynomials, are calculated by by collecting
    terms of the same order in \(x\) and \(y\).
  prefs: []
  type: TYPE_NORMAL
- en: After finding \(\chi\), the next step is to use \(\eta = \xi*h + \chi\), to
    determine \(\xi\) and \(\eta\). This can be done by dividing \(\chi\) by \(h\)
    which would give \(-\xi\) as the quotient and \(\eta\) as the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra Solving
    of First Order ODEs Using Symmetry Methods, pp. 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\eta = g(x), \xi = f(x)\]\[\eta = f(y), \xi = g(y)\]
  prefs: []
  type: TYPE_NORMAL
- en: For the first assumption,
  prefs: []
  type: TYPE_NORMAL
- en: First \(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{ \partial
    yy}}\) is calculated. Let us say this value is A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is constant, then \(h\) is matched to the form \(A(x) + B(x)e^{ \frac{y}{C}}\)
    then, \(\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}\) gives \(f(x)\) and \(A(x)*f(x)\)
    gives \(g(x)\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise \(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{ \partial
    Y}} = \gamma\) is calculated. If
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a] \(\gamma\) is a function of \(x\) alone
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b] \(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{ \partial
    h}{\partial x}}{h + \gamma} = G\) is a function of \(x\) alone. then, \(e^{\int
    G \,dx}\) gives \(f(x)\) and \(-\gamma*f(x)\) gives \(g(x)\)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(x)\), the coordinates are
    again interchanged, to get \(\xi\) as \(f(x^*)\) and \(\eta\) as \(g(y^*)\)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This heuristic uses the following two assumptions on \(\xi\) and \(\eta\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\eta = 0, \xi = f(x) + g(y)\]\[\eta = f(x) + g(y), \xi = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: The first assumption of this heuristic holds good if
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{ \partial x^{2}}(h^{-1}))^{-1}]\]
  prefs: []
  type: TYPE_NORMAL
- en: is separable in \(x\) and \(y\),
  prefs: []
  type: TYPE_NORMAL
- en: The separated factors containing \(y\) is \(\frac{\partial g}{\partial y}\).
    From this \(g(y)\) can be determined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The separated factors containing \(x\) is \(f''(x)\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\) equals \(\frac{f''(x)}{f(x)
    + g(y)}\). From this \(f(x)\) can be determined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second assumption holds good if \(\frac{dy}{dx} = h(x, y)\) is rewritten
    as \(\frac{dy}{dx} = \frac{1}{h(y, x)}\) and the same properties of the first
    assumption satisfies. After obtaining \(f(x)\) and \(g(y)\), the coordinates are
    again interchanged, to get \(\eta\) as \(f(x) + g(y)\).
  prefs: []
  type: TYPE_NORMAL
- en: For both assumptions, the constant factors are separated among \(g(y)\) and
    \(f''(x)\), such that \(f''(x)\) obtained from 3] is the same as that obtained
    from 2]. If not possible, then this heuristic fails.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 7
    - pp. 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This heuristic assumes the presence of unknown functions or known functions
    with non-integer powers.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all functions and non-integer powers containing x and y
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop over each element \(f\) in the list, find \(\frac{\frac{\partial f}{\partial
    x}}{ \frac{\partial f}{\partial x}} = R\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is separable in \(x\) and \(y\), let \(X\) be the factors containing \(x\).
    Then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a] Check if \(\xi = X\) and \(\eta = -\frac{X}{R}\) satisfy the PDE. If yes,
    then return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\xi\) and \(\eta\)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b] Check if \(\xi = \frac{-R}{X}\) and \(\eta = -\frac{1}{X}\) satisfy the PDE.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If yes, then return \(\xi\) and \(\eta\)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If not, then check if
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a] \(\xi = -R,\eta = 1\)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b] \(\xi = 1, \eta = -\frac{1}{R}\)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are solutions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This heuristic finds if infinitesimals of the form \(\eta = f(x)\), \(\xi =
    g(y)\) without making any assumptions on \(h\).
  prefs: []
  type: TYPE_NORMAL
- en: The complete sequence of steps is given in the paper mentioned below.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This heuristic assumes
  prefs: []
  type: TYPE_NORMAL
- en: \(\xi = ax + by + c\) and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(\eta = fx + gy + h\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After substituting the following assumptions in the determining PDE, it reduces
    to
  prefs: []
  type: TYPE_NORMAL
- en: \[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x} - (fx +
    gy + c)\frac{\partial h}{\partial y}\]
  prefs: []
  type: TYPE_NORMAL
- en: Solving the reduced PDE obtained, using the method of characteristics, becomes
    impractical. The method followed is grouping similar terms and solving the system
    of linear equations obtained. The difference between the bivariate heuristic is
    that \(h\) need not be a rational function in this case.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order ODE Patterns, pp. 10
    - pp. 12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rational Riccati Solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These functions are intended for internal use to solve a first order Riccati
    differential equation with atleast one rational particular solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Given a solution \(w(x)\) to the equation
  prefs: []
  type: TYPE_NORMAL
- en: \[w'(x) = b_0(x) + b_1(x)*w(x) + b_2(x)*w(x)^2\]
  prefs: []
  type: TYPE_NORMAL
- en: and rational function coefficients \(b_1(x)\) and \(b_2(x)\), this function
    transforms the solution to give a solution \(y(x)\) for its corresponding normal
    Riccati ODE
  prefs: []
  type: TYPE_NORMAL
- en: \[y'(x) + y(x)^2 = a(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: using the transformation
  prefs: []
  type: TYPE_NORMAL
- en: \[y(x) = -b_2(x)*w(x) - b'_2(x)/(2*b_2(x)) - b_1(x)/2\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Inverse transforming the solution to the normal Riccati ODE to get the solution
    to the Riccati ODE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Convert a Riccati ODE into its corresponding normal Riccati ODE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Helper function to calculate the coefficients in the c-vector for each pole.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Helper function to calculate the coefficients in the d-vector based on the valuation
    of the function at oo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The function computes the Laurent series coefficients of a rational function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**num: A Poly object that is the numerator of `f(x)`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**den: A Poly object that is the denominator of `f(x)`.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**x: The variable of expansion of the series.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**r: The point of expansion of the series.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**m: Multiplicity of r if r is a pole of `f(x)`. Should**'
  prefs: []
  type: TYPE_NORMAL
- en: '**be zero otherwise.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**n: Order of the term upto which the series is expanded.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'series: A dictionary that has power of the term as key'
  prefs: []
  type: TYPE_NORMAL
- en: and coefficient of that term as value.
  prefs: []
  type: TYPE_NORMAL
- en: Below is a basic outline of how the Laurent series of a
  prefs: []
  type: TYPE_NORMAL
- en: rational function \(f(x)\) about \(x_0\) is being calculated -
  prefs: []
  type: TYPE_NORMAL
- en: Substitute \(x + x_0\) in place of \(x\). If \(x_0\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: is a pole of \(f(x)\), multiply the expression by \(x^m\)
  prefs: []
  type: TYPE_NORMAL
- en: where \(m\) is the multiplicity of \(x_0\). Denote the
  prefs: []
  type: TYPE_NORMAL
- en: the resulting expression as g(x). We do this substitution
  prefs: []
  type: TYPE_NORMAL
- en: so that we can now find the Laurent series of g(x) about
  prefs: []
  type: TYPE_NORMAL
- en: \(x = 0\).
  prefs: []
  type: TYPE_NORMAL
- en: We can then assume that the Laurent series of \(g(x)\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: takes the following form -
  prefs: []
  type: TYPE_NORMAL
- en: \[g(x) = \frac{num(x)}{den(x)} = \sum_{m = 0}^{\infty} a_m x^m\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(a_m\) denotes the Laurent series coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: Multiply the denominator to the RHS of the equation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: and form a recurrence relation for the coefficients \(a_m\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Helper function to calculate -
  prefs: []
  type: TYPE_NORMAL
- en: 1\. m - The degree bound for the polynomial solution that must be found for
    the auxiliary differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. ybar - Part of the solution which can be computed using the poles, c and
    d vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Helper function to find a polynomial solution of degree m for the auxiliary
    differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Helper function to remove redundant solutions to the differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: ” Helper function which computes the general solution for a Riccati ODE from
    its particular solutions.
  prefs: []
  type: TYPE_NORMAL
- en: There are 3 cases to find the general solution from the particular solutions
    for a Riccati ODE depending on the number of particular solution(s) we have -
    1, 2 or 3.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see Section 6 of “Methods of Solution of the Riccati Differential
    Equation” by D. R. Haaheim and F. M. Stein
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The main function that gives particular/general solutions to Riccati ODEs that
    have atleast 1 rational particular solution.
  prefs: []
  type: TYPE_NORMAL
- en: System of ODEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These functions are intended for internal use by [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") for system of differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The equations of this type of ode are .
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = f(t) x + g(t) y\]\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]
  prefs: []
  type: TYPE_NORMAL
- en: This is solved by first multiplying the first equation by \(-a\) and adding
    it to the second equation to obtain
  prefs: []
  type: TYPE_NORMAL
- en: \[y' - a x' = -a h(t) (y - a x)\]
  prefs: []
  type: TYPE_NORMAL
- en: Setting \(U = y - ax\) and integrating the equation we arrive at
  prefs: []
  type: TYPE_NORMAL
- en: \[y - ax = C_1 e^{-a \int h(t) \,dt}\]
  prefs: []
  type: TYPE_NORMAL
- en: and on substituting the value of y in first equation give rise to first order
    ODEs. After solving for \(x\), we can obtain \(y\) by substituting the value of
    \(x\) in second equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The equations of this type of ode are .
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = f(t) x + g(t) y\]\[y' = h(t) x + p(t) y\]
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating the first equation and substituting the value of \(y\) from
    second equation will give a second-order linear equation
  prefs: []
  type: TYPE_NORMAL
- en: \[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: This above equation can be easily integrated if following conditions are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: \(fgp - g^{2} h + f g' - f' g = 0\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If first condition is satisfied then it is solved by current dsolve solver and
    in second case it becomes a constant coefficient differential equation which is
    also solved by current solver.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise if the above condition fails then, a particular solution is assumed
    as \(x = x_0(t)\) and \(y = y_0(t)\) Then the general solution is expressed as
  prefs: []
  type: TYPE_NORMAL
- en: \[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]\[y
    = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)}
    \,dt]\]
  prefs: []
  type: TYPE_NORMAL
- en: where C1 and C2 are arbitrary constants and
  prefs: []
  type: TYPE_NORMAL
- en: \[F(t) = e^{\int f(t) \,dt}, P(t) = e^{\int p(t) \,dt}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Convert a linear system of ODEs to matrix form
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eqs** : list of SymPy expressions or equalities'
  prefs: []
  type: TYPE_NORMAL
- en: The equations as expressions (assumed equal to zero).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**funcs** : list of applied functions'
  prefs: []
  type: TYPE_NORMAL
- en: The dependent variables of the system of ODEs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**order** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The order of the system of ODEs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The tuple `(As, b)` where `As` is a tuple of matrices and `b` is the
  prefs: []
  type: TYPE_NORMAL
- en: the matrix representing the rhs of the matrix equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ODEOrderError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the system of ODEs have an order greater than what was specified
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ODENonlinearError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the system of ODEs is nonlinear
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Express a system of linear ordinary differential equations as a single matrix
    differential equation [1]. For example the system \(x' = x + y + 1\) and \(y'
    = x - y\) can be represented as
  prefs: []
  type: TYPE_NORMAL
- en: \[A_1 X' = A_0 X + b\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(A_1\) and \(A_0\) are \(2 \times 2\) matrices and \(b\), \(X\) and \(X'\)
    are \(2 \times 1\) matrices with \(X = [x, y]^T\).
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order systems are represented with additional matrices e.g. a second-order
    system would look like
  prefs: []
  type: TYPE_NORMAL
- en: \[A_2 X'' = A_1 X' + A_0 X + b\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We can create a system of linear ODEs like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Now `linear_ode_to_matrix` can represent this as a matrix differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The original equations can be recovered from these matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: If the system of equations has a maximum order greater than the order of the
    system specified, a ODEOrderError exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: If the system of equations is nonlinear, then ODENonlinearError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`linear_eq_to_matrix`](solveset.html#sympy.solvers.solveset.linear_eq_to_matrix
    "sympy.solvers.solveset.linear_eq_to_matrix")'
  prefs: []
  type: TYPE_NORMAL
- en: for systems of linear algebraic equations.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R884](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Matrix_differential_equation](https://en.wikipedia.org/wiki/Matrix_differential_equation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Function that solves for highest order derivatives in a system
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eqs** : List'
  prefs: []
  type: TYPE_NORMAL
- en: List of the ODEs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**funcs** : List'
  prefs: []
  type: TYPE_NORMAL
- en: List of dependent variables
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: Independent variable
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'This function inputs a system of ODEs and based on the system, the dependent
    variables and their highest order, returns the system in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X'(t) = A(t) X(t) + b(t)\]
  prefs: []
  type: TYPE_NORMAL
- en: Here, \(X(t)\) is the vector of dependent variables of lower order, \(A(t)\)
    is the coefficient matrix, \(b(t)\) is the non-homogeneous term and \(X'(t)\)
    is the vector of dependent variables in their respective highest order. We use
    the term canonical form to imply the system of ODEs which is of the above form.
  prefs: []
  type: TYPE_NORMAL
- en: If the system passed has a non-linear term with multiple solutions, then a list
    of systems is returned in its canonical form.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Helper function that determines the type of the system of ODEs for solving with
    [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve")
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Coefficient matrix of the system of ODEs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b** : Matrix or None'
  prefs: []
  type: TYPE_NORMAL
- en: Non-homogeneous term of the system. The default value is None. If this argument
    is None, then the system is assumed to be homogeneous.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Dict
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the coefficient matrix does not have a commutative antiderivative
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This function takes in the coefficient matrix and/or the non-homogeneous term
    and returns the type of the equation that can be solved by [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve").
  prefs: []
  type: TYPE_NORMAL
- en: If the system is constant coefficient homogeneous, then “type1” is returned
  prefs: []
  type: TYPE_NORMAL
- en: If the system is constant coefficient non-homogeneous, then “type2” is returned
  prefs: []
  type: TYPE_NORMAL
- en: If the system is non-constant coefficient homogeneous, then “type3” is returned
  prefs: []
  type: TYPE_NORMAL
- en: If the system is non-constant coefficient non-homogeneous, then “type4” is returned
  prefs: []
  type: TYPE_NORMAL
- en: If the system has a non-constant coefficient matrix which can be factorized
    into constant coefficient matrix, then “type5” or “type6” is returned for when
    the system is homogeneous or non-homogeneous respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, if the system of ODEs is of “type3” or “type4”, then along with the
    type, the commutative antiderivative of the coefficient matrix is also returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the system cannot be solved by [`sympy.solvers.ode.systems.linodesolve()`](#sympy.solvers.ode.systems.linodesolve
    "sympy.solvers.ode.systems.linodesolve"), then NotImplementedError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`linodesolve`](#sympy.solvers.ode.systems.linodesolve "sympy.solvers.ode.systems.linodesolve")'
  prefs: []
  type: TYPE_NORMAL
- en: Function for which linodesolve_type gets the information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Matrix exponential \(\exp(A*t)\) for the matrix *A* and scalar *t*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix \(A\) in the expression \(\exp(A*t)\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns the Jordan form of the \(\exp(A*t)\) along with the matrix \(P\) such
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\exp(A*t) = P * expJ * P^{-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: We will consider a 2x2 defective matrix. This shows that our method works even
    for defective matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: It can be observed that this function gives us the Jordan normal form and the
    required invertible matrix P.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it is shown that P and expJ returned by this function is correct as they
    satisfy the formula: P * expJ * P_inverse = exp(A*t).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R885](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Defective_matrix](https://en.wikipedia.org/wiki/Defective_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R886](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Jordan_matrix](https://en.wikipedia.org/wiki/Jordan_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R887](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Jordan_normal_form](https://en.wikipedia.org/wiki/Jordan_normal_form)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Matrix exponential \(\exp(A*t)\) for the matrix `A` and scalar `t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix \(A\) in the expression \(\exp(A*t)\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The independent variable
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'This functions returns the \(\exp(A*t)\) by doing a simple matrix multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\exp(A*t) = P * expJ * P^{-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'where \(expJ\) is \(\exp(J*t)\). \(J\) is the Jordan normal form of \(A\) and
    \(P\) is matrix such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \[A = P * J * P^{-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: The matrix exponential \(\exp(A*t)\) appears in the solution of linear differential
    equations. For example if \(x\) is a vector and \(A\) is a matrix then the initial
    value problem
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{dx(t)}{dt} = A \times x(t), x(0) = x0\]
  prefs: []
  type: TYPE_NORMAL
- en: has the unique solution
  prefs: []
  type: TYPE_NORMAL
- en: \[x(t) = \exp(A t) x0\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: We will consider a 2x2 matrix for comupting the exponential
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, exp(A*t) is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`matrix_exp_jordan_form`](#sympy.solvers.ode.systems.matrix_exp_jordan_form
    "sympy.solvers.ode.systems.matrix_exp_jordan_form")'
  prefs: []
  type: TYPE_NORMAL
- en: For exponential of Jordan normal form
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R888](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Jordan_normal_form](https://en.wikipedia.org/wiki/Jordan_normal_form)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R889](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Matrix_exponential](https://en.wikipedia.org/wiki/Matrix_exponential)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: System of n equations linear first-order differential equations
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Coefficient matrix of the system of linear first order ODEs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: Independent variable in the system of ODEs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b** : Matrix or None'
  prefs: []
  type: TYPE_NORMAL
- en: Non-homogeneous term in the system of ODEs. If None is passed, a homogeneous
    system of ODEs is assumed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**B** : Matrix or None'
  prefs: []
  type: TYPE_NORMAL
- en: Antiderivative of the coefficient matrix. If the antiderivative is not passed
    and the solution requires the term, then the solver would compute it internally.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**type** : String'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of the system of ODEs passed. Depending on the type, the solution is evaluated.
    The type values allowed and the corresponding system it solves are: “type1” for
    constant coefficient homogeneous “type2” for constant coefficient non-homogeneous,
    “type3” for non-constant coefficient homogeneous, “type4” for non-constant coefficient
    non-homogeneous, “type5” and “type6” for non-constant coefficient homogeneous
    and non-homogeneous systems respectively where the coefficient matrix can be factorized
    to a constant coefficient matrix. The default value is “auto” which will let the
    solver decide the correct type of the system passed.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**doit** : Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the solution if True, default value is False
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**tau: Expression**'
  prefs: []
  type: TYPE_NORMAL
- en: Used to substitute for the value of \(t\) after we get the solution of the system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: This error is raised when the coefficient matrix, non-homogeneous term or the
    antiderivative, if passed, are not a matrix or do not have correct dimensions
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonSquareMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: When the coefficient matrix or its antiderivative, if passed is not a square
    matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the coefficient matrix does not have a commutative antiderivative
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'This solver solves the system of ODEs of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X'(t) = A(t) X(t) + b(t)\]
  prefs: []
  type: TYPE_NORMAL
- en: Here, \(A(t)\) is the coefficient matrix, \(X(t)\) is the vector of n independent
    variables, \(b(t)\) is the non-homogeneous term and \(X'(t)\) is the derivative
    of \(X(t)\)
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the properties of \(A(t)\) and \(b(t)\), this solver evaluates
    the solution differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(A(t)\) is constant coefficient matrix and \(b(t)\) is zero vector i.e.
    system is homogeneous, the system is “type1”. The solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X(t) = \exp(A t) C\]
  prefs: []
  type: TYPE_NORMAL
- en: Here, \(C\) is a vector of constants and \(A\) is the constant coefficient matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(A(t)\) is constant coefficient matrix and \(b(t)\) is non-zero i.e.
    system is non-homogeneous, the system is “type2”. The solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(A(t)\) is coefficient matrix such that its commutative with its antiderivative
    \(B(t)\) and \(b(t)\) is a zero vector i.e. system is homogeneous, the system
    is “type3”. The solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X(t) = \exp(B(t)) C\]
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(A(t)\) is commutative with its antiderivative \(B(t)\) and \(b(t)\)
    is non-zero i.e. system is non-homogeneous, the system is “type4”. The solution
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[X(t) = e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'When \(A(t)\) is a coefficient matrix such that it can be factorized into a
    scalar and a constant coefficient matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: \[A(t) = f(t) * A\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Where \(f(t)\) is a scalar expression in the independent variable \(t\) and
    \(A\) is a constant matrix, then we can do the following substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: \[tau = \int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the substitution for the non-homogeneous term is done only when its non-zero.
    Using these substitutions, our original system becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: \[Y'(tau) = A * Y(tau) + b(tau)/f(tau)\]
  prefs: []
  type: TYPE_NORMAL
- en: The above system can be easily solved using the solution for “type1” or “type2”
    depending on the homogeneity of the system. After we get the solution for \(Y(tau)\),
    we substitute the solution for \(tau\) as \(t\) to get back \(X(t)\)
  prefs: []
  type: TYPE_NORMAL
- en: \[X(t) = Y(tau)\]
  prefs: []
  type: TYPE_NORMAL
- en: Systems of “type5” and “type6” have a commutative antiderivative but we use
    this solution because its faster to compute.
  prefs: []
  type: TYPE_NORMAL
- en: The final solution is the general solution for all the four equations since
    a constant coefficient matrix is always commutative with its antidervative.
  prefs: []
  type: TYPE_NORMAL
- en: An additional feature of this function is, if someone wants to substitute for
    value of the independent variable, they can pass the substitution \(tau\) and
    the solution will have the independent variable substituted with the passed expression(\(tau\)).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: To solve the system of ODEs using this function directly, several things must
    be done in the right order. Wrong inputs to the function will lead to incorrect
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Here, it is important to note that before we derive the coefficient matrix,
    it is important to get the system of ODEs into the desired form. For that we will
    use [`sympy.solvers.ode.systems.canonical_odes()`](#sympy.solvers.ode.systems.canonical_odes
    "sympy.solvers.ode.systems.canonical_odes").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will use [`sympy.solvers.ode.systems.linear_ode_to_matrix()`](#sympy.solvers.ode.systems.linear_ode_to_matrix
    "sympy.solvers.ode.systems.linear_ode_to_matrix") to get the coefficient matrix
    and the non-homogeneous term if it is there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We have the coefficient matrices and the non-homogeneous term ready. Now, we
    can use [`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type") to get the information for the system
    of ODEs to finally pass it to the solver.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can prove if the solution is correct or not by using [`sympy.solvers.ode.checkodesol()`](#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the doit method to evaluate the solutions passed by the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will look at a system of ODEs which is non-constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The system defined above is already in the desired form, so we do not have to
    convert it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: A user can also pass the commutative antiderivative required for type3 and type4
    system of ODEs. Passing an incorrect one will lead to incorrect results. If the
    coefficient matrix is not commutative with its antiderivative, then [`sympy.solvers.ode.systems.linodesolve_type()`](#sympy.solvers.ode.systems.linodesolve_type
    "sympy.solvers.ode.systems.linodesolve_type") raises a NotImplementedError. If
    it does have a commutative antiderivative, then the function just returns the
    information about the system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can pass the antiderivative as an argument to get the solution. If the
    system information is not passed, then the solver will compute the required arguments
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we can verify the solution obtained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`linear_ode_to_matrix`](#sympy.solvers.ode.systems.linear_ode_to_matrix "sympy.solvers.ode.systems.linear_ode_to_matrix")'
  prefs: []
  type: TYPE_NORMAL
- en: Coefficient matrix computation function
  prefs: []
  type: TYPE_NORMAL
- en: '[`canonical_odes`](#sympy.solvers.ode.systems.canonical_odes "sympy.solvers.ode.systems.canonical_odes")'
  prefs: []
  type: TYPE_NORMAL
- en: System of ODEs representation change
  prefs: []
  type: TYPE_NORMAL
- en: '[`linodesolve_type`](#sympy.solvers.ode.systems.linodesolve_type "sympy.solvers.ode.systems.linodesolve_type")'
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about systems of ODEs to pass in this solver
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = x^n F(x,y)\]\[y' = g(y) F(x,y)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: if \(n \neq 1\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]
  prefs: []
  type: TYPE_NORMAL
- en: if \(n = 1\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C_1\) and \(C_2\) are arbitrary constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = e^{\lambda x} F(x,y)\]\[y' = g(y) F(x,y)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: if \(\lambda \neq 0\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\varphi = -\frac{1}{\lambda} log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]
  prefs: []
  type: TYPE_NORMAL
- en: if \(\lambda = 0\)
  prefs: []
  type: TYPE_NORMAL
- en: \[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C_1\) and \(C_2\) are arbitrary constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Autonomous system of general form
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = F(x,y)\]\[y' = G(x,y)\]
  prefs: []
  type: TYPE_NORMAL
- en: Assuming \(y = y(x, C_1)\) where \(C_1\) is an arbitrary constant is the general
    solution of the first-order equation
  prefs: []
  type: TYPE_NORMAL
- en: \[F(x,y) y'_x = G(x,y)\]
  prefs: []
  type: TYPE_NORMAL
- en: Then the general solution of the original system of equations has the form
  prefs: []
  type: TYPE_NORMAL
- en: \[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Equation:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = f_1(x) g_1(y) \phi(x,y,t)\]\[y' = f_2(x) g_2(y) \phi(x,y,t)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'First integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C\) is an arbitrary constant.
  prefs: []
  type: TYPE_NORMAL
- en: On solving the first integral for \(x\) (resp., \(y\) ) and on substituting
    the resulting expression into either equation of the original solution, one arrives
    at a first-order equation for determining \(y\) (resp., \(x\) ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Clairaut system of ODEs
  prefs: []
  type: TYPE_NORMAL
- en: \[x = t x' + F(x',y')\]\[y = t y' + G(x',y')\]
  prefs: []
  type: TYPE_NORMAL
- en: The following are solutions of the system
  prefs: []
  type: TYPE_NORMAL
- en: '\((i)\) straight lines:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C_1\) and \(C_2\) are arbitrary constants;
  prefs: []
  type: TYPE_NORMAL
- en: \((ii)\) envelopes of the above lines;
  prefs: []
  type: TYPE_NORMAL
- en: \((iii)\) continuously differentiable lines made up from segments of the lines
    \((i)\) and \((ii)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x
    y\]
  prefs: []
  type: TYPE_NORMAL
- en: 'First Integrals:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C_1\) and \(C_2\) are arbitrary constants. On solving the integrals
    for \(y\) and \(z\) and on substituting the resulting expressions into the first
    equation of the system, we arrives at a separable first-order equation on \(x\).
    Similarly doing that for other two equations, we will arrive at first order equation
    on \(y\) and \(z\) too.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a x' = (b - c) y z f(x, y, z, t)\]\[b y' = (c - a) z x f(x, y, z, t)\]\[c
    z' = (a - b) x y f(x, y, z, t)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'First Integrals:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2}
    = C_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C_1\) and \(C_2\) are arbitrary constants. On solving the integrals
    for \(y\) and \(z\) and on substituting the resulting expressions into the first
    equation of the system, we arrives at a first-order differential equations on
    \(x\). Similarly doing that for other two equations we will arrive at first order
    equation on \(y\) and \(z\).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(F_n = F_n(x, y, z, t)\).
  prefs: []
  type: TYPE_NORMAL
- en: 'First Integral:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \[a x + b y + c z = C_1,\]
  prefs: []
  type: TYPE_NORMAL
- en: where C is an arbitrary constant.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If we assume function \(F_n\) to be independent of \(t\),i.e, \(F_n\) =
    \(F_n (x, y, z)\) Then, on eliminating \(t\) and \(z\) from the first two equation
    of the system, one arrives at the first-order equation
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
    b F_3 (x, y, z)}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(z = \frac{1}{c} (C_1 - a x - b y)\)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Equations:'
  prefs: []
  type: TYPE_NORMAL
- en: \[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y
    F_1 - a x F_2\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(F_n = F_n (x, y, z, t)\)
  prefs: []
  type: TYPE_NORMAL
- en: 'First integral:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \[a x^{2} + b y^{2} + c z^{2} = C_1\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C\) is an arbitrary constant.
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Assuming the function \(F_n\) is independent of \(t\): \(F_n = F_n (x,
    y, z)\). Then on eliminating \(t\) and \(z\) from the first two equations of the
    system, one arrives at the first-order equation'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)} {c z F_2 (x,
    y, z) - b y F_3 (x, y, z)}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: \[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b
    F_1 - a F_2)\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(F_n = F_n (x, y, z, t)\) and are arbitrary functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First Integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(C\) is an arbitrary constant. If the function \(F_n\) is independent
    of \(t\), then, by eliminating \(t\) and \(z\) from the first two equations of
    the system, one arrives at a first-order equation.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: -[https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf](https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: '## Information on the ode module'
  prefs: []
  type: TYPE_NORMAL
- en: This module contains [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    and different helper functions that it uses.
  prefs: []
  type: TYPE_NORMAL
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") solves ordinary
    differential equations. See the docstring on the various functions for their uses.
    Note that partial differential equations support is in `pde.py`. Note that hint
    functions have docstrings describing their various methods, but they are intended
    for internal use. Use `dsolve(ode, func, hint=hint)` to solve an ODE using a specific
    hint. See also the docstring on [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functions in this module**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the user functions in this module:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") - Solves
    ODEs.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    - Classifies ODEs into possible hints for [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`checkodesol()`](#sympy.solvers.ode.checkodesol "sympy.solvers.ode.checkodesol")
    - Checks if an equation is the solution to an ODE.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`homogeneous_order()`](#sympy.solvers.ode.homogeneous_order "sympy.solvers.ode.homogeneous_order")
    - Returns the homogeneous order of an expression.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`infinitesimals()`](#sympy.solvers.ode.infinitesimals "sympy.solvers.ode.infinitesimals")
    - Returns the infinitesimals of the Lie group of point transformations of an ODE,
    such that it is invariant.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`checkinfsol()`](#sympy.solvers.ode.checkinfsol "sympy.solvers.ode.checkinfsol")
    - Checks if the given infinitesimals are the actual infinitesimals of a first
    order ODE.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'These are the non-solver helper functions that are for internal use. The user
    should use the various options to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    to obtain the functionality provided by these functions:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    - Does all forms of ODE simplification.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ode_sol_simplicity()`](#sympy.solvers.ode.ode.ode_sol_simplicity "sympy.solvers.ode.ode.ode_sol_simplicity")
    - A key function for comparing solutions by simplicity.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`constantsimp()`](#sympy.solvers.ode.constantsimp "sympy.solvers.ode.constantsimp")
    - Simplifies arbitrary constants.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`constant_renumber()`](#sympy.solvers.ode.ode.constant_renumber "sympy.solvers.ode.ode.constant_renumber")
    - Renumber arbitrary constants.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral "sympy.solvers.ode.ode._handle_Integral")
    - Evaluate unevaluated Integrals.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also the docstrings of these functions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Currently implemented solver methods**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods are implemented for solving ordinary differential equations.
    See the docstrings of the various hint functions for more information on each
    (run `help(ode)`):'
  prefs: []
  type: TYPE_NORMAL
- en: 1st order separable differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order differential equations whose coefficients or \(dx\) and \(dy\) are
    functions homogeneous of the same order.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order exact differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order linear differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1st order Bernoulli differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Power series solutions for first order differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Lie Group method of solving first order differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 2nd order Liouville differential equations.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Power series solutions for second order differential equations at ordinary and
    regular singular points.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order differential equation that can be solved with algebraic rearrangement
    and integration.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear homogeneous differential equation with constant coefficients.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear inhomogeneous differential equation with constant coefficients
    using the method of undetermined coefficients.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(n\)th order linear inhomogeneous differential equation with constant coefficients
    using the method of variation of parameters.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Philosophy behind this module**'
  prefs: []
  type: TYPE_NORMAL
- en: This module is designed to make it easy to add new ODE solving methods without
    having to mess with the solving code for other methods. The idea is that there
    is a [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    function, which takes in an ODE and tells you what hints, if any, will solve the
    ODE. It does this without attempting to solve the ODE, so it is fast. Each solving
    method is a hint, and it has its own function, named `ode_<hint>`. That function
    takes in the ODE and any match expression gathered by [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") and returns a solved result. If this result
    has any integrals in it, the hint function will return an unevaluated [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") class. [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), which is the user wrapper function around all of
    this, will then call [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    on the result, which, among other things, will attempt to solve the equation for
    the dependent variable (the function we are solving for), simplify the arbitrary
    constants in the expression, and evaluate any integrals, if the hint allows it.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to add new solution methods**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have an ODE that you want [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    to be able to solve, try to avoid adding special case code here. Instead, try
    finding a general method that will solve your ODE, as well as others. This way,
    the [`ode`](#module-sympy.solvers.ode "sympy.solvers.ode") module will become
    more robust, and unhindered by special case hacks. WolphramAlpha and Maple’s DETools[odeadvisor]
    function are two resources you can use to classify a specific ODE. It is also
    better for a method to work with an \(n\)th order ODE instead of only with specific
    orders, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: To add a new method, there are a few things that you need to do. First, you
    need a hint name for your method. Try to name your hint so that it is unambiguous
    with all other methods, including ones that may not be implemented yet. If your
    method uses integrals, also include a `hint_Integral` hint. If there is more than
    one way to solve ODEs with your method, include a hint for each one, as well as
    a `<hint>_best` hint. Your `ode_<hint>_best()` function should choose the best
    using min with `ode_sol_simplicity` as the key argument. See [`HomogeneousCoeffBest`](#sympy.solvers.ode.single.HomogeneousCoeffBest
    "sympy.solvers.ode.single.HomogeneousCoeffBest"), for example. The function that
    uses your method will be called `ode_<hint>()`, so the hint must only use characters
    that are allowed in a Python function name (alphanumeric characters and the underscore
    ‘`_`’ character). Include a function for every hint, except for `_Integral` hints
    ([`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") takes care
    of those automatically). Hint names should be all lowercase, unless a word is
    commonly capitalized (such as Integral or Bernoulli). If you have a hint that
    you do not want to run with `all_Integral` that does not have an `_Integral` counterpart
    (such as a best hint that would defeat the purpose of `all_Integral`), you will
    need to remove it manually in the [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")
    code. See also the [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    docstring for guidelines on writing a hint name.
  prefs: []
  type: TYPE_NORMAL
- en: Determine *in general* how the solutions returned by your method compare with
    other methods that can potentially solve the same ODEs. Then, put your hints in
    the [`allhints`](#sympy.solvers.ode.allhints "sympy.solvers.ode.allhints") tuple
    in the order that they should be called. The ordering of this tuple determines
    which hints are default. Note that exceptions are ok, because it is easy for the
    user to choose individual hints with [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    In general, `_Integral` variants should go at the end of the list, and `_best`
    variants should go before the various hints they apply to. For example, the `undetermined_coefficients`
    hint comes before the `variation_of_parameters` hint because, even though variation
    of parameters is more general than undetermined coefficients, undetermined coefficients
    generally returns cleaner results for the ODEs that it can solve than variation
    of parameters does, and it does not require integration, so it is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to have a match expression or a function that matches the type
    of the ODE, which you should put in [`classify_ode()`](#sympy.solvers.ode.classify_ode
    "sympy.solvers.ode.classify_ode") (if the match function is more than just a few
    lines. It should match the ODE without solving for it as much as possible, so
    that [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    remains fast and is not hindered by bugs in solving code. Be sure to consider
    corner cases. For example, if your solution method involves dividing by something,
    make sure you exclude the case where that division will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the matching of the ODE will also give you the various parts
    that you need to solve it. You should put that in a dictionary (`.match()` will
    do this for you), and add that as `matching_hints['hint'] = matchdict` in the
    relevant part of [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode").
    [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    will then send this to [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"),
    which will send it to your function as the `match` argument. Your function should
    be named [PRE180] dictionary. For example, if you had to substitute in a dummy
    variable in [`classify_ode()`](#sympy.solvers.ode.classify_ode "sympy.solvers.ode.classify_ode")
    to match the ODE, you will need to pass it to your function using the \(match\)
    dict to access it. You can access the independent variable using `func.args[0]`,
    and the dependent variable (the function you are trying to solve for) as `func.func`.
    If, while trying to solve the ODE, you find that you cannot, raise `NotImplementedError`.
    [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve") will catch
    this error with the `all` meta-hint, rather than causing the whole routine to
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: Add a docstring to your function that describes the method employed. Like with
    anything else in SymPy, you will need to add a doctest to the docstring, in addition
    to real tests in `test_ode.py`. Try to maintain consistency with the other hint
    functions’ docstrings. Add your method to the list at the top of this docstring.
    Also, add your method to `ode.rst` in the `docs/src` directory, so that the Sphinx
    docs will pull its docstring into the main SymPy documentation. Be sure to make
    the Sphinx documentation by running `make html` from within the doc directory
    to verify that the docstring formats correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If your solution method involves integrating, use [`Integral`](../integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") instead of [`integrate()`](../core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate"). This allows the user to bypass hard/slow integration
    by using the `_Integral` variant of your hint. In most cases, calling [`sympy.core.basic.Basic.doit()`](../core.html#sympy.core.basic.Basic.doit
    "sympy.core.basic.Basic.doit") will integrate your solution. If this is not the
    case, you will need to write special code in [`_handle_Integral()`](#sympy.solvers.ode.ode._handle_Integral
    "sympy.solvers.ode.ode._handle_Integral"). Arbitrary constants should be symbols
    named `C1`, `C2`, and so on. All solution methods should return an equality instance.
    If you need an arbitrary number of arbitrary constants, you can use `constants
    = numbered_symbols(prefix='C', cls=Symbol, start=1)`. If it is possible to solve
    for the dependent function in a general way, do so. Otherwise, do as best as you
    can, but do not call solve in your `ode_<hint>()` function. [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") will attempt to solve the solution for you, so
    you do not need to do that. Lastly, if your ODE has a common simplification that
    can be applied to your solutions, you can add a special case in [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") for it. For example, solutions returned from
    the `1st_homogeneous_coeff` hints often have many [`log`](../functions/elementary.html#sympy.functions.elementary.exponential.log
    "sympy.functions.elementary.exponential.log") terms, so [`odesimp()`](#sympy.solvers.ode.ode.odesimp
    "sympy.solvers.ode.ode.odesimp") calls [`logcombine()`](../simplify/simplify.html#sympy.simplify.simplify.logcombine
    "sympy.simplify.simplify.logcombine") on them (it also helps to write the arbitrary
    constant as `log(C1)` instead of `C1` in this case). Also consider common ways
    that you can rearrange your solution to have [`constantsimp()`](#sympy.solvers.ode.constantsimp
    "sympy.solvers.ode.constantsimp") take better advantage of it. It is better to
    put simplification in [`odesimp()`](#sympy.solvers.ode.ode.odesimp "sympy.solvers.ode.ode.odesimp")
    than in your method, because it can then be turned off with the simplify flag
    in [`dsolve()`](#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve"). If you
    have any extraneous simplification in your function, be sure to only run it using
    `if match.get('simplify', True):`, especially if it can be slow or if it can reduce
    the domain of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as with every contribution to SymPy, your method will need to be tested.
    Add a test for each method in `test_ode.py`. Follow the conventions there, i.e.,
    test the solver using `dsolve(eq, f(x), hint=your_hint)`, and also test the solution
    using [`checkodesol()`](#sympy.solvers.ode.checkodesol "sympy.solvers.ode.checkodesol")
    (you can put these in a separate tests and skip/XFAIL if it runs too slow/does
    not work). Be sure to call your hint specifically in [`dsolve()`](#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), that way the test will not be broken simply by the
    introduction of another matching hint. If your method works for higher order (>1)
    ODEs, you will need to run `sol = constant_renumber(sol, 'C', 1, order)` for each
    solution, where `order` is the order of the ODE. This is because `constant_renumber`
    renumbers the arbitrary constants by printing order, which is platform dependent.
    Try to test every corner case of your solver, including a range of orders if it
    is a \(n\)th order solver, but if your solver is slow, such as if it involves
    hard integration, try to keep the test run time down.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to refactor existing hints to avoid duplicating code or creating inconsistencies.
    If you can show that your method exactly duplicates an existing method, including
    in the simplicity and speed of obtaining the solutions, then you can remove the
    old, less general method. The existing code is tested extensively in `test_ode.py`,
    so if anything is broken, one of those tests will surely fail.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are not intended for end-user use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Converts a solution with Integrals in it into an actual solution.
  prefs: []
  type: TYPE_NORMAL
- en: For most hints, this simply runs `expr.doit()`.
  prefs: []
  type: TYPE_NORMAL
