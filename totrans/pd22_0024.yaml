- en: Intro to data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/dsintro.html](https://pandas.pydata.org/docs/user_guide/dsintro.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We’ll start with a quick, non-comprehensive overview of the fundamental data
    structures in pandas to get you started. The fundamental behavior about data types,
    indexing, axis labeling, and alignment apply across all of the objects. To get
    started, import NumPy and load pandas into your namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fundamentally, **data alignment is intrinsic**. The link between labels and
    data will not be broken unless done so explicitly by you.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll give a brief intro to the data structures, then consider all of the broad
    categories of functionality and methods in separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: '## Series'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is a one-dimensional labeled array capable of holding any data type (integers,
    strings, floating point numbers, Python objects, etc.). The axis labels are collectively
    referred to as the **index**. The basic method to create a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") is to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `data` can be many different things:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python dict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a scalar value (like 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The passed **index** is a list of axis labels. Thus, this separates into a
    few cases depending on what **data is**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From ndarray**'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is an ndarray, **index** must be the same length as **data**. If no
    index is passed, one will be created having values `[0, ..., len(data) - 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: pandas supports non-unique index values. If an operation that does not support
    duplicate index values is attempted, an exception will be raised at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '**From dict**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    can be instantiated from dicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If an index is passed, the values in data corresponding to the labels in the
    index will be pulled out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: NaN (not a number) is the standard missing data marker used in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '**From scalar value**'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is a scalar value, an index must be provided. The value will be repeated
    to match the length of **index**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Series is ndarray-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    acts very similarly to a `ndarray` and is a valid argument to most NumPy functions.
    However, operations such as slicing will also slice the index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will address array-based indexing like `s.iloc[[4, 3, 1]]` in [section on
    indexing](indexing.html#indexing).
  prefs: []
  type: TYPE_NORMAL
- en: Like a NumPy array, a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") has a single [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is often a NumPy dtype. However, pandas and 3rd-party libraries extend
    NumPy’s type system in a few places, in which case the dtype would be an [`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype"). Some examples within pandas are [Categorical
    data](categorical.html#categorical) and [Nullable integer data type](integer_na.html#integer-na).
    See [dtypes](basics.html#basics-dtypes) for more.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the actual array backing a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the array can be useful when you need to do some operation without
    the index (to disable [automatic alignment](#dsintro-alignment), for example).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). Briefly, an ExtensionArray is a thin
    wrapper around one or more *concrete* arrays like a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). pandas knows how to take an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") and store it in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or a column of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). See [dtypes](basics.html#basics-dtypes) for more.'
  prefs: []
  type: TYPE_NORMAL
- en: While [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is ndarray-like, if you need an *actual* ndarray, then use [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even if the [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is backed by a [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will return a NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Series is dict-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is also like a fixed-size dict in that you can get and set values by index label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If a label is not contained in the index, an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the [`Series.get()`](../reference/api/pandas.Series.get.html#pandas.Series.get
    "pandas.Series.get") method, a missing label will return None or specified default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These labels can also be accessed by [attribute](indexing.html#indexing-attribute-access).
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized operations and label alignment with Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with raw NumPy arrays, looping through value-by-value is usually
    not necessary. The same is true when working with [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in pandas. [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") can also be passed into most NumPy methods expecting an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A key difference between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and ndarray is that operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") automatically align the data based on label. Thus, you can write
    computations without giving consideration to whether the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") involved have the same labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result of an operation between unaligned [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") will have the **union** of the indexes involved. If a label is
    not found in one [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or the other, the result will be marked as missing `NaN`. Being
    able to write code without doing any explicit data alignment grants immense freedom
    and flexibility in interactive data analysis and research. The integrated data
    alignment features of the pandas data structures set pandas apart from the majority
    of related tools for working with labeled data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, we chose to make the default result of operations between differently
    indexed objects yield the **union** of the indexes in order to avoid loss of information.
    Having an index label, though the data is missing, is typically important information
    as part of a computation. You of course have the option of dropping labels with
    missing data via the **dropna** function.
  prefs: []
  type: TYPE_NORMAL
- en: Name attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    also has a `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    `name` can be assigned automatically in many cases, in particular, when selecting
    a single column from a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), the `name` will be assigned the column label.
  prefs: []
  type: TYPE_NORMAL
- en: You can rename a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") with the [`pandas.Series.rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `s` and `s2` refer to different objects.  ## DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    is a 2-dimensional labeled data structure with columns of potentially different
    types. You can think of it like a spreadsheet or SQL table, or a dict of Series
    objects. It is generally the most commonly used pandas object. Like Series, DataFrame
    accepts many different kinds of input:'
  prefs: []
  type: TYPE_NORMAL
- en: Dict of 1D ndarrays, lists, dicts, or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-D numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Structured or record](https://numpy.org/doc/stable/user/basics.rec.html) ndarray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the data, you can optionally pass **index** (row labels) and **columns**
    (column labels) arguments. If you pass an index and / or columns, you are guaranteeing
    the index and / or columns of the resulting DataFrame. Thus, a dict of Series
    plus a specific index will discard all data not matching up to the passed index.
  prefs: []
  type: TYPE_NORMAL
- en: If axis labels are not passed, they will be constructed from the input data
    based on common sense rules.
  prefs: []
  type: TYPE_NORMAL
- en: From dict of Series or dicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting **index** will be the **union** of the indexes of the various
    Series. If there are any nested dicts, these will first be converted to Series.
    If no columns are passed, the columns will be the ordered list of dict keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The row and column labels can be accessed respectively by accessing the **index**
    and **columns** attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a particular set of columns is passed along with a dict of data, the passed
    columns override the keys in the dict.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From dict of ndarrays / lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All ndarrays must share the same length. If an index is passed, it must also
    be the same length as the arrays. If no index is passed, the result will be `range(n)`,
    where `n` is the array length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From structured or record array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This case is handled identically to a dict of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame is not intended to work exactly like a 2-dimensional NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '### From a list of dicts'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]  ### From a dict of tuples'
  prefs: []
  type: TYPE_NORMAL
- en: You can automatically create a MultiIndexed frame by passing a tuples dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]  ### From a Series'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be a DataFrame with the same index as the input Series, and
    with one column whose name is the original name of the Series (only if no other
    column name provided).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]  ### From a list of namedtuples'
  prefs: []
  type: TYPE_NORMAL
- en: The field names of the first `namedtuple` in the list determine the columns
    of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame").
    The remaining namedtuples (or tuples) are simply unpacked and their values are
    fed into the rows of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). If any of those tuples is shorter than the first `namedtuple`
    then the later columns in the corresponding row are marked as missing values.
    If any are longer than the first `namedtuple`, a `ValueError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]  ### From a list of dataclasses'
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes as introduced in [PEP557](https://www.python.org/dev/peps/pep-0557),
    can be passed into the DataFrame constructor. Passing a list of dataclasses is
    equivalent to passing a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware, that all values in the list should be dataclasses, mixing types
    in the list would result in a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Missing data**'
  prefs: []
  type: TYPE_NORMAL
- en: To construct a DataFrame with missing data, we use `np.nan` to represent missing
    values. Alternatively, you may pass a `numpy.MaskedArray` as the data argument
    to the DataFrame constructor, and its masked entries will be considered missing.
    See [Missing data](missing_data.html#missing-data) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**DataFrame.from_dict**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_dict()`](../reference/api/pandas.DataFrame.from_dict.html#pandas.DataFrame.from_dict
    "pandas.DataFrame.from_dict") takes a dict of dicts or a dict of array-like sequences
    and returns a DataFrame. It operates like the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor except for the `orient` parameter which is `''columns''`
    by default, but which can be set to `''index''` in order to use the dict keys
    as row labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass `orient=''index''`, the keys will be the row labels. In this case,
    you can also pass the desired column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**DataFrame.from_records**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_records()`](../reference/api/pandas.DataFrame.from_records.html#pandas.DataFrame.from_records
    "pandas.DataFrame.from_records") takes a list of tuples or an ndarray with structured
    dtype. It works analogously to the normal [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor, except that the resulting DataFrame index may
    be a specific field of the structured dtype.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '### Column selection, addition, deletion'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") semantically like a dict of like-indexed [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. Getting, setting, and deleting columns works with the
    same syntax as the analogous dict operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Columns can be deleted or popped like with a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a scalar value, it will naturally be propagated to fill the
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") that does not have the same index as the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), it will be conformed to the DataFrame’s index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can insert raw ndarrays but their length must match the length of the DataFrame’s
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, columns get inserted at the end. [`DataFrame.insert()`](../reference/api/pandas.DataFrame.insert.html#pandas.DataFrame.insert
    "pandas.DataFrame.insert") inserts at a particular location in the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]  ### Assigning new columns in method chains'
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by [dplyr’s](https://dplyr.tidyverse.org/reference/mutate.html) `mutate`
    verb, DataFrame has an [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method that allows you to easily create new columns
    that are potentially derived from existing columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we inserted a precomputed value. We can also pass in a
    function of one argument to be evaluated on the DataFrame being assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") **always** returns a copy of the data, leaving the
    original DataFrame untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a callable, as opposed to an actual value to be inserted, is useful
    when you don’t have a reference to the DataFrame at hand. This is common when
    using [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") in a chain of operations. For example, we can limit
    the DataFrame to just those observations with a Sepal Length greater than 5, calculate
    the ratio, and plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/basics_assign.png](../Images/67b8f4ee2abe121d27a77929ee9748b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Since a function is passed in, the function is computed on the DataFrame being
    assigned to. Importantly, this is the DataFrame that’s been filtered to those
    rows with sepal length greater than 5\. The filtering happens first, and then
    the ratio calculations. This is an example where we didn’t have a reference to
    the *filtered* DataFrame available.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature for [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") is simply `**kwargs`. The keys are the column names
    for the new fields, and the values are either a value to be inserted (for example,
    a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or NumPy array), or a function of one argument to be called on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). A *copy* of the original [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is returned, with the new values inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The order of `**kwargs` is preserved. This allows for *dependent* assignment,
    where an expression later in `**kwargs` can refer to a column created earlier
    in the same [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the second expression, `x['C']` will refer to the newly created column, that’s
    equal to `dfa['A'] + dfa['B']`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing / selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basics of indexing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Syntax | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Select column | `df[col]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by label | `df.loc[label]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by integer location | `df.iloc[loc]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Slice rows | `df[5:10]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: '| Select rows by boolean vector | `df[bool_vec]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: 'Row selection, for example, returns a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") whose index is the columns of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For a more exhaustive treatment of sophisticated label-based indexing and slicing,
    see the [section on indexing](indexing.html#indexing). We will address the fundamentals
    of reindexing / conforming to new sets of labels in the [section on reindexing](basics.html#basics-reindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '### Data alignment and arithmetic'
  prefs: []
  type: TYPE_NORMAL
- en: Data alignment between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects automatically align on **both the columns and the
    index (row labels)**. Again, the resulting object will have the union of the column
    and row labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When doing an operation between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), the default behavior is to align the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") **index** on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") **columns**, thus [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)
    row-wise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: For explicit control over the matching and broadcasting behavior, see the section
    on [flexible binary operations](basics.html#basics-binop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operations with scalars operate element-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean operators operate element-wise as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Transposing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To transpose, access the `T` attribute or [`DataFrame.transpose()`](../reference/api/pandas.DataFrame.transpose.html#pandas.DataFrame.transpose
    "pandas.DataFrame.transpose"), similar to an ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '### DataFrame interoperability with NumPy functions'
  prefs: []
  type: TYPE_NORMAL
- en: Most NumPy functions can be called directly on [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    is not intended to be a drop-in replacement for ndarray as its indexing semantics
    and data model are quite different in places from an n-dimensional array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`, which allows it to work with NumPy’s [universal
    functions](https://numpy.org/doc/stable/reference/ufuncs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The ufunc is applied to the underlying array in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When multiple [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    are passed to a ufunc, they are aligned before performing the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Like other parts of the library, pandas will automatically align labeled inputs
    as part of a ufunc with multiple inputs. For example, using `numpy.remainder()`
    on two [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with differently ordered labels will align before the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the union of the two indices is taken, and non-overlapping values
    are filled with missing values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When a binary ufunc is applied to a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"), the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") implementation takes precedence and a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: NumPy ufuncs are safe to apply to [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") backed by non-ndarray arrays, for example [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") (see [Sparse calculation](sparse.html#sparse-calculation)).
    If possible, the ufunc is applied without converting the underlying data to an
    ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Console display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very large [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") will be truncated to display them in the console. You can
    also get a summary using [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"). (The **baseball** dataset is from the **plyr** R package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using [`DataFrame.to_string()`](../reference/api/pandas.DataFrame.to_string.html#pandas.DataFrame.to_string
    "pandas.DataFrame.to_string") will return a string representation of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") in tabular form, though it won’t always fit the console width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Wide DataFrames will be printed across multiple rows by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change how much to print on a single row by setting the `display.width`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust the max width of the individual columns by setting `display.max_colwidth`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can also disable this feature via the `expand_frame_repr` option. This will
    print the table in one block.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame column attribute access and IPython completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") column label is a valid Python variable name, the column can
    be accessed like an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns are also connected to the [IPython](https://ipython.org) completion
    mechanism so they can be tab-completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]  ## Series'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is a one-dimensional labeled array capable of holding any data type (integers,
    strings, floating point numbers, Python objects, etc.). The axis labels are collectively
    referred to as the **index**. The basic method to create a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") is to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `data` can be many different things:'
  prefs: []
  type: TYPE_NORMAL
- en: a Python dict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a scalar value (like 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The passed **index** is a list of axis labels. Thus, this separates into a
    few cases depending on what **data is**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From ndarray**'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is an ndarray, **index** must be the same length as **data**. If no
    index is passed, one will be created having values `[0, ..., len(data) - 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: pandas supports non-unique index values. If an operation that does not support
    duplicate index values is attempted, an exception will be raised at that time.
  prefs: []
  type: TYPE_NORMAL
- en: '**From dict**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    can be instantiated from dicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If an index is passed, the values in data corresponding to the labels in the
    index will be pulled out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: NaN (not a number) is the standard missing data marker used in pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '**From scalar value**'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is a scalar value, an index must be provided. The value will be repeated
    to match the length of **index**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Series is ndarray-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    acts very similarly to a `ndarray` and is a valid argument to most NumPy functions.
    However, operations such as slicing will also slice the index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will address array-based indexing like `s.iloc[[4, 3, 1]]` in [section on
    indexing](indexing.html#indexing).
  prefs: []
  type: TYPE_NORMAL
- en: Like a NumPy array, a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") has a single [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is often a NumPy dtype. However, pandas and 3rd-party libraries extend
    NumPy’s type system in a few places, in which case the dtype would be an [`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype"). Some examples within pandas are [Categorical
    data](categorical.html#categorical) and [Nullable integer data type](integer_na.html#integer-na).
    See [dtypes](basics.html#basics-dtypes) for more.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the actual array backing a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the array can be useful when you need to do some operation without
    the index (to disable [automatic alignment](#dsintro-alignment), for example).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). Briefly, an ExtensionArray is a thin
    wrapper around one or more *concrete* arrays like a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). pandas knows how to take an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") and store it in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or a column of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). See [dtypes](basics.html#basics-dtypes) for more.'
  prefs: []
  type: TYPE_NORMAL
- en: While [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is ndarray-like, if you need an *actual* ndarray, then use [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Even if the [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is backed by a [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will return a NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Series is dict-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is also like a fixed-size dict in that you can get and set values by index label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If a label is not contained in the index, an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the [`Series.get()`](../reference/api/pandas.Series.get.html#pandas.Series.get
    "pandas.Series.get") method, a missing label will return None or specified default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These labels can also be accessed by [attribute](indexing.html#indexing-attribute-access).
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized operations and label alignment with Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with raw NumPy arrays, looping through value-by-value is usually
    not necessary. The same is true when working with [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in pandas. [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") can also be passed into most NumPy methods expecting an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: A key difference between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and ndarray is that operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") automatically align the data based on label. Thus, you can write
    computations without giving consideration to whether the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") involved have the same labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The result of an operation between unaligned [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") will have the **union** of the indexes involved. If a label is
    not found in one [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or the other, the result will be marked as missing `NaN`. Being
    able to write code without doing any explicit data alignment grants immense freedom
    and flexibility in interactive data analysis and research. The integrated data
    alignment features of the pandas data structures set pandas apart from the majority
    of related tools for working with labeled data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, we chose to make the default result of operations between differently
    indexed objects yield the **union** of the indexes in order to avoid loss of information.
    Having an index label, though the data is missing, is typically important information
    as part of a computation. You of course have the option of dropping labels with
    missing data via the **dropna** function.
  prefs: []
  type: TYPE_NORMAL
- en: Name attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    also has a `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    `name` can be assigned automatically in many cases, in particular, when selecting
    a single column from a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), the `name` will be assigned the column label.
  prefs: []
  type: TYPE_NORMAL
- en: You can rename a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") with the [`pandas.Series.rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that `s` and `s2` refer to different objects.
  prefs: []
  type: TYPE_NORMAL
- en: Series is ndarray-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    acts very similarly to a `ndarray` and is a valid argument to most NumPy functions.
    However, operations such as slicing will also slice the index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will address array-based indexing like `s.iloc[[4, 3, 1]]` in [section on
    indexing](indexing.html#indexing).
  prefs: []
  type: TYPE_NORMAL
- en: Like a NumPy array, a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") has a single [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is often a NumPy dtype. However, pandas and 3rd-party libraries extend
    NumPy’s type system in a few places, in which case the dtype would be an [`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype"). Some examples within pandas are [Categorical
    data](categorical.html#categorical) and [Nullable integer data type](integer_na.html#integer-na).
    See [dtypes](basics.html#basics-dtypes) for more.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the actual array backing a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the array can be useful when you need to do some operation without
    the index (to disable [automatic alignment](#dsintro-alignment), for example).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). Briefly, an ExtensionArray is a thin
    wrapper around one or more *concrete* arrays like a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). pandas knows how to take an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") and store it in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or a column of a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). See [dtypes](basics.html#basics-dtypes) for more.'
  prefs: []
  type: TYPE_NORMAL
- en: While [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is ndarray-like, if you need an *actual* ndarray, then use [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Even if the [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is backed by a [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will return a NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Series is dict-like
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    is also like a fixed-size dict in that you can get and set values by index label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If a label is not contained in the index, an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the [`Series.get()`](../reference/api/pandas.Series.get.html#pandas.Series.get
    "pandas.Series.get") method, a missing label will return None or specified default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: These labels can also be accessed by [attribute](indexing.html#indexing-attribute-access).
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized operations and label alignment with Series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with raw NumPy arrays, looping through value-by-value is usually
    not necessary. The same is true when working with [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in pandas. [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") can also be passed into most NumPy methods expecting an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: A key difference between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and ndarray is that operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") automatically align the data based on label. Thus, you can write
    computations without giving consideration to whether the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") involved have the same labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The result of an operation between unaligned [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") will have the **union** of the indexes involved. If a label is
    not found in one [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") or the other, the result will be marked as missing `NaN`. Being
    able to write code without doing any explicit data alignment grants immense freedom
    and flexibility in interactive data analysis and research. The integrated data
    alignment features of the pandas data structures set pandas apart from the majority
    of related tools for working with labeled data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, we chose to make the default result of operations between differently
    indexed objects yield the **union** of the indexes in order to avoid loss of information.
    Having an index label, though the data is missing, is typically important information
    as part of a computation. You of course have the option of dropping labels with
    missing data via the **dropna** function.
  prefs: []
  type: TYPE_NORMAL
- en: Name attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    also has a `name` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    `name` can be assigned automatically in many cases, in particular, when selecting
    a single column from a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), the `name` will be assigned the column label.
  prefs: []
  type: TYPE_NORMAL
- en: You can rename a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") with the [`pandas.Series.rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that `s` and `s2` refer to different objects.
  prefs: []
  type: TYPE_NORMAL
- en: '## DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    is a 2-dimensional labeled data structure with columns of potentially different
    types. You can think of it like a spreadsheet or SQL table, or a dict of Series
    objects. It is generally the most commonly used pandas object. Like Series, DataFrame
    accepts many different kinds of input:'
  prefs: []
  type: TYPE_NORMAL
- en: Dict of 1D ndarrays, lists, dicts, or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-D numpy.ndarray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Structured or record](https://numpy.org/doc/stable/user/basics.rec.html) ndarray'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the data, you can optionally pass **index** (row labels) and **columns**
    (column labels) arguments. If you pass an index and / or columns, you are guaranteeing
    the index and / or columns of the resulting DataFrame. Thus, a dict of Series
    plus a specific index will discard all data not matching up to the passed index.
  prefs: []
  type: TYPE_NORMAL
- en: If axis labels are not passed, they will be constructed from the input data
    based on common sense rules.
  prefs: []
  type: TYPE_NORMAL
- en: From dict of Series or dicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting **index** will be the **union** of the indexes of the various
    Series. If there are any nested dicts, these will first be converted to Series.
    If no columns are passed, the columns will be the ordered list of dict keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The row and column labels can be accessed respectively by accessing the **index**
    and **columns** attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a particular set of columns is passed along with a dict of data, the passed
    columns override the keys in the dict.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: From dict of ndarrays / lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All ndarrays must share the same length. If an index is passed, it must also
    be the same length as the arrays. If no index is passed, the result will be `range(n)`,
    where `n` is the array length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: From structured or record array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This case is handled identically to a dict of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame is not intended to work exactly like a 2-dimensional NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '### From a list of dicts'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]  ### From a dict of tuples'
  prefs: []
  type: TYPE_NORMAL
- en: You can automatically create a MultiIndexed frame by passing a tuples dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]  ### From a Series'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be a DataFrame with the same index as the input Series, and
    with one column whose name is the original name of the Series (only if no other
    column name provided).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]  ### From a list of namedtuples'
  prefs: []
  type: TYPE_NORMAL
- en: The field names of the first `namedtuple` in the list determine the columns
    of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame").
    The remaining namedtuples (or tuples) are simply unpacked and their values are
    fed into the rows of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). If any of those tuples is shorter than the first `namedtuple`
    then the later columns in the corresponding row are marked as missing values.
    If any are longer than the first `namedtuple`, a `ValueError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]  ### From a list of dataclasses'
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes as introduced in [PEP557](https://www.python.org/dev/peps/pep-0557),
    can be passed into the DataFrame constructor. Passing a list of dataclasses is
    equivalent to passing a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware, that all values in the list should be dataclasses, mixing types
    in the list would result in a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '**Missing data**'
  prefs: []
  type: TYPE_NORMAL
- en: To construct a DataFrame with missing data, we use `np.nan` to represent missing
    values. Alternatively, you may pass a `numpy.MaskedArray` as the data argument
    to the DataFrame constructor, and its masked entries will be considered missing.
    See [Missing data](missing_data.html#missing-data) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**DataFrame.from_dict**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_dict()`](../reference/api/pandas.DataFrame.from_dict.html#pandas.DataFrame.from_dict
    "pandas.DataFrame.from_dict") takes a dict of dicts or a dict of array-like sequences
    and returns a DataFrame. It operates like the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor except for the `orient` parameter which is `''columns''`
    by default, but which can be set to `''index''` in order to use the dict keys
    as row labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass `orient=''index''`, the keys will be the row labels. In this case,
    you can also pass the desired column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '**DataFrame.from_records**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_records()`](../reference/api/pandas.DataFrame.from_records.html#pandas.DataFrame.from_records
    "pandas.DataFrame.from_records") takes a list of tuples or an ndarray with structured
    dtype. It works analogously to the normal [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor, except that the resulting DataFrame index may
    be a specific field of the structured dtype.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '### Column selection, addition, deletion'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") semantically like a dict of like-indexed [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. Getting, setting, and deleting columns works with the
    same syntax as the analogous dict operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Columns can be deleted or popped like with a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a scalar value, it will naturally be propagated to fill the
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") that does not have the same index as the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), it will be conformed to the DataFrame’s index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: You can insert raw ndarrays but their length must match the length of the DataFrame’s
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, columns get inserted at the end. [`DataFrame.insert()`](../reference/api/pandas.DataFrame.insert.html#pandas.DataFrame.insert
    "pandas.DataFrame.insert") inserts at a particular location in the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]  ### Assigning new columns in method chains'
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by [dplyr’s](https://dplyr.tidyverse.org/reference/mutate.html) `mutate`
    verb, DataFrame has an [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method that allows you to easily create new columns
    that are potentially derived from existing columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we inserted a precomputed value. We can also pass in a
    function of one argument to be evaluated on the DataFrame being assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") **always** returns a copy of the data, leaving the
    original DataFrame untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a callable, as opposed to an actual value to be inserted, is useful
    when you don’t have a reference to the DataFrame at hand. This is common when
    using [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") in a chain of operations. For example, we can limit
    the DataFrame to just those observations with a Sepal Length greater than 5, calculate
    the ratio, and plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/basics_assign.png](../Images/67b8f4ee2abe121d27a77929ee9748b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Since a function is passed in, the function is computed on the DataFrame being
    assigned to. Importantly, this is the DataFrame that’s been filtered to those
    rows with sepal length greater than 5\. The filtering happens first, and then
    the ratio calculations. This is an example where we didn’t have a reference to
    the *filtered* DataFrame available.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature for [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") is simply `**kwargs`. The keys are the column names
    for the new fields, and the values are either a value to be inserted (for example,
    a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or NumPy array), or a function of one argument to be called on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). A *copy* of the original [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is returned, with the new values inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The order of `**kwargs` is preserved. This allows for *dependent* assignment,
    where an expression later in `**kwargs` can refer to a column created earlier
    in the same [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: In the second expression, `x['C']` will refer to the newly created column, that’s
    equal to `dfa['A'] + dfa['B']`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing / selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basics of indexing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Syntax | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Select column | `df[col]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by label | `df.loc[label]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by integer location | `df.iloc[loc]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Slice rows | `df[5:10]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: '| Select rows by boolean vector | `df[bool_vec]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: 'Row selection, for example, returns a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") whose index is the columns of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: For a more exhaustive treatment of sophisticated label-based indexing and slicing,
    see the [section on indexing](indexing.html#indexing). We will address the fundamentals
    of reindexing / conforming to new sets of labels in the [section on reindexing](basics.html#basics-reindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '### Data alignment and arithmetic'
  prefs: []
  type: TYPE_NORMAL
- en: Data alignment between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects automatically align on **both the columns and the
    index (row labels)**. Again, the resulting object will have the union of the column
    and row labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'When doing an operation between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), the default behavior is to align the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") **index** on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") **columns**, thus [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)
    row-wise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: For explicit control over the matching and broadcasting behavior, see the section
    on [flexible binary operations](basics.html#basics-binop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operations with scalars operate element-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean operators operate element-wise as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Transposing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To transpose, access the `T` attribute or [`DataFrame.transpose()`](../reference/api/pandas.DataFrame.transpose.html#pandas.DataFrame.transpose
    "pandas.DataFrame.transpose"), similar to an ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '### DataFrame interoperability with NumPy functions'
  prefs: []
  type: TYPE_NORMAL
- en: Most NumPy functions can be called directly on [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    is not intended to be a drop-in replacement for ndarray as its indexing semantics
    and data model are quite different in places from an n-dimensional array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`, which allows it to work with NumPy’s [universal
    functions](https://numpy.org/doc/stable/reference/ufuncs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The ufunc is applied to the underlying array in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: When multiple [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    are passed to a ufunc, they are aligned before performing the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Like other parts of the library, pandas will automatically align labeled inputs
    as part of a ufunc with multiple inputs. For example, using `numpy.remainder()`
    on two [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with differently ordered labels will align before the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the union of the two indices is taken, and non-overlapping values
    are filled with missing values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When a binary ufunc is applied to a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"), the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") implementation takes precedence and a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: NumPy ufuncs are safe to apply to [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") backed by non-ndarray arrays, for example [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") (see [Sparse calculation](sparse.html#sparse-calculation)).
    If possible, the ufunc is applied without converting the underlying data to an
    ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Console display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very large [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") will be truncated to display them in the console. You can
    also get a summary using [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"). (The **baseball** dataset is from the **plyr** R package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using [`DataFrame.to_string()`](../reference/api/pandas.DataFrame.to_string.html#pandas.DataFrame.to_string
    "pandas.DataFrame.to_string") will return a string representation of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") in tabular form, though it won’t always fit the console width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Wide DataFrames will be printed across multiple rows by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change how much to print on a single row by setting the `display.width`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust the max width of the individual columns by setting `display.max_colwidth`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: You can also disable this feature via the `expand_frame_repr` option. This will
    print the table in one block.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame column attribute access and IPython completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") column label is a valid Python variable name, the column can
    be accessed like an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns are also connected to the [IPython](https://ipython.org) completion
    mechanism so they can be tab-completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: From dict of Series or dicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resulting **index** will be the **union** of the indexes of the various
    Series. If there are any nested dicts, these will first be converted to Series.
    If no columns are passed, the columns will be the ordered list of dict keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The row and column labels can be accessed respectively by accessing the **index**
    and **columns** attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When a particular set of columns is passed along with a dict of data, the passed
    columns override the keys in the dict.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: From dict of ndarrays / lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All ndarrays must share the same length. If an index is passed, it must also
    be the same length as the arrays. If no index is passed, the result will be `range(n)`,
    where `n` is the array length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: From structured or record array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This case is handled identically to a dict of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame is not intended to work exactly like a 2-dimensional NumPy ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '### From a list of dicts'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '### From a dict of tuples'
  prefs: []
  type: TYPE_NORMAL
- en: You can automatically create a MultiIndexed frame by passing a tuples dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '### From a Series'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be a DataFrame with the same index as the input Series, and
    with one column whose name is the original name of the Series (only if no other
    column name provided).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '### From a list of namedtuples'
  prefs: []
  type: TYPE_NORMAL
- en: The field names of the first `namedtuple` in the list determine the columns
    of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame").
    The remaining namedtuples (or tuples) are simply unpacked and their values are
    fed into the rows of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). If any of those tuples is shorter than the first `namedtuple`
    then the later columns in the corresponding row are marked as missing values.
    If any are longer than the first `namedtuple`, a `ValueError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '### From a list of dataclasses'
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes as introduced in [PEP557](https://www.python.org/dev/peps/pep-0557),
    can be passed into the DataFrame constructor. Passing a list of dataclasses is
    equivalent to passing a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware, that all values in the list should be dataclasses, mixing types
    in the list would result in a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '**Missing data**'
  prefs: []
  type: TYPE_NORMAL
- en: To construct a DataFrame with missing data, we use `np.nan` to represent missing
    values. Alternatively, you may pass a `numpy.MaskedArray` as the data argument
    to the DataFrame constructor, and its masked entries will be considered missing.
    See [Missing data](missing_data.html#missing-data) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**DataFrame.from_dict**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_dict()`](../reference/api/pandas.DataFrame.from_dict.html#pandas.DataFrame.from_dict
    "pandas.DataFrame.from_dict") takes a dict of dicts or a dict of array-like sequences
    and returns a DataFrame. It operates like the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor except for the `orient` parameter which is `''columns''`
    by default, but which can be set to `''index''` in order to use the dict keys
    as row labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass `orient=''index''`, the keys will be the row labels. In this case,
    you can also pass the desired column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '**DataFrame.from_records**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.from_records()`](../reference/api/pandas.DataFrame.from_records.html#pandas.DataFrame.from_records
    "pandas.DataFrame.from_records") takes a list of tuples or an ndarray with structured
    dtype. It works analogously to the normal [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") constructor, except that the resulting DataFrame index may
    be a specific field of the structured dtype.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '### Column selection, addition, deletion'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") semantically like a dict of like-indexed [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") objects. Getting, setting, and deleting columns works with the
    same syntax as the analogous dict operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Columns can be deleted or popped like with a dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a scalar value, it will naturally be propagated to fill the
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") that does not have the same index as the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), it will be conformed to the DataFrame’s index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: You can insert raw ndarrays but their length must match the length of the DataFrame’s
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, columns get inserted at the end. [`DataFrame.insert()`](../reference/api/pandas.DataFrame.insert.html#pandas.DataFrame.insert
    "pandas.DataFrame.insert") inserts at a particular location in the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '### Assigning new columns in method chains'
  prefs: []
  type: TYPE_NORMAL
- en: Inspired by [dplyr’s](https://dplyr.tidyverse.org/reference/mutate.html) `mutate`
    verb, DataFrame has an [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method that allows you to easily create new columns
    that are potentially derived from existing columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, we inserted a precomputed value. We can also pass in a
    function of one argument to be evaluated on the DataFrame being assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") **always** returns a copy of the data, leaving the
    original DataFrame untouched.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a callable, as opposed to an actual value to be inserted, is useful
    when you don’t have a reference to the DataFrame at hand. This is common when
    using [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") in a chain of operations. For example, we can limit
    the DataFrame to just those observations with a Sepal Length greater than 5, calculate
    the ratio, and plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/basics_assign.png](../Images/67b8f4ee2abe121d27a77929ee9748b4.png)'
  prefs: []
  type: TYPE_IMG
- en: Since a function is passed in, the function is computed on the DataFrame being
    assigned to. Importantly, this is the DataFrame that’s been filtered to those
    rows with sepal length greater than 5\. The filtering happens first, and then
    the ratio calculations. This is an example where we didn’t have a reference to
    the *filtered* DataFrame available.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature for [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") is simply `**kwargs`. The keys are the column names
    for the new fields, and the values are either a value to be inserted (for example,
    a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or NumPy array), or a function of one argument to be called on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). A *copy* of the original [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is returned, with the new values inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The order of `**kwargs` is preserved. This allows for *dependent* assignment,
    where an expression later in `**kwargs` can refer to a column created earlier
    in the same [`assign()`](../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: In the second expression, `x['C']` will refer to the newly created column, that’s
    equal to `dfa['A'] + dfa['B']`.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing / selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basics of indexing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Syntax | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Select column | `df[col]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by label | `df.loc[label]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Select row by integer location | `df.iloc[loc]` | Series |'
  prefs: []
  type: TYPE_TB
- en: '| Slice rows | `df[5:10]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: '| Select rows by boolean vector | `df[bool_vec]` | DataFrame |'
  prefs: []
  type: TYPE_TB
- en: 'Row selection, for example, returns a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") whose index is the columns of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: For a more exhaustive treatment of sophisticated label-based indexing and slicing,
    see the [section on indexing](indexing.html#indexing). We will address the fundamentals
    of reindexing / conforming to new sets of labels in the [section on reindexing](basics.html#basics-reindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '### Data alignment and arithmetic'
  prefs: []
  type: TYPE_NORMAL
- en: Data alignment between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects automatically align on **both the columns and the
    index (row labels)**. Again, the resulting object will have the union of the column
    and row labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'When doing an operation between [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") and [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), the default behavior is to align the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") **index** on the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") **columns**, thus [broadcasting](https://numpy.org/doc/stable/user/basics.broadcasting.html)
    row-wise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: For explicit control over the matching and broadcasting behavior, see the section
    on [flexible binary operations](basics.html#basics-binop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operations with scalars operate element-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean operators operate element-wise as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Transposing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To transpose, access the `T` attribute or [`DataFrame.transpose()`](../reference/api/pandas.DataFrame.transpose.html#pandas.DataFrame.transpose
    "pandas.DataFrame.transpose"), similar to an ndarray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '### DataFrame interoperability with NumPy functions'
  prefs: []
  type: TYPE_NORMAL
- en: Most NumPy functions can be called directly on [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    is not intended to be a drop-in replacement for ndarray as its indexing semantics
    and data model are quite different in places from an n-dimensional array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`, which allows it to work with NumPy’s [universal
    functions](https://numpy.org/doc/stable/reference/ufuncs.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The ufunc is applied to the underlying array in a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: When multiple [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    are passed to a ufunc, they are aligned before performing the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Like other parts of the library, pandas will automatically align labeled inputs
    as part of a ufunc with multiple inputs. For example, using `numpy.remainder()`
    on two [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with differently ordered labels will align before the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the union of the two indices is taken, and non-overlapping values
    are filled with missing values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: When a binary ufunc is applied to a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"), the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") implementation takes precedence and a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: NumPy ufuncs are safe to apply to [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") backed by non-ndarray arrays, for example [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") (see [Sparse calculation](sparse.html#sparse-calculation)).
    If possible, the ufunc is applied without converting the underlying data to an
    ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Console display
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A very large [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") will be truncated to display them in the console. You can
    also get a summary using [`info()`](../reference/api/pandas.DataFrame.info.html#pandas.DataFrame.info
    "pandas.DataFrame.info"). (The **baseball** dataset is from the **plyr** R package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using [`DataFrame.to_string()`](../reference/api/pandas.DataFrame.to_string.html#pandas.DataFrame.to_string
    "pandas.DataFrame.to_string") will return a string representation of the [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") in tabular form, though it won’t always fit the console width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Wide DataFrames will be printed across multiple rows by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change how much to print on a single row by setting the `display.width`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: You can adjust the max width of the individual columns by setting `display.max_colwidth`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: You can also disable this feature via the `expand_frame_repr` option. This will
    print the table in one block.
  prefs: []
  type: TYPE_NORMAL
- en: DataFrame column attribute access and IPython completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") column label is a valid Python variable name, the column can
    be accessed like an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The columns are also connected to the [IPython](https://ipython.org) completion
    mechanism so they can be tab-completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
