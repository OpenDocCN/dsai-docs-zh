["```py\nclass sympy.diffgeom.Manifold(name, dim, **kwargs)\n```", "```py\n>>> from sympy.diffgeom import Manifold\n>>> m = Manifold('M', 2)\n>>> m\nM\n>>> m.dim\n2 \n```", "```py\nclass sympy.diffgeom.Patch(name, manifold, **kwargs)\n```", "```py\n>>> from sympy.diffgeom import Manifold, Patch\n>>> m = Manifold('M', 2)\n>>> p = Patch('P', m)\n>>> p\nP\n>>> p.dim\n2 \n```", "```py\nclass sympy.diffgeom.CoordSystem(name, patch, symbols=None, relations={}, **kwargs)\n```", "```py\n>>> from sympy import symbols, pi, sqrt, atan2, cos, sin\n>>> from sympy.diffgeom import Manifold, Patch, CoordSystem\n>>> m = Manifold('M', 2)\n>>> p = Patch('P', m)\n>>> x, y = symbols('x y', real=True)\n>>> r, theta = symbols('r theta', nonnegative=True)\n>>> relation_dict = {\n... ('Car2D', 'Pol'): [(x, y), (sqrt(x**2 + y**2), atan2(y, x))],\n... ('Pol', 'Car2D'): [(r, theta), (r*cos(theta), r*sin(theta))]\n... }\n>>> Car2D = CoordSystem('Car2D', p, (x, y), relation_dict)\n>>> Pol = CoordSystem('Pol', p, (r, theta), relation_dict) \n```", "```py\n>>> Car2D\nCar2D\n>>> Car2D.dim\n2\n>>> Car2D.symbols\n(x, y)\n>>> _[0].func\n<class 'sympy.diffgeom.diffgeom.CoordinateSymbol'> \n```", "```py\n>>> Car2D.transformation(Pol)\nLambda((x, y), Matrix([\n[sqrt(x**2 + y**2)],\n[      atan2(y, x)]]))\n>>> Car2D.transform(Pol)\nMatrix([\n[sqrt(x**2 + y**2)],\n[      atan2(y, x)]])\n>>> Car2D.transform(Pol, [1, 2])\nMatrix([\n[sqrt(5)],\n[atan(2)]]) \n```", "```py\n>>> Pol.jacobian(Car2D)\nMatrix([\n[cos(theta), -r*sin(theta)],\n[sin(theta),  r*cos(theta)]])\n>>> Pol.jacobian(Car2D, [1, pi/2])\nMatrix([\n[0, -1],\n[1,  0]])\n>>> Car2D.jacobian_determinant(Pol)\n1/sqrt(x**2 + y**2)\n>>> Car2D.jacobian_determinant(Pol, [1,0])\n1 \n```", "```py\nbase_oneform(coord_index)\n```", "```py\nbase_oneforms()\n```", "```py\nbase_scalar(coord_index)\n```", "```py\nbase_scalars()\n```", "```py\nbase_vector(coord_index)\n```", "```py\nbase_vectors()\n```", "```py\ncoord_function(coord_index)\n```", "```py\ncoord_functions()\n```", "```py\ncoord_tuple_transform_to(to_sys, coords)\n```", "```py\njacobian(sys, coordinates=None)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> R2_p.jacobian(R2_r)\nMatrix([\n[cos(theta), -rho*sin(theta)],\n[sin(theta),  rho*cos(theta)]])\n>>> R2_p.jacobian(R2_r, [1, 0])\nMatrix([\n[1, 0],\n[0, 1]]) \n```", "```py\njacobian_determinant(sys, coordinates=None)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> R2_r.jacobian_determinant(R2_p)\n1/sqrt(x**2 + y**2)\n>>> R2_r.jacobian_determinant(R2_p, [1, 0])\n1 \n```", "```py\njacobian_matrix(sys, coordinates=None)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> R2_p.jacobian(R2_r)\nMatrix([\n[cos(theta), -rho*sin(theta)],\n[sin(theta),  rho*cos(theta)]])\n>>> R2_p.jacobian(R2_r, [1, 0])\nMatrix([\n[1, 0],\n[0, 1]]) \n```", "```py\npoint(coords)\n```", "```py\npoint_to_coords(point)\n```", "```py\ntransform(sys, coordinates=None)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> R2_r.transform(R2_p)\nMatrix([\n[sqrt(x**2 + y**2)],\n[      atan2(y, x)]])\n>>> R2_r.transform(R2_p, [0, 1])\nMatrix([\n[   1],\n[pi/2]]) \n```", "```py\ntransformation(sys)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> R2_r.transformation(R2_p)\nLambda((x, y), Matrix([\n[sqrt(x**2 + y**2)],\n[      atan2(y, x)]])) \n```", "```py\nclass sympy.diffgeom.CoordinateSymbol(coord_sys, index, **assumptions)\n```", "```py\n>>> from sympy import symbols, Lambda, Matrix, sqrt, atan2, cos, sin\n>>> from sympy.diffgeom import Manifold, Patch, CoordSystem\n>>> m = Manifold('M', 2)\n>>> p = Patch('P', m)\n>>> x, y = symbols('x y', real=True)\n>>> r, theta = symbols('r theta', nonnegative=True)\n>>> relation_dict = {\n... ('Car2D', 'Pol'): Lambda((x, y), Matrix([sqrt(x**2 + y**2), atan2(y, x)])),\n... ('Pol', 'Car2D'): Lambda((r, theta), Matrix([r*cos(theta), r*sin(theta)]))\n... }\n>>> Car2D = CoordSystem('Car2D', p, [x, y], relation_dict)\n>>> Pol = CoordSystem('Pol', p, [r, theta], relation_dict)\n>>> x, y = Car2D.symbols \n```", "```py\n>>> x.name\n'x'\n>>> x.coord_sys == Car2D\nTrue\n>>> x.index\n0\n>>> x.is_real\nTrue \n```", "```py\n>>> x.rewrite(Pol)\nr*cos(theta)\n>>> sqrt(x**2 + y**2).rewrite(Pol).simplify()\nr \n```", "```py\nclass sympy.diffgeom.Point(coord_sys, coords, **kwargs)\n```", "```py\n>>> from sympy import pi\n>>> from sympy.diffgeom import Point\n>>> from sympy.diffgeom.rn import R2, R2_r, R2_p\n>>> rho, theta = R2_p.symbols \n```", "```py\n>>> p = Point(R2_p, [rho, 3*pi/4]) \n```", "```py\n>>> p.manifold == R2\nTrue \n```", "```py\n>>> p.coords()\nMatrix([\n[   rho],\n[3*pi/4]])\n>>> p.coords(R2_r)\nMatrix([\n[-sqrt(2)*rho/2],\n[ sqrt(2)*rho/2]]) \n```", "```py\ncoords(sys=None)\n```", "```py\nclass sympy.diffgeom.BaseScalarField(coord_sys, index, **kwargs)\n```", "```py\n>>> from sympy import Function, pi\n>>> from sympy.diffgeom import BaseScalarField\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> rho, _ = R2_p.symbols\n>>> point = R2_p.point([rho, 0])\n>>> fx, fy = R2_r.base_scalars()\n>>> ftheta = BaseScalarField(R2_r, 1) \n```", "```py\n>>> fx(point)\nrho\n>>> fy(point)\n0 \n```", "```py\n>>> (fx**2+fy**2).rcall(point)\nrho**2 \n```", "```py\n>>> g = Function('g')\n>>> fg = g(ftheta-pi)\n>>> fg.rcall(point)\ng(-pi) \n```", "```py\nclass sympy.diffgeom.BaseVectorField(coord_sys, index, **kwargs)\n```", "```py\n>>> from sympy import Function\n>>> from sympy.diffgeom.rn import R2_p, R2_r\n>>> from sympy.diffgeom import BaseVectorField\n>>> from sympy import pprint \n```", "```py\n>>> x, y = R2_r.symbols\n>>> rho, theta = R2_p.symbols\n>>> fx, fy = R2_r.base_scalars()\n>>> point_p = R2_p.point([rho, theta])\n>>> point_r = R2_r.point([x, y]) \n```", "```py\n>>> g = Function('g')\n>>> s_field = g(fx, fy) \n```", "```py\n>>> v = BaseVectorField(R2_r, 1)\n>>> pprint(v(s_field))\n/ d           \\|\n|---(g(x, xi))||\n\\dxi          /|xi=y\n>>> pprint(v(s_field).rcall(point_r).doit())\nd\n--(g(x, y))\ndy\n>>> pprint(v(s_field).rcall(point_p))\n/ d                        \\|\n|---(g(rho*cos(theta), xi))||\n\\dxi                       /|xi=rho*sin(theta) \n```", "```py\nclass sympy.diffgeom.Commutator(v1, v2)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_p, R2_r\n>>> from sympy.diffgeom import Commutator\n>>> from sympy import simplify \n```", "```py\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> e_r = R2_p.base_vector(0) \n```", "```py\n>>> c_xy = Commutator(e_x, e_y)\n>>> c_xr = Commutator(e_x, e_r)\n>>> c_xy\n0 \n```", "```py\n>>> c_xr\nCommutator(e_x, e_rho)\n>>> simplify(c_xr(fy**2))\n-2*cos(theta)*y**2/(x**2 + y**2) \n```", "```py\nclass sympy.diffgeom.Differential(form_field)\n```", "```py\n>>> from sympy import Function\n>>> from sympy.diffgeom.rn import R2_r\n>>> from sympy.diffgeom import Differential\n>>> from sympy import pprint \n```", "```py\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> g = Function('g')\n>>> s_field = g(fx, fy)\n>>> dg = Differential(s_field) \n```", "```py\n>>> dg\nd(g(x, y))\n>>> pprint(dg(e_x))\n/ d           \\|\n|---(g(xi, y))||\n\\dxi          /|xi=x\n>>> pprint(dg(e_y))\n/ d           \\|\n|---(g(x, xi))||\n\\dxi          /|xi=y \n```", "```py\n>>> Differential(dg)\n0 \n```", "```py\nclass sympy.diffgeom.TensorProduct(*args)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r\n>>> from sympy.diffgeom import TensorProduct \n```", "```py\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> dx, dy = R2_r.base_oneforms() \n```", "```py\n>>> TensorProduct(dx, dy)(e_x, e_y)\n1\n>>> TensorProduct(dx, dy)(e_y, e_x)\n0\n>>> TensorProduct(dx, fx*dy)(fx*e_x, e_y)\nx**2\n>>> TensorProduct(e_x, e_y)(fx**2, fy**2)\n4*x*y\n>>> TensorProduct(e_y, dx)(fy)\ndx \n```", "```py\n>>> tp1 = TensorProduct(dx, dy)\n>>> TensorProduct(tp1, dx)(e_x, e_y, e_x)\n1 \n```", "```py\n>>> TP = TensorProduct\n>>> metric = TP(dx, dx) + 3*TP(dy, dy)\n>>> metric.rcall(e_y, None)\n3*dy \n```", "```py\n>>> metric.rcall(e_y)\n3*dy \n```", "```py\nclass sympy.diffgeom.WedgeProduct(*args)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r\n>>> from sympy.diffgeom import WedgeProduct \n```", "```py\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> dx, dy = R2_r.base_oneforms() \n```", "```py\n>>> WedgeProduct(dx, dy)(e_x, e_y)\n1\n>>> WedgeProduct(dx, dy)(e_y, e_x)\n-1\n>>> WedgeProduct(dx, fx*dy)(fx*e_x, e_y)\nx**2\n>>> WedgeProduct(e_x, e_y)(fy, None)\n-e_x \n```", "```py\n>>> wp1 = WedgeProduct(dx, dy)\n>>> WedgeProduct(wp1, dx)(e_x, e_y, e_x)\n0 \n```", "```py\nclass sympy.diffgeom.LieDerivative(v_field, expr)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r, R2_p\n>>> from sympy.diffgeom import (LieDerivative, TensorProduct) \n```", "```py\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> e_rho, e_theta = R2_p.base_vectors()\n>>> dx, dy = R2_r.base_oneforms() \n```", "```py\n>>> LieDerivative(e_x, fy)\n0\n>>> LieDerivative(e_x, fx)\n1\n>>> LieDerivative(e_x, e_x)\n0 \n```", "```py\n>>> LieDerivative(e_x, e_rho)\nCommutator(e_x, e_rho)\n>>> LieDerivative(e_x + e_y, fx)\n1 \n```", "```py\n>>> tp = TensorProduct(dx, dy)\n>>> LieDerivative(e_x, tp)\nLieDerivative(e_x, TensorProduct(dx, dy))\n>>> LieDerivative(e_x, tp)\nLieDerivative(e_x, TensorProduct(dx, dy)) \n```", "```py\nclass sympy.diffgeom.BaseCovarDerivativeOp(coord_sys, index, christoffel)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r\n>>> from sympy.diffgeom import BaseCovarDerivativeOp\n>>> from sympy.diffgeom import metric_to_Christoffel_2nd, TensorProduct \n```", "```py\n>>> TP = TensorProduct\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> dx, dy = R2_r.base_oneforms() \n```", "```py\n>>> ch = metric_to_Christoffel_2nd(TP(dx, dx) + TP(dy, dy))\n>>> ch\n[[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n>>> cvd = BaseCovarDerivativeOp(R2_r, 0, ch)\n>>> cvd(fx)\n1\n>>> cvd(fx*e_x)\ne_x \n```", "```py\nclass sympy.diffgeom.CovarDerivativeOp(wrt, christoffel)\n```", "```py\n>>> from sympy.diffgeom.rn import R2_r\n>>> from sympy.diffgeom import CovarDerivativeOp\n>>> from sympy.diffgeom import metric_to_Christoffel_2nd, TensorProduct\n>>> TP = TensorProduct\n>>> fx, fy = R2_r.base_scalars()\n>>> e_x, e_y = R2_r.base_vectors()\n>>> dx, dy = R2_r.base_oneforms()\n>>> ch = metric_to_Christoffel_2nd(TP(dx, dx) + TP(dy, dy)) \n```", "```py\n>>> ch\n[[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n>>> cvd = CovarDerivativeOp(fx*e_x, ch)\n>>> cvd(fx)\nx\n>>> cvd(fx*e_x)\nx*e_x \n```", "```py\nsympy.diffgeom.intcurve_series(vector_field, param, start_point, n=6, coord_sys=None, coeffs=False)\n```", "```py\n>>> from sympy.abc import t, x, y\n>>> from sympy.diffgeom.rn import R2_p, R2_r\n>>> from sympy.diffgeom import intcurve_series \n```", "```py\n>>> start_point = R2_r.point([x, y])\n>>> vector_field = R2_r.e_x \n```", "```py\n>>> intcurve_series(vector_field, t, start_point, n=3)\nMatrix([\n[t + x],\n[    y]]) \n```", "```py\n>>> series = intcurve_series(vector_field, t, start_point, n=3, coeffs=True)\n>>> series[0]\nMatrix([\n[x],\n[y]])\n>>> series[1]\nMatrix([\n[t],\n[0]])\n>>> series[2]\nMatrix([\n[0],\n[0]]) \n```", "```py\n>>> series = intcurve_series(vector_field, t, start_point,\n...             n=3, coord_sys=R2_p, coeffs=True)\n>>> series[0]\nMatrix([\n[sqrt(x**2 + y**2)],\n[      atan2(y, x)]])\n>>> series[1]\nMatrix([\n[t*x/sqrt(x**2 + y**2)],\n[   -t*y/(x**2 + y**2)]])\n>>> series[2]\nMatrix([\n[t**2*(-x**2/(x**2 + y**2)**(3/2) + 1/sqrt(x**2 + y**2))/2],\n[                                t**2*x*y/(x**2 + y**2)**2]]) \n```", "```py\nsympy.diffgeom.intcurve_diffequ(vector_field, param, start_point, coord_sys=None)\n```", "```py\n>>> from sympy.abc import t\n>>> from sympy.diffgeom.rn import R2, R2_p, R2_r\n>>> from sympy.diffgeom import intcurve_diffequ \n```", "```py\n>>> start_point = R2_r.point([0, 1])\n>>> vector_field = -R2.y*R2.e_x + R2.x*R2.e_y \n```", "```py\n>>> equations, init_cond = intcurve_diffequ(vector_field, t, start_point)\n>>> equations\n[f_1(t) + Derivative(f_0(t), t), -f_0(t) + Derivative(f_1(t), t)]\n>>> init_cond\n[f_0(0), f_1(0) - 1] \n```", "```py\n>>> equations, init_cond = intcurve_diffequ(vector_field, t, start_point, R2_p)\n>>> equations\n[Derivative(f_0(t), t), Derivative(f_1(t), t) - 1]\n>>> init_cond\n[f_0(0) - 1, f_1(0) - pi/2] \n```", "```py\nsympy.diffgeom.vectors_in_basis(expr, to_sys)\n```", "```py\n>>> from sympy.diffgeom import vectors_in_basis\n>>> from sympy.diffgeom.rn import R2_r, R2_p \n```", "```py\n>>> vectors_in_basis(R2_r.e_x, R2_p)\n-y*e_theta/(x**2 + y**2) + x*e_rho/sqrt(x**2 + y**2)\n>>> vectors_in_basis(R2_p.e_r, R2_r)\nsin(theta)*e_y + cos(theta)*e_x \n```", "```py\nsympy.diffgeom.twoform_to_matrix(expr)\n```", "```py\n>>> from sympy.diffgeom.rn import R2\n>>> from sympy.diffgeom import twoform_to_matrix, TensorProduct\n>>> TP = TensorProduct \n```", "```py\n>>> twoform_to_matrix(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\nMatrix([\n[1, 0],\n[0, 1]])\n>>> twoform_to_matrix(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\nMatrix([\n[x, 0],\n[0, 1]])\n>>> twoform_to_matrix(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy) - TP(R2.dx, R2.dy)/2)\nMatrix([\n[   1, 0],\n[-1/2, 1]]) \n```", "```py\nsympy.diffgeom.metric_to_Christoffel_1st(expr)\n```", "```py\n>>> from sympy.diffgeom.rn import R2\n>>> from sympy.diffgeom import metric_to_Christoffel_1st, TensorProduct\n>>> TP = TensorProduct \n```", "```py\n>>> metric_to_Christoffel_1st(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n>>> metric_to_Christoffel_1st(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[[1/2, 0], [0, 0]], [[0, 0], [0, 0]]] \n```", "```py\nsympy.diffgeom.metric_to_Christoffel_2nd(expr)\n```", "```py\n>>> from sympy.diffgeom.rn import R2\n>>> from sympy.diffgeom import metric_to_Christoffel_2nd, TensorProduct\n>>> TP = TensorProduct \n```", "```py\n>>> metric_to_Christoffel_2nd(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[[0, 0], [0, 0]], [[0, 0], [0, 0]]]\n>>> metric_to_Christoffel_2nd(R2.x*TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[[1/(2*x), 0], [0, 0]], [[0, 0], [0, 0]]] \n```", "```py\nsympy.diffgeom.metric_to_Riemann_components(expr)\n```", "```py\n>>> from sympy import exp\n>>> from sympy.diffgeom.rn import R2\n>>> from sympy.diffgeom import metric_to_Riemann_components, TensorProduct\n>>> TP = TensorProduct \n```", "```py\n>>> metric_to_Riemann_components(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[[[0, 0], [0, 0]], [[0, 0], [0, 0]]], [[[0, 0], [0, 0]], [[0, 0], [0, 0]]]]\n>>> non_trivial_metric = exp(2*R2.r)*TP(R2.dr, R2.dr) +         R2.r**2*TP(R2.dtheta, R2.dtheta)\n>>> non_trivial_metric\nexp(2*rho)*TensorProduct(drho, drho) + rho**2*TensorProduct(dtheta, dtheta)\n>>> riemann = metric_to_Riemann_components(non_trivial_metric)\n>>> riemann[0, :, :, :]\n[[[0, 0], [0, 0]], [[0, exp(-2*rho)*rho], [-exp(-2*rho)*rho, 0]]]\n>>> riemann[1, :, :, :]\n[[[0, -1/rho], [1/rho, 0]], [[0, 0], [0, 0]]] \n```", "```py\nsympy.diffgeom.metric_to_Ricci_components(expr)\n```", "```py\n>>> from sympy import exp\n>>> from sympy.diffgeom.rn import R2\n>>> from sympy.diffgeom import metric_to_Ricci_components, TensorProduct\n>>> TP = TensorProduct \n```", "```py\n>>> metric_to_Ricci_components(TP(R2.dx, R2.dx) + TP(R2.dy, R2.dy))\n[[0, 0], [0, 0]]\n>>> non_trivial_metric = exp(2*R2.r)*TP(R2.dr, R2.dr) +                              R2.r**2*TP(R2.dtheta, R2.dtheta)\n>>> non_trivial_metric\nexp(2*rho)*TensorProduct(drho, drho) + rho**2*TensorProduct(dtheta, dtheta)\n>>> metric_to_Ricci_components(non_trivial_metric)\n[[1/rho, 0], [0, exp(-2*rho)*rho]] \n```"]