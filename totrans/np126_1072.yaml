- en: Array API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/c-api/array.html](https://numpy.org/doc/1.26/reference/c-api/array.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The test of a first-rate intelligence is the ability to hold twoopposed ideas
    in the mind at the same time, and still retain theability to function.— *F. Scott
    Fitzgerald*For a successful technology, reality must take precedence over publicrelations,
    for Nature cannot be fooled.— *Richard P. Feynman* ## Array structure and data
    access'
  prefs: []
  type: TYPE_NORMAL
- en: These macros access the [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") structure members and are defined in `ndarraytypes.h`. The input
    argument, *arr*, can be any [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that is directly interpretable as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")* (any instance of the [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and its sub-types).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The number of dimensions in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Returns an integer representing the [array-flags](#array-flags).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Return the (builtin) typenumber for the elements of this array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Convert obj and place it in the ndarray, *arr*, at the place pointed to by itemptr.
    Return -1 if an error occurs or 0 on success.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Enables the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Clears the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These two macros are similar and obtain the pointer to the data-buffer for the
    array. The first macro can (and should be) assigned to a particular pointer where
    the second is for generic processing. If you have not guaranteed a contiguous
    and/or aligned array then be sure you understand how to access the data in the
    array to avoid memory and/or alignment problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the dimensions/shape of the array. The number of elements
    matches the number of dimensions of the array. Can return `NULL` for 0-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS"), named to be
    consistent with the [`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape") usage within Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the strides of the array. The number of elements matches
    the number of dimensions of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Return the shape in the *n* \(^{\textrm{th}}\) dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Return the stride in the *n* \(^{\textrm{th}}\) dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Return the itemsize for the elements of this array.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the old API that was deprecated in version 1.7, this function
    had the return type `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Returns the total size (in number of elements) of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Returns 0 if *obj* is not a sub-class of ndarray. Otherwise, returns the total
    number of elements in the array. Safer version of [`PyArray_SIZE`](#c.PyArray_SIZE
    "PyArray_SIZE") (*obj*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Returns the total number of bytes consumed by the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This returns the base object of the array. In most cases, this means the object
    which owns the memory the array is pointing at.
  prefs: []
  type: TYPE_NORMAL
- en: If you are constructing an array using the C API, and specifying your own memory,
    you should use the function [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject") to set the base to an object which owns the memory.
  prefs: []
  type: TYPE_NORMAL
- en: If the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag is set, it has a different meaning, namely base is the array into which the
    current array will be copied upon copy resolution. This overloading of the base
    property for two functions is likely to change in a future version of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Returns a borrowed reference to the dtype property of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for PyArray_DESCR, named to be consistent with the ‘dtype’ usage within
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Get a Python object of a builtin type from the ndarray, *arr*, at the location
    pointed to by itemptr. Return `NULL` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item") is identical to PyArray_GETITEM.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The function pointed to by the [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__"). The first argument is the newly created sub-type.
    The second argument (if not NULL) is the “parent” array (if the array was created
    using slicing or some other operation where a clearly-distinguishable parent is
    present). This routine can do anything it wants to. It should return a -1 on error
    and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Data access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  prefs: []
  type: TYPE_NORMAL
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  prefs: []
  type: TYPE_NORMAL
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: If *descr* is NULL, the data type of *prototype* is used.
  prefs: []
  type: TYPE_NORMAL
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  prefs: []
  type: TYPE_NORMAL
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is 0 on success, -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  prefs: []
  type: TYPE_NORMAL
- en: From other objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is C-style contiguous
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has strides that are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: General check of Python Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Data-type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an unsigned integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a signed integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer, floating point, or complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a string data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.18.
  prefs: []
  type: TYPE_NORMAL
- en: For structured datatypes with no fields this function now returns False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Type is either flexible or user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Type represents object data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Type represents Boolean data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Type has fields associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  prefs: []
  type: TYPE_NORMAL
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  prefs: []
  type: TYPE_NORMAL
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: User-defined data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Initialize all function pointers and members to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  prefs: []
  type: TYPE_NORMAL
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  prefs: []
  type: TYPE_NORMAL
- en: Special functions for NPY_OBJECT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 for success, -1 for failure.
  prefs: []
  type: TYPE_NORMAL
- en: '## Array flags'
  prefs: []
  type: TYPE_NORMAL
- en: The `flags` attribute of the `PyArrayObject` structure contains important information
    about the memory used by the array (pointed to by the data member) This flag information
    must be kept accurate or strange results and even segfaults may result.
  prefs: []
  type: TYPE_NORMAL
- en: There are 6 (binary) flags that describe the memory area used by the data buffer.
    These constants are defined in `arrayobject.h` and determine the bit-position
    of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like
    interface for getting (and, if appropriate, setting) these flags.
  prefs: []
  type: TYPE_NORMAL
- en: Memory areas of all kinds can be pointed to by an ndarray, necessitating these
    flags. If you get an arbitrary `PyArrayObject` in C-code, you need to be aware
    of the flags that are set. If you need to guarantee a certain kind of array (like
    [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    and [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")), then pass
    these requirements into the PyArray_FromAny function.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Array Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in C-style contiguous order (last index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The data area and all array elements are aligned appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The data area can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  prefs: []
  type: TYPE_NORMAL
- en: Combinations of array flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: Flag-like constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Cast to the desired type, even if it can’t be done without losing information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting array is a copy of the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: Flag checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* can be written to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  prefs: []
  type: TYPE_NORMAL
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  prefs: []
  type: TYPE_NORMAL
- en: Array method alternative API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  prefs: []
  type: TYPE_NORMAL
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Shape Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Item selection and manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: raise a ValueError;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: all values are clipped to the region [0, len(*op*) ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  prefs: []
  type: TYPE_NORMAL
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Counts the number of non-zero elements in the array object *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  prefs: []
  type: TYPE_NORMAL
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute z as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary Data With Object Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: When working with more complex dtypes which are composed of other dtypes, such
    as the struct dtype, creating inner loops that manipulate the dtypes requires
    carrying along additional data. NumPy supports this idea through a struct [`NpyAuxData`](#c.NpyAuxData
    "NpyAuxData"), mandating a few conventions so that it is possible to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an [`NpyAuxData`](#c.NpyAuxData "NpyAuxData") is similar to defining
    a class in C++, but the object semantics have to be tracked manually since the
    API is in C. Here’s an example for a function which doubles up an element using
    an element copier function as a primitive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The function pointer type for NpyAuxData free functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: The function pointer type for NpyAuxData clone functions. These functions should
    never set the Python exception on error, because they may be called from a multi-threaded
    context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: A macro which calls the auxdata’s free function appropriately, does nothing
    if auxdata is NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: A macro which calls the auxdata’s clone function appropriately, returning a
    deep copy of the auxiliary data.
  prefs: []
  type: TYPE_NORMAL
- en: Array Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of NumPy 1.6.0, these array iterators are superseded by the new array iterator,
    [`NpyIter`](iterator.html#c.NpyIter "NpyIter").
  prefs: []
  type: TYPE_NORMAL
- en: An array iterator is a simple way to access the elements of an N-dimensional
    array quickly and efficiently, as seen in [the example](iterator.html#iteration-example)
    which provides more description of this useful approach to looping over an array
    from C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator object from the array, *arr*. This is equivalent to
    *arr*. **flat**. The array iterator object makes it easy to loop over an N-dimensional
    non-contiguous array in C-style contiguous fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator that will iterate over all axes but the one provided
    in **axis*. The returned iterator cannot be used with [`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D"). This iterator could be used to write something similar
    to what ufuncs do wherein the loop over the largest axis is done by a separate
    sub-routine. If **axis* is negative then **axis* will be set to the axis having
    the smallest stride and that axis will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator that is broadcast to iterate as an array of the shape
    provided by *dimensions* and *nd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an array iterator (or instance of a subclass of the
    array iterator type).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Reset an *iterator* to the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Incremement the index and the dataptr members of the *iterator* to point to
    the next element of the array. If the array is not (C-style) contiguous, also
    increment the N-dimensional coordinates array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to the current element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Set the *iterator* index, dataptr, and coordinates members to the location in
    the array indicated by the N-dimensional c-array, *destination*, which must have
    size at least *iterator* ->nd_m1+1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Set the *iterator* index and dataptr to the location in the array indicated
    by the integer *index* which points to an element in the C-styled flattened array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates TRUE as long as the iterator has not looped through all of the elements,
    otherwise it evaluates FALSE.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting (multi-iterators)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: A simplified interface to broadcasting. This function takes the number of arrays
    to broadcast and then *num* extra ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)") ) arguments. These arguments are converted to arrays and
    iterators are created. [`PyArray_Broadcast`](#c.PyArray_Broadcast "PyArray_Broadcast")
    is then called on the resulting multi-iterator object. The resulting, broadcasted
    mult-iterator object is then returned. A broadcasted operation can then be performed
    using a single loop and using [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Reset all the iterators to the beginning in a multi-iterator object, *multi*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to its next (broadcasted)
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Return the data-pointer of the *i* \(^{\textrm{th}}\) iterator in a multi-iterator
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Advance the pointer of only the *i* \(^{\textrm{th}}\) iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to the given \(N\)
    -dimensional *destination* where \(N\) is the number of dimensions in the broadcasted
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to the corresponding
    location of the *index* into the flattened broadcasted array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates TRUE as long as the multi-iterator has not looped through all of the
    elements (of the broadcasted result), otherwise it evaluates FALSE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This function encapsulates the broadcasting rules. The *mit* container should
    already contain iterators for all the arrays that need to be broadcast. On return,
    these iterators will be adjusted so that iteration over each simultaneously will
    accomplish the broadcasting. A negative number is returned if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a multi-iterator object that has been previously “broadcasted,”
    finds the dimension with the smallest “sum of strides” in the broadcasted result
    and adapts all the iterators so as not to iterate over that dimension (by effectively
    making them of length-1 in that dimension). The corresponding dimension is returned
    unless *mit* ->nd is 0, then -1 is returned. This function is useful for constructing
    ufunc-like routines that broadcast their inputs correctly and then call a strided
    1-d version of the routine as the inner-loop. This 1-d version is usually optimized
    for speed and for this reason the loop should be performed over the axis that
    won’t require large stride jumps.
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood iterators are subclasses of the iterator object, and can be used
    to iter over a neighborhood of a point. For example, you may want to iterate over
    every voxel of a 3d image, and for every such voxel, iterate over an hypercube.
    Neighborhood iterator automatically handle boundaries, thus making this kind of
    code much easier to write than manual boundaries handling, at the cost of a slight
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a new neighborhood iterator from an existing iterator.
    The neighborhood will be computed relatively to the position currently pointed
    by *iter*, the bounds define the shape of the neighborhood iterator, and the mode
    argument the boundaries handling mode.
  prefs: []
  type: TYPE_NORMAL
- en: The *bounds* argument is expected to be a (2 * iter->ao->nd) arrays, such as
    the range bound[2*i]->bounds[2*i+1] defines the range where to walk for dimension
    i (both bounds are included in the walked coordinates). The bounds should be ordered
    for each dimension (bounds[2*i] <= bounds[2*i+1]).
  prefs: []
  type: TYPE_NORMAL
- en: 'The mode should be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Zero padding. Outside bounds values will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: One padding, Outside bounds values will be 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Constant padding. Outside bounds values will be the same as the first item in
    fill_value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Mirror padding. Outside bounds values will be as if the array items were mirrored.
    For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will be 1, x[4]
    will be 4, x[5] will be 1, etc…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Circular padding. Outside bounds values will be as if the array was repeated.
    For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4]
    will be 1, x[5] will be 2, etc…
  prefs: []
  type: TYPE_NORMAL
- en: If the mode is constant filling (*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*),
    fill_value should point to an array object which holds the filling value (the
    first item will be the filling value if the array contains more than one item).
    For other cases, fill_value may be NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator holds a reference to iter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return NULL on failure (in which case the reference count of iter is not changed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iter itself can be a Neighborhood iterator: this can be useful for .e.g automatic
    boundaries handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the object returned by this function should be safe to use as a normal iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next
    is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the position of iter is not the beginning of the data and the underlying
    data for iter is contiguous, the iterator will point to the start of the data
    instead of position pointed by iter. To avoid this situation, iter should be moved
    to the required position only after the creation of iterator, and PyArrayNeighborhoodIter_Reset
    must be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Reset the iterator position to the first point of the neighborhood. This should
    be called whenever the iter argument given at PyArray_NeighborhoodIterObject is
    changed (see example)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: After this call, iter->dataptr points to the next point of the neighborhood.
    Calling this function after every point of the neighborhood has been visited is
    undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Array mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array mapping is the machinery behind advanced indexing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: Use advanced indexing to iterate an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'Swap the axes to or from their inserted form. `MapIter` always puts the advanced
    (array) indices first in the iteration. But if they are consecutive, it will insert/transpose
    them back before returning. This is stored as `mit->consec != 0` (the place where
    they are inserted). For assignments, the opposite happens: the values to be assigned
    are transposed (`getmap=1` instead of `getmap=0`). `getmap=0` and `getmap=1` undo
    the other operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: This function needs to update the state of the map iterator and point `mit->dataptr`
    to the memory-location of the next object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function never handles an extra operand but provides compatibility
    for an old (exposed) API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")
    but with an additional `copy_if_overlap` argument. If `copy_if_overlap != 0`,
    checks if `a` has memory overlap with any of the arrays in `index` and with `extra_op`,
    and make copies as appropriate to avoid problems if the input is modified during
    the iteration. `iter->array` may contain a copied array (WRITEBACKIFCOPY set).
  prefs: []
  type: TYPE_NORMAL
- en: Array Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *arr*.
  prefs: []
  type: TYPE_NORMAL
- en: This function checks to see if *arr* is a 0-dimensional array and, if so, returns
    the appropriate array scalar. It should be used whenever 0-dimensional arrays
    could be returned to Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Return an array scalar object of the given *dtype* by **copying** from memory
    pointed to by *data*. *base* is expected to be the array object that is the owner
    of the data. *base* is required if *dtype* is a `void` scalar, or if the `NPY_USE_GETITEM`
    flag is set and it is known that the `getitem` method uses the `arr` argument
    without checking if it is `NULL`. Otherwise *base* may be `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: If the data is not in native byte order (as indicated by `dtype->byteorder`)
    then this function will byteswap the data, because array scalars are always in
    correct machine-byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Return an array scalar object of the type and itemsize indicated by the array
    object *arr* copied from the memory pointed to by *data* and swapping if the data
    in *arr* is not in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Return a 0-dimensional array of type determined by *outcode* from *scalar* which
    should be an array-scalar object. If *outcode* is NULL, then the type is determined
    from *scalar*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Return in *ctypeptr* a pointer to the actual value in an array scalar. There
    is no error checking so *scalar* must be an array-scalar object, and ctypeptr
    must have enough space to hold the correct type. For flexible-sized types, a pointer
    to the data is copied into the memory of *ctypeptr*, for all other types, the
    actual data is copied into the address pointed to by *ctypeptr*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Return the data (cast to the data type indicated by *outcode*) from the array-scalar,
    *scalar*, into the memory pointed to by *ctypeptr* (which must be large enough
    to handle the incoming memory).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Returns a scalar type-object from a type-number, *type* . Equivalent to [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj except for reference counting and error-checking.
    Returns a new reference to the typeobject on success or `NULL` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: See the function [`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")
    for an alternative mechanism introduced in NumPy 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Return the kind of scalar represented by *typenum* and the array in **arr* (if
    *arr* is not `NULL` ). The array is assumed to be rank-0 and only used if *typenum*
    represents a signed integer. If *arr* is not `NULL` and the first element is negative
    then [`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR "NPY_INTNEG_SCALAR")
    is returned, otherwise [`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR") is returned. The possible return values are the enumerated
    values in [`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: See the function [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")
    for details of NumPy type promotion, updated in NumPy 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Implements the rules for scalar coercion. Scalars are only silently coerced
    from thistype to neededtype if this function returns nonzero. If scalar is [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR"), then this function is equivalent to [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"). The rule is that scalars of the same KIND can be coerced
    into arrays of the same KIND. This rule means that high-precision scalars will
    never cause low-precision arrays of the same KIND to be upcast.
  prefs: []
  type: TYPE_NORMAL
- en: Data-type descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Data-type objects must be reference counted so be aware of the action on the
    data-type reference of different C-API calls. The standard rule is that when a
    data-type object is returned it is a new reference. Functions that take [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* objects and return arrays steal references to the data-type
    their inputs unless otherwise noted. Therefore, you must own a reference to any
    data-type object used as input to such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates as true if *obj* is a data-type object ( [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Return a new data-type object copied from *obj* (the fields reference is just
    updated so that the new object points to the same fields dictionary if any).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Create a new data-type object from the built-in (or user-registered) data-type
    indicated by *typenum*. All builtin types should not have any of their fields
    changed. This creates a new copy of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure so that you can fill it in as appropriate. This function
    is especially needed for flexible data-types which need to have a new elsize member
    in order to be meaningful in array construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Create a new data-type object with the byteorder set according to *newendian*.
    All referenced data-type objects (in subdescr and fields members of the data-type
    object) are also changed (recursively).
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of *newendian* is one of these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: If a byteorder of [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") is encountered
    it is left alone. If newendian is [`NPY_SWAP`](#c.NPY_SWAP "NPY_SWAP"), then all
    byte-orders are swapped. Other valid newendian values are [`NPY_NATIVE`](#c.NPY_NATIVE
    "NPY_NATIVE"), [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"), and [`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG") which all cause the returned data-typed descriptor (and all it’s referenced
    data-type descriptors) to have the corresponding byte- order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: Determine an appropriate data-type object from the object *op* (which should
    be a “nested” sequence object) and the minimum data-type descriptor mintype (which
    can be `NULL` ). Similar in behavior to array(*op*).dtype. Don’t confuse this
    function with [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter").
    This function essentially looks at all the objects in the (nested) sequence and
    determines the data-type from the elements it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Return a data-type object from an array-scalar object. No checking is done to
    be sure that *scalar* is an array scalar. If no suitable data-type can be determined,
    then a data-type of [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    is returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: Returns a data-type object corresponding to *typenum*. The *typenum* can be
    one of the enumerated types, a character code for one of the enumerated types,
    or a user-defined type. If you want to use a flexible size array, then you need
    to `flexible typenum` and set the results `elsize` parameter to the desired size.
    The typenum is one of the [`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    A large number of Python objects can be converted to data-type objects. See [Data
    type objects (dtype)](../arrays.dtypes.html#arrays-dtypes) for a complete description.
    This version of the converter converts None objects to a [`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE") data-type object. This function can be used with the “O&”
    character code in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    This version of the converter converts None objects so that the returned data-type
    is `NULL`. This function can also be used with the “O&” character in PyArg_ParseTuple
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Like [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: Like [`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Take the fields dictionary, *dict*, such as the one attached to a data-type
    object and construct an ordered-list of field names such as is stored in the names
    field of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Other conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Importing the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, coolhelper.c would contain at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, these #defines work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the API Version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Internal Flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  prefs: []
  type: TYPE_NORMAL
- en: Threading support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Group 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Group 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never use semicolons after the threading support macros.
  prefs: []
  type: TYPE_NORMAL
- en: Priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Default priority for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Default subtype priority.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Default scalar priority (very small)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: Default buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Default size of the user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Smallest size of user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Largest size allowed for the user-settable buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Other constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: The number of floating-point types
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of dimensions allowed in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of array arguments that can be used in functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 0 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 1 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Returns the reference count of any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order if all the inputs are Fortran, C otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: C order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: The default for most operations, raises an exception if an index is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Clips an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Wraps an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the selection algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: Only allow identical types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Allow identical and casts involving byte swapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Allow any cast, no matter what kind of data loss may occur.
  prefs: []
  type: TYPE_NORMAL
- en: '## Array structure and data access'
  prefs: []
  type: TYPE_NORMAL
- en: These macros access the [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") structure members and are defined in `ndarraytypes.h`. The input
    argument, *arr*, can be any [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that is directly interpretable as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")* (any instance of the [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and its sub-types).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: The number of dimensions in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: Returns an integer representing the [array-flags](#array-flags).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Return the (builtin) typenumber for the elements of this array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Convert obj and place it in the ndarray, *arr*, at the place pointed to by itemptr.
    Return -1 if an error occurs or 0 on success.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Enables the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: Clears the specified array flags. This function does no validation, and assumes
    that you know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: These two macros are similar and obtain the pointer to the data-buffer for the
    array. The first macro can (and should be) assigned to a particular pointer where
    the second is for generic processing. If you have not guaranteed a contiguous
    and/or aligned array then be sure you understand how to access the data in the
    array to avoid memory and/or alignment problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the dimensions/shape of the array. The number of elements
    matches the number of dimensions of the array. Can return `NULL` for 0-dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for [`PyArray_DIMS`](#c.PyArray_DIMS "PyArray_DIMS"), named to be
    consistent with the [`shape`](../generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape") usage within Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pointer to the strides of the array. The number of elements matches
    the number of dimensions of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Return the shape in the *n* \(^{\textrm{th}}\) dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Return the stride in the *n* \(^{\textrm{th}}\) dimension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Return the itemsize for the elements of this array.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in the old API that was deprecated in version 1.7, this function
    had the return type `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Returns the total size (in number of elements) of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Returns 0 if *obj* is not a sub-class of ndarray. Otherwise, returns the total
    number of elements in the array. Safer version of [`PyArray_SIZE`](#c.PyArray_SIZE
    "PyArray_SIZE") (*obj*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: Returns the total number of bytes consumed by the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: This returns the base object of the array. In most cases, this means the object
    which owns the memory the array is pointing at.
  prefs: []
  type: TYPE_NORMAL
- en: If you are constructing an array using the C API, and specifying your own memory,
    you should use the function [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject
    "PyArray_SetBaseObject") to set the base to an object which owns the memory.
  prefs: []
  type: TYPE_NORMAL
- en: If the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag is set, it has a different meaning, namely base is the array into which the
    current array will be copied upon copy resolution. This overloading of the base
    property for two functions is likely to change in a future version of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: Returns a borrowed reference to the dtype property of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: A synonym for PyArray_DESCR, named to be consistent with the ‘dtype’ usage within
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: Get a Python object of a builtin type from the ndarray, *arr*, at the location
    pointed to by itemptr. Return `NULL` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.ndarray.item`](../generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item") is identical to PyArray_GETITEM.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: The function pointed to by the [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.11)") [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__"). The first argument is the newly created sub-type.
    The second argument (if not NULL) is the “parent” array (if the array was created
    using slicing or some other operation where a clearly-distinguishable parent is
    present). This routine can do anything it wants to. It should return a -1 on error
    and 0 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Data access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Data access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions and macros provide easy access to elements of the ndarray from
    C. These work for all arrays. You may need to take care when accessing the data
    in the array, however, if it is not in machine byte-order, misaligned, or not
    writeable. In other words, be sure to respect the state of the flags unless you
    know what you are doing, or have previously guaranteed an array that is writeable,
    aligned, and in machine byte-order using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). If you wish to handle all types of arrays, the copyswap function
    for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris)
    do not like misaligned data and will crash if you de-reference a misaligned pointer.
    Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Return a pointer to the data of the ndarray, *aobj*, at the N-dimensional index
    given by the c-array, *ind*, (which must be at least *aobj* ->nd in size). You
    may want to typecast the returned pointer to the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Quick, inline access to the element at the given coordinates in the ndarray,
    *obj*, which must have respectively 1, 2, 3, or 4 dimensions (this is not checked).
    The corresponding *i*, *j*, *k*, and *l* coordinates can be any integer but will
    be interpreted as `npy_intp`. You may want to typecast the returned pointer to
    the data type of the ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  prefs: []
  type: TYPE_NORMAL
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  prefs: []
  type: TYPE_NORMAL
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: If *descr* is NULL, the data type of *prototype* is used.
  prefs: []
  type: TYPE_NORMAL
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  prefs: []
  type: TYPE_NORMAL
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is 0 on success, -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  prefs: []
  type: TYPE_NORMAL
- en: From other objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is C-style contiguous
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has strides that are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: From scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*. The easiest way to get one is using
    [`PyArray_DescrFromType`](#c.PyArray_DescrFromType "PyArray_DescrFromType").
  prefs: []
  type: TYPE_NORMAL
- en: This is the main array creation function. Most new arrays are created with this
    flexible function.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object is an object of Python-type *subtype*, which must be a subtype
    of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type "PyArray_Type").
    The array has *nd* dimensions, described by *dims*. The data-type descriptor of
    the new array is *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: If *subtype* is of an array subclass instead of the base [`&PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type"), then *obj* is the object to pass to the [`__array_finalize__`](../arrays.classes.html#numpy.class.__array_finalize__
    "numpy.class.__array_finalize__") method of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is `NULL`, then new unitinialized memory will be allocated and *flags*
    can be non-zero to indicate a Fortran-style contiguous array. Use [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") to initialize the memory.
  prefs: []
  type: TYPE_NORMAL
- en: If *data* is not `NULL`, then it is assumed to point to the memory to be used
    for the array and the *flags* argument is used as the new flags for the array
    (except the state of [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY")
    flag of the new array will be reset).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if *data* is non-NULL, then *strides* can also be provided. If
    *strides* is `NULL`, then the array strides are computed as C-style contiguous
    (default) or Fortran-style contiguous (*flags* is nonzero for *data* = `NULL`
    or *flags* & [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    is nonzero non-NULL *data*). Any provided *dims* and *strides* are copied into
    newly allocated dimension and strides arrays for the new array object.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_CheckStrides`](#c.PyArray_CheckStrides "PyArray_CheckStrides") can
    help verify non- `NULL` stride information.'
  prefs: []
  type: TYPE_NORMAL
- en: If `data` is provided, it must stay alive for the life of the array. One way
    to manage this is through [`PyArray_SetBaseObject`](#c.PyArray_SetBaseObject "PyArray_SetBaseObject")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This function steals a reference to *descr* if it is not NULL. This array creation
    routine allows for the convenient creation of a new array matching an existing
    array’s shapes and memory layout, possibly changing the layout and/or data type.
  prefs: []
  type: TYPE_NORMAL
- en: When *order* is [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"),
    the result order is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    if *prototype* is a fortran array, [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER")
    otherwise. When *order* is [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER"),
    the result order matches that of *prototype*, even when the axes of *prototype*
    aren’t in C or Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: If *descr* is NULL, the data type of *prototype* is used.
  prefs: []
  type: TYPE_NORMAL
- en: If *subok* is 1, the newly created array will use the sub-type of *prototype*
    to create the new array, otherwise it will create a base-class array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    (…) except you specify the data-type descriptor with *type_num* and *itemsize*,
    where *type_num* corresponds to a builtin (or user-defined) type. If the type
    always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize
    specifies the particular size of this array.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If data is passed to [`PyArray_NewFromDescr`](#c.PyArray_NewFromDescr "PyArray_NewFromDescr")
    or [`PyArray_New`](#c.PyArray_New "PyArray_New"), this memory must not be deallocated
    until the new array is deleted. If this data came from another Python object,
    this can be accomplished using [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF
    "(in Python v3.11)") on that object and setting the base member of the new array
    to point to that object. If strides are passed in they must be consistent with
    the dimensions, the itemsize, and the data of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Create a new uninitialized array of type, *typenum*, whose size in each of *nd*
    dimensions is given by the integer array, *dims*.The memory for the array is uninitialized
    (unless typenum is [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    in which case each element in the array is set to NULL). The *typenum* argument
    allows specification of any of the builtin data-types such as [`NPY_FLOAT`](dtype.html#c.NPY_TYPES.NPY_FLOAT
    "NPY_FLOAT") or [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG "NPY_LONG"). The
    memory for the array can be set to zero if desired using [`PyArray_FILLWBYTE`](#c.PyArray_FILLWBYTE
    "PyArray_FILLWBYTE") (return_object, 0).This function cannot be used to create
    a flexible-type array (no itemsize given).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Create an array wrapper around *data* pointed to by the given pointer. The array
    flags will have a default that the data area is well-behaved and C-style contiguous.
    The shape of the array is given by the *dims* c-array of length *nd*. The data-type
    of the array is indicated by *typenum*. If data comes from another reference-counted
    Python object, the reference count on this object should be increased after the
    pointer is passed in, and the base member of the returned ndarray should point
    to the Python object that owns the data. This will ensure that the provided memory
    is not freed while the returned array is in existence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *descr*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new array with the provided data-type descriptor, *descr*, of the shape
    determined by *nd* and *dims*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array pointed to by *obj* —which must be a (subclass of) ndarray—with
    the contents of *val* (evaluated as a byte). This macro calls memset, so obj must
    be contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. Fill the memory with zeros (or
    the 0 object if *dtype* corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Zeros`](#c.PyArray_Zeros "PyArray_Zeros") which takes
    a type-number instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new *nd* -dimensional array with shape given by *dims* and data
    type given by *dtype*. If *fortran* is non-zero, then a Fortran-order array is
    created, otherwise a C-order array is created. The array is uninitialized unless
    the data type corresponds to [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT
    "NPY_OBJECT") in which case the array is filled with [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Macro form of [`PyArray_Empty`](#c.PyArray_Empty "PyArray_Empty") which takes
    a type-number, *typenum*, instead of a data-type object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type, *typenum*, that ranges from
    *start* to *stop* (exclusive) in increments of *step* . Equivalent to **arange**
    (*start*, *stop*, *step*, dtype).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new 1-dimensional array of data-type determined by `descr`, that
    ranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent
    to arange( `start`, `stop`, `step`, `typenum` ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: This function **steals a reference** to `obj` and sets it as the base property
    of `arr`.
  prefs: []
  type: TYPE_NORMAL
- en: If you construct an array by passing in your own memory buffer as a parameter,
    you need to set the array’s *base* property to ensure the lifetime of the memory
    buffer is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The return value is 0 on success, -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: If the object provided is an array, this function traverses the chain of *base*
    pointers so that each array points to the owner of the memory directly. Once the
    base is set, it may not be changed to another value.
  prefs: []
  type: TYPE_NORMAL
- en: From other objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: This is the main function used to obtain an array from any nested sequence,
    or object that exposes the array interface, *op*. The parameters allow specification
    of the required *dtype*, the minimum (*min_depth*) and maximum (*max_depth*) number
    of dimensions acceptable, and other *requirements* for the array. This function
    **steals a reference** to the dtype argument, which needs to be a [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The *dtype* argument may be `NULL`, indicating that any data-type
    (and byteorder) is acceptable. Unless [`NPY_ARRAY_FORCECAST`](#c.PyArray_FromAny.NPY_ARRAY_FORCECAST
    "NPY_ARRAY_FORCECAST") is present in `flags`, this call will generate an error
    if the data type cannot be safely obtained from the object. If you want to use
    `NULL` for the *dtype* and ensure the array is not swapped then use [`PyArray_CheckFromAny`](#c.PyArray_CheckFromAny
    "PyArray_CheckFromAny"). A value of 0 for either of the depth parameters causes
    the parameter to be ignored. Any of the following array flags can be added (*e.g.*
    using |) to get the *requirements* argument. If your code can handle general (*e.g.*
    strided, byte-swapped, or unaligned arrays) then *requirements* may be 0\. Also,
    if *op* is not already an array (or does not expose the array interface), then
    a new array will be created (and filled from *op* using the sequence protocol).
    The new array will have [`NPY_ARRAY_DEFAULT`](#c.PyArray_FromAny.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") as its flags member. The *context* argument is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is C-style contiguous
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array is aligned on proper boundaries for its data type.
    An aligned array has the data pointer and every strides factor as a multiple of
    the alignment factor for the data-type- descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: Make sure a copy is made of *op*. If this flag is not present, data is not copied
    if it can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the result is a base-class ndarray. By default, if *op* is an instance
    of a subclass of ndarray, an instance of that same subclass is returned. If this
    flag is set, an ndarray object will be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: Force a cast to the output type even if it cannot be done safely. Without this
    flag, a data cast will occur only if it can be done safely, otherwise an error
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: If *op* is already an array, but does not satisfy the requirements, then a copy
    is made (which will satisfy the requirements). If this flag is present and a copy
    (of an object that is already an array) must be made, then the corresponding [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag is set in the returned copy and *op* is made
    to be read-only. You must be sure to call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") to copy the contents back into *op* and the
    *op* array will be made writeable again. If *op* is not writeable to begin with,
    or if it is not already an array, then an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")
    | [`NPY_ARRAY_WRITEABLE`](#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.PyArray_FromAny.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.PyArray_FromAny.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.PyArray_FromAny.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Nearly identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (…) except *requirements* can contain [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED") (over-riding the specification in *dtype*) and [`NPY_ARRAY_ELEMENTSTRIDES`](#c.NPY_ARRAY_ELEMENTSTRIDES
    "NPY_ARRAY_ELEMENTSTRIDES") which indicates that the array should be aligned in
    the sense that the strides are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has a data-type descriptor that is in machine byte-order,
    over-riding any specification in the *dtype* argument. Normally, the byte-order
    requirement is determined by the *dtype* argument. If this flag is set and the
    dtype argument does not indicate a machine byte-order descriptor (or is NULL and
    the object is already an array with a data-type descriptor that is not in machine
    byte- order), then a new data-type descriptor is created and used with its byte-order
    field set to native.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") | [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED "NPY_ARRAY_NOTSWAPPED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the returned array has strides that are multiples of the element size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") for
    when *op* is already an array but it needs to be of a specific *newtype* (including
    byte-order) or has certain *requirements*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_struct__`](../arrays.interface.html#object.__array_struct__
    "object.__array_struct__") attribute and follows the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: Returns an ndarray object from a Python object that exposes the [`__array_interface__`](../arrays.interface.html#object.__array_interface__
    "object.__array_interface__") attribute following the array interface protocol.
    If the object does not contain this attribute then a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: Return an ndarray object from a Python object that exposes the [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method. The [`__array__`](../arrays.classes.html#numpy.class.__array__
    "numpy.class.__array__") method can take 0, or 1 argument `([dtype])`. `context`
    is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a (C-style) contiguous and behaved function array from
    any nested sequence or array interface exporting object, *op*, of (non-flexible)
    type given by the enumerated *typenum*, of minimum depth *min_depth*, and of maximum
    depth *max_depth*. Equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") and the type_num member of the type argument set to *typenum*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: This function returns a well-behaved C-style contiguous array from any nested
    sequence or array-interface exporting object. The minimum number of dimensions
    the array can have is given by *min_depth* while the maximum is *max_depth*. This
    is equivalent to call [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    with requirements [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT "NPY_ARRAY_DEFAULT")
    and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY "NPY_ARRAY_ENSUREARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Return an aligned and in native-byteorder array from any nested sequence or
    array-interface exporting object, op, of a type given by the enumerated typenum.
    The minimum number of dimensions the array can have is given by min_depth while
    the maximum is max_depth. This is equivalent to a call to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") with requirements set to BEHAVED.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: This function **steals a reference** to `op` and makes sure that `op` is a base-class
    ndarray. It special cases array scalars, but otherwise calls [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") ( `op`, NULL, 0, 0, [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"), NULL).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or (ASCII)
    text `string` of length `slen`. The data-type of the array to-be-created is given
    by `dtype`. If num is -1, then **copy** the entire string and return an appropriately
    sized array, otherwise, `num` is the number of items to **copy** from the string.
    If `sep` is NULL (or “”), then interpret the string as bytes of binary data, otherwise
    convert the sub-strings separated by `sep` to items of data-type `dtype`. Some
    data-types may not be readable in text mode and an error will be raised if that
    occurs. All errors return NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from a binary or text file.
    The open file pointer is `fp`, the data-type of the array to be created is given
    by `dtype`. This must match the data in the file. If `num` is -1, then read until
    the end of the file and return an appropriately sized array, otherwise, `num`
    is the number of items to read. If `sep` is NULL (or “”), then read from the file
    in binary mode, otherwise read from the file in text mode with `sep` providing
    the item separator. Some array types cannot be read in text mode in which case
    an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: Construct a one-dimensional ndarray of a single type from an object, `buf`,
    that exports the (single-segment) buffer protocol (or has an attribute __buffer__
    that returns an object that exports the buffer protocol). A writeable buffer will
    be tried first followed by a read- only buffer. The [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") flag of the returned array will reflect which one was successful.
    The data is assumed to start at `offset` bytes from the start of the memory location
    for the object. The type of the data in the buffer will be interpreted depending
    on the data- type descriptor, `dtype.` If `count` is negative then it will be
    determined from the size of the buffer and the requested itemsize, otherwise,
    `count` represents how many elements should be converted from the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: Copy from the source array, `src`, into the destination array, `dest`, performing
    a data-type conversion if necessary. If an error occurs return -1 (otherwise 0).
    The shape of `src` must be broadcastable to the shape of `dest`. The data areas
    of dest and src must not overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: Assign an object `src` to a NumPy array `dest` according to array-coercion rules.
    This is basically identical to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny"),
    but assigns directly to the output array. Returns 0 on success and -1 on failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Move data from the source array, `src`, into the destination array, `dest`,
    performing a data-type conversion if necessary. If an error occurs return -1 (otherwise
    0). The shape of `src` must be broadcastable to the shape of `dest`. The data
    areas of dest and src may overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: If `op` is already (C-style) contiguous and well-behaved then just return a
    reference, otherwise return a (contiguous and well-behaved) copy of the array.
    The parameter op must be a (sub-class of an) ndarray and no checking for that
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Convert `obj` to an ndarray. The argument can be any nested sequence or object
    that exports the array interface. This is a macro form of [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") using `NULL`, 0, 0, 0 for the other arguments. Your code must
    be able to handle any data-type descriptor and any combination of data-flags to
    use this macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *requirements* indicating properties the resulting array
    must have. Available requirements that can be enforced are [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"), [`NPY_ARRAY_NOTSWAPPED`](#c.NPY_ARRAY_NOTSWAPPED
    "NPY_ARRAY_NOTSWAPPED"), [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY "NPY_ARRAY_ENSURECOPY"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY"),
    [`NPY_ARRAY_FORCECAST`](#c.NPY_ARRAY_FORCECAST "NPY_ARRAY_FORCECAST"), and [`NPY_ARRAY_ENSUREARRAY`](#c.NPY_ARRAY_ENSUREARRAY
    "NPY_ARRAY_ENSUREARRAY"). Standard combinations of flags can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FROM_O`](#c.PyArray_FROM_O "PyArray_FROM_O") except it
    can take an argument of *typenum* specifying the type-number the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: Combination of [`PyArray_FROM_OF`](#c.PyArray_FROM_OF "PyArray_FROM_OF") and
    [`PyArray_FROM_OT`](#c.PyArray_FROM_OT "PyArray_FROM_OT") allowing both a *typenum*
    and a *flags* argument to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny") except
    the data-type is specified using a typenumber. [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*typenum*) is passed directly to [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny"). This macro also adds [`NPY_ARRAY_DEFAULT`](#c.NPY_ARRAY_DEFAULT
    "NPY_ARRAY_DEFAULT") to requirements if [`NPY_ARRAY_ENSURECOPY`](#c.NPY_ARRAY_ENSURECOPY
    "NPY_ARRAY_ENSURECOPY") is passed in as requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulate the functionality of functions and methods that take the axis= keyword
    and work properly with None as the axis argument. The input array is `obj`, while
    `*axis` is a converted integer (so that >=MAXDIMS is the None value), and `requirements`
    gives the needed properties of `obj`. The output is a converted version of the
    input so that requirements are met and if needed a flattening has occurred. On
    output negative values of `*axis` are converted and the new value is checked to
    ensure consistency with the shape of `obj`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: General check of Python Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Data-type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an unsigned integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a signed integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer, floating point, or complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a string data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.18.
  prefs: []
  type: TYPE_NORMAL
- en: For structured datatypes with no fields this function now returns False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Type is either flexible or user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Type represents object data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Type represents Boolean data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Type has fields associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  prefs: []
  type: TYPE_NORMAL
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  prefs: []
  type: TYPE_NORMAL
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: User-defined data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: Initialize all function pointers and members to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  prefs: []
  type: TYPE_NORMAL
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  prefs: []
  type: TYPE_NORMAL
- en: Special functions for NPY_OBJECT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 for success, -1 for failure.
  prefs: []
  type: TYPE_NORMAL
- en: General check of Python Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object whose type is a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python object with type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to [`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented
    "(in Python v3.11)") and no error condition is set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: If `op` implements any part of the array interface, then `out` will contain
    a new reference to the newly created ndarray using the interface or `out` will
    contain `NULL` if an error during conversion occurs. Otherwise, out will contain
    a borrowed reference to Py_NotImplemented and no error condition is set. This
    version allows setting of the dtype in the part of the array interface that looks
    for the [`__array__`](../arrays.classes.html#numpy.class.__array__ "numpy.class.__array__")
    attribute. *context* is unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of (a subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") and has 0 dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of `Py{cls}ArrType_Type`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either an array scalar (an instance of a sub-type
    of `PyGenericArr_Type` ), or an instance of (a sub-class of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an instance of a builtin numeric type (int, float,
    complex, long, bool)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a builtin Python scalar object (int, float, complex,
    bytes, str, long, bool).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is either a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")) or an array scalar (an instance of a sub- type of `PyGenericArr_Type`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is a Python scalar object (see [`PyArray_IsPythonScalar`](#c.PyArray_IsPythonScalar
    "PyArray_IsPythonScalar")), an array scalar (an instance of a sub-type of `PyGenericArr_Type`)
    or an instance of a sub-type of [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type") whose dimensionality is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Data-type checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the typenum macros, the argument is an integer representing an enumerated
    array data type. For the array type checking macros the argument must be a [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)")* that can be directly interpreted as a [PyArrayObject](types-and-structures.html#c.PyArrayObject
    "PyArrayObject")*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an unsigned integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a signed integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: Type represents any integer, floating point, or complex floating point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a string data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: Type represents an enumerated type corresponding to one of the standard Python
    scalar (bool, int, float, or complex).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Type represents one of the flexible array types ( [`NPY_STRING`](dtype.html#c.NPY_TYPES.NPY_STRING
    "NPY_STRING"), [`NPY_UNICODE`](dtype.html#c.NPY_TYPES.NPY_UNICODE "NPY_UNICODE"),
    or [`NPY_VOID`](dtype.html#c.NPY_TYPES.NPY_VOID "NPY_VOID") ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Type has no size information attached, and can be resized. Should only be called
    on flexible dtypes. Types that are attached to an array will always be sized,
    hence the array form of this macro not existing.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.18.
  prefs: []
  type: TYPE_NORMAL
- en: For structured datatypes with no fields this function now returns False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: Type represents a user-defined type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: Type is either flexible or user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: Type represents object data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: Type represents Boolean data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: Type has fields associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of the ndarray *m* is **not** in machine byte-order
    according to the array’s data-type descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *type1* and *type2* actually
    represent equivalent types for this platform (the fortran member of each type
    is ignored). For example, on 32-bit platforms, [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") and [`NPY_INT`](dtype.html#c.NPY_TYPES.NPY_INT "NPY_INT") are equivalent.
    Otherwise return [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: Return [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *a1* and *a2* are arrays with
    equivalent types for this platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: Special case of [`PyArray_EquivTypes`](#c.PyArray_EquivTypes "PyArray_EquivTypes")
    (…) that does not accept flexible data types but may be easier to call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: True if byteorder characters *b1* and *b2* ( [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"),
    [`NPY_BIG`](#c.NPY_BIG "NPY_BIG"), [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE"),
    [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") ) are either equal or equivalent as
    to their specification of a native byte order. Thus, on a little-endian machine
    [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE") and [`NPY_NATIVE`](#c.NPY_NATIVE "NPY_NATIVE")
    are equivalent where they are not equivalent on a big-endian machine.
  prefs: []
  type: TYPE_NORMAL
- en: Converting data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: Mainly for backwards compatibility to the Numeric C-API and for simple casts
    to non-flexible types. Return a new array object with the elements of *arr* cast
    to the data-type *typenum* which must be one of the enumerated types and not a
    flexible type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: Return a new array of the *type* specified, casting the elements of *arr* as
    appropriate. The fortran argument specifies the ordering of the output array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: As of 1.6, this function simply calls [`PyArray_CopyInto`](#c.PyArray_CopyInto
    "PyArray_CopyInto"), which handles the casting.
  prefs: []
  type: TYPE_NORMAL
- en: Cast the elements of the array *in* into the array *out*. The output array should
    be writeable, have an integer-multiple of the number of elements in the input
    array (more than one copy can be placed in out), and have a data type that is
    one of the builtin types. Returns 0 on success and -1 if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: Return the low-level casting function to cast from the given descriptor to the
    builtin type number. If no casting function exists return `NULL` and set an error.
    Using this function instead of direct access to *from* ->f->cast will allow support
    of any user-defined casting functions added to a descriptors casting dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: Returns non-zero if an array of data type *fromtype* can be cast to an array
    of data type *totype* without losing information. An exception is that 64-bit
    integers are allowed to be cast to 64-bit floating point values even though this
    can lose precision on large integers so as not to proliferate the use of long
    doubles without explicit requests. Flexible array types are not checked according
    to their lengths with this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[`PyArray_CanCastTypeTo`](#c.PyArray_CanCastTypeTo "PyArray_CanCastTypeTo")
    supersedes this function in NumPy 1.6 and later.'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if an array of data type *fromtype* (which can include flexible
    types) can be cast safely to an array of data type *totype* (which can include
    flexible types) according to the casting rule *casting*. For simple types with
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), this
    is basically a wrapper around [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"), but for flexible types such as strings or unicode, it
    produces results taking into account their sizes. Integer and float types can
    only be cast to a string or unicode type using [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING
    "NPY_SAFE_CASTING") if the string or unicode type is big enough to hold the max
    value of the integer/float type being cast from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Returns non-zero if *arr* can be cast to *totype* according to the casting rule
    given in *casting*. If *arr* is an array scalar, its value is taken into account,
    and non-zero is also returned when the value will not overflow or be truncated
    to an integer when converting to a smaller type.
  prefs: []
  type: TYPE_NORMAL
- en: This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr),
    totype, casting), but it also handles a special case arising because the set of
    uint values is not a subset of the int values for types with the same number of
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: If *arr* is an array, returns its data type descriptor, but if *arr* is an array
    scalar (has 0 dimensions), it finds the data type of smallest size to which the
    value may be converted without overflow or truncation to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: This function will not demote complex to float or anything to boolean, but will
    demote a signed integer to an unsigned integer when the scalar value is positive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Finds the data type of smallest size and kind to which *type1* and *type2* may
    be safely converted. This function is symmetric and associative. A string or unicode
    result will be the proper size for storing the max value of the input types converted
    to a string or unicode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: This applies type promotion to all the input arrays and dtype objects, using
    the NumPy rules for combining scalars and arrays, to determine the output type
    for an operation with the given set of operands. This is the same result type
    that ufuncs produce.
  prefs: []
  type: TYPE_NORMAL
- en: See the documentation of [`numpy.result_type`](../generated/numpy.result_type.html#numpy.result_type
    "numpy.result_type") for more detail about the type promotion algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: This function is superseded by [`PyArray_MinScalarType`](#c.PyArray_MinScalarType
    "PyArray_MinScalarType") and/or [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType").
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful for determining a common type that two or more arrays
    can be converted to. It only works for non-flexible array types as no itemsize
    information is passed. The *mintype* argument represents the minimum type acceptable,
    and *op* represents the object that will be converted to an array. The return
    value is the enumerated typenumber that represents the data-type that *op* should
    have.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: The functionality this provides is largely superseded by iterator [`NpyIter`](iterator.html#c.NpyIter
    "NpyIter") introduced in 1.6, with flag [`NPY_ITER_COMMON_DTYPE`](iterator.html#c.NPY_ITER_COMMON_DTYPE
    "NPY_ITER_COMMON_DTYPE") or with the same dtype parameter for all operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a sequence of Python objects contained in *op* to an array of ndarrays
    each having the same data type. The type is selected in the same way as *PyArray_ResultType*.
    The length of the sequence is returned in *n*, and an *n* -length array of [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject") pointers is the return value (or `NULL` if an error occurs).
    The returned array must be freed by the caller of this routine (using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") ) and all the array objects in it `DECREF` ‘d or a memory-leak
    will occur. The example template-code below shows a typically usage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now
    produces a type capable of holding the scalar value. Previously priority was given
    to the dtype of the arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 0 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to newly created memory of size *arr* ->itemsize that holds the representation
    of 1 for that type. The returned pointer, *ret*, **must be freed** using [`PyDataMem_FREE`](#c.PyDataMem_FREE
    "PyDataMem_FREE") (ret) when it is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: Returns [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") if *typenum* represents a valid
    type-number (builtin or user-defined or character code). Otherwise, this function
    returns [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: User-defined data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: Initialize all function pointers and members to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a data-type as a new user-defined data type for arrays. The type must
    have most of its entries filled in. This is not always checked and errors can
    produce segfaults. In particular, the typeobj member of the `dtype` structure
    must be filled with a Python type that has a fixed-size element-size that corresponds
    to the elsize member of *dtype*. Also the `f` member must have the required functions:
    nonzero, copyswap, copyswapn, getitem, setitem, and cast (some of the cast functions
    may be `NULL` if no support is desired). To avoid confusion, you should choose
    a unique character typecode but this is not enforced and not relied on internally.'
  prefs: []
  type: TYPE_NORMAL
- en: A user-defined type number is returned that uniquely identifies the type. A
    pointer to the new structure can then be obtained from [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") using the returned type number. A -1 is returned if an
    error occurs. If this *dtype* has already been registered (checked only by the
    address of the pointer), then return the previously-assigned type-number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: Register a low-level casting function, *castfunc*, to convert from the data-type,
    *descr*, to the given data-type number, *totype*. Any old casting function is
    over-written. A `0` is returned on success or a `-1` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: Register the data-type number, *totype*, as castable from data-type object,
    *descr*, of the given *scalar* kind. Use *scalar* = [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR") to register that an array of data-type *descr* can be cast safely
    to a data-type whose type_number is *totype*. The return value is 0 on success
    or -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: Given a string return the type-number for the data-type with that string as
    the type-object name. Returns `NPY_NOTYPE` without setting an error if no type
    can be found. Only works for user-defined data-types.
  prefs: []
  type: TYPE_NORMAL
- en: Special functions for NPY_OBJECT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When working with arrays or buffers filled with objects NumPy tries to ensure
    such buffers are filled with `None` before any data may be read. However, code
    paths may existed where an array is only initialized to `NULL`. NumPy itself accepts
    `NULL` as an alias for `None`, but may `assert` non-`NULL` when compiled in debug
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Because NumPy is not yet consistent about initialization with None, users **must**
    expect a value of `NULL` when working with buffers created by NumPy. Users **should**
    also ensure to pass fully initialized buffers to NumPy, since NumPy may make this
    a strong requirement in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There is currently an intention to ensure that NumPy always initializes object
    arrays before they may be read. Any failure to do so will be regarded as a bug.
    In the future, users may be able to rely on non-NULL values when reading from
    any array, although exceptions for writing to freshly created arrays may remain
    (e.g. for output arrays in ufunc code). As of NumPy 1.23 known code paths exists
    where proper filling is not done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It increments the
    reference count of every object in the array according to the data-type of *op*.
    A -1 is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: A function to INCREF all the objects at the location *ptr* according to the
    data-type *dtype*. If *ptr* is the start of a structured type with an object at
    any offset, then this will (recursively) increment the reference count of all
    object-like items in the structured type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: Used for an array, *op*, that contains any Python objects. It decrements the
    reference count of every object in the array according to the data-type of *op*.
    Normal return value is 0\. A -1 is returned if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: A function to XDECREF all the object-like items at the location *ptr* as recorded
    in the data-type, *dtype*. This works recursively so that if `dtype` itself has
    fields with data-types that contain object-like items, all the object-like fields
    will be XDECREF `'d`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: Fill a newly created array with a single value obj at all locations in the structure
    with object data-types. No checking is performed but *arr* must be of data-type
    [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT") and be single-segment
    and uninitialized (no previous objects in position). Use [`PyArray_XDECREF`](#c.PyArray_XDECREF
    "PyArray_XDECREF") (*arr*) if you need to decrement all the items in the object
    array prior to calling this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'Precondition: `arr` is a copy of `base` (though possibly with different strides,
    ordering, etc.) Sets the [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") flag and `arr->base`, and set `base` to READONLY.
    Call [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy "PyArray_ResolveWritebackIfCopy")
    before calling *Py_DECREF* in order copy any changes back to `base` and reset
    the READONLY flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 for success, -1 for failure.
  prefs: []
  type: TYPE_NORMAL
- en: '## Array flags'
  prefs: []
  type: TYPE_NORMAL
- en: The `flags` attribute of the `PyArrayObject` structure contains important information
    about the memory used by the array (pointed to by the data member) This flag information
    must be kept accurate or strange results and even segfaults may result.
  prefs: []
  type: TYPE_NORMAL
- en: There are 6 (binary) flags that describe the memory area used by the data buffer.
    These constants are defined in `arrayobject.h` and determine the bit-position
    of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like
    interface for getting (and, if appropriate, setting) these flags.
  prefs: []
  type: TYPE_NORMAL
- en: Memory areas of all kinds can be pointed to by an ndarray, necessitating these
    flags. If you get an arbitrary `PyArrayObject` in C-code, you need to be aware
    of the flags that are set. If you need to guarantee a certain kind of array (like
    [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    and [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")), then pass
    these requirements into the PyArray_FromAny function.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Array Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in C-style contiguous order (last index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: The data area and all array elements are aligned appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: The data area can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  prefs: []
  type: TYPE_NORMAL
- en: Combinations of array flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: Flag-like constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: Cast to the desired type, even if it can’t be done without losing information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting array is a copy of the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: Flag checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* can be written to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  prefs: []
  type: TYPE_NORMAL
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Array Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ndarray can have a data segment that is not a simple contiguous chunk of
    well-behaved memory you can manipulate. It may not be aligned with word boundaries
    (very important on some platforms). It might have its data in a different byte-order
    than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous
    order. The array flags are used to indicate what can be said about data associated
    with an array.
  prefs: []
  type: TYPE_NORMAL
- en: In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_
    macro namespace in them. That form of the constant names is deprecated in 1.7.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in C-style contiguous order (last index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: The data area is in Fortran-style contiguous order (first index varies the fastest).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Arrays can be both C-style and Fortran-style contiguous simultaneously. This
    is clear for 1-dimensional arrays, but can also be true for higher dimensional
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Even for contiguous arrays a stride for a given dimension `arr.strides[dim]`
    may be *arbitrary* if `arr.shape[dim] == 1` or the array has no elements. It does
    *not* generally hold that `self.strides[-1] == self.itemsize` for C-style contiguous
    arrays or `self.strides[0] == self.itemsize` for Fortran-style contiguous arrays
    is true. The correct way to access the `itemsize` of an array from the C API is
    `PyArray_ITEMSIZE(arr)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Internal memory layout of an ndarray](../arrays.ndarray.html#arrays-ndarray)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: The data area is owned by this array. Should never be set manually, instead
    create a `PyObject` wrapping the data and set the array’s base to that object.
    For an example, see the test in `test_mem_policy`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: The data area and all array elements are aligned appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: The data area can be written to.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the above 3 flags are defined so that a new, well- behaved array
    has these flags defined as true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: The data area represents a (well-behaved) copy whose information should be transferred
    back to the original when [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") is called.
  prefs: []
  type: TYPE_NORMAL
- en: This is a special flag that is set if this array represents a copy made because
    a user required certain flags in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    and a copy had to be made of some other array (and the user asked for this flag
    to be set in such a situation). The base attribute then points to the “misbehaved”
    array (which is set read_only). [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") will copy its contents back to the “misbehaved”
    array (casting if necessary) and will reset the “misbehaved” array to [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE"). If the “misbehaved” array was not [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE") to begin with then [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") would have returned an error because [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY") would not have been possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags "PyArray_UpdateFlags") (obj,
    flags) will update the `obj->flags` for `flags` which can be any of [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS
    "NPY_ARRAY_C_CONTIGUOUS"), [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"),
    or [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE").'
  prefs: []
  type: TYPE_NORMAL
- en: Combinations of array flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED") | [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE
    "NPY_ARRAY_WRITEABLE")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_BEHAVED`](#c.NPY_ARRAY_BEHAVED "NPY_ARRAY_BEHAVED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_CARRAY`](#c.NPY_ARRAY_CARRAY "NPY_ARRAY_CARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: '[`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS")
    | [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS")
    | [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED")'
  prefs: []
  type: TYPE_NORMAL
- en: Flag-like constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These constants are used in [`PyArray_FromAny`](#c.PyArray_FromAny "PyArray_FromAny")
    (and its macro forms) to specify desired properties of the new array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: Cast to the desired type, even if it can’t be done without losing information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting array is a copy of the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the resulting object is an actual ndarray, and not a sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: Flag checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all of these macros *arr* must be an instance of a (subclass of) [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, arr, must be an ndarray or subclass. The parameter, *flags*,
    should be an integer consisting of bitwise combinations of the possible flags
    an array can have: [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS "NPY_ARRAY_F_CONTIGUOUS"),
    [`NPY_ARRAY_OWNDATA`](#c.NPY_ARRAY_OWNDATA "NPY_ARRAY_OWNDATA"), [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED"), [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE"),
    [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY "NPY_ARRAY_WRITEBACKIFCOPY").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *arr* is Fortran-style contiguous and *not* C-style contiguous.
    [`PyArray_IS_F_CONTIGUOUS`](#c.PyArray_IS_F_CONTIGUOUS "PyArray_IS_F_CONTIGUOUS")
    is the correct way to test for Fortran-style contiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* can be written to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is properly aligned on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and writeable and in machine
    byte-order according to its descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is aligned and in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous and [`PyArray_ISBEHAVED`](#c.PyArray_ISBEHAVED
    "PyArray_ISBEHAVED") (*arr*) is true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is C-style contiguous, aligned, and
    in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* is Fortran-style contiguous, aligned,
    and in machine byte-order **.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if the data area of *arr* consists of a single (C-style or Fortran-style)
    contiguous segment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: The [`NPY_ARRAY_C_CONTIGUOUS`](#c.NPY_ARRAY_C_CONTIGUOUS "NPY_ARRAY_C_CONTIGUOUS"),
    [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED "NPY_ARRAY_ALIGNED"), and [`NPY_ARRAY_F_CONTIGUOUS`](#c.NPY_ARRAY_F_CONTIGUOUS
    "NPY_ARRAY_F_CONTIGUOUS") array flags can be “calculated” from the array object
    itself. This routine updates one or more of these flags of *arr* as specified
    in *flagmask* by performing the required calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep the flags updated (using [`PyArray_UpdateFlags`](#c.PyArray_UpdateFlags
    "PyArray_UpdateFlags") can help) whenever a manipulation with an array is performed
    that might cause them to change. Later calculations in NumPy that rely on the
    state of these flags do not repeat the calculation to update them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: This function does nothing and returns 0 if *obj* is writeable. It raises an
    exception and returns -1 if *obj* is not writeable. It may also do other house-keeping,
    such as issuing warnings on arrays which are transitioning to become views. Always
    call this function at some point before writing to an array.
  prefs: []
  type: TYPE_NORMAL
- en: '*name* is a name for the array, used to give better error messages. It can
    be something like “assignment destination”, “output array”, or even just “array”.'
  prefs: []
  type: TYPE_NORMAL
- en: Array method alternative API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  prefs: []
  type: TYPE_NORMAL
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Shape Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Item selection and manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: raise a ValueError;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: all values are clipped to the region [0, len(*op*) ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  prefs: []
  type: TYPE_NORMAL
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Counts the number of non-zero elements in the array object *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.getfield`](../generated/numpy.ndarray.getfield.html#numpy.ndarray.getfield
    "numpy.ndarray.getfield") (*self*, *dtype*, *offset*). This function [steals a
    reference](https://docs.python.org/3/c-api/intro.html?reference-count-details)
    to *PyArray_Descr* and returns a new array of the given *dtype* using the data
    in the current array at a specified *offset* in bytes. The *offset* plus the itemsize
    of the new array type must be less than `self ->descr->elsize` or an error is
    raised. The same shape and strides as the original array are used. Therefore,
    this function has the effect of returning a field from a structured array. But,
    it can also be used to select specific bytes or groups of bytes from any array
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.setfield`](../generated/numpy.ndarray.setfield.html#numpy.ndarray.setfield
    "numpy.ndarray.setfield") (*self*, *val*, *dtype*, *offset* ). Set the field starting
    at *offset* in bytes and of the given *dtype* to *val*. The *offset* plus *dtype*
    ->elsize must be less than *self* ->descr->elsize or an error is raised. Otherwise,
    the *val* argument is converted to an array and copied into the field pointed
    to. If necessary, the elements of *val* are repeated to fill the destination array,
    But, the number of elements in the destination must be an integer multiple of
    the number of elements in *val*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.byteswap`](../generated/numpy.ndarray.byteswap.html#numpy.ndarray.byteswap
    "numpy.ndarray.byteswap") (*self*, *inplace*). Return an array whose data area
    is byteswapped. If *inplace* is non-zero, then do the byteswap inplace and return
    a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.copy`](../generated/numpy.ndarray.copy.html#numpy.ndarray.copy
    "numpy.ndarray.copy") (*self*, *fortran*). Make a copy of the *old* array. The
    returned array is always aligned and writeable with data interpreted the same
    as the old array. If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    then a C-style contiguous array is returned. If *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER
    "NPY_FORTRANORDER"), then a Fortran-style contiguous array is returned. If *order
    is* [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the array
    returned is Fortran-style contiguous only if the old one is; otherwise, it is
    C-style contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tolist`](../generated/numpy.ndarray.tolist.html#numpy.ndarray.tolist
    "numpy.ndarray.tolist") (*self*). Return a nested Python list from *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.tobytes`](../generated/numpy.ndarray.tobytes.html#numpy.ndarray.tobytes
    "numpy.ndarray.tobytes") (*self*, *order*). Return the bytes of this array in
    a Python string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: Write the contents of *self* to the file pointer *fp* in C-style contiguous
    fashion. Write the data as binary bytes if *sep* is the string “”or `NULL`. Otherwise,
    write the contents of *self* as text using the *sep* string as the item separator.
    Each item will be printed to the file. If the *format* string is not `NULL` or
    “”, then it is a Python print statement format string showing how the items are
    to be written.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to the given *file* (either a string or a Python
    file object). If *file* is a Python string it is considered to be the name of
    a file which is then opened in binary mode. The given *protocol* is used (if *protocol*
    is negative, or the highest available is used). This is a simple wrapper around
    cPickle.dump(*self*, *file*, *protocol*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: Pickle the object in *self* to a Python string and return it. Use the Pickle
    *protocol* provided (or the highest available if *protocol* is negative).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: Fill the array, *arr*, with the given scalar object, *obj*. The object is first
    converted to the data type of *arr*, and then copied into every location. A -1
    is returned if an error occurs, otherwise 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.view`](../generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") (*self*, *dtype*). Return a new view of the array *self*
    as possibly a different data-type, *dtype*, and different array subclass *ptype*.
  prefs: []
  type: TYPE_NORMAL
- en: If *dtype* is `NULL`, then the returned array will have the same data type as
    *self*. The new data-type must be consistent with the size of *self*. Either the
    itemsizes must be identical, or *self* must be single-segment and the total number
    of bytes must be the same. In the latter case the dimensions of the returned array
    will be altered in the last (or first for Fortran-style contiguous arrays) dimension.
    The data area of the returned array and self is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Shape Manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: Result will be a new array (pointing to the same memory location as *self* if
    possible), but having a shape given by *newshape*. If the new shape is not compatible
    with the strides of *self*, then a copy of the array with the new specified shape
    will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.reshape`](../generated/numpy.ndarray.reshape.html#numpy.ndarray.reshape
    "numpy.ndarray.reshape") (*self*, *shape*) where *shape* is a sequence. Converts
    *shape* to a [`PyArray_Dims`](types-and-structures.html#c.PyArray_Dims "PyArray_Dims")
    structure and calls [`PyArray_Newshape`](#c.PyArray_Newshape "PyArray_Newshape")
    internally. For back-ward compatibility – Not recommended
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.squeeze`](../generated/numpy.ndarray.squeeze.html#numpy.ndarray.squeeze
    "numpy.ndarray.squeeze") (*self*). Return a new view of *self* with all of the
    dimensions of length 1 removed from the shape.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: matrix objects are always 2-dimensional. Therefore, [`PyArray_Squeeze`](#c.PyArray_Squeeze
    "PyArray_Squeeze") has no effect on arrays of matrix sub-class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.swapaxes`](../generated/numpy.ndarray.swapaxes.html#numpy.ndarray.swapaxes
    "numpy.ndarray.swapaxes") (*self*, *a1*, *a2*). The returned array is a new view
    of the data in *self* with the given axes, *a1* and *a2*, swapped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.resize`](../generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran
    ). This function only works on single-segment arrays. It changes the shape of
    *self* inplace and will reallocate the memory for *self* if *newshape* has a different
    total number of elements then the old shape. If reallocation is necessary, then
    *self* must own its data, have *self* - `>base==NULL`, have *self* - `>weakrefs==NULL`,
    and (unless refcheck is 0) not be referenced by any other array. The fortran argument
    can be [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER
    "NPY_CORDER"), or [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER").
    It currently has no effect. Eventually it could be used to determine how the resize
    operation should view the data when constructing a differently-dimensioned array.
    Returns None on success and NULL on error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.transpose`](../generated/numpy.ndarray.transpose.html#numpy.ndarray.transpose
    "numpy.ndarray.transpose") (*self*, *permute*). Permute the axes of the ndarray
    object *self* according to the data structure *permute* and return the result.
    If *permute* is `NULL`, then the resulting array has its axes reversed. For example
    if *self* has shape \(10\times20\times30\), and *permute* `.ptr` is (0,2,1) the
    shape of the result is \(10\times30\times20.\) If *permute* is `NULL`, the shape
    of the result is \(30\times20\times10.\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.flatten`](../generated/numpy.ndarray.flatten.html#numpy.ndarray.flatten
    "numpy.ndarray.flatten") (*self*, *order*). Return a 1-d copy of the array. If
    *order* is [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER")
    the elements are scanned out in Fortran order (first-dimension varies the fastest).
    If *order* is [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"), the elements
    of `self` are scanned in C-order (last dimension varies the fastest). If *order*
    [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER "NPY_ANYORDER"), then the result of
    [`PyArray_ISFORTRAN`](#c.PyArray_ISFORTRAN "PyArray_ISFORTRAN") (*self*) is used
    to determine which order to flatten.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.ravel(*order*). Same basic functionality as [`PyArray_Flatten`](#c.PyArray_Flatten
    "PyArray_Flatten") (*self*, *order*) except if *order* is 0 and *self* is C-style
    contiguous, the shape is altered but no copy is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Item selection and manipulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.take`](../generated/numpy.ndarray.take.html#numpy.ndarray.take
    "numpy.ndarray.take") (*self*, *indices*, *axis*, *ret*, *clipmode*) except *axis*
    =None in Python is obtained by setting *axis* = [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") in C. Extract the items from self indicated by the integer-valued
    *indices* along the given *axis.* The clipmode argument can be [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE"), [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), or [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP
    "NPY_CLIP") to indicate what to do with out-of-bound indices. The *ret* argument
    can specify an output array rather than having one created internally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to *self*.put(*values*, *indices*, *clipmode* ). Put *values* into
    *self* at the corresponding (flattened) *indices*. If *values* is too small it
    will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: Place the *values* in *self* wherever corresponding positions (using a flattened
    context) in *mask* are true. The *mask* and *self* arrays must have the same total
    number of elements. If *values* is too small, it will be repeated as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.repeat`](../generated/numpy.ndarray.repeat.html#numpy.ndarray.repeat
    "numpy.ndarray.repeat") (*self*, *op*, *axis*). Copy the elements of *self*, *op*
    times along the given *axis*. Either *op* is a scalar integer or a sequence of
    length *self* ->dimensions[ *axis* ] indicating how many times to repeat each
    item along the axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.choose`](../generated/numpy.ndarray.choose.html#numpy.ndarray.choose
    "numpy.ndarray.choose") (*self*, *op*, *ret*, *clipmode*). Create a new array
    by selecting elements from the sequence of arrays in *op* based on the integer
    values in *self*. The arrays must all be broadcastable to the same shape and the
    entries in *self* should be between 0 and len(*op*). The output is placed in *ret*
    unless it is `NULL` in which case a new output is created. The *clipmode* argument
    determines behavior for when entries in *self* are not between 0 and len(*op*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: raise a ValueError;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: wrap values < 0 by adding len(*op*) and values >=len(*op*) by subtracting len(*op*)
    until they are in range;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: all values are clipped to the region [0, len(*op*) ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sort`](../generated/numpy.ndarray.sort.html#numpy.ndarray.sort
    "numpy.ndarray.sort") (*self*, *axis*, *kind*). Return an array with the items
    of *self* sorted along *axis*. The array is sorted using the algorithm denoted
    by *kind*, which is an integer/enum pointing to the type of sorting algorithms
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argsort`](../generated/numpy.ndarray.argsort.html#numpy.ndarray.argsort
    "numpy.ndarray.argsort") (*self*, *axis*). Return an array of indices such that
    selection of these indices along the given `axis` would return a sorted version
    of *self*. If *self* ->descr is a data-type with fields defined, then self->descr->names
    is used to determine the sort order. A comparison where the first field is equal
    will use the second field and so on. To alter the sort order of a structured array,
    create a new data-type with a different order of names and construct a view of
    the array with that new data-type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: Given a sequence of arrays (*sort_keys*) of the same shape, return an array
    of indices (similar to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…)) that would sort the arrays lexicographically. A lexicographic sort specifies
    that when two keys are found to be equal, the order is based on comparison of
    subsequent keys. A merge sort (which leaves equal entries unmoved) is required
    to be defined for the types. The sort is accomplished by sorting the indices first
    using the first *sort_key* and then using the second *sort_key* and so forth.
    This is equivalent to the lexsort(*sort_keys*, *axis*) Python command. Because
    of the way the merge-sort works, be sure to understand the order the *sort_keys*
    must be in (reversed from the order you would use when comparing two elements).
  prefs: []
  type: TYPE_NORMAL
- en: If these arrays are all collected in a structured array, then [`PyArray_Sort`](#c.PyArray_Sort
    "PyArray_Sort") (…) can also be used to sort the array directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.searchsorted`](../generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "numpy.ndarray.searchsorted") (*self*, *values*, *side*, *perm*). Assuming *self*
    is a 1-d array in ascending order, then the output is an array of indices the
    same shape as *values* such that, if the elements in *values* were inserted before
    the indices, the order of *self* would be preserved. No checking is done on whether
    or not self is in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The *side* argument indicates whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: The *sorter* argument, if not `NULL`, must be a 1D array of integer indices
    the same length as *self*, that sorts it into ascending order. This is typically
    the result of a call to [`PyArray_ArgSort`](#c.PyArray_ArgSort "PyArray_ArgSort")
    (…) Binary search is used to find the required insertion points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.partition`](../generated/numpy.ndarray.partition.html#numpy.ndarray.partition
    "numpy.ndarray.partition") (*self*, *ktharray*, *axis*, *kind*). Partitions the
    array so that the values of the element indexed by *ktharray* are in the positions
    they would be if the array is fully sorted and places all elements smaller than
    the kth before and all elements equal or greater after the kth element. The ordering
    of all elements within the partitions is undefined. If *self*->descr is a data-type
    with fields defined, then self->descr->names is used to determine the sort order.
    A comparison where the first field is equal will use the second field and so on.
    To alter the sort order of a structured array, create a new data-type with a different
    order of names and construct a view of the array with that new data-type. Returns
    zero on success and -1 on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argpartition`](../generated/numpy.ndarray.argpartition.html#numpy.ndarray.argpartition
    "numpy.ndarray.argpartition") (*self*, *ktharray*, *axis*, *kind*). Return an
    array of indices such that selection of these indices along the given `axis` would
    return a partitioned version of *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.diagonal`](../generated/numpy.ndarray.diagonal.html#numpy.ndarray.diagonal
    "numpy.ndarray.diagonal") (*self*, *offset*, *axis1*, *axis2* ). Return the *offset*
    diagonals of the 2-d arrays defined by *axis1* and *axis2*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Counts the number of non-zero elements in the array object *self*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.nonzero`](../generated/numpy.ndarray.nonzero.html#numpy.ndarray.nonzero
    "numpy.ndarray.nonzero") (*self*). Returns a tuple of index arrays that select
    elements of *self* that are nonzero. If (nd= [`PyArray_NDIM`](#c.PyArray_NDIM
    "PyArray_NDIM") ( `self` ))==1, then a single index array is returned. The index
    arrays have data type [`NPY_INTP`](dtype.html#c.NPY_TYPES.NPY_INTP "NPY_INTP").
    If a tuple is returned (nd \(\neq\) 1), then its length is nd.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.compress`](../generated/numpy.ndarray.compress.html#numpy.ndarray.compress
    "numpy.ndarray.compress") (*self*, *condition*, *axis* ). Return the elements
    along *axis* corresponding to elements of *condition* that are true.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Pass in [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS") for axis in order to achieve
    the same effect that is obtained by passing in `axis=None` in Python (treating
    the array as a 1-d array).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The out argument specifies where to place the result. If out is NULL, then the
    output array is created, otherwise the output is placed in out which must be the
    correct size and type. A new reference to the output array is always returned
    even when out is not NULL. The caller of the routine has the responsibility to
    `Py_DECREF` out if not NULL or a memory-leak will occur.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmax`](../generated/numpy.ndarray.argmax.html#numpy.ndarray.argmax
    "numpy.ndarray.argmax") (*self*, *axis*). Return the index of the largest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.argmin`](../generated/numpy.ndarray.argmin.html#numpy.ndarray.argmin
    "numpy.ndarray.argmin") (*self*, *axis*). Return the index of the smallest element
    of *self* along *axis*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.max`](../generated/numpy.ndarray.max.html#numpy.ndarray.max
    "numpy.ndarray.max") (*self*, *axis*). Returns the largest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.min`](../generated/numpy.ndarray.min.html#numpy.ndarray.min
    "numpy.ndarray.min") (*self*, *axis*). Return the smallest element of *self* along
    the given *axis*. When the result is a single element, returns a numpy scalar
    instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.ptp`](../generated/numpy.ndarray.ptp.html#numpy.ndarray.ptp
    "numpy.ndarray.ptp") (*self*, *axis*). Return the difference between the largest
    element of *self* along *axis* and the smallest element of *self* along *axis*.
    When the result is a single element, returns a numpy scalar instead of an ndarray.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The rtype argument specifies the data-type the reduction should take place over.
    This is important if the data-type of the array is not “large” enough to handle
    the output. By default, all integer data-types are made at least as large as [`NPY_LONG`](dtype.html#c.NPY_TYPES.NPY_LONG
    "NPY_LONG") for the “add” and “multiply” ufuncs (which form the basis for mean,
    sum, cumsum, prod, and cumprod functions).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.mean`](../generated/numpy.ndarray.mean.html#numpy.ndarray.mean
    "numpy.ndarray.mean") (*self*, *axis*, *rtype*). Returns the mean of the elements
    along the given *axis*, using the enumerated type *rtype* as the data type to
    sum in. Default sum behavior is obtained using [`NPY_NOTYPE`](dtype.html#c.NPY_NOTYPE
    "NPY_NOTYPE") for *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.trace`](../generated/numpy.ndarray.trace.html#numpy.ndarray.trace
    "numpy.ndarray.trace") (*self*, *offset*, *axis1*, *axis2*, *rtype*). Return the
    sum (using *rtype* as the data type of summation) over the *offset* diagonal elements
    of the 2-d arrays defined by *axis1* and *axis2* variables. A positive offset
    chooses diagonals above the main diagonal. A negative offset selects diagonals
    below the main diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.clip`](../generated/numpy.ndarray.clip.html#numpy.ndarray.clip
    "numpy.ndarray.clip") (*self*, *min*, *max*). Clip an array, *self*, so that values
    larger than *max* are fixed to *max* and values less than *min* are fixed to *min*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.conjugate`](../generated/numpy.ndarray.conjugate.html#numpy.ndarray.conjugate
    "numpy.ndarray.conjugate") (*self*). Return the complex conjugate of *self*. If
    *self* is not of complex data type, then return *self* with a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.round`](../generated/numpy.ndarray.round.html#numpy.ndarray.round
    "numpy.ndarray.round") (*self*, *decimals*, *out*). Returns the array with elements
    rounded to the nearest decimal place. The decimal place is defined as the \(10^{-\textrm{decimals}}\)
    digit so that negative *decimals* cause rounding to the nearest 10’s, 100’s, etc.
    If out is `NULL`, then the output array is created, otherwise the output is placed
    in *out* which must be the correct size and type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.std`](../generated/numpy.ndarray.std.html#numpy.ndarray.std
    "numpy.ndarray.std") (*self*, *axis*, *rtype*). Return the standard deviation
    using data along *axis* converted to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.sum`](../generated/numpy.ndarray.sum.html#numpy.ndarray.sum
    "numpy.ndarray.sum") (*self*, *axis*, *rtype*). Return 1-d vector sums of elements
    in *self* along *axis*. Perform the sum after converting data to data type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumsum`](../generated/numpy.ndarray.cumsum.html#numpy.ndarray.cumsum
    "numpy.ndarray.cumsum") (*self*, *axis*, *rtype*). Return cumulative 1-d sums
    of elements in *self* along *axis*. Perform the sum after converting data to data
    type *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.prod`](../generated/numpy.ndarray.prod.html#numpy.ndarray.prod
    "numpy.ndarray.prod") (*self*, *axis*, *rtype*). Return 1-d products of elements
    in *self* along *axis*. Perform the product after converting data to data type
    *rtype*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.cumprod`](../generated/numpy.ndarray.cumprod.html#numpy.ndarray.cumprod
    "numpy.ndarray.cumprod") (*self*, *axis*, *rtype*). Return 1-d cumulative products
    of elements in `self` along `axis`. Perform the product after converting data
    to data type `rtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.all`](../generated/numpy.ndarray.all.html#numpy.ndarray.all
    "numpy.ndarray.all") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of `self` defined by `axis` in which all the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent to [`ndarray.any`](../generated/numpy.ndarray.any.html#numpy.ndarray.any
    "numpy.ndarray.any") (*self*, *axis*). Return an array with True elements for
    every 1-d sub-array of *self* defined by *axis* in which any of the elements are
    True.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  prefs: []
  type: TYPE_NORMAL
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute z as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  prefs: []
  type: TYPE_NORMAL
- en: Array Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it is useful to access a multidimensional array as a C-style multi-dimensional
    array so that algorithms can be implemented using C’s a[i][j][k] syntax. This
    routine returns a pointer, *ptr*, that simulates this kind of C-style array, for
    1-, 2-, and 3-d ndarrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op** – The address to any Python object. This Python object will be replaced
    with an equivalent well-behaved, C-style contiguous, ndarray of the given data
    type specified by the last two arguments. Be sure that stealing a reference in
    this way to the input object is justified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ptr** – The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for
    3-d) variable where ctype is the equivalent C-type for the data type. On return,
    *ptr* will be addressable as a 1-d, 2-d, or 3-d array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dims** – An output array that contains the shape of the array object. This
    array gives boundaries on any looping that will take place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nd** – The dimensionality of the array (1, 2, or 3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**typedescr** – A [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure indicating the desired data-type (including required
    byteorder). The call will steal a reference to the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The simulation of a C-style array is not complete for 2-d and 3-d arrays. For
    example, the simulated arrays of pointers cannot be passed to subroutines expecting
    specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring
    those kind of inputs, you must statically define the required array and copy data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: Must be called with the same objects and memory locations returned from [`PyArray_AsCArray`](#c.PyArray_AsCArray
    "PyArray_AsCArray") (…). This function cleans up memory that otherwise would get
    leaked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: Join the sequence of objects in *obj* together along *axis* into a single array.
    If the dimensions or types are not compatible an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimensions of *obj1* and *obj2*. Neither
    array is conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: Compute a product-sum over the last dimension of *obj1* and the second-to-last
    dimension of *obj2*. For 2-d arrays this is a matrix-product. Neither array is
    conjugated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Same as PyArray_MatrixProduct, but store the result in *out*. The output array
    must have the correct shape, type, and be C-contiguous, or an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: Applies the Einstein summation convention to the array operands provided, returning
    a new array or placing the result in *out*. The string in *subscripts* is a comma
    separated list of index letters. The number of operands is in *nop*, and *op_in*
    is an array containing those operands. The data type of the output can be forced
    with *dtype*, the output order can be forced with *order* ([`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER
    "NPY_KEEPORDER") is recommended), and when *dtype* is specified, *casting* indicates
    how permissive the data conversion should be.
  prefs: []
  type: TYPE_NORMAL
- en: See the [`einsum`](../generated/numpy.einsum.html#numpy.einsum "numpy.einsum")
    function for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: A specialized copy and transpose function that works only for 2-d arrays. The
    returned array is a transposed copy of *op*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the 1-d correlation of the 1-d arrays *op1* and *op2* . The correlation
    is computed at each output point by multiplying *op1* by a shifted version of
    *op2* and summing the result. As a result of the shift, needed values outside
    of the defined range of *op1* and *op2* are interpreted as zero. The mode determines
    how many shifts to return: 0 - return only shifts that did not need to assume
    zero- values; 1 - return an object that is the same size as *op1*, 2 - return
    all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not compute the usual correlation: if op2 is larger than op1, the
    arguments are swapped, and the conjugate is never taken for complex arrays. See
    PyArray_Correlate2 for the usual signal processing correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: 'Updated version of PyArray_Correlate, which uses the usual definition of correlation
    for 1d arrays. The correlation is computed at each output point by multiplying
    *op1* by a shifted version of *op2* and summing the result. As a result of the
    shift, needed values outside of the defined range of *op1* and *op2* are interpreted
    as zero. The mode determines how many shifts to return: 0 - return only shifts
    that did not need to assume zero- values; 1 - return an object that is the same
    size as *op1*, 2 - return all possible shifts (any overlap at all is accepted).'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Compute z as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: If both `x` and `y` are `NULL`, then return [`PyArray_Nonzero`](#c.PyArray_Nonzero
    "PyArray_Nonzero") (*condition*). Otherwise, both *x* and *y* must be given and
    the object returned is shaped like *condition* and has elements of *x* and *y*
    where *condition* is respectively True or False.
  prefs: []
  type: TYPE_NORMAL
- en: Other functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: Determine if *newstrides* is a strides array consistent with the memory of an
    *nd* -dimensional array with shape `dims` and element-size, *elsize*. The *newstrides*
    array is checked to see if jumping by the provided number of bytes in each direction
    will ever mean jumping more than *numbytes* which is the assumed size of the available
    memory segment. If *numbytes* is 0, then an equivalent *numbytes* is computed
    assuming *nd*, *dims*, and *elsize* refer to a single-segment array. Return [`NPY_TRUE`](#c.NPY_TRUE
    "NPY_TRUE") if *newstrides* is acceptable, otherwise return [`NPY_FALSE`](#c.NPY_FALSE
    "NPY_FALSE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: Both of these routines multiply an *n* -length array, *seq*, of integers and
    return the result. No overflow checking is performed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: Given two *n* -length arrays of integers, *l1*, and *l2*, return 1 if the lists
    are identical; otherwise, return 0.
  prefs: []
  type: TYPE_NORMAL
- en: Auxiliary Data With Object Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: When working with more complex dtypes which are composed of other dtypes, such
    as the struct dtype, creating inner loops that manipulate the dtypes requires
    carrying along additional data. NumPy supports this idea through a struct [`NpyAuxData`](#c.NpyAuxData
    "NpyAuxData"), mandating a few conventions so that it is possible to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an [`NpyAuxData`](#c.NpyAuxData "NpyAuxData") is similar to defining
    a class in C++, but the object semantics have to be tracked manually since the
    API is in C. Here’s an example for a function which doubles up an element using
    an element copier function as a primitive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: The function pointer type for NpyAuxData free functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: The function pointer type for NpyAuxData clone functions. These functions should
    never set the Python exception on error, because they may be called from a multi-threaded
    context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: A macro which calls the auxdata’s free function appropriately, does nothing
    if auxdata is NULL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: A macro which calls the auxdata’s clone function appropriately, returning a
    deep copy of the auxiliary data.
  prefs: []
  type: TYPE_NORMAL
- en: Array Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of NumPy 1.6.0, these array iterators are superseded by the new array iterator,
    [`NpyIter`](iterator.html#c.NpyIter "NpyIter").
  prefs: []
  type: TYPE_NORMAL
- en: An array iterator is a simple way to access the elements of an N-dimensional
    array quickly and efficiently, as seen in [the example](iterator.html#iteration-example)
    which provides more description of this useful approach to looping over an array
    from C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator object from the array, *arr*. This is equivalent to
    *arr*. **flat**. The array iterator object makes it easy to loop over an N-dimensional
    non-contiguous array in C-style contiguous fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator that will iterate over all axes but the one provided
    in **axis*. The returned iterator cannot be used with [`PyArray_ITER_GOTO1D`](#c.PyArray_ITER_GOTO1D
    "PyArray_ITER_GOTO1D"). This iterator could be used to write something similar
    to what ufuncs do wherein the loop over the largest axis is done by a separate
    sub-routine. If **axis* is negative then **axis* will be set to the axis having
    the smallest stride and that axis will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: Return an array iterator that is broadcast to iterate as an array of the shape
    provided by *dimensions* and *nd*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates true if *op* is an array iterator (or instance of a subclass of the
    array iterator type).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: Reset an *iterator* to the beginning of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: Incremement the index and the dataptr members of the *iterator* to point to
    the next element of the array. If the array is not (C-style) contiguous, also
    increment the N-dimensional coordinates array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: A pointer to the current element of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: Set the *iterator* index, dataptr, and coordinates members to the location in
    the array indicated by the N-dimensional c-array, *destination*, which must have
    size at least *iterator* ->nd_m1+1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: Set the *iterator* index and dataptr to the location in the array indicated
    by the integer *index* which points to an element in the C-styled flattened array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates TRUE as long as the iterator has not looped through all of the elements,
    otherwise it evaluates FALSE.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting (multi-iterators)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: A simplified interface to broadcasting. This function takes the number of arrays
    to broadcast and then *num* extra ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject
    "(in Python v3.11)") ) arguments. These arguments are converted to arrays and
    iterators are created. [`PyArray_Broadcast`](#c.PyArray_Broadcast "PyArray_Broadcast")
    is then called on the resulting multi-iterator object. The resulting, broadcasted
    mult-iterator object is then returned. A broadcasted operation can then be performed
    using a single loop and using [`PyArray_MultiIter_NEXT`](#c.PyArray_MultiIter_NEXT
    "PyArray_MultiIter_NEXT") (..)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: Reset all the iterators to the beginning in a multi-iterator object, *multi*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to its next (broadcasted)
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: Return the data-pointer of the *i* \(^{\textrm{th}}\) iterator in a multi-iterator
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: Advance the pointer of only the *i* \(^{\textrm{th}}\) iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to the given \(N\)
    -dimensional *destination* where \(N\) is the number of dimensions in the broadcasted
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: Advance each iterator in a multi-iterator object, *multi*, to the corresponding
    location of the *index* into the flattened broadcasted array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates TRUE as long as the multi-iterator has not looped through all of the
    elements (of the broadcasted result), otherwise it evaluates FALSE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: This function encapsulates the broadcasting rules. The *mit* container should
    already contain iterators for all the arrays that need to be broadcast. On return,
    these iterators will be adjusted so that iteration over each simultaneously will
    accomplish the broadcasting. A negative number is returned if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a multi-iterator object that has been previously “broadcasted,”
    finds the dimension with the smallest “sum of strides” in the broadcasted result
    and adapts all the iterators so as not to iterate over that dimension (by effectively
    making them of length-1 in that dimension). The corresponding dimension is returned
    unless *mit* ->nd is 0, then -1 is returned. This function is useful for constructing
    ufunc-like routines that broadcast their inputs correctly and then call a strided
    1-d version of the routine as the inner-loop. This 1-d version is usually optimized
    for speed and for this reason the loop should be performed over the axis that
    won’t require large stride jumps.
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Neighborhood iterators are subclasses of the iterator object, and can be used
    to iter over a neighborhood of a point. For example, you may want to iterate over
    every voxel of a 3d image, and for every such voxel, iterate over an hypercube.
    Neighborhood iterator automatically handle boundaries, thus making this kind of
    code much easier to write than manual boundaries handling, at the cost of a slight
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a new neighborhood iterator from an existing iterator.
    The neighborhood will be computed relatively to the position currently pointed
    by *iter*, the bounds define the shape of the neighborhood iterator, and the mode
    argument the boundaries handling mode.
  prefs: []
  type: TYPE_NORMAL
- en: The *bounds* argument is expected to be a (2 * iter->ao->nd) arrays, such as
    the range bound[2*i]->bounds[2*i+1] defines the range where to walk for dimension
    i (both bounds are included in the walked coordinates). The bounds should be ordered
    for each dimension (bounds[2*i] <= bounds[2*i+1]).
  prefs: []
  type: TYPE_NORMAL
- en: 'The mode should be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: Zero padding. Outside bounds values will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: One padding, Outside bounds values will be 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: Constant padding. Outside bounds values will be the same as the first item in
    fill_value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: Mirror padding. Outside bounds values will be as if the array items were mirrored.
    For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will be 1, x[4]
    will be 4, x[5] will be 1, etc…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: Circular padding. Outside bounds values will be as if the array was repeated.
    For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4]
    will be 1, x[5] will be 2, etc…
  prefs: []
  type: TYPE_NORMAL
- en: If the mode is constant filling (*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*),
    fill_value should point to an array object which holds the filling value (the
    first item will be the filling value if the array contains more than one item).
    For other cases, fill_value may be NULL.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator holds a reference to iter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return NULL on failure (in which case the reference count of iter is not changed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iter itself can be a Neighborhood iterator: this can be useful for .e.g automatic
    boundaries handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the object returned by this function should be safe to use as a normal iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next
    is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the position of iter is not the beginning of the data and the underlying
    data for iter is contiguous, the iterator will point to the start of the data
    instead of position pointed by iter. To avoid this situation, iter should be moved
    to the required position only after the creation of iterator, and PyArrayNeighborhoodIter_Reset
    must be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: Reset the iterator position to the first point of the neighborhood. This should
    be called whenever the iter argument given at PyArray_NeighborhoodIterObject is
    changed (see example)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: After this call, iter->dataptr points to the next point of the neighborhood.
    Calling this function after every point of the neighborhood has been visited is
    undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Array mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array mapping is the machinery behind advanced indexing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: Use advanced indexing to iterate an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: 'Swap the axes to or from their inserted form. `MapIter` always puts the advanced
    (array) indices first in the iteration. But if they are consecutive, it will insert/transpose
    them back before returning. This is stored as `mit->consec != 0` (the place where
    they are inserted). For assignments, the opposite happens: the values to be assigned
    are transposed (`getmap=1` instead of `getmap=0`). `getmap=0` and `getmap=1` undo
    the other operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: This function needs to update the state of the map iterator and point `mit->dataptr`
    to the memory-location of the next object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function never handles an extra operand but provides compatibility
    for an old (exposed) API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [`PyArray_MapIterArray`](#c.PyArray_MapIterArray "PyArray_MapIterArray")
    but with an additional `copy_if_overlap` argument. If `copy_if_overlap != 0`,
    checks if `a` has memory overlap with any of the arrays in `index` and with `extra_op`,
    and make copies as appropriate to avoid problems if the input is modified during
    the iteration. `iter->array` may contain a copied array (WRITEBACKIFCOPY set).
  prefs: []
  type: TYPE_NORMAL
- en: Array Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: This function steals a reference to *arr*.
  prefs: []
  type: TYPE_NORMAL
- en: This function checks to see if *arr* is a 0-dimensional array and, if so, returns
    the appropriate array scalar. It should be used whenever 0-dimensional arrays
    could be returned to Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: Return an array scalar object of the given *dtype* by **copying** from memory
    pointed to by *data*. *base* is expected to be the array object that is the owner
    of the data. *base* is required if *dtype* is a `void` scalar, or if the `NPY_USE_GETITEM`
    flag is set and it is known that the `getitem` method uses the `arr` argument
    without checking if it is `NULL`. Otherwise *base* may be `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: If the data is not in native byte order (as indicated by `dtype->byteorder`)
    then this function will byteswap the data, because array scalars are always in
    correct machine-byte order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: Return an array scalar object of the type and itemsize indicated by the array
    object *arr* copied from the memory pointed to by *data* and swapping if the data
    in *arr* is not in machine byte-order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: Return a 0-dimensional array of type determined by *outcode* from *scalar* which
    should be an array-scalar object. If *outcode* is NULL, then the type is determined
    from *scalar*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: Return in *ctypeptr* a pointer to the actual value in an array scalar. There
    is no error checking so *scalar* must be an array-scalar object, and ctypeptr
    must have enough space to hold the correct type. For flexible-sized types, a pointer
    to the data is copied into the memory of *ctypeptr*, for all other types, the
    actual data is copied into the address pointed to by *ctypeptr*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: Return the data (cast to the data type indicated by *outcode*) from the array-scalar,
    *scalar*, into the memory pointed to by *ctypeptr* (which must be large enough
    to handle the incoming memory).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: Returns a scalar type-object from a type-number, *type* . Equivalent to [`PyArray_DescrFromType`](#c.PyArray_DescrFromType
    "PyArray_DescrFromType") (*type*)->typeobj except for reference counting and error-checking.
    Returns a new reference to the typeobject on success or `NULL` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: See the function [`PyArray_MinScalarType`](#c.PyArray_MinScalarType "PyArray_MinScalarType")
    for an alternative mechanism introduced in NumPy 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Return the kind of scalar represented by *typenum* and the array in **arr* (if
    *arr* is not `NULL` ). The array is assumed to be rank-0 and only used if *typenum*
    represents a signed integer. If *arr* is not `NULL` and the first element is negative
    then [`NPY_INTNEG_SCALAR`](#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR "NPY_INTNEG_SCALAR")
    is returned, otherwise [`NPY_INTPOS_SCALAR`](#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR
    "NPY_INTPOS_SCALAR") is returned. The possible return values are the enumerated
    values in [`NPY_SCALARKIND`](#c.NPY_SCALARKIND "NPY_SCALARKIND").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: See the function [`PyArray_ResultType`](#c.PyArray_ResultType "PyArray_ResultType")
    for details of NumPy type promotion, updated in NumPy 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Implements the rules for scalar coercion. Scalars are only silently coerced
    from thistype to neededtype if this function returns nonzero. If scalar is [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR"), then this function is equivalent to [`PyArray_CanCastSafely`](#c.PyArray_CanCastSafely
    "PyArray_CanCastSafely"). The rule is that scalars of the same KIND can be coerced
    into arrays of the same KIND. This rule means that high-precision scalars will
    never cause low-precision arrays of the same KIND to be upcast.
  prefs: []
  type: TYPE_NORMAL
- en: Data-type descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Data-type objects must be reference counted so be aware of the action on the
    data-type reference of different C-API calls. The standard rule is that when a
    data-type object is returned it is a new reference. Functions that take [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* objects and return arrays steal references to the data-type
    their inputs unless otherwise noted. Therefore, you must own a reference to any
    data-type object used as input to such a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates as true if *obj* is a data-type object ( [PyArray_Descr](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr")* ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: Return a new data-type object copied from *obj* (the fields reference is just
    updated so that the new object points to the same fields dictionary if any).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: Create a new data-type object from the built-in (or user-registered) data-type
    indicated by *typenum*. All builtin types should not have any of their fields
    changed. This creates a new copy of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr
    "PyArray_Descr") structure so that you can fill it in as appropriate. This function
    is especially needed for flexible data-types which need to have a new elsize member
    in order to be meaningful in array construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: Create a new data-type object with the byteorder set according to *newendian*.
    All referenced data-type objects (in subdescr and fields members of the data-type
    object) are also changed (recursively).
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of *newendian* is one of these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: If a byteorder of [`NPY_IGNORE`](#c.NPY_IGNORE "NPY_IGNORE") is encountered
    it is left alone. If newendian is [`NPY_SWAP`](#c.NPY_SWAP "NPY_SWAP"), then all
    byte-orders are swapped. Other valid newendian values are [`NPY_NATIVE`](#c.NPY_NATIVE
    "NPY_NATIVE"), [`NPY_LITTLE`](#c.NPY_LITTLE "NPY_LITTLE"), and [`NPY_BIG`](#c.NPY_BIG
    "NPY_BIG") which all cause the returned data-typed descriptor (and all it’s referenced
    data-type descriptors) to have the corresponding byte- order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: Determine an appropriate data-type object from the object *op* (which should
    be a “nested” sequence object) and the minimum data-type descriptor mintype (which
    can be `NULL` ). Similar in behavior to array(*op*).dtype. Don’t confuse this
    function with [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter").
    This function essentially looks at all the objects in the (nested) sequence and
    determines the data-type from the elements it finds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: Return a data-type object from an array-scalar object. No checking is done to
    be sure that *scalar* is an array scalar. If no suitable data-type can be determined,
    then a data-type of [`NPY_OBJECT`](dtype.html#c.NPY_TYPES.NPY_OBJECT "NPY_OBJECT")
    is returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: Returns a data-type object corresponding to *typenum*. The *typenum* can be
    one of the enumerated types, a character code for one of the enumerated types,
    or a user-defined type. If you want to use a flexible size array, then you need
    to `flexible typenum` and set the results `elsize` parameter to the desired size.
    The typenum is one of the [`NPY_TYPES`](dtype.html#c.NPY_TYPES "NPY_TYPES").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    A large number of Python objects can be converted to data-type objects. See [Data
    type objects (dtype)](../arrays.dtypes.html#arrays-dtypes) for a complete description.
    This version of the converter converts None objects to a [`NPY_DEFAULT_TYPE`](dtype.html#c.NPY_TYPES.NPY_DEFAULT_TYPE
    "NPY_DEFAULT_TYPE") data-type object. This function can be used with the “O&”
    character code in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: Convert any compatible Python object, *obj*, to a data-type object in *dtype*.
    This version of the converter converts None objects so that the returned data-type
    is `NULL`. This function can also be used with the “O&” character in PyArg_ParseTuple
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: Like [`PyArray_DescrConverter`](#c.PyArray_DescrConverter "PyArray_DescrConverter")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: Like [`PyArray_DescrConverter2`](#c.PyArray_DescrConverter2 "PyArray_DescrConverter2")
    except it aligns C-struct-like objects on word-boundaries as the compiler would.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: Take the fields dictionary, *dict*, such as the one attached to a data-type
    object and construct an ordered-list of field names such as is stored in the names
    field of the [`PyArray_Descr`](types-and-structures.html#c.PyArray_Descr "PyArray_Descr")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Other conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  prefs: []
  type: TYPE_NORMAL
- en: For use with [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of these functions can be used in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)") (…) with the “O&” format specifier to automatically convert
    any Python object to the required C-object. All of these functions return [`NPY_SUCCEED`](#c.NPY_SUCCEED
    "NPY_SUCCEED") if successful and [`NPY_FAIL`](#c.NPY_FAIL "NPY_FAIL") if not.
    The first argument to all of these function is a Python object. The second argument
    is the **address** of the C-type to convert the Python object to.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to understand what steps you should take to manage the memory when using
    these conversion functions. These functions can require freeing memory, and/or
    altering the reference counts of specific objects based on your use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object to a [`PyArrayObject`](types-and-structures.html#c.PyArrayObject
    "PyArrayObject"). If [`PyArray_Check`](#c.PyArray_Check "PyArray_Check") (*obj*)
    is TRUE then its reference count is incremented and a reference placed in *address*.
    If *obj* is not an array, then convert it to an array using [`PyArray_FromAny`](#c.PyArray_FromAny
    "PyArray_FromAny") . No matter what is returned, you must DECREF the object returned
    by this routine in *address* when you are done with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: This is a default converter for output arrays given to functions. If *obj* is
    [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")
    or `NULL`, then **address* will be `NULL` but the call will succeed. If [`PyArray_Check`](#c.PyArray_Check
    "PyArray_Check") ( *obj*) is TRUE then it is returned in **address* without incrementing
    its reference count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence, *obj*, smaller than [`NPY_MAXDIMS`](#c.NPY_MAXDIMS
    "NPY_MAXDIMS") to a C-array of [`npy_intp`](dtype.html#c.npy_intp "npy_intp").
    The Python object could also be a single number. The *seq* variable is a pointer
    to a structure with members ptr and len. On successful return, *seq* ->ptr contains
    a pointer to memory that must be freed, by calling [`PyDimMem_FREE`](#c.PyDimMem_FREE
    "PyDimMem_FREE"), to avoid a memory leak. The restriction on memory size allows
    this converter to be conveniently used for sequences intended to be interpreted
    as array shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, with a (single-segment) buffer interface to
    a variable with members that detail the object’s use of its chunk of memory. The
    *buf* variable is a pointer to a structure with base, ptr, len, and flags members.
    The [`PyArray_Chunk`](types-and-structures.html#c.PyArray_Chunk "PyArray_Chunk")
    structure is binary compatible with the Python’s buffer object (through its len
    member on 32-bit platforms and its ptr member on 64-bit platforms). On return,
    the base member is set to *obj* (or its base if *obj* is already a buffer object
    pointing to another object). If you need to hold on to the memory be sure to INCREF
    the base member. The chunk of memory is pointed to by *buf* ->ptr member and has
    length *buf* ->len. The flags member of *buf* is [`NPY_ARRAY_ALIGNED`](#c.NPY_ARRAY_ALIGNED
    "NPY_ARRAY_ALIGNED") with the [`NPY_ARRAY_WRITEABLE`](#c.NPY_ARRAY_WRITEABLE "NPY_ARRAY_WRITEABLE")
    flag set if *obj* has a writeable buffer interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: Convert a Python object, *obj*, representing an axis argument to the proper
    value for passing to the functions that take an integer axis. Specifically, if
    *obj* is None, *axis* is set to [`NPY_MAXDIMS`](#c.NPY_MAXDIMS "NPY_MAXDIMS")
    which is interpreted correctly by the C-API functions that take axis arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python object, *obj*, to [`NPY_TRUE`](#c.NPY_TRUE "NPY_TRUE") or
    [`NPY_FALSE`](#c.NPY_FALSE "NPY_FALSE"), and place the result in *value*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert Python strings into the corresponding byte-order character: ‘>’, ‘<’,
    ‘s’, ‘=’, or ‘|’.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_QUICKSORT`](#c.NPY_SORTKIND.NPY_QUICKSORT
    "NPY_QUICKSORT") (starts with ‘q’ or ‘Q’), [`NPY_HEAPSORT`](#c.NPY_SORTKIND.NPY_HEAPSORT
    "NPY_HEAPSORT") (starts with ‘h’ or ‘H’), [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") (starts with ‘m’ or ‘M’) or [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT
    "NPY_STABLESORT") (starts with ‘t’ or ‘T’). [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other for backwards compatibility and may refer to one of
    several stable sorting algorithms depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: Convert Python strings into one of [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT") (starts with ‘l’ or ‘L’), or [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT") (starts with ‘r’ or ‘R’).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘C’, ‘F’, ‘A’, and ‘K’ into the [`NPY_ORDER`](#c.NPY_ORDER
    "NPY_ORDER") enumeration [`NPY_CORDER`](#c.NPY_ORDER.NPY_CORDER "NPY_CORDER"),
    [`NPY_FORTRANORDER`](#c.NPY_ORDER.NPY_FORTRANORDER "NPY_FORTRANORDER"), [`NPY_ANYORDER`](#c.NPY_ORDER.NPY_ANYORDER
    "NPY_ANYORDER"), and [`NPY_KEEPORDER`](#c.NPY_ORDER.NPY_KEEPORDER "NPY_KEEPORDER").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, and ‘unsafe’
    into the [`NPY_CASTING`](#c.NPY_CASTING "NPY_CASTING") enumeration [`NPY_NO_CASTING`](#c.NPY_CASTING.NPY_NO_CASTING
    "NPY_NO_CASTING"), [`NPY_EQUIV_CASTING`](#c.NPY_CASTING.NPY_EQUIV_CASTING "NPY_EQUIV_CASTING"),
    [`NPY_SAFE_CASTING`](#c.NPY_CASTING.NPY_SAFE_CASTING "NPY_SAFE_CASTING"), [`NPY_SAME_KIND_CASTING`](#c.NPY_CASTING.NPY_SAME_KIND_CASTING
    "NPY_SAME_KIND_CASTING"), and [`NPY_UNSAFE_CASTING`](#c.NPY_CASTING.NPY_UNSAFE_CASTING
    "NPY_UNSAFE_CASTING").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: Convert the Python strings ‘clip’, ‘wrap’, and ‘raise’ into the [`NPY_CLIPMODE`](#c.NPY_CLIPMODE
    "NPY_CLIPMODE") enumeration [`NPY_CLIP`](#c.NPY_CLIPMODE.NPY_CLIP "NPY_CLIP"),
    [`NPY_WRAP`](#c.NPY_CLIPMODE.NPY_WRAP "NPY_WRAP"), and [`NPY_RAISE`](#c.NPY_CLIPMODE.NPY_RAISE
    "NPY_RAISE").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: Converts either a sequence of clipmodes or a single clipmode into a C array
    of [`NPY_CLIPMODE`](#c.NPY_CLIPMODE "NPY_CLIPMODE") values. The number of clipmodes
    *n* must be known before calling this function. This function is provided to help
    functions allow a different clipmode for each dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Other conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert all kinds of Python objects (including arrays and array scalars) to
    a standard integer. On error, -1 is returned and an exception set. You may find
    useful the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: Convert all kinds of Python objects (including arrays and array scalars) to
    a (platform-pointer-sized) integer. On error, -1 is returned and an exception
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: Convert any Python sequence (or single Python number) passed in as *seq* to
    (up to) *maxvals* pointer-sized integers and place them in the *vals* array. The
    sequence can be smaller then *maxvals* as the number of converted objects is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: Convert typestring characters (with *itemsize*) to basic enumerated data types.
    The typestring character corresponding to signed and unsigned integers, floating
    point numbers, and complex-floating point numbers are recognized and converted.
    Other values of gentype are returned. This function can be used to convert, for
    example, the string ‘f4’ to [`NPY_FLOAT32`](dtype.html#c.NPY_TYPES.NPY_FLOAT32
    "NPY_FLOAT32").
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Importing the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, coolhelper.c would contain at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, these #defines work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the API Version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Internal Flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  prefs: []
  type: TYPE_NORMAL
- en: Threading support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: Group 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Group 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never use semicolons after the threading support macros.
  prefs: []
  type: TYPE_NORMAL
- en: Priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: Default priority for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: Default subtype priority.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: Default scalar priority (very small)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: Default buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: Default size of the user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: Smallest size of user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: Largest size allowed for the user-settable buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Other constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: The number of floating-point types
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of dimensions allowed in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of array arguments that can be used in functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 0 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 1 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: Returns the reference count of any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order if all the inputs are Fortran, C otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: C order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: The default for most operations, raises an exception if an index is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: Clips an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: Wraps an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the selection algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: Only allow identical types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: Allow identical and casts involving byte swapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: Allow any cast, no matter what kind of data loss may occur.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to make use of the C-API from another extension module, the [`import_array`](#c.import_array
    "import_array") function must be called. If the extension module is self-contained
    in a single .c file, then that is all that needs to be done. If, however, the
    extension module involves multiple files where the C-API is needed then some additional
    steps must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: This function must be called in the initialization section of a module that
    will make use of the C-API. It imports the module where the function-pointer table
    is stored and points the correct variable to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these #defines you can use the C-API in multiple files for a single extension
    module. In each file you must define [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL
    "PY_ARRAY_UNIQUE_SYMBOL") to some name that will hold the C-API (*e.g.* myextension_ARRAY_API).
    This must be done **before** including the numpy/arrayobject.h file. In the module
    initialization routine you call [`import_array`](#c.import_array "import_array").
    In addition, in the files that do not have the module initialization sub_routine
    define [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") prior to including
    numpy/arrayobject.h.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled
    and linked into a single extension module. Suppose coolmodule.c contains the required
    initcool module initialization function (with the import_array() function called).
    Then, coolmodule.c would have at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, coolhelper.c would contain at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also put the common two last lines into an extension-local header file
    as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, these #defines work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither is defined, the C-API is declared to be `static void**`, so it is
    only visible within the compilation unit that #includes numpy/arrayobject.h.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, but [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is
    not, the C-API is declared to be `void**`, so that it will also be visible to
    other compilation units.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If [`NO_IMPORT_ARRAY`](#c.NO_IMPORT_ARRAY "NO_IMPORT_ARRAY") is #defined, regardless
    of whether [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is, the C-API is declared to be `extern void**`, so it is expected to be defined
    in another compilation unit.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever [`PY_ARRAY_UNIQUE_SYMBOL`](#c.PY_ARRAY_UNIQUE_SYMBOL "PY_ARRAY_UNIQUE_SYMBOL")
    is #defined, it also changes the name of the variable holding the C-API, which
    defaults to `PyArray_API`, to whatever the macro is #defined to.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the API Version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because python extensions are not used in the same way as usual libraries on
    most platforms, some errors cannot be automatically detected at build time or
    even runtime. For example, if you build an extension using a function available
    only for numpy >= 1.3.0, and you import the extension later with numpy 1.2, you
    will not get an import error (but almost certainly a segmentation fault when calling
    the function). That’s why several functions are provided to check for numpy versions.
    The macros [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION
    "NPY_FEATURE_VERSION") corresponds to the numpy version used to build the extension,
    whereas the versions returned by the functions [`PyArray_GetNDArrayCVersion`](#c.PyArray_GetNDArrayCVersion
    "PyArray_GetNDArrayCVersion") and [`PyArray_GetNDArrayCFeatureVersion`](#c.PyArray_GetNDArrayCFeatureVersion
    "PyArray_GetNDArrayCFeatureVersion") corresponds to the runtime numpy’s version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for ABI and API compatibilities can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") != `PyArray_GetNDArrayCVersion()`,
    the extension has to be recompiled (ABI incompatibility).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION") == `PyArray_GetNDArrayCVersion()`
    and [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") <= `PyArray_GetNDArrayCFeatureVersion()`
    means backward compatible changes.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ABI incompatibility is automatically detected in every numpy’s version. API
    incompatibility detection was added in numpy 1.4.0\. If you want to supported
    many different numpy versions with one extension binary, you have to build your
    extension with the lowest [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION")
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the ndarray object (check to see if this variable is
    defined to guarantee the `numpy/arrayobject.h` header is being used).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: The current version of the C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: This just returns the value [`NPY_VERSION`](#c.NPY_VERSION "NPY_VERSION"). [`NPY_VERSION`](#c.NPY_VERSION
    "NPY_VERSION") changes whenever a backward incompatible change at the ABI level.
    Because it is in the C-API, however, comparing the output of this function from
    the value defined in the current header gives a way to test if the C-API has changed
    thus requiring a re-compilation of extension modules that use the C-API. This
    is automatically checked in the function [`import_array`](#c.import_array "import_array").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: This just returns the value [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION").
    [`NPY_FEATURE_VERSION`](#c.NPY_FEATURE_VERSION "NPY_FEATURE_VERSION") changes
    whenever the API changes (e.g. a function is added). A changed value does not
    always require a recompile.
  prefs: []
  type: TYPE_NORMAL
- en: Internal Flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy stores an internal table of Python callable objects that are used to
    implement arithmetic operations for arrays as well as certain array calculation
    methods. This function allows the user to replace any or all of these Python objects
    with their own versions. The keys of the dictionary, *dict*, are the named functions
    to replace and the paired value is the Python callable object to use. Care should
    be taken that the function used to replace an internal array operation does not
    itself call back to that internal array operation (unless you have designed the
    function to handle that), or an unchecked infinite recursion can result (possibly
    causing program crash). The key names that represent operations that can be replaced
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**add**, **subtract**, **multiply**, **divide**, **remainder**, **power**,
    **square**, **reciprocal**, **ones_like**, **sqrt**, **negative**, **positive**,
    **absolute**, **invert**, **left_shift**, **right_shift**, **bitwise_and**, **bitwise_xor**,
    **bitwise_or**, **less**, **less_equal**, **equal**, **not_equal**, **greater**,
    **greater_equal**, **floor_divide**, **true_divide**, **logical_or**, **logical_and**,
    **floor**, **ceil**, **maximum**, **minimum**, **rint**.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: These functions are included here because they are used at least once in the
    array object’s methods. The function returns -1 (without setting a Python Error)
    if one of the objects being assigned is not callable.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: Return a Python dictionary containing the callable Python objects stored in
    the internal arithmetic operation table. The keys of this dictionary are given
    in the explanation for [`PyArray_SetNumericOps`](#c.PyArray_SetNumericOps "PyArray_SetNumericOps").
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated since version 1.16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: This function allows you to alter the tp_str and tp_repr methods of the array
    object to any Python function. Thus you can alter what happens for all arrays
    when str(arr) or repr(arr) is called from Python. The function to be called is
    passed in as *op*. If *repr* is non-zero, then this function will be called in
    response to repr(arr), otherwise the function will be called in response to str(arr).
    No check on whether or not *op* is callable is performed. The callable passed
    in to *op* should expect an array argument and should return a string to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate memory. These macros are used internally
    to create arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: Macros to allocate, free, and reallocate dimension and strides memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: These macros use different memory allocators, depending on the constant [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM"). The system malloc is used when [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM
    "NPY_USE_PYMEM") is 0, if [`NPY_USE_PYMEM`](#c.PyArray_realloc.NPY_USE_PYMEM "NPY_USE_PYMEM")
    is 1, then the Python memory allocator is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. It then copies `obj->data`
    to *obj->base->data*, and returns the error state of the copy operation. This
    is the opposite of [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called once you are finished
    with `obj`, just before `Py_DECREF(obj)`. It may be called multiple times, or
    with `NULL` input. See also [`PyArray_DiscardWritebackIfCopy`](#c.PyArray_DiscardWritebackIfCopy
    "PyArray_DiscardWritebackIfCopy").
  prefs: []
  type: TYPE_NORMAL
- en: Returns 0 if nothing was done, -1 on error, and 1 if action was taken.
  prefs: []
  type: TYPE_NORMAL
- en: Threading support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These macros are only meaningful if [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") evaluates True during compilation of the extension module.
    Otherwise, these macros are equivalent to whitespace. Python uses a single Global
    Interpreter Lock (GIL) for each Python process so that only a single thread may
    execute at a time (even on multi-cpu machines). When calling out to a compiled
    function that may take time to compute (and does not have side-effects for other
    threads like updated global variables), the GIL should be released so that other
    Python threads can run while the time-consuming calculations are performed. This
    can be accomplished using two groups of macros. Typically, if one macro in a group
    is used in a code block, all of them must be used in the same code block. Currently,
    [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS "NPY_ALLOW_THREADS") is defined to
    the python-defined [`WITH_THREADS`](#c.WITH_THREADS "WITH_THREADS") constant unless
    the environment variable `NPY_NOSMP` is set in which case [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") is defined to be 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: Group 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1212]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Group 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never use semicolons after the threading support macros.
  prefs: []
  type: TYPE_NORMAL
- en: Group 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to call code that may take some time but does not use any
    Python C-API calls. Thus, the GIL should be released during its calculation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Equivalent to [`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS
    "(in Python v3.11)") except it uses [`NPY_ALLOW_THREADS`](#c.NPY_ALLOW_THREADS
    "NPY_ALLOW_THREADS") to determine if the macro if replaced with white-space or
    not.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area. This macro sets up the variable needed
    for storing the Python state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right before code that does not need the Python interpreter (no Python
    C-API calls). This macro saves the Python state and releases the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place right after code that does not need the Python interpreter. This macro
    acquires the GIL and restores the Python state from the saved variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *dtype* does not contain arbitrary Python
    objects which may need the Python interpreter during execution of the loop.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to regain the GIL in situations where it was released using the BEGIN
    form of this macro.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Useful to release the GIL only if *loop_size* exceeds a minimum threshold, currently
    set to 500\. Should be matched with a [`NPY_END_THREADS`](#c.NPY_END_THREADS "NPY_END_THREADS")
    to regain the GIL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Group 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This group is used to re-acquire the Python GIL after it has been released.
    For example, suppose the GIL has been released (using the previous calls), and
    then some path in the code (perhaps in a different subroutine) requires use of
    the Python C-API, then these macros are useful to acquire the GIL. These macros
    accomplish essentially a reverse of the previous three (acquire the LOCK saving
    what state it had) and then re-release it with the saved state.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place in the variable declaration area to set up the necessary variable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place before code that needs to call the Python C-API (when it is known that
    the GIL has already been released).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Place after code that needs to call the Python C-API (to re-release the GIL).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never use semicolons after the threading support macros.
  prefs: []
  type: TYPE_NORMAL
- en: Priority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: Default priority for arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: Default subtype priority.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: Default scalar priority (very small)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`__array_priority__`](../arrays.classes.html#numpy.class.__array_priority__
    "numpy.class.__array_priority__") attribute (converted to a double) of *obj* or
    *def* if no attribute of that name exists. Fast returns that avoid the attribute
    lookup are provided for objects of type [`PyArray_Type`](types-and-structures.html#c.PyArray_Type
    "PyArray_Type").
  prefs: []
  type: TYPE_NORMAL
- en: Default buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: Default size of the user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: Smallest size of user-settable internal buffers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: Largest size allowed for the user-settable buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Other constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: The number of floating-point types
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of dimensions allowed in arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: The maximum number of array arguments that can be used in functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 0 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: Defined as 1 for use with Bool.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: The return value of failed converter functions which are called using the “O&”
    syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: The return value of successful converter functions which are called using the
    “O&” syntax in [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple
    "(in Python v3.11)")-like functions.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates as True if arrays *a1* and *a2* have the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: Returns the maximum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: Returns the minimum of *a* and *b*. If (*a*) or (*b*) are expressions they are
    evaluated twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: 'Implements the complex comparisons between two complex numbers (structures
    with a real and imag member) using NumPy’s definition of the ordering which is
    lexicographic: comparing the real parts first and then the complex parts if the
    real parts are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: Returns the reference count of any Python object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: If `obj->flags` has [`NPY_ARRAY_WRITEBACKIFCOPY`](#c.NPY_ARRAY_WRITEBACKIFCOPY
    "NPY_ARRAY_WRITEBACKIFCOPY"), this function clears the flags, *DECREF* s *obj->base*
    and makes it writeable, and sets `obj->base` to NULL. In contrast to [`PyArray_ResolveWritebackIfCopy`](#c.PyArray_ResolveWritebackIfCopy
    "PyArray_ResolveWritebackIfCopy") it makes no attempt to copy the data from *obj->base*.
    This undoes [`PyArray_SetWritebackIfCopyBase`](#c.PyArray_SetWritebackIfCopyBase
    "PyArray_SetWritebackIfCopyBase"). Usually this is called after an error when
    you are finished with `obj`, just before `Py_DECREF(obj)`. It may be called multiple
    times, or with `NULL` input.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: A special variable-type which can take on different values to indicate the sorting
    algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: Used as an alias of [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT "NPY_MERGESORT")
    and vica versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of sorts. It is fixed at three by the need for backwards
    compatibility, and consequently [`NPY_MERGESORT`](#c.NPY_SORTKIND.NPY_MERGESORT
    "NPY_MERGESORT") and [`NPY_STABLESORT`](#c.NPY_SORTKIND.NPY_STABLESORT "NPY_STABLESORT")
    are aliased to each other and may refer to one of several stable sorting algorithms
    depending on the data type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: 'A special variable type indicating the number of “kinds” of scalars distinguished
    in determining scalar-coercion rules. This variable can take on the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: Defined to be the number of scalar kinds (not including [`NPY_NOSCALAR`](#c.NPY_SCALARKIND.NPY_NOSCALAR
    "NPY_NOSCALAR")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: An enumeration type indicating the element order that an array should be interpreted
    in. When a brand new array is created, generally only **NPY_CORDER** and **NPY_FORTRANORDER**
    are used, whereas when one or more inputs are provided, the order can be based
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order if all the inputs are Fortran, C otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: C order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: An order as close to the order of the inputs as possible, even if the input
    is in neither C nor Fortran order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the kind of clipping that should be applied in certain
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: The default for most operations, raises an exception if an index is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: Clips an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: Wraps an index to the valid range if it is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating whether the index returned should be that of the
    first suitable location (if [`NPY_SEARCHLEFT`](#c.NPY_SEARCHSIDE.NPY_SEARCHLEFT
    "NPY_SEARCHLEFT")) or of the last (if [`NPY_SEARCHRIGHT`](#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT
    "NPY_SEARCHRIGHT")).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: A variable type indicating the selection algorithm being used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.6.
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration type indicating how permissive data conversions should be. This
    is used by the iterator added in NumPy 1.6, and is intended to be used more broadly
    in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: Only allow identical types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: Allow identical and casts involving byte swapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: Only allow casts which will not cause values to be rounded, truncated, or otherwise
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: Allow any safe casts, and casts between types of the same kind. For example,
    float64 -> float32 is permitted with this rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: Allow any cast, no matter what kind of data loss may occur.
  prefs: []
  type: TYPE_NORMAL
