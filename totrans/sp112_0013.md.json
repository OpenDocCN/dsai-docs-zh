["```py\n>>> from scipy.spatial import Delaunay\n>>> import numpy as np\n>>> points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]])\n>>> tri = Delaunay(points) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> plt.triplot(points[:,0], points[:,1], tri.simplices)\n>>> plt.plot(points[:,0], points[:,1], 'o') \n```", "```py\n>>> for j, p in enumerate(points):\n...     plt.text(p[0]-0.03, p[1]+0.03, j, ha='right') # label the points\n>>> for j, s in enumerate(tri.simplices):\n...     p = points[s].mean(axis=0)\n...     plt.text(p[0], p[1], '#%d' % j, ha='center') # label triangles\n>>> plt.xlim(-0.5, 1.5); plt.ylim(-0.5, 1.5)\n>>> plt.show() \n```", "```py\n>>> i = 1\n>>> tri.simplices[i,:]\narray([3, 1, 0], dtype=int32)\n>>> points[tri.simplices[i,:]]\narray([[ 1\\. ,  1\\. ],\n [ 0\\. ,  1.1],\n [ 0\\. ,  0\\. ]]) \n```", "```py\n>>> tri.neighbors[i]\narray([-1,  0, -1], dtype=int32) \n```", "```py\n>>> points[tri.simplices[i, 1]]\narray([ 0\\. ,  1.1]) \n```", "```py\n>>> points = np.array([[0, 0], [0, 1], [1, 0], [1, 1], [1, 1]])\n>>> tri = Delaunay(points)\n>>> np.unique(tri.simplices.ravel())\narray([0, 1, 2, 3], dtype=int32) \n```", "```py\n>>> tri.coplanar\narray([[4, 0, 3]], dtype=int32) \n```", "```py\n>>> tri = Delaunay(points, qhull_options=\"QJ Pp\")\n>>> points[tri.simplices]\narray([[[1, 0],\n [1, 1],\n [0, 0]],\n [[1, 1],\n [1, 1],\n [1, 0]],\n [[1, 1],\n [0, 1],\n [0, 0]],\n [[0, 1],\n [1, 1],\n [1, 1]]]) \n```", "```py\n>>> from scipy.spatial import ConvexHull\n>>> rng = np.random.default_rng()\n>>> points = rng.random((30, 2))   # 30 random points in 2-D\n>>> hull = ConvexHull(points) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(points[:,0], points[:,1], 'o')\n>>> for simplex in hull.simplices:\n...     plt.plot(points[simplex,0], points[simplex,1], 'k-')\n>>> plt.show() \n```", "```py\n>>> from scipy.spatial import KDTree\n>>> points = np.array([[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2],\n...                    [2, 0], [2, 1], [2, 2]])\n>>> tree = KDTree(points)\n>>> tree.query([0.1, 0.1])\n(0.14142135623730953, 0) \n```", "```py\n>>> x = np.linspace(-0.5, 2.5, 31)\n>>> y = np.linspace(-0.5, 2.5, 33)\n>>> xx, yy = np.meshgrid(x, y)\n>>> xy = np.c_[xx.ravel(), yy.ravel()]\n>>> import matplotlib.pyplot as plt\n>>> dx_half, dy_half = np.diff(x[:2])[0] / 2., np.diff(y[:2])[0] / 2.\n>>> x_edges = np.concatenate((x - dx_half, [x[-1] + dx_half]))\n>>> y_edges = np.concatenate((y - dy_half, [y[-1] + dy_half]))\n>>> plt.pcolormesh(x_edges, y_edges, tree.query(xy)[1].reshape(33, 31), shading='flat')\n>>> plt.plot(points[:,0], points[:,1], 'ko')\n>>> plt.show() \n```", "```py\n>>> from scipy.spatial import Voronoi\n>>> vor = Voronoi(points)\n>>> vor.vertices\narray([[0.5, 0.5],\n [0.5, 1.5],\n [1.5, 0.5],\n [1.5, 1.5]]) \n```", "```py\n>>> vor.regions\n[[], [-1, 0], [-1, 1], [1, -1, 0], [3, -1, 2], [-1, 3], [-1, 2], [0, 1, 3, 2], [2, -1, 0], [3, -1, 1]] \n```", "```py\n>>> vor.ridge_vertices\n[[-1, 0], [-1, 0], [-1, 1], [-1, 1], [0, 1], [-1, 3], [-1, 2], [2, 3], [-1, 3], [-1, 2], [1, 3], [0, 2]] \n```", "```py\n>>> vor.ridge_points\narray([[0, 3],\n [0, 1],\n [2, 5],\n [2, 1],\n [1, 4],\n [7, 8],\n [7, 6],\n [7, 4],\n [8, 5],\n [6, 3],\n [4, 5],\n [4, 3]], dtype=int32) \n```", "```py\n>>> plt.plot(points[:, 0], points[:, 1], 'o')\n>>> plt.plot(vor.vertices[:, 0], vor.vertices[:, 1], '*')\n>>> plt.xlim(-1, 3); plt.ylim(-1, 3) \n```", "```py\n>>> for simplex in vor.ridge_vertices:\n...     simplex = np.asarray(simplex)\n...     if np.all(simplex >= 0):\n...         plt.plot(vor.vertices[simplex, 0], vor.vertices[simplex, 1], 'k-') \n```", "```py\n>>> center = points.mean(axis=0)\n>>> for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):\n...     simplex = np.asarray(simplex)\n...     if np.any(simplex < 0):\n...         i = simplex[simplex >= 0][0] # finite end Voronoi vertex\n...         t = points[pointidx[1]] - points[pointidx[0]]  # tangent\n...         t = t / np.linalg.norm(t)\n...         n = np.array([-t[1], t[0]]) # normal\n...         midpoint = points[pointidx].mean(axis=0)\n...         far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * 100\n...         plt.plot([vor.vertices[i,0], far_point[0]],\n...                  [vor.vertices[i,1], far_point[1]], 'k--')\n>>> plt.show() \n```", "```py\n>>> import numpy as np\n>>> from scipy import spatial\n>>> import matplotlib.pyplot as plt \n```", "```py\n>>> def mandala(n_iter, n_points, radius):\n...  \"\"\"Creates a mandala figure using Voronoi tessellations.\n...\n...     Parameters\n...     ----------\n...     n_iter : int\n...         Number of iterations, i.e. how many times the equidistant points will\n...         be generated.\n...     n_points : int\n...         Number of points to draw per iteration.\n...     radius : scalar\n...         The radial expansion factor.\n...\n...     Returns\n...     -------\n...     fig : matplotlib.Figure instance\n...\n...     Notes\n...     -----\n...     This code is adapted from the work of Audrey Roy Greenfeld [1]_ and Carlos\n...     Focil-Espinosa [2]_, who created beautiful mandalas with Python code.  That\n...     code in turn was based on Antonio Sánchez Chinchón's R code [3]_.\n...\n...     References\n...     ----------\n...     .. [1] https://www.codemakesmehappy.com/2019/09/voronoi-mandalas.html\n...\n...     .. [2] https://github.com/CarlosFocil/mandalapy\n...\n...     .. [3] https://github.com/aschinchon/mandalas\n...\n...     \"\"\"\n...     fig = plt.figure(figsize=(10, 10))\n...     ax = fig.add_subplot(111)\n...     ax.set_axis_off()\n...     ax.set_aspect('equal', adjustable='box')\n...\n...     angles = np.linspace(0, 2*np.pi * (1 - 1/n_points), num=n_points) + np.pi/2\n...     # Starting from a single center point, add points iteratively\n...     xy = np.array([[0, 0]])\n...     for k in range(n_iter):\n...         t1 = np.array([])\n...         t2 = np.array([])\n...         # Add `n_points` new points around each existing point in this iteration\n...         for i in range(xy.shape[0]):\n...             t1 = np.append(t1, xy[i, 0] + radius**k * np.cos(angles))\n...             t2 = np.append(t2, xy[i, 1] + radius**k * np.sin(angles))\n...\n...         xy = np.column_stack((t1, t2))\n...\n...     # Create the Mandala figure via a Voronoi plot\n...     spatial.voronoi_plot_2d(spatial.Voronoi(xy), ax=ax)\n...\n...     return fig \n```", "```py\n>>> # Modify the following parameters in order to get different figures\n>>> n_iter = 3\n>>> n_points = 6\n>>> radius = 4 \n```", "```py\n>>> fig = mandala(n_iter, n_points, radius)\n>>> plt.show() \n```"]