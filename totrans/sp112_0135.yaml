- en: scipy.integrate.qmc_quad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.qmc_quad.html#scipy.integrate.qmc_quad](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.integrate.qmc_quad.html#scipy.integrate.qmc_quad)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute an integral in N-dimensions using Quasi-Monte Carlo quadrature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The integrand. Must accept a single argument `x`, an array which specifies the
    point(s) at which to evaluate the scalar-valued integrand, and return the value(s)
    of the integrand. For efficiency, the function should be vectorized to accept
    an array of shape `(d, n_points)`, where `d` is the number of variables (i.e.
    the dimensionality of the function domain) and *n_points* is the number of quadrature
    points, and return an array of shape `(n_points,)`, the integrand at each quadrature
    point.
  prefs: []
  type: TYPE_NORMAL
- en: '**a, b**array-like'
  prefs: []
  type: TYPE_NORMAL
- en: One-dimensional arrays specifying the lower and upper integration limits, respectively,
    of each of the `d` variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**n_estimates, n_points**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: '*n_estimates* (default: 8) statistically independent QMC samples, each of *n_points*
    (default: 1024) points, will be generated by *qrng*. The total number of points
    at which the integrand *func* will be evaluated is `n_points * n_estimates`. See
    Notes for details.'
  prefs: []
  type: TYPE_NORMAL
- en: '**qrng**[`QMCEngine`](scipy.stats.qmc.QMCEngine.html#scipy.stats.qmc.QMCEngine
    "scipy.stats.qmc.QMCEngine"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the QMCEngine from which to sample QMC points. The QMCEngine
    must be initialized to a number of dimensions `d` corresponding with the number
    of variables `x1, ..., xd` passed to *func*. The provided QMCEngine is used to
    produce the first integral estimate. If *n_estimates* is greater than one, additional
    QMCEngines are spawned from the first (with scrambling enabled, if it is an option.)
    If a QMCEngine is not provided, the default [`scipy.stats.qmc.Halton`](scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") will be initialized with the number of dimensions determine
    from the length of *a*.
  prefs: []
  type: TYPE_NORMAL
- en: '**log**boolean, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: When set to True, *func* returns the log of the integrand, and the result object
    contains the log of the integral.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**result**object'
  prefs: []
  type: TYPE_NORMAL
- en: 'A result object with attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: integralfloat
  prefs: []
  type: TYPE_NORMAL
- en: The estimate of the integral.
  prefs: []
  type: TYPE_NORMAL
- en: 'standard_error :'
  prefs: []
  type: TYPE_NORMAL
- en: The error estimate. See Notes for interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Values of the integrand at each of the *n_points* points of a QMC sample are
    used to produce an estimate of the integral. This estimate is drawn from a population
    of possible estimates of the integral, the value of which we obtain depends on
    the particular points at which the integral was evaluated. We perform this process
    *n_estimates* times, each time evaluating the integrand at different scrambled
    QMC points, effectively drawing i.i.d. random samples from the population of integral
    estimates. The sample mean \(m\) of these integral estimates is an unbiased estimator
    of the true value of the integral, and the standard error of the mean \(s\) of
    these estimates may be used to generate confidence intervals using the t distribution
    with `n_estimates - 1` degrees of freedom. Perhaps counter-intuitively, increasing
    *n_points* while keeping the total number of function evaluation points `n_points
    * n_estimates` fixed tends to reduce the actual error, whereas increasing *n_estimates*
    tends to decrease the error estimate.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: QMC quadrature is particularly useful for computing integrals in higher dimensions.
    An example integrand is the probability density function of a multivariate normal
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the integral over the unit hypercube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A two-sided, 99% confidence interval for the integral may be estimated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, the value reported by [`scipy.stats.multivariate_normal`](scipy.stats.multivariate_normal.html#scipy.stats.multivariate_normal
    "scipy.stats.multivariate_normal") is within this range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
