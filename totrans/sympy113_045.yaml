- en: List of active deprecations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动弃用列表
- en: Original text：[https://docs.sympy.org/latest/explanation/active-deprecations.html](https://docs.sympy.org/latest/explanation/active-deprecations.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/explanation/active-deprecations.html](https://docs.sympy.org/latest/explanation/active-deprecations.html)
- en: This pages lists all active deprecations in the SymPy codebase. See the [Deprecation
    Policy](../contributing/deprecations.html#deprecation-policy) page for a description
    of SymPy’s deprecation policy, as well as instructions for contributors on how
    to deprecate things.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面列出了 SymPy 代码库中的所有活动弃用。请参阅[弃用政策](../contributing/deprecations.html#deprecation-policy)页面，了解
    SymPy 的弃用政策说明以及贡献者如何弃用内容的说明。
- en: In particular, the deprecation policy for SymPy is for deprecations to last
    at least **1 year** after the first major release that includes the deprecation.
    After that period, the deprecated functionality may be removed from SymPy, and
    code will need to be updated to use the replacement feature to continue working.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，SymPy 的弃用政策要求在包含弃用功能的首个主要发布版本之后至少保留**1 year**。此后，将可能从 SymPy 中移除弃用功能，需要更新代码以使用替代功能以继续工作。
- en: During the deprecation period, a `SymPyDeprecationWarning` message will be printed
    whenever the deprecated functionality is used. It is recommended for users to
    update their code so that it does not use deprecated functionality, as described
    below for each given deprecation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在弃用期间，每当使用弃用功能时，将打印 `SymPyDeprecationWarning` 消息。建议用户更新其代码，使其不再使用弃用功能，具体方法如下所述，适用于每个给定的弃用。
- en: '## Silencing SymPy Deprecation Warnings'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '## 消除 SymPy 弃用警告'
- en: 'To silence SymPy deprecation warnings, add a filter using the [`warnings`](https://docs.python.org/3/library/warnings.html)
    module. For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除 SymPy 的弃用警告，请使用[`warnings`](https://docs.python.org/3/library/warnings.html)模块添加过滤器。例如：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here `(?s).*<regex matching the warning message>` is a regular expression matching
    the warning message. For example, to filter a warning about `sympy.printing`,
    you might use `message=r"(?s).*sympy\.printing"`. The leading `(?s).*` is there
    because the warnings module matches `message` against the start of the warning
    message, and because typical warning messages span multiple lines.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`(?s).*<regex matching the warning message>`是匹配警告消息的正则表达式。例如，要过滤有关`sympy.printing`的警告，可以使用`message=r"(?s).*sympy\.printing"`。前导的`(?s).*`是因为警告模块会将`message`与警告消息的开头匹配，而典型的警告消息跨越多行。
- en: '`<regex matching your module>` should be a regular expression matching your
    module that uses the deprecated code. It is recommended to include this so that
    you don’t also silence the same warning for unrelated modules.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`<regex matching your module>` 应为与使用弃用代码的模块匹配的正则表达式。建议包括此内容，以避免将相同警告也应用于不相关的模块。'
- en: This same pattern may be used to instead turn `SymPyDeprecationWarning` into
    an error so that you can test that you aren’t using deprecated code. To do this,
    replace `"ignore"` with `"error"` in the above example. You may also omit `message`
    to make this apply to all `SymPyDeprecationWarning` warnings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用相同模式将 `SymPyDeprecationWarning` 替换为错误，以便测试不使用弃用代码。要执行此操作，请在上述示例中将 `"ignore"`
    替换为 `"error"`。您还可以省略 `message`，以便将其应用于所有 `SymPyDeprecationWarning` 警告。
- en: If you are using pytest, you can use the [pytest warnings filtering capabilities](https://docs.pytest.org/en/latest/how-to/capture-warnings.html)
    to either ignore `SymPyDeprecationWarning` or turn them into errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 pytest，可以使用[pytest 警告过滤功能](https://docs.pytest.org/en/latest/how-to/capture-warnings.html)来忽略
    `SymPyDeprecationWarning` 或将其转换为错误。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Python [`-W` flag](https://docs.python.org/3/using/cmdline.html#cmdoption-W)
    and [`PYTHONWARNINGS` environment variable](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONWARNINGS)
    will NOT work to filter SymPy deprecation warnings (see [this blog post](https://nedbatchelder.com/blog/201810/why_warnings_is_mysterious.html)
    by Ned Batchelder and [this SymPy issue](https://github.com/sympy/sympy/issues/15130)
    for details on why). You will need to either add a `warnings` filter as above
    or use pytest to filter SymPy deprecation warnings.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python [`-W` flag](https://docs.python.org/3/using/cmdline.html#cmdoption-W)
    和 [`PYTHONWARNINGS` 环境变量](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONWARNINGS)
    无法用于过滤 SymPy 弃用警告（请参阅 Ned Batchelder 的[此篇博文](https://nedbatchelder.com/blog/201810/why_warnings_is_mysterious.html)和
    SymPy 的[此问题](https://github.com/sympy/sympy/issues/15130)了解详细信息）。您需要添加类似上述的 `warnings`
    过滤器或使用 pytest 来过滤 SymPy 弃用警告。
- en: Version 1.13
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.13
- en: '### Deprecated mechanics Body class'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '### 弃用机制 Body 类'
- en: 'The `Body` class in the `sympy.physics.mechanics` module has been deprecated.
    It was introduced to support the joints framework. However, it causes several
    problems because it represents both rigid bodies and particles. `Body` has now
    been fully replaced by `RigidBody` and `Particle`. Previously, one could create
    a simple rigid body or particle using only the `Body` class:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.physics.mechanics` 模块中的 `Body` 类已被弃用。它最初用于支持关节框架，但由于既表示刚体又表示粒子而导致多种问题。`Body`
    现已完全由 `RigidBody` 和 `Particle` 替代。以前，只需使用 `Body` 类即可创建简单的刚体或粒子：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now they should be created using the `RigidBody` and `Particle` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应使用 `RigidBody` 和 `Particle` 类创建：
- en: '[PRE2]  ### Deprecated mechanics JointsMethod'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]  ### 弃用的力学 JointsMethod'
- en: The `JointsMethod` class in the `sympy.physics.mechanics` module has been deprecated.
    It was introduced to support the joints framework, but it has been fully replaced
    due to limitations in its design. Previously, one could construct as system solely
    consisting out of bodies and joints, which were then parsed by `JointsMethod`
    to a backend, like `KanesMethod` to form the equations of motion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.physics.mechanics` 模块中的 `JointsMethod` 类已被弃用。它最初用于支持关节框架，但由于设计上的限制已被完全替换。以前，可以构建仅由体和关节组成的系统，然后由
    `JointsMethod` 解析到后端，例如 `KanesMethod` 以形成运动方程。'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The replacement of `JointsMethod` is `System`, which can be used to form the
    equations of motion of the same cart pole as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`JointsMethod` 的替代方案是 `System`，可用于形成相同小车摆杆的运动方程，如下所示：'
- en: '[PRE4]  ### Deprecated matrix mixin classes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]  ### 弃用的矩阵混合类'
- en: 'The matrix mixin classes are deprecated. Previously the `Matrix` class (aka
    `MutableDenseMatrix`) was created through an inheritance hierarchy that looked
    like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵混合类已弃用。以前的 `Matrix` 类（又名 `MutableDenseMatrix`）通过继承层次结构创建，看起来像：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As of SymPy 1.13 this has been simplified and all classes above `MatrixBase`are
    merged together so the hierarchy looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SymPy 1.13 起，所有类都已简化，以上 `MatrixBase` 的类被合并在一起，层次结构如下：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The matrix mixin classes like `MatrixRequired` etc are still available because
    downstream code might be subclassing these classes but these are all deprecated
    and will be removed in a future version of SymPy. Subclassing these classes is
    deprecated and anycode that does that should be changed to not subclass them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `MatrixRequired` 等矩阵混合类仍然可用，因为下游代码可能正在对这些类进行子类化，但这些类均已弃用，并将在未来版本的 SymPy 中移除。对这些类的子类化已被弃用，任何这样做的代码应修改为不再子类化它们。
- en: It is also deprecated to use these classes with `isinstance` like `isinstance(M,
    MatrixCommon)`. Any code doing this should be changed to use `isinstance(M, Matrixbase)`
    instead which will also work with previous SymPy versions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `isinstance` 与 `MatrixCommon` 这样的类也已被弃用，例如 `isinstance(M, MatrixCommon)`。任何使用此方法的代码应改为使用
    `isinstance(M, Matrixbase)`，这也适用于先前的 SymPy 版本。
- en: More generally importing anything from the `sympy.matrices.common` or `sympy.matrices.matrices`
    modules in which these classes are defined is deprecated. These modules will be
    removed in a future release of SymPy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，导入 `sympy.matrices.common` 或 `sympy.matrices.matrices` 模块中的任何内容都已弃用，这些模块将在未来的
    SymPy 发布中移除。
- en: 'The reason for this change is that the convoluted inheritance hierarchy made
    it difficult to improve `Matrix` for the majority of users while still providing
    all of these classes that could be subclassed. Since these mixin classes are no
    longer used as part of `Matrix` they no longer serve any function within SymPy
    and the removal of this now unused code will simplify the codebase.  ### The string
    fallback in `sympify()`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变更的原因是复杂的继承层次结构使得很难改进大多数用户的 `Matrix`，同时仍提供可以作为子类的所有这些类。由于这些混合类不再作为 `Matrix`
    的一部分使用，它们在 SymPy 中不再起任何作用，移除现在未使用的代码将简化代码库。### `sympify()` 中的字符串回退
- en: The `sympify` function would previously convert an unrecognized object to a
    string and retry sympification. This was deprecated in SymPy 1.6 and was removed
    in SymPy 1.13.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympify` 函数过去会将未识别的对象转换为字符串并重试 sympification。这在 SymPy 1.6 中已弃用，并在 SymPy 1.13
    中移除。'
- en: The behavior of [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") is that `sympify(expr)` tries various methods to
    try to convert `expr` into a SymPy objects. Previously if all these methods would
    fail, it would take `str(expr)` and try to parse it using [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). This string fallback feature was deprecated
    in SymPy 1.6 and was removed in SymPy 1.13.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    的行为是，`sympify(expr)` 尝试各种方法将 `expr` 转换为 SymPy 对象。以前，如果所有这些方法都失败了，它会取 `str(expr)`
    并尝试使用 [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr") 进行解析。这个字符串回退功能在 SymPy 1.6 中已弃用，并在 SymPy
    1.13 中删除。'
- en: 'This behaviour was problematic for a few reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为存在几个问题：
- en: It could affect performance in major ways. See for instance issues [#18056](https://github.com/sympy/sympy/issues/18056)
    and [#15416](https://github.com/sympy/sympy/issues/15416) where it caused up to
    100x slowdowns. The issue is that SymPy functions automatically call `sympify`
    on their arguments. Whenever a function is passed something that `sympify` doesn’t
    know how to convert to a SymPy object, for instance, a Python function type, it
    passes the string to [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). This is significantly slower than the
    direct conversions that happen by default. This occurs specifically whenever `sympify()`
    is used in library code instead of `_sympify()` (or equivalently `sympify(strict=True)`),
    but presently this is done a lot. Using `strict=True` will at some point be the
    default for all library code, but this is a [harder change to make](https://github.com/sympy/sympy/issues/11003).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会严重影响性能。例如，参见问题 [#18056](https://github.com/sympy/sympy/issues/18056) 和 [#15416](https://github.com/sympy/sympy/issues/15416)，在这些问题中，它导致了高达
    100 倍的减速。问题在于 SymPy 函数会自动对其参数调用 `sympify`。每当一个函数被传递一个 `sympify` 不知道如何转换为 SymPy
    对象的东西，例如一个 Python 函数类型，它会将字符串传递给 [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")。这比默认发生的直接转换慢得多。这在库代码中使用 `sympify()` 而不是
    `_sympify()`（或等效的 `sympify(strict=True)`）时特别发生。在某个时候，对所有库代码使用 `strict=True` 将成为默认设置，但这是一个更难的变更，参见
    [harder change to make](https://github.com/sympy/sympy/issues/11003)。
- en: It can cause security issues, since strings are evaled, and objects can return
    whatever string they want in their `__repr__`. See also [https://github.com/sympy/sympy/pull/12524](https://github.com/sympy/sympy/pull/12524).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `eval` 可能会引起安全问题，因为字符串是被求值的，并且对象可以在其 `__repr__` 中返回任意字符串。参见 [https://github.com/sympy/sympy/pull/12524](https://github.com/sympy/sympy/pull/12524)。
- en: It really wasn’t very useful to begin with. Just because an object’s string
    form can be parsed into a SymPy expression doesn’t mean it should be parsed that
    way. This is usually correct for custom numeric types, but an object’s repr could
    be anything. For instance, if the string form of an object looks like a valid
    Python identifier, it would parse as a `Symbol`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它一开始就不是很有用。仅仅因为一个对象的字符串形式可以解析为 SymPy 表达式并不意味着它应该以这种方式解析。这通常适用于自定义数值类型，但是一个对象的
    repr 可以是任何东西。例如，如果一个对象的字符串形式看起来像一个有效的 Python 标识符，它将被解析为 `Symbol`。
- en: There are plenty of ways to make custom objects work inside of [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify").
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以使自定义对象在 [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") 内部工作。
- en: Firstly, if an object is intended to work alongside other SymPy expressions,
    it should subclass from [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") (or [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")). If it does, [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") will just return it unchanged because it will already
    be a valid SymPy object.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果一个对象旨在与其他 SymPy 表达式一起工作，它应该从 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic")（或 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")）继承。如果是这样，[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") 将直接返回它，因为它已经是一个有效的 SymPy 对象。
- en: For objects that you control, you can add the `_sympy_` method. The [sympify
    docstring](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    has an example of this.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于您控制的对象，可以添加 `_sympy_` 方法。[sympify docstring](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") 中有一个示例。
- en: 'For objects that you don’t control, you can add a custom converter to the `sympy.core.sympify.converter`
    dictionary. The [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") docstring also has an example of this.  ### Deprecate
    the DMP.rep attribute.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于您无法控制的对象，您可以向 `sympy.core.sympify.converter` 字典中添加自定义转换器。[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") 的文档字符串中也有一个示例。  ### 弃用 DMP.rep 属性。'
- en: 'The internal type of `Poly` is the `DMP` class which previously could be used
    to access the coefficients of a polynomial as a list like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Poly` 的内部类型是 `DMP` 类，之前可以用来作为多项式系数的列表访问：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As of SymPy 1.13 the `DMP` type may be implemented by one of two subclasses:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SymPy 1.13 版本开始，`DMP` 类型可以由以下两个子类之一实现：
- en: '`DMP_Python` which is like the previous `DMP` type and has a list as its internal
    representation.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMP_Python` 类似于之前的 `DMP` 类型，并且其内部表示为列表的形式。'
- en: '`DUP_Flint` which wraps a Flint polynomial from python-flint.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DUP_Flint` 封装了来自 python-flint 的 Flint 多项式。'
- en: The `DUP_Flint` type does not have an attribute that is analogous to the list
    that `DMP_Python` has. Accessing `.rep` will still generate a list but now gives
    a deprecation warning.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`DUP_Flint` 类型没有类似于 `DMP_Python` 的列表属性。访问 `.rep` 仍会生成一个列表，但现在会生成弃用警告。'
- en: 'Instead of `.rep` use the `DMP.to_list()` method which returns an equivalent
    list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用 `.rep`，而是使用返回等效列表的 `DMP.to_list()` 方法：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `.to_list()` method is also available in previous versions of SymPy and
    its behaviour is unchanged.  ### Deprecate the pkgdata module'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`.to_list()` 方法在 SymPy 的早期版本中也是可用的，其行为没有改变。  ### 弃用 pkgdata 模块'
- en: 'The `sympy.utilities.pkdata` module is deprecated and will be removed. It is
    no longer used anywhere in SymPy and is unsuitable for use by any downstream code.
    Use the stdlib `importlib.resources` module instead.  ### Deprecate Eq.rewrite(Add)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.utilities.pkdata` 模块已经被废弃并将被移除。在 SymPy 中它已不再使用，也不适合任何下游代码使用。请使用标准库中的
    `importlib.resources` 模块。  ### 弃用 Eq.rewrite(Add)'
- en: 'The ability to rewrite `eq = Eq(x, y)` like `eq.rewrite(Add)` to give `x -
    y` has been deprecated in favor of writing `eq.lhs - eq.rhs`. A replacement property/method
    was not deemed necessary given the clarity of the explicit use of `lhs` and `rhs`,
    and the inclusion of this functionality in the rewrite apparatus leads to failures
    when a node expecting a Boolean is re- written as an Expr.  ### Deprecate markers,
    annotations, fill, rectangles of the Plot class'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '可以像 `eq = Eq(x, y)` 一样重写 `eq.rewrite(Add)` 以得到 `x - y` 已经被废弃，现在应该写成 `eq.lhs
    - eq.rhs`。考虑到显式使用 `lhs` 和 `rhs` 的清晰度，不再认为需要替换属性/方法，并且将此功能包含在重写装置中导致期望布尔值的节点重写为表达式时失败。  ###
    弃用标记，注释，填充，图类的矩形'
- en: The properties `markers, annotations, fill, rectangles` (containing user-provided
    numerical data to be added on a plot) are deprecated. The new implementation saves
    user-provided numerical data into appropriate data series, which can easily be
    processed by `MatplotlibBackend`. Instead of setting those properties directly,
    users should pass the homonym keyword arguments to the plotting functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用户提供的数值数据以添加到绘图上的 `markers, annotations, fill, rectangles` 属性已被弃用。新的实现将用户提供的数值数据保存到适当的数据系列中，可以轻松地由
    `MatplotlibBackend` 处理。用户不应直接设置这些属性，而应将同名关键字参数传递给绘图函数。
- en: 'The supported behavior is to pass keyword arguments to the plotting functions,
    which works fine for all versions of SymPy (before and after 1.13):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的行为是将关键字参数传递给绘图函数，这对 SymPy 的所有版本（1.13 之前和之后）都适用：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Setting attributes on the plot object is deprecated and will raise warnings:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置绘图对象的属性已被弃用，并将引发警告：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Motivation for this deprecation: the implementation of the `Plot` class suggests
    that it is ok to add attributes and hard-coded if-statements in the `MatplotlibBackend`
    class to provide more and more functionalities for user-provided numerical data
    (e.g. adding horizontal lines, or vertical lines, or bar plots, etc). However,
    in doing so one would reinvent the wheel: plotting libraries already implements
    the necessary API. There is no need to hard code these things. The plotting module
    should facilitate the visualization of symbolic expressions. The best way to add
    custom numerical data is to retrieve the figure created by the plotting module
    and use the API of a particular plotting library. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引入此弃用的动机：`Plot` 类的实现表明，可以在 `MatplotlibBackend` 类中添加属性和硬编码的 if 语句来为用户提供更多功能，例如添加水平线、垂直线或条形图等。然而，这样做等于重复造轮子：绘图库已经实现了必要的
    API。没有必要硬编码这些内容。绘图模块应该便于可视化符号表达式。添加自定义数值数据的最佳方法是检索由绘图模块创建的图，并使用特定绘图库的 API。例如：
- en: '[PRE11]  ### Moved mechanics functions'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE11]  ### 移动的力学函数'
- en: 'With the introduction of some new objects like the `Inertia` and load objects
    in the `sympy.physics.mechanics` module, some functions from `sympy.physics.mechanics.functions`
    have been moved to new modules. This removes some circular import errors and makes
    it easier to navigate through the source code, due to the parity between function
    names and module names. The following functions were moved:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`sympy.physics.mechanics`模块中引入一些新对象如`Inertia`和负载对象，一些函数从`sympy.physics.mechanics.functions`已移动到新模块。这消除了一些循环导入错误，并使得通过函数名和模块名之间的对等性更容易导航源代码。以下函数已移动：
- en: '`inertia` has been moved to `sympy.physics.mechanics.inertia`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inertia` 已经移动到 `sympy.physics.mechanics.inertia`'
- en: '`inertia_of_point_mass` has been moved to `sympy.physics.mechanics.inertia`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inertia_of_point_mass` 已经移动到 `sympy.physics.mechanics.inertia`'
- en: '`gravity` has been moved to `sympy.physics.mechanics.loads`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gravity` 已经移动到 `sympy.physics.mechanics.loads`'
- en: 'Previously you could import the functions from `sympy.physics.mechanics.functions`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前可以从 `sympy.physics.mechanics.functions` 导入函数：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now they should be imported from `sympy.physics.mechanics`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该从 `sympy.physics.mechanics` 导入它们：
- en: '[PRE13]  ### Ordered comparisons like `a < b` with modular integers'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]  ### 带模数整数的有序比较如 `a < b`'
- en: 'SymPy’s `GF` domains represent modular integers. Previously it was possible
    to compare these with ordered comparisons like `a < b`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的`GF`域表示模数整数。以前可以用像 `a < b` 这样的有序比较来比较它们：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will now fail with `TypeError` when the ground types are set to `flint`.
    When the ground types are not `flint` these comparisons are now deprecated: they
    will still work but will give a deprecation warning when used.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置的地面类型为`flint`时，这将导致`TypeError`。当地面类型不是`flint`时，这些比较现在已弃用：它们仍然有效，但在使用时会给出弃用警告。
- en: 'Ordered comparisons of modular integer or finite fields do not make sense because
    these are not ordered fields:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 模数整数或有限域的有序比较是没有意义的，因为这些不是有序域：
- en: '[PRE15]  ### The `ModularInteger.to_int()` method'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]  ### `ModularInteger.to_int()` 方法'
- en: 'SymPy’s `GF` domains are for modular integers e.g. `GF(n)` is for the integers
    modulo `n` and can be used like:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的`GF`域用于模数整数，例如`GF(n)`是模数`n`的整数，并且可以像这样使用：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The elements of a modular integer domain have a `to_int()` method that is deprecated
    since SymPy 1.13:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模数整数域的元素有一个自SymPy 1.13版起已弃用的`to_int()`方法：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead the preferred way to achieve equivalent behavior is to use the method
    on the domain (added in SymPy 1.13) or alternatively calling `int` might be better:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，实现等效行为的首选方法是使用域上的方法（自SymPy 1.13版起添加）或者可能更好的是调用 `int`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These two ways of converting to an `int` are not equivalent. The domain `GF(p)`
    can be defined with `symmetric=True` or `symmetric=False`. This difference affects
    the behavior of the `to_int` method:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种转换为`int`的方法并不等效。域`GF(p)`可以使用`symmetric=True`或`symmetric=False`定义。这种差异会影响`to_int`方法的行为：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So if `symmetric=True` (which is the default) then the `to_int` method will
    sometimes return negative integers. If `symmetric=False` or if the `int(a)` method
    is used the returned result is always a nonnegative integer. Note also that the
    behaviour of `int(a)` was changed in SymPy 1.13: in previous versions it was equivalent
    to `a.to_int()`. To write code that behaves the same way in all SymPy versions
    you can:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果 `symmetric=True`（这是默认值），`to_int` 方法有时会返回负整数。如果 `symmetric=False` 或者使用 `int(a)`
    方法，返回的结果总是非负整数。还要注意，`int(a)` 的行为在 SymPy 1.13 中已更改：在先前的版本中，它等同于 `a.to_int()`。为了编写在所有
    SymPy 版本中行为一致的代码，您可以：
- en: Use `symmetric=False` and use `int(a)`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `symmetric=False` 并使用 `int(a)`。
- en: Define a function like
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，如
- en: '[PRE20]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The reason for this change is that it makes it possible to use python-flint’s
    `nmod` as an alternative (much faster) implementation for the elements of `GF(p)`.
    It is not possible to add a `to_int` method to python-flint’s `nmod` type or to
    capture the equivalent of `symmetric=True/False` by storing data in the `nmod`
    instance. Deprecating and removing the `to_int` method and changing the behavior
    of the `int` method means that the element instances do not have any behavior
    that depends on whether the domain is considered to be “symmetric” or not. Instead
    the notion of “symmetric” is now purely a property of the domain object itself
    rather than of the elements and so the `to_int` method that depends on this must
    be a domain method rather than an element method.  ### Relocate symbolic functions
    from `ntheory` to `functions`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变的原因是，这样做可以使用python-flint的 `nmod` 作为 `GF(p)` 的元素的替代（更快）实现。不可能向python-flint的
    `nmod` 类型添加 `to_int` 方法，或者通过在 `nmod` 实例中存储数据来捕获 `symmetric=True/False` 的等价物。弃用和移除
    `to_int` 方法并改变 `int` 方法的行为意味着元素实例没有任何取决于域是否被视为“对称”的行为。相反，“对称”的概念现在纯粹是域对象自身的属性，而不是元素的属性，因此取决于这一点的
    `to_int` 方法必须是一个域方法而不是元素方法。### 将 `ntheory` 中的符号函数移至 `functions`
- en: 'The following symbolic functions in `ntheory` have been moved to `functions`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntheory` 中的以下符号函数已经移动到 `functions`：'
- en: '`sympy.ntheory.factor_.divisor_sigma`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.divisor_sigma`'
- en: '`sympy.ntheory.factor_.primenu`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.primenu`'
- en: '`sympy.ntheory.factor_.primeomega`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.primeomega`'
- en: '`sympy.ntheory.factor_.reduce_totient`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.reduce_totient`'
- en: '`sympy.ntheory.factor_.totient`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.totient`'
- en: '`sympy.ntheory.generate.primepi`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.generate.primepi`'
- en: '`sympy.partitions_.npartitions`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.partitions_.npartitions`'
- en: '`sympy.ntheory.residue_ntheory.jacobi_symbol`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.residue_ntheory.jacobi_symbol`'
- en: '`sympy.ntheory.residue_ntheory.legendre_symbol`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.residue_ntheory.legendre_symbol`'
- en: '`sympy.ntheory.residue_ntheory.mobius`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.residue_ntheory.mobius`'
- en: Code that imports these functions from top-level like `from sympy import mobius`
    will continue to work fine. However code that imports these from the fully qualified
    module like `from sympy.ntheory import mobius` or `from sympy.ntheory.residue_ntheory
    import mobius` will now see a deprecation warning. The new location for these
    functions is in `sympy.functions` but the intended way to import them is still
    from top-level like `from sympy import mobius`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶层导入这些函数的代码，比如 `from sympy import mobius` 仍然可以正常工作。但是从完全合格的模块导入这些函数的代码，比如 `from
    sympy.ntheory import mobius` 或者 `from sympy.ntheory.residue_ntheory import mobius`
    现在会看到一个弃用警告。这些函数的新位置在 `sympy.functions` 中，但是导入它们的预期方式仍然是从顶层，比如 `from sympy import
    mobius`。
- en: The following symbolic functions in `ntheory` have been moved to `functions`,
    but cannot be imported at top-level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntheory` 中的以下符号函数已经移动到 `functions`，但无法在顶层导入。'
- en: '`sympy.ntheory.factor_.udivisor_sigma`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.ntheory.factor_.udivisor_sigma`'
- en: The following functions have been moved from `functions` to `ntheory` because
    they are numeric functions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数从 `functions` 移动到 `ntheory`，因为它们是数值函数。
- en: '`sympy.functions.combinatorial.numbers.carmichael.is_carmichael`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.functions.combinatorial.numbers.carmichael.is_carmichael`'
- en: '`sympy.functions.combinatorial.numbers.carmichael.find_carmichael_numbers_in_range`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.functions.combinatorial.numbers.carmichael.find_carmichael_numbers_in_range`'
- en: '`sympy.functions.combinatorial.numbers.carmichael.find_first_n_carmichaels`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.functions.combinatorial.numbers.carmichael.find_first_n_carmichaels`'
- en: If you are using these functions, change from
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用这些函数，请从
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: to
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Version 1.12
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本1.12
- en: '### The `ManagedProperties` metaclass'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '### `ManagedProperties` 元类'
- en: 'The `ManagedProperties` metaclass was previously the metaclass for `Basic`.
    Now `Basic` does not use metaclasses and so its metaclass is just `type`. Any
    code that previously subclassed `Basic` and wanted to do anything with metaclasses
    would have needed to subclass `ManagedProperties` to make the relevant metaclass.
    The only relevant method of `ManagedProperties` has been moved to `Basic.__init_subclass__`.
    Since `ManagedProperties` is not used as the metaclass for `Basic` any more and
    no longer does anything useful it should be possible for such code to just subclass
    `type` instead for any metaclass.  ### New Joint coordinate format'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedProperties`元类以前是`Basic`的元类。现在`Basic`不再使用元类，因此其元类只是`type`。任何以前子类化`Basic`并希望使用元类的代码都需要子类化`ManagedProperties`以使用相关的元类。`ManagedProperties`的唯一相关方法已移至`Basic.__init_subclass__`。由于`ManagedProperties`不再作为`Basic`的元类使用，并且不再做任何有用的事情，因此此类代码现在可以仅仅子类化`type`来代替任何元类。###
    新关节坐标格式'
- en: 'The format, i.e. type and auto generated name, of the generalized coordinates
    and generalized speeds of the joints in the `sympy.physics.mechanics` module has
    changed. The data type has changed from `list` to `Matrix`, which is the same
    as the type for the generalized coordinates within the `KanesMethod`. The auto
    naming of the generalized coordinates and generalized speeds of the `PinJoint`
    and `PrismaticJoint` have also changed to `q_<joint.name>` and `u_<joint.name>`.
    Previously each of those joints had an unique template for auto generating these
    names.  ### New Joint intermediate frames'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化坐标和泛化速度的格式，即关节在`sympy.physics.mechanics`模块中的类型和自动生成的名称，已经发生了变化。数据类型已从`list`改变为`Matrix`，与`KanesMethod`中泛化坐标的类型相同。`PinJoint`和`PrismaticJoint`的泛化坐标和泛化速度的自动命名也已更改为`q_<joint.name>`和`u_<joint.name>`。以前，每个关节都有一个独特的模板来自动生成这些名称。###
    新关节中间框架
- en: The definition of the joint axis in the `sympy.physics.mechanics` module has
    changed. Instead of using the arguments `parent_axis` and `child_axis` to automatically
    determine the joint axis and an intermediate reference frame, the joints now use
    an intermediate frame argument for both the parent and the child body, i.e. `parent_interframe`
    and `child_interframe`. This means that you can now fully define the joint attachment,
    consisting of a point and frame, for both bodies. Furthermore, if a joint like
    the `PinJoint` has a specific joint axis, e.g. the axis about which the rotation
    occurs, then this axis can be specified using the `joint_axis` argument. An advantage
    of this setup is that one can more accurately define the transformation from the
    parent body to the child body.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.physics.mechanics`模块中关节轴的定义已更改。现在，不再使用参数`parent_axis`和`child_axis`来自动确定关节轴和中间参考框架，而是关节现在同时使用了父体和子体的中间框架参数，即`parent_interframe`和`child_interframe`。这意味着您现在可以完全定义两个体的关节附着点和框架。此外，如果像`PinJoint`这样的关节有特定的关节轴，例如旋转发生的轴线，则可以使用`joint_axis`参数来指定此轴。此设置的优势在于可以更准确地定义从父体到子体的变换。'
- en: 'For example, suppose you want a `PinJoint` that rotates the child body about
    the `parent.z` axis and `-child.z` axis. The previous way to specify this joint
    was:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要一个`PinJoint`来使子体绕`parent.z`轴和`-child.z`轴旋转。以前指定这个关节的方式是：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When inspecting this matrix you will notice that for `theta_pin = 0` the child
    body is rotated \(\pi\) rad about the `parent.y` axis. In the new definition you
    can see that we get the same result, but this time we have also specified this
    exact rotation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查此矩阵时，您会注意到对于`theta_pin = 0`，子体围绕`parent.y`轴旋转\(\pi\)弧度。在新定义中，我们可以看到得到相同结果，但这次我们还指定了这个确切的旋转：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However if you liked the fact that the deprecated arguments aligned the frames
    for you, then you can still make use of this feature by providing vectors to `parent_interframe`
    and `child_interframe`, which are then oriented such that the joint axis expressed
    in the intermediate frame is aligned with the given vector:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您喜欢废弃参数对齐框架的功能，那么您仍然可以通过向`parent_interframe`和`child_interframe`提供向量来使用此功能，然后这些向量将被定向，以便在中间框架中表示的关节轴与给定向量对齐：
- en: '[PRE25]  ### Change in joint attachment point argument'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]### 关节附着点参数变更'
- en: The argument names for specifying the attachment points of a joint in `sympy.physics.mechanics`
    , i.e. `parent_joint_pos` and `child_joint_pos`, have been changed to `parent_point`
    and `child_point`. This is because these arguments can now also be `Point` objects,
    so they can be exactly the same as the `parent_point` and `child_point` attributes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sympy.physics.mechanics` 中指定关节附着点的参数名已更改为 `parent_point` 和 `child_point`，即
    `parent_joint_pos` 和 `child_joint_pos`。这是因为这些参数现在也可以是 `Point` 对象，因此它们可以与 `parent_point`
    和 `child_point` 属性完全相同。
- en: 'For example, suppose you want a `PinJoint` in the parent to be positioned at
    `parent.frame.x` with respect to the mass center, and in the child at `-child.frame.x`.
    The previous way to specify this was:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望 `PinJoint` 在父级中被定位在 `parent.frame.x` 处相对于质心，在子级中为 `-child.frame.x`。以前指定这一点的方式是：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now you can do the same with either
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以用同样的方式来处理
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Or
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Version 1.11
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.11
- en: '### Modules `sympy.tensor.array.expressions.conv_*` renamed to `sympy.tensor.array.expressions.from_*`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '### 模块 `sympy.tensor.array.expressions.conv_*` 重命名为 `sympy.tensor.array.expressions.from_*`'
- en: 'In order to avoid possible naming and tab-completion conflicts with functions
    with similar names to the names of the modules, all modules whose name starts
    with `conv_*` in `sympy.tensor.array.expressions` have been renamed to `from_*`.  ###
    New Mathematica code parser'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '为了避免可能与模块同名函数的命名和制表完成冲突，`sympy.tensor.array.expressions` 中所有名称以 `conv_*` 开头的模块已重命名为
    `from_*`。 ### 新的 Mathematica 代码解析器'
- en: The old mathematica code parser defined in the module `sympy.parsing.mathematica`
    in the function `mathematica` is deprecated. The function `parse_mathematica`
    with a new and more comprehensive parser should be used instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块 `sympy.parsing.mathematica` 中定义的旧 Mathematica 代码解析器已被弃用。应改用具有新的更全面解析器的 `parse_mathematica`
    函数。
- en: The `additional_translations` parameter for the Mathematica parser is not available
    in `parse_mathematica`. Additional translation rules to convert Mathematica expressions
    into SymPy ones should be specified after the conversion using SymPy’s `.replace(
    )` or `.subs( )` methods on the output expression. If the translator fails to
    recognize the logical meaning of a Mathematica expression, a form similar to Mathematica’s
    full form will be returned, using SymPy’s `Function` object to encode the nodes
    of the syntax tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Mathematica 解析器的 `parse_mathematica` 函数中不可用的 `additional_translations` 参数。应在使用
    SymPy 的 `.replace()` 或 `.subs()` 方法转换后，指定将 Mathematica 表达式转换为 SymPy 表达式的附加转换规则。如果翻译器无法识别
    Mathematica 表达式的逻辑含义，则将返回类似 Mathematica 的完整形式，使用 SymPy 的 `Function` 对象来编码语法树的节点。
- en: 'For example, suppose you want `F` to be a function that returns the maximum
    value multiplied by the minimum value, the previous way to specify this conversion
    was:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望 `F` 是一个返回最大值乘以最小值的函数，以前指定此转换的方法是：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you can do the same with
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以用同样的方式做到
- en: '[PRE30]  ### Redundant static methods in `carmichael`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]  ### `carmichael` 中冗余的静态方法'
- en: A number of static methods in `~.carmichael` are just wrappers around other
    functions. Instead of `carmichael.is_perfect_square` use `sympy.ntheory.primetest.is_square`
    and instead of `carmichael.is_prime` use `~.isprime`. Finally, `carmichael.divides`
    can be replaced by instead checking
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `~.carmichael` 中的一些静态方法只是其他函数的包装器。例如，代替 `carmichael.is_perfect_square` 使用
    `sympy.ntheory.primetest.is_square`，代替 `carmichael.is_prime` 使用 `~.isprime`。最后，`carmichael.divides`
    可以替换为检查
- en: '[PRE31]  ### The `check` argument to `HadamardProduct`, `MatAdd` and `MatMul`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]  ### 对 `HadamardProduct`、`MatAdd` 和 `MatMul` 的 `check` 参数'
- en: This argument can be used to pass incorrect values to `~.HadamardProduct`, `~.MatAdd`,
    and `~.MatMul` leading to later problems. The `check` argument will be removed
    and the arguments will always be checked for correctness, i.e., the arguments
    are matrices or matrix symbols.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数可以用来传递给 `~.HadamardProduct`、`~.MatAdd` 和 `~.MatMul` 的错误值，从而导致后续问题。`check`
    参数将被移除，并且参数将始终被检查正确性，即参数是矩阵或矩阵符号。
- en: Version 1.10
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.10
- en: '### Some traversal functions have been moved'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '### 一些遍历函数已经移动'
- en: Some traversal functions have moved. Specifically, the functions
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一些遍历函数已经移动。具体来说，这些函数
- en: '`bottom_up`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom_up`'
- en: '`interactive_traversal`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interactive_traversal`'
- en: '`postorder_traversal`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postorder_traversal`'
- en: '`preorder_traversal`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preorder_traversal`'
- en: '`use`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use`'
- en: have moved to different SymPy submodules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 已移动到不同的 SymPy 子模块。
- en: These functions should be used from the top-level `sympy` namespace, like
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数应该从顶级的 `sympy` 命名空间中使用，比如
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: or
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In general, end-users should use the top-level `sympy` namespace for any functions
    present there. If a name is in the top-level namespace, its specific SymPy submodule
    should not be relied on, as functions may move around due to internal refactorings.  ###
    `sympy.core.trace`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '通常情况下，最终用户应该使用顶级 `sympy` 命名空间中存在的任何函数。如果一个名称在顶级命名空间中，不应依赖于其特定的 SymPy 子模块，因为由于内部重构，函数可能会移动。
    ### `sympy.core.trace`'
- en: 'The trace object `sympy.core.trace.Tr()` was moved to `sympy.physics.quantum.trace.Tr()`.
    This was because it was only used in the `sympy.physics.quantum` submodule, so
    it was better to have it there than in the core.  ### The `sympy.core.compatibility`
    submodule'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '追踪对象 `sympy.core.trace.Tr()` 已经移至 `sympy.physics.quantum.trace.Tr()`。这是因为它仅在
    `sympy.physics.quantum` 子模块中使用，所以将其放在那里比放在核心模块中更合适。 ### `sympy.core.compatibility`
    子模块'
- en: The `sympy.core.compatibility` submodule is deprecated.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.core.compatibility` 子模块已经被弃用。'
- en: This submodule was only ever intended for internal use. Now that SymPy no longer
    supports Python 2, this module is no longer necessary, and the remaining helper
    functions have been moved to more convenient places in the SymPy codebase.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此子模块最初仅用于内部使用。由于 SymPy 不再支持 Python 2，因此此模块已不再必要，并且剩余的辅助函数已移至 SymPy 代码库中更方便的位置。
- en: Some of the functions that were in this module are available from the top-level
    SymPy namespace, i.e.,
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中的一些函数现在可以从顶级 SymPy 命名空间中获取，即，
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: or
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In general, end-users should use the top-level `sympy` namespace for any functions
    present there. If a name is in the top-level namespace, its specific SymPy submodule
    should not be relied on, as functions may move around due to internal refactorings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，最终用户应该使用顶级 `sympy` 命名空间中存在的任何函数。如果一个名称在顶级命名空间中，不应依赖于其特定的 SymPy 子模块，因为由于内部重构，函数可能会移动：
- en: The remaining functions in `sympy.core.compatibility` were only intended for
    internal SymPy use and should not be used by user code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.core.compatibility` 中剩余的函数仅供内部 SymPy 使用，不应该被用户代码使用。'
- en: Additionally, these two functions, `ordered` and `default_sort_key`, also used
    to be in `sympy.utilities.iterables` but have been moved from there as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这两个函数 `ordered` 和 `default_sort_key` 也曾在 `sympy.utilities.iterables` 中，但它们也已经从那里移动。
- en: Version 1.9
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.9
- en: '### `expr_free_symbols`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '### `expr_free_symbols`'
- en: The `expr_free_symbols` attribute of various SymPy objects is deprecated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 SymPy 对象的 `expr_free_symbols` 属性已经被弃用。
- en: '`expr_free_symbols` was meant to represent indexed objects such as `MatrixElement`
    and [`Indexed`](../modules/tensor/indexed.html#sympy.tensor.indexed.Indexed "sympy.tensor.indexed.Indexed")
    as free symbols. This was intended to make derivatives of free symbols work. However,
    this now works without making use of the method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr_free_symbols` 被设计为表示像 `MatrixElement` 和 [`Indexed`](../modules/tensor/indexed.html#sympy.tensor.indexed.Indexed
    "sympy.tensor.indexed.Indexed") 这样的索引对象作为自由符号。这旨在使自由符号的导数工作。然而，现在即使不使用该方法也能正常工作：'
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This was a general property that was added to solve a very specific problem
    but it added a layer of abstraction that is not necessary in general.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用属性，旨在解决一个非常具体的问题，但它增加了不必要的抽象层。
- en: objects that have structural “non-expression” nodes already allow one to focus
    on the expression node if desired, e.g.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于已经具有结构化“非表达式”节点的对象，如果需要，可以直接专注于表达式节点，例如。
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: introduction of this property encourages imprecise thinking when requesting
    free_symbols since it allows one to get symbols from a specific node of an object
    without specifying the node
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引入此属性会在请求自由符号时鼓励不精确的思考，因为它允许从对象的特定节点获取符号而不必指定节点。
- en: 'the property was incorrectly added to `AtomicExpr` so numbers are returned
    as `expr_free_symbols`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该属性被错误地添加到 `AtomicExpr`，因此数字被返回为 `expr_free_symbols`：
- en: '[PRE38]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'the application of the concept was misapplied to define `Subs.expr_free_symbols`:
    it added in `expr_free_symbols` of the point but the point is a `Tuple` so nothing
    was added'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用这个概念来定义 `Subs.expr_free_symbols` 是错误的：它增加了点的 `expr_free_symbols` 但是点是一个 `Tuple`，因此没有添加任何内容。
- en: it was not used anywhere else in the codebase except in the context of differentiating
    a `Subs` object, which suggested that it was not something of general use, this
    is also confirmed by the fact that,
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在代码库中除了在不同iating `Subs` 对象的上下文中未被使用外，这表明它并非通用用途，这也由以下事实确认：
- en: it was added without specific tests except for test of the derivatives of the
    Subs object for which it was introduced
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是在未进行具体测试的情况下添加的，除了引入它的 `Subs` 对象的导数测试外。
- en: 'See issue [#21494](https://github.com/sympy/sympy/issues/21494) for more discussion.  ###
    `sympy.stats.sample(numsamples=n)`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '更多讨论请参见问题[#21494](https://github.com/sympy/sympy/issues/21494)。  ### `sympy.stats.sample(numsamples=n)`'
- en: The `numsamples` parameter to [`sympy.stats.sample()`](../modules/stats.html#sympy.stats.sample
    "sympy.stats.sample") is deprecated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.stats.sample()`](../modules/stats.html#sympy.stats.sample "sympy.stats.sample")的`numsamples`参数已弃用。'
- en: '`numsamples` makes `sample()` return a list of size `numsamples`, like'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`numsamples`使得`sample()`返回大小为`numsamples`的列表，例如：'
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, this functionality can be easily implemented by the user with a list
    comprehension
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户可以通过列表推导轻松实现此功能。
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Additionally, it is redundant with the `size` parameter, which makes `sample`
    return a NumPy array with the given shape.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它与`size`参数重复，使得`sample`返回一个具有给定形状的NumPy数组。
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Historically, `sample` was changed in SymPy 1.7 so it returned an iterator instead
    of sample value. Since an iterator was returned, a numsamples parameter was added
    to specify the length of the iterator.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，SymPy 1.7中更改了`sample`，使其返回迭代器而不是样本值。因此，添加了一个`numsamples`参数来指定迭代器的长度。
- en: 'However, this new behavior was considered confusing, as discussed in issue
    [#21563](https://github.com/sympy/sympy/issues/21563), so it was reverted. Now,
    `sample_iter` should be used if a iterator is needed. Consequently, the `numsamples`
    parameter is no longer needed for `sample()`.  ### `sympy.polys.solvers.RawMatrix`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，由于在问题[#21563](https://github.com/sympy/sympy/issues/21563)中讨论的混乱，这种新行为被撤销了。现在，如果需要迭代器，则应使用`sample_iter`。因此，`sample()`不再需要`numsamples`参数。  ###
    `sympy.polys.solvers.RawMatrix`'
- en: The `RawMatrix` class is deprecated. The `RawMatrix` class was a subclass of
    `Matrix` that used domain elements instead of `Expr` as the elements of the matrix.
    This breaks a key internal invariant of `Matrix` and this kind of subclassing
    limits improvements to the `Matrix` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`RawMatrix`类已弃用。`RawMatrix`类是`Matrix`的子类，其使用域元素而不是`Expr`作为矩阵的元素。这违反了`Matrix`的关键内部不变量，并且这种子类化限制了对`Matrix`类的改进。'
- en: 'The only part of SymPy that documented the use of the `RawMatrix` class was
    the Smith normal form code, and that has now been changed to use `DomainMatrix`
    instead. It is recommended that anyone using `RawMatrix` with the previous Smith
    Normal Form code should switch to using `DomainMatrix` as shown in issue [#21402](https://github.com/sympy/sympy/pull/21402).
    A better API for the Smith normal form will be added later.  ### Non-`Expr` objects
    in a Matrix'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'SymPy唯一文档化使用`RawMatrix`类的部分是Smith正常形式代码，现在已更改为使用`DomainMatrix`。建议任何使用`RawMatrix`以前的Smith正常形式代码的人切换到使用问题[#21402](https://github.com/sympy/sympy/pull/21402)中显示的`DomainMatrix`。稍后将添加更好的Smith正常形式API。  ###
    非`Expr`对象在矩阵中'
- en: 'In SymPy 1.8 and earlier versions it was possible to put non-[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") elements in a [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") and the matrix elements could be any arbitrary
    Python object:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy 1.8及更早版本中，可以在[`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix")中放置非[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")元素，并且矩阵元素可以是任意的Python对象：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is not useful and does not really work, e.g.:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不实用，实际上并不起作用，例如：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The main reason for making this possible was that there were a number of `Matrix`
    subclasses in the SymPy codebase that wanted to work with objects from the polys
    module, e.g.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 允许此功能的主要原因是SymPy代码库中有许多`Matrix`子类希望使用polys模块中的对象，例如：
- en: '`RawMatrix` (see [above](#deprecated-rawmatrix)) was used in `solve_lin_sys`
    which was part of `heurisch` and was also used by `smith_normal_form`. The `NewMatrix`
    class used domain elements as the elements of the Matrix rather than `Expr`.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RawMatrix`（见[上文](#deprecated-rawmatrix)）在`solve_lin_sys`中被使用，这是`heurisch`的一部分，并且也被`smith_normal_form`使用。`NewMatrix`类使用域元素作为矩阵的元素，而不是`Expr`。'
- en: '`NewMatrix` was used in the `holonomic` module and also used domain elements
    as matrix elements'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NewMatrix`在`holonomic`模块中被使用，并且还使用域元素作为矩阵的元素。'
- en: '`PolyMatrix` used a mix of `Poly` and `Expr` as the matrix elements and was
    used by `risch`.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PolyMatrix`将`Poly`和`Expr`混合作为矩阵元素，并被`risch`使用。'
- en: All of these matrix subclasses were broken in different ways and the introduction
    of [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") ([#20780](https://github.com/sympy/sympy/pull/20780),
    [#20759](https://github.com/sympy/sympy/pull/20759), [#20621](https://github.com/sympy/sympy/pull/20621),
    [#19882](https://github.com/sympy/sympy/pull/19882), [#18844](https://github.com/sympy/sympy/pull/18844))
    provides a better solution for all cases. Previous PRs have removed the dependence
    of these other use cases on Matrix ([#21441](https://github.com/sympy/sympy/pull/21441),
    [#21427](https://github.com/sympy/sympy/pull/21427), [#21402](https://github.com/sympy/sympy/pull/21402))
    and now [#21496](https://github.com/sympy/sympy/pull/21496) has deprecated having
    non-`Expr` in a `Matrix`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些矩阵子类都以不同的方式损坏，并且引入了 [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") ([#20780](https://github.com/sympy/sympy/pull/20780),
    [#20759](https://github.com/sympy/sympy/pull/20759), [#20621](https://github.com/sympy/sympy/pull/20621),
    [#19882](https://github.com/sympy/sympy/pull/19882), [#18844](https://github.com/sympy/sympy/pull/18844))
    提供了所有情况的更好解决方案。以前的 PR 已经移除了这些其他用例对 Matrix 的依赖 ([#21441](https://github.com/sympy/sympy/pull/21441),
    [#21427](https://github.com/sympy/sympy/pull/21427), [#21402](https://github.com/sympy/sympy/pull/21402))，现在
    [#21496](https://github.com/sympy/sympy/pull/21496) 已经废弃了在 `Matrix` 中使用非`Expr`元素的做法。
- en: This change makes it possible to improve the internals of the Matrix class but
    it potentially impacts on some downstream use cases that might be similar to the
    uses of `Matrix` with non-`Expr` elements that were in the SymPy codebase. A potential
    replacement for code that used `Matrix` with non-`Expr` elements is [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") if the elements are something
    like domain elements and a domain object can be provided for them. Alternatively
    if the goal is just printing support then perhaps `TableForm` can be used.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变更使得可以改进 Matrix 类的内部，但可能对一些下游用例产生影响，这些用例可能与 SymPy 代码库中使用非`Expr`元素的 Matrix
    使用方式类似。如果希望用类似域元素和域对象可以为其提供的元素替换使用 `Matrix` 的代码，请使用 [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")。或者，如果目标只是打印支持，则可能可以使用 `TableForm`。
- en: 'It isn’t clear what to advise as a replacement here without knowing more about
    the usecase. If you are unclear how to update your code, please [open an issue](https://github.com/sympy/sympy/issues/new)
    or [write to our mailing list](https://groups.google.com/g/sympy) so we can discuss
    it.  ### The `get_segments` attribute of plotting objects'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '没有清楚的建议可以在此处替换，除非了解更多关于用例的信息。如果不清楚如何更新您的代码，请[提出问题](https://github.com/sympy/sympy/issues/new)或[写信到我们的邮件列表](https://groups.google.com/g/sympy)，以便讨论。
    ### 绘图对象的 `get_segments` 属性'
- en: The `get_segments` method implemented in [`Line2DBaseSeries`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries
    "sympy.plotting.series.Line2DBaseSeries") is used to convert two list of coordinates,
    `x` and `y`, into a list of segments used by Matplotlib’s `LineCollection` to
    plot a line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Line2DBaseSeries`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries
    "sympy.plotting.series.Line2DBaseSeries") 中实现的 `get_segments` 方法用于将 `x` 和 `y`
    两个坐标列表转换为 Matplotlib 的 `LineCollection` 绘制线段所需的段列表。'
- en: Since the list of segments is only required by Matplotlib (for example, Bokeh,
    Plotly, Mayavi, K3D only require lists of coordinates), this has been moved inside
    the `MatplotlibBackend` class.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于段列表仅由 Matplotlib 需要（例如，Bokeh、Plotly、Mayavi、K3D 只需要坐标列表），因此这一改变已经移至 `MatplotlibBackend`
    类内部。
- en: Note that previously, the method [`get_points()`](../modules/plotting.html#sympy.plotting.series.LineOver1DRangeSeries.get_points
    "sympy.plotting.series.LineOver1DRangeSeries.get_points") always returned uniformly
    sampled points, which meant that some functions were not plotted correctly when
    using `get_points()` to plot with Matplotlib.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意之前，[`get_points()`](../modules/plotting.html#sympy.plotting.series.LineOver1DRangeSeries.get_points
    "sympy.plotting.series.LineOver1DRangeSeries.get_points") 方法总是返回均匀采样的点，这意味着当使用
    `get_points()` 和 Matplotlib 绘图时，一些函数未能正确绘制。
- en: 'To avoid this problem, the method `get_segments()` could be used, which used
    adaptive sampling and which could be used with Matplotlib’s `LineCollection`.
    However, this has been changed, and now `get_points()` can also use adaptive sampling.
    The [`get_data()`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries.get_data
    "sympy.plotting.series.Line2DBaseSeries.get_data") method can also be used.  ###
    The `mdft` function in `sympy.physics.matrices`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免这个问题，可以使用`get_segments()`方法，它使用自适应采样，并可以与Matplotlib的`LineCollection`一起使用。但是，现在也可以使用`get_points()`进行自适应采样。可以使用[`get_data()`](../modules/plotting.html#sympy.plotting.series.Line2DBaseSeries.get_data
    "sympy.plotting.series.Line2DBaseSeries.get_data")方法。### `sympy.physics.matrices`中的`mdft`函数
- en: The `sympy.physics.matrices.mdft()` function is deprecated. It can be replaced
    with the `DFT` class in `sympy.matrices.expressions.fourier`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.physics.matrices.mdft()`函数已弃用。可以用`sympy.matrices.expressions.fourier`中的`DFT`类替换。'
- en: 'In particular, replace `mdft(n)` with `DFT(n).as_explicit()`. For example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，用`DFT(n).as_explicit()`替换`mdft(n)`。例如：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This was changed because the `sympy.physics` submodule is supposed to only
    contain things that are specific to physics, but the discrete Fourier transform
    matrix is a more general mathematical concept, so it is better located in the
    `sympy.matrices` module. Furthermore, the `DFT` class is a [matrix expression](../modules/matrices/expressions.html#module-sympy.matrices.expressions
    "sympy.matrices.expressions"), meaning it can be unevaluated and support symbolic
    shape.  ### The private `SparseMatrix._smat` and `DenseMatrix._mat` attributes'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化是因为`sympy.physics`子模块只应包含与物理有关的内容，但离散傅立叶变换矩阵是一个更一般的数学概念，因此最好放在`sympy.matrices`模块中。此外，`DFT`类是一个[矩阵表达式](../modules/matrices/expressions.html#module-sympy.matrices.expressions
    "sympy.matrices.expressions")，这意味着它可以未评估并支持符号形状。### `SparseMatrix._smat`和`DenseMatrix._mat`私有属性
- en: The `._mat` attribute of [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") and the `._smat` attribute of [`SparseMatrix`](../modules/matrices/sparse.html#sympy.matrices.sparse.SparseMatrix
    "sympy.matrices.sparse.SparseMatrix") are deprecated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix "sympy.matrices.dense.Matrix")的`._mat`属性和[`SparseMatrix`](../modules/matrices/sparse.html#sympy.matrices.sparse.SparseMatrix
    "sympy.matrices.sparse.SparseMatrix")的`._smat`属性已弃用。'
- en: The internal representation of `Matrix` and `SparseMatrix` was changed to be
    a [`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") in [#21626](https://github.com/sympy/sympy/pull/21626)
    so that it is no longer possible to expose a mutable list/dict as a way of mutating
    a `Matrix`. Instead of `._mat` the new `.flat()` method can be used, which returns
    a new list that cannot be used to mutate the `Matrix` itself. Instead of `._smat`
    the `.todok()` method can be used which returns a new dict.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix`和`SparseMatrix`的内部表示已更改为[#21626](https://github.com/sympy/sympy/pull/21626)中的[`DomainMatrix`](../modules/polys/domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")，因此不再可能将可变列表/字典暴露为突变`Matrix`的一种方式。新的`.flat()`方法可以使用，它返回一个新列表，不能用于突变`Matrix`本身。可以使用`.todok()`方法而不是`._smat`。'
- en: 'Note that these attributes are already changed in SymPy 1.9 to return read-only
    copies, so that any code that relied on mutating them will be broken. Also these
    attributes were technically always private (they started with an underscore),
    so user code should not really have been using them in the first place.  ### laplace_transform
    of a Matrix with noconds=False'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些属性在SymPy 1.9中已更改为返回只读副本，因此依赖于突变它们的任何代码将会失败。此外，这些属性在技术上始终是私有的（它们以下划线开头），因此用户代码在第一次使用它们时不应该真的使用它们。###
    Matrix的laplace_transform与noconds=False
- en: 'Prior to version 1.9, calling [`laplace_transform()`](../modules/integrals/integrals.html#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform") on a [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") with `noconds=False` (which is the default), resulted
    in a Matrix of tuples:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.9之前，在一个带有`noconds=False`（默认情况）的[`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix")上调用[`laplace_transform()`](../modules/integrals/integrals.html#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")会导致元组的矩阵：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However, `Matrix` is only designed to work with `Expr` objects (see [Non-Expr
    objects in a Matrix](#deprecated-non-expr-in-matrix) above).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`Matrix`仅设计用于与`Expr`对象一起工作（见上面的[Matrix中的非Expr对象](#deprecated-non-expr-in-matrix)）。
- en: To avoid this, either use `noconds=True` to remove the convergence conditions
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，可以使用`noconds=True`来移除收敛条件。
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: or use `legacy_matrix=False` to return the new behavior, which will be to return
    a single tuple with the Matrix in the first argument and the convergence conditions
    combined into a single condition for the whole matrix.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`legacy_matrix=False`来返回新的行为，即在第一个参数中返回矩阵，并将收敛条件组合为整个矩阵的单一条件。
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When this deprecation is removed the `legacy_matrix=False` behavior will become
    the default, but the flag will be left intact for compatibility.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当此废弃项被移除时，`legacy_matrix=False`行为将成为默认值，但标志将保留以确保兼容性。
- en: Version 1.8
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本1.8
- en: '### `sympy.printing.theanocode`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '### `sympy.printing.theanocode`'
- en: '[Theano](https://github.com/Theano/Theano) has been discontinued, and forked
    into a new project called [Aesara](https://github.com/aesara-devs/aesara). The
    `sympy.printing.theanocode` module has been renamed to [`sympy.printing.aesaracode`](../modules/printing.html#module-sympy.printing.aesaracode
    "sympy.printing.aesaracode"), and all the corresponding functions have been renamed
    (e.g., `theano_code` has been renamed to [`aesara_code()`](../modules/printing.html#sympy.printing.aesaracode.aesara_code
    "sympy.printing.aesaracode.aesara_code"), `TheanoPrinter` has been renamed to
    [`AesaraPrinter`](../modules/printing.html#sympy.printing.aesaracode.AesaraPrinter
    "sympy.printing.aesaracode.AesaraPrinter"), and so on).  ### `sympy.assumptions.handlers.AskHandler`
    and related methods'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[Theano](https://github.com/Theano/Theano)已停止，并分支成一个名为[Aesara](https://github.com/aesara-devs/aesara)的新项目。`sympy.printing.theanocode`模块已重命名为[`sympy.printing.aesaracode`](../modules/printing.html#module-sympy.printing.aesaracode
    "sympy.printing.aesaracode")，并且所有对应的函数也已重命名（例如，`theano_code`已重命名为[`aesara_code()`](../modules/printing.html#sympy.printing.aesaracode.aesara_code
    "sympy.printing.aesaracode.aesara_code")，`TheanoPrinter`已重命名为[`AesaraPrinter`](../modules/printing.html#sympy.printing.aesaracode.AesaraPrinter
    "sympy.printing.aesaracode.AesaraPrinter")等）。 ### `sympy.assumptions.handlers.AskHandler`和相关方法'
- en: '`Predicate` has experienced a big design change. Previously, its handler was
    a list of `AskHandler` classes and registration was done by `add_handler()` and
    `remove_handler()` functions. Now, its handler is a multipledispatch instance
    and registration is done by `register()` or `register_many()` methods. Users must
    define a predicate class to introduce a new one.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`经历了重大设计变化。先前，其处理程序是`AskHandler`类的列表，并通过`add_handler()`和`remove_handler()`函数进行注册。现在，其处理程序是一个`multipledispatch`实例，并通过`register()`或`register_many()`方法进行注册。用户必须定义一个谓词类来引入新的谓词。'
- en: 'Previously, handlers were defined and registered this way:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 先前，处理程序是通过以下方式定义和注册的：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It should be changed to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 应该更改为这样：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See GitHub issue [#20209](https://github.com/sympy/sympy/issues/20209).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 见GitHub问题[#20209](https://github.com/sympy/sympy/issues/20209)。
- en: Version 1.7.1
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本1.7.1
- en: '### Calling `sympy.stats.StochasticProcess.distribution` with `RandomIndexedSymbol`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用`RandomIndexedSymbol`调用`sympy.stats.StochasticProcess.distribution`'
- en: The `distribution` method of `sympy.stats` [stochastic processes](../modules/stats.html#sympy-stats-stochastic-processes)
    used to accept a `RandomIndexedSymbol` (that is, a stochastic process indexed
    with a timestamp), but should now only be called with the timestamp.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.stats`的`distribution`方法曾接受`RandomIndexedSymbol`（即按时间戳索引的随机过程），但现在应仅在时间戳下调用。'
- en: For example, if you have
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Previously this would work
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以前这样可以工作
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: It should now be called like
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该这样调用
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This was change was made as part of a change to store only `Basic` objects in
    `sympy.stats` `.args`. See issue [#20078](https://github.com/sympy/sympy/issues/20078)
    for details.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这一更改是作为存储只有`sympy.stats`中的`Basic`对象的`.args`的更改的一部分进行的。有关详情，请参见问题[#20078](https://github.com/sympy/sympy/issues/20078)。
- en: Version 1.7
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本1.7
- en: '### `sympy.stats.DiscreteMarkovChain.absorbing_probabilites()`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '### `sympy.stats.DiscreteMarkovChain.absorbing_probabilities()`'
- en: 'The `absorbing_probabilites` method name was misspelled. The correct spelling
    [`absorbing_probabilities()`](../modules/stats.html#sympy.stats.DiscreteMarkovChain.absorbing_probabilities
    "sympy.stats.DiscreteMarkovChain.absorbing_probabilities") (“absorbing probabilit*i*es”)
    should be used instead.  ### `sympy.utilities.misc.find_executable()`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`absorbing_probabilites`方法名称拼写错误。正确的拼写是[`absorbing_probabilities()`](../modules/stats.html#sympy.stats.DiscreteMarkovChain.absorbing_probabilities
    "sympy.stats.DiscreteMarkovChain.absorbing_probabilities")（“absorbing probabilit*i*es”）应该被使用。'
- en: 'The function `sympy.utilities.misc.find_executable()` is deprecated. Instead
    use the standard library [`shutil.which()`](https://docs.python.org/3/library/shutil.html#shutil.which)
    function, which has been in the standard library since Python 3.3 and is more
    powerful.  ### Mutable attributes in `sympy.diffgeom`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`sympy.utilities.misc.find_executable()`已被弃用。而应使用标准库中自Python 3.3起就存在的[`shutil.which()`](https://docs.python.org/3/library/shutil.html#shutil.which)函数，这更为强大。###
    `sympy.diffgeom`中的可变属性
- en: Several parts of [`sympy.diffgeom`](../modules/diffgeom.html#module-sympy.diffgeom
    "sympy.diffgeom") have been updated to no longer be mutable, which better matches
    the immutable design used in the rest of SymPy.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 多个部分在[`sympy.diffgeom`](../modules/diffgeom.html#module-sympy.diffgeom "sympy.diffgeom")中已更新，不再可变，这与SymPy其他部分使用的不可变设计更匹配。
- en: Passing strings for symbol names in [`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem
    "sympy.diffgeom.CoordSystem") is deprecated. Instead you should be explicit and
    pass symbols with the appropriate assumptions, for instance, instead of
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给[`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem "sympy.diffgeom.CoordSystem")的符号名称字符串已被弃用。相反，您应该明确地传递带有适当假设的符号，例如，而不是
- en: '[PRE54]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: use
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE55]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Similarly, the `names` keyword argument has been renamed to `symbols`, which
    should be a list of symbols.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`names`关键字参数已重命名为`symbols`，应为符号列表。
- en: The `Manifold.patches` attribute is deprecated. Patches should be tracked separately.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Manifold.patches`属性已被弃用。应该单独跟踪补丁。'
- en: The `Patch.coord_systems` attribute is deprecated. Coordinate systems should
    be tracked separately.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Patch.coord_systems`属性已被弃用。应该单独跟踪坐标系。'
- en: 'The `CoordSystem.transforms` attribute, `CoordSystem.connect_to()` method,
    and `CoordSystem.coord_tuple_transform_to()` method are deprecated. Instead, use
    the `relations` keyword to the `CoordSystem` class constructor and the [`CoordSystem.transformation()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transformation
    "sympy.diffgeom.CoordSystem.transformation") and [`CoordSystem.transform()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transform
    "sympy.diffgeom.CoordSystem.transform") methods (see the docstring of [`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem
    "sympy.diffgeom.CoordSystem") for examples).  ### The `unicode` argument and attribute
    to `sympy.printing.pretty.stringpict.prettyForm` and the `sympy.printing.pretty.pretty_symbology.xstr`
    function'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoordSystem.transforms`属性，`CoordSystem.connect_to()`方法以及`CoordSystem.coord_tuple_transform_to()`方法已被弃用。应使用`CoordSystem`类构造函数的`relations`关键字以及[`CoordSystem.transformation()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transformation
    "sympy.diffgeom.CoordSystem.transformation")和[`CoordSystem.transform()`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem.transform
    "sympy.diffgeom.CoordSystem.transform")方法（参见[`CoordSystem`](../modules/diffgeom.html#sympy.diffgeom.CoordSystem
    "sympy.diffgeom.CoordSystem")的文档字符串以获取示例）。### `sympy.printing.pretty.stringpict.prettyForm`和`sympy.printing.pretty.pretty_symbology.xstr`函数的`unicode`参数和属性'
- en: 'The `sympy.printing.pretty.pretty_symbology.xstr` function, and the `unicode`
    argument and attribute to [`sympy.printing.pretty.stringpict.prettyForm`](../modules/printing.html#sympy.printing.pretty.stringpict.prettyForm
    "sympy.printing.pretty.stringpict.prettyForm") were both present to support the
    Unicode behavior of Python 2\. Since Unicode strings are the default in Python
    3, these are not needed any more. `xstr()` should be replaced with just `str()`,
    the `unicode` argument to `prettyForm` should be omitted, and the `prettyForm.unicode`
    attribute should be replaced with the `prettyForm.s` attribute.  ### Passing the
    arguments to `lambdify` as a `set`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.printing.pretty.pretty_symbology.xstr`函数以及[`sympy.printing.pretty.stringpict.prettyForm`](../modules/printing.html#sympy.printing.pretty.stringpict.prettyForm
    "sympy.printing.pretty.stringpict.prettyForm")的`unicode`参数和属性都是为了支持Python 2的Unicode行为而存在的。由于Python
    3中Unicode字符串是默认的，这些不再需要。应将`xstr()`替换为`str()`，省略`prettyForm`的`unicode`参数，并用`prettyForm.s`属性替换`prettyForm.unicode`属性。###
    将参数作为`lambdify`的`set`传递'
- en: Passing the function arguments to lambdify as a set is deprecated. Instead pass
    them as a list or tuple. For example, instead of
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 传递函数参数作为`lambdify`的集合已被弃用。应作为列表或元组传递它们。例如，而不是
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: use
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE57]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is because sets are unordered. For instance, in the above example it would
    be impossible for `lambidfy` to know if it was called with `{x, y}` or `{y, x}`.
    Thus, when passed the arguments as a set `lambdify` would have to guess their
    order, which would lead to an incorrect function if it guessed incorrectly.  ###
    Core operators no longer accept non-Expr args'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '这是因为集合是无序的。 例如，在上面的示例中，`lambidfy`无法知道它是否以`{x, y}`或`{y, x}`调用。 因此，当作为集合传递参数时，`lambdify`必须猜测它们的顺序，如果猜测错误，将导致函数不正确。  ###
    核心运算符不再接受非Expr参数'
- en: The core operator classes [`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add"),
    [`Mul`](../modules/core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"), and [`Pow`](../modules/core.html#sympy.core.power.Pow
    "sympy.core.power.Pow") can no longer be constructed directly with objects that
    are not subclasses of [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr").
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 核心操作类[`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add")，[`Mul`](../modules/core.html#sympy.core.mul.Mul
    "sympy.core.mul.Mul")和[`Pow`](../modules/core.html#sympy.core.power.Pow "sympy.core.power.Pow")现在不能直接使用非[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")子类的对象构造。
- en: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    is the superclass of all SymPy classes that represent scalar numeric quantities.
    For example, [`sin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin"), [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"), and [`Add`](../modules/core.html#sympy.core.add.Add
    "sympy.core.add.Add") are all subclasses of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"). However, may objects in SymPy are not [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") because they represent some other type of mathematical
    object. For example, [`Set`](../modules/sets.html#sympy.sets.sets.Set "sympy.sets.sets.Set"),
    [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    and [`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean")
    are all non-`Expr`. These do not make mathematical sense inside of `Add`, `Mul`,
    and `Pow`, which are designed specifically to represent the addition, multiplication,
    and exponentiation of scalar complex numbers.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")是所有表示标量数值数量的SymPy类的超类。
    例如，[`sin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin")，[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol")和[`Add`](../modules/core.html#sympy.core.add.Add "sympy.core.add.Add")都是[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")的子类。 但是，SymPy中的许多对象不是[`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")，因为它们表示其他类型的数学对象。 例如，[`Set`](../modules/sets.html#sympy.sets.sets.Set
    "sympy.sets.sets.Set")，[`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")和[`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean
    "sympy.logic.boolalg.Boolean")都不是`Expr`。 这些对象在`Add`，`Mul`和`Pow`内部没有数学意义，这些类专门用于表示标量复数的加法，乘法和指数运算。'
- en: Manually constructing one of these classes with such an object is possible,
    but it will generally create something that will then break. For example
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以手动构造这些类的一个对象，但通常会导致错误。 例如
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: works and creates `Tuple(2)`, but only because `Mul` is “tricked” by always
    treating \(1 \cdot x = x\). If instead you try
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 可以工作并创建`Tuple(2)`，但仅因为`Mul`始终将 \(1 \cdot x = x\) 视为“欺骗”。 如果您尝试
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: it fails with an exception
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败并引发异常
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: because it tries to call a method of `Expr` on the `Tuple` object, which does
    not have all the `Expr` methods (because it is not a subclass of `Expr`).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它尝试在`Tuple`对象上调用`Expr`的方法，而`Tuple`对象没有所有`Expr`方法（因为它不是`Expr`的子类）。
- en: If you want to use the `+`, `*`, or `**` operation on a non-`Expr` object, use
    the operator directly rather than using `Mul`, `Add` or `Pow`. If functional versions
    of these are desired, you can use a `lambda` or the [`operator`](https://docs.python.org/3/library/operator.html)
    module.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在非`Expr`对象上使用`+`，`*`或`**`操作，请直接使用运算符，而不是使用`Mul`，`Add`或`Pow`。 如果需要函数版本，可以使用`lambda`或[`operator`](https://docs.python.org/3/library/operator.html)模块。
- en: Version 1.6
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本1.6
- en: '### Various `sympy.utilities` submodules have moved'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '### 各种 `sympy.utilities` 子模块已迁移'
- en: The following submodules have been renamed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子模块已更名。
- en: '`sympy.utilities.benchmarking` → `sympy.testing.benchmarking`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.utilities.benchmarking` → `sympy.testing.benchmarking`'
- en: '`sympy.utilities.pytest` → `sympy.testing.pytest`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.utilities.pytest` → `sympy.testing.pytest`'
- en: '`sympy.utilities.randtests` → `sympy.core.random`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.utilities.randtests` → `sympy.core.random`'
- en: '`sympy.utilities.runtests` → `sympy.testing.runtests`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.utilities.runtests` → `sympy.testing.runtests`'
- en: '`sympy.utilities.tmpfiles` → `sympy.testing.tmpfiles`  ### `sympy.testing.randtest`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.utilities.tmpfiles` → `sympy.testing.tmpfiles`  ### `sympy.testing.randtest`'
- en: '`sympy.testing.randtest` is deprecated. The functions in it have been moved
    to `sympy.core.random`. The following functions have been moved.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest` 已经弃用。其中的函数已移至 `sympy.core.random`。以下函数已移动。'
- en: '`sympy.testing.randtest.random_complex_number` → `sympy.core.random.random_complex_number`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest.random_complex_number` → `sympy.core.random.random_complex_number`'
- en: '`sympy.testing.randtest.verify_numerically` `sympy.core.random.verify_numerically`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest.verify_numerically` → `sympy.core.random.verify_numerically`'
- en: '`sympy.testing.randtest.test_derivative_numerically` → `sympy.core.random.test_derivative_numerically`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest.test_derivative_numerically` → `sympy.core.random.test_derivative_numerically`'
- en: '`sympy.testing.randtest._randrange` → `sympy.core.random._randrange`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest._randrange` → `sympy.core.random._randrange`'
- en: '`sympy.testing.randtest._randint` → `sympy.core.random._randint`  ### Mixing
    `Poly` and non-polynomial expressions in binary operations'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sympy.testing.randtest._randint` → `sympy.core.random._randint`  ### 在二进制操作中混合
    `Poly` 和非多项式表达式'
- en: In previous versions of SymPy, [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") was a subclass of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), but it has been changed to only be a subclass of [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). This means that some things that used to work with
    `Poly` are now deprecated because they are only designed to work with [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 SymPy 版本中，[`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 是 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 的子类，但现在它已被更改为只是 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 的子类。这意味着某些以前与 `Poly` 一起工作的功能现在已弃用，因为它们仅设计用于与 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 对象一起使用。
- en: This includes combining `Poly` with `Expr` objects using binary operations,
    for example
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括使用二进制操作组合 `Poly` 和 `Expr` 对象，例如
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To do this, either explicitly convert the non-`Poly` operand to a `Poly` using
    [`Expr.as_poly()`](../modules/core.html#sympy.core.expr.Expr.as_poly "sympy.core.expr.Expr.as_poly")
    or convert the `Poly` operand to an [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") using [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr"), depending on which type you want the result
    to be.  ### The `print_cyclic` flag of `sympy.combinatorics.Permutation`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '要实现此功能，可以通过使用 [`Expr.as_poly()`](../modules/core.html#sympy.core.expr.Expr.as_poly
    "sympy.core.expr.Expr.as_poly") 将非 `Poly` 操作数显式转换为 `Poly`，或者通过使用 [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr") 将 `Poly` 操作数转换为 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")，具体取决于你想要的结果类型。 ### `sympy.combinatorics.Permutation` 的
    `print_cyclic` 标志'
- en: The `print_cyclic` attribute of [`sympy.combintorics.Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") controls whether permutations
    print as cycles or arrays. This would be done by setting `Permutation.print_cyclic
    = True` or `Permutation.print_cyclic = False`. However, this method of controlling
    printing is bad because it is a global flag, but printing should not depend on
    global behavior.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.combinatorics.Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") 的 `print_cyclic` 属性控制排列打印为循环还是数组。可以通过设置
    `Permutation.print_cyclic = True` 或 `Permutation.print_cyclic = False` 来实现。然而，这种控制打印方式的方法并不好，因为它是一个全局标志，而打印不应该依赖于全局行为。'
- en: Instead, users should use the `perm_cyclic` flag of the corresponding printer.
    The easiest way to configure this is to set the flag when calling [`init_printing()`](../modules/interactive.html#sympy.interactive.printing.init_printing
    "sympy.interactive.printing.init_printing"), like
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，用户应该使用相应打印机的 `perm_cyclic` 标志。配置此项的最简单方法是在调用 [`init_printing()`](../modules/interactive.html#sympy.interactive.printing.init_printing
    "sympy.interactive.printing.init_printing") 时设置该标志，例如
- en: '[PRE62]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The [`Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") docstring contains more details
    on the `perm_cyclic` flag.  ### Using `integrate` with `Poly`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Permutation`](../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") 的文档字符串详细介绍了 `perm_cyclic` 标志。###
    使用 `integrate` 和 `Poly`'
- en: In previous versions of SymPy, [`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") was a subclass of [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), but it has been changed to only be a subclass of [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). This means that some things that used to work with
    `Poly` are now deprecated because they are only designed to work with [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") objects.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 SymPy 版本中，[`Poly`](../modules/polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 是 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 的子类，但现在已更改为仅是 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 的子类。这意味着某些以前与 `Poly` 一起工作的东西现在已经过时，因为它们只设计用于与 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 对象一起使用。
- en: This includes calling [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") or [`Integral`](../modules/integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral") with `Poly`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 包括使用 `Poly` 调用 [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") 或 [`Integral`](../modules/integrals/integrals.html#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")。
- en: To integrate a `Poly`, use the [`Poly.integrate()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.integrate
    "sympy.polys.polytools.Poly.integrate") method. To compute the integral as an
    [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") object,
    call the [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr") method first.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 `Poly` 进行积分，使用 [`Poly.integrate()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.integrate
    "sympy.polys.polytools.Poly.integrate") 方法。要将积分计算为 [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 对象，请首先调用 [`Poly.as_expr()`](../modules/polys/reference.html#sympy.polys.polytools.Poly.as_expr
    "sympy.polys.polytools.Poly.as_expr") 方法。
- en: 'See also [Mixing Poly and non-polynomial expressions in binary operations](#deprecated-poly-nonpoly-binary-operations)
    above.  ### Creating an indefinite `Integral` with an `Eq` argument'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅 [在二元操作中混合多项式和非多项式表达式](#deprecated-poly-nonpoly-binary-operations) 上方。###
    使用 `Eq` 参数创建不定积分 `Integral`
- en: Passing an [`Eq()`](../modules/core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    object to [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") is deprecated in the case where the integral
    is indefinite. This is because if \(f(x) = g(x)\), then \(\int f(x)\,dx = \int
    g(x)\,dx\) is not true in general, due to the arbitrary constants (which `integrate`
    does not include).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [`Eq()`](../modules/core.html#sympy.core.relational.Equality "sympy.core.relational.Equality")
    对象传递给 [`integrate()`](../modules/integrals/integrals.html#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") 在积分为不定积分的情况下已经过时。这是因为如果 \(f(x) = g(x)\)，那么一般来说
    \(\int f(x)\,dx = \int g(x)\,dx\) 是不成立的，这是由于任意常数（`integrate` 不包括这些常数）。
- en: If you want to make an equality of indefinite integrals, use `Eq(integrate(f(x),
    x), integrate(g(x), x))` explicitly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建不定积分的等式，请明确使用 `Eq(integrate(f(x), x), integrate(g(x), x))`。
- en: If you already have an equality object `eq`, you can use `Eq(integrate(eq.lhs,
    x), integrate(eq.rhs, x))`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经有一个等式对象 `eq`，可以使用 `Eq(integrate(eq.lhs, x), integrate(eq.rhs, x))`。
- en: Version 1.5
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.5
- en: '### `Tensor.fun_eval` and `Tensor.__call__`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '### `Tensor.fun_eval` 和 `Tensor.__call__`'
- en: '`TensExpr.fun_eval` and `Tensor.__call__` (i.e., calling a tensor to evaluate
    it) are deprecated. The `Tensor.substitute_indices()` method should be used. This
    was changed because `fun_eval` was considered a confusing name and using function
    evaluation was considered both confusing and dangerous.  ### `TensorType`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`TensExpr.fun_eval` 和 `Tensor.__call__`（即调用张量来评估它）已经过时。应该使用 `Tensor.substitute_indices()`
    方法。这一变更是因为 `fun_eval` 被认为是一个令人困惑的名称，并且使用函数评估被认为是既令人困惑又危险的。### `TensorType`'
- en: The `TensorType` class is deprecated. Use [`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads") instead. The `TensorType` class had no purpose
    except shorter creation of [`TensorHead`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorHead
    "sympy.tensor.tensor.TensorHead") objects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`TensorType`类已弃用。请使用[`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads")代替。`TensorType`类除了更短地创建[`TensorHead`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorHead
    "sympy.tensor.tensor.TensorHead")对象之外，没有其他用途。'
- en: 'See also [The tensorhead() function](#deprecated-tensorhead) below.  ### The
    `dummy_fmt` argument to `TensorIndexType`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '另请参阅下面的[The tensorhead() function](#deprecated-tensorhead)。  ### `TensorIndexType`的`dummy_fmt`参数'
- en: 'The `dummy_fmt` keyword argument to [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") is deprecated. Setting `dummy_fmt=''L''`
    leads to `_dummy_fmt=''L_%d''`, which is confusing and uses obsolete string formatting.
    `dummy_name` should be used instead. This change was made because `dummy_name`
    is a clearer name.  ### The `metric` argument to `TensorIndexType`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType")的`dummy_fmt`关键字参数已弃用。设置`dummy_fmt=''L''`将导致`_dummy_fmt=''L_%d''`，这是令人困惑并且使用过时的字符串格式化。应改用`dummy_name`。这个改变是因为`dummy_name`是一个更清晰的名称。  ###
    `TensorIndexType`的`metric`参数'
- en: The `metric` keyword argument to [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") is deprecated. The name “metric” was ambiguous
    because it meant “metric symmetry” in some places and “metric tensor” in others.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType")的`metric`关键字参数已弃用。名称“metric”在某些地方指“度量对称性”，在其他地方指“度量张量”，存在歧义。'
- en: 'Either the `metric_symmetry` keyword or the `TensorIndexType.set_metric()`
    method should be used instead.  ### The `get_kronecker_delta()` and `get_epsilon()`
    methods of `TensorIndexType`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '应使用`metric_symmetry`关键字或`TensorIndexType.set_metric()`方法。  ### `TensorIndexType`的`get_kronecker_delta()`和`get_epsilon()`方法'
- en: 'The `get_kronecker_delta()` and `get_epsilon()` methods of [`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType") are deprecated. Use the `TensorIndexType.delta`
    and `TensorIndexType.epsilon` properties instead, respectively.  ### The `tensorsymmetry()`
    function'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TensorIndexType`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType
    "sympy.tensor.tensor.TensorIndexType")的`get_kronecker_delta()`和`get_epsilon()`方法已弃用。分别使用`TensorIndexType.delta`和`TensorIndexType.epsilon`属性。  ###
    `tensorsymmetry()`函数'
- en: The `tensorsymmetry()` function in `sympy.tensor` is deprecated. Use the [`TensorSymmetry`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorSymmetry
    "sympy.tensor.tensor.TensorSymmetry") class constructor instead.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy.tensor`中的`tensorsymmetry()`函数已经被弃用。请使用[`TensorSymmetry`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensorSymmetry
    "sympy.tensor.tensor.TensorSymmetry")类构造函数替代。'
- en: '`TensorSymmetry` is preferred over `tensorsymmetry()` because the latter'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`TensorSymmetry`优于`tensorsymmetry()`，因为后者'
- en: Does not have any extra functionality
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有额外的功能
- en: Involves obscure Young tableau
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 涉及晦涩的Young表
- en: 'Is not a member of the `TensorSymmetry` class  ### The `tensorhead()` function'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '不是`TensorSymmetry`类的成员  ### `tensorhead()`函数'
- en: 'The `tensorhead()` function is deprecated in favor of [`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads"). `tensor_heads()` is more consistent with
    other SymPy names (i.e., `Symbol` and `symbols()` or `TensorIndex` and `tensor_indices()`).
    It also does not use Young tableau to denote symmetries.  ### The `is_EmptySet`
    attribute of sets'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`tensorhead()`函数已弃用，建议使用[`tensor_heads()`](../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_heads
    "sympy.tensor.tensor.tensor_heads")代替。`tensor_heads()`与SymPy的其他命名（例如，`Symbol`和`symbols()`或`TensorIndex`和`tensor_indices()`）更一致。它也不使用Young表来表示对称性。  ###
    集合的`is_EmptySet`属性'
- en: The `is_EmptySet` attribute of [Set](../modules/sets.html#sets-module) objects
    is deprecated. Instead either use
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[Set](../modules/sets.html#sets-module)对象的`is_EmptySet`属性已弃用。而是使用'
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: or
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The difference is that `s.is_empty` may return `None` if it is unknown if the
    set is empty.  ### `ProductSet(iterable)`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '不同之处在于如果集合是否为空未知时，`s.is_empty`可能返回`None`。  ### `ProductSet(iterable)`'
- en: Passing a single iterable as the first argument to [`ProductSet`](../modules/sets.html#sympy.sets.sets.ProductSet
    "sympy.sets.sets.ProductSet") is deprecated. Creating a product set from an iterable
    should be done using `ProductSet(*iterable)`, or as each individual argument.
    For example
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个可迭代对象作为[`ProductSet`](../modules/sets.html#sympy.sets.sets.ProductSet "sympy.sets.sets.ProductSet")的第一个参数已被弃用。应该使用`ProductSet(*iterable)`创建产品集，或者作为每个单独的参数。例如
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is done because sets themselves can be iterables, and sets of sets are
    allowed. But the product set of a single set should mathematically be that set
    itself (or more exactly, the set of 1-tuples of elements of that set). Automatically
    denesting a single iterable makes it impossible to represent this object and makes
    `ProductSet` not generalize correctly when passed 1 argument. On the other hand,
    treating the first argument differently if it is a set than if it is another type
    of iterable (which is what is currently done in the deprecated code path) is confusing
    behavior.  ### The `set_potential_energy` method in `sympy.physics.mechanics`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以这样做是因为集合本身可以是可迭代的，而集合的集合也是允许的。但是，单个可迭代对象的产品集在数学上应该是该集合本身（或更确切地说，该集合的元素的一元组的集合）。自动去嵌套单个可迭代对象使得无法表示这种对象，并且在传递1个参数时，使得`ProductSet`不能正确推广。另一方面，在旧代码路径中，如果第一个参数是集合，则对其进行不同处理与处理其他类型的可迭代对象（当前弃用的代码路径）会导致行为混乱。###
    在`sympy.physics.mechanics`中的`set_potential_energy`方法
- en: The `set_potential_energy()` methods of [`sympy.physics.mechanics.particle.Particle`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle
    "sympy.physics.mechanics.particle.Particle") and [`sympy.physics.mechanics.rigidbody.RigidBody`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody
    "sympy.physics.mechanics.rigidbody.RigidBody") are deprecated.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.physics.mechanics.particle.Particle`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle
    "sympy.physics.mechanics.particle.Particle")和[`sympy.physics.mechanics.rigidbody.RigidBody`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody
    "sympy.physics.mechanics.rigidbody.RigidBody")的`set_potential_energy()`方法已被弃用。'
- en: Instead one should set the [`Particle.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle.potential_energy
    "sympy.physics.mechanics.particle.Particle.potential_energy") and [`RigidBody.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody.potential_energy
    "sympy.physics.mechanics.rigidbody.RigidBody.potential_energy") attributes to
    set the potential energy, like
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应该设置[`Particle.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.particle.Particle.potential_energy
    "sympy.physics.mechanics.particle.Particle.potential_energy")和[`RigidBody.potential_energy`](../modules/physics/mechanics/api/part_bod.html#sympy.physics.mechanics.rigidbody.RigidBody.potential_energy
    "sympy.physics.mechanics.rigidbody.RigidBody.potential_energy")属性来设置势能，例如
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This change was made to be more Pythonic, by using setters and getters of a
    `@property` method rather than an explicit `set_` method.  ### Using a set for
    the condition in `ConditionSet`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变更是为了更符合Python风格，使用`@property`方法的设置器和获取器，而不是显式的`set_`方法。### 在`ConditionSet`中使用集合表示条件
- en: Using a set for the condition in ConditionSet is deprecated. A boolean should
    be used instead. This is because the condition is mathematically a boolean, and
    it is ambiguous what a set should mean in this context.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConditionSet`中使用集合表示条件已被弃用。应该使用布尔值代替。这是因为条件在数学上是布尔值，而在此上下文中使用集合会引起歧义。
- en: To fix this deprecation, replace
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复此弃用问题，请替换
- en: '[PRE67]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: with
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For example,
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: would become
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 会变成
- en: '[PRE70]  ### The `max_degree` and `get_upper_degree` properties of `sympy.polys.multivariate_resultants.DixonResultant`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE70]### `sympy.polys.multivariate_resultants.DixonResultant`的`max_degree`和`get_upper_degree`属性'
- en: 'The `max_degree` property and `get_upper_degree()` methods of `DixonResultant`
    are deprecated. See issue [#17749](https://github.com/sympy/sympy/pull/17749)
    for details.  ### Non-tuple iterable for the first argument to `Lambda`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`DixonResultant`的`max_degree`属性和`get_upper_degree()`方法已被弃用。详细信息请参见问题[#17749](https://github.com/sympy/sympy/pull/17749)。###
    对于`Lambda`，第一个参数不是元组而是其他可迭代对象'
- en: Using a non-tuple as the first argument to [`Lambda`](../modules/core.html#sympy.core.function.Lambda
    "sympy.core.function.Lambda") is deprecated. If you have a non-tuple, convert
    it to a tuple first, like `Lambda(tuple(args), expr)`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非元组作为[`Lambda`](../modules/core.html#sympy.core.function.Lambda "sympy.core.function.Lambda")的第一个参数已被弃用。如果参数不是元组，请首先将其转换为元组，如`Lambda(tuple(args),
    expr)`。
- en: This was done so that `Lambda` could support general tuple unpacking, like
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是因为`Lambda`能够支持通用的元组解包，例如
- en: '[PRE71]  ### The `evaluate` flag to `differentiate_finite`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE71]  ### `differentiate_finite` 的 `evaluate` 标志'
- en: The `evaluate` flag to [`differentiate_finite()`](../modules/calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite") is deprecated.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[`differentiate_finite()`](../modules/calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite") 的 `evaluate` 标志已弃用。'
- en: '`differentiate_finite(expr, x, evaluate=True)` expands the intermediate derivatives
    before computing differences. But this usually not what you want, as it does not
    satisfy the product rule.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`differentiate_finite(expr, x, evaluate=True)` 在计算差分之前会展开中间导数。但通常这不是你想要的，因为它不符合乘积法则。'
- en: If you really do want this behavior, you can emulate it with
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要这种行为，你可以用以下方式模拟它：
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: See the discussion on issue [#17881](https://github.com/sympy/sympy/pull/17881).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 参见问题讨论 [#17881](https://github.com/sympy/sympy/pull/17881)。
- en: Version 1.4
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本 1.4
- en: '### `TensorIndexType.data` and related methods'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '### `TensorIndexType.data` 和相关方法'
- en: The `TensorIndexType.data` property is deprecated, as well as several methods
    which made use of it including the `get_matrix()`, the `__getitem__()` (indexing),
    `__iter__()` (iteration), `_components_data_full_destroy()`, and `__pow__()` (`**`)
    methods. Storing data on tensor objects was a design flaw and not consistent with
    how the rest of SymPy works.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`TensorIndexType.data` 属性已弃用，以及使用它的几个方法，包括 `get_matrix()`，`__getitem__()`（索引），`__iter__()`（迭代），`_components_data_full_destroy()`
    和 `__pow__()`（`**`）方法。在张量对象上存储数据是一种设计缺陷，并不符合 SymPy 的其余工作方式。'
- en: Instead, the [`TensExpr.replace_with_arrays()`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensExpr.replace_with_arrays
    "sympy.tensor.tensor.TensExpr.replace_with_arrays") method should be used.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 取而代之的是应该使用 [`TensExpr.replace_with_arrays()`](../modules/tensor/tensor.html#sympy.tensor.tensor.TensExpr.replace_with_arrays
    "sympy.tensor.tensor.TensExpr.replace_with_arrays") 方法。
