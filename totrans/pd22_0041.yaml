- en: 'Group by: split-apply-combine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/groupby.html](https://pandas.pydata.org/docs/user_guide/groupby.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By “group by” we are referring to a process involving one or more of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Splitting** the data into groups based on some criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applying** a function to each group independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combining** the results into a data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Out of these, the split step is the most straightforward. In the apply step,
    we might wish to do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregation**: compute a summary statistic (or statistics) for each group.
    Some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute group sums or means.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute group sizes / counts.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformation**: perform some group-specific computations and return a like-indexed
    object. Some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize data (zscore) within a group.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Filling NAs within groups with a value derived from each group.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtration**: discard some groups, according to a group-wise computation
    that evaluates to True or False. Some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discard data that belong to groups with only a few members.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Filter out data based on the group sum or mean.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these operations are defined on GroupBy objects. These operations are
    similar to those of the [aggregating API](basics.html#basics-aggregate), [window
    API](window.html#window-overview), and [resample API](timeseries.html#timeseries-aggregate).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that a given operation does not fall into one of these categories
    or is some combination of them. In such a case, it may be possible to compute
    the operation using GroupBy’s `apply` method. This method will examine the results
    of the apply step and try to sensibly combine them into a single result if it
    doesn’t fit into either of the above three categories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An operation that is split into multiple steps using built-in GroupBy operations
    will be more efficient than using the `apply` method with a user-defined Python
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name GroupBy should be quite familiar to those who have used a SQL-based
    tool (or `itertools`), in which you can write code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We aim to make operations like this natural and easy to express using pandas.
    We’ll address each area of GroupBy functionality, then provide some non-trivial
    examples / use cases.
  prefs: []
  type: TYPE_NORMAL
- en: See the [cookbook](cookbook.html#cookbook-grouping) for some advanced strategies.
  prefs: []
  type: TYPE_NORMAL
- en: '## Splitting an object into groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'The abstract definition of grouping is to provide a mapping of labels to group
    names. To create a GroupBy object (more on what the GroupBy object is later),
    you may do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping can be specified many different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python function, to be called on each of the index labels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list or NumPy array of the same length as the index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dict or `Series`, providing a `label -> group name` mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `DataFrame` objects, a string indicating either a column name or an index
    level name to be used to group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of any of the above things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collectively we refer to the grouping objects as the **keys**. For example,
    consider the following `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A string passed to `groupby` may refer to either a column or an index level.
    If a string matches both a column name and an index level name, a `ValueError`
    will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On a DataFrame, we obtain a GroupBy object by calling [`groupby()`](../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby"). This method returns a `pandas.api.typing.DataFrameGroupBy`
    instance. We could naturally group by either the `A` or `B` columns, or both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`df.groupby(''A'')` is just syntactic sugar for `df.groupby(df[''A''])`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we also have a MultiIndex on columns `A` and `B`, we can group by all the
    columns except the one we specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The above GroupBy will split the DataFrame on its index (rows). To split by
    columns, first do a transpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    objects support duplicate values. If a non-unique index is used as the group key
    in a groupby operation, all values for the same index value will be considered
    to be in one group and thus the output of aggregation functions will only contain
    unique index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that **no splitting occurs** until it’s needed. Creating the GroupBy object
    only verifies that you’ve passed a valid mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many kinds of complicated data manipulations can be expressed in terms of GroupBy
    operations (though it can’t be guaranteed to be the most efficient implementation).
    You can get quite creative with the label mapping functions.
  prefs: []
  type: TYPE_NORMAL
- en: '### GroupBy sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default the group keys are sorted during the `groupby` operation. You may
    however pass `sort=False` for potential speedups. With `sort=False` the order
    among group-keys follows the order of appearance of the keys in the original dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `groupby` will preserve the order in which *observations* are sorted
    *within* each group. For example, the groups created by `groupby()` below are
    in the order they appeared in the original `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#### GroupBy dropna'
  prefs: []
  type: TYPE_NORMAL
- en: By default `NA` values are excluded from group keys during the `groupby` operation.
    However, in case you want to include `NA` values in group keys, you could pass
    `dropna=False` to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The default setting of `dropna` argument is `True` which means `NA` are not
    included in group keys.  ### GroupBy object attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groups` attribute is a dictionary whose keys are the computed unique groups
    and corresponding values are the axis labels belonging to each group. In the above
    example we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the standard Python `len` function on the GroupBy object returns the
    number of groups, which is the same as the length of the `groups` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`GroupBy` will tab complete column names, GroupBy operations, and other attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]  ### GroupBy with MultiIndex'
  prefs: []
  type: TYPE_NORMAL
- en: With [hierarchically-indexed data](advanced.html#advanced-hierarchical), it’s
    quite natural to group by one of the levels of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a Series with a two-level `MultiIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can then group by one of the levels in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the MultiIndex has names specified, these can be passed instead of the level
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with multiple levels is supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be supplied as keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: More on the `sum` function and aggregation later.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping DataFrame with Index levels and columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DataFrame may be grouped by a combination of columns and index levels. You
    can specify both column and index names, or use a [`Grouper`](../reference/api/pandas.Grouper.html#pandas.Grouper
    "pandas.Grouper").
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create a DataFrame with a MultiIndex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Then we group `df` by the `second` index level and the `A` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Index levels may also be specified by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be specified as keys directly to `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: DataFrame column selection in GroupBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have created the GroupBy object from a DataFrame, you might want to
    do something different for each of the columns. Thus, by using `[]` on the GroupBy
    object in a similar way as the one used to get a column from a DataFrame, you
    can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is mainly syntactic sugar for the alternative, which is much more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, this method avoids recomputing the internal grouping information
    derived from the passed key.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include the grouping columns if you want to operate on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]  ## Iterating through groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the GroupBy object in hand, iterating through the grouped data is very
    natural and functions similarly to [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of grouping by multiple keys, the group name will be a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See [Iterating through groups](timeseries.html#timeseries-iterating-label).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single group can be selected using [`DataFrameGroupBy.get_group()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.get_group.html#pandas.core.groupby.DataFrameGroupBy.get_group
    "pandas.core.groupby.DataFrameGroupBy.get_group"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for an object grouped on multiple columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '## Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: An aggregation is a GroupBy operation that reduces the dimension of the grouping
    object. The result of an aggregation is, or at least is treated as, a scalar value
    for each column in a group. For example, producing the sum of each column in a
    group of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the result, the keys of the groups appear in the index by default. They can
    be instead included in the columns by passing `as_index=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '### Built-in aggregation methods'
  prefs: []
  type: TYPE_NORMAL
- en: Many common aggregations are built-in to GroupBy objects as methods. Of the
    methods listed below, those with a `*` do *not* have an efficient, GroupBy-specific,
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`any()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.any.html#pandas.core.groupby.DataFrameGroupBy.any
    "pandas.core.groupby.DataFrameGroupBy.any") | Compute whether any of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`all()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.all.html#pandas.core.groupby.DataFrameGroupBy.all
    "pandas.core.groupby.DataFrameGroupBy.all") | Compute whether all of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`count()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") | Compute the number of non-NA values
    in the groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`cov()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cov.html#pandas.core.groupby.DataFrameGroupBy.cov
    "pandas.core.groupby.DataFrameGroupBy.cov") * | Compute the covariance of the
    groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`first()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.first.html#pandas.core.groupby.DataFrameGroupBy.first
    "pandas.core.groupby.DataFrameGroupBy.first") | Compute the first occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmax.html#pandas.core.groupby.DataFrameGroupBy.idxmax
    "pandas.core.groupby.DataFrameGroupBy.idxmax") | Compute the index of the maximum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmin.html#pandas.core.groupby.DataFrameGroupBy.idxmin
    "pandas.core.groupby.DataFrameGroupBy.idxmin") | Compute the index of the minimum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`last()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.last.html#pandas.core.groupby.DataFrameGroupBy.last
    "pandas.core.groupby.DataFrameGroupBy.last") | Compute the last occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`max()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.max.html#pandas.core.groupby.DataFrameGroupBy.max
    "pandas.core.groupby.DataFrameGroupBy.max") | Compute the maximum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`mean()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean
    "pandas.core.groupby.DataFrameGroupBy.mean") | Compute the mean of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`median()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.median.html#pandas.core.groupby.DataFrameGroupBy.median
    "pandas.core.groupby.DataFrameGroupBy.median") | Compute the median of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`min()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min
    "pandas.core.groupby.DataFrameGroupBy.min") | Compute the minimum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`nunique()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nunique.html#pandas.core.groupby.DataFrameGroupBy.nunique
    "pandas.core.groupby.DataFrameGroupBy.nunique") | Compute the number of unique
    values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`prod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.prod.html#pandas.core.groupby.DataFrameGroupBy.prod
    "pandas.core.groupby.DataFrameGroupBy.prod") | Compute the product of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`quantile()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.quantile.html#pandas.core.groupby.DataFrameGroupBy.quantile
    "pandas.core.groupby.DataFrameGroupBy.quantile") | Compute a given quantile of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sem()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sem.html#pandas.core.groupby.DataFrameGroupBy.sem
    "pandas.core.groupby.DataFrameGroupBy.sem") | Compute the standard error of the
    mean of the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`size()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") | Compute the number of values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`skew()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.skew.html#pandas.core.groupby.DataFrameGroupBy.skew
    "pandas.core.groupby.DataFrameGroupBy.skew") * | Compute the skew of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`std()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.std.html#pandas.core.groupby.DataFrameGroupBy.std
    "pandas.core.groupby.DataFrameGroupBy.std") | Compute the standard deviation of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum
    "pandas.core.groupby.DataFrameGroupBy.sum") | Compute the sum of the values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`var()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.var.html#pandas.core.groupby.DataFrameGroupBy.var
    "pandas.core.groupby.DataFrameGroupBy.var") | Compute the variance of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the size of each group. This is included
    in GroupBy as the `size` method. It returns a Series whose index consists of the
    group names and the values are the sizes of each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While the [`DataFrameGroupBy.describe()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.describe.html#pandas.core.groupby.DataFrameGroupBy.describe
    "pandas.core.groupby.DataFrameGroupBy.describe") method is not itself a reducer,
    it can be used to conveniently produce a collection of summary statistics about
    each of the groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the number of unique values of each
    group. This is similar to the [`DataFrameGroupBy.value_counts()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.value_counts.html#pandas.core.groupby.DataFrameGroupBy.value_counts
    "pandas.core.groupby.DataFrameGroupBy.value_counts") function, except that it
    only counts the number of unique values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation functions **will not** return the groups that you are aggregating
    over as named *columns* when `as_index=True`, the default. The grouped columns
    will be the **indices** of the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing `as_index=False` **will** return the groups that you are aggregating
    over as named columns, regardless if they are named **indices** or *columns* in
    the inputs.  ### The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method can accept many different
    types of inputs. This section details using string aliases for various GroupBy
    methods; other inputs are detailed in the sections below.
  prefs: []
  type: TYPE_NORMAL
- en: Any reduction method that pandas implements can be passed as a string to [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate"). Users are encouraged to use
    the shorthand, `agg`. It will operate as if the corresponding method was called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the aggregation will have the group names as the new index. In
    the case of multiple keys, the result is a [MultiIndex](advanced.html#advanced-hierarchical)
    by default. As mentioned above, this can be changed by using the `as_index` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that you could use the [`DataFrame.reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") DataFrame function to achieve the same result
    as the column names are stored in the resulting `MultiIndex`, although this will
    make an extra copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]  ### Aggregation with User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Users can also provide their own User-Defined Functions (UDFs) for custom aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When aggregating with a UDF, the UDF should not mutate the provided `Series`.
    See [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating with a UDF is often less performant than using the pandas built-in
    methods on GroupBy. Consider breaking up a complex operation into a chain of operations
    that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The resulting dtype will reflect that of the aggregating function. If the results
    from different groups have different dtypes, then a common dtype will be determined
    in the same way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]  ### Applying multiple functions at once'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a grouped `Series`, you can pass a list or dict of functions to `SeriesGroupBy.agg()`,
    outputting a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'On a grouped `DataFrame`, you can pass a list of functions to `DataFrameGroupBy.agg()`
    to aggregate each column, which produces an aggregated result with a hierarchical
    column index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting aggregations are named after the functions themselves. If you
    need to rename, then you can add in a chained operation for a `Series` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For a grouped `DataFrame`, you can rename in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, the output column names should be unique, but pandas will allow
    you apply to the same function (or two functions with the same name) to the same
    column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: pandas also allows you to provide multiple lambdas. In this case, pandas will
    mangle the name of the (nameless) lambda functions, appending `_<i>` to each subsequent
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]  ### Named aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: To support column-specific aggregation *with control over the output column
    names*, pandas accepts the special syntax in [`DataFrameGroupBy.agg()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") and [`SeriesGroupBy.agg()`](../reference/api/pandas.core.groupby.SeriesGroupBy.agg.html#pandas.core.groupby.SeriesGroupBy.agg
    "pandas.core.groupby.SeriesGroupBy.agg"), known as “named aggregation”, where
  prefs: []
  type: TYPE_NORMAL
- en: The keywords are the *output* column names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values are tuples whose first element is the column to select and the second
    element is the aggregation to apply to that column. pandas provides the [`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg
    "pandas.NamedAgg") namedtuple with the fields `['column', 'aggfunc']` to make
    it clearer what the arguments are. As usual, the aggregation can be a callable
    or a string alias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg "pandas.NamedAgg")
    is just a `namedtuple`. Plain tuples are allowed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the column names you want are not valid Python keywords, construct a dictionary
    and unpack the keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When using named aggregation, additional keyword arguments are not passed through
    to the aggregation functions; only pairs of `(column, aggfunc)` should be passed
    as `**kwargs`. If your aggregation functions require additional arguments, apply
    them partially with `functools.partial()`.
  prefs: []
  type: TYPE_NORMAL
- en: Named aggregation is also valid for Series groupby aggregations. In this case
    there’s no column selection, so the values are just the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Applying different functions to DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on GroupBy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]  ## Transformation'
  prefs: []
  type: TYPE_NORMAL
- en: A transformation is a GroupBy operation whose result is indexed the same as
    the one being grouped. Common examples include [`cumsum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumsum.html#pandas.core.groupby.DataFrameGroupBy.cumsum
    "pandas.core.groupby.DataFrameGroupBy.cumsum") and [`diff()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.diff.html#pandas.core.groupby.DataFrameGroupBy.diff
    "pandas.core.groupby.DataFrameGroupBy.diff").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Unlike aggregations, the groupings that are used to split the original object
    are not included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since transformations do not include the groupings that are used to split the
    result, the arguments `as_index` and `sort` in [`DataFrame.groupby()`](../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") and [`Series.groupby()`](../reference/api/pandas.Series.groupby.html#pandas.Series.groupby
    "pandas.Series.groupby") have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: A common use of a transformation is to add the result back into the original
    DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Built-in transformation methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`bfill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.bfill.html#pandas.core.groupby.DataFrameGroupBy.bfill
    "pandas.core.groupby.DataFrameGroupBy.bfill") | Back fill NA values within each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumcount()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumcount.html#pandas.core.groupby.DataFrameGroupBy.cumcount
    "pandas.core.groupby.DataFrameGroupBy.cumcount") | Compute the cumulative count
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummax.html#pandas.core.groupby.DataFrameGroupBy.cummax
    "pandas.core.groupby.DataFrameGroupBy.cummax") | Compute the cumulative max within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummin.html#pandas.core.groupby.DataFrameGroupBy.cummin
    "pandas.core.groupby.DataFrameGroupBy.cummin") | Compute the cumulative min within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumprod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumprod.html#pandas.core.groupby.DataFrameGroupBy.cumprod
    "pandas.core.groupby.DataFrameGroupBy.cumprod") | Compute the cumulative product
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumsum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumsum.html#pandas.core.groupby.DataFrameGroupBy.cumsum
    "pandas.core.groupby.DataFrameGroupBy.cumsum") | Compute the cumulative sum within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`diff()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.diff.html#pandas.core.groupby.DataFrameGroupBy.diff
    "pandas.core.groupby.DataFrameGroupBy.diff") | Compute the difference between
    adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`ffill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ffill.html#pandas.core.groupby.DataFrameGroupBy.ffill
    "pandas.core.groupby.DataFrameGroupBy.ffill") | Forward fill NA values within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`pct_change()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.pct_change.html#pandas.core.groupby.DataFrameGroupBy.pct_change
    "pandas.core.groupby.DataFrameGroupBy.pct_change") | Compute the percent change
    between adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`rank()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.rank.html#pandas.core.groupby.DataFrameGroupBy.rank
    "pandas.core.groupby.DataFrameGroupBy.rank") | Compute the rank of each value
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`shift()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.shift.html#pandas.core.groupby.DataFrameGroupBy.shift
    "pandas.core.groupby.DataFrameGroupBy.shift") | Shift values up or down within
    each group |'
  prefs: []
  type: TYPE_TB
- en: In addition, passing any built-in aggregation method as a string to [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") (see the next section) will
    broadcast the result across the group, producing a transformed result. If the
    aggregation method has an efficient implementation, this will be performant as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '### The [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the [aggregation method](#groupby-aggregate-agg), the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can accept string aliases
    to the built-in transformation methods in the previous section. It can *also*
    accept string aliases to the built-in aggregation methods. When an aggregation
    method is provided, the result will be broadcast across the group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to string aliases, the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can also accept User-Defined
    Functions (UDFs). The UDF must:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a result that is either the same size as the group chunk or broadcastable
    to the size of the group chunk (e.g., a scalar, `grouped.transform(lambda x: x.iloc[-1])`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate column-by-column on the group chunk. The transform is applied to the
    first group chunk using chunk.apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not perform in-place operations on the group chunk. Group chunks should be treated
    as immutable, and changes to a group chunk may produce unexpected results. See
    [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optionally) operates on all columns of the entire group chunk at once. If this
    is supported, a fast path is used starting from the *second* chunk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Transforming by supplying `transform` with a UDF is often less performant than
    using the built-in methods on GroupBy. Consider breaking up a complex operation
    into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in this section can be made more performant by calling built-in
    methods instead of using UDFs. See [below for examples](#groupby-efficient-transforms).
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.0: When using `.transform` on a grouped DataFrame and
    the transformation function returns a DataFrame, pandas now aligns the result’s
    index with the input’s index. You can call `.to_numpy()` within the transformation
    function to avoid alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to [The aggregate() method](#groupby-aggregate-agg), the resulting dtype
    will reflect that of the transformation function. If the results from different
    groups have different dtypes, then a common dtype will be determined in the same
    way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to standardize the data within each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We would expect the result to now have mean 0 and standard deviation 1 within
    each group (up to floating-point error), which we can easily check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We can also visually compare the original and transformed data sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_transform_plot.png](../Images/69f287bde1e1c618b8c84fdbd3fe04dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Transformation functions that have lower dimension outputs are broadcast to
    match the shape of the input array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Another common data transform is to replace missing data with the group mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can verify that the group means have not changed in the transformed data,
    and that the transformed data contains no NAs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the note above, each of the examples in this section can be
    computed more efficiently using built-in methods. In the code below, the inefficient
    way using a UDF is commented out and the faster alternative appears below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]  ### Window and resample operations'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use `resample()`, `expanding()` and `rolling()` as methods
    on groupbys.
  prefs: []
  type: TYPE_NORMAL
- en: The example below will apply the `rolling()` method on the samples of the column
    B, based on the groups of column A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `expanding()` method will accumulate a given operation (`sum()` in the example)
    for all the members of each particular group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you want to use the `resample()` method to get a daily frequency in
    each group of your dataframe, and wish to complete the missing values with the
    `ffill()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]  ## Filtration'
  prefs: []
  type: TYPE_NORMAL
- en: A filtration is a GroupBy operation that subsets the original grouping object.
    It may either filter out entire groups, part of groups, or both. Filtrations return
    a filtered version of the calling object, including the grouping columns when
    provided. In the following example, `class` is included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unlike aggregations, filtrations do not add the group keys to the index of the
    result. Because of this, passing `as_index=False` or `sort=True` will not affect
    these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Filtrations will respect subsetting the columns of the GroupBy object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Built-in filtrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as filtrations. All these methods have
    an efficient, GroupBy-specific, implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`head()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.head.html#pandas.core.groupby.DataFrameGroupBy.head
    "pandas.core.groupby.DataFrameGroupBy.head") | Select the top row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") | Select the nth row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`tail()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.tail.html#pandas.core.groupby.DataFrameGroupBy.tail
    "pandas.core.groupby.DataFrameGroupBy.tail") | Select the bottom row(s) of each
    group |'
  prefs: []
  type: TYPE_TB
- en: Users can also use transformations along with Boolean indexing to construct
    complex filtrations within groups. For example, suppose we are given groups of
    products and their volumes, and we wish to subset the data to only the largest
    products capturing no more than 90% of the total volume within each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by supplying `filter` with a User-Defined Function (UDF) is often
    less performant than using the built-in methods on GroupBy. Consider breaking
    up a complex operation into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method takes a User-Defined Function (UDF) that, when applied to
    an entire group, returns either `True` or `False`. The result of the `filter`
    method is then the subset of groups for which the UDF returned `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to take only elements that belong to groups with a group sum
    greater than 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Another useful operation is filtering out elements that belong to groups with
    only a couple members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, instead of dropping the offending groups, we can return a like-indexed
    objects where the groups that do not pass the filter are filled with NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: For DataFrames with multiple columns, filters should explicitly specify a column
    as the filter criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]  ## Flexible `apply`'
  prefs: []
  type: TYPE_NORMAL
- en: Some operations on the grouped data might not fit into the aggregation, transformation,
    or filtration categories. For these, you can use the `apply` function.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` has to try to infer from the result whether it should act as a reducer,
    transformer, *or* filter, depending on exactly what is passed to it. Thus the
    grouped column(s) may be included in the output or not. While it tries to intelligently
    guess how to behave, it can sometimes guess wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in this section can be more reliably, and more efficiently,
    computed using other pandas functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The dimension of the returned result can also change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`apply` on a Series can operate on a returned value from the applied function
    that is itself a series, and possibly upcast the result to a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [The aggregate() method](#groupby-aggregate-agg), the resulting dtype
    will reflect that of the apply function. If the results from different groups
    have different dtypes, then a common dtype will be determined in the same way
    as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: Control grouped column(s) placement with `group_keys`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To control whether the grouped column(s) are included in the indices, you can
    use the argument `group_keys` which defaults to `True`. Compare
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Numba Accelerated Routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: If [Numba](https://numba.pydata.org/) is installed as an optional dependency,
    the `transform` and `aggregate` methods support `engine='numba'` and `engine_kwargs`
    arguments. See [enhancing performance with Numba](enhancingperf.html#enhancingperf-numba)
    for general usage of the arguments and performance considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature must start with `values, index` **exactly** as the data
    belonging to each group will be passed into `values`, and the group index will
    be passed into `index`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using `engine='numba'`, there will be no “fall back” behavior internally.
    The group data and group index will be passed as NumPy arrays to the JITed user
    defined function, and no alternative execution attempts will be tried.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exclusion of non-numeric columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again consider the example DataFrame we’ve been looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to compute the standard deviation grouped by the `A` column.
    There is a slight problem, namely that we don’t care about the data in column
    `B` because it is not numeric. You can avoid non-numeric columns by specifying
    `numeric_only=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that `df.groupby('A').colname.std().` is more efficient than `df.groupby('A').std().colname`.
    So if the result of an aggregation function is only needed over one column (here
    `colname`), it may be filtered *before* applying the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '### Handling of (un)observed Categorical values'
  prefs: []
  type: TYPE_NORMAL
- en: When using a `Categorical` grouper (as a single grouper, or as part of multiple
    groupers), the `observed` keyword controls whether to return a cartesian product
    of all possible groupers values (`observed=False`) or only those that are observed
    groupers (`observed=True`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Show all values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Show only the observed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The returned dtype of the grouped will *always* include *all* of the categories
    that were grouped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]  ### NA group handling'
  prefs: []
  type: TYPE_NORMAL
- en: By `NA`, we are referring to any `NA` values, including [`NA`](../reference/api/pandas.NA.html#pandas.NA
    "pandas.NA"), `NaN`, `NaT`, and `None`. If there are any `NA` values in the grouping
    key, by default these will be excluded. In other words, any “`NA` group” will
    be dropped. You can include NA groups by specifying `dropna=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with ordered factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Categorical variables represented as instances of pandas’s `Categorical` class
    can be used as group keys. If so, the order of the levels will be preserved. When
    `observed=False` and `sort=False`, any unobserved categories will be at the end
    of the result in order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '### Grouping with a grouper specification'
  prefs: []
  type: TYPE_NORMAL
- en: You may need to specify a bit more data to properly group. You can use the `pd.Grouper`
    to provide this local control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Groupby a specific column with the desired frequency. This is like resampling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: When `freq` is specified, the object returned by `pd.Grouper` will be an instance
    of `pandas.api.typing.TimeGrouper`. When there is a column and index with the
    same name, you can use `key` to group by the column and `level` to group by the
    index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Taking the first rows of each group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like for a DataFrame or Series you can call head and tail on a groupby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This shows the first or last n rows from each group.
  prefs: []
  type: TYPE_NORMAL
- en: '### Taking the nth row of each group'
  prefs: []
  type: TYPE_NORMAL
- en: To select the nth item from each group, use [`DataFrameGroupBy.nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") or [`SeriesGroupBy.nth()`](../reference/api/pandas.core.groupby.SeriesGroupBy.nth.html#pandas.core.groupby.SeriesGroupBy.nth
    "pandas.core.groupby.SeriesGroupBy.nth"). Arguments supplied can be any integer,
    lists of integers, slices, or lists of slices; see below for examples. When the
    nth element of a group does not exist an error is *not* raised; instead no corresponding
    rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: In general this operation acts as a filtration. In certain cases it will also
    return one row per group, making it also a reduction. However because in general
    it can return zero or multiple rows per group, pandas treats it as a filtration
    in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If the nth element of a group does not exist, then no corresponding row is included
    in the result. In particular, if the specified `n` is larger than any group, the
    result will be an empty DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to select the nth not-null item, use the `dropna` kwarg. For a
    DataFrame this should be either `''any''` or `''all''` just like you would pass
    to dropna:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You can also select multiple rows from each group by specifying multiple nth
    values as a list of ints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: You may also use slices or lists of slices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Enumerate group items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the order in which each row appears within its group, use the `cumcount`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '### Enumerate groups'
  prefs: []
  type: TYPE_NORMAL
- en: To see the ordering of the groups (as opposed to the order of rows within a
    group given by `cumcount`) you can use [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup").
  prefs: []
  type: TYPE_NORMAL
- en: Note that the numbers given to the groups match the order in which the groups
    would be seen when iterating over the groupby object, not the order they are first
    observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Plotting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groupby also works with some plotting methods. In this case, suppose we suspect
    that the values in column 1 are 3 times higher on average in group “B”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily visualize this with a boxplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_boxplot.png](../Images/a66f2e7e2f4e8b2ceab43cacec7614f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of calling `boxplot` is a dictionary whose keys are the values of
    our grouping column `g` (“A” and “B”). The values of the resulting dictionary
    can be controlled by the `return_type` keyword of `boxplot`. See the [visualization
    documentation](visualization.html#visualization-box) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, `df.groupby("g").boxplot()` is not equivalent to `df.boxplot(by="g")`.
    See [here](visualization.html#visualization-box-return) for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '### Piping function calls'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the functionality provided by `DataFrame` and `Series`, functions
    that take `GroupBy` objects can be chained together using a `pipe` method to allow
    for a cleaner, more readable syntax. To read about `.pipe` in general terms, see
    [here](basics.html#basics-pipe).
  prefs: []
  type: TYPE_NORMAL
- en: Combining `.groupby` and `.pipe` is often useful when you need to reuse GroupBy
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine having a DataFrame with columns for stores, products,
    revenue and quantity sold. We’d like to do a groupwise calculation of *prices*
    (i.e. revenue/quantity) per store and per product. We could do this in a multi-step
    operation, but expressing it in terms of piping can make the code more readable.
    First we set the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We now find the prices per store/product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Piping can also be expressive when you want to deliver a grouped object to
    some arbitrary function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Here `mean` takes a GroupBy object and finds the mean of the Revenue and Quantity
    columns respectively for each Store-Product combination. The `mean` function can
    be any function that takes in a GroupBy object; the `.pipe` will pass the GroupBy
    object as a parameter into the function you specify.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Multi-column factorization'
  prefs: []
  type: TYPE_NORMAL
- en: By using [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup"), we can extract information about
    the groups in a way similar to [`factorize()`](../reference/api/pandas.factorize.html#pandas.factorize
    "pandas.factorize") (as described further in the [reshaping API](reshaping.html#reshaping-factorize))
    but which applies naturally to multiple columns of mixed type and different sources.
    This can be useful as an intermediate categorical-like step in processing, when
    the relationships between the group rows are more important than their content,
    or as input to an algorithm which only accepts the integer encoding. (For more
    information about support in pandas for full categorical data, see the [Categorical
    introduction](categorical.html#categorical) and the [API documentation](../reference/arrays.html#api-arrays-categorical).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Groupby by indexer to ‘resample’ data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resampling produces new hypothetical samples (resamples) from already existing
    observed data or from a model that generates data. These new samples are similar
    to the pre-existing samples.
  prefs: []
  type: TYPE_NORMAL
- en: In order for resample to work on indices that are non-datetimelike, the following
    procedure can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, **df.index // 5** returns an integer array which
    is used to determine what gets selected for the groupby operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The example below shows how we can downsample by consolidation of samples into
    fewer ones. Here by using **df.index // 5**, we are aggregating the samples in
    bins. By applying **std()** function, we aggregate the information contained in
    many samples into a small subset of values which is their standard deviation thereby
    reducing the number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Returning a Series to propagate names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Group DataFrame columns, compute a set of metrics and return a named Series.
    The Series name is used as the name for the column index. This is especially useful
    in conjunction with reshaping operations such as stacking, in which the column
    index name will be used as the name of the inserted column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '## Splitting an object into groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'The abstract definition of grouping is to provide a mapping of labels to group
    names. To create a GroupBy object (more on what the GroupBy object is later),
    you may do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The mapping can be specified many different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python function, to be called on each of the index labels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list or NumPy array of the same length as the index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dict or `Series`, providing a `label -> group name` mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `DataFrame` objects, a string indicating either a column name or an index
    level name to be used to group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of any of the above things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Collectively we refer to the grouping objects as the **keys**. For example,
    consider the following `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A string passed to `groupby` may refer to either a column or an index level.
    If a string matches both a column name and an index level name, a `ValueError`
    will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'On a DataFrame, we obtain a GroupBy object by calling [`groupby()`](../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby"). This method returns a `pandas.api.typing.DataFrameGroupBy`
    instance. We could naturally group by either the `A` or `B` columns, or both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`df.groupby(''A'')` is just syntactic sugar for `df.groupby(df[''A''])`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we also have a MultiIndex on columns `A` and `B`, we can group by all the
    columns except the one we specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The above GroupBy will split the DataFrame on its index (rows). To split by
    columns, first do a transpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    objects support duplicate values. If a non-unique index is used as the group key
    in a groupby operation, all values for the same index value will be considered
    to be in one group and thus the output of aggregation functions will only contain
    unique index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Note that **no splitting occurs** until it’s needed. Creating the GroupBy object
    only verifies that you’ve passed a valid mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many kinds of complicated data manipulations can be expressed in terms of GroupBy
    operations (though it can’t be guaranteed to be the most efficient implementation).
    You can get quite creative with the label mapping functions.
  prefs: []
  type: TYPE_NORMAL
- en: '### GroupBy sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default the group keys are sorted during the `groupby` operation. You may
    however pass `sort=False` for potential speedups. With `sort=False` the order
    among group-keys follows the order of appearance of the keys in the original dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `groupby` will preserve the order in which *observations* are sorted
    *within* each group. For example, the groups created by `groupby()` below are
    in the order they appeared in the original `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '#### GroupBy dropna'
  prefs: []
  type: TYPE_NORMAL
- en: By default `NA` values are excluded from group keys during the `groupby` operation.
    However, in case you want to include `NA` values in group keys, you could pass
    `dropna=False` to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The default setting of `dropna` argument is `True` which means `NA` are not
    included in group keys.  ### GroupBy object attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groups` attribute is a dictionary whose keys are the computed unique groups
    and corresponding values are the axis labels belonging to each group. In the above
    example we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the standard Python `len` function on the GroupBy object returns the
    number of groups, which is the same as the length of the `groups` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '`GroupBy` will tab complete column names, GroupBy operations, and other attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]  ### GroupBy with MultiIndex'
  prefs: []
  type: TYPE_NORMAL
- en: With [hierarchically-indexed data](advanced.html#advanced-hierarchical), it’s
    quite natural to group by one of the levels of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a Series with a two-level `MultiIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We can then group by one of the levels in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If the MultiIndex has names specified, these can be passed instead of the level
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with multiple levels is supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be supplied as keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: More on the `sum` function and aggregation later.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping DataFrame with Index levels and columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DataFrame may be grouped by a combination of columns and index levels. You
    can specify both column and index names, or use a [`Grouper`](../reference/api/pandas.Grouper.html#pandas.Grouper
    "pandas.Grouper").
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create a DataFrame with a MultiIndex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Then we group `df` by the `second` index level and the `A` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Index levels may also be specified by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be specified as keys directly to `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: DataFrame column selection in GroupBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have created the GroupBy object from a DataFrame, you might want to
    do something different for each of the columns. Thus, by using `[]` on the GroupBy
    object in a similar way as the one used to get a column from a DataFrame, you
    can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'This is mainly syntactic sugar for the alternative, which is much more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, this method avoids recomputing the internal grouping information
    derived from the passed key.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include the grouping columns if you want to operate on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '### GroupBy sorting'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default the group keys are sorted during the `groupby` operation. You may
    however pass `sort=False` for potential speedups. With `sort=False` the order
    among group-keys follows the order of appearance of the keys in the original dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `groupby` will preserve the order in which *observations* are sorted
    *within* each group. For example, the groups created by `groupby()` below are
    in the order they appeared in the original `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '#### GroupBy dropna'
  prefs: []
  type: TYPE_NORMAL
- en: By default `NA` values are excluded from group keys during the `groupby` operation.
    However, in case you want to include `NA` values in group keys, you could pass
    `dropna=False` to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The default setting of `dropna` argument is `True` which means `NA` are not
    included in group keys.  #### GroupBy dropna'
  prefs: []
  type: TYPE_NORMAL
- en: By default `NA` values are excluded from group keys during the `groupby` operation.
    However, in case you want to include `NA` values in group keys, you could pass
    `dropna=False` to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The default setting of `dropna` argument is `True` which means `NA` are not
    included in group keys.
  prefs: []
  type: TYPE_NORMAL
- en: '### GroupBy object attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `groups` attribute is a dictionary whose keys are the computed unique groups
    and corresponding values are the axis labels belonging to each group. In the above
    example we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the standard Python `len` function on the GroupBy object returns the
    number of groups, which is the same as the length of the `groups` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '`GroupBy` will tab complete column names, GroupBy operations, and other attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '### GroupBy with MultiIndex'
  prefs: []
  type: TYPE_NORMAL
- en: With [hierarchically-indexed data](advanced.html#advanced-hierarchical), it’s
    quite natural to group by one of the levels of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a Series with a two-level `MultiIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: We can then group by one of the levels in `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'If the MultiIndex has names specified, these can be passed instead of the level
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with multiple levels is supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be supplied as keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: More on the `sum` function and aggregation later.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping DataFrame with Index levels and columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DataFrame may be grouped by a combination of columns and index levels. You
    can specify both column and index names, or use a [`Grouper`](../reference/api/pandas.Grouper.html#pandas.Grouper
    "pandas.Grouper").
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create a DataFrame with a MultiIndex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Then we group `df` by the `second` index level and the `A` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Index levels may also be specified by name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Index level names may be specified as keys directly to `groupby`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: DataFrame column selection in GroupBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have created the GroupBy object from a DataFrame, you might want to
    do something different for each of the columns. Thus, by using `[]` on the GroupBy
    object in a similar way as the one used to get a column from a DataFrame, you
    can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'This is mainly syntactic sugar for the alternative, which is much more verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, this method avoids recomputing the internal grouping information
    derived from the passed key.
  prefs: []
  type: TYPE_NORMAL
- en: You can also include the grouping columns if you want to operate on them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '## Iterating through groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the GroupBy object in hand, iterating through the grouped data is very
    natural and functions similarly to [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of grouping by multiple keys, the group name will be a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: See [Iterating through groups](timeseries.html#timeseries-iterating-label).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single group can be selected using [`DataFrameGroupBy.get_group()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.get_group.html#pandas.core.groupby.DataFrameGroupBy.get_group
    "pandas.core.groupby.DataFrameGroupBy.get_group"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for an object grouped on multiple columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '## Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: An aggregation is a GroupBy operation that reduces the dimension of the grouping
    object. The result of an aggregation is, or at least is treated as, a scalar value
    for each column in a group. For example, producing the sum of each column in a
    group of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In the result, the keys of the groups appear in the index by default. They can
    be instead included in the columns by passing `as_index=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '### Built-in aggregation methods'
  prefs: []
  type: TYPE_NORMAL
- en: Many common aggregations are built-in to GroupBy objects as methods. Of the
    methods listed below, those with a `*` do *not* have an efficient, GroupBy-specific,
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`any()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.any.html#pandas.core.groupby.DataFrameGroupBy.any
    "pandas.core.groupby.DataFrameGroupBy.any") | Compute whether any of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`all()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.all.html#pandas.core.groupby.DataFrameGroupBy.all
    "pandas.core.groupby.DataFrameGroupBy.all") | Compute whether all of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`count()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") | Compute the number of non-NA values
    in the groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`cov()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cov.html#pandas.core.groupby.DataFrameGroupBy.cov
    "pandas.core.groupby.DataFrameGroupBy.cov") * | Compute the covariance of the
    groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`first()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.first.html#pandas.core.groupby.DataFrameGroupBy.first
    "pandas.core.groupby.DataFrameGroupBy.first") | Compute the first occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmax.html#pandas.core.groupby.DataFrameGroupBy.idxmax
    "pandas.core.groupby.DataFrameGroupBy.idxmax") | Compute the index of the maximum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmin.html#pandas.core.groupby.DataFrameGroupBy.idxmin
    "pandas.core.groupby.DataFrameGroupBy.idxmin") | Compute the index of the minimum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`last()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.last.html#pandas.core.groupby.DataFrameGroupBy.last
    "pandas.core.groupby.DataFrameGroupBy.last") | Compute the last occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`max()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.max.html#pandas.core.groupby.DataFrameGroupBy.max
    "pandas.core.groupby.DataFrameGroupBy.max") | Compute the maximum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`mean()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean
    "pandas.core.groupby.DataFrameGroupBy.mean") | Compute the mean of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`median()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.median.html#pandas.core.groupby.DataFrameGroupBy.median
    "pandas.core.groupby.DataFrameGroupBy.median") | Compute the median of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`min()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min
    "pandas.core.groupby.DataFrameGroupBy.min") | Compute the minimum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`nunique()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nunique.html#pandas.core.groupby.DataFrameGroupBy.nunique
    "pandas.core.groupby.DataFrameGroupBy.nunique") | Compute the number of unique
    values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`prod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.prod.html#pandas.core.groupby.DataFrameGroupBy.prod
    "pandas.core.groupby.DataFrameGroupBy.prod") | Compute the product of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`quantile()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.quantile.html#pandas.core.groupby.DataFrameGroupBy.quantile
    "pandas.core.groupby.DataFrameGroupBy.quantile") | Compute a given quantile of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sem()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sem.html#pandas.core.groupby.DataFrameGroupBy.sem
    "pandas.core.groupby.DataFrameGroupBy.sem") | Compute the standard error of the
    mean of the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`size()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") | Compute the number of values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`skew()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.skew.html#pandas.core.groupby.DataFrameGroupBy.skew
    "pandas.core.groupby.DataFrameGroupBy.skew") * | Compute the skew of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`std()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.std.html#pandas.core.groupby.DataFrameGroupBy.std
    "pandas.core.groupby.DataFrameGroupBy.std") | Compute the standard deviation of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum
    "pandas.core.groupby.DataFrameGroupBy.sum") | Compute the sum of the values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`var()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.var.html#pandas.core.groupby.DataFrameGroupBy.var
    "pandas.core.groupby.DataFrameGroupBy.var") | Compute the variance of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the size of each group. This is included
    in GroupBy as the `size` method. It returns a Series whose index consists of the
    group names and the values are the sizes of each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: While the [`DataFrameGroupBy.describe()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.describe.html#pandas.core.groupby.DataFrameGroupBy.describe
    "pandas.core.groupby.DataFrameGroupBy.describe") method is not itself a reducer,
    it can be used to conveniently produce a collection of summary statistics about
    each of the groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the number of unique values of each
    group. This is similar to the [`DataFrameGroupBy.value_counts()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.value_counts.html#pandas.core.groupby.DataFrameGroupBy.value_counts
    "pandas.core.groupby.DataFrameGroupBy.value_counts") function, except that it
    only counts the number of unique values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation functions **will not** return the groups that you are aggregating
    over as named *columns* when `as_index=True`, the default. The grouped columns
    will be the **indices** of the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing `as_index=False` **will** return the groups that you are aggregating
    over as named columns, regardless if they are named **indices** or *columns* in
    the inputs.  ### The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method can accept many different
    types of inputs. This section details using string aliases for various GroupBy
    methods; other inputs are detailed in the sections below.
  prefs: []
  type: TYPE_NORMAL
- en: Any reduction method that pandas implements can be passed as a string to [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate"). Users are encouraged to use
    the shorthand, `agg`. It will operate as if the corresponding method was called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the aggregation will have the group names as the new index. In
    the case of multiple keys, the result is a [MultiIndex](advanced.html#advanced-hierarchical)
    by default. As mentioned above, this can be changed by using the `as_index` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Note that you could use the [`DataFrame.reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") DataFrame function to achieve the same result
    as the column names are stored in the resulting `MultiIndex`, although this will
    make an extra copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]  ### Aggregation with User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Users can also provide their own User-Defined Functions (UDFs) for custom aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When aggregating with a UDF, the UDF should not mutate the provided `Series`.
    See [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating with a UDF is often less performant than using the pandas built-in
    methods on GroupBy. Consider breaking up a complex operation into a chain of operations
    that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The resulting dtype will reflect that of the aggregating function. If the results
    from different groups have different dtypes, then a common dtype will be determined
    in the same way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]  ### Applying multiple functions at once'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a grouped `Series`, you can pass a list or dict of functions to `SeriesGroupBy.agg()`,
    outputting a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'On a grouped `DataFrame`, you can pass a list of functions to `DataFrameGroupBy.agg()`
    to aggregate each column, which produces an aggregated result with a hierarchical
    column index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting aggregations are named after the functions themselves. If you
    need to rename, then you can add in a chained operation for a `Series` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'For a grouped `DataFrame`, you can rename in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, the output column names should be unique, but pandas will allow
    you apply to the same function (or two functions with the same name) to the same
    column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: pandas also allows you to provide multiple lambdas. In this case, pandas will
    mangle the name of the (nameless) lambda functions, appending `_<i>` to each subsequent
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]  ### Named aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: To support column-specific aggregation *with control over the output column
    names*, pandas accepts the special syntax in [`DataFrameGroupBy.agg()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") and [`SeriesGroupBy.agg()`](../reference/api/pandas.core.groupby.SeriesGroupBy.agg.html#pandas.core.groupby.SeriesGroupBy.agg
    "pandas.core.groupby.SeriesGroupBy.agg"), known as “named aggregation”, where
  prefs: []
  type: TYPE_NORMAL
- en: The keywords are the *output* column names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values are tuples whose first element is the column to select and the second
    element is the aggregation to apply to that column. pandas provides the [`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg
    "pandas.NamedAgg") namedtuple with the fields `['column', 'aggfunc']` to make
    it clearer what the arguments are. As usual, the aggregation can be a callable
    or a string alias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg "pandas.NamedAgg")
    is just a `namedtuple`. Plain tuples are allowed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: If the column names you want are not valid Python keywords, construct a dictionary
    and unpack the keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: When using named aggregation, additional keyword arguments are not passed through
    to the aggregation functions; only pairs of `(column, aggfunc)` should be passed
    as `**kwargs`. If your aggregation functions require additional arguments, apply
    them partially with `functools.partial()`.
  prefs: []
  type: TYPE_NORMAL
- en: Named aggregation is also valid for Series groupby aggregations. In this case
    there’s no column selection, so the values are just the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Applying different functions to DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on GroupBy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '### Built-in aggregation methods'
  prefs: []
  type: TYPE_NORMAL
- en: Many common aggregations are built-in to GroupBy objects as methods. Of the
    methods listed below, those with a `*` do *not* have an efficient, GroupBy-specific,
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`any()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.any.html#pandas.core.groupby.DataFrameGroupBy.any
    "pandas.core.groupby.DataFrameGroupBy.any") | Compute whether any of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`all()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.all.html#pandas.core.groupby.DataFrameGroupBy.all
    "pandas.core.groupby.DataFrameGroupBy.all") | Compute whether all of the values
    in the groups are truthy |'
  prefs: []
  type: TYPE_TB
- en: '| [`count()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") | Compute the number of non-NA values
    in the groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`cov()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cov.html#pandas.core.groupby.DataFrameGroupBy.cov
    "pandas.core.groupby.DataFrameGroupBy.cov") * | Compute the covariance of the
    groups |'
  prefs: []
  type: TYPE_TB
- en: '| [`first()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.first.html#pandas.core.groupby.DataFrameGroupBy.first
    "pandas.core.groupby.DataFrameGroupBy.first") | Compute the first occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmax.html#pandas.core.groupby.DataFrameGroupBy.idxmax
    "pandas.core.groupby.DataFrameGroupBy.idxmax") | Compute the index of the maximum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`idxmin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.idxmin.html#pandas.core.groupby.DataFrameGroupBy.idxmin
    "pandas.core.groupby.DataFrameGroupBy.idxmin") | Compute the index of the minimum
    value in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`last()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.last.html#pandas.core.groupby.DataFrameGroupBy.last
    "pandas.core.groupby.DataFrameGroupBy.last") | Compute the last occurring value
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`max()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.max.html#pandas.core.groupby.DataFrameGroupBy.max
    "pandas.core.groupby.DataFrameGroupBy.max") | Compute the maximum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`mean()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.mean.html#pandas.core.groupby.DataFrameGroupBy.mean
    "pandas.core.groupby.DataFrameGroupBy.mean") | Compute the mean of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`median()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.median.html#pandas.core.groupby.DataFrameGroupBy.median
    "pandas.core.groupby.DataFrameGroupBy.median") | Compute the median of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`min()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.min.html#pandas.core.groupby.DataFrameGroupBy.min
    "pandas.core.groupby.DataFrameGroupBy.min") | Compute the minimum value in each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`nunique()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nunique.html#pandas.core.groupby.DataFrameGroupBy.nunique
    "pandas.core.groupby.DataFrameGroupBy.nunique") | Compute the number of unique
    values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`prod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.prod.html#pandas.core.groupby.DataFrameGroupBy.prod
    "pandas.core.groupby.DataFrameGroupBy.prod") | Compute the product of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`quantile()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.quantile.html#pandas.core.groupby.DataFrameGroupBy.quantile
    "pandas.core.groupby.DataFrameGroupBy.quantile") | Compute a given quantile of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sem()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sem.html#pandas.core.groupby.DataFrameGroupBy.sem
    "pandas.core.groupby.DataFrameGroupBy.sem") | Compute the standard error of the
    mean of the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`size()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") | Compute the number of values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`skew()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.skew.html#pandas.core.groupby.DataFrameGroupBy.skew
    "pandas.core.groupby.DataFrameGroupBy.skew") * | Compute the skew of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`std()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.std.html#pandas.core.groupby.DataFrameGroupBy.std
    "pandas.core.groupby.DataFrameGroupBy.std") | Compute the standard deviation of
    the values in each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`sum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.sum.html#pandas.core.groupby.DataFrameGroupBy.sum
    "pandas.core.groupby.DataFrameGroupBy.sum") | Compute the sum of the values in
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`var()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.var.html#pandas.core.groupby.DataFrameGroupBy.var
    "pandas.core.groupby.DataFrameGroupBy.var") | Compute the variance of the values
    in each group |'
  prefs: []
  type: TYPE_TB
- en: 'Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the size of each group. This is included
    in GroupBy as the `size` method. It returns a Series whose index consists of the
    group names and the values are the sizes of each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: While the [`DataFrameGroupBy.describe()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.describe.html#pandas.core.groupby.DataFrameGroupBy.describe
    "pandas.core.groupby.DataFrameGroupBy.describe") method is not itself a reducer,
    it can be used to conveniently produce a collection of summary statistics about
    each of the groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Another aggregation example is to compute the number of unique values of each
    group. This is similar to the [`DataFrameGroupBy.value_counts()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.value_counts.html#pandas.core.groupby.DataFrameGroupBy.value_counts
    "pandas.core.groupby.DataFrameGroupBy.value_counts") function, except that it
    only counts the number of unique values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation functions **will not** return the groups that you are aggregating
    over as named *columns* when `as_index=True`, the default. The grouped columns
    will be the **indices** of the returned object.
  prefs: []
  type: TYPE_NORMAL
- en: Passing `as_index=False` **will** return the groups that you are aggregating
    over as named columns, regardless if they are named **indices** or *columns* in
    the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '### The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate") method can accept many different
    types of inputs. This section details using string aliases for various GroupBy
    methods; other inputs are detailed in the sections below.
  prefs: []
  type: TYPE_NORMAL
- en: Any reduction method that pandas implements can be passed as a string to [`aggregate()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html#pandas.core.groupby.DataFrameGroupBy.aggregate
    "pandas.core.groupby.DataFrameGroupBy.aggregate"). Users are encouraged to use
    the shorthand, `agg`. It will operate as if the corresponding method was called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the aggregation will have the group names as the new index. In
    the case of multiple keys, the result is a [MultiIndex](advanced.html#advanced-hierarchical)
    by default. As mentioned above, this can be changed by using the `as_index` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Note that you could use the [`DataFrame.reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") DataFrame function to achieve the same result
    as the column names are stored in the resulting `MultiIndex`, although this will
    make an extra copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '### Aggregation with User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Users can also provide their own User-Defined Functions (UDFs) for custom aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When aggregating with a UDF, the UDF should not mutate the provided `Series`.
    See [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating with a UDF is often less performant than using the pandas built-in
    methods on GroupBy. Consider breaking up a complex operation into a chain of operations
    that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: The resulting dtype will reflect that of the aggregating function. If the results
    from different groups have different dtypes, then a common dtype will be determined
    in the same way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '### Applying multiple functions at once'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a grouped `Series`, you can pass a list or dict of functions to `SeriesGroupBy.agg()`,
    outputting a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'On a grouped `DataFrame`, you can pass a list of functions to `DataFrameGroupBy.agg()`
    to aggregate each column, which produces an aggregated result with a hierarchical
    column index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting aggregations are named after the functions themselves. If you
    need to rename, then you can add in a chained operation for a `Series` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'For a grouped `DataFrame`, you can rename in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In general, the output column names should be unique, but pandas will allow
    you apply to the same function (or two functions with the same name) to the same
    column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: pandas also allows you to provide multiple lambdas. In this case, pandas will
    mangle the name of the (nameless) lambda functions, appending `_<i>` to each subsequent
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '### Named aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: To support column-specific aggregation *with control over the output column
    names*, pandas accepts the special syntax in [`DataFrameGroupBy.agg()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") and [`SeriesGroupBy.agg()`](../reference/api/pandas.core.groupby.SeriesGroupBy.agg.html#pandas.core.groupby.SeriesGroupBy.agg
    "pandas.core.groupby.SeriesGroupBy.agg"), known as “named aggregation”, where
  prefs: []
  type: TYPE_NORMAL
- en: The keywords are the *output* column names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values are tuples whose first element is the column to select and the second
    element is the aggregation to apply to that column. pandas provides the [`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg
    "pandas.NamedAgg") namedtuple with the fields `['column', 'aggfunc']` to make
    it clearer what the arguments are. As usual, the aggregation can be a callable
    or a string alias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[`NamedAgg`](../reference/api/pandas.NamedAgg.html#pandas.NamedAgg "pandas.NamedAgg")
    is just a `namedtuple`. Plain tuples are allowed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: If the column names you want are not valid Python keywords, construct a dictionary
    and unpack the keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: When using named aggregation, additional keyword arguments are not passed through
    to the aggregation functions; only pairs of `(column, aggfunc)` should be passed
    as `**kwargs`. If your aggregation functions require additional arguments, apply
    them partially with `functools.partial()`.
  prefs: []
  type: TYPE_NORMAL
- en: Named aggregation is also valid for Series groupby aggregations. In this case
    there’s no column selection, so the values are just the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Applying different functions to DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on GroupBy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '## Transformation'
  prefs: []
  type: TYPE_NORMAL
- en: A transformation is a GroupBy operation whose result is indexed the same as
    the one being grouped. Common examples include [`cumsum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumsum.html#pandas.core.groupby.DataFrameGroupBy.cumsum
    "pandas.core.groupby.DataFrameGroupBy.cumsum") and [`diff()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.diff.html#pandas.core.groupby.DataFrameGroupBy.diff
    "pandas.core.groupby.DataFrameGroupBy.diff").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Unlike aggregations, the groupings that are used to split the original object
    are not included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since transformations do not include the groupings that are used to split the
    result, the arguments `as_index` and `sort` in [`DataFrame.groupby()`](../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") and [`Series.groupby()`](../reference/api/pandas.Series.groupby.html#pandas.Series.groupby
    "pandas.Series.groupby") have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: A common use of a transformation is to add the result back into the original
    DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Built-in transformation methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`bfill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.bfill.html#pandas.core.groupby.DataFrameGroupBy.bfill
    "pandas.core.groupby.DataFrameGroupBy.bfill") | Back fill NA values within each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumcount()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumcount.html#pandas.core.groupby.DataFrameGroupBy.cumcount
    "pandas.core.groupby.DataFrameGroupBy.cumcount") | Compute the cumulative count
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummax.html#pandas.core.groupby.DataFrameGroupBy.cummax
    "pandas.core.groupby.DataFrameGroupBy.cummax") | Compute the cumulative max within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummin.html#pandas.core.groupby.DataFrameGroupBy.cummin
    "pandas.core.groupby.DataFrameGroupBy.cummin") | Compute the cumulative min within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumprod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumprod.html#pandas.core.groupby.DataFrameGroupBy.cumprod
    "pandas.core.groupby.DataFrameGroupBy.cumprod") | Compute the cumulative product
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumsum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumsum.html#pandas.core.groupby.DataFrameGroupBy.cumsum
    "pandas.core.groupby.DataFrameGroupBy.cumsum") | Compute the cumulative sum within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`diff()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.diff.html#pandas.core.groupby.DataFrameGroupBy.diff
    "pandas.core.groupby.DataFrameGroupBy.diff") | Compute the difference between
    adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`ffill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ffill.html#pandas.core.groupby.DataFrameGroupBy.ffill
    "pandas.core.groupby.DataFrameGroupBy.ffill") | Forward fill NA values within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`pct_change()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.pct_change.html#pandas.core.groupby.DataFrameGroupBy.pct_change
    "pandas.core.groupby.DataFrameGroupBy.pct_change") | Compute the percent change
    between adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`rank()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.rank.html#pandas.core.groupby.DataFrameGroupBy.rank
    "pandas.core.groupby.DataFrameGroupBy.rank") | Compute the rank of each value
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`shift()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.shift.html#pandas.core.groupby.DataFrameGroupBy.shift
    "pandas.core.groupby.DataFrameGroupBy.shift") | Shift values up or down within
    each group |'
  prefs: []
  type: TYPE_TB
- en: In addition, passing any built-in aggregation method as a string to [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") (see the next section) will
    broadcast the result across the group, producing a transformed result. If the
    aggregation method has an efficient implementation, this will be performant as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '### The [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the [aggregation method](#groupby-aggregate-agg), the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can accept string aliases
    to the built-in transformation methods in the previous section. It can *also*
    accept string aliases to the built-in aggregation methods. When an aggregation
    method is provided, the result will be broadcast across the group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to string aliases, the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can also accept User-Defined
    Functions (UDFs). The UDF must:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a result that is either the same size as the group chunk or broadcastable
    to the size of the group chunk (e.g., a scalar, `grouped.transform(lambda x: x.iloc[-1])`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate column-by-column on the group chunk. The transform is applied to the
    first group chunk using chunk.apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not perform in-place operations on the group chunk. Group chunks should be treated
    as immutable, and changes to a group chunk may produce unexpected results. See
    [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optionally) operates on all columns of the entire group chunk at once. If this
    is supported, a fast path is used starting from the *second* chunk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Transforming by supplying `transform` with a UDF is often less performant than
    using the built-in methods on GroupBy. Consider breaking up a complex operation
    into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in this section can be made more performant by calling built-in
    methods instead of using UDFs. See [below for examples](#groupby-efficient-transforms).
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.0: When using `.transform` on a grouped DataFrame and
    the transformation function returns a DataFrame, pandas now aligns the result’s
    index with the input’s index. You can call `.to_numpy()` within the transformation
    function to avoid alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to [The aggregate() method](#groupby-aggregate-agg), the resulting dtype
    will reflect that of the transformation function. If the results from different
    groups have different dtypes, then a common dtype will be determined in the same
    way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to standardize the data within each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'We would expect the result to now have mean 0 and standard deviation 1 within
    each group (up to floating-point error), which we can easily check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: We can also visually compare the original and transformed data sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_transform_plot.png](../Images/69f287bde1e1c618b8c84fdbd3fe04dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Transformation functions that have lower dimension outputs are broadcast to
    match the shape of the input array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Another common data transform is to replace missing data with the group mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: We can verify that the group means have not changed in the transformed data,
    and that the transformed data contains no NAs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the note above, each of the examples in this section can be
    computed more efficiently using built-in methods. In the code below, the inefficient
    way using a UDF is commented out and the faster alternative appears below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]  ### Window and resample operations'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use `resample()`, `expanding()` and `rolling()` as methods
    on groupbys.
  prefs: []
  type: TYPE_NORMAL
- en: The example below will apply the `rolling()` method on the samples of the column
    B, based on the groups of column A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The `expanding()` method will accumulate a given operation (`sum()` in the example)
    for all the members of each particular group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you want to use the `resample()` method to get a daily frequency in
    each group of your dataframe, and wish to complete the missing values with the
    `ffill()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Built-in transformation methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`bfill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.bfill.html#pandas.core.groupby.DataFrameGroupBy.bfill
    "pandas.core.groupby.DataFrameGroupBy.bfill") | Back fill NA values within each
    group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumcount()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumcount.html#pandas.core.groupby.DataFrameGroupBy.cumcount
    "pandas.core.groupby.DataFrameGroupBy.cumcount") | Compute the cumulative count
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummax()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummax.html#pandas.core.groupby.DataFrameGroupBy.cummax
    "pandas.core.groupby.DataFrameGroupBy.cummax") | Compute the cumulative max within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cummin()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cummin.html#pandas.core.groupby.DataFrameGroupBy.cummin
    "pandas.core.groupby.DataFrameGroupBy.cummin") | Compute the cumulative min within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumprod()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumprod.html#pandas.core.groupby.DataFrameGroupBy.cumprod
    "pandas.core.groupby.DataFrameGroupBy.cumprod") | Compute the cumulative product
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`cumsum()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.cumsum.html#pandas.core.groupby.DataFrameGroupBy.cumsum
    "pandas.core.groupby.DataFrameGroupBy.cumsum") | Compute the cumulative sum within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`diff()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.diff.html#pandas.core.groupby.DataFrameGroupBy.diff
    "pandas.core.groupby.DataFrameGroupBy.diff") | Compute the difference between
    adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`ffill()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ffill.html#pandas.core.groupby.DataFrameGroupBy.ffill
    "pandas.core.groupby.DataFrameGroupBy.ffill") | Forward fill NA values within
    each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`pct_change()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.pct_change.html#pandas.core.groupby.DataFrameGroupBy.pct_change
    "pandas.core.groupby.DataFrameGroupBy.pct_change") | Compute the percent change
    between adjacent values within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`rank()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.rank.html#pandas.core.groupby.DataFrameGroupBy.rank
    "pandas.core.groupby.DataFrameGroupBy.rank") | Compute the rank of each value
    within each group |'
  prefs: []
  type: TYPE_TB
- en: '| [`shift()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.shift.html#pandas.core.groupby.DataFrameGroupBy.shift
    "pandas.core.groupby.DataFrameGroupBy.shift") | Shift values up or down within
    each group |'
  prefs: []
  type: TYPE_TB
- en: In addition, passing any built-in aggregation method as a string to [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") (see the next section) will
    broadcast the result across the group, producing a transformed result. If the
    aggregation method has an efficient implementation, this will be performant as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '### The [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the [aggregation method](#groupby-aggregate-agg), the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can accept string aliases
    to the built-in transformation methods in the previous section. It can *also*
    accept string aliases to the built-in aggregation methods. When an aggregation
    method is provided, the result will be broadcast across the group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to string aliases, the [`transform()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.transform.html#pandas.core.groupby.DataFrameGroupBy.transform
    "pandas.core.groupby.DataFrameGroupBy.transform") method can also accept User-Defined
    Functions (UDFs). The UDF must:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a result that is either the same size as the group chunk or broadcastable
    to the size of the group chunk (e.g., a scalar, `grouped.transform(lambda x: x.iloc[-1])`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate column-by-column on the group chunk. The transform is applied to the
    first group chunk using chunk.apply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not perform in-place operations on the group chunk. Group chunks should be treated
    as immutable, and changes to a group chunk may produce unexpected results. See
    [Mutating with User Defined Function (UDF) methods](gotchas.html#gotchas-udf-mutation)
    for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optionally) operates on all columns of the entire group chunk at once. If this
    is supported, a fast path is used starting from the *second* chunk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Transforming by supplying `transform` with a UDF is often less performant than
    using the built-in methods on GroupBy. Consider breaking up a complex operation
    into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in this section can be made more performant by calling built-in
    methods instead of using UDFs. See [below for examples](#groupby-efficient-transforms).
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.0: When using `.transform` on a grouped DataFrame and
    the transformation function returns a DataFrame, pandas now aligns the result’s
    index with the input’s index. You can call `.to_numpy()` within the transformation
    function to avoid alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to [The aggregate() method](#groupby-aggregate-agg), the resulting dtype
    will reflect that of the transformation function. If the results from different
    groups have different dtypes, then a common dtype will be determined in the same
    way as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wish to standardize the data within each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'We would expect the result to now have mean 0 and standard deviation 1 within
    each group (up to floating-point error), which we can easily check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: We can also visually compare the original and transformed data sets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_transform_plot.png](../Images/69f287bde1e1c618b8c84fdbd3fe04dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Transformation functions that have lower dimension outputs are broadcast to
    match the shape of the input array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Another common data transform is to replace missing data with the group mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: We can verify that the group means have not changed in the transformed data,
    and that the transformed data contains no NAs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the note above, each of the examples in this section can be
    computed more efficiently using built-in methods. In the code below, the inefficient
    way using a UDF is commented out and the faster alternative appears below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '### Window and resample operations'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use `resample()`, `expanding()` and `rolling()` as methods
    on groupbys.
  prefs: []
  type: TYPE_NORMAL
- en: The example below will apply the `rolling()` method on the samples of the column
    B, based on the groups of column A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The `expanding()` method will accumulate a given operation (`sum()` in the example)
    for all the members of each particular group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you want to use the `resample()` method to get a daily frequency in
    each group of your dataframe, and wish to complete the missing values with the
    `ffill()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '## Filtration'
  prefs: []
  type: TYPE_NORMAL
- en: A filtration is a GroupBy operation that subsets the original grouping object.
    It may either filter out entire groups, part of groups, or both. Filtrations return
    a filtered version of the calling object, including the grouping columns when
    provided. In the following example, `class` is included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unlike aggregations, filtrations do not add the group keys to the index of the
    result. Because of this, passing `as_index=False` or `sort=True` will not affect
    these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Filtrations will respect subsetting the columns of the GroupBy object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Built-in filtrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as filtrations. All these methods have
    an efficient, GroupBy-specific, implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`head()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.head.html#pandas.core.groupby.DataFrameGroupBy.head
    "pandas.core.groupby.DataFrameGroupBy.head") | Select the top row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") | Select the nth row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`tail()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.tail.html#pandas.core.groupby.DataFrameGroupBy.tail
    "pandas.core.groupby.DataFrameGroupBy.tail") | Select the bottom row(s) of each
    group |'
  prefs: []
  type: TYPE_TB
- en: Users can also use transformations along with Boolean indexing to construct
    complex filtrations within groups. For example, suppose we are given groups of
    products and their volumes, and we wish to subset the data to only the largest
    products capturing no more than 90% of the total volume within each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by supplying `filter` with a User-Defined Function (UDF) is often
    less performant than using the built-in methods on GroupBy. Consider breaking
    up a complex operation into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method takes a User-Defined Function (UDF) that, when applied to
    an entire group, returns either `True` or `False`. The result of the `filter`
    method is then the subset of groups for which the UDF returned `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to take only elements that belong to groups with a group sum
    greater than 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Another useful operation is filtering out elements that belong to groups with
    only a couple members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, instead of dropping the offending groups, we can return a like-indexed
    objects where the groups that do not pass the filter are filled with NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: For DataFrames with multiple columns, filters should explicitly specify a column
    as the filter criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Built-in filtrations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following methods on GroupBy act as filtrations. All these methods have
    an efficient, GroupBy-specific, implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`head()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.head.html#pandas.core.groupby.DataFrameGroupBy.head
    "pandas.core.groupby.DataFrameGroupBy.head") | Select the top row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") | Select the nth row(s) of each group
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`tail()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.tail.html#pandas.core.groupby.DataFrameGroupBy.tail
    "pandas.core.groupby.DataFrameGroupBy.tail") | Select the bottom row(s) of each
    group |'
  prefs: []
  type: TYPE_TB
- en: Users can also use transformations along with Boolean indexing to construct
    complex filtrations within groups. For example, suppose we are given groups of
    products and their volumes, and we wish to subset the data to only the largest
    products capturing no more than 90% of the total volume within each group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The `filter` method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by supplying `filter` with a User-Defined Function (UDF) is often
    less performant than using the built-in methods on GroupBy. Consider breaking
    up a complex operation into a chain of operations that utilize the built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method takes a User-Defined Function (UDF) that, when applied to
    an entire group, returns either `True` or `False`. The result of the `filter`
    method is then the subset of groups for which the UDF returned `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to take only elements that belong to groups with a group sum
    greater than 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Another useful operation is filtering out elements that belong to groups with
    only a couple members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, instead of dropping the offending groups, we can return a like-indexed
    objects where the groups that do not pass the filter are filled with NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: For DataFrames with multiple columns, filters should explicitly specify a column
    as the filter criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '## Flexible `apply`'
  prefs: []
  type: TYPE_NORMAL
- en: Some operations on the grouped data might not fit into the aggregation, transformation,
    or filtration categories. For these, you can use the `apply` function.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` has to try to infer from the result whether it should act as a reducer,
    transformer, *or* filter, depending on exactly what is passed to it. Thus the
    grouped column(s) may be included in the output or not. While it tries to intelligently
    guess how to behave, it can sometimes guess wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All of the examples in this section can be more reliably, and more efficiently,
    computed using other pandas functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The dimension of the returned result can also change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '`apply` on a Series can operate on a returned value from the applied function
    that is itself a series, and possibly upcast the result to a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Similar to [The aggregate() method](#groupby-aggregate-agg), the resulting dtype
    will reflect that of the apply function. If the results from different groups
    have different dtypes, then a common dtype will be determined in the same way
    as `DataFrame` construction.
  prefs: []
  type: TYPE_NORMAL
- en: Control grouped column(s) placement with `group_keys`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To control whether the grouped column(s) are included in the indices, you can
    use the argument `group_keys` which defaults to `True`. Compare
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Control grouped column(s) placement with `group_keys`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To control whether the grouped column(s) are included in the indices, you can
    use the argument `group_keys` which defaults to `True`. Compare
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Numba Accelerated Routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New in version 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: If [Numba](https://numba.pydata.org/) is installed as an optional dependency,
    the `transform` and `aggregate` methods support `engine='numba'` and `engine_kwargs`
    arguments. See [enhancing performance with Numba](enhancingperf.html#enhancingperf-numba)
    for general usage of the arguments and performance considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature must start with `values, index` **exactly** as the data
    belonging to each group will be passed into `values`, and the group index will
    be passed into `index`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using `engine='numba'`, there will be no “fall back” behavior internally.
    The group data and group index will be passed as NumPy arrays to the JITed user
    defined function, and no alternative execution attempts will be tried.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exclusion of non-numeric columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again consider the example DataFrame we’ve been looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to compute the standard deviation grouped by the `A` column.
    There is a slight problem, namely that we don’t care about the data in column
    `B` because it is not numeric. You can avoid non-numeric columns by specifying
    `numeric_only=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Note that `df.groupby('A').colname.std().` is more efficient than `df.groupby('A').std().colname`.
    So if the result of an aggregation function is only needed over one column (here
    `colname`), it may be filtered *before* applying the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '### Handling of (un)observed Categorical values'
  prefs: []
  type: TYPE_NORMAL
- en: When using a `Categorical` grouper (as a single grouper, or as part of multiple
    groupers), the `observed` keyword controls whether to return a cartesian product
    of all possible groupers values (`observed=False`) or only those that are observed
    groupers (`observed=True`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Show all values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'Show only the observed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The returned dtype of the grouped will *always* include *all* of the categories
    that were grouped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]  ### NA group handling'
  prefs: []
  type: TYPE_NORMAL
- en: By `NA`, we are referring to any `NA` values, including [`NA`](../reference/api/pandas.NA.html#pandas.NA
    "pandas.NA"), `NaN`, `NaT`, and `None`. If there are any `NA` values in the grouping
    key, by default these will be excluded. In other words, any “`NA` group” will
    be dropped. You can include NA groups by specifying `dropna=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with ordered factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Categorical variables represented as instances of pandas’s `Categorical` class
    can be used as group keys. If so, the order of the levels will be preserved. When
    `observed=False` and `sort=False`, any unobserved categories will be at the end
    of the result in order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '### Grouping with a grouper specification'
  prefs: []
  type: TYPE_NORMAL
- en: You may need to specify a bit more data to properly group. You can use the `pd.Grouper`
    to provide this local control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Groupby a specific column with the desired frequency. This is like resampling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: When `freq` is specified, the object returned by `pd.Grouper` will be an instance
    of `pandas.api.typing.TimeGrouper`. When there is a column and index with the
    same name, you can use `key` to group by the column and `level` to group by the
    index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Taking the first rows of each group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like for a DataFrame or Series you can call head and tail on a groupby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: This shows the first or last n rows from each group.
  prefs: []
  type: TYPE_NORMAL
- en: '### Taking the nth row of each group'
  prefs: []
  type: TYPE_NORMAL
- en: To select the nth item from each group, use [`DataFrameGroupBy.nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") or [`SeriesGroupBy.nth()`](../reference/api/pandas.core.groupby.SeriesGroupBy.nth.html#pandas.core.groupby.SeriesGroupBy.nth
    "pandas.core.groupby.SeriesGroupBy.nth"). Arguments supplied can be any integer,
    lists of integers, slices, or lists of slices; see below for examples. When the
    nth element of a group does not exist an error is *not* raised; instead no corresponding
    rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: In general this operation acts as a filtration. In certain cases it will also
    return one row per group, making it also a reduction. However because in general
    it can return zero or multiple rows per group, pandas treats it as a filtration
    in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: If the nth element of a group does not exist, then no corresponding row is included
    in the result. In particular, if the specified `n` is larger than any group, the
    result will be an empty DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to select the nth not-null item, use the `dropna` kwarg. For a
    DataFrame this should be either `''any''` or `''all''` just like you would pass
    to dropna:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: You can also select multiple rows from each group by specifying multiple nth
    values as a list of ints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: You may also use slices or lists of slices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Enumerate group items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the order in which each row appears within its group, use the `cumcount`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '### Enumerate groups'
  prefs: []
  type: TYPE_NORMAL
- en: To see the ordering of the groups (as opposed to the order of rows within a
    group given by `cumcount`) you can use [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup").
  prefs: []
  type: TYPE_NORMAL
- en: Note that the numbers given to the groups match the order in which the groups
    would be seen when iterating over the groupby object, not the order they are first
    observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Plotting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groupby also works with some plotting methods. In this case, suppose we suspect
    that the values in column 1 are 3 times higher on average in group “B”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily visualize this with a boxplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_boxplot.png](../Images/a66f2e7e2f4e8b2ceab43cacec7614f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of calling `boxplot` is a dictionary whose keys are the values of
    our grouping column `g` (“A” and “B”). The values of the resulting dictionary
    can be controlled by the `return_type` keyword of `boxplot`. See the [visualization
    documentation](visualization.html#visualization-box) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, `df.groupby("g").boxplot()` is not equivalent to `df.boxplot(by="g")`.
    See [here](visualization.html#visualization-box-return) for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '### Piping function calls'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the functionality provided by `DataFrame` and `Series`, functions
    that take `GroupBy` objects can be chained together using a `pipe` method to allow
    for a cleaner, more readable syntax. To read about `.pipe` in general terms, see
    [here](basics.html#basics-pipe).
  prefs: []
  type: TYPE_NORMAL
- en: Combining `.groupby` and `.pipe` is often useful when you need to reuse GroupBy
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine having a DataFrame with columns for stores, products,
    revenue and quantity sold. We’d like to do a groupwise calculation of *prices*
    (i.e. revenue/quantity) per store and per product. We could do this in a multi-step
    operation, but expressing it in terms of piping can make the code more readable.
    First we set the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: We now find the prices per store/product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Piping can also be expressive when you want to deliver a grouped object to
    some arbitrary function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Here `mean` takes a GroupBy object and finds the mean of the Revenue and Quantity
    columns respectively for each Store-Product combination. The `mean` function can
    be any function that takes in a GroupBy object; the `.pipe` will pass the GroupBy
    object as a parameter into the function you specify.
  prefs: []
  type: TYPE_NORMAL
- en: Exclusion of non-numeric columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again consider the example DataFrame we’ve been looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to compute the standard deviation grouped by the `A` column.
    There is a slight problem, namely that we don’t care about the data in column
    `B` because it is not numeric. You can avoid non-numeric columns by specifying
    `numeric_only=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Note that `df.groupby('A').colname.std().` is more efficient than `df.groupby('A').std().colname`.
    So if the result of an aggregation function is only needed over one column (here
    `colname`), it may be filtered *before* applying the aggregation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '### Handling of (un)observed Categorical values'
  prefs: []
  type: TYPE_NORMAL
- en: When using a `Categorical` grouper (as a single grouper, or as part of multiple
    groupers), the `observed` keyword controls whether to return a cartesian product
    of all possible groupers values (`observed=False`) or only those that are observed
    groupers (`observed=True`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Show all values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Show only the observed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The returned dtype of the grouped will *always* include *all* of the categories
    that were grouped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '### NA group handling'
  prefs: []
  type: TYPE_NORMAL
- en: By `NA`, we are referring to any `NA` values, including [`NA`](../reference/api/pandas.NA.html#pandas.NA
    "pandas.NA"), `NaN`, `NaT`, and `None`. If there are any `NA` values in the grouping
    key, by default these will be excluded. In other words, any “`NA` group” will
    be dropped. You can include NA groups by specifying `dropna=False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Grouping with ordered factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Categorical variables represented as instances of pandas’s `Categorical` class
    can be used as group keys. If so, the order of the levels will be preserved. When
    `observed=False` and `sort=False`, any unobserved categories will be at the end
    of the result in order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '### Grouping with a grouper specification'
  prefs: []
  type: TYPE_NORMAL
- en: You may need to specify a bit more data to properly group. You can use the `pd.Grouper`
    to provide this local control.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Groupby a specific column with the desired frequency. This is like resampling.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: When `freq` is specified, the object returned by `pd.Grouper` will be an instance
    of `pandas.api.typing.TimeGrouper`. When there is a column and index with the
    same name, you can use `key` to group by the column and `level` to group by the
    index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Taking the first rows of each group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like for a DataFrame or Series you can call head and tail on a groupby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: This shows the first or last n rows from each group.
  prefs: []
  type: TYPE_NORMAL
- en: '### Taking the nth row of each group'
  prefs: []
  type: TYPE_NORMAL
- en: To select the nth item from each group, use [`DataFrameGroupBy.nth()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.nth.html#pandas.core.groupby.DataFrameGroupBy.nth
    "pandas.core.groupby.DataFrameGroupBy.nth") or [`SeriesGroupBy.nth()`](../reference/api/pandas.core.groupby.SeriesGroupBy.nth.html#pandas.core.groupby.SeriesGroupBy.nth
    "pandas.core.groupby.SeriesGroupBy.nth"). Arguments supplied can be any integer,
    lists of integers, slices, or lists of slices; see below for examples. When the
    nth element of a group does not exist an error is *not* raised; instead no corresponding
    rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: In general this operation acts as a filtration. In certain cases it will also
    return one row per group, making it also a reduction. However because in general
    it can return zero or multiple rows per group, pandas treats it as a filtration
    in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: If the nth element of a group does not exist, then no corresponding row is included
    in the result. In particular, if the specified `n` is larger than any group, the
    result will be an empty DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to select the nth not-null item, use the `dropna` kwarg. For a
    DataFrame this should be either `''any''` or `''all''` just like you would pass
    to dropna:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: You can also select multiple rows from each group by specifying multiple nth
    values as a list of ints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: You may also use slices or lists of slices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Enumerate group items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see the order in which each row appears within its group, use the `cumcount`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '### Enumerate groups'
  prefs: []
  type: TYPE_NORMAL
- en: To see the ordering of the groups (as opposed to the order of rows within a
    group given by `cumcount`) you can use [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup").
  prefs: []
  type: TYPE_NORMAL
- en: Note that the numbers given to the groups match the order in which the groups
    would be seen when iterating over the groupby object, not the order they are first
    observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Plotting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groupby also works with some plotting methods. In this case, suppose we suspect
    that the values in column 1 are 3 times higher on average in group “B”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily visualize this with a boxplot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '![../_images/groupby_boxplot.png](../Images/a66f2e7e2f4e8b2ceab43cacec7614f1.png)'
  prefs: []
  type: TYPE_IMG
- en: The result of calling `boxplot` is a dictionary whose keys are the values of
    our grouping column `g` (“A” and “B”). The values of the resulting dictionary
    can be controlled by the `return_type` keyword of `boxplot`. See the [visualization
    documentation](visualization.html#visualization-box) for more.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For historical reasons, `df.groupby("g").boxplot()` is not equivalent to `df.boxplot(by="g")`.
    See [here](visualization.html#visualization-box-return) for an explanation.
  prefs: []
  type: TYPE_NORMAL
- en: '### Piping function calls'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the functionality provided by `DataFrame` and `Series`, functions
    that take `GroupBy` objects can be chained together using a `pipe` method to allow
    for a cleaner, more readable syntax. To read about `.pipe` in general terms, see
    [here](basics.html#basics-pipe).
  prefs: []
  type: TYPE_NORMAL
- en: Combining `.groupby` and `.pipe` is often useful when you need to reuse GroupBy
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, imagine having a DataFrame with columns for stores, products,
    revenue and quantity sold. We’d like to do a groupwise calculation of *prices*
    (i.e. revenue/quantity) per store and per product. We could do this in a multi-step
    operation, but expressing it in terms of piping can make the code more readable.
    First we set the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: We now find the prices per store/product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Piping can also be expressive when you want to deliver a grouped object to
    some arbitrary function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Here `mean` takes a GroupBy object and finds the mean of the Revenue and Quantity
    columns respectively for each Store-Product combination. The `mean` function can
    be any function that takes in a GroupBy object; the `.pipe` will pass the GroupBy
    object as a parameter into the function you specify.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Multi-column factorization'
  prefs: []
  type: TYPE_NORMAL
- en: By using [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup"), we can extract information about
    the groups in a way similar to [`factorize()`](../reference/api/pandas.factorize.html#pandas.factorize
    "pandas.factorize") (as described further in the [reshaping API](reshaping.html#reshaping-factorize))
    but which applies naturally to multiple columns of mixed type and different sources.
    This can be useful as an intermediate categorical-like step in processing, when
    the relationships between the group rows are more important than their content,
    or as input to an algorithm which only accepts the integer encoding. (For more
    information about support in pandas for full categorical data, see the [Categorical
    introduction](categorical.html#categorical) and the [API documentation](../reference/arrays.html#api-arrays-categorical).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Groupby by indexer to ‘resample’ data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resampling produces new hypothetical samples (resamples) from already existing
    observed data or from a model that generates data. These new samples are similar
    to the pre-existing samples.
  prefs: []
  type: TYPE_NORMAL
- en: In order for resample to work on indices that are non-datetimelike, the following
    procedure can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, **df.index // 5** returns an integer array which
    is used to determine what gets selected for the groupby operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The example below shows how we can downsample by consolidation of samples into
    fewer ones. Here by using **df.index // 5**, we are aggregating the samples in
    bins. By applying **std()** function, we aggregate the information contained in
    many samples into a small subset of values which is their standard deviation thereby
    reducing the number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Returning a Series to propagate names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Group DataFrame columns, compute a set of metrics and return a named Series.
    The Series name is used as the name for the column index. This is especially useful
    in conjunction with reshaping operations such as stacking, in which the column
    index name will be used as the name of the inserted column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '### Multi-column factorization'
  prefs: []
  type: TYPE_NORMAL
- en: By using [`DataFrameGroupBy.ngroup()`](../reference/api/pandas.core.groupby.DataFrameGroupBy.ngroup.html#pandas.core.groupby.DataFrameGroupBy.ngroup
    "pandas.core.groupby.DataFrameGroupBy.ngroup"), we can extract information about
    the groups in a way similar to [`factorize()`](../reference/api/pandas.factorize.html#pandas.factorize
    "pandas.factorize") (as described further in the [reshaping API](reshaping.html#reshaping-factorize))
    but which applies naturally to multiple columns of mixed type and different sources.
    This can be useful as an intermediate categorical-like step in processing, when
    the relationships between the group rows are more important than their content,
    or as input to an algorithm which only accepts the integer encoding. (For more
    information about support in pandas for full categorical data, see the [Categorical
    introduction](categorical.html#categorical) and the [API documentation](../reference/arrays.html#api-arrays-categorical).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Groupby by indexer to ‘resample’ data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resampling produces new hypothetical samples (resamples) from already existing
    observed data or from a model that generates data. These new samples are similar
    to the pre-existing samples.
  prefs: []
  type: TYPE_NORMAL
- en: In order for resample to work on indices that are non-datetimelike, the following
    procedure can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, **df.index // 5** returns an integer array which
    is used to determine what gets selected for the groupby operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The example below shows how we can downsample by consolidation of samples into
    fewer ones. Here by using **df.index // 5**, we are aggregating the samples in
    bins. By applying **std()** function, we aggregate the information contained in
    many samples into a small subset of values which is their standard deviation thereby
    reducing the number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Returning a Series to propagate names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Group DataFrame columns, compute a set of metrics and return a named Series.
    The Series name is used as the name for the column index. This is especially useful
    in conjunction with reshaping operations such as stacking, in which the column
    index name will be used as the name of the inserted column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
